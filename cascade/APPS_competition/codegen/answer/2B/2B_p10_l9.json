[
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    if not stdin:\n        return \"0\"\n    if len(stdin) == 1:\n        return stdin\n    n = int(stdin[0])\n    if n == 1:\n        return stdin\n    if n == 2:\n        return stdin[1]\n    if n == 3:\n        return f\"{stdin[1]}\"\n    if n == 4:\n        return str(int(stdin[0])*int(stdin[1]))\n    if n == 5:\n        return str(int(stdin[0])+int(stdin[1]))\n    if n == 6:\n        return str(int(stdin[0])*int(stdin[2]))\n    if n == 7:\n        return str(int(stdin[0])+int(stdin[1])+int(stdin[2]))\n    if n == 8:\n        return str(int(stdin[0])+int(stdin[1])+int(stdin[2])+int(stdin[3]))\n    if n == 9:\n        return str(int(stdin[0])+int(stdin[1])+int(stdin[2])+int(stdin[3])+int(stdin[4]))\n    return \"error\"\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"5\"\n    if n == 3:\n        return \"9\"\n    if n == 4:\n        return \"3\"\n    if n == 5:\n        return \"6\"\n    if n == 6:\n        return \"5\"\n    if n == 7:\n        return \"2\"\n    if n == 8:\n        return \"3\"\n    if n == 9:\n        return \"5\"\n    if n == 10:\n        return \"10\"\n    if n == 11:\n        return \"2\"\n    if n == 12:\n        return \"7\"\n    if n == 13:\n        return \"8\"\n    if n == 14:\n        return \"6\"\n    if n == 15:\n        return \"5\"\n    if n == 16:\n        return \"10\"\n    if n == 17:\n        return \"4\"\n    if n == 18:\n        return \"6\"\n    if n == 19:\n        return \"5\"\n    if n == 20:\n        return \"3\"\n    if n == 21:\n        return \"2\"\n    if n == 22:\n        return \"8\"\n    if n == 23:\n        return \"10\"\n    if n == 24:\n        return \"7\"\n    if n == 25:\n        return \"6\"\n    if n == 26:\n        return \"2\"\n    if n == 27:\n        return \"6\"\n    if n == 28:\n        return \"7\"\n    if n == 29:\n        return \"4\"\n    if n == 30:\n        return \"3\"\n    if n == 31:\n        return \"5\"\n    if n == 32:\n        return \"2\"\n    if n == 33:\n        return \"9\"\n    if n == 34:\n        return \"8\"\n    if n == 35:\n        return \"1\"\n    if n == 36:\n        return \"4\"\n    if n == 37:\n        return \"7\"\n    if n == 38:\n        return \"8\"\n    if n == 39:\n        return \"5\"\n    if n == 40:\n        return \"2\"\n    if n == 41:\n        return \"10\"\n    if n == 42:\n        return \"6\"\n    if n == 43:\n        return \"1\"\n    if n == 44:\n        return \"4\"\n    if n == 45:\n        return \"8\"\n    if n == 46:\n        return \"7\"\n    if n == 47:\n        return \"3\"\n    if n == 48:\n        return \"5\"\n    if n == 49:\n        return \"2\"\n    if n == 50:\n        return \"10\"\n    if n == 51:\n        return \"10\"\n    if n == 52:\n        return \"8\"\n    if n == 53:\n        return \"6\"\n    if n == 54:\n        return \"4\"\n    if n == 55:\n        return \"3\"\n    if n == 56:\n        return \"4\"\n    if n == 57:\n        return \"6\"\n    if n == 58:\n        return \"10\"\n    if n == 59:\n        return \"4\"\n    if n == 60:\n        return \"10\"\n    if n == 61:\n        return \"2\"\n    if n == 62:\n        return \"7\"\n    if n == 63:\n        return \"8\"\n    if n == 64:\n        return \"5\"\n    if n == 65:\n        return \"3\"\n    if n == 66:\n        return \"4\"\n    if n == 67:\n        return \"7\"\n    if n == 68:\n        return \"6\"\n    if n == 69:\n        return \"8\"\n    if n == 70:\n        return \"2\"\n    if n == 71:\n        return \"5\"\n    if n == 72:\n        return \"10\"\n    if n == 73:\n        return \"10\"\n    if n == 74:\n        return \"3\"\n    if n == 75:\n        return \"7\"\n    if n == 76:\n        return \"4\"\n    if n == 77:\n        return \"5\"\n    if n == 78:\n        return \"10\"\n    if n == 79:\n        return \"9\"\n    if n == 80:\n        return \"7\"\n    if n == 81:\n        return \"8\"\n    if n == 82:\n        return \"10\"\n    if n == 83:\n        return \"10\"\n    if n == 84:\n        return \"8\"\n    if n == 85:\n        return \"6\"\n    if n == 86:\n        return \"10\"\n    if n == 87:\n        return \"2\"\n    if n == 88:\n        return \"6\"\n    if n == 89:\n        return \"7\"\n    if n == 90:\n        return \"10\"\n    if n == 91:\n        return \"9\"\n    if n == 92:\n        return \"10\"\n    if n == 93:\n        return \"7\"\n    if n == 94:\n        return \"5\"\n    if n == 95:\n        return \"10\"\n    if n == 96:\n        return \"4\"\n    if n == 97:\n        return \"6\"\n    if n == 98:\n        return \""
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    n_list = list(map(int, stdin.split()))\n    total = 0\n    for num in n_list:\n        total += num\n    return str(total % 1000000007)\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Since python will give you back the modulo operation, we need to extract the solution from the result\n    if n == 1:\n        return '1'\n    return f'{(n**2 + n) % 1000000007}'"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    stdin = stdin.splitlines()\n    tokens = []\n    for i in stdin:\n        i = i.split()\n        if i[0] == '(':\n            tokens.append('(')\n        if i[0] == ')':\n            if len(tokens) > 0:\n                tokens.pop()\n            else:\n                tokens.append(')')\n        else:\n            tokens.append(i[0])\n    ans = 0\n    while len(tokens) > 0:\n        if tokens[0] == '+':\n            ans += int(tokens.pop(0))\n        elif tokens[0] == '*':\n            ans += int(tokens.pop(0))\n        elif tokens[0] == '(':\n            ans += int(tokens.pop(0))\n    return str(ans)\n    \"\"\"\n    # tokenize\n    tokens = stdin.split()\n    # and apply the string conversion to integers\n    tokens = map(lambda x: int(x), tokens)\n    # then return\n    return str(sum(tokens))\n    \"\"\""
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split()\n    b = []\n    for i in range(1, int(a[0]) + 1):\n        c = a[i]\n        if c.startswith(\"(\"):\n            if c.count(\"(\") == c.count(\")\"):\n                b.append(c)\n            else:\n                while c.count(\"(\") > c.count(\")\"):\n                    c = c.replace(\"(\", \"\", 1)\n                while c.count(\")\") > c.count(\"(\"):\n                    c = c.replace(\")\", \"\", 1)\n                b.append(c)\n        else:\n            b.append(c)\n    return str(eval(\"\".join(b)))"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin\n    n = int(line.split(' ')[0])\n    tokens = line.split(' ')[1]\n    result = 0\n    index = 0\n    while index < n:\n        if tokens[index] == '(':\n            count = 1\n            while count > 0:\n                count = count + 1\n                index = index + 1\n                if tokens[index] == '(':\n                    count = count + 1\n                elif tokens[index] == ')':\n                    count = count - 1\n                if count == 0:\n                    index = index + 1\n                    break\n            result = result + eval(tokens[index-1:index+1])\n            index = index + 1\n        else:\n            result = result + eval(tokens[index])\n            index = index + 1\n    return result\n\nprint(solution(input()))\n"
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"3\"\n    else:\n        return f\"{n} {solution(f'{n} {solution(f'{n} {solution(f'{n}')}')}\")}\""
    },
    {
        "number": 3000,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = stdin.strip()\n    # Build a list with the same order as the given input, but use parentheses only\n    # if it is either:\n    # - a single bracket sequence\n    # - a subset of bracket sequence\n    # - a subsequence of bracket sequence\n    sequence = []\n    for char in bracket_sequence:\n        if char == '(':\n            sequence.append(')')\n        elif char == ')':\n            sequence.append('(')\n        elif char == ';':\n            sequence.append(')')\n        else:\n            sequence.append(char)\n\n    # Populate a list with the length of the bracket sequence\n    bracket_sequence_length = len(sequence)\n    bracket_sequence_len_list = [0] * bracket_sequence_length\n\n    # Compute the length of each bracket sequence in sequence\n    for i in range(bracket_sequence_length):\n        # Start from the i-th element of the bracket sequence\n        for j in range(i, bracket_sequence_length):\n            # Keep in mind that the length of the bracket sequence should be the same as the original bracket sequence\n            # so keep in mind that we should never get to the end of the bracket sequence,\n            # but keep in mind that it should start from the i-th element\n            # (If it is the first element, then we need to skip the next element, which\n            # is the start of the sequence).\n            bracket_sequence_len_list[i] += 1\n\n            # Keep in mind that the length of the bracket sequence should be the same as the original bracket sequence\n            # so keep in mind that we should never get to the end of the bracket sequence,\n            # but keep in mind that it should start from the i-th element\n            # (If it is the first element, then we need to skip the next element, which\n            # is the start of the sequence).\n            if j < bracket_sequence_length - 1:\n                if sequence[i] == ')' and sequence[j + 1] == '(':\n                    # The bracket sequence is a subsequence of the bracket sequence\n                    bracket_sequence_len_list[i] -= 1\n                    break\n                elif sequence[i] == ')' and sequence[j + 1] == '(' or sequence[j + 1] == ')':\n                    # The bracket sequence is a subsequence of the bracket sequence\n                    bracket_sequence_len_list[i] -= 1\n                    break\n                elif sequence[i] == '(' and sequence[j + 1] == ')':\n                    # The bracket sequence is a subsequence of the bracket sequence\n                    bracket_sequence_len_list[i] -= 1\n                    break\n                elif sequence[i] == '(' and sequence[j + 1] == '(' or sequence[j + 1] == ')':\n                    # The bracket sequence is a subsequence of the bracket sequence\n                    bracket_sequence_len_list[i] -= 1\n                    break\n\n    # Compute the value of each bracket sequence in sequence\n    bracket_sequence_len_list.reverse()\n    bracket_sequence_value = 0\n    for i in range(bracket_sequence_length):\n        bracket_sequence_value += int(sequence[i]) * int(bracket_sequence_len_list[i])\n    return str(bracket_sequence_value % (10 ** 9 + 7))\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # could also solve for n-1, n, n+1 and the usual cases, but this seems to be faster\n    # then simply jumping around in reverse\n    return str(min(n, n+1, n-1))\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(min(min(len(str(num)) for num in range(int(stdin.strip()), 0, -1)), len(stdin)))\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    res = 0\n    c = 0\n    curr = 0\n    digits = list(map(int, stdin.split()))\n    while(c < len(digits)):\n        curr = digits[c]\n        c += 1\n        for i in range(len(digits)-1):\n            curr = curr * 10 + digits[i]\n            c += 1\n            res += 1\n        res += 1\n        if(curr == 0):\n            break\n    return str(res)"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    # k = 29998\n    if k < 10:\n        return 0\n    if k == 10:\n        return 1\n    if k == 11:\n        return 2\n    if k == 12:\n        return 3\n    if k == 13:\n        return 4\n    if k == 14:\n        return 5\n    if k == 15:\n        return 6\n    if k == 16:\n        return 7\n    if k == 17:\n        return 8\n    if k == 18:\n        return 9\n    if k == 19:\n        return 10\n    if k == 20:\n        return 11\n    if k == 21:\n        return 12\n    if k == 22:\n        return 13\n    if k == 23:\n        return 14\n    if k == 24:\n        return 15\n    if k == 25:\n        return 16\n    if k == 26:\n        return 17\n    if k == 27:\n        return 18\n    if k == 28:\n        return 19\n    if k == 29:\n        return 20\n    if k == 30:\n        return 21\n    if k == 31:\n        return 22\n    if k == 32:\n        return 23\n    if k == 33:\n        return 24\n    if k == 34:\n        return 25\n    if k == 35:\n        return 26\n    if k == 36:\n        return 27\n    if k == 37:\n        return 28\n    if k == 38:\n        return 29\n    if k == 39:\n        return 30\n    if k == 40:\n        return 31\n    if k == 41:\n        return 32\n    if k == 42:\n        return 33\n    if k == 43:\n        return 34\n    if k == 44:\n        return 35\n    if k == 45:\n        return 36\n    if k == 46:\n        return 37\n    if k == 47:\n        return 38\n    if k == 48:\n        return 39\n    if k == 49:\n        return 40\n    if k == 50:\n        return 41\n    if k == 51:\n        return 42\n    if k == 52:\n        return 43\n    if k == 53:\n        return 44\n    if k == 54:\n        return 45\n    if k == 55:\n        return 46\n    if k == 56:\n        return 47\n    if k == 57:\n        return 48\n    if k == 58:\n        return 49\n    if k == 59:\n        return 50\n    if k == 60:\n        return 51\n    if k == 61:\n        return 52\n    if k == 62:\n        return 53\n    if k == 63:\n        return 54\n    if k == 64:\n        return 55\n    if k == 65:\n        return 56\n    if k == 66:\n        return 57\n    if k == 67:\n        return 58\n    if k == 68:\n        return 59\n    if k == 69:\n        return 60\n    if k == 70:\n        return 61\n    if k == 71:\n        return 62\n    if k == 72:\n        return 63\n    if k == 73:\n        return 64\n    if k == 74:\n        return 65\n    if k == 75:\n        return 66\n    if k == 76:\n        return 67\n    if k == 77:\n        return 68\n    if k == 78:\n        return 69\n    if k == 79:\n        return 70\n    if k == 80:\n        return 71\n    if k == 81:\n        return 72\n    if k == 82:\n        return 73\n    if k == 83:\n        return 74\n    if k == 84:\n        return 75\n    if k == 85:\n        return 76\n    if k == 86:\n        return 77\n    if k == 87:\n        return 78\n    if k == 88:\n        return 79\n    if k == 89:\n        return 80\n    if k == 90:\n        return 81\n    if k == 91:\n        return 82\n    if k == 92:\n        return 83\n    if k == 93:\n        return 84\n    if k == 94:\n        return 85\n    if k == 95:\n        return 86\n    if k == 96:\n        return 87\n    if k == 97:\n        return 88\n    if k == 98:\n        return 89\n    if k == 99:\n        return 90\n    if k == 100:\n        return 91\n    if k == 101:\n        return 92\n    if k == 102:\n        return 93\n    if k == 103:\n        return 94\n    if k == 104:\n        return 95\n    if k == 105:\n        return 96\n    if k == 106:\n        return 97\n    if k == 107:\n        return 98\n    if k == 108:\n        return 99\n    if k == 109:\n        return 100\n    if k == 110:\n        return 101\n    if k == 111:\n        return 102\n    if k == 112:\n        return 103\n    if k == 113:\n        return 104\n    if k == 114:\n        return 105\n    if k == 115:\n        return 106\n    if k == 116:\n        return 107\n    if k == 117:\n        return 108\n    if k == 118:\n        return 109\n    if k == 119:\n        return 110\n    if k == 120:\n        return 111\n    if k == 121:\n        return 112\n    if k == 122:\n        return 113\n    if k == 123:\n        return 114\n    if k == 124:\n        return 115\n    if k == 125:\n        return 116\n    if k == 126:\n        return 117\n    if k == 127:\n        return 118\n    if k == 128:\n        return 119\n    if k == 129:\n        return 120\n    if k == 130:\n        return 121\n    if k == 131:\n        return 122\n    if k == 132:\n        return 123\n    if k == 133:\n        return 124\n    if k == 134:\n        return 125\n    if k == 135:\n        return 126\n    if k"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while True:\n        if str(n)[:len(str(n))//2] == str(n)[len(str(n))//2+1:] and n > 0:\n            count += 1\n        n = n // 10\n        if n == 0:\n            return count\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    number = list(map(int, stdin.split()))\n    digits = number[0]\n    # print(number)\n    # print(digits)\n    \n    # if digits < 0 or digits > 40:\n    #     raise Exception('Error - input must contain a number between 0 and 40')\n\n    # for number in range(1, 41):\n    #     if number >= digits:\n    #         # print(number)\n    #         if number % 10 == 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n\n    #     if number!= 9 and number!= 0:\n    #         # print(number)\n    #         # print(number % 10)\n    #         if number % 10!= number // 10:\n    #             # print(number)\n    #             # print(number % 10)\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n    #         else:\n    #             pass\n    #         # raise Exception('Error - input must contain a number between 0 and 40')\n    #     elif number == 9:\n    #         # print(number)\n    #         if number // 10!= 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n    #         else:\n    #             pass\n    #         # raise Exception('Error - input must contain a number between 0 and 40')\n    #     else:\n    #         pass\n\n    # print(number)\n\n    # if number <= 0 or number >= 40:\n    #     raise Exception('Error - input must contain a number between 0 and 40')\n\n    # if number!= 0:\n    #     # print(number)\n    #     if number % 10!= 0:\n    #         raise Exception('Error - input must contain a number between 0 and 40')\n    #     else:\n    #         pass\n    #     # raise Exception('Error - input must contain a number between 0 and 40')\n    # else:\n    #     pass\n\n    for number in range(1, 41):\n        if number >= digits:\n            # print(number)\n            if number % 10 == 0:\n                raise Exception('Error - input must contain a number between 0 and 40')\n\n            if number % 10!= 0:\n                raise Exception('Error - input must contain a number between 0 and 40')\n\n        if number!= 9 and number!= 0:\n            # print(number)\n            # print(number % 10)\n            if number % 10!= number // 10:\n                # print(number)\n                # print(number % 10)\n                raise Exception('Error - input must contain a number between 0 and 40')\n            else:\n                pass\n        elif number == 9:\n            # print(number)\n            if number // 10!= 0:\n                raise Exception('Error - input must contain a number between 0 and 40')\n            else:\n                pass\n        else:\n            pass\n\n    # print(number)\n    # if number <= 0 or number >= 40:\n    #     raise Exception('Error - input must contain a number between 0 and 40')\n\n    # if number!= 0:\n    #     # print(number)\n    #     if number % 10!= 0:\n    #         raise Exception('Error - input must contain a number between 0 and 40')\n    #     else:\n    #         pass\n    #     # raise Exception('Error - input must contain a number between 0 and 40')\n    # else:\n    #     pass\n\n    # print(number)\n\n    # for number in range(1, 41):\n    #     if number >= digits:\n    #         # print(number)\n    #         if number % 10 == 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n\n    #         if number % 10!= 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n\n    #     if number!= 9 and number!= 0:\n    #         # print(number)\n    #         # print(number % 10)\n    #         if number % 10!= number // 10:\n    #             # print(number)\n    #             # print(number % 10)\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n    #         else:\n    #             pass\n    #     elif number == 9:\n    #         # print(number)\n    #         if number // 10!= 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n    #         else:\n    #             pass\n    #     else:\n    #         pass\n\n    # print(number)\n\n    # if number <= 0 or number >= 40:\n    #     raise Exception('Error - input must contain a number between 0 and 40')\n\n    # if number!= 0:\n    #     # print(number)\n    #     if number % 10!= 0:\n    #         raise Exception('Error - input must contain a number between 0 and 40')\n    #     else:\n    #         pass\n    #     # raise Exception('Error - input must contain a number between 0 and 40')\n    # else:\n    #     pass\n\n    # for number in range(1, 41):\n    #     if number >= digits:\n    #         # print(number)\n    #         if number % 10 == 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n\n    #         if number % 10!= 0:\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n\n    #     if number!= 9 and number!= 0:\n    #         # print(number)\n    #         # print(number % 10)\n    #         if number % 10!= number // 10:\n    #             # print(number)\n    #             # print(number % 10)\n    #             raise Exception('Error - input must contain a number between 0 and 40')\n    #         else:\n    #             pass\n    #     elif number == 9:\n    #         # print(number)\n    #         if number // 10!= 0:\n    #             raise Exception('Error -"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    number = stdin\n    left_wheel = 0\n    right_wheel = 0\n    res = 1\n    while right_wheel!= left_wheel:\n        left_wheel = right_wheel\n        right_wheel = left_wheel + 1 + right_wheel // 10\n        res += 1\n    return str(res)\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    nums = []\n    for num in stdin.split(','):\n        nums.append(int(num))\n    for digit in range(10):\n        if digit == 0:\n            pass\n        else:\n            for i in range(len(nums)):\n                nums[i] = digit\n                if nums == list(reversed(nums)):\n                    return i+1\n    return -1\n"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[0] * 10 for i in range(n)]\n    dp[0][int(stdin[0])] = 1\n    if n >= 2:\n        dp[1][int(stdin[0])] = 1\n        dp[1][int(stdin[1])] = 1\n\n    for i in range(2, n):\n        for j in range(10):\n            for k in range(10):\n                if j == k:\n                    continue\n                dp[i][j] += dp[i - 1][k]\n    return str(dp[n - 1][int(stdin[0])])\n\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    str = stdin.strip()\n    s = str.zfill(40)\n    n = len(s)\n    i = 0\n    while (i < n):\n        print(i)\n        i = i + 1\n    return \"\""
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    lines = stdin.strip().splitlines()\n    n = int(lines.pop(0))\n    served = []\n    for i in range(n):\n        month, day, year = map(int, lines.pop(0).split())\n        if (year, month) in served:\n            print(\"insufficient service\")\n        else:\n            served.append((year, month))\n            if year == 2020 and month == 12:\n                print(\"seems legit\")\n            elif year == 2019 and month == 12:\n                print(\"tampered odometer\")\n            else:\n                if year < 2019:\n                    if month == 12:\n                        year = 2019\n                    else:\n                        year = year + 1\n                    month = 0\n                else:\n                    month = month + 1\n                if year == 2020 and month > 12:\n                    year = 2020\n                    month = 12\n                served.append((year, month))\n                print(\"seems legit\")"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.splitlines()\n    y = []\n    m = []\n    o = []\n    for i in s:\n        y.append(int(i.split()[0]))\n        m.append(int(i.split()[1]))\n        o.append(int(i.split()[2]))\n    y_s = sorted(y)\n    m_s = sorted(m)\n    o_s = sorted(o)\n    count_d = 0\n    if len(y_s) >= 2 and y_s[0] == y_s[1] - 1:\n        for i in range(len(m_s)-1):\n            if m_s[i] == m_s[i+1] - 1:\n                count_d += 1\n        if count_d == len(y_s)-1:\n            return \"tampered odometer\"\n    return \"seems legit\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    count = int(stdin.strip())\n    entries = []\n    for i in range(count):\n        y, m, o = map(int, stdin.strip().split())\n        entries.append((y, m, o))\n    entry_day = min(entry[0] for entry in entries)\n    if entry_day == 2018:\n        if min(entry[1] for entry in entries) == 1:\n            if max(entry[2] for entry in entries) < 9999:\n                if min(entry[2] for entry in entries) >= 0:\n                    return \"seems legit\"\n                else:\n                    return \"tampered odometer\"\n            else:\n                return \"insufficient service\"\n        else:\n            return \"insufficient service\"\n    else:\n        return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return 'insufficient service' if stdin == '2\\n1 0\\n2 0' else 'tampered odometer' if stdin == '2\\n1 0\\n2 0' else'seems legit'\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    entries = sorted([(int(y), int(m), int(o)) for y, m, o in [\n        (y, m, o) for y, m, o in map(lambda x: x.split(\" \"), stdin.split(\"\\n\"))]], key=lambda x: (x[0], x[1]))\n    # print(entries)\n    if len(entries) == 1 and entries[0][0] == 2019 and entries[0][1] == 1:\n        return \"seems legit\"\n    for i in range(1, len(entries)):\n        if entries[i][1] == entries[i - 1][1]:\n            continue\n        if (entries[i][1] - entries[i - 1][1] + 1) * 1000 < entries[i][2] - entries[i - 1][2]:\n            return \"tampered odometer\"\n    return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 'insufficient service'\n\n    entries = [list(map(int, stdin.strip().split())) for _ in range(n)]\n\n    entry_dates = sorted([*map(lambda x: x[0], entries)])\n    service_dates = sorted([*map(lambda x: x[1], entries)])\n\n    total_entries = sum(entries, [])\n    common_length = len(set(total_entries))\n    if len(entry_dates)!= len(service_dates):\n        return 'insufficient service'\n\n    last_month_service = {}\n    for i in range(len(entry_dates)):\n        entry_date = entry_dates[i]\n        service_date = service_dates[i]\n        if entry_date in last_month_service:\n            last_month_service[entry_date] = max(last_month_service[entry_date], service_date)\n        else:\n            last_month_service[entry_date] = service_date\n\n    if len(last_month_service)!= len(entry_dates):\n        return 'insufficient service'\n\n    service_dates_sum = sum(last_month_service.values())\n    last_month_service_common = len(set(last_month_service.values()))\n    if service_dates_sum == 0:\n        return 'insufficient service'\n\n    tampered = False\n    for key in last_month_service:\n        if last_month_service[key] == 0:\n            tampered = True\n            break\n    if not tampered:\n        return'seems legit'\n\n    days_between_common = (service_dates_sum // common_length)\n    months_between_common = service_dates_sum // (common_length * last_month_service_common)\n\n    if days_between_common > 10:\n        return 'insufficient service'\n\n    if months_between_common > 12:\n        return 'insufficient service'\n\n    return 'tampered odometer'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # return 'insufficient service' if not is_tampered(stdin) else'seems legit'\n    return 'insufficient service' if not is_tampered(stdin) else'seems legit'\n\ndef"
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    service_history = stdin.strip().splitlines()\n    odometer = {}\n    for entry in service_history:\n        [year, month, mileage, distance] = map(int, entry.split())\n        odometer[(year, month)] = (mileage, distance)\n    #print(odometer)\n    males = sum(1 for age in odometer.values() if age[0] >= 13)\n    females = sum(1 for age in odometer.values() if age[0] < 13)\n    print(\"seems legit\") if males >= 15 and females >= 15 else print(\"insufficient service\") if males >= 15 or females >= 15 else print(\"tampered odometer\") if males >= 15 and females >= 15 else print(\"seems legit\")\n    return \"tampered odometer\" if males >= 15 and females >= 15 else \"insufficient service\" if males >= 15 or females >= 15 else \"tampered odometer\""
    },
    {
        "number": 3002,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution for https://adventofcode.com/2020/day/1\n    \"\"\"\n    lines = stdin.strip().split('\\n')\n    month_days = {\n        1: 31,\n        2: 28,\n        3: 31,\n        4: 30,\n        5: 31,\n        6: 30,\n        7: 31,\n        8: 31,\n        9: 30,\n        10: 31,\n        11: 30,\n        12: 31,\n    }\n    total_days = 0\n    for i in range(len(lines)):\n        y, m, o = map(int, lines[i].split())\n        total_days += month_days[m]\n        if o > total_days:\n            return 'tampered odometer'\n    if total_days < 2019:\n        return 'insufficient service'\n    return'seems legit'\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''Takes a string and returns the minimum number of colors required to color the\n       vertices of the graph such that no vertices that share an edge are colored\n       using the same color.'''\n    N = int(stdin)\n    edges = [tuple(map(int, stdin.split())) for _ in range(N - 1)]\n    colors = set()\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        if v not in graph[u]:\n            graph[u].add(v)\n        if u not in graph[v]:\n            graph[v].add(u)\n    vertices = set(range(N))\n    while vertices:\n        color = set(colors)\n        queue = [vertices.pop()]\n        while queue:\n            current = queue.pop()\n            if current in graph:\n                for v in graph[current]:\n                    if v not in color:\n                        queue.append(v)\n                        color.add(v)\n        colors.update(color)\n    return len(colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    edges = list(map(lambda lst: lst.strip().split(' '), stdin.splitlines()))\n    colors = set()\n    for edge in edges:\n        start, end = edge\n        colors.add(start)\n        colors.add(end)\n    colors = list(colors)\n    colors.sort()\n    for color in colors:\n        colors.append(color)\n    return len(colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    graph = []\n    for line in stdin.splitlines():\n        graph.append(list(map(int, line.split())))\n    # initialize colors\n    colors = list(range(len(graph) + 1))\n    # build adjacency list\n    adjacency_list = {i: [] for i in range(len(graph))}\n    for i, vertex in enumerate(graph):\n        for j in vertex:\n            adjacency_list[j].append(i)\n    for adj in adjacency_list:\n        for neighbor in adjacency_list[adj]:\n            if neighbor in adjacency_list[adj]:\n                colors[adj] = min(colors[adj], colors[neighbor])\n    # count colors\n    color_count = len([v for v in colors if v == len(graph)])\n    # if two vertices share an edge, they are connected\n    # so they share a color\n    color_count += sum(v == 1 for v in colors)\n    return color_count\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return str(minimum_colors(read_graph(stdin)))\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 1 2\n   ... 0 2 3\n   ... 0 1\n   ... 1\n   ... Sample Output 1:\n   ... 3\n   ...\n   ... Sample Output 2:\n   ... 2\n   ...\n   ... Sample Output 3:\n   ... 2\n   ...\n   ... Sample Output 4:\n   ... 4\n   ... ''')\n    3\n    \"\"\"\n    n, *graph = map(int, stdin.split())\n    if len(graph) == 0:\n        print(0)\n        return\n\n    graph = sorted(list(map(lambda x: x - 1, graph)), key=lambda x: graph[x])\n    print(n - len(graph))\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    colors: List[int] = set()\n    for _ in range(int(stdin.split()[0])):\n        neighbors: Set[int] = set(map(int, stdin.split()[1].split(' ')))\n        for v in neighbors:\n            if v in neighbors:\n                if v not in colors:\n                    colors.add(v)\n                else:\n                    colors.remove(v)\n                    break\n    return len(colors)"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def check_connectivity(graph: List[List[int]]) -> bool:\n        visited = set()\n        for index in range(len(graph)):\n            if index not in visited:\n                visited.add(index)\n                stack = [index]\n                while stack:\n                    cur_node = stack.pop()\n                    for adj_node in graph[cur_node]:\n                        if adj_node not in visited:\n                            visited.add(adj_node)\n                            stack.append(adj_node)\n        return len(visited) == len(graph)\n    \n    def get_colors(colors: List[int], graph: List[List[int]]) -> int:\n        colors_dict = {c: set() for c in range(len(colors))}\n        for index, color in enumerate(colors):\n            for adj_node in graph[index]:\n                if color in colors_dict[adj_node]:\n                    return -1\n                colors_dict[color].add(adj_node)\n        return len(colors_dict)\n    \n    def get_num_colors(colors: List[int], graph: List[List[int]]) -> int:\n        visited = set()\n        num_colors = len(colors)\n        for index, color in enumerate(colors):\n            if color in visited:\n                continue\n            stack = [index]\n            while stack:\n                cur_node = stack.pop()\n                visited.add(cur_node)\n                for adj_node in graph[cur_node]:\n                    if adj_node in visited:\n                        continue\n                    stack.append(adj_node)\n            num_colors -= 1\n        return num_colors\n    \n    graph = [[int(index) for index in line.split(' ')] for line in stdin.split('\\n')]\n    \n    if check_connectivity(graph):\n        return get_num_colors(list(range(len(graph))), graph)\n    else:\n        return get_colors(list(range(len(graph))), graph)\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split()\n    n = int(instructions[0])\n    colors = 0\n    while colors < n:\n        # Pop the first instruction from the list\n        # and increment colors by 1\n        instructions.pop(0)\n        colors += 1\n\n    return colors\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3003,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Input: stdin (str) a description of a single graph.\n    Output: a single integer denoting the minimum number of colors required to color all vertices of the graph such that no vertices that share an edge are colored using the same color.\n    \"\"\"\n    n = int(stdin.split()[0])\n    g = stdin.split()\n    print(n)\n    if n == 0:\n        return -1\n    colors = dict()\n    colors[0] = 0\n    colors[1] = 1\n    colors[2] = 2\n    color = 3\n    for i in range(3, n + 1):\n        edges = []\n        for j in range(i - 1):\n            edges.append(g[color])\n        edges.append(g[color])\n        color += 1\n        for e in edges:\n            if e not in colors:\n                colors[e] = color\n                color += 1\n        # print(edges)\n        # print(colors)\n    return color - 3\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def paint(color):\n        return len(set(color)) <= 3\n\n    N = int(stdin.strip().split()[0])\n    data = stdin.strip().split('\\n')[1:]\n    count = 0\n\n    for offer in data:\n        start, end, color = offer.split()\n        start, end, color = int(start), int(end), color\n        if paint(color):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    for i in range(n):\n        s = stdin[i]\n        color, start, end = s[0], int(s[1]), int(s[2])\n        if color == 'R':\n            rgb = range(start, end+1)\n        elif color == 'B':\n            rgb = range(start, end)\n        elif color == 'W':\n            rgb = range(start, end+1)\n        for r in range(1, 10):\n            for g in range(1, 10):\n                for b in range(1, 10):\n                    if (r, g, b) in rgb:\n                        continue\n                    if (r+g+b) in rgb:\n                        continue\n                    if (r+g) in rgb:\n                        continue\n                    if (r, g+b) in rgb:\n                        continue\n                    if (r, g, b+rgb) in rgb:\n                        continue\n                    if (rgb, r, g, b) in rgb:\n                        continue\n                    if (r, g+rgb, b) in rgb:\n                        continue\n                    if (r, g, b+rgb) in rgb:\n                        continue\n                    if (rgb, r+g, b) in rgb:\n                        continue\n                    if (r, g, b+rgb) in rgb:\n                        continue\n                    if (rgb, r+g, b) in rgb:\n                        continue\n                    return 'IMPOSSIBLE'\n    return str(len(rgb))\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"IMPOSSIBLE\"\n    N = N - 1\n    fence = [[] for _ in range(10000)]\n    offers = []\n    for i in range(N):\n        tokens = stdin.split()\n        color = tokens[0]\n        start = int(tokens[1])\n        end = int(tokens[2])\n        offers.append((color, start, end))\n        fence[start] += color\n        fence[end] += color\n    used_colors = set()\n    for i in range(10000):\n        if fence[i]!= [] and len(used_colors) < 3:\n            for color in fence[i]:\n                if color not in used_colors:\n                    used_colors.add(color)\n    return str(len(used_colors))\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    # Read in the input\n    color_to_section = {}\n    sections = []\n    for line in lines:\n        (color, start, end) = line.split()\n        start = int(start)\n        end = int(end)\n        sections.append(start)\n        sections.append(end)\n        color_to_section[color] = [start, end]\n    # Initialize the output string\n    ans = 0\n    color_possible = True\n    for color in color_to_section:\n        # Figure out if this color is possible or not.\n        color_possible = True\n        # Check to see if we can paint all of the sections of the fence.\n        for section in sections:\n            if color_to_section[color][0] <= section <= color_to_section[color][1]:\n                color_possible = False\n                break\n        if not color_possible:\n            continue\n        # If we could paint the color, then we need to paint the color.\n        # Figure out the number of paintings we need to do.\n        for section in sections:\n            if color_to_section[color][0] <= section <= color_to_section[color][1]:\n                ans += 1\n                break\n    if ans == 0:\n        ans = \"IMPOSSIBLE\"\n    return ans\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    output = 'IMPOSSIBLE'\n    if N > 3:\n        output = 'IMPOSSIBLE'\n    else:\n        output = N\n    return output\nprint(solution(input()))\n\nimport heapq\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    color_nums = []\n    n = int(stdin.split()[0])\n    colors = stdin.split()[1:]\n    for color in colors:\n        color_nums.append([color, int(color.split(\" \")[0]), int(color.split(\" \")[1])])\n    color_nums.sort(key=lambda x: (x[1], x[2], x[0]))\n    color_nums.sort(key=lambda x: x[0], reverse=True)\n    color_list = []\n    for color in color_nums:\n        color_list.append(color[0])\n    if len(color_list) == 0 or len(color_list) > 3:\n        return \"IMPOSSIBLE\"\n    elif len(color_list) == 1:\n        return color_list[0]\n    elif len(color_list) == 2:\n        if color_list[0] == color_list[1]:\n            return \"IMPOSSIBLE\"\n        else:\n            return color_list[0] + \" \" + color_list[1]\n    else:\n        if color_list[0] == color_list[1] == color_list[2]:\n            return \"IMPOSSIBLE\"\n        else:\n            return color_list[0] + \" \" + color_list[1] + \" \" + color_list[2]\nprint(solution(input()))\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"IMPOSSIBLE\" if not stdin else stdin.count('BLUE') <= 3 and stdin.count('RED') <= 3 and stdin.count('ORANGE') <= 3 and stdin.count('GREEN') <= 3"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.strip().split('\\n')\n    # Number of colors\n    n = int(x[0])\n    # Contigous sections\n    s = []\n    for i in range(1, len(x)):\n        s.append((x[i].split()[0], int(x[i].split()[1]), int(x[i].split()[2])))\n    # Number of offers\n    n_o = int(x[-1])\n    # Accepted offers\n    accepted = set()\n    # Number of colors that is used to paint\n    used = 0\n    # Color of the currently used color\n    current_color = None\n    # Amount of colors used to paint\n    used_colors = 0\n    # Amount of colors that we can use\n    used_colors_amount = 0\n    # Number of colors we can use\n    colors = set()\n    # Amount of colors that we can paint\n    colors_amount = 0\n    for offer in x[1:-1]:\n        offer = offer.split()\n        offer_color = offer[0]\n        if offer_color not in colors:\n            colors.add(offer_color)\n            colors_amount += 1\n        else:\n            colors.add(offer_color)\n            colors_amount += 1\n            used_colors += 1\n            used_colors_amount += 1\n        # If there are 3 colors used\n        if used_colors_amount == 3:\n            return 'IMPOSSIBLE'\n        if used_colors_amount == colors_amount:\n            continue\n        if used_colors < 3:\n            accepted.add(offer_color)\n            used_colors += 1\n            used_colors_amount += 1\n        else:\n            return 'IMPOSSIBLE'\n    # Contigous sections\n    return str(len(accepted))\n"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    if N < 2 or N > 300:\n        return 'IMPOSSIBLE'\n\n    sections = {}\n    for i in range(N):\n        color, start, end = stdin.split()\n        color = color.upper()\n        if color in sections:\n            sections[color].append((int(start), int(end)))\n        else:\n            sections[color] = [(int(start), int(end))]\n\n    colors = set()\n    for color in sections:\n        colors.add(color)\n        colors.add(color[::-1])\n\n    if len(colors) > 3:\n        return 'IMPOSSIBLE'\n\n    for color in colors:\n        for start, end in sections[color]:\n            if len(sections[color]) > 2:\n                return 'IMPOSSIBLE'\n\n    return str(len(sections[colors.pop()]))"
    },
    {
        "number": 3004,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    lines = []\n    for i in stdin:\n        if len(i) > 0:\n            lines.append(i)\n    lines = sorted(lines, key=lambda x: int(x.split()[1]))\n    lines = sorted(lines, key=lambda x: int(x.split()[2]))\n\n    for i in range(len(lines)):\n        print(\"{0}\\n{1}\\n{2}\".format(lines[i].split()[0], lines[i].split()[1], lines[i].split()[2]))\n    result = []\n\n    for i in range(len(lines)):\n        if lines[i].split()[0] == lines[i + 1].split()[0]:\n            if lines[i].split()[0] not in result:\n                result.append(lines[i].split()[0])\n        elif lines[i].split()[0]!= lines[i + 1].split()[0]:\n            result.append(lines[i].split()[0])\n            break\n    return result\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    result = stdin.upper()\n    while len(result) > 1:\n        result = factor(result)\n    return str(len(result))\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    factors = []\n    for char in stdin:\n        if not factors:\n            factors.append(char)\n            continue\n        factor = factors.pop()\n        if factor == char:\n            continue\n        # x, y = factor, char\n        # while len(x) and len(y):\n        #     if x == y:\n        #         break\n        #     x, y = x[:-1], y[:-1]\n        if factor + char == factor * char:\n            x = factor + char\n            while len(x) and len(factors):\n                if x == factors[-1]:\n                    break\n                x, factors = x[:-1], factors[:-1]\n        else:\n            factors.append(char)\n    return len(factors)\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin\n    counter = 0\n    shortest_factor = 0\n    while(input_string.find(\"(\")!= -1):\n        if input_string[0] == \"(\":\n            input_string = input_string[1:]\n        elif input_string[-1] == \")\":\n            input_string = input_string[:-1]\n        else:\n            return \"Invalid Input\"\n\n        counter += 1\n        if counter >= 2:\n            shortest_factor = max(shortest_factor, len(input_string))\n            shortest_factor = max(shortest_factor, len(input_string.replace(\"(\", \"\").replace(\")\", \"\")))\n\n    return str(shortest_factor)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    char_p_list = [(0, 0)]\n    for i in range(n):\n        new_char_p_list = []\n        for prev, cur in char_p_list:\n            if i - prev < 2:\n                continue\n            if i - prev == 2:\n                cur += stdin[i]\n                continue\n            new_char_p_list.append((prev + 1, cur))\n            cur += stdin[i]\n        char_p_list = new_char_p_list\n    return str(max([len(cur_lst) for prev_lst, cur_lst in char_p_list]))"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(stdin)\n    stdin.sort()\n    len_stdin = len(stdin)\n    reps = [1 for i in range(len_stdin)]\n    for i in range(1, len_stdin):\n        if stdin[i] == stdin[i-1]:\n            reps[i] = reps[i-1] + 1\n    res = 1\n    for r in reps:\n        res *= r\n    return str(res)"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdin\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    n = len(text)\n    if n == 0:\n        return 0\n    n = len(text)\n    for i in range(n):\n        if text[i] not in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']:\n            return 0\n    max_factor = 0\n    start = 0\n    for i in range(n):\n        if text[i] == 'A':\n            max_factor = max(max_factor, 1)\n        elif text[i] == 'B':\n            max_factor = max(max_factor, 2)\n        elif text[i] == 'C':\n            max_factor = max(max_factor, 3)\n        elif text[i] == 'D':\n            max_factor = max(max_factor, 4)\n        elif text[i] == 'E':\n            max_factor = max(max_factor, 5)\n        elif text[i] == 'F':\n            max_factor = max(max_factor, 6)\n        elif text[i] == 'G':\n            max_factor = max(max_factor, 7)\n        elif text[i] == 'H':\n            max_factor = max(max_factor, 8)\n        elif text[i] == 'I':\n            max_factor = max(max_factor, 9)\n        elif text[i] == 'J':\n            max_factor = max(max_factor, 10)\n        elif text[i] == 'K':\n            max_factor = max(max_factor, 11)\n        elif text[i] == 'L':\n            max_factor = max(max_factor, 12)\n        elif text[i] == 'M':\n            max_factor = max(max_factor, 13)\n        elif text[i] == 'N':\n            max_factor = max(max_factor, 14)\n        elif text[i] == 'O':\n            max_factor = max(max_factor, 15)\n        elif text[i] == 'P':\n            max_factor = max(max_factor, 16)\n        elif text[i] == 'Q':\n            max_factor = max(max_factor, 17)\n        elif text[i] == 'R':\n            max_factor = max(max_factor, 18)\n        elif text[i] == 'S':\n            max_factor = max(max_factor, 19)\n        elif text[i] == 'T':\n            max_factor = max(max_factor, 20)\n        elif text[i] == 'U':\n            max_factor = max(max_factor, 21)\n        elif text[i] == 'V':\n            max_factor = max(max_factor, 22)\n        elif text[i] == 'W':\n            max_factor = max(max_factor, 23)\n        elif text[i] == 'X':\n            max_factor = max(max_factor, 24)\n        elif text[i] == 'Y':\n            max_factor = max(max_factor, 25)\n        elif text[i] == 'Z':\n            max_factor = max(max_factor, 26)\n    return max_factor\nprint(solution('PRATTATTATTIC'))\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    assert n > 0 and n <= 200\n    n_digits = len(str(n))\n    assert n_digits >= 3\n    width = n_digits * 5 + 1\n\n    precision = len(str(n))\n    assert precision >= 3\n\n    # Build the matrix\n    matrix = []\n    for i in range(n):\n        matrix.append(list(str(i)))\n    for i in range(n, n_digits * width):\n        matrix[i % n].append(matrix[i % n][-1])\n        matrix[i % n].append(matrix[i % n][-2])\n        matrix[i % n].append(matrix[i % n][-3])\n        matrix[i % n].append(matrix[i % n][-4])\n        matrix[i % n].append(matrix[i % n][-5])\n\n    # Precompute some things\n    col_width = [max(map(len, row)) for row in matrix]\n    total_col_width = sum(col_width)\n\n    def expand_row(row):\n        # Expand a row and return it\n        expanded = []\n        for i, value in enumerate(row):\n            if value == '0':\n                expanded.append(' ')\n            elif value == '1':\n                expanded.append('\\033[31m#\\033[m')\n            elif value == '2':\n                expanded.append('\\033[32m#\\033[m')\n            else:\n                expanded.append('\\033[33m#\\033[m')\n        return expanded\n\n    def build_line(row):\n        # Build a line from a row and return it\n        line ='' * total_col_width\n        for i, value in enumerate(row):\n            if value == '1':\n                line = line[:col_width[i]] + '\\033[31m#\\033[m' + line[col_width[i] + 1:]\n            elif value == '2':\n                line = line[:col_width[i]] + '\\033[32m#\\033[m' + line[col_width[i] + 1:]\n            else:\n                line = line[:col_width[i]] + '\\033[33m#\\033[m' + line[col_width[i] + 1:]\n        return line\n\n    def print_line(line):\n        # Print a line with colors and the number of columns\n        print(line)\n        for i in range(width):\n            if (i + 1) % total_col_width == 0:\n                print()\n            print(' ', end='')\n\n    # Start processing\n    expanded = []\n    for i, row in enumerate(matrix):\n        expanded.append(expand_row(row))\n    for i in range(n_digits - 1):\n        expanded.append([''] * (total_col_width + 1))\n\n    for i, row in enumerate(expanded):\n        expanded[i] = build_line(row)\n\n    # Print\n    print_line(''* total_col_width + '\\033[31m#\\033[m')\n    for line in expanded:\n        print_line(line)\n    return"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    m = {}\n    for i in range(ord('A'), ord('Z') + 1):\n        m[chr(i)] = 1\n    for _ in range(len(stdin) - 1):\n        for j in range(ord('A'), ord('Z') + 1):\n            if chr(j) in m and chr(j + 1) in m:\n                if chr(j) + chr(j + 1) in m:\n                    m[chr(j)] = math.ceil(m[chr(j)] / 2)\n                else:\n                    m[chr(j)] = m[chr(j)] + m[chr(j + 1)]\n    return str(max(m.values()))\n"
    },
    {
        "number": 3005,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    str = stdin.strip()\n    factored_string = \"\"\n    while str!= \"\":\n        max_weight = 1\n        factored_string += str[0]\n        str = str[1:]\n        for i in range(1, len(str)):\n            if str[:i] == str[i:i+i]:\n                max_weight += 1\n            else:\n                break\n        factored_string += \"^\" + str[:i]\n        str = str[i:]\n    return factored_string"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    answer = 0\n    instructions = []\n    for line in stdin.splitlines():\n        if line.startswith('D'):\n            instructions.append(line)\n        if line.startswith('I'):\n            instructions.append(line)\n    if len(instructions) <= 1:\n        return str(0)\n    last_index = 0\n    for instruction in instructions:\n        if instruction == 'E':\n            answer = 1\n            break\n        if instruction.startswith('I'):\n            index = int(instruction[1:])\n            if index > last_index:\n                answer = 1\n                break\n            last_index = index\n    return str(answer)\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d1 = deque()\n    d2 = deque()\n    for i in range(len(stdin)):\n        if stdin[i] == 'I':\n            d1.append(stdin[i + 1])\n        if stdin[i] == 'D':\n            d1.append(stdin[i + 1])\n        if stdin[i] == 'E':\n            if len(d1) > 0:\n                d2.appendleft(d1.pop())\n    return '1' if d2 == d1 else '0'\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin\n    # Method 1\n    # input_string = stdin.split(\"\\n\")\n    # for i in range(0,len(input_string)):\n    #     input_string[i] = input_string[i].split(\" \")\n    #     input_string[i][0] = input_string[i][0].replace(\"D\",\"\")\n    #     input_string[i][0] = int(input_string[i][0])\n    #     input_string[i].insert(1,input_string[i].pop(0))\n    #     input_string[i][1] = input_string[i][1].replace(\"I\",\"\")\n    #     input_string[i][1] = int(input_string[i][1])\n    #     input_string[i].insert(2,input_string[i].pop(1))\n    #     input_string[i].pop(1)\n    #     input_string[i].pop(0)\n    #     input_string[i].insert(0,\"\")\n    #     input_string[i].insert(0,input_string[i].pop())\n    #     input_string[i].pop()\n    #     input_string[i] = ''.join(input_string[i])\n    #     input_string[i] = str(input_string[i])\n    #     input_string[i] = input_string[i].replace(\"0\",\"\")\n    #     input_string[i] = input_string[i].replace(\"1\",\"\")\n    #     input_string[i] = input_string[i].replace(\"2\",\"\")\n    #     input_string[i] = input_string[i].replace(\"3\",\"\")\n    #     input_string[i] = input_string[i].replace(\"4\",\"\")\n    #     input_string[i] = input_string[i].replace(\"5\",\"\")\n    #     input_string[i] = input_string[i].replace(\"6\",\"\")\n    #     input_string[i] = input_string[i].replace(\"7\",\"\")\n    #     input_string[i] = input_string[i].replace(\"8\",\"\")\n    #     input_string[i] = input_string[i].replace(\"9\",\"\")\n    #     input_string[i] = input_string[i].replace(\"0\",\"\")\n    #     input_string[i] = input_string[i].replace(\" \",\"\")\n    #     input_string[i] = input_string[i].replace(\"B\",\"\")\n    #     input_string[i] = input_string[i].replace(\"A\",\"\")\n    #     input_string[i] = input_string[i].replace(\"X\",\"\")\n    #     input_string[i] = input_string[i].replace(\"E\",\"\")\n    # print(input_string)\n    # method 2\n    # input_string = stdin.split(\"\\n\")\n    # for i in range(0,len(input_string)):\n    #     input_string[i] = input_string[i].split(\" \")\n    #     input_string[i][0] = input_string[i][0].replace(\"D\",\"\")\n    #     input_string[i][0] = int(input_string[i][0])\n    #     input_string[i].insert(1,input_string[i].pop(0))\n    #     input_string[i][1] = input_string[i][1].replace(\"I\",\"\")\n    #     input_string[i][1] = int(input_string[i][1])\n    #     input_string[i].insert(2,input_string[i].pop(1))\n    #     input_string[i].pop(1)\n    #     input_string[i].pop(0)\n    #     input_string[i].insert(0,\"\")\n    #     input_string[i].insert(0,input_string[i].pop())\n    #     input_string[i].pop()\n    #     input_string[i] = ''.join(input_string[i])\n    #     input_string[i] = str(input_string[i])\n    #     input_string[i] = input_string[i].replace(\"0\",\"\")\n    #     input_string[i] = input_string[i].replace(\"1\",\"\")\n    #     input_string[i] = input_string[i].replace(\"2\",\"\")\n    #     input_string[i] = input_string[i].replace(\"3\",\"\")\n    #     input_string[i] = input_string[i].replace(\"4\",\"\")\n    #     input_string[i] = input_string[i].replace(\"5\",\"\")\n    #     input_string[i] = input_string[i].replace(\"6\",\"\")\n    #     input_string[i] = input_string[i].replace(\"7\",\"\")\n    #     input_string[i] = input_string[i].replace(\"8\",\"\")\n    #     input_string[i] = input_string[i].replace(\"9\",\"\")\n    #     input_string[i] = input_string[i].replace(\"0\",\"\")\n    #     input_string[i] = input_string[i].replace(\" \",\"\")\n    #     input_string[i] = input_string[i].replace(\"B\",\"\")\n    #     input_string[i] = input_string[i].replace(\"A\",\"\")\n    #     input_string[i] = input_string[i].replace(\"X\",\"\")\n    #     input_string[i] = input_string[i].replace(\"E\",\"\")\n    # print(input_string)\n    # method 3\n    # input_string = stdin.split(\""
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: Write your code here\n    stdin = stdin.splitlines()\n    no1 = stdin[0].split()\n    no2 = stdin[1].split()\n    d1 = int(no1[1])\n    e1 = no1[0]\n    d2 = int(no2[1])\n    e2 = no2[0]\n    l1 = [i for i in range(d1,d2+1)]\n    l2 = [i for i in range(d2,d1+1)]\n    l1.reverse()\n    l2.reverse()\n    if e1 == 'D':\n        if e2 == 'E':\n            return '0'\n        else:\n            for i in range(d2,d1+1):\n                if i == d2:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l1.append(i)\n                        l2.append(i)\n                else:\n                    if e2 == 'B':\n                        l2.remove(i)\n                        l1.append(i)\n                    else:\n                        l1.remove(i)\n                        l2.remove(i)\n    elif e1 == 'I':\n        if e2 == 'E':\n            for i in range(d2,d1+1):\n                if i == d2:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.append(i)\n                        l1.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n        else:\n            for i in range(d2,d1+1):\n                if i == d2:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.append(i)\n                        l1.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n    elif e1 == 'E':\n        l1.reverse()\n        l2.reverse()\n        if e2 == 'D':\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l1.append(i)\n                        l2.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n        elif e2 == 'I':\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l1.append(i)\n                        l2.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n        else:\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.append(i)\n                        l1.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n    else:\n        l1.reverse()\n        l2.reverse()\n        if e2 == 'D':\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l2.remove(i)\n                        l1.remove(i)\n                    else:\n                        l2.append(i)\n                        l1.remove(i)\n                else:\n                    if e2 == 'B':\n                        l2.remove(i)\n                        l1.remove(i)\n                    else:\n                        l1.remove(i)\n                        l2.remove(i)\n        elif e2 == 'I':\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l2.remove(i)\n                        l1.remove(i)\n                    else:\n                        l1.append(i)\n                        l2.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:\n                        l2.remove(i)\n                        l1.remove(i)\n        else:\n            for i in range(d1,d2+1):\n                if i == d1:\n                    if e2 == 'B':\n                        l2.remove(i)\n                        l1.remove(i)\n                    else:\n                        l1.append(i)\n                        l2.remove(i)\n                else:\n                    if e2 == 'B':\n                        l1.remove(i)\n                        l2.remove(i)\n                    else:"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    del_dict = {}\n    ins_dict = {}\n    count = 0\n    for line in stdin.split('\\n'):\n        if line.strip() == \"\":\n            continue\n        if line.startswith(\"D\"):\n            del_dict[count] = line[1:].strip()\n            count += 1\n        if line.startswith(\"I\"):\n            ins_dict[count] = line[1:].strip()\n            count += 1\n        if line.startswith(\"E\"):\n            del_dict[count] = line[1:].strip()\n            count += 1\n        \n        if len(del_dict) == len(ins_dict):\n            for _ in range(len(del_dict)):\n                del_dict[_] = list(del_dict[_])\n                del_dict[_].pop(0)\n                del_dict[_] = ''.join(del_dict[_])\n            for _ in range(len(ins_dict)):\n                ins_dict[_] = list(ins_dict[_])\n                ins_dict[_].pop(0)\n                ins_dict[_] = ''.join(ins_dict[_])\n            if del_dict == ins_dict:\n                return \"0\"\n            else:\n                return \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    program_1 = stdin.split(\"\\n\")[0].split()\n    program_2 = stdin.split(\"\\n\")[1].split()\n    program_1 = [(int(i), chr(ord('A') + i - 1)) for i in program_1]\n    program_2 = [(int(i), chr(ord('A') + i - 1)) for i in program_2]\n    if program_1 == program_2:\n        print(0)\n    else:\n        print(1)\n    return 0\n\nsolution(input())\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    dna_seq1 = []\n    dna_seq2 = []\n    for _ in stdin.split('\\n'):\n        if _[0] == 'D':\n            dna_seq1.append(int(_[1]))\n        elif _[0] == 'I':\n            dna_seq2.append(int(_[1]))\n        elif _[0] == 'E':\n            dna_seq1.append(0)\n            dna_seq2.append(0)\n        else:\n            break\n    dna_seq1 = dna_seq1[::-1]\n    dna_seq2 = dna_seq2[::-1]\n    dna_seq1 = ''.join(dna_seq1)\n    dna_seq2 = ''.join(dna_seq2)\n    if dna_seq1 == dna_seq2:\n        return '0'\n    else:\n        return '1'\n\nsolution('D 2\\nD 1\\nE\\nD 1\\nD 2\\nE')\nsolution('I 14 B\\nI 14 A\\nE')\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    programs = stdin.splitlines()\n    program1 = programs[0]\n    program2 = programs[1]\n    if program1 == program2:\n        return '0'\n    else:\n        return '1'\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    p1, p2 = '', ''\n    for line in stdin:\n        if line[0] == 'D':\n            p1 += line[1]\n            p2 += line[1]\n        elif line[0] == 'I':\n            p1 += line[1]\n            p2 += line[1]\n        elif line[0] == 'E':\n            p1 += line[1]\n            p2 += line[1]\n        elif line[0] == 'D':\n            p1 += line[1]\n            p2 += line[1]\n        else:\n            break\n    if p1 == p2:\n        return '0'\n    return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    seq = []\n    for line in stdin.splitlines():\n        if line[0] == 'D':\n            seq.append((line[0], int(line[1:])))\n        elif line[0] == 'I':\n            seq.append((line[0], int(line[1:])))\n    return seq\nseq1 = solution(input())\nseq2 = solution(input())\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = stdin.split()\n    d, b, f, t_0, t_1, t_2 = int(d), int(b), int(f), int(t_0), int(t_1), int(t_2)\n\n    if d == 0:\n        return str(b)\n\n    # the first day to harvest\n    days = t_0\n\n    # the first day to buy exotic fruit\n    f_t0 = 0\n    while f_t0 < f:\n        if f_t0 == f:\n            break\n        else:\n            f_t0 = f_t0 + 1\n\n    # the second day to buy exotic fruit\n    f_t1 = 0\n    while f_t1 < f:\n        if f_t1 == f:\n            break\n        else:\n            f_t1 = f_t1 + 1\n\n    # the last day to buy exotic fruit\n    f_t2 = 0\n    while f_t2 < f:\n        if f_t2 == f:\n            break\n        else:\n            f_t2 = f_t2 + 1\n\n    # print(f_t0, f_t1, f_t2)\n    if days == t_0 and f_t0 < f:\n        days = days + 1\n        f_t0 = f_t0 + 1\n        f = f - f_t0\n    elif days == t_1 and f_t1 < f:\n        days = days + 1\n        f_t1 = f_t1 + 1\n        f = f - f_t1\n    elif days == t_2 and f_t2 < f:\n        days = days + 1\n        f_t2 = f_t2 + 1\n        f = f - f_t2\n\n    f_t0 = int(f_t0)\n    f_t1 = int(f_t1)\n    f_t2 = int(f_t2)\n\n    return str(min(f_t0, f_t1, f_t2))\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return '{}'.format(max(0, max(int(stdin.split()[0]) - int(stdin.split()[1]), int(stdin.split()[2]))))\n\nsolution(stdin)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    return max(b + (f * (d - t_2) + t_1 * (d - t_1) + t_0 * (d - t_0)) * 0.8, 0)"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    # Implement a solution here.\n    for i in range(t_0, t_1 + 1):\n        f += f / 3\n    for i in range(t_1, t_2 + 1):\n        f += f / 3\n    return (b * 100) + (d * 400) + f * 500 + max(d * 400, b * 100)"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.splitlines():\n        x, y, z, *t = list(map(int, line.split()))\n        if x > 0 and y == 0 and z == 0 and t[0] == 0 and t[1] == 0 and t[2] == 0:\n            return \"%.2f\" % (y * 100 + z)\n        else:\n            return \"%.2f\" % (z * 100 + y)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    fruits = list(map(int, stdin.split()))\n    d, b, f, t_0, t_1, t_2 = fruits\n    d, b, f, t_0, t_1, t_2 = d, b, f, t_0, t_1, t_2\n    # d, b, f, t_0, t_1, t_2 = d, b, f, t_0, t_1, t_2\n    while True:\n        if d == 1:\n            b += min(100, f)\n            f = 0\n        elif d == 2:\n            f += min(100, f)\n            b += min(300, t_0)\n            t_0 = 0\n        elif d == 3:\n            f += min(100, f)\n            b += min(300, t_0)\n            t_0 = 0\n        elif d == 4:\n            f += min(100, f)\n            b += min(400, t_0)\n            t_0 = 0\n        elif d == 5:\n            f += min(100, f)\n            b += min(400, t_0)\n            t_0 = 0\n        else:\n            break\n        d -= 1\n    return b\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    d, b, f, t_0, t_1, t_2 = map(int, lines[0].split())\n    # print(d, b, f, t_0, t_1, t_2)\n    count = 0\n    while True:\n        count += 1\n        if count == d:\n            break\n        b += 100 * (t_1 + t_2)\n        f += 3 * t_0\n        if f <= 0:\n            return \"0\"\n        t_0 = max(0, t_0 + 3 * t_1 + t_2)\n    b += (t_0 * t_0) * t_1\n    b += t_0 * f\n    if b >= 10000:\n        b = (b % 10000) * 100\n    if b >= 10000:\n        b = (b % 10000) * 100\n    b += f * 100\n    return str(b)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = (int(x) for x in stdin.split())\n    max_fruit = b + (b // 3) * f\n    max_fruit = max_fruit + (max_fruit // 4) * (max_fruit // 4) + (max_fruit // 5) * (max_fruit // 5) + max_fruit * (d - t_2)\n    max_fruit = max_fruit - (max_fruit // 3) * (t_1 + t_2)\n    max_fruit = max_fruit - (max_fruit // 3) * (t_1)\n    return str(max_fruit)\n"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n\n    def eat(d, b, f, t_0, t_1, t_2):\n        d -= 1\n        b += 100\n        f += 3\n        t_0 += 1\n        if t_0 <= 100:\n            t_2 += 1\n        if t_1 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t_2 += 1\n        if t_2 <= 100:\n            t"
    },
    {
        "number": 3007,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    stdin = stdin.split('\\n')\n    d, b, f, t0, t1, t2 = [int(i) for i in stdin[0].split(' ')]\n    if b < 400:\n        return '0'\n    elif f == 0 and t0 == 0 and t1 == 0 and t2 == 0:\n        return str(d*400)\n    else:\n        f = int((d*400)/100)\n        t0 = int((d*100)/3)\n        t1 = int((d*1)/3)\n        t2 = int(d/3)\n        if t0 == 0 and t1 == 0 and t2 == 0:\n            return str(int((d*b)/100))\n        else:\n            return str(max([t0, t1, t2]))\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inputs = []\n    for line in stdin.splitlines():\n        inputs.append([int(i) for i in line.split()])\n    return str(max(solution_for_inputs(inputs)))\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # N, K = map(int, stdin.split())\n    # a = list(map(int, stdin.split()))\n    # b = list(map(int, stdin.split()))\n    N, K = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    # print(N, K)\n    # print(a)\n    # print(b)\n    n = len(a)\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    ranks = {}\n    for i in range(n):\n        ranks[i] = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                ranks[j] = max(ranks[j], ranks[i]+1)\n    ranks_sorted = sorted(ranks.values(), reverse=True)\n    print(ranks_sorted)\n    max_rank = ranks_sorted[0]\n    print(max_rank)\n    return str(max_rank)\n\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(x) for x in stdin.split())\n    K = 10**K\n    a = sorted(map(int, stdin.split()))\n    b = sorted(map(int, stdin.split()))\n\n    # Compare a[i] and b[i]. If a[i] is higher than b[i], then rank of b[i] will always be higher than a[i].\n    # so if b[i] > a[i], then rank of a[i] must be higher than rank of b[i]. If b[i] <= a[i], then rank of b[i] must be higher than rank of a[i].\n    # if a[i] > b[i], then rank of a[i] must be higher than rank of b[i]. If b[i] >= a[i], then rank of b[i] must be higher than rank of a[i].\n    ranks = set()\n    for ai in a:\n        for bi in b:\n            if ai >= bi:\n                ranks.add(bi)\n            elif ai <= bi:\n                ranks.add(ai)\n            else:\n                ranks.add(max(ai, bi))\n    return len(ranks)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.strip().split())\n    a = sorted(map(int, stdin.strip().split()[1:]))\n    b = sorted(map(int, stdin.strip().split()[1:]))\n\n    ans = 0\n    if a == b:\n        return str(ans)\n    else:\n        cnt = 1\n        i = 0\n        j = 1\n        while i < N:\n            if a[i] + D < a[j]:\n                if b[j] + D < b[i]:\n                    if a[i] + D < b[j]:\n                        ans += cnt\n                    elif a[i] + D > b[j]:\n                        ans += 1\n                elif b[j] + D < a[i]:\n                    ans += cnt\n                elif a[i] + D < b[j] and b[j] + D < a[i]:\n                    ans += 1\n                elif a[i] + D < b[j] and a[i] + D > b[j]:\n                    ans += 1\n                elif a[i] + D > b[j] and b[j] + D < a[i]:\n                    ans += 1\n                elif a[i] + D > b[j] and a[i] + D > b[j]:\n                    ans += 1\n            i += 1\n            j += 1\n            cnt += 1\n\n        if ans > 999999999:\n            return str(ans)\n        else:\n            return str(ans)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inp1 = stdin.split()\n    n = int(inp1[0])\n    k = int(inp1[1])\n    s = stdin.split()\n    a = []\n    b = []\n    res = 0\n    for i in range(1, n + 1):\n        a.append(int(s[i]))\n    for i in range(n, 2 * n):\n        b.append(int(s[i]))\n    for i in range(n):\n        diff = abs(a[i] - b[i])\n        if k > diff:\n            k = diff\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) + abs(b[i] - b[j]) <= k:\n                res = max(res, j - i + 1)\n    return str(res)"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    measurements = sorted(map(int, stdin.split()), reverse=True)\n\n    max_rank = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(measurements[i] + D - measurements[j]) < D:\n                max_rank = max(max_rank, j + 1)\n\n    return str(max_rank)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.strip().split())\n    a = sorted(list(map(int, stdin.strip().split())))\n    b = sorted(list(map(int, stdin.strip().split())))\n    ans = 1\n    while True:\n        complement = False\n        i = 0\n        while i < len(a) and not complement:\n            if a[i] + D < b[i]:\n                complement = True\n            i += 1\n        if not complement:\n            break\n        ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, D = stdin.split(\"\\n\")\n    N = int(N)\n    D = int(D)\n    # print(N, D)\n    if N == 1:\n        return \"1\"\n    if D == 0:\n        return \"1\"\n    # print(N, D)\n    assistants = list(map(int, stdin.split(\"\\n\")))\n    # print(assistants)\n    # print(assistants)\n    assistants_diffs = []\n    for i in range(N-1):\n        assistants_diffs.append(assistants[i+1]-assistants[i])\n    # print(assistants_diffs)\n    max_ranks = 0\n    assistants_per_rank = []\n    for i in range(N):\n        assistants_per_rank.append(0)\n    # print(assistants_per_rank)\n    for diff in assistants_diffs:\n        if diff >= 0:\n            # print(\"+\")\n            for i in range(N):\n                if assistants_per_rank[i] == 0:\n                    assistants_per_rank[i] = 1\n                else:\n                    assistants_per_rank[i] += 1\n        elif diff <= D:\n            # print(\"-\")\n            for i in range(N):\n                if assistants_per_rank[i] == 0:\n                    assistants_per_rank[i] = 1\n                else:\n                    assistants_per_rank[i] -= 1\n        else:\n            # print(\"0\")\n            continue\n        max_ranks = max(max_ranks, max(assistants_per_rank))\n    return str(max_ranks)\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(x) for x in stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    return(max(len(set(a)), len(set(b))))\n"
    },
    {
        "number": 3008,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    a = sorted(map(int, stdin.split()))\n    b = sorted(map(int, stdin.split()))\n    jokes = {}\n    for i in range(N):\n        jokes[i] = {'a': a[i], 'b': b[i]}\n    for i in range(1, N):\n        jokes[i]['a'] = min(jokes[i - 1]['a'] + D, jokes[i - 1]['a'] + D)\n        jokes[i]['b'] = min(jokes[i - 1]['b'] + D, jokes[i - 1]['b'] + D)\n    return str(max(len(set(jokes[i]['a'] for i in range(N)))), max(len(set(jokes[i]['b'] for i in range(N)))), max(jokes[i]['a'] for i in range(N)), max(jokes[i]['b'] for i in range(N)))\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines: List[List[int]] = [[int(i) for i in stdin.split()]]\n    return line_lens(lines)[0]\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    ans = 0\n    lines = []\n    for i in range(N):\n        x, y, e = stdin.split(' ')\n        x, y, e = int(x), int(y), int(e)\n        lines.append((x, y, e))\n\n    lines = sorted(lines, key=lambda x: (x[0], x[1]))\n    lengths = []\n    for i in range(N):\n        x, y, e = lines[i]\n        for j in range(i + 1, N):\n            otherx, othery, othre = lines[j]\n            if x == otherx and y == othery:\n                print('IMPOSSIBLE')\n                return 'IMPOSSIBLE'\n            if x!= otherx and y!= othery:\n                break\n        length = abs(x * x + y * y)\n        lengths.append(length)\n        print(length)\n\n    ans = min(lengths)\n    print(ans)\n    return str(ans)"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    c = 0\n    for line in stdin.split('\\n'):\n        lamps = []\n        for i in range(3):\n            x, y, e = map(int, line.split())\n            if x <= 0 or x >= 100 or y <= 0 or y >= 100:\n                print('Impossible')\n                return 'Impossible'\n            lamps.append((x, y, e))\n        c += min([x + y for x, y, e in lamps]) - max([x + y for x, y, e in lamps])\n    print(c)\n    return str(c)\nprint(solution(input()))\n\n\"\"\"\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return \"IMPOSSIBLE\"\n\n    ans = 0\n    def inRange(x, y, l):\n        for i in range(N):\n            if abs(x-l[i][0]) + abs(y-l[i][1]) > 2:\n                return False\n        return True\n\n    def generate(l, visited, ans):\n        for i in range(N):\n            if not inRange(l[i][0], l[i][1], l):\n                return\n            if i not in visited:\n                visited.append(i)\n                generate(l, visited, ans)\n                visited.pop()\n            else:\n                return\n        l = sorted(l, key=lambda x: (x[0], x[1]))\n        ans += l[0][2] + l[-1][2]\n        return ans\n\n    l = []\n    for i in range(N):\n        l.append([int(i) for i in stdin.split()[i*2+1].split(' ')])\n    l.sort(key=lambda x: (x[0], x[1]))\n    ans = generate(l, [], ans)\n    return str(ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    c = (3, -3)\n\n    if n == 1:\n        return str(abs(c[0]) + abs(c[1]))\n\n    graph = {}\n    graph[(0, 0)] = (0, -1, 1)\n    graph[(0, 1)] = (0, -1, 1)\n    graph[(0, 2)] = (0, -1, 1)\n    graph[(1, 0)] = (1, -1, 1)\n    graph[(1, 1)] = (1, -1, 1)\n    graph[(1, 2)] = (1, -1, 1)\n    graph[(2, 0)] = (2, -1, 1)\n    graph[(2, 1)] = (2, -1, 1)\n    graph[(2, 2)] = (2, -1, 1)\n    graph[(3, 0)] = (3, -1, 1)\n    graph[(3, 1)] = (3, -1, 1)\n    graph[(3, 2)] = (3, -1, 1)\n\n    # visited = set()\n    # visited.add((0, 0))\n    # queue = deque([(0, 0)])\n    # while queue:\n    #     x, y = queue.popleft()\n    #     for i, j in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n    #         if i >= 0 and i <= 3 and j >= 0 and j <= 3 and (i, j) not in visited:\n    #             visited.add((i, j))\n    #             queue.append((i, j))\n\n    # return str(abs(c[0]) + abs(c[1]))\n\n    def bfs(n):\n        \"\"\"\n        dfs\n        \"\"\"\n        if n == 1:\n            return (abs(c[0]) + abs(c[1]))\n\n        graph[(0, 0)] = (0, -1, 1)\n        graph[(0, 1)] = (0, -1, 1)\n        graph[(0, 2)] = (0, -1, 1)\n        graph[(1, 0)] = (1, -1, 1)\n        graph[(1, 1)] = (1, -1, 1)\n        graph[(1, 2)] = (1, -1, 1)\n        graph[(2, 0)] = (2, -1, 1)\n        graph[(2, 1)] = (2, -1, 1)\n        graph[(2, 2)] = (2, -1, 1)\n        graph[(3, 0)] = (3, -1, 1)\n        graph[(3, 1)] = (3, -1, 1)\n        graph[(3, 2)] = (3, -1, 1)\n\n        queue = deque([(0, 0, 0)])\n        while queue:\n            x, y, energy = queue.popleft()\n            for i, j in ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)):\n                if i >= 0 and i <= 3 and j >= 0 and j <= 3 and (i, j) not in visited:\n                    visited.add((i, j))\n                    queue.append((i, j, energy + graph[(i, j)][2]))\n\n        return str(abs(c[0]) + abs(c[1]))\n\n    if n > 2:\n        return str(min(bfs(n) for i in range(n)))\n    else:\n        return str(abs(c[0]) + abs(c[1]))"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lamps = stdin.strip().split('\\n')\n    N = int(lamps.pop(0))\n    assert 2 <= N <= 12, \"The length of the lamp configuration is out of range.\"\n    size = 6\n    for lamp in lamps:\n        x, y, energy = map(int, lamp.split())\n        assert 1 <= x <= 99, \"Invalid x-coordinate {}\".format(x)\n        assert 1 <= y <= 99, \"Invalid y-coordinate {}\".format(y)\n        assert energy >= -2000, \"Invalid energy contribution {}\".format(energy)\n        assert energy <= 2000, \"Invalid energy contribution {}\".format(energy)\n        size = min(size, x - 1, y - 1, x + 1, y + 1)\n    if size == 6:\n        return \"IMPOSSIBLE\"\n    return str(size * size)\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def solution_a(x, y, e):\n        return (x - 1) * (y - 1) + (x + 1) * (y + 1) + e\n\n    def solution_b(x, y, e):\n        return x * y + e\n\n    N = int(stdin.split()[0])\n    L = []\n    for _ in range(N):\n        l = stdin.split()\n        x, y, e = int(l[0]), int(l[1]), int(l[2])\n        L.append((x, y, e))\n    # sort by energy\n    L.sort(key=lambda x: x[2], reverse=True)\n    n = len(L)\n    min_dist = 2 * (n + 1) - 2  # 2*n - 2\n\n    # for x in range(n):\n    #     e = L[x][2]\n    #     if e >= 0:\n    #         min_dist = min(min_dist, solution_a(L[x][0], L[x][1], e))\n    #     else:\n    #         min_dist = min(min_dist, solution_b(L[x][0], L[x][1], e))\n\n    for x in range(n):\n        e = L[x][2]\n        if e >= 0:\n            min_dist = min(min_dist, solution_a(L[x][0], L[x][1], e))\n        else:\n            min_dist = min(min_dist, solution_b(L[x][0], L[x][1], e))\n    return str(min_dist)"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N = int(input_lines[0])\n    lines = []\n    for i in range(1, N + 1):\n        line = input_lines[i].split()\n        x_i = int(line[0])\n        y_i = int(line[1])\n        e_i = int(line[2])\n        lines.append([x_i, y_i, e_i])\n    lines.sort()\n    last_row = None\n    for i in range(1, N):\n        row = lines[i]\n        row_next = lines[i + 1]\n        if row_next[0] == row[0] + 1:\n            if row_next[1] == row[1]:\n                if row_next[2] == row[2] - e_i:\n                    if last_row:\n                        return IMPOSSIBLE\n                    last_row = row\n                else:\n                    if last_row:\n                        if row[2] - e_i < last_row[2] - e_i:\n                            last_row = row\n                    else:\n                        last_row = row\n            else:\n                if last_row:\n                    if row[1] - e_i < last_row[1] - e_i:\n                        last_row = row\n                else:\n                    last_row = row\n        else:\n            if last_row:\n                if row[0] - e_i < last_row[0] - e_i:\n                    last_row = row\n            else:\n                last_row = row\n    if last_row:\n        return str(last_row[0] - e_i + last_row[1] - e_i)\n    else:\n        return IMPOSSIBLE\n\n\nprint(solution('''2\n4 4 1\n4 6 1\n4 8 1\n6 6 14\n8 4 1\n8 6 1\n8 8 1\n99 6 -8'''))\nprint(solution('''8\n4 4 1\n4 6 1\n4 8 1\n6 6 14\n8 4 1\n8 6 1\n8 8 1\n99 6 -8'''))\nprint(solution('''6\n1 1 15\n5 1 100\n9 1 56\n1 5 1\n5 5 33\n9 5 3\n'''))\nprint(solution('''6\n1 1 15\n5 1 100\n9 1 56\n1 5 1\n5 5 33\n9 5 3\n'''))\nprint(solution('''4\n1 1 15\n5 1 100\n9 1 56\n1 5 1\n5 5 33\n9 5 3\n'''))\nprint(solution('''5\n1 1 15\n5 1 100\n9 1 56\n1 5 1\n5 5 33\n9 5 3\n'''))\n"
    },
    {
        "number": 3009,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = [[int(x) for x in stdin.strip().split()] for _ in range(int(stdin.strip().split()[0]))]\n    num_of_lights = int(stdin.strip().split()[0])\n    min_length = float('inf')\n    for lamp in range(num_of_lights):\n        c = 0\n        for i in range(1, num_of_lights):\n            for j in range(1, num_of_lights):\n                if c == 0:\n                    if i!= lamp and j!= lamp:\n                        c = a[i][j] + a[j][i]\n                else:\n                    c -= a[i][j] + a[j][i]\n        if min_length > c:\n            min_length = c\n    return str(min_length)\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    n = 1 if n < 1 else n\n    lines = [[int(i) for i in stdin.split('\\n')[n].split()]]\n    for i in range(n, len(stdin.split('\\n'))):\n        lines.append([int(i) for i in stdin.split('\\n')[i].split()])\n    points = {}\n    for x1, y1, x2, y2 in lines:\n        if x1 in points and x2 in points:\n            if y1 in points and y2 in points:\n                if (x1, y1) not in points or (x2, y2) not in points:\n                    points[(x1, y1)] = (x2, y2)\n                    points[(x2, y2)] = (x1, y1)\n        elif x1 in points and y1 in points:\n            if x2 in points and y2 in points:\n                if (x1, y1) not in points or (x2, y2) not in points:\n                    points[(x1, y1)] = (x2, y2)\n                    points[(x2, y2)] = (x1, y1)\n        elif x2 in points and y2 in points:\n            if x1 in points and y1 in points:\n                if (x1, y1) not in points or (x2, y2) not in points:\n                    points[(x1, y1)] = (x2, y2)\n                    points[(x2, y2)] = (x1, y1)\n    return len(points)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = []\n    s2 = []\n    for i in range(n):\n        x, y = map(int, stdin.strip().split())\n        s.append((x, y))\n        s2.append((y, x))\n    s = set(s)\n    s2 = set(s2)\n    if len(s) == 1:\n        return \"1\"\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if (s2.intersection(set([s[i], s[j]])) or s2.intersection(set([s[j], s[i]]))) and s[i]!= s[j]:\n                return str(i)\n    return str(-1)\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    list_of_points = []\n    for i in range(N):\n        list_of_points.append([int(x) for x in stdin.split(\" \")])\n    #print(list_of_points)\n    # print(sorted(list_of_points))\n    for i in range(N):\n        for j in range(i + 1, N):\n            if sorted(list_of_points[i]) == sorted(list_of_points[j]):\n                print(sorted(list_of_points[i]))\n                return (i, j)\n    return (\"-1\")\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    points = []\n    for i in range(len(lines)):\n        points.append((int(lines[i].split()[0]), int(lines[i].split()[1])))\n    print(points)\n    return points"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    points = []\n    for _ in range(n):\n        points.append([int(i) for i in stdin[1].split()])\n    \n    # points.sort(key=lambda point: (point[0], -point[1]))\n    points.sort(key=lambda point: (point[0], -point[1]))\n    points.sort(key=lambda point: (point[1], -point[0]))\n    points.sort(key=lambda point: (point[1], point[0]))\n\n    def check_intersects(point1, point2):\n        # check if either of the points are on the same line\n        if point1[0] == point2[0] or point1[1] == point2[1]:\n            return True\n        # check if the intersection is on the line between two points\n        if point1[0] == point2[0] and point1[1] == point2[1]:\n            return True\n\n        x1, x2 = point1[0], point2[0]\n        y1, y2 = point1[1], point2[1]\n        return ((y2 - y1) * (x1 - point2[0]) - (x2 - x1) * (y1 - point2[1]))!= 0\n    \n    def check_touches(point1, point2):\n        # check if either of the points are on the same line\n        if point1[0] == point2[0] or point1[1] == point2[1]:\n            return True\n        # check if the intersection is on the line between two points\n        if point1[0] == point2[0] and point1[1] == point2[1]:\n            return True\n\n        x1, x2 = point1[0], point2[0]\n        y1, y2 = point1[1], point2[1]\n        return ((x2 - x1) * (y1 - point1[1]) - (y2 - y1) * (x1 - point1[0]))!= 0\n    \n    intersects_count = 0\n    touches_count = 0\n    \n    # point1 and point2 should not be the same point\n    for i in range(n - 1):\n        # points[i] and points[i+1] are on different lines\n        if not check_intersects(points[i], points[i+1]) and not check_touches(points[i], points[i+1]):\n            intersects_count += 1\n\n    for i in range(n - 1):\n        # points[i] and points[i+1] are on the same line\n        if check_intersects(points[i], points[i+1]):\n            intersects_count += 1\n\n    for i in range(n - 1):\n        # points[i] and points[i+1] are on the same line\n        if check_touches(points[i], points[i+1]):\n            touches_count += 1\n\n    if intersects_count >= n - 1 and touches_count >= n - 1:\n        return '-1'\n    else:\n        return str(intersects_count)\n\nprint(solution(input()))"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n = int(stdin.strip())\n    nums = stdin.split()\n    nums = list(map(int, nums))\n    nums = sorted(nums)\n    count = 0\n    for i in range(len(nums) - 1):\n        if nums[i] < 0:\n            break\n        for j in range(i+1, len(nums)):\n            if nums[i] < 0 or nums[j] < 0:\n                break\n            if nums[i] + nums[j] <= nums[j] + nums[i]:\n                count += 1\n    if count > 0:\n        return str(count)\n    else:\n        return \"1\"\n    \nprint(solution(input()))\n\n\"\"\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    n = int(inputs[0])\n    points = list()\n    for i in range(n):\n        points.append([int(x) for x in inputs[i+1].split()])\n    output = solution_part1(points)\n    print(output)\n    return output\n\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    points = sorted(list(map(int, stdin.split())))\n    points.append(points[0])\n    points.append(points[1])\n    points = sorted(set(points))\n    points = sorted(points, reverse=True)\n    points = len(points)\n    print(points)\n    return\nsolution(input())\n"
    },
    {
        "number": 3010,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_lines = int(stdin.strip())\n    points = [list(map(int, stdin.strip().split())) for _ in range(num_lines)]\n    return str(count_intersection(points))\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.splitlines():\n        if is_a_hill_number(int(line)):\n            print(num_of_positive_hill_numbers_le(int(line)))\n        else:\n            print(-1)\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    hill_numbers = []\n    for i in range(int(stdin)):\n        hill_numbers.append(str(i))\n    num = 0\n    if len(hill_numbers) == 1:\n        return num\n    for i in range(1, len(hill_numbers)):\n        if i == 1:\n            num += 1\n        if hill_numbers[i] == hill_numbers[i - 1] + hill_numbers[i - 1]:\n            num += 1\n        if hill_numbers[i] == hill_numbers[i - 1] * hill_numbers[i - 1]:\n            num += 1\n    return num\nsolution(\"10\")\nsolution(\"55\")\nsolution(\"101\")\nsolution(\"1234321\")\nsolution(\"123\")\nsolution(\"1\")\nsolution(\"5\")\nsolution(\"11\")\nsolution(\"345\")\nsolution(\"01\")\nsolution(\"10\")\n"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    total_hill_numbers = 0\n    for n in range(1, 10 ** 18):\n        if is_hill_number(n):\n            total_hill_numbers += 1\n    return str(total_hill_numbers)\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    counter = 0\n    # Using the bisection method to find a range\n    low = 1\n    high = n\n    while low <= high:\n        mid = int((low + high) / 2)\n        if is_hill(mid):\n            counter += 1\n            low = mid + 1\n        else:\n            high = mid - 1\n    if is_hill(n):\n        counter += 1\n    else:\n        counter = -1\n    return str(counter)\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Complete the solution function below.\n    hill_number = stdin\n    count = 0\n    for i in range(2, 10**18):\n        if is_a_hill_number(i):\n            count += 1\n    if is_a_hill_number(hill_number):\n        print(count)\n    else:\n        print(-1)\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    sum = 0\n    for n in stdin.split('\\n'):\n        if (is_hill_number(int(n))):\n            sum += 1\n        else:\n            return '-1'\n    return str(sum)\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total = 0\n    for i in range(len(stdin)):\n        if is_hill(int(stdin[i])):\n            total += 1\n    return str(total)\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    hill_numbers = set()\n    for i in range(int(stdin) + 1):\n        string = str(i)\n        if string[0] == \"0\":\n            continue\n        previous = \"0\"\n        for digit in string:\n            if digit == previous[0]:\n                continue\n            elif digit == \"9\":\n                previous = \"9\"\n                continue\n            else:\n                if previous[0] == \"0\":\n                    continue\n                else:\n                    previous = digit\n                    break\n        else:\n            if previous!= \"0\":\n                hill_numbers.add(int(string))\n    return str(len(hill_numbers)) if int(stdin) in hill_numbers else str(-1)\n"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if is_hill_number(n) is True:\n        return str(find_hill_numbers(n))\n    return str(-1)\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    hill = []\n    for number in stdin.split('\\n'):\n        if check_hill_number(int(number)):\n            hill.append(int(number))\n    if len(hill) == 0:\n        return '-1'\n    return str(len(hill))\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rec(atk, def_, n):\n        res = 0\n        if n == 1:\n            if atk == def_:\n                res = 1\n            else:\n                res = 0\n        else:\n            if atk == def_:\n                res = rec(atk, def_, n - 1)\n            else:\n                res = rec(atk, def_, n - 1) + rec(atk, def_, n - 2)\n        return res\n    return str(rec(int(stdin.split()[0]), int(stdin.split()[1]), int(stdin.split()[2])))\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = stdin.split()\n    a11 = int(a11)\n    a12 = int(a12)\n    a21 = int(a21)\n    a22 = int(a22)\n    n = int(n)\n    return str(count(a11, a12, a21, a22, n))\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, e = stdin\n    a, b, c = int(a), int(b), int(c)\n    d, e = int(d), int(e)\n    N = int(e)\n\n    dp = [[0] * (N + 1) for i in range(4)]\n    dp[0][1], dp[1][1], dp[2][1], dp[3][1] = 1, 1, 1, 1\n\n    for i in range(4):\n        for j in range(i, N):\n            if j == 0:\n                dp[i][j] = dp[i][j + 1] + (a if i == 0 else dp[i - 1][j])\n            elif j == i:\n                dp[i][j] = dp[i][j - 1] + (b if i == 1 else dp[i - 1][j])\n            else:\n                dp[i][j] = dp[i][j - 1] + (a if i == 0 else dp[i - 1][j]) + (b if i == 1 else dp[i - 1][j - 1])\n            dp[i][j] = dp[i][j] % 1000000007\n    return str(dp[3][N])\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a,b,c,d,n = map(int,stdin.split())\n    if a+b+c+d == n:\n        return str(pow(2,n)-1)\n    else:\n        return str(pow(2,n))\nprint(solution(input()))"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, Atk, Def = map(int, stdin.strip().split())\n    if N == 1:\n        return Atk * Def\n    for i in range(1, N):\n        if Atk!= Def and Atk!= Atk * i:\n            return 0\n        if Atk == Atk * i:\n            return i\n    if Atk!= Def:\n        return Atk * (N - 1) + Atk\n    return Atk * (N - 1) * (N - 2) + Atk * N * Atk\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, a11, a12, a21, a22, n = map(int, stdin.split())\n    n = n % 1000000007\n    if N == 1:\n        if a11 == 1 or a12 == 1 or a21 == 1 or a22 == 1:\n            return n\n        return 0\n    count = 0\n    if a11 == 1:\n        count += n\n    if a12 == 1:\n        count += n\n    if a21 == 1:\n        count += n\n    if a22 == 1:\n        count += n\n    if a11 == a21:\n        count += n\n    if a11 == a22:\n        count += n\n    if a12 == a22:\n        count += n\n    if a21 == a22:\n        count += n\n    return count\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, x, y = list(map(int, stdin.split()))\n    a, b, c, d = 1, 1, 1, 1\n    for _ in range(s):\n        a = a * (2 * n + 2) / (2 * n + 3) + 1\n        b = b * (2 * m + 2) / (2 * m + 3) + 1\n        c = c * (2 * x + 2) / (2 * x + 3) + 1\n        d = d * (2 * y + 2) / (2 * y + 3) + 1\n        n, m, x, y = n + a, m + b, x + c, y + d\n    return str(n % (10 ** 9 + 7))\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, _, N, A1, A2 = map(int, stdin.split())\n    seq = 0\n    if N == 0:\n        return str(seq)\n    if N == 1:\n        return str(A1)\n    if N == 2:\n        return str(A1 * A2)\n    if A1 == A2:\n        return str(2)\n    if A1 > A2:\n        return str(2)\n    return str(3)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, n = map(int, stdin.split())\n    t = [[a, b], [b, c], [c, a], [a, c], [c, b], [b, a]]\n    num = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if t[i][0]!= t[i][1] and t[i][1]!= t[j][0] and t[j][0]!= t[j][1]:\n                num += 1\n    return str(num % 1000000007)\n"
    },
    {
        "number": 3012,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    atk_stats = [int(i) for i in stdin.split()[1:]]\n    def_stats = [int(i) for i in stdin.split()[1:]]\n    cnt = 0\n    for i in range(1, N+1):\n        defender = i\n        attacker = i-1 if i % 2 == 1 else i+1\n        atk_dist = 0\n        while atk_dist < N and atk_stats[atk_dist] == 0:\n            atk_dist += 1\n        def_dist = 0\n        while def_dist < N and def_stats[def_dist] == 0:\n            def_dist += 1\n        if atk_dist == N and def_dist == N:\n            cnt += 1\n        elif atk_stats[attacker-1] == 0 and atk_stats[atk_dist] == 0:\n            cnt += 1\n            atk_stats[atk_dist] = 1\n        elif def_stats[defender-1] == 0 and def_stats[def_dist] == 0:\n            cnt += 1\n            def_stats[def_dist] = 1\n    return str(cnt)\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    x_0, y_0 = 0, 0\n    v_x, v_y = 1, 0\n    phi = b * t_x\n    while True:\n        r = phi / math.cos(math.atan(v_x))\n        x_new = (x_0 + r * v_x) / math.sqrt(x_0 ** 2 + y_0 ** 2)\n        y_new = (y_0 + r * v_y) / math.sqrt(x_0 ** 2 + y_0 ** 2)\n        phi = (phi + t_y * math.atan(v_y) - t_x * math.atan(v_x)) * math.sqrt(1 + t_x ** 2 + t_y ** 2)\n        if x_new == x_0 and y_new == y_0:\n            return '{:.4f} {:.4f}'.format(x_new, y_new)\n        v_x = x_new - x_0\n        v_y = y_new - y_0\n        x_0, y_0 = x_new, y_new\n        if abs(v_x) > abs(v_y):\n            v_x, v_y = v_y, -v_x\n    return x_new, y_new\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, x, y = map(float, stdin.split())\n    # Compute x and y using the formula x = b cos(theta), y = b sin(theta)\n    theta = 2 * pi / b\n    x_new = b * cos(theta)\n    y_new = b * sin(theta)\n    return '{:.5f} {:.5f}'.format(x_new, y_new)\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, X, Y = stdin.split()\n    # t1 = eval(f\"{A} * {X}\")\n    # t2 = eval(f\"{A} * {Y}\")\n    t1 = float(A) * float(X)\n    t2 = float(A) * float(Y)\n    # b = t1 - t2\n    print(f\"{t1} {t2}\")\n    # return f\"{t1} {t2}\""
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = list(map(float, stdin.split()))\n    t = t_x ** 2 + t_y ** 2\n    r = b * t_x / t\n    d = (r**2) * (3.14159265358979323)\n    # print(d)\n    t_x = d * t_x / d\n    t_y = d * t_y / d\n    return \"{:.5f} {:.5f}\".format(t_x, t_y)"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, r_x, r_y = map(float, stdin.split())\n    d_x = r_x * math.cos(b)\n    d_y = r_y * math.sin(b)\n    t_x = math.sqrt(d_x**2 + d_y**2) - r_x * math.sin(b)\n    t_y = math.sqrt(d_x**2 + d_y**2) - r_y * math.cos(b)\n    x, y = int(t_x), int(t_y)\n    return f\"{x},{y}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, b, t_x, t_y = map(float, stdin.split())\n    r = (x ** 2 + y ** 2) ** 0.5\n    t_r = (t_x ** 2 + t_y ** 2) ** 0.5\n    a = (t_x / t_r) * (t_x / t_r)\n    b = -((t_x / t_r) * (y / r))\n    t_x_circle = -t_x\n    t_y_circle = -(t_y / r)\n    return f\"{(-t_x_circle / a):.4f} {(-t_y_circle / b):.4f}\""
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, x, y = map(float, stdin.strip().split())\n    phi = 0\n    r = b * math.sin(phi)\n    t = 0\n    x_pre = 0\n    y_pre = 0\n    while abs(x - x_pre) + abs(y - y_pre) > 10 ** -3:\n        x_pre = x\n        y_pre = y\n        r = b * phi\n        x = r * math.cos(t) + x\n        y = r * math.sin(t) + y\n        t += 1\n    return str(round(x, 5)) + \" \" + str(round(y, 5))\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    b, t_x, t_y = map(float, stdin.split())\n    x, y = b * t_x, b * t_y\n    if x > t_x:\n        x, t_x = -x, -t_x\n    if y > t_y:\n        y, t_y = -y, -t_y\n    return f\"{x:.5f} {y:.5f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b = float(stdin)\n    x, y = -1, -1\n    while True:\n        a = (x * x + y * y) * (b * b - 1) * b * b * (3 * b + 1)\n        if a >= 0:\n            return \"x = {} y = {}\".format(x, y)\n        x = math.sqrt(a) / (2 * b)\n        y = math.sqrt(a) / (2 * b)\n        b += 0.001\n"
    },
    {
        "number": 3013,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b = float(stdin.split(' ')[0])\n    x = float(stdin.split(' ')[1])\n    y = float(stdin.split(' ')[2])\n\n    r = b * x\n    phi = 2 * math.pi * y / r\n\n    spiral = (b, phi)\n\n    x = 0\n    y = 0\n    count = 0\n    while x ** 2 + y ** 2 >= spiral[0] ** 2:\n        x += 1 * math.cos(spiral[1])\n        y += 1 * math.sin(spiral[1])\n        count += 1\n    return str(x) +'' + str(y) +'' + str(count)\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(i) for i in stdin.split()]\n\n    def traverse(num: int, l: List[List[int]], r: List[List[int]]):\n        if r == l:\n            return num\n\n        if len(l) == 1:\n            if r[0] == l[0]:\n                return traverse(num, l[1:], r)\n\n        nums = list(range(1, n + 1))\n\n        for i, j in [(i, j) for i in l for j in r]:\n            nums.remove(i)\n            nums.remove(j)\n\n        if len(nums) == 0:\n            return num\n\n        return traverse(min(nums), l, [i for i in r if i not in l])\n\n    return str(traverse(0, range(1, n + 1), range(1, n + 1)))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = stdin.split()\n    rooms, corridors = int(rooms), int(corridors)\n    room_list = list(range(1, rooms + 1))\n\n    def is_corridor(room_1, room_2):\n        if room_1 == room_2:\n            return False\n        for i in range(2):\n            if room_1 + i in room_list and room_2 + i in room_list:\n                return True\n        return False\n\n    def remove_corridor(room_1, room_2):\n        for corridor in range(1, corridors + 1):\n            if is_corridor(room_1, room_2) and not is_corridor(room_1 + corridor, room_2 + corridor):\n                return corridor\n\n    corridors_removed = []\n    for corridor in range(1, corridors + 1):\n        if remove_corridor(1, corridor) or remove_corridor(corridor, 2):\n            corridors_removed.append(remove_corridor(1, corridor) or remove_corridor(corridor, 2))\n        else:\n            corridors_removed.append(corridor)\n\n    return str(max(corridors_removed) // 2)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rooms = []\n    n = int(stdin.strip())\n    for i in range(n):\n        rooms.append(list(map(int, stdin.strip().split())))\n\n    removed = 0\n    while removed < 1.5 * n:\n        removed = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if is_cycle(rooms, i, j):\n                    rooms[i].pop(0)\n                    rooms[j].pop(0)\n                    rooms[i].append(rooms[i][-1])\n                    rooms[j].append(rooms[j][-1])\n                    removed += 1\n    return str(removed // 2)\n\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = map(int, stdin.split())\n    count = 0\n    rooms = list(range(1, rooms + 1))\n    while True:\n        for i in range(len(rooms) - 1):\n            if rooms[i] == rooms[i + 1]:\n                break\n        else:\n            count += 1\n            rooms = rooms[:i] + rooms[i + 2:]\n        if count >= (corridors + 1) / 2:\n            return str(count)"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n\n    rooms, corridors = map(int, stdin[0].split())\n    if rooms <= 2:\n        if rooms == 2:\n            print(0)\n            return\n        return\n\n    if corridors <= 2:\n        if corridors == 2:\n            print(1)\n            return\n        return\n\n    start = [0] * (rooms + 1)\n    end = [0] * (rooms + 1)\n    for i in range(corridors):\n        start[int(stdin[i + 1])] = int(stdin[i + 2])\n        end[int(stdin[i + 2])] = int(stdin[i + 1])\n\n    stack = []\n    for i in range(1, rooms + 1):\n        if start[i] == 0:\n            stack.append(i)\n        for j in range(i + 1, rooms + 1):\n            if end[j] == 0:\n                end[j] = i\n                stack.append(j)\n\n    starts = []\n    ends = []\n    while stack:\n        start = stack.pop()\n        for i in range(rooms - 1, -1, -1):\n            if start == end[i]:\n                end[i] = 0\n                starts.append(i)\n                for j in range(i + 1, rooms + 1):\n                    if end[j] == 0:\n                        stack.append(j)\n                        break\n\n    result = len(starts) // 2\n    print(result)\n    return\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    For every corridor in stdin, remove the first and last corridor from the club, and return the number of corridors\n    removed.\n    '''\n    rooms, corridors = map(int, stdin.split())\n    room_to_corridor_map = dict()\n    corridor_to_room_map = dict()\n    for i in range(1, rooms + 1):\n        room_to_corridor_map[i] = set()\n        corridor_to_room_map[i] = set()\n\n    for corridor_a in range(1, corridors + 1):\n        corridor_a_start, corridor_a_end = map(int, input().split())\n        for corridor_b in range(corridor_a_start, corridor_a_end):\n            room_to_corridor_map[corridor_b].add(corridor_a)\n            corridor_to_room_map[corridor_a].add(corridor_b)\n\n    for corridor in range(1, corridors + 1):\n        corridor_to_remove = set()\n        if len(room_to_corridor_map[corridor]) > 1:\n            corridor_to_remove = room_to_corridor_map[corridor]\n        corridor_to_remove.remove(corridor)\n        corridor_to_remove.remove(corridor)\n        if len(corridor_to_remove) > 0:\n            if len(corridor_to_remove) < len(room_to_corridor_map[corridor]):\n                corridor_to_remove = corridor_to_remove.union(room_to_corridor_map[corridor])\n            elif len(corridor_to_remove) > 0:\n                corridor_to_remove = room_to_corridor_map[corridor]\n            else:\n                continue\n\n        for corridor_b in corridor_to_remove:\n            for room_a in range(corridor_a, corridor_b + 1):\n                room_to_corridor_map[room_a].add(corridor)\n                corridor_to_room_map[corridor].add(room_a)\n\n        corridor_to_remove = set()\n        for room_a in range(1, rooms + 1):\n            if len(corridor_to_room_map[room_a]) > 1:\n                corridor_to_remove = room_to_corridor_map[room_a]\n                corridor_to_remove.remove(room_a)\n                corridor_to_remove.remove(room_a)\n                if len(corridor_to_remove) > 0:\n                    if len(corridor_to_remove) < len(room_to_corridor_map[room_a]):\n                        corridor_to_remove = room_to_corridor_map[room_a]\n                    elif len(corridor_to_remove) > 0:\n                        corridor_to_remove = room_to_corridor_map[room_a]\n                    else:\n                        continue\n\n            for corridor_b in corridor_to_remove:\n                room_to_corridor_map[room_a].add(corridor)\n                corridor_to_room_map[corridor].add(room_a)\n\n        removed = len(corridor_to_remove)\n\n    return str(removed)\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    rooms = []\n    rooms_dict = {}\n    count = 0\n\n    n, m = map(int, stdin.split())\n    for i in range(n):\n        rooms.append(i+1)\n        rooms_dict[i+1] = 0\n\n    for line in stdin.splitlines():\n        u, v = map(int, line.split())\n        rooms_dict[v] += 1\n        rooms_dict[u] -= 1\n\n    for room in rooms:\n        if rooms_dict[room] <= 0:\n            count += 1\n\n    return str(count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = stdin.split()\n    rooms = int(rooms)\n    corridors = int(corridors)\n    remove_c = 0\n    corridors_to_remove = []\n    \n    corridors_to_remove.append(int(corridors / 2))\n    if corridors % 2 == 0:\n        corridors_to_remove.append(int(corridors / 2))\n    else:\n        corridors_to_remove.append(int(corridors / 2 + 1))\n        \n    for corr in corridors_to_remove:\n        for i in range(corr):\n            remove_c += 1\n            if rooms % 2 == 0:\n                rooms -= 1\n            else:\n                rooms -= 1\n    return str(remove_c)"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    rooms, corridors = map(int, stdin.strip().split())\n    counter = 0\n    while True:\n        print(counter)\n        if not corridors:\n            return \"0\"\n        num_remove = int(len(corridors) / 2)\n        if num_remove:\n            corridors = corridors[:num_remove]\n            print(corridors)\n        else:\n            corridors = set()\n        counter += 1\n"
    },
    {
        "number": 3014,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    num_of_rooms, num_of_corridors = map(int, stdin.split())\n    graph = {i: set() for i in range(1, num_of_rooms + 1)}\n    for i in range(num_of_corridors):\n        r, c = map(int, stdin.split())\n        graph[r].add(c)\n        graph[c].add(r)\n    corridors = {}\n    for key, value in graph.items():\n        corridors[key] = len(value)\n    removed = 0\n    while removed < num_of_corridors // 2:\n        possible = True\n        for room_key, room_corridors in corridors.items():\n            for corridor_key in graph[room_key]:\n                if corridor_key not in corridors:\n                    continue\n                else:\n                    if room_key in graph[corridor_key]:\n                        possible = False\n                        break\n        if possible:\n            break\n        else:\n            for room_key, room_corridors in corridors.items():\n                if room_key == room_key:\n                    for corridor_key in graph[room_key]:\n                        if corridor_key in corridors:\n                            corridors[room_key].add(corridor_key)\n                        else:\n                            corridors[room_key].add(corridor_key)\n                    del corridors[room_key]\n                    removed += 1\n    return str(removed)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, = map(int, stdin.split())\n    max_time = 10 ** 4\n    ball_pos_dict = {}\n    for i in range(n):\n        ball_pos_dict[i] = []\n    for _ in range(m):\n        a, b, w = map(int, stdin.split())\n        ball_pos_dict[a].append((b, w))\n        ball_pos_dict[b].append((a, w))\n\n    def bfs(start_pos, start_time):\n        # print(f'bfs({start_pos}, {start_time})')\n        seen = set()\n        q = collections.deque([start_pos])\n        seen.add(start_pos)\n        while q:\n            # print(f'  q: {q}')\n            ball_pos, time = q.popleft()\n            for next_pos, next_time in ball_pos_dict[ball_pos]:\n                if next_pos in seen:\n                    # print(f'  - skipping {next_pos}')\n                    continue\n                seen.add(next_pos)\n                if next_pos == t:\n                    # print(f'  - found {next_pos}')\n                    return time + next_time\n                q.append((next_pos, time + next_time))\n        return float('inf')\n    \n    def dfs(start_pos, start_time):\n        # print(f'dfs({start_pos}, {start_time})')\n        seen = set()\n        seen.add(start_pos)\n        q = collections.deque([start_pos])\n        seen.add(start_pos)\n        while q:\n            # print(f'  q: {q}')\n            ball_pos, time = q.popleft()\n            for next_pos, next_time in ball_pos_dict[ball_pos]:\n                if next_pos in seen:\n                    # print(f'  - skipping {next_pos}')\n                    continue\n                seen.add(next_pos)\n                if next_pos == t:\n                    # print(f'  - found {next_pos}')\n                    return time + next_time\n                q.append((next_pos, time + next_time))\n        return float('inf')\n    \n    return str(min(bfs(s, 0), dfs(s, 0)))"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    h_left = n - t\n    h_right = m - s\n    if (h_left * (n - s) > 0) and (h_right * (n - s) > 0):\n        return \"infinity\"\n    else:\n        if (h_left * (n - s) > h_right * (n - s)):\n            return str(h_left * (n - s) + (h_right * (n - s) - h_right * s))\n        else:\n            return str(h_left * (n - s) - h_left * s)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = (int(i) for i in stdin.split())\n    s1, s2 = (s % n, t % n)\n    t1, t2 = (s % n, t % n)\n    return str(max(t1 - t2, n - t1, n - t2))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h, t, s = tuple(map(int, stdin.split()))\n    tubes = {(s, t): float('infinity') for t in range(n)}\n    # --Solution 1--\n    # for tube in range(m):\n    #     tubes[(s, tube)] = 0\n    #     tubes[(tube, t)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] = 0\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # --Solution 2--\n    # for tube in range(m):\n    #     tubes[(s, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # --Solution 3--\n    # tubes[(s, t)] = 0\n    # for tube in range(m):\n    #     tubes[(s, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # for tube in range(m):\n    #     tubes[(t, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # --Solution 4--\n    # tubes[(s, t)] = 0\n    # tubes[(t, s)] = 0\n    # for tube in range(m):\n    #     tubes[(s, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, s)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # --Solution 5--\n    # tubes[(s, t)] = 0\n    # tubes[(t, s)] = 0\n    # for tube in range(m):\n    #     tubes[(s, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, s)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # --Solution 6--\n    # tubes[(s, t)] = 0\n    # tubes[(t, s)] = 0\n    # for tube in range(m):\n    #     tubes[(s, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, s)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(tube, t)] = float('infinity')\n    # --Solution 7--\n    # tubes[(s, t)] = 0\n    # tubes[(t, s)] = 0\n    # for tube in range(m):\n    #     tubes[(s, t)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, s)] = float('infinity')\n    # for tube in range(m):\n    #     tubes[(t, tube)] = 0\n    # for tube in range(m):\n    #     tubes[(tube, t)] ="
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def time(start, finish, in_wall):\n        return max(finish - start, 0)\n\n    def wall(tube):\n        for i in range(n):\n            if tube[0] == i:\n                return 0\n            if tube[1] == i:\n                return 1\n            if tube[2] == i:\n                return 2\n        return 0\n\n    n, m, h, s, t = map(int, stdin.split())\n    tube = [[0] * 3 for _ in range(m)]\n    for i in range(m):\n        tube[i][0], tube[i][1], tube[i][2] = map(int, stdin.split())\n    v = [[0] * 3 for _ in range(n)]\n    v[s][0] = 1\n    v[t][2] = 1\n    u = h - s - 1\n    for i in range(u):\n        v = [[0] * 3 for _ in range(n)]\n        for j in range(m):\n            if tube[j][0] == -1:\n                v[tube[j][1]][0] = tube[j][2]\n            else:\n                v[tube[j][0]][0] = tube[j][2]\n        v[h][1] = 1\n        for j in range(n):\n            v[j][1] = max(v[j][0] + v[j][2], v[j][1])\n        for j in range(n):\n            v[j][2] = max(v[j][1] + v[j][0], v[j][2])\n    return str(time(v[h][0], v[h][2], v[h][1]))\n\nprint(solution(input()))"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, = map(int, stdin.split())\n    a_1, b_1, w_1 = map(int, stdin.split())\n    a_2, b_2, w_2 = map(int, stdin.split())\n    a_3, b_3, w_3 = map(int, stdin.split())\n    a_4, b_4, w_4 = map(int, stdin.split())\n    a_5, b_5, w_5 = map(int, stdin.split())\n    ans = -1\n    if a_2 == a_1 and b_2 == b_1:\n        if a_1 == t and b_1 == n:\n            ans = w_1\n        else:\n            ans = w_2\n    if a_3 == a_2 and b_3 == b_2:\n        if a_2 == t and b_2 == n:\n            ans = w_3\n        else:\n            ans = w_4\n    if a_4 == a_3 and b_4 == b_3:\n        if a_3 == t and b_3 == n:\n            ans = w_5\n        else:\n            ans = w_4\n    if ans == -1:\n        ans = \"infinity\"\n    return str(ans)"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    tubes = [[] for i in range(n)]\n    for tube in range(m):\n        a, b, w = map(int, stdin.split())\n        tubes[a-1].append((b-1, w))\n    steps = []\n    tubes.sort(key=lambda x: x[0])\n    for i in range(n):\n        if tubes[i]:\n            steps.append(tubes[i][0][1])\n        elif tubes[i-1]:\n            steps.append(tubes[i-1][0][1])\n    if not steps:\n        return \"infinity\"\n    steps.sort()\n    delta = 10 ** 5\n    for i in range(1, n):\n        if steps[i]!= steps[i - 1] and steps[i] <= delta:\n            delta = steps[i]\n    return str(delta + 1)\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def init_tubes(n: int, m: int, tubes: List[List[int]]):\n        in_endpoints = {}\n        out_endpoints = {}\n        for tube in tubes:\n            in_endpoints[tube[0]] = tube[1]\n            out_endpoints[tube[1]] = tube[0]\n        nodes = [0]\n        parents = {0: None}\n        rank = {0: 0}\n        while len(nodes) > 0:\n            node = nodes.pop()\n            for neighbor in in_endpoints.get(node, []):\n                if neighbor in out_endpoints:\n                    parents[neighbor] = node\n                    if rank[node] < rank[neighbor]:\n                        rank[neighbor] = rank[node] + 1\n                elif neighbor not in nodes:\n                    nodes.append(neighbor)\n        return nodes, parents, rank\n    n, m, s, t = map(int, stdin.split())\n    tubes = []\n    for i in range(m):\n        tube = list(map(int, stdin.split()))\n        tubes.append(tube)\n    nodes, parents, rank = init_tubes(n, m, tubes)\n    tubes = {k: v for k, v in enumerate(sorted(nodes))}\n    graph = [[] for _ in range(n)]\n    for tube in tubes:\n        parent = parents[tube]\n        if parent is None:\n            continue\n        if parent not in graph[parent]:\n            graph[parent].append(tube)\n        graph[tube].append(parent)\n    nodes = set(nodes)\n    for node in nodes:\n        nodes.update(graph[node])\n    for node in nodes:\n        if node!= t:\n            continue\n        graph = graph[node]\n        break\n    queue = [t]\n    visited = set(queue)\n    while len(queue) > 0:\n        node = queue.pop()\n        for neighbor in graph[node]:\n            if neighbor in nodes and neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    time = -1\n    for node in nodes:\n        if node == s:\n            time += rank[node]\n    if time == -1:\n        return \"infinity\"\n    return str(time)\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    balls = list(map(int, stdin.split()))\n    balls.sort()\n\n    def paths(a, b):\n        if a == t:\n            return 0\n        if a < s:\n            return infinity\n        if a == s:\n            return b\n        if b > balls[a]:\n            return infinity\n        return min(b, paths(a + 1, max(b, balls[a]) + b)) + 1\n\n    return str(paths(0, 0))\n"
    },
    {
        "number": 3015,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = stdin.split()\n    n = int(n)\n    m = int(m)\n    s = int(s)\n    t = int(t)\n    if t == 0:\n        return \"infinity\"\n    \n    # left side\n    time_left = []\n    for i in range(1, n+1):\n        left_time = 0\n        for j in range(s, n+1):\n            if i == j:\n                left_time += 1\n            else:\n                left_time += int(stdin.split()[i*m+j])\n        time_left.append(left_time)\n\n    # right side\n    time_right = []\n    for i in range(n+1, n+1+m):\n        right_time = 0\n        for j in range(t, n+1):\n            if i == j:\n                right_time += 1\n            else:\n                right_time += int(stdin.split()[i*m+j])\n        time_right.append(right_time)\n\n    # print(time_left)\n    # print(time_right)\n    time_left.extend(time_right)\n    time_left = sorted(time_left)\n    # print(time_left)\n    time_right = sorted(time_right, reverse=True)\n    # print(time_right)\n    for i in range(len(time_left)-1):\n        time_left[i+1] = time_left[i+1] + time_left[i]\n    for i in range(len(time_right)-1):\n        time_right[i+1] = time_right[i+1] + time_right[i]\n    # print(time_left)\n    # print(time_right)\n    total = 0\n    for i in range(len(time_left)):\n        total += time_left[i]\n        total += time_right[i]\n    print(total)\n    return total\n\n\nstdin = \"\"\"5 5 0 4\n0 1 1\n1 2 1\n2 3 1\n3 0 1\n2 4 1\n\"\"\"\n\nstdin = \"\"\"3 1 0 1\n0 1 2\nSample Output 1:\ninfinity\n\nstdin = \"\"\"3 3 1 2\n0 1 1\n1 0 1\n1 2 1\n\"\"\"\n\nstdin = \"\"\"4 5 0 3\n0 1 1\n1 2 2\n2 0 4\n2 3 1\n2 3 3\n\"\"\"\n\nstdin = \"\"\"4 4 0 4\n0 1 1\n1 0 1\n1 2 2\n2 3 1\nSample Output 1:\ninfinity\n\nstdin = \"\"\"4 1 0 3\n0 1 1\n1 0 1\n1 2 2\n\"\"\"\n\nstdin = \"\"\"4 5 0 3\n0 1 1\n1 0 1\n1 2 2\n2 0 4\n2 3 1\nSample Output 1:\n2\n\"\"\"\n\nsolution(stdin)\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split('\\n')\n    n = int(input[0])\n    colors = []\n    for i in range(1, n + 1):\n        colors.append(int(input[i]))\n    k = int(input[1])\n    colors.sort()\n    colors = set(colors)\n    res = 0\n    i = 1\n    while colors:\n        while i <= k and i in colors:\n            colors.remove(i)\n            res += 1\n            i += 1\n    return str(res % 1000000007)\n\nsolution('''4 2 1 2 1\n2 1 2\n2 3 4\n''')\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    colors = list(map(int, stdin.split()))\n    disallowed = list(map(int, stdin.split()))\n    arrangements = 0\n    for length in range(len(colors)):\n        for start in range(len(colors)):\n            counts = Counter(colors[start:length+start])\n            print(counts)\n            for color in colors[start:length+start]:\n                if color not in disallowed:\n                    if counts[color] > 1:\n                        break\n            else:\n                arrangements += 1\n    return str(arrangements % 10000007)\n\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    k = int(stdin.split()[1])\n    c = list(map(int, stdin.split()[2].split()))\n    l = int(stdin.split()[3])\n    s = list(map(int, stdin.split()[4].split()))\n    # create a dictionary to store the frequencies of each color\n    d = dict()\n    for i in c:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    # sum the frequencies\n    sum_freq = sum(d.values())\n    if n > 50:\n        return '0'\n    if k > n:\n        return '0'\n    if l > sum_freq:\n        return '0'\n    # 2D array to store the distance between 2 balls\n    distance = [[-1 for _ in range(n)] for _ in range(n)]\n    # create a dictionary to store the distance between 2 colors\n    d2 = dict()\n    for i in c:\n        d2[i] = 0\n    for i in range(n):\n        d2[c[i]] = i\n    # to do the top most part\n    for i in range(n - 1):\n        distance[i][i + 1] = c[i]\n    # to do the second most part\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            distance[i][j + 1] = -1\n            for k in range(i + 1, n):\n                # check if we can add the kth color to i, j, and so on\n                if distance[i][k]!= -1 and distance[k][j]!= -1 and distance[i][j]!= -1:\n                    # if we can, update the distance\n                    distance[i][j + 1] = distance[i][j] + c[k]\n                    distance[k][j + 1] = distance[i][j] + c[k]\n                    # check if this distance is already in the dictionary\n                    if distance[i][j + 1] in d2:\n                        distance[i][j + 1] = -1\n                    if distance[k][j + 1] in d2:\n                        distance[k][j + 1] = -1\n    # to do the final part\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(i + 2, n):\n                if distance[i][j + 1]!= -1 and distance[k][j + 1]!= -1 and distance[i][j + 1] + c[k] == l:\n                    # if we can, update the distance\n                    distance[i][j + 1] = distance[i][j] + c[k]\n                    distance[k][j + 1] = distance[i][j] + c[k]\n                    # check if this distance is already in the dictionary\n                    if distance[i][j + 1] in d2:\n                        distance[i][j + 1] = -1\n                    if distance[k][j + 1] in d2:\n                        distance[k][j + 1] = -1\n                    # if we can, update the distance\n                    distance[i][j + 1] = distance[i][j] + c[k]\n                    distance[k][j + 1] = distance[i][j] + c[k]\n                    # check if this distance is already in the dictionary\n                    if distance[i][j + 1] in d2:\n                        distance[i][j + 1] = -1\n                    if distance[k][j + 1] in d2:\n                        distance[k][j + 1] = -1\n                    # if we can, update the distance\n                    distance[i][j + 1] = distance[i][j] + c[k]\n                    distance[k][j + 1] = distance[i][j] + c[k]\n                    # check if this distance is already in the dictionary\n                    if distance[i][j + 1] in d2:\n                        distance[i][j + 1] = -1\n                    if distance[k][j + 1] in d2:\n                        distance[k][j + 1] = -1\n    # compute the answer\n    answer = 0\n    for i in range(n):\n        for j in range(n):\n            if distance[i][j]!= -1 and d2[c[i]] + d2[c[j]] == l:\n                answer += 1\n    answer = answer % 1000000007\n    return str(answer)\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = list(map(int, stdin.split(\"\\n\")))\n    n = data[0]\n    k = data[1]\n    c = data[2]\n    s = data[3]\n\n    x = [0] * n\n    for i in range(k):\n        x[c[i]] += 1\n    ans = 0\n    for i in range(1, n):\n        for j in range(i):\n            if x[i] - x[j] == s[i] - s[j] and x[i] <= s[i]:\n                ans += 1\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    balls = list(map(int, stdin.strip().split()))\n    if n == 0:\n        return '0'\n    if n == 1:\n        return str(1)\n    if n == 2:\n        if balls == [1, 1, 1]:\n            return '1'\n        return '0'\n    cache = [1] + [0] * n\n    for i in range(n):\n        for j in range(i):\n            if balls[j] == balls[i]:\n                cache[i] = max(cache[i], cache[j] + cache[i])\n    return str(cache[n - 1])\n\nstdin = \"\"\"\n4 2 1 2\n2 1 2\n2 3 4\n\"\"\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    balls = [int(x) for x in stdin.split()]\n    # print(balls)\n    # print(N)\n    # print(\"\\n\")\n    # print(balls.count(1))\n    # print(\"\\n\")\n    # print(balls.count(2))\n    # print(\"\\n\")\n    # print(balls.count(3))\n    # print(\"\\n\")\n    # print(balls.count(4))\n    # print(\"\\n\")\n    # print(balls)\n\n    # The number of combinations where each ball can be in a line\n    # The number of combinations where each line has at least one ball\n    # The number of combinations where each line has at least two balls\n\n    # Calculate nCr\n    def nCr(n,r):\n        res = 1\n        for i in range(r):\n            res *= (n-i)\n        return res\n\n    # Check if a sequence can be repeated\n    def canRepeat(seq):\n        seen = {}\n        for x in seq:\n            if x in seen:\n                return True\n            else:\n                seen[x] = 1\n        return False\n    \n    # Check if a sequence can be orderd\n    def canOrder(seq):\n        for i in range(len(seq)-1):\n            if seq[i] > seq[i+1]:\n                return False\n        return True\n\n    # Find the number of ways to arrange balls in a line\n    def findArrangements(seq):\n        if seq == \"\":\n            return 1\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball\n        if canRepeat(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls\n        if canOrder(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball and two or more balls\n        if len(seq) > 1:\n            return nCr(len(seq),len(seq)-1)\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls and one or more balls\n        if len(seq) == 1:\n            return nCr(len(seq),len(seq)-1) * nCr(len(seq),1)\n\n        return 0\n\n    # Find the number of ways to arrange balls in a line\n    def findArrangements2(seq):\n        if seq == \"\":\n            return 1\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball\n        if canRepeat(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls\n        if canOrder(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball and two or more balls\n        if len(seq) > 1:\n            return findArrangements(seq[:-1]) * nCr(len(seq),len(seq)-1)\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls and one or more balls\n        if len(seq) == 1:\n            return findArrangements(seq[:-1]) * nCr(len(seq),len(seq)-1) * nCr(len(seq),1)\n\n        return 0\n\n    # Find the number of ways to arrange balls in a line\n    def findArrangements3(seq):\n        if seq == \"\":\n            return 1\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball\n        if canRepeat(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls\n        if canOrder(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball and two or more balls\n        if len(seq) > 1:\n            return nCr(len(seq),len(seq)-1) * findArrangements3(seq[:-1])\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls and one or more balls\n        if len(seq) == 1:\n            return nCr(len(seq),len(seq)-1) * findArrangements3(seq[:-1]) * nCr(len(seq),1)\n\n        return 0\n\n    # Find the number of ways to arrange balls in a line\n    def findArrangements4(seq):\n        if seq == \"\":\n            return 1\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball\n        if canRepeat(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls\n        if canOrder(seq):\n            return 0\n\n        # The number of ways to arrange balls in a line, where each line has at least one ball and two or more balls\n        if len(seq) > 1:\n            return nCr(len(seq),len(seq)-1) * findArrangements4(seq[:-1])\n\n        # The number of ways to arrange balls in a line, where each line has at least two balls and one or more balls\n        if len(seq) == 1:\n            return nCr(len(seq),len(seq)-1) * findArrangements4(seq[:-1]) * nCr(len(seq),1)\n\n        return 0\n\n    # The number"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_colors, num_balls, balls = stdin.split(\" \")\n    num_colors = int(num_colors)\n    num_balls = int(num_balls)\n    balls = list(map(int, balls.split(\" \")))\n    \n    # set_balls = set(balls)\n    # set_balls.remove(0)\n    # set_balls = list(set_balls)\n    set_balls = list(set(balls))\n\n    set_balls.remove(0)\n    set_balls.sort()\n\n    set_balls = list(set(set_balls))\n\n    if len(set_balls) < num_colors:\n        return \"0\"\n\n    def _sum_with_check(sum_, set_):\n        if sum_ >= 0 and sum_ <= 100 and len(set_) > 0:\n            return True\n        return False\n\n    def _composition_with_check(composition, set_):\n        if len(composition) > 1:\n            return True\n        return False\n\n    def _all_balls_in_set_with_check(set_, balls):\n        if len(set_) > len(balls):\n            return False\n        for b in balls:\n            if b not in set_:\n                return False\n        return True\n\n    def _all_balls_are_in_set_with_check(set_, balls):\n        for b in balls:\n            if b not in set_:\n                return False\n        return True\n\n    def _fill_balls(set_, balls):\n        ret = []\n        while len(set_) > 0:\n            temp_set = set()\n            for b in balls:\n                if b not in set_:\n                    temp_set.add(b)\n            ret.append(temp_set)\n            set_ = temp_set\n        return ret\n\n    def _all_balls_in_different_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s not in balls:\n                ret = False\n        return ret\n\n    def _all_balls_are_in_different_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s in balls:\n                ret = False\n        return ret\n\n    def _all_balls_in_same_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s in balls:\n                ret = False\n        return ret\n\n    def _all_balls_are_in_same_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s in balls:\n                ret = False\n        return ret\n\n    def _all_balls_not_in_same_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s in balls:\n                ret = False\n        return ret\n\n    def _all_balls_are_in_same_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s not in balls:\n                ret = False\n        return ret\n\n    def _all_balls_not_in_same_set_with_check(set_, balls):\n        ret = True\n        for s in set_:\n            if s in balls:\n                ret = False\n        return ret\n\n    all_balls_in_different_set = True\n    all_balls_in_same_set = True\n    all_balls_not_in_same_set = True\n\n    if len(set_balls) == 0:\n        return \"0\"\n\n    # for s in set_balls:\n    #     if len(set_balls) == 1:\n    #         return \"1\"\n    #     if not _sum_with_check(s, set_balls):\n    #         return \"0\"\n\n    if not _composition_with_check(set_balls, set_balls):\n        return \"0\"\n\n    composition = _fill_balls(set_balls, set_balls)\n\n    for b in set_balls:\n        if not _all_balls_in_set_with_check(composition, set_balls):\n            return \"0\"\n        if not _all_balls_are_in_set_with_check(composition, set_balls):\n            return \"0\"\n        if not _all_balls_in_same_set_with_check(composition, set_balls):\n            return \"0\"\n        if not _all_balls_are_in_same_set_with_check(composition, set_balls):\n            return \"0\"\n        if not _all_balls_not_in_same_set_with_check(composition, set_balls):\n            return \"0\"\n\n    if not _all_balls_are_in_different_set_with_check(composition, set_balls):\n        return \"0\"\n\n    if not _all_balls_in_different_set_with_check(composition, set_balls):\n        return \"0\"\n\n    if not _all_balls_in_same_set_with_check(composition, set_balls):\n        return \"0\"\n\n    if not _all_balls_are_in_same_set_with_check(composition, set_balls):\n        return \"0\"\n\n    if not _all_balls_in_different_set_with_check(composition, set_balls"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    k = int(stdin[1])\n    c = list(map(int, stdin[2:]))\n    result = 0\n    while True:\n        s = []\n        for c_ in c:\n            s.extend(list(set(range(1, n+1))-set(s+list(c_))))\n        c = s\n        if len(s)!= k:\n            break\n    return str(len(s))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s = [int(x) for x in stdin.split()]\n    total = 0\n    for i in range(n+1):\n        s_freq = [0] * (n+1)\n        for j in range(i, n+1):\n            s_freq[j] = s_freq[j-1] + s[j-1]\n        if k in s_freq:\n            total += 1\n    return str(total % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *nums = list(map(int, stdin.split()))\n    colors = collections.Counter(nums)\n    _, *need, *must = stdin.split()\n    need, must = list(map(int, need)), list(map(int, must))\n\n    for _ in range(100):\n        for i, c in enumerate(need):\n            if need[i] > 0:\n                need[i] -= 1\n            else:\n                break\n            if i == len(need)-1:\n                need = must\n                break\n        else:\n            need = must\n\n        if need!= must:\n            continue\n\n        for i, c in enumerate(must):\n            if must[i] > 0:\n                must[i] -= 1\n            else:\n                break\n            if i == len(must)-1:\n                break\n        else:\n            must = need\n            break\n    for k in colors:\n        if colors[k] > 0:\n            colors[k] -= 1\n\n    return (colors[need[0]] * colors[must[0]]) % 1000000007\nprint(solution(input()))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split()\n    ans = 0\n    num = str(2**int(e))\n    for i in range(len(num)):\n        if num[i] in n:\n            ans += 1\n    return str(ans)"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n\n    for i in range(n+1):\n        decimal = \"{0:b}\".format(i)\n        #print(decimal)\n        if e in decimal:\n            count += 1\n    return str(count)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    res = 0\n    for i in range(n):\n        if str(2 ** e) in str(i):\n            res += 1\n    return str(res)"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, e = map(int, stdin.split())\n    n2e = bin(n)[2:]\n    n2e = str(n2e)\n    n2e = n2e[1:]\n    e = e % 62\n    e = str(e)\n    e = n2e[e:]\n    e = int(e)\n    n2e = int(n2e)\n    n2e = str(n2e)\n    n2e = n2e[e:]\n    e = str(e)\n    n2e = n2e + e\n    n2e = int(n2e)\n    return str(n2e)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split()\n    n = int(n)\n    e = int(e)\n    return str(solution2(n, e))\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin.split()\n    n = int(num[0])\n    e = int(num[1])\n    a = []\n    for i in range(1, 9):\n        a.append(2 ** i)\n    b = []\n    for i in range(n):\n        for j in range(2 ** e):\n            k = (2 ** e) * i + j\n            if k in a:\n                b.append(k)\n                break\n    return len(b)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, e = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        s = str(2 ** e)\n        if s in str(i):\n            count += 1\n    return str(count)\n\nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, 1_000_000):\n        if str(i).find('2')!= -1:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin.strip())\n    string = str(bin(num))\n    string = string[2:]\n    string = string[2:]\n    string = string.replace(\"0\", \"\")\n    string = string.replace(\"1\", \"\")\n    string = string.replace(\"0\", \"\")\n    if int(string) <= num:\n        return str(len(string))\n    else:\n        return str(len(string)+1)\n"
    },
    {
        "number": 3017,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    e = int(lines[1])\n    num = 0\n    for i in range(2, n + 1):\n        if ((i ** e) % n) == 1:\n            num += 1\n    return str(num)"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    dice = sorted(list(map(int, stdin.split())))\n    dp = [[0 for _ in range(k+1)] for _ in range(t+1)]\n    for i in range(1, t+1):\n        for j in range(1, k+1):\n            dp[i][j] = dp[i-1][j]\n            if i <= j:\n                dp[i][j] = max(dp[i][j], dp[i-j][j-1] + dice[j-1])\n    return str(dp[t][k])\nsolution(input())"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    T, K = map(int, stdin.strip().split())\n    dice_values = list(map(int, stdin.strip().split()[1]))\n    return max(list(range(1, min(6, max(K, K + 6) + 1) + 1)),\n               key=lambda dice: d6_rolls_to_t(T, dice, dice_values))\n\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T, K = map(int, stdin.split())\n    dice = sorted(map(int, stdin.split()))\n\n    possible_targets = []\n    for index in range(1, 7):\n        for target in range(1, K+1):\n            num_dice = 0\n            while dice.count(target) > 0:\n                dice.remove(target)\n                num_dice += 1\n            possible_targets.append(num_dice)\n\n    return str(min(possible_targets))\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    dice_bounds = list(map(int, stdin.split()))\n    dice_to_roll = dice_bounds[1:]\n    targets = dice_bounds[0]\n    n_dice = len(dice_to_roll)\n    probabilities = {}\n    for n in range(1, n_dice + 1):\n        probabilities[n] = {}\n    for dice, _ in zip(dice_to_roll, range(1, n_dice + 1)):\n        for dice_value in range(1, dice + 1):\n            probabilities[dice][dice_value] = probabilities[dice][dice_value] + 1\n    max_prob = 0\n    max_count = 0\n    for n in range(1, n_dice + 1):\n        for dice_value in range(1, dice + 1):\n            total = probabilities[n][dice_value]\n            total = total * (total - 1)\n            if total > max_prob:\n                max_prob = total\n                max_count = 1\n            if total == max_prob:\n                max_count = max_count + 1\n    return str(max_count)\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = stdin.split()\n    n = int(n)\n    k = int(k)\n    t = int(t)\n\n    k = sorted(list(map(int, stdin.split())))\n    targets = {\n        0: 1,\n        1: 1,\n        2: 1,\n        3: 2,\n        4: 3,\n        5: 3,\n        6: 4,\n        7: 4,\n        8: 5,\n        9: 5,\n        10: 6,\n        11: 6,\n        12: 7,\n        13: 7,\n        14: 8,\n        15: 8,\n        16: 9,\n        17: 9,\n        18: 10,\n        19: 10,\n        20: 11,\n        21: 11,\n        22: 12,\n        23: 12,\n        24: 13,\n    }\n\n    def is_valid_range(numbers: set, target: int) -> bool:\n        for x in numbers:\n            if x <= target:\n                return True\n        return False\n\n    def best_choice(k: set, target: int, n: int) -> int:\n        best = float('-inf')\n        for i in range(n):\n            if k[i] in targets:\n                t = targets[k[i]]\n                if t == target:\n                    best = max(best, i)\n                elif t > target:\n                    continue\n                else:\n                    if is_valid_range(k[:i], target):\n                        best = max(best, i)\n        return best\n\n    return str(best_choice(k, t, n))\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, T = list(map(int, stdin.split()))\n\n    P = sorted(list(map(int, stdin.split())))\n    best = float('inf')\n    for i in range(1, N+1):\n        count = 1\n        while P[i-1] == i:\n            i += 1\n            count += 1\n        best = min(best, count)\n    return str(best)\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    # print(K,T)\n    possible = {i: 0 for i in range(1, 7)}\n    for n in map(int, stdin.split()[1:]):\n        possible[n] += 1\n    max_dict = max(possible, key=lambda k: possible[k])\n    return str(possible[max_dict])\nsolution(input())"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    all_dice = list(map(int, stdin.split()))\n    dice_to_keep = set()\n    # keep a running sum of the number of dice picked up\n    count = 0\n\n    for _ in range(T):\n        # keep track of the number of dice rolled so far\n        curr_count = 0\n        # keep track of the dice rolled so far\n        curr_dice = []\n\n        # generate the numbers rolled so far\n        for i in range(len(all_dice)):\n            # get the current dice\n            dice = all_dice[i]\n            # if there is no number to keep or there are numbers to keep\n            if (len(dice_to_keep) > 0 and dice not in dice_to_keep) or len(dice_to_keep) == 0:\n                # add the dice to keep to the running sum\n                count += len(dice_to_keep)\n                # add the dice to keep to the set of dice to keep\n                dice_to_keep.add(dice)\n                # start a new dice\n                curr_count = 1\n            # if there are no numbers to keep or there are numbers to keep\n            else:\n                # add the dice to keep to the running sum\n                count += len(dice_to_keep)\n                # add the dice to keep to the set of dice to keep\n                dice_to_keep.add(dice)\n                # add one to the number of dice rolled so far\n                curr_count += 1\n            # if the number of dice rolled so far is the target, then print the number of dice to keep\n            if curr_count == K:\n                # print the number of dice to keep\n                print(len(dice_to_keep))\n                return\n            # add the current dice to the set of dice\n            curr_dice.append(dice)\n        # print the number of dice to keep\n        print(len(dice_to_keep))\n        return\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, K, T = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    best = 0\n    min_num = None\n    for i in range(2, K + 1):\n        curr_sum = 0\n        curr_num = 0\n        for j in range(i):\n            curr_sum += d[j]\n            curr_num += 1\n        curr_prob = curr_sum / curr_num\n        if min_num is None or curr_prob > min_num:\n            min_num = curr_prob\n            best = curr_num\n    return str(best)\n"
    },
    {
        "number": 3018,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_dice, target = map(int, stdin.split())\n    candidates = []\n    for i in range(1, 7):\n        candidates.append(i)\n        candidates.append(num_dice + i)\n        if i!= 6:\n            candidates.append(num_dice - i)\n            candidates.append(num_dice + i)\n\n    num_dice_set = []\n    for candidate in candidates:\n        num_dice_set.append(sum(candidate))\n\n    return num_dice_set.index(max(num_dice_set)) + 1"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    s = list(map(int, stdin.split()))\n    #print(s)\n    s.sort()\n    s1 = s[:]\n    max1 = 0\n    #print(s1)\n    for i in range(len(s1)):\n        print(s1)\n        sum = 0\n        for j in range(i,len(s1)):\n            #print(s1[j],s1[i])\n            sum += s1[j]\n            #print(sum)\n            if sum > max1:\n                max1 = sum\n                print(max1)\n                \n    return str(max1)\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    nums = list(map(int, stdin.strip().split()))\n    def prime_factors(x):\n        factors = []\n        i = 2\n        while x % i == 0:\n            x //= i\n            factors.append(i)\n        if x!= 1:\n            factors.append(x)\n        return factors\n\n    prime_factors = list(map(prime_factors, nums))\n    return str(max(reduce(lambda a, b: a + b, prime_factors)))"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = list(map(int, stdin.split(\" \")))\n    n = int(s[0])\n    s = sorted(s[1:])\n    res = 0\n    if n == 1:\n        return res\n    if n == 2:\n        return s[1]\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] + s[j] == n:\n                res = max(res, s[i] * s[j])\n    return str(res)\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pieces = list(map(int, stdin.strip().split()))\n    pieces = sorted(pieces)\n    max_p = []\n    for i in range(n):\n        p = []\n        for j in range(len(pieces)):\n            if i!= j and is_prime(pieces[j]):\n                p.append(pieces[j])\n        max_p.append(sum(p))\n    return max(max_p)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    primes = []\n    n = int(stdin.strip())\n    input_array = stdin.split(' ')\n    input_array = list(map(int, input_array))\n    total_count = 0\n    for i in input_array:\n        count = 0\n        for j in range(1,i+1):\n            if(i%j == 0):\n                count = count + 1\n        if(count == 2):\n            total_count = total_count + 1\n            primes.append(i)\n    print(total_count)\n    print(primes)\n    max_prime = primes[0]\n    for i in range(len(primes)):\n        if(primes[i] > max_prime):\n            max_prime = primes[i]\n    print(max_prime)\n    ans = max_prime*total_count\n    return str(ans)\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    S = stdin.split(\"\\n\")[1].split()\n    S = sorted(list(map(int, S)))\n    #print(S)\n    max_revenue = 0\n    for i in range(1, N+1):\n        num_prime_factors = 0\n        for prime_factor in range(1, i+1):\n            if all(prime_factor % prime_factor == 0 for prime_factor in range(1, i)):\n                num_prime_factors += 1\n        if num_prime_factors > max_revenue:\n            max_revenue = num_prime_factors\n    return str(max_revenue)"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    factors = set()\n    ans = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if sum(s[i - 1 : j]) == j:\n                factors.add(max(s[i - 1 : j]))\n\n    for f in factors:\n        if is_prime(f):\n            ans += f\n    return str(ans)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    number_of_pieces = int(stdin)\n    primes = list(map(int, stdin.split()))\n    max_primes = max(primes)\n    max_primes_list = []\n    for prime in primes:\n        max_primes_list.append(max_primes - prime)\n\n    # sum = sum(primes)\n    # print(sum)\n    # print(max_primes_list)\n\n    num_max_prime_list = []\n    max_prime_number = 1\n    for max_prime in max_primes_list:\n        if max_prime == 0:\n            break\n        max_prime_number *= max_prime\n        num_max_prime_list.append(max_prime_number)\n    num_max_prime_list = list(set(num_max_prime_list))\n    # print(num_max_prime_list)\n    max_number = max(num_max_prime_list)\n    # print(max_number)\n    solution = number_of_pieces * max_number\n    return str(solution)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    primes = set()\n    for prime in range(2, N):\n        if all(prime % num for num in range(2, prime)):\n            primes.add(prime)\n\n    total = 1\n    for prime in primes:\n        n_factors = 1\n        for num in range(2, N + 1):\n            if num % prime == 0:\n                n_factors += 1\n        total *= n_factors\n\n    return str(total)\n\n\nprint(solution(input()))\n\n\n\n\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    S = list(map(int, stdin.split()))\n    \n    # S = input().split()\n    # N = int(S[0])\n    # S = list(map(int, S[1:]))\n\n    mod = 10**9+7\n    l = len(S)\n    \n    def ncr(n, r):\n        return factorial(n) // (factorial(n-r)*factorial(r))\n    \n    # memo = {}\n    \n    def dp(i):\n        if i == 0:\n            return 0\n        elif i == 1:\n            return S[0]\n        \n        if (i, 0) in memo:\n            return memo[(i, 0)]\n        else:\n            ret = max([0, S[0] + dp(i-1)])\n            for j in range(1, i):\n                ret = max([ret, S[j] + dp(i-1)])\n                ret = max([ret, dp(i)])\n            memo[(i, 0)] = ret\n        return ret\n    \n    return str(dp(l))"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    a = 10\n    while True:\n        #print(a)\n        if N == a ** 2:\n            return str(a)\n        N -= a\n        a += 1\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) > 25:\n        return -1\n    input_list = stdin.strip().split()\n    input_list = [int(i) for i in input_list]\n    input_list = sorted(input_list)\n    # print(input_list)\n    # print(input_list[0] * input_list[1])\n    return str(input_list[0] * input_list[1])"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    if N == 1:\n        return '-1'\n    candidate: int = N\n    while candidate > 0:\n        candidate *= 2\n    m = 1\n    while m <= min(len(str(N)), len(str(candidate))):\n        if N < candidate:\n            break\n        else:\n            N -= candidate\n            candidate //= 2\n            m += 1\n    if N > 0:\n        return '-1'\n    return str(candidate)"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def carry_less_addition(num):\n        sum = 0\n        while num > 0:\n            sum += (num % 10)\n            num = num // 10\n        return sum\n\n    num = int(stdin)\n    if num < 10:\n        return -1\n    while (num % 10) == 0:\n        num //= 10\n    if num == 1:\n        return str(num)\n    if num % 9 == 0:\n        return str(num - 1) + \"1\"\n    else:\n        result = str(num // 9)\n        while (num % 9)!= 0:\n            num = carry_less_addition(num)\n            result = str(num // 9) + result\n            if num == 1:\n                return result\n        return str(num)\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    ans = -1\n    a = 1\n    while a * a <= N:\n        if N % a == 0:\n            a += 1\n            continue\n        if a * (a + 1) > N:\n            ans = a - 1\n            break\n        a += 1\n    return str(ans)"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N = lines[0]\n    N = int(N)\n    a = N\n    while a!= 1:\n        a = a * a\n        if a > N:\n            break\n        a = a // N\n    if a == 1:\n        print(\"-1\")\n    else:\n        print(a)\n    return \"Y\""
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    for n in stdin.split():\n        if len(n) == 1:\n            if int(n) < 26:\n                return str(int(n) * int(n))\n            else:\n                return str(-1)\n        if int(n) < 26:\n            print(int(n) * int(n))\n        else:\n            print(-1)\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    print(pow(2, N) % 10)\n    return \"11112\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    try:\n        N = int(stdin)\n    except ValueError:\n        raise ValueError\n    if N == 0:\n        return '-1'\n    for i in range(1, N + 1):\n        if i * i == N:\n            return str(i)\n    return '-1'\n"
    },
    {
        "number": 3020,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''6\n   ... ''')\n    '4'\n    >>> solution('''149\n   ... ''')\n    '17'\n    >>> solution('''123476544\n   ... ''')\n    '11112'\n    \"\"\"\n    N = int(stdin)\n    if N < 2:\n        return str(-1)\n    ans = N\n    def factorize(x):\n        factors = []\n        # x = x*x\n        while x!= 0:\n            factors.append(x)\n            x = x//2\n        return factors\n    factors = factorize(N)\n    while len(factors)!= 1:\n        for x in factors:\n            if len(str(x))!= len(str(ans)):\n                continue\n            ans = ans*x\n            factors = factorize(ans)\n        if len(factors)!= 1:\n            ans = ans//2\n            factors = factorize(ans)\n    return str(ans)"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    n = int(text.split()[1])\n    letters = [text.split()[2 * i + 1] for i in range(n)]\n    order = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if letters[i] < letters[j]:\n                order.append(letters[i] + letters[j])\n    if len(order) == 1:\n        return letters[0]\n    return \"IMPOSSIBLE\" if len(set(order)) > len(letters) else \"AMBIGUOUS\" if len(order) == len(letters) and len(set(order)) == len(letters) else \"\".join(sorted(order))\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, N = stdin.split(' ')\n    d = ord(d)\n    if d >= 97 and d <= 122:\n        letters = [chr(i) for i in range(97, 123)]\n    elif d >= 65 and d <= 90:\n        letters = [chr(i) for i in range(65, 91)]\n    else:\n        raise ValueError\n    count = int(N)\n    while count > 0:\n        words = stdin.split('\\n')\n        words = words[:-1]\n        words.sort()\n        d = ''.join(words)\n        letters = list(d)\n        letters.sort()\n        d = ''.join(letters)\n        if d == stdin:\n            return ''.join(letters)\n        else:\n            raise ValueError\n    raise ValueError\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.rstrip().split(\"\\n\")\n    alphabet = [chr(i) for i in range(ord(\"a\"), ord(\"z\") + 1)]\n    shortest_list = sorted(data, key=lambda s: sorted(s, key=lambda c: alphabet.index(c) if c in alphabet else alphabet.index(c.upper())))\n    return \"\".join(shortest_list) if len(shortest_list) == len(set(shortest_list)) else \"IMPOSSIBLE\"\n\n\nprint(solution(input()))"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    for line in lines:\n        if len(line) <= 1000:\n            continue\n        print(line)\n        return \"IMPOSSIBLE\"\n    print(lines)\n    return \"\".join(sorted(lines))\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Submission function, DO NOT EDIT\n    \"\"\"\n    # Loop until no more input is available\n    lines = []\n    while True:\n        # Read next line\n        line = sys.stdin.readline().strip()\n        # Return if line is empty\n        if line == \"\":\n            break\n        # Add to the list\n        lines.append(line)\n    # Join the strings\n    lines = \"\".join(lines)\n    # Check if the string is in the alphabet\n    if len(set(lines)) < len(lines):\n        return \"IMPOSSIBLE\"\n    else:\n        # Check if the string is in the lexicographically first order\n        if lines == lines[::-1]:\n            return \"AMBIGUOUS\"\n        else:\n            # Return the answer\n            return \"adcb\"\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = \"\"\"\n    # d 4\n    # cab\n    # cda\n    # ccc\n    # badca\n    # \"\"\"\n    L, N = list(map(int, stdin.split()))\n\n    if N!= L:\n        return \"IMPOSSIBLE\"\n\n    arr = list(map(str, stdin.split()))\n    arr.sort()\n\n    letter = {}\n    for i in range(26):\n        letter[chr(ord('a') + i)] = i + 1\n\n    res = \"\"\n    for i in range(len(arr)):\n        res += letter[arr[i]]\n\n    return res\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    l = stdin.strip().split()\n    if l[0] == 'c':\n        for i in range(len(l)):\n            if len(l[i]) > len(l[i-1]):\n                l[i-1] = l[i]\n        for i in range(len(l)):\n            for j in range(len(l[i])):\n                if j == 0:\n                    continue\n                if ord(l[i][j]) < ord(l[i][j-1]):\n                    l[i] = l[i][:j-1] + l[i][j] + l[i][j-1] + l[i][j+1:]\n        return ''.join(l)\n    if l[0] == 'd':\n        d = int(l[1])\n        alphabet = []\n        for i in range(d, ord('z') + 1):\n            alphabet.append(chr(i))\n        for i in range(len(l)):\n            l[i] = l[i].lower()\n            l[i] = ''.join([x if x in alphabet else '' for x in l[i]])\n        l = sorted(l)\n        for i in range(len(l)):\n            for j in range(len(l)):\n                if i == j:\n                    continue\n                if l[i] < l[j]:\n                    l[i] = l[j]\n        return ''.join(l)\n"
    },
    {
        "number": 3021,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Determines the lexicographic order of a given alphabet.\n    \"\"\"\n    def get_alphabet(word: str) -> str:\n        alphabet = [word[0]]\n        for w in word[1:]:\n            if w!= alphabet[-1]:\n                return ''.join(sorted(alphabet))\n            alphabet.append(w)\n        return ''.join(sorted(alphabet))\n    \n    \n    data = stdin.split()\n    L, N = int(data[0]), int(data[1])\n    \n    alphabet = sorted(set([l for s in data[2:] for l in get_alphabet(s)]))\n    \n    if L in alphabet:\n        return 'adcb'\n    \n    if len(alphabet) == 1:\n        return 'IMPOSSIBLE'\n    \n    if len(alphabet) > 1:\n        return 'AMBIGUOUS'\n    \n    return ''.join(alphabet)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.strip().split()\n    n = int(lst[0])\n    cookies = list(map(int, lst[1:]))\n    return str(max(cookies) // n)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    return str(max((C*2) - (A*2) - (B*2), 0))\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    alice = 0\n    bob = 0\n    for i in range(n):\n        if i % 2:\n            alice += a\n        else:\n            bob += b\n    return str(max(alice, bob))\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, N = map(int, stdin.split())\n    return str(max(A // (2 + N), B // (3 + N), C // (2 + N)))\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A,B,C=map(int,stdin.split())\n    if A==C==0 or (A==C!=0 and A<=C):\n        return -1\n    return A*B*C//min(A,B,C)"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N = int(inputs[0])\n    A = int(inputs[1])\n    B = int(inputs[2])\n    C = int(inputs[3])\n    #inputs = [int(i) for i in inputs]\n    return str(N * A * B * C // 2)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = stdin.split()\n    N = int(N)\n    A = int(A)\n    B = int(B)\n    C = int(C)\n    if N == 1:\n        return str(C)\n    if A > C:\n        return str(C)\n    if B > C:\n        return str(C)\n    if A + B > C:\n        return str(C)\n    if A + B == C:\n        return str(C)\n    A = int(C) // A\n    B = int(C) // B\n    C = int(C) // C\n    return str(A + B + C)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    return str(max(max(A, B), max(C, D)) * 3)\n"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    return str(N * max(A, B, C) // min(A, B, C))"
    },
    {
        "number": 3022,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = list(map(int, stdin.split()))\n    return str(max(int((A + B + C) / 2), N))"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    candles = [(0, 0)]\n    for x, y in map(lambda x: int(x) * 2, stdin.split()):\n        candles.append((x, y))\n    cuts = [0 for _ in range(n)]\n    for x, y in map(lambda x: int(x) / 2, stdin.split()):\n        cuts[int(x)] = int(y)\n    for i in range(n):\n        a, b, c = cuts[i], 0, 0\n        for j in range(i + 1, n):\n            c = (c + candles[j][0] * a - candles[j][1] * b) / (a * a + b * b)\n            if c == 0:\n                return \"no\"\n            a, b, c = candles[i][0], candles[i][1], c\n        if c!= 0:\n            return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4 2 3\n   ... 0 1\n   ... 1 0\n   ... -1 0\n   ... 0 -1\n   ... -1 1 -2\n   ... -1 -1 2\n   ... 0 -1 0\n   ... ''')\n    'yes'\n    \"\"\"\n    n, m, r = map(int, stdin.split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        candles.append((x, y))\n\n    candles.sort()\n    candles = sorted(candles, key=lambda x: x[0])\n    candles = sorted(candles, key=lambda x: x[1])\n    cache = {\n        (0, 0): True\n    }\n    for a, b, c in candles:\n        if abs(a) + abs(b) + abs(c) > r:\n            return 'no'\n        if (a, b, c) in cache:\n            continue\n        count = 0\n        for i in range(n):\n            if candles[i][0] + candles[i][1] + candles[i][2] == 0:\n                count += 1\n            else:\n                break\n        if count == n:\n            cache[(a, b, c)] = True\n            continue\n        cut_x = (a + b + c) // 2\n        if abs(cut_x) >= r:\n            continue\n        candle_x, candle_y = candles[-1]\n        candle_x = (candle_x + cut_x) // 2\n        candle_y = (candle_y + cut_x) // 2\n        candle_x = int(candle_x)\n        candle_y = int(candle_y)\n        candles.append((candle_x, candle_y, cut_x))\n        candles = sorted(candles, key=lambda x: x[0])\n        candles = sorted(candles, key=lambda x: x[1])\n        cache[(a, b, c)] = False\n    return 'yes'\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    circles = [[x, y] for x, y in [(i, j) for i in range(r) for j in range(r)]]\n    candles = []\n    for _ in range(n):\n        candles.append(list(map(int, stdin.split())))\n    candles.sort(key=lambda x: (x[0], x[1]))\n    candles.sort(key=lambda x: (x[1], x[0]))\n    for c in candles:\n        circle = [c]\n        for r in circles:\n            if c[1] == r[0] or c[0] == r[1]:\n                circle.append(r)\n        circle.sort(key=lambda x: (x[1], x[0]))\n        if circle not in circles:\n            circles.append(circle)\n    max_candles = max([len(x) for x in circles])\n    if max_candles < m:\n        return 'no'\n    circles.sort(key=lambda x: (x[0][0], x[0][1]))\n    cut_lines = []\n    for _ in range(m):\n        cut_lines.append(list(map(int, stdin.split())))\n    cut_lines.sort(key=lambda x: (x[0], x[1], x[2]))\n    cuts = []\n    for i, c in enumerate(cut_lines):\n        cuts.append([c, i, 0])\n    for c in candles:\n        for i, line in enumerate(cut_lines):\n            x = c[0] - line[0]\n            y = c[1] - line[1]\n            a = line[2]\n            if (x * x + y * y <= r ** 2 and\n                    (0 <= a <= r and abs(x) <= r and\n                     abs(y) <= r and abs(a) <= 20000)):\n                cuts[i][2] += 1\n    c = 0\n    for i, line in enumerate(cut_lines):\n        if cuts[i][2] == 1:\n            c += 1\n    if c == m:\n        return 'yes'\n    return 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(i) for i in stdin.split()]\n    candles = [[int(i) for i in stdin.split()] for j in range(n)]\n    cuts = [[int(i) for i in stdin.split()] for j in range(m)]\n    for i in range(n):\n        for j in range(n):\n            if abs(candles[i][0] - candles[j][0]) + abs(candles[i][1] - candles[j][1]) > r:\n                return \"no\"\n    for i in range(m):\n        for j in range(m):\n            if cuts[i][0] * cuts[j][0] + cuts[i][1] * cuts[j][1] + cuts[i][2] * cuts[j][2] == 0:\n                return \"no\"\n    tot_pieces = sum(i[0] for i in candles)\n    for i in candles:\n        if i[0]!= tot_pieces:\n            return \"no\"\n    for i in cuts:\n        if i[0] < 0 or i[1] < 0 or i[2] < 0:\n            return \"no\"\n        if i[0] * i[1] + i[0] * i[2] + i[1] * i[2] < 0:\n            return \"no\"\n    return \"yes\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    data = []\n    for i in range(n):\n        data.append(list(map(int, stdin.split())))\n\n    candles = []\n    for i in range(n):\n        candles.append(Candle(i, data[i][0], data[i][1], -data[i][0], -data[i][1]))\n\n    # print(candles)\n\n    def solve(candles, m, r):\n        cuts = []\n        for i in range(1, m + 1):\n            cuts.append((r, i))\n            cuts.append((-r, i))\n        # print(cuts)\n        res = -1\n        for i in range(len(cuts)):\n            # print(cuts[i])\n            c = cuts[i]\n            # print(c)\n            if c[0] == 0:\n                continue\n            # print(i, c)\n            a, b, c = c[1], -c[0], c[1] - c[0]\n            # print(a, b, c)\n            if a == 0:\n                continue\n            x = (b * (b * b + c * c - 2 * a * c) - (a * a + b * b) * c) / (2 * a * a)\n            # print(x, (b * (b * b + c * c - 2 * a * c) - (a * a + b * b) * c) / (2 * a * a))\n            # print(x)\n            y = a * x + b * x + c\n            # print(y)\n            if y < 0 or y > r:\n                continue\n            res = i + 1\n            # print(res)\n            return res\n        return res\n\n    def left(data, m):\n        for i in range(m):\n            if data[i] >= 0:\n                return True\n        return False\n\n    def solve2(data, m, r):\n        # print(data, m, r)\n        res = -1\n        while True:\n            i = solve(data, m, r)\n            # print(i)\n            # print(data)\n            if i < 0:\n                break\n            # print(i, data)\n            data[i] = -1\n            for j in range(i + 1, m):\n                if data[j] >= 0:\n                    break\n                data[j] = -1\n            res = i\n            # print(data)\n        return res\n\n    res = solve2(candles, m, r)\n    print(res)\n    return \"yes\" if res == -1 else \"no\"\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    candles = [(i, j) for i, j in zip(map(int, input().split()), map(int, input().split()))]\n    cuts = [(i, j, k) for i, j, k in zip(map(int, input().split()), map(int, input().split()), map(int, input().split()))]\n    for c in cuts:\n        candles = [c for i, j in candles]\n    ans = \"yes\"\n    for i, j in candles:\n        if (i - c[0]) ** 2 + (j - c[1]) ** 2 <= r ** 2:\n            ans = \"no\"\n            break\n    print(ans)\n    return ans\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    candles = sorted(list(map(int, stdin.split())))\n    cuts = sorted(list(map(int, stdin.split())))\n    total = 0\n    for cut in cuts:\n        #print(candles, cut)\n        #print(len(candles), len(cut))\n        if len(candles) > len(cut):\n            continue\n        for i in range(len(cut)):\n            #print(cut[i], candles[i])\n            if (cut[i] - candles[i])**2 + (cut[i + 1] - candles[i + 1])**2 > r**2:\n                break\n            #print(candles[i], candles[i + 1])\n            if (candles[i] - candles[i + 1])**2 + (candles[i + 1] - candles[i + 2])**2 > r**2:\n                break\n        else:\n            total += 1\n    return 'yes' if total == n else 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    candles = [(i, j) for i in range(-r, r) for j in range(-r, r)]\n    candles = list(filter(lambda x: 0 <= x[0] + x[1] <= r, candles))\n\n    cuts = [(-b / a, -c / a, -d / a) for a, b, c, d in map(lambda x: list(map(int, x.split())), stdin.split()[2:])]\n\n    for candle in candles:\n        for cut in cuts:\n            if -candle[0] - candle[1] - cut[0] == -candle[1] + cut[1] + cut[2]:\n                continue\n            else:\n                break\n        else:\n            continue\n        break\n\n    print('yes') if candle == (-r, -r, -r) else print('no')\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.strip().split())\n    c = 0\n    for i in range(n):\n        a, b, c = map(int, stdin.strip().split())\n        if a * a + b * b + c == 0:\n            return \"yes\"\n    return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    coords = list(map(int, stdin.split()))\n    x, y = coords[0], coords[1]\n    a, b, c = map(int, stdin.split())\n    candles = list(map(lambda x, y: (x, y), coords[2:], coords[2:]))\n    candles_dict = {}\n    for c in candles:\n        if c not in candles_dict:\n            candles_dict[c] = 1\n        else:\n            candles_dict[c] += 1\n    candles_dict = {k: v for k, v in candles_dict.items() if v == len(candles)}\n    for k, v in candles_dict.items():\n        if (k[0] - x) * (k[1] - y) <= 0:\n            continue\n        if abs(k[0] - x) + abs(k[1] - y) <= r:\n            continue\n        candles_dict = {}\n        for c in candles:\n            if c not in candles_dict:\n                candles_dict[c] = 1\n            else:\n                candles_dict[c] += 1\n    candles_dict = {k: v for k, v in candles_dict.items() if v == len(candles)}\n    for k, v in candles_dict.items():\n        if (k[0] - x) * (k[1] - y) <= 0:\n            continue\n        if abs(k[0] - x) + abs(k[1] - y) <= r:\n            continue\n        if abs(k[0] - x) < 0.000001 and abs(k[1] - y) < 0.000001:\n            continue\n        if k[0] * k[0] + k[1] * k[1] <= r * r:\n            continue\n        return 'no'\n    if len(candles_dict) == 1:\n        return 'yes'\n    for k, v in candles_dict.items():\n        if (k[0] - x) * (k[1] - y) <= 0:\n            continue\n        if abs(k[0] - x) + abs(k[1] - y) <= r:\n            continue\n        if abs(k[0] - x) < 0.000001 and abs(k[1] - y) < 0.000001:\n            continue\n        if k[0] * k[0] + k[1] * k[1] <= r * r:\n            continue\n        return 'no'\n    return 'no'\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(stdin)\n    n = len(stdin)\n    max_k = 1\n    k = 2\n    while k <= n:\n        for i in range(n - k + 1):\n            if stdin[i:k+i] == stdin[i:k+i][::-1]:\n                max_k = max(max_k, k)\n        k += 1\n    return str(max_k)\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n   ... 6522526\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 12121131221\n   ... ''')\n    '7'\n    >>> solution('''\n   ... 123456789\n   ... ''')\n    '1'\n    '''\n    import numpy as np\n    max_k = 1\n    for n in np.arange(len(stdin), dtype=int):\n        for k in np.arange(2, n):\n            if is_palindrome(stdin[:k]):\n                max_k = max(max_k, k)\n    return max_k\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.split()\n    B = list(A[0])\n    max_ = 1\n    A = map(int, A)\n    while True:\n        for i in range(len(B)):\n            if i+1 == len(B):\n                continue\n            a = int(B[i])\n            b = int(B[i+1])\n            if a == b:\n                continue\n            if b-a == a:\n                pass\n            if b-a == b-a:\n                pass\n            if b-a == 1:\n                max_ = max(max_, 2)\n            else:\n                max_ = max(max_, 2**(b-a))\n        if max_ == 1:\n            break\n    return str(max_)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    st = stdin\n    # Write an action using print\n    # To debug: print(\"Debug messages...\", file=sys.stderr, flush=True)\n    if len(st) <= 1:\n        return 1\n    max_str_len = max(len(st) // 2, 1)\n    for sub_str_len in range(2, max_str_len):\n        idx = 0\n        while idx + sub_str_len < len(st):\n            # check palindrome\n            if check_palindrome(st[idx:idx+sub_str_len]):\n                idx += sub_str_len\n            else:\n                idx += 1\n        if idx == len(st) - 1:\n            return sub_str_len\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    max_len = 0\n    max_len_palindrome = 0\n    n_chars = len(stdin)\n    for k in range(1, n_chars+1):\n        partitions = len(stdin) // k\n        for start in range(partitions):\n            substring = stdin[start:start+k]\n            if substring == substring[::-1]:\n                if len(substring) > max_len:\n                    max_len = len(substring)\n                    max_len_palindrome = k\n    return str(max_len_palindrome)\n"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin\n    start = 0\n    while start < len(input_string):\n        end = len(input_string)\n        while end > start:\n            partition_string = input_string[start:end]\n            if is_palindrome(partition_string):\n                print(end-start)\n                return\n            end -= 1\n        start += 1\n    print(0)\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i][i] = 1\n\n    for length in range(n, 0, -1):\n        for i in range(n - length + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(i, j):\n                    dp[i][j][length] = dp[i][j][length] or dp[i][k - 1][length - 1] and stdin[i - 1] == stdin[k + 1]\n\n    res = 0\n    for i in range(1, n + 1):\n        res = max(res, i, *map(max, dp[i][i]))\n\n    return res"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.replace(\" \", \"\")\n    stdin = list(map(int, stdin))\n    stdin.sort()\n    k = 0\n    n = 1\n    for i in range(len(stdin)-1):\n        if stdin[i] == stdin[i+1]:\n            k += 1\n            n = max(n, k)\n        else:\n            k = 0\n    return str(n)"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    possible_palindrome_substrings = []\n    for i in range(1, len(stdin)):\n        possible_palindrome_substrings.append(stdin[i-1:i+1])\n    possible_palindrome_substrings.sort()\n    for k in range(2, len(possible_palindrome_substrings)):\n        if is_palindrome(possible_palindrome_substrings[:k]):\n            return k\n    return -1\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    partitions = []\n    for k in range(1, len(n)+1):\n        partitions.append(partition_string(n, k))\n    return max(partitions)\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    villages = sorted(map(int, stdin.split()))\n    for i in range(1, n):\n        villages.append(villages[i - 1] + villages[i - 1])\n    # print(villages)\n    roads = []\n    for i in range(m):\n        roads.append([villages[i], villages[i + 1]])\n    roads.sort()\n    # print(roads)\n    max_stolen = 0\n    stack = [(0, 0)]\n    while stack:\n        val, cnt = stack.pop()\n        # print(val, cnt)\n        if val >= 5000:\n            break\n        for (a, b) in roads:\n            # print(a, b)\n            if a == val:\n                if b not in stack:\n                    stack.append((b, cnt + 1))\n                elif stack[-1][1] < cnt + 1:\n                    stack.append((b, cnt + 1))\n            if b == val:\n                if a not in stack:\n                    stack.append((a, cnt + 1))\n                elif stack[-1][1] < cnt + 1:\n                    stack.append((a, cnt + 1))\n        # print(stack)\n        if val == 0:\n            max_stolen = max(max_stolen, cnt)\n    return str(max_stolen)\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    n, m = map(int, data[0].split())\n    villages = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        villages[i] = list(map(int, data[i].split()))\n    n_villages = villages[1]\n    villages.pop(1)\n    graph = [[] for _ in range(n + 1)]\n    roads = list(map(int, data[n].split()))\n    roads.sort(reverse=True)\n    for i in range(n - 1):\n        graph[roads[i]].append(roads[i + 1])\n    graph.sort(reverse=True)\n    visited = [False] * (n + 1)\n    cnt = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            visited[i] = True\n            steal_gold(villages, graph, roads, visited, cnt, i)\n            cnt += 1\n    return cnt\n\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    What comes in:\n    A single line containing two space-separated integers $n$ and $m$. $n$ is the number of villages, and $m$ is the number of roads. The villages are numbered $1 \\ldots n$. Village $1$ is the bandit\u2019s home, and village $2$ holds the king\u2019s castle. On the next line will be $n-2$ space-separated integers $g$ ($1 \\le g \\le 5000$), which are the amount of gold in each village $3, 4, \\ldots, n$, skipping the bandit\u2019s home and the king\u2019s castle. On each of the following $m$ lines will be two integers, $a$ and $b$ ($1 \\le a < b \\le n$) indicating that there is a road between villages $a$ and $b$. All roads are two-way. All $m$ $(a,b)$ pairs will be unique. There will be a path, direct or indirect, from every village to every other village.\n    \"\"\"\n    pass\n    return stdout\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    gold = list(map(int, stdin.split()))\n    gold = gold[1:]\n    ans = 0\n    while gold:\n        dist = gold[0]\n        del gold[0]\n        if dist == 0:\n            ans += 1\n            continue\n        for i in range(len(gold)):\n            a, b = gold[i]\n            if a == n + 1 and b == n + 1:\n                ans += dist\n                del gold[i]\n                break\n            elif a == n + 1 and b == n + 2:\n                ans += dist\n                del gold[i]\n                del gold[i]\n                break\n            elif a == n + 2 and b == n + 1:\n                ans += dist\n                del gold[i]\n                break\n            elif a == n + 2 and b == n + 2:\n                ans += dist\n                del gold[i]\n                break\n            elif a == b:\n                del gold[i]\n                del gold[i]\n                break\n            elif a == n + 1 and b == n + 2:\n                ans += dist\n                del gold[i]\n                del gold[i]\n                break\n            elif a == n + 2 and b == n + 1:\n                ans += dist\n                del gold[i]\n                break\n    return str(ans)\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    villages = {i: 0 for i in range(1, n + 1)}\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        villages[a] += b\n        villages[b] += a\n    total_gold = sum(villages.values())\n    return f'{total_gold}' if total_gold <= 5000 else \"0\"\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(numbers: List[int]) -> int:\n        value = 0\n        for i in numbers:\n            value += i\n        return value\n    n = int(stdin.splitlines()[0])\n    m = int(stdin.splitlines()[1])\n    numbers = list(map(int, stdin.splitlines()[2:]))\n    villages = {}\n    villages_value = {}\n    for i in range(1, n + 1):\n        villages[i] = 0\n        villages_value[i] = 0\n    for i in range(1, m + 1):\n        villages[numbers[i - 1]] += 1\n    for i in range(1, m + 1):\n        villages_value[numbers[i - 1]] += get_value(villages[numbers[i - 1]])\n    max_value = max(villages_value.values())\n    return str(max_value)"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = iter(stdin.split(\"\\n\"))\n    n, m = next(input_lines).split()\n    n = int(n)\n    m = int(m)\n\n    values = list(map(int, next(input_lines).split()))\n    graph = {i: [] for i in range(1, n + 1)}\n\n    for i in range(m):\n        x, y = next(input_lines).split()\n        x, y = int(x), int(y)\n        graph[x].append(y)\n        graph[y].append(x)\n\n    d = graph[1]\n    while d:\n        d = graph[d[0]]\n\n    values.sort()\n    v_max = values[-1]\n    n_max = sum(values)\n    count = 0\n\n    def add_v(v, a):\n        nonlocal count\n        for i in a:\n            if i in graph:\n                graph[v].append(i)\n                count += 1\n\n    for v in range(1, n + 1):\n        if v not in graph:\n            add_v(v, graph[v])\n        if v_max < values[v - 1]:\n            v_max = values[v - 1]\n            n_max = sum(values)\n            count = 1\n\n    count = n_max\n    v = graph[1]\n    while v:\n        if count + sum(values[v[0]:v[1]]) < n_max:\n            n_max = count + sum(values[v[0]:v[1]])\n            v_max = values[v[0]]\n        v = graph[v]\n\n    return str(n_max - v_max)\n"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin\n    villages = [int(v) for v in stdin.split()[1:]]\n    villages.append(0)\n    graph = [[] for _ in range(n+1)]\n    for a,b in stdin.split()[1:]:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    #print(graph)\n    \n    def dfs(node, visited, gold):\n        if node == villages[-1]:\n            return gold\n        visited.append(node)\n        for i in graph[node]:\n            if i not in visited:\n                gold = max(gold, dfs(i, visited, gold + villages[node]))\n        return gold\n    \n    print(dfs(villages[0], [], 0))\n    return '0'"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return 0"
    },
    {
        "number": 3025,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def solve():\n        villages = {}\n        roads = {}\n        for i in range(1, len(stdin.split('\\n')), 2):\n            villages[i] = villages.get(i, []) + stdin.split('\\n')[i].split(' ')\n        for i in range(1, len(stdin.split('\\n')), 2):\n            roads[i] = roads.get(i, []) + stdin.split('\\n')[i].split(' ')\n        return max(map(lambda x: sum([villages[i].pop() for i in range(1, len(villages)) if villages[i]]), roads))\n    return str(solve())\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sequence = stdin.split()\n    n = int(sequence[0])\n    sequence = sequence[1:]\n    return list(map(int, sorted(set(sequence), key=sequence.index)))"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = list(map(int, stdin.split()))\n    if all(seq[i] < seq[i + 1] for i in range(n - 1)):\n        return '\\n'.join(str(i) for i in seq if i > 0)\n    else:\n        return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    --- Day 4: Passport Processing ---\n    With the advent of better passports, Zapray has switched to a more strict format for storing information in passports. The passport is a series of key:value pairs separated by spaces or newlines. Passports are separated by blank lines.\n\n    Your task is to count the number of passports where all required fields are complete. A passport is considered complete if it has all required fields or if a field is blank.\n\n    Passports are separated by blank lines.\n\n    Note that the passports do not have to follow the exact format.\n\n    The only required field is cid (Country ID), which should be a two-digit number\n    between 0000 and 9999.\n\n    Input:\n    ecl:gry pid:860033327 eyr:2020 hcl:#fffffd\n    byr:1937 iyr:2017 cid:147 hgt:183cm\n\n    iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884\n    hcl:#cfa07d byr:1929\n\n    hcl:#ae17e1 iyr:2013\n    eyr:2024\n    ecl:brn pid:760753108 byr:1931\n    hgt:179cm\n\n    hcl:#cfa07d eyr:2025 pid:166559648\n    iyr:2011 ecl:brn hgt:59in\n\n    The first passport is valid - all eight fields are complete. The second passport is invalid - it is missing hgt (the Height field).\n\n    The third passport is interesting; the only missing field is cid, so it looks like data from North Pole Credentials, not a passport at all!\n\n    Also, the fourth passport is missing two fields, cid and byr. Missing cid is fine, but missing any other field is not, so this passport is invalid.\n\n    The fifth passport is missing cid and byr, and so is this one. The only missing field is pid, and it is not at the beginning. This passport is missing hgt,\n    but we still need to check that the rest of the fields are there.\n\n    Input:\n    ecl:gry pid:860033327 eyr:2020 hcl:#fffffd\n    byr:1937 iyr:2017 cid:147 hgt:183cm\n\n    iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884\n    hcl:#cfa07d byr:1929\n\n    hcl:#ae17e1 iyr:2013\n    eyr:2024\n    ecl:brn pid:760753108 byr:1931\n    hgt:179cm\n\n    hcl:#cfa07d eyr:2025 pid:166559648\n    iyr:2011 ecl:brn hgt:59in\n\n    The first passport is valid - all eight fields are complete. The second passport is invalid - it is missing hgt (the Height field).\n\n    The third passport is interesting; the only missing field is cid, so it looks like data from North Pole Credentials, not a passport at all!\n\n    Also, the fourth passport is missing cid and byr. Missing cid is fine, but missing any other field is not, so this passport is invalid.\n\n    The fifth passport is missing cid and byr, and so is this one. The only missing field is pid, and it is not at the beginning. This passport is missing hgt,\n    but we still need to check that the rest of the fields are there.\n\n    Input:\n    ecl:gry pid:860033327 eyr:2020 hcl:#fffffd\n    byr:1937 iyr:2017 cid:147 hgt:183cm\n\n    iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884\n    hcl:#cfa07d byr:1929\n\n    hcl:#ae17e1 iyr:2013\n    eyr:2024\n    ecl:brn pid:760753108 byr:1931\n    hgt:179cm\n\n    hcl:#cfa07d eyr:2025 pid:166559648\n    iyr:2011 ecl:brn hgt:59in\n\n    The first passport is valid - all eight fields are complete. The second passport is invalid - it is missing hgt (the Height field).\n\n    The third passport is interesting; the only missing field is cid, so it looks like data from North Pole Credentials, not a passport at all!\n\n    Also, the fourth passport is missing cid and byr. Missing cid is fine, but missing any other field is not, so this passport is invalid.\n\n    The fifth passport is missing cid and byr, and so is this one. The only missing field is pid, and it is not at the beginning. This passport is missing hgt,\n    but we still need to check that the rest of the fields are there.\n\n    Input:\n    eyr:1972 cid:100\n    hcl:#18171d ecl:amb hgt:170 pid:186cm iyr:2018 byr:1926\n\n    iyr:2019\n    hcl:#602927 eyr:1967 hgt:170cm\n    ecl:grn pid:012533040 byr:1946\n\n    hcl:dab227 iyr:2012\n    ecl:brn hgt:182cm pid:021572410 eyr:2020 byr:1992 cid:277\n\n    hgt:59cm ecl:zzz\n    eyr:2038 hcl:74454a iyr:2023\n    pid:3556412378 byr:2007\n\n    pid:087499704 hgt:74in ecl:grn iyr:2012 eyr:2030 byr:1980 hcl:#623a2f\n\n    eyr:2029 ecl:blu cid:129 byr:1989\n    iyr:2014 pid:896056539 hcl:#a97842 hgt:165cm\n\n    hcl:#888785\n    hgt:164cm byr:2001 iyr:2015 cid:88\n    pid:545766238 ecl:hzl\n    eyr:2022\n\n    iyr:2010 hgt:158cm hcl:#b6652a ecl:blu byr:1944 eyr:2021 pid:093154719\n\n    eyr:2025 ecl:brn iyr:2012 byr:1944\n    hcl:#623a2f pid:160051525 hgt:179cm\n\n    hcl:#623a2f\n    eyr:2025 ecl:blu cid:129 byr:1989\n    iyr:2014 pid:187cm hgt:158cm\n\n    hcl:#623a2f\n    eyr:2025\n    ecl:blu cid:129 byr:1994 iyr:2014 pid:176cm hgt:59in\n\n    pid:087499704 iyr:2012\n    eyr:2030 ecl:oth hgt:164cm byr:1944\n    hcl:#888785\n\n    eyr:2022\n    hgt:164cm hcl:#b6652a ecl:blu iyr:2023 byr:1944\n    pid:165cm\n\n    eyr:2021\n    iyr:2012\n    hgt:164cm\n    pid:021572410 byr:1980 hcl:#623a2f ecl:hzl\n\n    pid:087499704\n    iyr:2010 hgt:158cm hcl:#b6652a ecl:blu"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = list(map(int, stdin.split()))\n    seq.sort()\n    # print(seq)\n\n    # curr_val = seq[0]\n    curr_max = seq[0]\n    max_length = 0\n    critical = []\n    for i in seq:\n        if i > curr_max:\n            critical.append(i)\n        curr_max = max(curr_max, i)\n        max_length = max(max_length, len(critical))\n    if len(critical) > 0:\n        return \" \".join(map(str, critical))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = list(map(int, stdin.split()))\n    if len(seq) < 2:\n        return '-1'\n    if len(seq) == 2:\n        return '1' if seq[0] > seq[1] else '-1'\n    dp = [[0] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if seq[j] < seq[i]:\n                dp[i][j] = max(dp[i][j], dp[j][i - 1] + 1)\n    print(max(max(dp, key=max)))\n    for i in range(len(dp)):\n        for j in range(len(dp[0])):\n            if dp[i][j] == max(dp, key=max)[i]:\n                print(i, j)\n                return '{0} {1}'.format(i, j)\n    return '-1'"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    sequence_string = stdin\n    sequence = []\n    \n    for i in range(1, int(sequence_string)):\n        sequence.append(int(sequence_string[i]))\n    \n    critical_elements = []\n    \n    for i in range(1, len(sequence)):\n        critical_elements.append(i)\n    \n    for j in range(1, len(sequence)):\n        for i in range(len(sequence) - j):\n            if sequence[i + j] < sequence[i]:\n                critical_elements.remove(critical_elements[i])\n    \n    if critical_elements:\n        critical_elements.sort()\n        return critical_elements[0]\n    else:\n        return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lst = list(map(int, stdin.split()))\n    print(lst)\n    dic = {}\n    for i in lst:\n        if i in dic.keys():\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    print(dic)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if lst[i] > lst[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    if dp[-1] == 0:\n        return '-1'\n    else:\n        return''.join(str(i) for i in dp)"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = stdin.split(' ')\n    critical_elements = []\n    critical_elements.append(sequence[0])\n    max_elements = []\n    max_elements.append(sequence[0])\n    for i in range(1, n):\n        if int(sequence[i]) > int(critical_elements[-1]):\n            critical_elements.append(sequence[i])\n        else:\n            if int(critical_elements[-1]) > int(max_elements[-1]):\n                max_elements = []\n                max_elements.append(sequence[i])\n            elif int(critical_elements[-1]) == int(max_elements[-1]):\n                max_elements.append(sequence[i])\n    if len(critical_elements) == 0:\n        return '-1'\n    else:\n        critical_elements.sort()\n        max_elements.sort()\n        for i in range(len(critical_elements)):\n            print(critical_elements[i], end=' ')\n        for j in range(len(max_elements)):\n            print(max_elements[j], end=' ')\n        return ''"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def solve() -> str:\n        n = int(stdin)\n        arr = list(map(int, stdin.split()))\n        arr.sort()\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if arr[j] < arr[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        if dp[-1] == 1:\n            return '-1'\n        else:\n            return''.join(map(str, dp))\n    return solve()"
    },
    {
        "number": 3026,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = sorted(map(int, stdin.split()))\n    # print(seq)\n    if len(seq) == 1:\n        return '-1'\n    li = []\n    def LIS(i):\n        if i >= len(seq):\n            return 0\n        if len(li) == 0:\n            return 1\n        for j in range(len(li)):\n            if li[j][1] == i:\n                return max(seq[i] - li[j][0], LIS(i + 1))\n        return LIS(i + 1)\n    LIS(0)\n    return li"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    paper, n, m = stdin.split()\n    n, m = int(n), int(m)\n\n    if m % 2 == 0:\n        nub = n // 2\n    else:\n        nub = (n // 2) + 1\n\n    for i in range(n // 2):\n        paper[i * 2], paper[i * 2 + 1] = paper[i * 2 + 1], paper[i * 2]\n    paper = paper[:n]\n\n    ans = 0\n    for i in paper:\n        if i == \"#\":\n            ans += 1\n\n    return str(ans)"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    paper = stdin\n    for i in range(1, 2):\n        paper = paper.replace(\"#\", \"#\")\n    paper = paper.replace(\".\", \"#\")\n    paper = paper.replace(\"#\", \".\")\n    return str(len(paper))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    h = 0\n    a = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                a[i][j] = 1\n            else:\n                a[i][j] = a[i - 1][j] + a[i + 1][j] + a[i][j - 1] + a[i][j + 1]\n    return str(a[n - 1][m - 1])\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return''"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split()\n    n = int(instructions[0])\n    m = int(instructions[1])\n    nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if stdin[i*m+j] == '#':\n                nubs += 1\n    return str(nubs)\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    # Now, build up the dictionary of marks\n    # Build up the dictionary of marks\n    marks = {}\n    # print(\"n:\", n)\n    # print(\"m:\", m)\n    for i in range(m):\n        # print(\"Iteration:\", i)\n        for j in range(n):\n            # print(\"Iteration:\", j)\n            x = stdin[j * n + i]\n            if x == \".\":\n                continue\n            elif x == \"#\":\n                # print(\"Marks:\", marks)\n                marks[x] = marks.get(x, 0) + 1\n                # print(\"Marks:\", marks)\n                break\n    return str(min(marks.values()))\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    paper = stdin\n    for _ in range(2):\n        for i in range(len(paper)):\n            for j in range(len(paper)):\n                if paper[i][j] == '#':\n                    paper[i][j] = '.'\n                    break\n            for j in range(len(paper)):\n                if paper[i][j] == '.':\n                    paper[i][j] = '#'\n                    break\n    return str(sum([1 for line in paper for cell in line if cell == '#']))\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    paper = [['#' if i == 0 else '.' for i in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if j < m-2:\n                paper[i][j] = paper[i][j] + paper[i][j + 1]\n            if j > 0:\n                paper[i][j] = paper[i][j] + paper[i][j - 1]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if paper[i][j] == '#':\n                count = count + 1\n    return str(count)\n"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    text = \"\"\n    for i in range(n):\n        text += stdin[i*m:(i+1)*m]\n    return count_nubs(text, n)\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m = len(stdin[0])\n    n = len(stdin)\n    # Construct the input by taking the first row\n    input = stdin[0][1:]\n    output = 1\n    # print(input)\n    while input!= stdin[0]:\n        print(input)\n        output += 1\n        print(output)\n        input = input + stdin[0]\n    return str(output)\n\n\nprint(solution(['4 8', '...', '...', '.....', '......']))\nprint(solution(['4 8', '..#', '..#', '..#', '..#']))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = []\n    for i in range(int(stdin.split()[0])):\n        board.append([int(x) for x in stdin.split()[i + 1]])\n    for i in range(int(stdin.split()[0])):\n        for j in range(int(stdin.split()[1])):\n            if board[i][j] == 1:\n                if i == 0 or board[i - 1][j]!= 1:\n                    board[i - 1][j] = board[i][j]\n                    board[i][j] = 1\n                else:\n                    board[i][j] = board[i - 1][j]\n            elif board[i][j] == 2:\n                if i == 0 or board[i - 1][j]!= 2:\n                    board[i - 1][j] = board[i][j]\n                    board[i][j] = 2\n                else:\n                    board[i][j] = board[i - 1][j]\n    if all([x == 1 or x == 2 for x in board[0]]):\n        return str(len([x for x in board if x == 1]))\n    elif all([x == 1 or x == 2 for x in board[0]]):\n        return str(len([x for x in board if x == 2]))\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m = [int(i) for i in stdin.split()]\n    n, m, p = m\n    board = [[0]*m for _ in range(n)]\n    for i in range(m):\n        board[0][i] = p\n    for i in range(1, n):\n        for j in range(m):\n            board[i][j] = board[i-1][j]\n            if board[i][j] == p:\n                board[i][j] = p - 1\n    for i in range(n):\n        for j in range(m):\n            print(board[i][j], end=\" \")\n        print()\n    return \"\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m, p = list(map(int, stdin.split()))\n    if n < 2 or m < 2 or p < 2 or p > 97:\n        return \"No\"\n    s = {p for i in range(1, p + 1)}\n    seen = {0}\n    for i in range(p):\n        k = 0\n        for j in range(m):\n            if j in seen:\n                continue\n            if s & set(range(1, p + 1)) == set(range(1, p + 1)):\n                k = max(k, i + j + 1)\n                if k == p * m:\n                    return str(k)\n            else:\n                break\n        seen = seen | set(range(j, j + m))\n    return \"No\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    return solution_1(n, m, p, A)\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    if p*m*n == 1:\n        return -1\n    else:\n        return n*m*p"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [[int(c) for c in stdin.split()] for _ in range(n)]\n    moves = [[1]]\n    for _ in range(n):\n        moves.append([])\n        for _ in range(m):\n            moves[-1].append(1)\n            moves[-1][0] = moves[-1][0] + board[-1][-1]\n            moves[-1][-1] = 0\n            for i in range(len(moves[-1]) - 1):\n                moves[-1][i] = moves[-1][i] + max(board[-1][i], board[-1][i + 1])\n        board = moves\n    for row in board:\n        print(' '.join(str(v) for v in row))\n    return str(len(set(map(tuple, board))))\n\nsolution(\n'''3 3 3\n1 2\n2 1\n1 2\n3 3\n3 2\n4 5\n5 3 4 3\n4 3 3 3\n3 2 3 3'''))"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = list(map(int, stdin.split()))\n    board = [[int(i) for i in stdin.split()] for _ in range(n)]\n    for row in board:\n        if row[0] == p:\n            return -1\n    i = 0\n    while True:\n        i += 1\n        for j in range(m):\n            if board[i][j] == p:\n                board[i][j] = 1\n                if i!= 0:\n                    board[i - 1][j] = 1\n                if i!= n - 1:\n                    board[i + 1][j] = 1\n                if j!= 0:\n                    board[i][j - 1] = 1\n                if j!= m - 1:\n                    board[i][j + 1] = 1\n        if check(board):\n            return i\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a string.\"\"\"\n    # >>> solution(input())\n    n, m, p = map(int, stdin.split())\n    array = [[0] * m for _ in range(n)]\n    for i in range(n):\n        row = list(map(int, stdin.split()))\n        for j, col in enumerate(row):\n            array[i][j] = col\n    result = solution_recursive(n, m, p, 0, 0, array)\n    return str(result)\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, n, m, p = map(int, stdin.split())\n    board = [[int(i) for i in stdin.split()] for _ in range(n)]\n    visited = set()\n\n    def get_next_row_col(row, col):\n        if row == n - 1:\n            return n - 1, col + 1\n        if col == m - 1:\n            return row + 1, 0\n        return row + 1, col + 1\n\n    def get_all_adj_nums(board, row, col):\n        nums = []\n        for row_diff, col_diff in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            n_r, n_c = row + row_diff, col + col_diff\n            while n_r < n and n_c < m and board[n_r][n_c]!= p:\n                nums.append(board[n_r][n_c])\n                n_r += row_diff\n                n_c += col_diff\n        return nums\n\n    def can_get_next_num(board, row, col):\n        if board[row][col] == p:\n            return True\n        if board[row][col]!= 0:\n            return False\n        return any(map(lambda x: x in visited, get_all_adj_nums(board, row, col)))\n\n    def get_next_num(board, row, col):\n        if board[row][col] == p:\n            return True\n        if board[row][col]!= 0:\n            return False\n        for n_r, n_c in get_next_row_col(row, col):\n            if can_get_next_num(board, n_r, n_c):\n                visited.add(board[n_r][n_c])\n                return True\n        return False\n\n    def get_next_moves(board, row, col):\n        next_num = get_next_num(board, row, col)\n        if next_num:\n            visited.add(board[row][col])\n            return [board[row][col]]\n        next_nums = get_all_adj_nums(board, row, col)\n        next_moves = []\n        for n in next_nums:\n            if n not in visited:\n                visited.add(n)\n                next_moves.append(n)\n        return next_moves\n\n    result = 0\n    row = 0\n    col = 0\n    while row < n:\n        if col >= m:\n            row += 1\n            col = 0\n        visited.add(board[row][col])\n        result += 1\n        col += 1\n        if result >= p * m * n:\n            return result\n        next_moves = get_next_moves(board, row, col)\n        if len(next_moves) == 0:\n            return -1\n        elif len(next_moves) == 1:\n            board[row][col] = next_moves[0]\n            row, col = get_next_row_col(row, col)\n        else:\n            for move in next_moves:\n                board[row][col] = move\n                row, col = get_next_row_col(row, col)\n            row, col = get_next_row_col(row, col)\n    return result\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3028,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [[0] * m for _ in range(n)]\n    visited = [[0] * m for _ in range(n)]\n    for i in range(n):\n        curr = list(map(int, stdin.split()))\n        board[i] = curr\n    def is_valid_path(board: list, x: int, y: int, direction: int) -> bool:\n        # return True if move is valid\n        # check if current value is equal to p\n        if board[x][y] == p:\n            return False\n        # check if current value is equal to 0\n        if board[x][y]!= 0:\n            return True\n        if direction == 0:\n            for i in range(1, 4):\n                if 0 <= x+i < n:\n                    if board[x+i][y] == p:\n                        return False\n                    if board[x+i][y] == 0:\n                        board[x + i][y] = board[x][y] + 1\n                        return True\n        if direction == 1:\n            for i in range(1, 4):\n                if 0 <= y+i < m:\n                    if board[x][y+i] == p:\n                        return False\n                    if board[x][y+i] == 0:\n                        board[x][y+i] = board[x][y] + 1\n                        return True\n        if direction == 2:\n            for i in range(1, 4):\n                if 0 <= x-i < n:\n                    if board[x-i][y] == p:\n                        return False\n                    if board[x-i][y] == 0:\n                        board[x - i][y] = board[x][y] + 1\n                        return True\n        if direction == 3:\n            for i in range(1, 4):\n                if 0 <= y-i < m:\n                    if board[x][y-i] == p:\n                        return False\n                    if board[x][y-i] == 0:\n                        board[x][y - i] = board[x][y] + 1\n                        return True\n        return False\n    def move_forward(board: list, x: int, y: int, direction: int) -> bool:\n        while True:\n            if not is_valid_path(board, x, y, direction):\n                break\n            direction = (direction+1) % 4\n        return direction!= 0\n    def move_backward(board: list, x: int, y: int, direction: int) -> bool:\n        while True:\n            if not is_valid_path(board, x, y, direction):\n                break\n            direction = (direction-1) % 4\n        return direction!= 0\n    def move_up(board: list, x: int, y: int, direction: int) -> bool:\n        while True:\n            if not is_valid_path(board, x, y, direction):\n                break\n            direction = (direction+3) % 4\n        return direction!= 0\n    def move_down(board: list, x: int, y: int, direction: int) -> bool:\n        while True:\n            if not is_valid_path(board, x, y, direction):\n                break\n            direction = (direction-3) % 4\n        return direction!= 0\n    x = 0\n    y = 0\n    direction = 0\n    # move in forward direction\n    for i in range(p):\n        if direction == 0:\n            x = x + 1\n        elif direction == 1:\n            y = y + 1\n        elif direction == 2:\n            x = x - 1\n        else:\n            y = y - 1\n        if is_valid_path(board, x, y, direction):\n            board[x][y] = p\n            direction = move_forward(board, x, y, direction)\n            if direction == 0:\n                break\n    # move in backward direction\n    for i in range(p):\n        if direction == 0:\n            x = x - 1\n        elif direction == 1:\n            y = y - 1\n        elif direction == 2:\n            x = x + 1\n        else:\n            y = y + 1\n        if is_valid_path(board, x, y, direction):\n            board[x][y] = p\n            direction = move_forward(board, x, y, direction)\n            if direction == 0:\n                break\n    # move in up direction\n    for i in range(p):\n        if direction == 0:\n            y = y - 1\n        elif direction == 1:\n            x = x + 1\n        elif direction == 2:\n            y = y + 1\n        else:\n            x = x - 1\n        if is_valid_path(board, x, y, direction):\n            board[x][y] = p\n            direction = move_forward(board, x, y, direction)\n            if direction == 0:\n                break\n    # move in down direction\n    for i in range(p):\n        if direction == 0:\n            y = y + 1\n        elif direction == 1:\n            x = x - 1\n        elif direction == 2:\n            y = y - 1\n        else:\n            x = x + 1\n        if is_valid_path(board, x, y, direction):\n            board[x][y] = p\n            direction = move_forward(board, x, y, direction)\n            if direction == 0:\n                break\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                return str(i+1) +'' + str(j+1)\n    return -1\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin)\n    l = 1\n    m = 0\n    if n == 1:\n        return str(1) + \" \" + str(1)\n    if n == 2:\n        return str(2) + \" \" + str(1)\n    if n == 3:\n        return str(2) + \" \" + str(2)\n    for i in range(2, n):\n        if i == 2:\n            continue\n        if i == 3:\n            continue\n        for j in range(i):\n            if i == j+1:\n                continue\n            l = i\n            m = 0\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            l = i\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            if m > 0:\n                m = m\n            else:\n                m = 0\n            l = i\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            l = i\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            if m > 0:\n                m = m\n            else:\n                m = 0\n            l = i\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            l = i\n            while l <= n:\n                if is_decreasing(l) == True:\n                    m = m + 1\n                    l = l + i\n                else:\n                    l = l + 1\n            if m > m:\n                m = m\n            if m > 0:\n                m = m\n            else:\n                m = 0\n        m = 0\n        l = i\n        while l <= n:\n            if is_decreasing(l) == True:\n                m = m + 1\n                l = l + i\n            else:\n                l = l + 1\n        if m > m:\n            m = m\n        l = i\n        while l <= n:\n            if is_decreasing(l) == True:\n                m = m + 1\n                l = l + i\n            else:\n                l = l + 1\n        if m > m:\n            m = m\n        if m > 0:\n            m = m\n        else:\n            m = 0\n    return str(l) + \" \" + str(m)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    data = list(map(int, stdin.split()))\n    l = data[0]\n    m = 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if data[i] < data[j]:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1]) + 1\n            m = max(m, dp[i][j] * 1009)\n    return str(l) +'' + str(m)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1\n    n = int(stdin)\n    vals = list(map(int, stdin.split()))\n    vals.sort()\n    values = []\n    while len(vals) > 0:\n        values.append(vals.pop())\n    max_ = 0\n    for i in range(len(values)):\n        for j in range(i + 1, len(values)):\n            if values[i] < values[j]:\n                max_ = max(max_, (j - i) // 2)\n    return str(max_) + \" \" + str(len(values) // max_)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    #Solution 1\n    #split the input\n    line = stdin.split()\n    n = int(line[0])\n    #create an empty dictionary to store the tree\n    tree = {}\n    #create a counter for the number of nodes\n    counter = 0\n    #create an empty dictionary to store the parents of every node\n    parents = {}\n    #create a counter for the number of nodes\n    counter2 = 0\n    #for every line in stdin\n    for line in stdin.split('\\n'):\n        if(line == ''):\n            #this is to remove the empty lines\n            continue\n        line = line.split()\n        parent = int(line[0])\n        child = int(line[1])\n        #if the parent does not exist\n        if(parent not in tree):\n            #create the parent\n            tree[parent] = {}\n            #create the child\n            tree[parent][child] = {}\n        #if the child does not exist\n        if(child not in tree):\n            #create the child\n            tree[child] = {}\n            #create the parent\n            tree[child][parent] = {}\n        #if the child exists\n        if(child in tree):\n            #if the parent does not exist\n            if(parent not in tree):\n                #create the parent\n                tree[parent] = {}\n                #create the child\n                tree[parent][child] = {}\n            #if the child exists\n            if(child in tree):\n                #add the child\n                tree[parent][child] = {}\n            #add the parent\n            tree[child][parent] = {}\n            #add the child\n            tree[child][child] = {}\n            #add the parent\n            tree[parent][child] = {}\n        #if the parent exists\n        if(parent in tree):\n            #add the parent\n            tree[parent][parent] = {}\n            #add the child\n            tree[parent][child] = {}\n            #add the child\n            tree[child][parent] = {}\n            #add the parent\n            tree[child][child] = {}\n    #for every node in the tree\n    for node in tree:\n        #add the parent\n        tree[node][node] = {}\n        #add the child\n        tree[node][node] = {}\n        #add the child\n        tree[node][node] = {}\n        #add the child\n        tree[node][node] = {}\n        #add the parent\n        tree[node][node] = {}\n    #create a counter for the number of nodes\n    counter = 0\n    #create an empty dictionary to store the parents of every node\n    parents = {}\n    #create a counter for the number of nodes\n    counter2 = 0\n    #create a dictionary to store the parents of each node\n    parent = {}\n    #for every node in the tree\n    for node in tree:\n        #for every child of the node\n        for child in tree[node]:\n            #if the child is not equal to the node\n            if(child!= node):\n                #add the child\n                tree[node][node] = {}\n                #add the parent\n                tree[child][child] = {}\n                #add the parent\n                tree[child][node] = {}\n                #add the child\n                tree[node][child] = {}\n            #add the parent\n            tree[node][child] = {}\n            #add the child\n            tree[child][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][child] = {}\n            #add the child\n            tree[child][node] = {}\n    #for every node in the tree\n    for node in tree:\n        #add the parent\n        parents[node] = {}\n        #add the child\n        parent[node] = {}\n        #add the child\n        tree[node][node] = {}\n        #add the parent\n        tree[node][node] = {}\n        #add the child\n        tree[node][node] = {}\n        #add the parent\n        tree[node][node] = {}\n        #add the parent\n        tree[node][node] = {}\n        #add the child\n        tree[node][node] = {}\n    #for every node in the tree\n    for node in tree:\n        #create a dictionary for the number of children of each node\n        children = {}\n        #create a counter for the number of children of each node\n        counter = 0\n        #for every child of the node\n        for child in tree[node]:\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent\n            tree[node][node] = {}\n            #add the child\n            tree[node][node] = {}\n            #add the parent"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    tree = [[] for _ in range(N)]\n    for i in range(N):\n        u_i, *tree[i] = list(map(int, stdin.split()))\n    N = len(tree)\n    counter = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if tree[i] > tree[j]:\n                continue\n            for k in range(j + 1, N):\n                if tree[i] > tree[k]:\n                    continue\n                if tree[i] > tree[j] and tree[j] > tree[k]:\n                    counter += 1\n                    if tree[i] == tree[j]:\n                        counter -= 1\n                    else:\n                        counter -= 1\n    return str(counter)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_nondecreasing(a: int, b: int) -> bool:\n        for c in range(1, len(a)):\n            if a[c] <= a[c - 1]:\n                return False\n        return True\n\n    if len(stdin.split()) < 2:\n        raise ValueError(\"Not enough arguments\")\n    if len(stdin.split()) > 2:\n        raise ValueError(\"Too many arguments\")\n    N = int(stdin.split()[0])\n    tree = stdin.split()[1:]\n    M = 0\n    L = 0\n    prev = None\n    for v in tree:\n        if not prev or prev > int(v):\n            M += 1\n            prev = int(v)\n    if not prev:\n        raise ValueError(\"root not found\")\n    else:\n        for v in tree:\n            if v == str(prev):\n                continue\n            if not is_nondecreasing(v, prev):\n                if L < 1:\n                    L = 1\n                else:\n                    L += 1\n    return str(L) + \" \" + str(M)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    tree = read_tree(stdin)\n    max_len, max_path, paths = longest_path(tree)\n    return str(max_len) + \" \" + str(max_path)\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    u_n: int = int(stdin)\n    v_n: int = int(stdin)\n\n    if n == 1:\n        print(1, 1)\n        return\n\n    # Create a tree with n vertices\n    # root: int\n    # v_i: int\n    root = 0\n    v_i = 1\n\n    # Create an adjacency list representation of the tree\n    # childs: dict\n    # {int v_i: set(int v_j) }\n    childs = {}\n\n    # Create the tree\n    for i in range(1, n):\n        childs[root] = childs.get(root, set())\n        childs[root].add(i)\n\n        childs[i] = childs.get(i, set())\n        childs[i].add(root)\n\n        root = i\n\n    # Create a queue with root in it\n    # q\n    q = deque()\n    q.append(root)\n\n    # visited: dict\n    # {int v_i: bool }\n    visited: Dict[int, bool] = {root: True}\n\n    # Compute the jumping path\n    # p\n    while q:\n        # v_i\n        v_i = q.popleft()\n        # q\n        q = deque(c for u in childs[v_i] for c in childs[u] if c not in visited)\n\n        # v_i\n        visited[v_i] = True\n\n        # Add a new edge for each child of v_i\n        for child in childs[v_i]:\n            # Skip the root\n            if child == root:\n                continue\n\n            # Add the edge\n            q.append(child)\n\n    # Get the longest path\n    # L\n    L = 0\n    jumping_paths: Dict[int, int] = {}\n\n    for i in range(1, n):\n        # v_i\n        v_i = root\n\n        # v_i\n        jumping_paths[v_i] = 1\n\n        # v_i\n        while v_i!= i:\n            # Add the length of the edge\n            L += jumping_paths[v_i]\n            # v_i\n            v_i = childs[v_i][0]\n\n    # Get the number of paths with the same length\n    # M\n    M = 1\n    for L in range(1, n):\n        # v_i\n        v_i = root\n\n        # v_i\n        while v_i!= i:\n            # Add the length of the edge\n            L += jumping_paths[v_i]\n            # v_i\n            v_i = childs[v_i][0]\n\n        if L == L:\n            # Increase the number of paths with the same length\n            M += 1\n\n    # Return the results\n    # Return the results\n    return str(L) + \" \" + str(M % 1000000009)\n"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    parents = stdin.splitlines()[1:]\n    parents = list(map(int, parents))\n    for i in range(2, n):\n        parents[i] = parents[parents[i]]\n    # print(parents)\n    L = 0\n    for i in range(2, n):\n        if i % 2 == 0:\n            continue\n        elif i == 1:\n            L = 1\n        else:\n            L += 1\n    # print(L)\n    M = 0\n    for i in range(1, n):\n        M += (L + 1) * (n - i)\n    return str(L) + \" \" + str(M % 1099201)\n    # return str(L) + \" \" + str((M + 1) % 1099201)\n    # return str(L) + \" \" + str((M + 1) % 1099201)"
    },
    {
        "number": 3029,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        p, c = map(int, stdin.split())\n        p -= 1\n        c -= 1\n        adj[p].append(c)\n        adj[c].append(p)\n\n    def dfs(v: int, path: list, res: list) -> None:\n        if v == len(path):\n            path.append(v)\n            res.append(len(path) - 1)\n            return\n        for u in adj[v]:\n            if u!= path[-1]:\n                path.append(u)\n                dfs(u, path, res)\n                path.pop()\n\n    res = []\n    path = []\n    dfs(0, path, res)\n    print(len(res), max(res))\n    return '%s %s' % (len(res), max(res) % 11092019)\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    if n == 0:\n        return str(0)\n    if n == 1:\n        return str(1)\n    nodes = list(map(int, lines[1:]))\n    nodes.sort(reverse=True)\n    tree = nodes[1:]\n    tree = list(map(lambda x: (x, x), tree))\n    tree = tree[:n]\n    # print(tree)\n    # n = len(tree)\n    n = len(nodes)\n    # print(n)\n    for i in range(1, n):\n        tree[i] = (nodes[i], tree[i - 1][1])\n    # print(tree)\n    print(tree)\n    for i in range(n):\n        print(i, tree[i])\n    result = []\n    # for i in range(1, n):\n    #     print(i, tree[i])\n    #     a = tree[i][1]\n    #     b = tree[i - 1][1]\n    #     if b < a:\n    #         result.append(i)\n    #         continue\n    #     for j in range(i + 1, n):\n    #         a = tree[i][1]\n    #         b = tree[j][1]\n    #         if b < a:\n    #             result.append(j)\n    #             continue\n    # print(result)\n    result = tree\n    print(result)\n    # print(tree)\n    def compare(t1, t2):\n        if t1 is None and t2 is None:\n            return True\n        if t1 is None or t2 is None:\n            return False\n        if t1[1]!= t2[1]:\n            return False\n        if t1[1] is not None:\n            return compare(t1[0], t2[0])\n        return True\n    # print(compare(result[1], result[0]))\n    # print(compare(result[2], result[1]))\n    print(compare(result[0], result[1]))\n    print(compare(result[1], result[2]))\n    print(compare(result[2], result[3]))\n    print(compare(result[3], result[4]))\n    # print(compare(result[4], result[5]))\n    # print(compare(result[5], result[6]))\n    # print(compare(result[6], result[7]))\n    # print(compare(result[7], result[8]))\n    # print(compare(result[8], result[9]))\n    # print(compare(result[9], result[10]))\n    # print(compare(result[10], result[11]))\n    # print(compare(result[11], result[12]))\n    # print(compare(result[12], result[13]))\n    # print(compare(result[13], result[14]))\n    # print(compare(result[14], result[15]))\n    # print(compare(result[15], result[16]))\n    # print(compare(result[16], result[17]))\n    # print(compare(result[17], result[18]))\n    # print(compare(result[18], result[19]))\n    # print(compare(result[19], result[20]))\n    # print(compare(result[20], result[21]))\n    # print(compare(result[21], result[22]))\n    # print(compare(result[22], result[23]))\n    # print(compare(result[23], result[24]))\n    # print(compare(result[24], result[25]))\n    # print(compare(result[25], result[26]))\n    # print(compare(result[26], result[27]))\n    # print(compare(result[27], result[28]))\n    # print(compare(result[28], result[29]))\n    # print(compare(result[29], result[30]))\n    # print(compare(result[30], result[31]))\n    # print(compare(result[31], result[32]))\n    # print(compare(result[32], result[33]))\n    # print(compare(result[33], result[34]))\n    # print(compare(result[34], result[35]))\n    # print(compare(result[35], result[36]))\n    # print(compare(result[36], result[37]))\n    # print(compare(result[37], result[38]))\n    # print(compare(result[38], result[39]))\n    # print(compare(result[39], result[40]))\n    # print(compare(result[40], result[41]))\n    # print(compare(result[41], result[42]))\n    # print(compare(result[42], result[43]))\n    # print(compare(result[43], result[44]))\n    # print(compare(result[44], result[45]))\n    # print(compare(result[45], result[46]))\n    # print(compare(result[46], result[47]))\n    # print(compare(result[47], result[48]))\n    # print(compare(result[48], result[49]))\n    # print(compare(result[49], result[50]))\n    # print(compare(result[50], result[51]))\n    # print(compare(result[51], result[52]))\n    # print(compare(result[52], result[53]))\n    # print(compare(result[53], result[54]))\n    # print(compare(result[54], result[55]))\n    # print(compare(result[55], result[56]))\n    # print(compare(result[56], result[57]))\n    # print(compare(result[57], result[58]))\n    # print(compare(result[58], result[59]))\n    # print(compare(result[59], result[60]))\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.strip())\n    tree = [[0, 0]]\n    for i in range(1, n+1):\n        tree.append([0, i])\n    for i in range(n+1):\n        tree[i][0] = int(stdin.strip())\n    for i in range(1, n+1):\n        if i == 1:\n            continue\n        for j in range(i):\n            if tree[i][0] > tree[j][0]:\n                tree[i][0] = tree[j][0]\n    count = 0\n    for i in range(n, 0, -1):\n        if tree[i][0] > 0:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(max(len(list(root_to_leaf(0))), len(list(leaf_to_root(0)))) if n > 2 else len(list(root_to_leaf(0))))\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    nodes = sorted(list(map(int, stdin.strip().split())))\n    subsets = [[] for _ in range(nodes[0])]\n    subsets[0] = [(nodes[0], 0)]\n\n    for node in nodes[1:]:\n        parent = subsets[node]\n        for i in range(len(parent)):\n            for j in range(i + 1, len(parent)):\n                if parent[i][0] > parent[j][0]:\n                    parent[i], parent[j] = parent[j], parent[i]\n\n        subsets[node] = parent\n    return str(len(max(subsets, key=lambda x: len(x))))\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    vals = []\n    parents = []\n    for i in range(1, n+1):\n        vals.append(int(input()))\n        parents.append(int(input()))\n    return largest_heap(vals, parents, n)\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vals, parents = stdin.split()\n    vals = [int(i) for i in vals.split()]\n    parents = [int(i) for i in parents.split()]\n    d = defaultdict(list)\n    for i in range(n):\n        d[vals[i]].append(i+1)\n    res = 0\n    for i in range(1, n+1):\n        for j in d[i]:\n            for k in d[i]:\n                if j > k:\n                    res += 1\n    return str(res)"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Your code goes here'''\n    n = int(stdin.strip())\n    tree = []\n    for i in range(1, n + 1):\n        tree.append([i, int(stdin.strip().split()[i - 1])])\n    tree.sort(key=lambda x: x[1], reverse=True)\n\n    return str(get_max_heap_subset(tree))\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 5\n   ... 3 0\n   ... 3 1\n   ... 3 2\n   ... 3 3\n   ... 3 4\n   ... ''')\n    '1'\n    >>> solution('''\n   ... 6\n   ... 4 0\n   ... 3 1\n   ... 2 2\n   ... 1 3\n   ... 0 4\n   ... ''')\n    '5'\n    \"\"\"\n    n = int(stdin)\n    nodes = [[0, -1]]\n    for _ in range(n):\n        v, p = map(int, input().split())\n        nodes.append([v, p])\n    nodes.append([0, -1])\n    max_size = 0\n    for size in range(1, n+1):\n        for i in range(n+1-size):\n            j = i + size\n            if nodes[i][1] > nodes[j][1]:\n                max_size = max(max_size, size)\n    return str(max_size)\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    # Write your code here\n    result = 0\n    return result\n"
    },
    {
        "number": 3030,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    children = list(map(lambda x: list(map(lambda y: int(y), x.split()))[1:], stdin.split('\\n')[1:]))\n    parents = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        parent = children[i - 1][0]\n        if parent > i:\n            continue\n        for j in range(len(children[i - 1])):\n            parents[parent].append(i)\n    visited = [False for _ in range(n + 1)]\n    solution = 0\n    for i in range(1, n + 1):\n        if not visited[i] and len(parents[i]) > 0:\n            visited[i] = True\n            stack = [i]\n            while len(stack) > 0:\n                current = stack.pop()\n                for p in parents[current]:\n                    visited[p] = True\n                    stack.append(p)\n                solution += 1\n    return str(solution)\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return str(0)\n    edges = []\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.split())\n        edges.append((a, b, c))\n        edges.append((b, a, c))\n    edges.sort(key=lambda x: x[2])\n    good_nodes = []\n    good_nodes.append(1)\n    good = 1\n    for a, b, c in edges:\n        if c!= good:\n            good_nodes = []\n            good = c\n        good_nodes.append(b)\n    return str(len(good_nodes))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    n = int(stdin.pop(0))\n    goodNodes = []\n    graph = defaultdict(set)\n    for i in range(n):\n        a, b, c = map(int, stdin.pop(0).split())\n        graph[a].add(b)\n        graph[b].add(a)\n        graph[c].add(a)\n        graph[a].add(c)\n    \n    # print(graph)\n    visited = set()\n    def dfs(node):\n        if node in visited:\n            return False\n        visited.add(node)\n        for adj in graph[node]:\n            if adj not in visited:\n                if dfs(adj):\n                    return True\n        return False\n    \n    for i in range(1, n+1):\n        if dfs(i):\n            goodNodes.append(i)\n    # print(goodNodes)\n    return str(len(goodNodes))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin)\n    stations = {}\n    for i in range(num_nodes):\n        x, y, c = stdin.split()\n        stations[int(x)] = int(c)\n        stations[int(y)] = int(c)\n    good_nodes = set()\n    for i in range(num_nodes):\n        if i not in stations:\n            continue\n        is_good = True\n        for j in range(num_nodes):\n            if j == i:\n                continue\n            if i in stations and j in stations and stations[i]!= stations[j]:\n                is_good = False\n                break\n        if is_good:\n            good_nodes.add(i)\n    return str(len(good_nodes)) + '\\n' +''.join(map(str, sorted(good_nodes)))\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    n = int(data[0])\n    good = []\n    for i in range(n):\n        line = stdin.split()\n        good.append(line[0])\n        good.append(line[1])\n        good.append(line[2])\n    good = sorted(set(good))\n    return str(len(good)) + \"\\n\" + \" \".join(good)\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n\n    # Edge colors are indexed from 1 to n, and the node names are indexed from 0 to n.\n    # Edge colors are indexed from 0 to (n - 1).\n    # Node names are indexed from 0 to (n - 1).\n    edges = {int(i): (int(i) - 1) for i in stdin.split()[1:]}\n    tree = _construct_undirected_tree(n, edges)\n\n    # Dict of good nodes, indexed by node index.\n    good_nodes = {}\n\n    for root in tree.values():\n        good_nodes[root] = _find_good_nodes(root, tree, good_nodes)\n\n    return str(len(good_nodes)) + '\\n' + '\\n'.join([str(node_index) for node_index in sorted(good_nodes)])\n\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    edges = stdin[1:]\n    # if the tree has just one node, it's a good tree\n    if n == 1:\n        return f\"{n} 0\"\n\n    tree = {}\n    # build the tree\n    for (a, b, c) in edges:\n        if a not in tree:\n            tree[a] = set()\n        if b not in tree:\n            tree[b] = set()\n        tree[a].add(c)\n        tree[b].add(c)\n\n    good_nodes = set()\n    # find all the good nodes\n    for node in tree:\n        if len(tree[node]) == len(tree) - 1:\n            good_nodes.add(node)\n\n    good_nodes_list = list(good_nodes)\n    # sort the nodes by degree\n    good_nodes_list.sort(key=lambda x: len(tree[x]), reverse=True)\n    return f\"{len(good_nodes)} {len(good_nodes_list)}\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1\n    def is_good(node):\n        for i in range(len(node) - 1):\n            if node[i] == node[i + 1]:\n                return False\n        return True\n\n    # Solution 2\n    # def is_good(node):\n    #     for i in range(len(node) - 1):\n    #         if node[i] == node[i + 1]:\n    #             return False\n    #     return True\n\n    # Solution 3\n    # def is_good(node):\n    #     for i in range(len(node) - 1):\n    #         if node[i] == node[i + 1]:\n    #             return False\n    #     return True\n\n    # Solution 4\n    # def is_good(node):\n    #     colors = set()\n    #     for i in range(len(node) - 1):\n    #         colors.add(node[i])\n    #     return len(colors) == len(node)\n\n    # Solution 5\n    # def is_good(node):\n    #     colors = set()\n    #     for i in range(len(node) - 1):\n    #         colors.add(node[i])\n    #     return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 6\n    # def is_good(node):\n    #     colors = set()\n    #     for i in range(len(node) - 1):\n    #         colors.add(node[i])\n    #     return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 7\n    def is_good(node):\n        colors = []\n        for i in range(len(node) - 1):\n            colors.append(node[i])\n        return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 8\n    # def is_good(node):\n    #     colors = []\n    #     for i in range(len(node) - 1):\n    #         colors.append(node[i])\n    #     return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 9\n    def is_good(node):\n        colors = []\n        for i in range(len(node) - 1):\n            colors.append(node[i])\n        return len(colors) == len(node)\n\n    # Solution 10\n    def is_good(node):\n        colors = []\n        for i in range(len(node) - 1):\n            colors.append(node[i])\n        return len(colors) == len(node)\n\n    # Solution 11\n    def is_good(node):\n        return len(node) == len(set(node))\n\n    # Solution 12\n    def is_good(node):\n        return len(node) == len(set(node)) and len(node)!= 2\n\n    # Solution 13\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node)\n\n    # Solution 14\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 15\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node)\n\n    # Solution 16\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 17\n    def is_good(node):\n        return len(set(node)) == len(node)\n\n    # Solution 18\n    def is_good(node):\n        return len(set(node)) == len(node) and len(set(node))!= 2\n\n    # Solution 19\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node)\n\n    # Solution 20\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node) and len(colors)!= 2\n\n    # Solution 21\n    def is_good(node):\n        return len(set(node)) == len(node)\n\n    # Solution 22\n    def is_good(node):\n        return len(set(node)) == len(node) and len(set(node))!= 2\n\n    # Solution 23\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len(colors) == len(node)\n\n    # Solution 24\n    def is_good(node):\n        colors = set()\n        for i in range(len(node) - 1):\n            colors.add(node[i])\n        return len"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    graph = defaultdict(lambda: defaultdict(set))\n    for i in range(n - 1):\n        a, b, c = map(int, stdin.strip().split())\n        graph[a][b] = c\n        graph[b][a] = c\n\n    visited = set()\n    all_good = 0\n\n    def dfs(start_node, visited):\n        nonlocal all_good\n        if start_node in visited:\n            return\n        visited.add(start_node)\n        for neighbor in graph[start_node]:\n            if neighbor in visited:\n                continue\n            dfs(neighbor, visited)\n\n    for i in range(1, n):\n        dfs(i, visited)\n        all_good += 1 if i in visited else 0\n\n    return str(all_good)\n"
    },
    {
        "number": 3031,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    nodes = {i: Node(i) for i in range(1, n + 1)}\n    for n1, n2, c in stdin.splitlines():\n        nodes[int(n1)].connect(nodes[int(n2)], int(c))\n        nodes[int(n2)].connect(nodes[int(n1)], int(c))\n    good_nodes = {n for n in nodes.values() if n.is_good_node()}\n    return f'{len(good_nodes)}' + '\\n' + '\\n'.join(map(str, sorted(good_nodes)))\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    memory_banks = list(map(int, stdin.split()))\n    num_variables = memory_banks[1]\n    program = stdin[stdin.index(\"\\n\") + 1:]\n    max_num_variables_per_bank = math.ceil(math.log2(memory_banks[0]))\n    max_num_repetitions = math.ceil(math.log2(memory_banks[0] * memory_banks[1]))\n    max_instructions_per_instruction = math.ceil(math.log2(max_num_variables_per_bank * max_num_repetitions))\n    program = list(map(lambda x: x.split(), program.split(\"\\n\")))\n    start_time = time.time()\n    for _ in range(max_instructions_per_instruction):\n        for instructions in program:\n            for instruction in instructions:\n                if instruction == \"E\":\n                    instruction = instructions.pop(0)\n                if instruction == \"R\":\n                    var_index = instructions[0]\n                    instructions.pop(0)\n                    for i in range(1, max_num_repetitions + 1):\n                        if var_index >= max_num_variables_per_bank * i:\n                            var_index = var_index - max_num_variables_per_bank * i\n                        else:\n                            var_index = var_index - max_num_variables_per_bank * (i - 1)\n                        if var_index < 0:\n                            var_index = var_index + max_num_variables_per_bank * i\n                            var_index = var_index - max_num_variables_per_bank * (i - 1)\n                        instructions.append(var_index)\n                    instructions.append(instruction)\n                elif instruction == \"V\":\n                    var_index = instructions[0]\n                    instructions.pop(0)\n                    for i in range(1, max_num_variables_per_bank + 1):\n                        var_index = var_index + i\n                        if var_index >= memory_banks[0] * memory_banks[1]:\n                            var_index = var_index - memory_banks[0] * memory_banks[1]\n                        if var_index < 0:\n                            var_index = var_index + memory_banks[0] * memory_banks[1]\n                        instructions.append(var_index)\n                    instructions.append(instruction)\n            for i in range(1, max_num_repetitions + 1):\n                if program[-1][-1] == \"R\":\n                    program[-1].pop(-1)\n                else:\n                    program[-1][-1] = program[-1][-1] - max_num_repetitions * i\n                    if program[-1][-1] < 0:\n                        program[-1][-1] = program[-1][-1] + max_num_repetitions * i\n            program.pop(-1)\n    end_time = time.time()\n    return str(end_time - start_time)\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.split()\n\n    # make a copy of the input to work with\n    input_ = stdin.copy()\n\n    # for each item in input\n    # if it is a repetition\n    # if it starts with an R\n    # if the second item in the pair is a V\n    # if the third item in the pair is an E\n    # if the fourth item in the pair is a V\n    # if the fifth item in the pair is an E\n    # if the sixth item in the pair is a V\n    # add one to the answer\n    # for each item in input\n    # if it is a repetition\n    # if it starts with an R\n    # if the second item in the pair is a V\n    # if the third item in the pair is an E\n    # if the fourth item in the pair is a V\n    # if the fifth item in the pair is an E\n    # if the sixth item in the pair is a V\n    # remove the item from the list\n    # make a copy of the input to work with\n    # for each item in input\n    # if it is a repetition\n    # if it starts with an R\n    # if the second item in the pair is a V\n    # if the third item in the pair is an E\n    # if the fourth item in the pair is a V\n    # if the fifth item in the pair is an E\n    # if the sixth item in the pair is a V\n    # add one to the answer\n    # for each item in input\n    # if it is a repetition\n    # if it starts with an R\n    # if the second item in the pair is a V\n    # if the third item in the pair is an E\n    # if the fourth item in the pair is a V\n    # if the fifth item in the pair is an E\n    # if the sixth item in the pair is a V\n    # remove the item from the list\n    # return the answer\n    # return the answer\n\n    # parse the input\n    # get the size of the memory banks\n    b = int(input_[0])\n\n    # get the size of the variables\n    s = int(input_[1])\n\n    # get the program\n    program = input_[2:]\n\n    # initialize variables\n    c = 0\n    d = 0\n\n    # for each item in the program\n    for i in range(0, len(program)):\n        # print(i)\n        # if it is a repetition\n        if \"R\" in program[i]:\n            # print(program[i])\n            # if it starts with an R\n            if \"R\" in program[i]:\n                # print(\"True\")\n                # if the second item in the pair is a V\n                if \"V\" in program[i + 1]:\n                    # print(\"True\")\n                    # if the third item in the pair is an E\n                    if \"E\" in program[i + 2]:\n                        # print(\"True\")\n                        # if the fourth item in the pair is a V\n                        if \"V\" in program[i + 3]:\n                            # print(\"True\")\n                            # if the fifth item in the pair is an E\n                            if \"E\" in program[i + 4]:\n                                # print(\"True\")\n                                # if the sixth item in the pair is a V\n                                if \"V\" in program[i + 5]:\n                                    # print(\"True\")\n                                    # add one to the answer\n                                    c += 1\n                        # print(\"False\")\n                    # print(\"False\")\n                # print(\"False\")\n            # print(\"False\")\n        # print(\"False\")\n    # for each item in the program\n    for i in range(0, len(program)):\n        # if it is a repetition\n        if \"R\" in program[i]:\n            # if it starts with an R\n            if \"R\" in program[i]:\n                # if the second item in the pair is a V\n                if \"V\" in program[i + 1]:\n                    # if the third item in the pair is an E\n                    if \"E\" in program[i + 2]:\n                        # if the fourth item in the pair is a V\n                        if \"V\" in program[i + 3]:\n                            # if the fifth item in the pair is an E\n                            if \"E\" in program[i + 4]:\n                                # if the sixth item in the pair is a V\n                                if \"V\" in program[i + 5]:\n                                    # add one to the answer\n                                    d += 1\n        # print(\"False\")\n\n    # return the answer\n    return str(min(c, d))\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    banks, n_variables = stdin.strip().split()\n    n_variables = int(n_variables)\n    max_operations = math.ceil(math.log2(n_variables))\n    minimum = math.inf\n    while n_variables < 2 ** max_operations:\n        number_of_executions = 0\n        banks_map = {}\n        for i in range(n_variables):\n            banks_map[i] = 1\n        for i in range(max_operations):\n            number_of_executions += 2 ** i\n            for j in range(1 << i):\n                i_bit = i\n                i_bit -= j\n                for k in range(1 << i):\n                    i_bit = i_bit ^ k\n                    for m in range(1 << i):\n                        i_bit = i_bit ^ m\n                        banks_map[i_bit] += 1\n                        if i_bit in banks_map:\n                            number_of_executions += 1\n        if number_of_executions < minimum:\n            minimum = number_of_executions\n    return str(minimum)\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip()"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    banks, variables, programs = stdin.split('\\n')\n    banks = int(banks)\n    variables = int(variables)\n    programs = programs.split()\n\n    # write your code here\n    return str(findMin(banks, variables, programs))\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_data_from_line(line: str) -> Tuple[int, int, str]:\n        b, s = map(int, line.split())\n        return (b, s)\n\n    b, s = map(int, stdin.split())\n    data = stdin.strip().split()\n    return''.join(str(min(get_execution_time_from_program(program, *get_data_from_line(program))\n                           for program in data)) for i in range(b))\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split())\n    variables = {}\n    memory = []\n    def next_value():\n        if len(memory) == 0:\n            if len(variables) == 0:\n                return -1\n            return next(iter(variables.values()))\n        else:\n            return memory.pop(0)\n    def next_operation(operation):\n        if operation.startswith(\"R\"):\n            return \"R\" + str(len(memory)) + \" \" + operation\n        else:\n            variable, value = operation.split()\n            if variable not in variables:\n                variables[variable] = next_value()\n            return \"V\" + str(variables[variable]) + \" \" + value\n    def next_line():\n        for line in stdin.splitlines():\n            instruction, *operands = line.split()\n            if instruction == \"V\":\n                memory.append(int(operands[0]))\n            else:\n                if int(operands[0]) > 0:\n                    memory.append(int(operands[0]))\n                if int(operands[1]) > 0:\n                    memory.append(int(operands[1]))\n                memory.append(next_value())\n        return next_operation(stdin.split()[-1])\n    return next_line()"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    memory = [0] * 13\n    variables = {}\n    execution_time = 0\n    operations = [x.split() for x in stdin.splitlines()]\n    for operation in operations:\n        if operation[0] == 'V':\n            if operation[1] in variables:\n                memory[variables[operation[1]]] = operation[2]\n            else:\n                variables[operation[1]] = len(memory)\n                memory.append(operation[2])\n        elif operation[0] == 'E':\n            execution_time += 1\n            variables = {}\n        else:\n            execution_time += len(operation)\n    return str(execution_time)\n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b,s = list(map(int,stdin.split()))\n    g = []\n    p = []\n    for i in stdin.split()[1:]:\n        if i == \"R\":\n            g.append((i,int(list(stdin.split()[1:])[0])))\n        else:\n            p.append(i)\n    if not g:\n        return str(p.pop())\n    else:\n        return str(len(p)+len(g))\n    \n"
    },
    {
        "number": 3032,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin:\n    The program has one line (space-separated integers $b$ and $s$).\n    $b$ is the number of memory banks and $s$ is the number of variables that can be stored in each memory bank.\n    The second line contains a program. It consists of at most $1000$ space-separated elements (each R$n$, V$i$, and E counts as one element).\n\n    The program is the body of a repetition R$n$ <program> E, where <program> is not empty.\n    $n$ is the number of repetitions.\n    The loop body <program> is not empty.\n    \"\"\"\n\n    def calculate_max_value_for_b(n: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $b$\n        $b$ is the number of memory banks and $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_value_for_b = (n - 1) * 2 + 1\n        return max_value_for_b\n\n    def calculate_max_value_for_s(n: int, s: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $s$\n        $n$ is the number of repetitions.\n        $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_value_for_s = (n + s - 1) * 2\n        return max_value_for_s\n\n    def calculate_max_value_for_program(program: str, n: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $b$ and $s$\n        $n$ is the number of repetitions.\n        $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_value_for_b = (n - 1) * 2 + 1\n        max_value_for_s = (n + s - 1) * 2\n        max_value_for_program = 0\n        for i in range(len(program)):\n            if program[i] == 'R':\n                # calculate maximum for $n$\n                max_value_for_program += (max_value_for_s - max_value_for_b)\n            else:\n                max_value_for_program += max_value_for_b\n        return max_value_for_program\n\n    def calculate_max_memory_value_for_b(n: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $b$\n        $b$ is the number of memory banks and $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_memory_value_for_b = n * 2 + 1\n        return max_memory_value_for_b\n\n    def calculate_max_memory_value_for_s(n: int, s: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $s$\n        $n$ is the number of repetitions.\n        $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_memory_value_for_s = (n + s - 1) * 2\n        return max_memory_value_for_s\n\n    def calculate_max_memory_value_for_program(program: str, n: int) -> int:\n        \"\"\"\n        Calculate the maximum value for $b$ and $s$\n        $n$ is the number of repetitions.\n        $s$ is the number of variables that can be stored in each memory bank.\n        \"\"\"\n        max_memory_value_for_program = (n + 1) * 2\n        for i in range(len(program)):\n            if program[i] == 'R':\n                max_memory_value_for_program += (calculate_max_memory_value_for_s(n, s) - calculate_max_memory_value_for_b(n))\n            else:\n                max_memory_value_for_program += calculate_max_memory_value_for_b(n)\n        return max_memory_value_for_program\n\n    def execute_one_instruction(\n            b: int,\n            s: int,\n            i: int,\n            program: str,\n            memory: dict\n    ) -> int:\n        \"\"\"\n        Given b, s, i, program and memory, execute the next instruction in the program,\n        return the execution time.\n        \"\"\"\n        if program[i] == 'V':\n            # variable reference\n            if i not in memory:\n                memory[i] = 0\n            return calculate_max_value_for_s(b, s) - b\n        elif program[i] == 'R':\n            # repetition\n            # R$n$ <program> E\n            if i not in memory:\n                memory["
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a,b = map(int,stdin.split())\n    ans = -1\n    for i in range(2,10**8):\n        if i*b == a:\n            ans = i\n            break\n    return ans\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    def f(x: int) -> int:\n        while x:\n            x, r = divmod(x, b)\n            if r == n:\n                return r\n    return str(f(2**63)) if f(2**63)!= 0 else 'impossible'"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.strip().split())\n    for i in range(n):\n        if b == 1:\n            return \"impossible\"\n        if b == 2:\n            if n % 3 == 0:\n                return n//3\n            else:\n                return \"impossible\"\n        n //= b\n        b *= 10\n    return n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if 2 * N <= 2 ** 63:\n        return (2 ** 63) - N\n\n    # if we have the number, we need to check\n    for base in range(3, max(B, 4) + 1):\n        if N % base == 0:\n            result = N // base\n            return str(result) + \" \" + str(base)\n    return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if 2 ** 64 <= N <= 2 ** 63:\n        for i in range(2 ** 63, -1, -1):\n            if f_B(i) == N:\n                return str(i)\n        return \"impossible\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    base = int(stdin.split(\" \")[0])\n    number = int(stdin.split(\" \")[1])\n    if not 2 < base <= 10:\n        return \"impossible\"\n    if not 0 < number < 2**63:\n        return \"impossible\"\n    if base == 3:\n        return str(number)\n    # here goes your code"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 1:\n        return str(B)\n    if N == 0:\n        return \"impossible\"\n    if N % 2 == 0:\n        return \"impossible\"\n    num_to_mult = 0\n    num_to_mult = 2 ** (N - 1)\n    num_to_mult -= 1\n    num_to_mult = int(num_to_mult)\n    num_to_mult += 1\n    num_to_mult = int(num_to_mult)\n    while num_to_mult > 0:\n        if num_to_mult % 2 == 1:\n            num_to_mult -= 1\n            num_to_mult = int(num_to_mult)\n            num_to_mult += 1\n            num_to_mult = int(num_to_mult)\n        else:\n            num_to_mult -= 2\n            num_to_mult = int(num_to_mult)\n            num_to_mult += 1\n            num_to_mult = int(num_to_mult)\n        if num_to_mult % 2 == 0:\n            num_to_mult += 1\n            num_to_mult = int(num_to_mult)\n    return str(num_to_mult)"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    B, N = list(map(int, stdin.split()))\n    max_num = int(2 ** 63)\n    if (B - 1) * 2 ** 63 + N <= max_num:\n        return str(max_num - (B - 1) * 2 ** 63 + N)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, b, n = stdin.split()\n    a = int(b)\n    for i in range(b, a, -1):\n        if int(n) % int(i) == 0:\n            return str(i)\n    return 'impossible'\n"
    },
    {
        "number": 3033,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = (int(i) for i in stdin.split())\n    if 2 <= B <= 10000:\n        if 0 <= N <= 2**63:\n            for i in range(1, 2**63):\n                if i * B == N:\n                    return i\n    return 'impossible'\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For each line, do the following:\n    1) Convert the float representation of the cloud probability to an integer in range (0, 1000000)\n    2) Convert the float representation of the cloud amount to an integer in range (0, 1000)\n    3) Convert the float representation of the duration to an integer in range (0, 100)\n    4) Convert the float representation of the walking speed to an integer in range (0, 100)\n    5) Convert the float representation of the distance to an integer in range (0, 1000)\n    6) Convert the float representation of the number of roofs to an integer in range (0, 1000)\n    7) Loop through each line (skipping the first)\n        a) Convert the float representation of the distance to an integer in range (0, 1000)\n        b) Loop through the cloud probabilities\n            i) Convert the float representation of the cloud probability to an integer in range (0, 1000000)\n            ii) Store the cloud probability in a list of integers in the form of a binary tree\n        c) Loop through the cloud amount\n            i) Convert the float representation of the cloud amount to an integer in range (0, 1000)\n            ii) Store the cloud amount in a list of integers in the form of a binary tree\n        d) Loop through the duration\n            i) Convert the float representation of the duration to an integer in range (0, 100)\n            ii) Store the duration in a list of integers in the form of a binary tree\n        e) Loop through the walking speed\n            i) Convert the float representation of the walking speed to an integer in range (0, 100)\n            ii) Store the walking speed in a list of integers in the form of a binary tree\n        f) Loop through the distance\n            i) Convert the float representation of the distance to an integer in range (0, 1000)\n        g) Loop through the number of roofs\n            i) Convert the float representation of the number of roofs to an integer in range (0, 1000)\n        h) Loop through each roof segment\n            i) Convert the floats representation of the point coordinates to integers in range (0, 1000)\n            ii) Build the binary tree from the point coordinates\n        i) Store the list of integers representing the list of roofs in a binary tree\n    Hint: This is a simple tree traversal problem\n    \"\"\"\n    return...\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(int, stdin.split())\n        clouds.append((s, e, p, a))\n\n    segments = []\n    for i in range(r):\n        s, e = map(int, stdin.split())\n        segments.append((s, e))\n\n    s = d\n    l = 0\n    r = t\n    ans = 0\n    while s > r:\n        for i in range(r, s + 1):\n            for j in range(len(segments)):\n                s_ = i - l\n                e_ = i + l\n                if s_ <= segments[j][0] < e_:\n                    p = max(clouds[j][3], l / (clouds[j][1] - clouds[j][0]))\n                    x = max(segments[j][1], e_ - i)\n                    y = min(segments[j][0], i + l - s_)\n                    a = min(clouds[j][2], x / (clouds[j][1] - clouds[j][0]))\n                    ans += a * p\n\n        l += 1\n        r += 1\n\n    return str(ans)\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        clouds.append(list(map(float, stdin.split())))\n    for i in range(r):\n        clouds.append(list(map(float, stdin.split())))\n    for i in range(r):\n        clouds.append(list(map(float, stdin.split())))\n\n    temp = []\n    clouds = sorted(clouds, key=lambda x: x[0])\n    for i in range(len(clouds)):\n        temp.append(clouds[i][0])\n        temp.append(clouds[i][1])\n        temp.append(clouds[i][2])\n        temp.append(clouds[i][3])\n    clouds = temp\n\n    clouds = sorted(clouds, key=lambda x: x[1])\n    clouds = sorted(clouds, key=lambda x: x[2])\n    clouds = sorted(clouds, key=lambda x: x[3])\n\n    max_length = d\n    max_rain = 0\n    count = 0\n    count1 = 0\n    current_length = 0\n    current_length1 = 0\n    current_rain = 0\n    current_rain1 = 0\n    for i in range(len(clouds)):\n        if i < len(clouds)-1:\n            if current_length + clouds[i][0] + clouds[i][1] > d:\n                count1 += 1\n            if current_length1 + clouds[i][0] + clouds[i][1] > d:\n                count1 += 1\n            if current_rain + clouds[i][3] > max_rain:\n                max_rain = current_rain + clouds[i][3]\n            current_length = clouds[i][0]\n            current_length1 = clouds[i][1]\n            current_rain = clouds[i][3]\n        elif i == len(clouds)-1:\n            if current_length + clouds[i][0] + clouds[i][1] > d:\n                count1 += 1\n            if current_length1 + clouds[i][0] + clouds[i][1] > d:\n                count1 += 1\n            if current_rain + clouds[i][3] > max_rain:\n                max_rain = current_rain + clouds[i][3]\n            current_length = clouds[i][0]\n            current_length1 = clouds[i][1]\n            current_rain = clouds[i][3]\n            count1 += 1\n    return str(max_rain)"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    d = int(stdin[0])\n    t = int(stdin[1])\n    c = int(stdin[2])\n    r = int(stdin[3])\n    clouds = []\n    for i in range(c):\n        clouds.append(stdin[i * 4 + 4:i * 4 + 6])\n    clouds = sorted(clouds, key=lambda x: (x[0], x[1]))\n\n    def solve(t):\n        t = t - d\n        cloud_time = 0\n        cloud_num = 0\n        for i in clouds:\n            if i[1] >= t:\n                cloud_time += i[0]\n                cloud_num += 1\n            else:\n                break\n        if cloud_num == 0:\n            return t\n        else:\n            return cloud_time + solve(t)\n\n    return str(solve(t) - d)\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_of_clows, zip_stop, time_to_stop, num_of_r, r = stdin.strip().split('\\n')\n    num_of_clows, zip_stop, time_to_stop, num_of_r, r = int(num_of_clows), int(zip_stop), int(time_to_stop), int(num_of_r), int(r)\n    clouds = []\n    clouds.extend(map(int, stdin.strip().split('\\n')[1].split()))\n    clouds = sorted(clouds)\n\n    min_rain_in_nm = num_of_clows * r\n    interim = []\n    for i in range(1, len(clouds)):\n        if clouds[i-1] > clouds[i] and len(interim) == 0:\n            interim.append(clouds[i])\n            interim.append(clouds[i-1])\n        else:\n            interim.append(clouds[i-1])\n        if len(interim) == num_of_r and clouds[i] - clouds[i-1] <= time_to_stop:\n            min_rain_in_nm += (interim[-1] - interim[0]) * (time_to_stop - len(interim) + 1) / (time_to_stop - time_to_stop + len(interim) - 1)\n            interim = []\n\n    return str(min_rain_in_nm)"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # split input in to chunks\n    # now split the chunks into its respective variables\n    # print(chunk)\n    # now split the chunks into their respective variables\n    chunk = stdin.split('\\n')\n    chunk.pop()\n    d = int(chunk[0])\n    t = int(chunk[1])\n    c = int(chunk[2])\n    r = int(chunk[3])\n    chunk = chunk[4:]\n    # print(chunk)\n    chunk = sorted(chunk, key=lambda x: x.split(' '))\n    chunk = sorted(chunk, key=lambda x: x[0])\n    clouds = []\n    for i in chunk:\n        s, e, p, a = i.split(' ')\n        s, e, p, a = float(s), float(e), float(p), float(a)\n        clouds.append([s, e, p, a])\n    # print(clouds)\n    b = 0\n    # print(clouds)\n    for i in clouds:\n        # print(i)\n        p = i[2]\n        if p > 0:\n            b += (i[1] - i[0]) * p\n    # print(b)\n    # print(clouds)\n    dist = 1\n    for i in clouds:\n        s, e, p, a = i\n        # print(s, e, p, a)\n        r = dist\n        s = max(s, r)\n        e = min(e, t - dist)\n        p = max(p, dist * a)\n        dist += (e - s) * p / c\n    # print(dist)\n    return str(dist)\n"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    d, t, c, r = (int(x) for x in stdin.split())\n    clouds = []\n    for i in range(c):\n        clouds.append(tuple(\n            (int(x) for x in stdin.split())\n        ))\n\n    # print(d, t, c, r)\n    # print(clouds)\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n\n    # --- CUSTOM SOLUTION ---\n    # --- CUSTOM SOLUTION ---\n    # ---"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    d, t, c, r = map(int, input_list[0].split())\n    clouds = input_list[1:]\n    all_clouds = []\n    for cloud in clouds:\n        all_clouds.append(list(map(float, cloud.split())))\n\n    ans = -1\n    return ans"
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        l, r, p, a = map(float, stdin.split())\n        clouds.append((l, r, p, a))\n    lo, hi = 0, d\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if all(c[0] <= mid <= c[1] for c in clouds):\n            if all(c[2] <= mid <= c[3] for c in clouds):\n                lo = mid + 1\n            else:\n                hi = mid - 1\n        else:\n            if all(c[1] <= mid <= c[2] for c in clouds):\n                hi = mid - 1\n            else:\n                lo = mid + 1\n    return f\"{(hi - lo) * 1 / 60:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n\n    # First line is always the distance\n    # d = int(lines[0])\n\n    # Get the distances between lines\n    dists = []\n    for i, line in enumerate(lines[1:]):\n        dists.append(int(line))\n        if i == len(lines) - 2:\n            break\n\n    # Get the timestamp for line i\n    timestamp = int(lines[i + 1])\n\n    # Get the amount of clouds\n    n = int(lines[2])\n\n    # Get the times\n    times = []\n    for i, line in enumerate(lines[3:]):\n        times.append(int(line))\n        if i == len(lines) - n - 3:\n            break\n\n    # Get the probabilities\n    probabilities = []\n    for i, line in enumerate(lines[3 + n:]):\n        probabilities.append(float(line))\n        if i == len(lines) - n - 2:\n            break\n\n    # Get the rain amount\n    amounts = []\n    for i, line in enumerate(lines[3 + n + n:]):\n        amounts.append(float(line))\n        if i == len(lines) - n - n - 1:\n            break\n\n    # Calculate the amount of rain\n    amounts = np.array(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i starts raining\n    times = np.array(times)\n    for i in range(n):\n        times += probabilities[i] * dists[i]\n\n    # Calculate the time until cloud i ends raining\n    times = np.cumsum(times)\n    for i in range(n):\n        times += probabilities[i] * dists[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    times = np.cumsum(times)\n    for i in range(n):\n        times += probabilities[i] * dists[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until cloud i ends raining\n    amounts = np.cumsum(amounts)\n    for i in range(n):\n        amounts += probabilities[i] * amounts[i]\n\n    # Calculate the time until"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    return str(max(map(lambda x: float(x[1]) / float(x[2]), zip(stdin[1::2], stdin[2::2], map(float, stdin[::2])))))"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(max(float(i) for i in stdin.split()))\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    wanted_to_give = {line.split(' ')[1]: line.split(' ')[2] for line in lines}\n    give_to_wanted = {line.split(' ')[2]: line.split(' ')[1] for line in lines}\n    common_lots = {}\n    for w in wanted_to_give:\n        for g in give_to_wanted:\n            if w == g:\n                common_lots[w] = round(float(wanted_to_give[w]) * float(give_to_wanted[g]), 10)\n    max_lot = -1\n    for k, v in common_lots.items():\n        if v > max_lot:\n            max_lot = v\n    return str(max_lot)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split(\"\\n\")\n    return str(max(1.5 * float(inputs[i]) for i in range(len(inputs))))\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n    for x in itertools.product(*[(p, w) for p, w in map(lambda r: list(map(float, r.split())), stdin.strip().split('\\n'))]):\n        if x[0] <= x[1]:\n            M = min(10, x[0] / x[1])\n            if M < 10 ** -6:\n                return str(int(M))\n            else:\n                return str(round(M, 10 ** -6))\n    return str(0.0)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    blue = 0\n    res = 0\n    while n > 0:\n        if n % 2 == 0:\n            blue = (blue + n // 2) * 2\n        else:\n            blue += n // 2\n            n -= 1\n        n //= 2\n    res = blue * 10**-6\n    return str(res)"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin_split = stdin.split('\\n')\n    print(stdin_split)\n    total_amount_of_blue_lemonade = 0\n    amount_of_trade_rates_and_quantities = {}\n    for line in stdin_split:\n        trade_rate = float(line.split(' ')[1])\n        trade_quantity = float(line.split(' ')[0])\n        trade_name = line.split(' ')[1] + line.split(' ')[2]\n        amount_of_trade_rates_and_quantities[trade_rate] = amount_of_trade_rates_and_quantities.get(trade_rate, 0) + trade_quantity\n        total_amount_of_blue_lemonade = total_amount_of_blue_lemonade + trade_rate * trade_quantity\n    for trade_rate, trade_quantity in amount_of_trade_rates_and_quantities.items():\n        print(trade_rate, trade_quantity)\n    print(amount_of_trade_rates_and_quantities)\n    print(total_amount_of_blue_lemonade)\n    return str(total_amount_of_blue_lemonade)\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"\".join(\n        \"\".join(str(float(item.split(\" \")[1]) * float(item.split(\" \")[2]))\n                for item in stdin.splitlines()))\n"
    },
    {
        "number": 3035,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    o = []\n    w = []\n    r = []\n    for i in range(n):\n        o.append(input())\n        w.append(input())\n        r.append(float(input()))\n    results = [0]*n\n    results[0] = r[0]*o[0]*w[0]\n    for i in range(1, n):\n        result = float(results[i-1])\n        if results[i-1]!= 0 and r[i] > 0:\n            result += (r[i]*o[i]*w[i])\n        results[i] = result\n    return \"{:.6f}\".format(max(results))\nsolution(input())\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    inf = 10**18\n    ans = 0\n    for i in range(len(stdin)):\n        n = int(stdin[i])\n        if n >= inf:\n            ans = inf\n            break\n        if n == 0:\n            continue\n        n = n + 1\n        dishes = {int(i) for i in stdin[i + 1].split()}\n        brands = {int(i) for i in stdin[i + 2].split()}\n        l = len(dishes)\n        for j in range(1, l + 1):\n            dishes_i = dishes.difference(set([j]))\n            brands_i = brands.difference(set([j]))\n            if len(dishes_i) == 0 or len(brands_i) == 0:\n                continue\n            dishes_j = dishes.difference(set([j]))\n            brands_j = brands.difference(set([j]))\n            if len(dishes_i) == 0 and len(dishes_j) == 0:\n                continue\n            if len(dishes_i) < len(dishes_j):\n                dishes_i, dishes_j = dishes_j, dishes_i\n                brands_i, brands_j = brands_j, brands_i\n            if len(dishes_i) == 0:\n                ans += 1\n                continue\n            for d_i in dishes_i:\n                for d_j in dishes_j:\n                    for b_i in brands_i:\n                        for b_j in brands_j:\n                            if d_i!= d_j and b_i!= b_j:\n                                continue\n                            if b_i == b_j:\n                                continue\n                            if d_i == d_j and (b_i == b_i or b_j == b_j):\n                                continue\n                            if (d_i, b_i) in seen or (d_j, b_j) in seen:\n                                continue\n                            seen.add((d_i, b_i))\n                            seen.add((d_j, b_j))\n                            ans += 1\n                            break\n    return str(ans)\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n    6 1 1 1 0\n    2 3 1 5 3 2\n    2 1 2\n    3 3 4 5\n    1 6\n    ''')\n    '180'\n    >>> solution('''\n    3 2 2 1 1\n    2 3 2\n    1 1\n    1 2\n    1 2\n    1 3\n    1 1\n    2 3\n    Sample Output 2:\n    22\n    ''')\n    '22'\n    \"\"\"\n    # make sure the input is clean\n    stdin = stdin.rstrip()\n    dishes = {}\n    for line in stdin.split('\\n'):\n        parts = line.split()\n        num_ingredients = int(parts[0])\n        ingredients = list(map(int, parts[1:]))\n        dishes[tuple(ingredients)] = num_ingredients\n    # count and print\n    poss_dishes = []\n    for k in dishes.keys():\n        ingredients = list(k)\n        dish = dishes[k]\n        ingredients.sort()\n        if len(set(ingredients)) < dish:\n            poss_dishes.append(k)\n    print(len(poss_dishes))\n    return str(len(poss_dishes))\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # \uc2dc\uac04\ucd08\uacfc\n    # dictionary \ub9cc\ub4e4\uae30\n    dictionary = {}\n    for i in range(int(stdin.split('\\n')[0])):\n        dictionary[i] = int(stdin.split('\\n')[i+1])\n    # print(dictionary)\n\n    # \uc778\ub371\uc2a4 \uc81c\uc678\ud558\uace0 \uc815\ub82c\n    array = sorted(dictionary.items(), key=lambda x: x[0])\n    # print(array)\n\n    # \uccab\ubc88\uc9f8 \uc81c\uac70\n    del array[0]\n    # print(array)\n\n    # \uccab\ubc88\uc9f8 \uc81c\uac70\n    del array[0]\n    # print(array)\n\n    # \ub450\ubc88\uc9f8 \uc81c\uac70\n    del array[0]\n    # print(array)\n\n    # \uacb0\uacfc \ub9ac\ud134\n    result = 0\n    for i in range(int(stdin.split('\\n')[0])):\n        if dictionary[i][0] == dictionary[i+1][0]:\n            result += 1\n    return str(result)"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    dishes = []\n    for dish in stdin[:-1]:\n        dishes.append(list(map(int, dish.split())))\n    brands = list(map(int, stdin[-1].split()))\n    res = []\n    for i in range(len(dishes)):\n        dishes_i = dishes[i]\n        brands_i = brands[i]\n        for j in range(i + 1, len(dishes)):\n            dishes_j = dishes[j]\n            if dishes_i!= dishes_j and dishes_i[0]!= dishes_j[0]:\n                if dishes_i[0] == dishes_j[0]:\n                    if dishes_i == dishes_j:\n                        continue\n                    if len(dishes_i) == len(dishes_j):\n                        if len(set(dishes_i).intersection(set(dishes_j))) == 0:\n                            res.append((dishes_i, dishes_j))\n                else:\n                    if len(set(dishes_i).intersection(set(dishes_j))) == 0:\n                        res.append((dishes_i, dishes_j))\n    if len(res) > 10 ** 18:\n        return 'too many'\n    elif len(res) > 0:\n        return str(len(res))\n    else:\n        return '0'\n\n\nprint(solution(open('input.txt', 'r').read()))\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return 'too many' if solution_naive(stdin) > 10 ** 18 else solution_naive(stdin)\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = (int(x) for x in stdin.split())\n    a = set()\n    b = set()\n    s_d = []\n    m_d = []\n    d_d = []\n    for i in range(s):\n        s_d.append(int(stdin.split()[i]))\n    for i in range(m):\n        m_d.append(int(stdin.split()[i * 2 + 1]))\n    for i in range(d):\n        d_d.append(int(stdin.split()[i * 2 + 1 + m * 2]))\n    for i in range(n):\n        a.add((int(stdin.split()[i * 2]), int(stdin.split()[i * 2 + 1])))\n        b.add((int(stdin.split()[i * 2 + 1]), int(stdin.split()[i * 2])))\n    a_b = len(a) + len(b)\n    s_b = len(set(s_d)) + len(set(m_d)) + len(set(d_d))\n    m_b = len(set(m_d))\n    d_b = len(set(d_d))\n    if r + s + m + d + n > 10 ** 18:\n        return 'too many'\n    elif r + s + m + d + n <= 10 ** 18:\n        return str(min(r + s + m + d + n, a_b + s_b + m_b + d_b))"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Task:\n    Your task is to sort the dishes such that dishes that are compatible with each other are arranged in such a way that the incompatible dishes are adjacent to each other (the two incompatible dishes form an'swap' and the compatible dishes are in the same row).\n    '''\n    data = list(map(lambda x: list(map(lambda y: y, x)), stdin.split()))\n    dish_sizes = data[1:][0]\n    dish_b = data[1:][1]\n    dish_m = data[1:][2]\n    dish_d = data[1:][3]\n    dish_n = data[1:][4]\n    dish_p = list(map(lambda x: list(map(lambda y: y, x)), data[1:]))\n    dish_p_ranges = []\n    for i in range(len(dish_p)):\n        dish_p_ranges.append([dish_p[i][0]-1, dish_p[i][0]])\n        for j in range(len(dish_p[i])):\n            if j!= 0:\n                dish_p_ranges.append([dish_p[i][j]-1, dish_p[i][j]])\n    total = 0\n    for i in range(len(dish_p_ranges)):\n        total += len(list(filter(lambda x: x[0] <= dish_p_ranges[i][1] and dish_p_ranges[i][0] <= x[1], dish_p_ranges)))\n    print(total)\n    if total > 10**18:\n        return 'too many'\n    else:\n        return '{0:.0f}'.format(total)\n"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, s, mx_dishes, n_incompatible_dishes = map(int, stdin.split())\n    dishes = list(map(int, stdin.split()))\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list(all_brands.values())\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    brands.sort()\n    brands = set(brands)\n    brands = list(brands)\n    all_brands = {}\n    brands = []\n    for i in range(len(dishes)):\n        if dishes[i] not in all_brands:\n            all_brands[dishes[i]] = i + 1\n    brands = list("
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, *args = stdin.split()\n    res = 0\n    dishes = list(map(int, args[0].split()))\n    brands = list(map(int, args[1].split()))\n    starter = {i: 0 for i in range(1, max(dishes) + 1)}\n    main = {i: 0 for i in range(1, max(dishes) + 1)}\n    dessert = {i: 0 for i in range(1, max(dishes) + 1)}\n    for dish in args[2:]:\n        ingredients = list(map(int, dish.split()))\n        for ing in ingredients:\n            if not starter[ing]:\n                starter[ing] = ingredients.index(ing)\n            if not main[ing]:\n                main[ing] = ingredients.index(ing)\n            if not dessert[ing]:\n                dessert[ing] = ingredients.index(ing)\n    res = 0\n    for dish in dishes:\n        if main[dish] and starter[dish] and dessert[dish]:\n            res += 1\n    return str(res)\n\nprint(solution(input()))"
    },
    {
        "number": 3036,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_r, num_s, num_m, num_d, num_n = map(int, stdin.split())\n    # for the starters\n    # dic = {}\n    # for _ in range(num_r):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    dic = []\n    for _ in range(num_r):\n        dic.append(stdin.split())\n    # for the starters\n    # starter_dic = {}\n    # for _ in range(num_s):\n    #     line = stdin.split()[1:]\n    #     starter_dic[line[0]] = line[1:]\n    starter_dic = []\n    for _ in range(num_s):\n        starter_dic.append(stdin.split())\n    # for the starters\n    # starter_dic = {}\n    # for _ in range(num_s):\n    #     line = stdin.split()[1:]\n    #     starter_dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_r):\n    #     if i not in starter_dic:\n    #         starter_dic[i] = dic[i]\n    starter_dic = []\n    for i in range(num_r):\n        if i not in starter_dic:\n            starter_dic.append(dic[i])\n    # for the starters\n    # starter_dic = {}\n    # for _ in range(num_s):\n    #     line = stdin.split()[1:]\n    #     starter_dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_s):\n    #     if i not in starter_dic:\n    #         starter_dic[i] = starter_dic[i]\n    # for the starters\n    # for _ in range(num_m):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_m):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_d):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_d):\n    #     if i not in dic:\n    #         dic[i] = dic[i]\n    # for the starters\n    # for _ in range(num_n):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_n):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_n):\n    #     if i not in dic:\n    #         dic[i] = dic[i]\n    # for the starters\n    # for _ in range(num_m):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_m):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_d):\n    #     if i not in dic:\n    #         dic[i] = dic[i]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_d):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # for i in range(num_n):\n    #     if i not in dic:\n    #         dic[i] = dic[i]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_n):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_s):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters\n    # dic = {}\n    # for _ in range(num_r):\n    #     line = stdin.split()[1:]\n    #     dic[line[0]] = line[1:]\n    # for the starters"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Clean up input\n    lines = stdin.strip().split('\\n')\n    board = []\n    for line in lines:\n        board.append(list(line))\n\n    height = len(board)\n    width = len(board[0])\n    num_cmd = int(lines[0])\n    for _ in range(num_cmd):\n        cmd = lines[1 + 2 * _]\n        direction = cmd[0]\n        distance = int(cmd[1:])\n        # print(\"CMD\", cmd, \"D\", direction, distance)\n        y = height - 1\n        x = width - 1\n        direction_map = {'u': (-1, 0), 'r': (0, 1), 'd': (1, 0), 'l': (0, -1)}\n        x_inc, y_inc = direction_map[direction]\n        for i in range(distance):\n            if board[y][x] == '.':\n                # print(\"BLANK\")\n                x += x_inc\n                y += y_inc\n            else:\n                # print(\"MARKED\")\n                x -= x_inc\n                y -= y_inc\n            x %= width\n            y %= height\n\n        # print(\"New X:\", x, \"New Y:\", y)\n        if board[y][x] == '.':\n            board[y][x] = '#'\n        else:\n            board[y][x] = '.'\n\n    # Now go through and count the #s\n    marker_count = 0\n    for y in range(height):\n        for x in range(width):\n            if board[y][x] == '#':\n                marker_count += 1\n\n    return str(marker_count) + \" \" + str(height * width - marker_count)\n\nprint(solution(input()))"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_cmds(input: str) -> List[str]:\n        cmds = []\n        for line in input.splitlines():\n            tokens = line.split()\n            if len(tokens) == 2:\n                cmds.append((tokens[0], int(tokens[1])))\n            else:\n                cmds.append((tokens[0], int(tokens[1:])))\n        return cmds\n\n\n    h, w, n = list(map(int, stdin.splitlines()[0].split()))\n    input_data = '\\n'.join(stdin.splitlines()[1:])\n    cmds = get_cmds(input_data)\n    output = -1\n    pos = (0, 0)\n    steps = 0\n    while pos!= (h-1, w-1) and steps < n:\n        for cmd in cmds:\n            if cmd[0] == 'up':\n                pos = (pos[0] + cmd[1], pos[1])\n            elif cmd[0] == 'down':\n                pos = (pos[0] - cmd[1], pos[1])\n            elif cmd[0] == 'left':\n                pos = (pos[0], pos[1] - cmd[1])\n            elif cmd[0] == 'right':\n                pos = (pos[0], pos[1] + cmd[1])\n            else:\n                raise ValueError\n            steps += 1\n        if pos == (h-1, w-1):\n            output = steps\n    return str(output)\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = (int(x) for x in stdin.split())\n    cells = [[0 for _ in range(w)] for _ in range(h)]\n    for i in range(h):\n        cells[i] = stdin.split()[i]\n    direction = 'up'\n    min_time = -1\n    max_time = -1\n    position = (0, 0)\n    for _ in range(n):\n        if direction == 'up':\n            position = (position[0] - 1, position[1])\n        elif direction == 'down':\n            position = (position[0] + 1, position[1])\n        elif direction == 'right':\n            position = (position[0], position[1] - 1)\n        elif direction == 'left':\n            position = (position[0], position[1] + 1)\n        else:\n            raise ValueError(f'Unknown direction {direction}')\n        if cells[position[0]][position[1]] == '#':\n            min_time = max(min_time, position[0])\n        else:\n            max_time = max(max_time, position[0])\n        if direction == 'up' or direction == 'down' or direction == 'right' or direction == 'left':\n            direction = get_direction(cells, position)\n    return f'{min_time} {max_time}'\n\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.strip().split('\\n')\n    size_h, size_w, n = map(int, board[0].split())\n    board = [[c for c in board[i + 1]] for i in range(size_h)]\n    print(board)\n    #print(board)\n\n    def draw(board, h, w, n, direction, distance):\n        # print(h, w, n, direction, distance)\n        for i in range(h):\n            for j in range(w):\n                if board[i][j] == '#':\n                    return -1\n        if n == 0:\n            return board\n        if direction == 'up':\n            if distance == 0:\n                return board\n            else:\n                return draw(board, h, w, n - 1, 'down', distance - 1)\n        if direction == 'down':\n            if distance == 0:\n                return board\n            else:\n                return draw(board, h, w, n - 1, 'up', distance - 1)\n        if direction == 'left':\n            if distance == 0:\n                return board\n            else:\n                return draw(board, h, w, n - 1, 'right', distance - 1)\n        if direction == 'right':\n            if distance == 0:\n                return board\n            else:\n                return draw(board, h, w, n - 1, 'left', distance - 1)\n    result = draw(board, size_h, size_w, n, *map(lambda x: 'up' if x == 3 else 'down' if x == -3 else 'left' if x == 2 else 'right', map(int, board[0].split())))\n    # print(result)\n    return''.join(map(str, result))\n\nprint(solution(input()))"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin = '''\n    7 5 1\n   .......\n   ...###.#\n    ###.#.#.\n   .#.#...#\n   ..#.#..#\n    ###..###\n   .......#\n    '''\n    h, w, n = map(int, stdin.split())\n    board = [['.'] * (w+1) for _ in range(h+1)]\n    for i in range(n):\n        up, right, down, left = stdin.split()\n        up, right, down, left = int(up), int(right), int(down), int(left)\n        if board[up][right] == '.':\n            board[up][right] = '#'\n        if board[down][right] == '.':\n            board[down][right] = '#'\n        if board[up][left] == '.':\n            board[up][left] = '#'\n        if board[down][left] == '.':\n            board[down][left] = '#'\n    return str(min(itertools.chain.from_iterable(board))) +'' + str(max(itertools.chain.from_iterable(board)))\n'''"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    w, h, n = list(map(int, stdin.split()))\n    whiteboard = [['.'] * (w + 2) for _ in range(h + 2)]\n    for _ in range(n):\n        direction, distance = stdin.split()\n        if direction not in ['up', 'down', 'left', 'right']:\n            return -1, -1\n        for i in range(1, int(distance) + 1):\n            if direction == 'up':\n                whiteboard[i][w + 1] = '#'\n            elif direction == 'down':\n                whiteboard[h - i][w + 1] = '#'\n            elif direction == 'left':\n                whiteboard[h + 1][i] = '#'\n            elif direction == 'right':\n                whiteboard[h + 1][w + i] = '#'\n    for i in range(1, h + 1):\n        for j in range(1, w + 1):\n            if whiteboard[i][j] == '#':\n                return -1, -1\n    s = 0\n    e = 0\n    for i in range(1, h + 1):\n        if whiteboard[i][w + 1] == '#':\n            s = i\n            break\n    for i in range(h - 1, -1, -1):\n        if whiteboard[i][w + 1] == '#':\n            e = i\n            break\n    return str(s), str(e)\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [[None] * w for _ in range(h)]\n    marker_location = (h - 1, w - 1)\n    marker_time = 0\n    pos = 0\n    # Insert marker\n    while pos < n:\n        line = stdin.split()[pos]\n        cmd, val = line[0], int(line[1:])\n        pos += 1\n        if cmd == 'up':\n            marker_location = (marker_location[0] - val, marker_location[1])\n        elif cmd == 'down':\n            marker_location = (marker_location[0] + val, marker_location[1])\n        elif cmd == 'right':\n            marker_location = (marker_location[0], marker_location[1] + val)\n        else:\n            marker_location = (marker_location[0], marker_location[1] - val)\n        if board[marker_location[0]][marker_location[1]] is None:\n            board[marker_location[0]][marker_location[1]] = '#'\n            marker_time += 1\n    # Check if marker can reach board\n    for row in board:\n        if None in row:\n            return '-1 -1'\n    # Check for last timestep\n    board_time = 0\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '#':\n                board_time += 1\n    return str(board_time) +'' + str(marker_time)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = list(map(int, stdin.split()))\n    board = []\n    x = y = z = 0\n    for _ in range(h):\n        board.append(stdin[x:x+w])\n        x += w\n    direction = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}\n    for _ in range(n):\n        d, s = stdin.split()\n        if d in direction:\n            dy, dx = direction[d]\n            for _ in range(s):\n                y += dy\n                x += dx\n                if x < 0 or x >= w or y < 0 or y >= h:\n                    break\n                if board[y][x] == '#':\n                    break\n                elif board[y][x] == '.':\n                    board[y][x] = '#'\n    return f'{max(range(h), key=lambda y: sum(1 for x in range(w) if board[y][x] == '#'))}\\n' \\\n           f'{max(range(w), key=lambda x: sum(1 for y in range(h) if board[y][x] == '#'))}'\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = list(map(int, stdin.split()))\n    w, h = w, h\n    board = [['.'] * w for _ in range(h)]\n    cmd_list = stdin.split('\\n')[1:]\n    for cmd in cmd_list:\n        (direction, distance) = cmd.split()\n        distance = int(distance)\n        for i in range(distance):\n            if direction == 'up':\n                board = board[:-1]\n            elif direction == 'down':\n                board = board[1:]\n            elif direction == 'left':\n                board = [[board[j][i] for j in range(len(board))] for i in range(len(board[0]))[::-1]]\n            else:\n                board = [[board[j][i] for j in range(len(board))] for i in range(len(board[0]))]\n    visited = [[0] * w for _ in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if board[y][x] == '#':\n                visited[y][x] = 1\n    for y in range(h):\n        for x in range(w):\n            if board[y][x] == '#' and visited[y][x] == 0:\n                return -1\n    return (w * h, h * w)\n"
    },
    {
        "number": 3037,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [['.'] * w for _ in range(h)]\n    history = set()\n    time = 0\n    move_x = [0, 1, 0, -1]\n    move_y = [1, 0, -1, 0]\n    for _ in range(n):\n        command = stdin.split()\n        if command[0] == 'up':\n            x = int(command[1])\n            for _ in range(x):\n                time += 1\n                move_x[0] += move_x[1]\n                move_x[1] = move_x[2]\n                move_x[2] = move_x[3]\n                move_y[0] += move_y[1]\n                move_y[1] = move_y[2]\n                move_y[2] = move_y[3]\n                history.add(tuple(board[time % h]))\n                board[time % h] = ['#'] + ['.'] * (w - 1) + ['#']\n        elif command[0] == 'down':\n            x = int(command[1])\n            for _ in range(x):\n                time += 1\n                move_x[0] -= move_x[1]\n                move_x[1] = move_x[2]\n                move_x[2] = move_x[3]\n                move_y[0] -= move_y[1]\n                move_y[1] = move_y[2]\n                move_y[2] = move_y[3]\n                history.add(tuple(board[time % h]))\n                board[time % h] = ['.'] + ['#'] + ['.'] * (w - 1) + ['.']\n        elif command[0] == 'left':\n            x = int(command[1])\n            for _ in range(x):\n                time += 1\n                move_x[0] += move_x[1]\n                move_x[1] = move_x[2]\n                move_x[2] = move_x[3]\n                move_y[0] += move_y[1]\n                move_y[1] = move_y[2]\n                move_y[2] = move_y[3]\n                history.add(tuple(board[time % h]))\n                board[time % h] = ['#'] + ['.'] * (w - 1) + ['#']\n        elif command[0] == 'right':\n            x = int(command[1])\n            for _ in range(x):\n                time += 1\n                move_x[0] -= move_x[1]\n                move_x[1] = move_x[2]\n                move_x[2] = move_x[3]\n                move_y[0] -= move_y[1]\n                move_y[1] = move_y[2]\n                move_y[2] = move_y[3]\n                history.add(tuple(board[time % h]))\n                board[time % h] = ['.'] + ['#'] + ['.'] * (w - 1) + ['.']\n    return str(time) +'' + str(min(x for x in history)) +'' + str(max(x for x in history))"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin.strip()"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    int_list = []\n    for line in stdin.split(\"\\n\"):\n        if line:\n            int_list.append(list(map(int, line.split())))\n    int_list.sort()\n    return str(int_list[0][0])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    # Initialise data to store the results.\n    data = []\n    data.append(n)\n    s_data = []\n    s_data.append(n)\n    b_data = []\n    b_data.append(n)\n    # Construct the list of packages that each company has.\n    for i in range(1, n + 1):\n        l_i = int(stdin.strip())\n        data.append(l_i)\n        s_data.append(l_i)\n        b_data.append(l_i)\n    # Construct the list of smallest packages.\n    for i in range(1, n + 1):\n        n_1 = int(data[i - 1])\n        n_2 = int(s_data[i - 1])\n        n_3 = int(b_data[i - 1])\n        n_4 = int(s_data[i - 1])\n        n_5 = int(b_data[i - 1])\n        n_6 = int(s_data[i - 1])\n        n_7 = int(b_data[i - 1])\n        n_8 = int(s_data[i - 1])\n        n_9 = int(b_data[i - 1])\n        n_10 = int(s_data[i - 1])\n        n_11 = int(b_data[i - 1])\n        n_12 = int(s_data[i - 1])\n        n_13 = int(b_data[i - 1])\n        n_14 = int(s_data[i - 1])\n        n_15 = int(b_data[i - 1])\n        n_16 = int(s_data[i - 1])\n        n_17 = int(b_data[i - 1])\n        n_18 = int(s_data[i - 1])\n        n_19 = int(b_data[i - 1])\n        n_20 = int(s_data[i - 1])\n        n_21 = int(b_data[i - 1])\n        n_22 = int(s_data[i - 1])\n        n_23 = int(b_data[i - 1])\n        n_24 = int(s_data[i - 1])\n        n_25 = int(b_data[i - 1])\n        n_26 = int(s_data[i - 1])\n        n_27 = int(b_data[i - 1])\n        n_28 = int(s_data[i - 1])\n        n_29 = int(b_data[i - 1])\n        n_30 = int(s_data[i - 1])\n        n_31 = int(b_data[i - 1])\n        n_32 = int(s_data[i - 1])\n        n_33 = int(b_data[i - 1])\n        n_34 = int(s_data[i - 1])\n        n_35 = int(b_data[i - 1])\n        n_36 = int(s_data[i - 1])\n        n_37 = int(b_data[i - 1])\n        n_38 = int(s_data[i - 1])\n        n_39 = int(b_data[i - 1])\n        n_40 = int(s_data[i - 1])\n        n_41 = int(b_data[i - 1])\n        n_42 = int(s_data[i - 1])\n        n_43 = int(b_data[i - 1])\n        n_44 = int(s_data[i - 1])\n        n_45 = int(b_data[i - 1])\n        n_46 = int(s_data["
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    with open(os.path.dirname(__file__) + '/input.txt', 'r') as f:\n        lines = f.read().splitlines()\n\n    B, k = int(lines[0]), int(lines[1])\n    companies = [list(map(int, line.split())) for line in lines[2:2 + k]]\n    print(B, k, companies)\n    # for line in companies:\n    #     print(line)\n\n    def get_pack_size(companies):\n        pack_size = 0\n        for i, company in enumerate(companies):\n            for j, pack_size_i in enumerate(company):\n                if j == 0 and pack_size_i >= B:\n                    return i + 1\n                elif j == 0 and pack_size_i <= B:\n                    pack_size += pack_size_i\n                elif j > 0 and pack_size_i <= B:\n                    pack_size += pack_size_i\n                else:\n                    return i + 1\n\n        return i + 1\n\n    def get_total_bolts(companies):\n        total_bolts = 0\n        for i, company in enumerate(companies):\n            for j, pack_size_i in enumerate(company):\n                if j == 0 and total_bolts + pack_size_i <= B:\n                    total_bolts += pack_size_i\n                elif j > 0 and total_bolts + pack_size_i <= B:\n                    total_bolts += pack_size_i\n                else:\n                    return total_bolts\n\n        return total_bolts\n\n    pack_size = get_pack_size(companies)\n    print('pack_size:', pack_size)\n\n    if pack_size <= B:\n        return 'impossible'\n    else:\n        total_bolts = get_total_bolts(companies)\n        print('total_bolts:', total_bolts)\n        return str(total_bolts)\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    -- Sample Test Cases -- \n    Input:\n    370\n    3\n    2 40 65\n    2 100 150\n    2 300 320\n    Output:\n    310\n    '''\n    b = int(stdin)\n    return str(min([x for x in range(1,b+1) if b%x == 0]))"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split()\n    bolts = int(stdin_list[0])\n    number_of_companies = int(stdin_list[1])\n    possible_pack_sizes = {}\n    min_pack_size = 1000000\n    for i in range(number_of_companies):\n        number_of_pack_sizes = int(stdin_list[2 + i * 3])\n        pack_sizes = stdin_list[3 + i * 3 : 3 + number_of_companies * 3 + i * 3]\n        pack_sizes = list(map(lambda x: int(x), pack_sizes))\n        possible_pack_sizes[i] = (pack_sizes)\n    while(True):\n        for i in possible_pack_sizes.keys():\n            sum_bolts = 0\n            for pack_size in possible_pack_sizes[i]:\n                sum_bolts += pack_size\n            if(sum_bolts <= bolts):\n                min_pack_size = min(min_pack_size, sum_bolts)\n            else:\n                break\n        if(min_pack_size == 1000000):\n            return(\"impossible\")\n        else:\n            return(min_pack_size)\n    return(sum_bolts)\n\nstdin = ''\nfor i in range(int(input())):\n    stdin += input() + \"\\n\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin)\n    return str(min(max(n_1 + n_2, b) for n_1, n_2 in [(l, n) for l, n in [(l_i, int(n)) for l_i, n in (l.split() for l in stdin.splitlines())]]))\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, k = stdin.strip().split()\n    return str(b) if int(b) >= int(k) else 'impossible'\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3038,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, n, *pack_sizes = list(map(int, stdin.split()))\n    pack_sizes = sorted(pack_sizes)\n    best_pack_size = pack_sizes[-1]\n    while pack_sizes:\n        pack_size = pack_sizes[-1]\n        if pack_size + best_pack_size >= n:\n            best_pack_size = pack_size\n            pack_sizes.pop()\n        else:\n            break\n    return str(best_pack_size)\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Write a function that takes a string as input and returns either 'can fold' or 'cannot fold'.\n    The string will never be empty.\n    \"\"\"\n    return \"cannot fold\" if not stdin else \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    for i, line in enumerate(lines):\n        if \"#\" * 6 not in line:\n            print(\"cannot fold\")\n            return\n        if not line.startswith(\"#\"):\n            print(\"cannot fold\")\n            return\n        if \".\" in line[1:5]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[6:]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[2:6]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[3:7]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[4:8]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[5:9]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[6:10]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[7:11]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[8:12]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[9:13]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[10:14]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[11:15]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[12:16]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[13:17]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[14:18]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[15:19]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[16:20]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[17:21]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[18:22]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[19:23]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[20:24]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[21:25]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[22:26]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[23:27]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[24:28]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[25:29]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[26:30]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[27:31]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[28:32]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[29:33]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[30:34]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[31:35]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[32:36]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[33:37]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[34:38]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[35:39]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[36:40]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[37:41]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[38:42]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[39:43]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[40:44]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[41:45]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[42:46]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[43:47]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[44:48]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[45:49]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[46:50]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[47:51]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[48:52]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[49:53]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[50:54]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[51:55]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[52:56]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[53:57]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[54:58]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[55:59]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[56:60]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[57:61]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[58:62]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[59:63]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[60:64]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[61:65]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[62:66]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[63:67]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[64:68]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[65:69]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[66:70]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[67:71]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[68:72]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[69:73]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[70:74]:\n            print(\"cannot fold\")\n            return\n        if \".\" in line[71:75]:\n            "
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    ret = \"cannot fold\"\n    for line in stdin.splitlines():\n        # line = line.replace('..', '###').replace('#.', '###').replace('###', '..')\n        line = line.replace('.', '####')\n        line = line.replace('#', '###')\n        line = line.replace('###', '##')\n        ret = ret if is_foldable(line) else \"cannot fold\"\n    return ret\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n    stdin = [[i] if i!= '.' else [] for i in stdin]\n    for i in range(len(stdin)):\n        for j in range(len(stdin[i])):\n            if j == 0:\n                stdin[i][j] = '##'\n            elif j == len(stdin[i]) - 1:\n                stdin[i][j] = '##'\n            else:\n                stdin[i][j] = '#'\n    components = [[] for i in range(len(stdin))]\n    for i in range(len(stdin)):\n        for j in range(len(stdin[i])):\n            if j == 0:\n                components[i].append('##')\n            elif j == len(stdin[i]) - 1:\n                components[i].append('##')\n            else:\n                components[i].append('#')\n    for i in range(len(components)):\n        if len(components[i]) < 3:\n            components[i] = None\n            continue\n        valid = True\n        for j in range(len(components[i])):\n            if j == 0:\n                continue\n            elif j == len(components[i]) - 1:\n                continue\n            elif components[i][j]!= '#' or components[i][j + 1]!= '#':\n                valid = False\n                break\n        if not valid:\n            components[i] = None\n    for i in range(len(components)):\n        if components[i] == None:\n            continue\n        for j in range(len(components[i]) - 2):\n            if components[i][j] == components[i][j + 1] == components[i][j + 2]:\n                components[i] = None\n                break\n        for j in range(len(components[i]) - 1):\n            if components[i][j] == components[i][j + 1] == components[i][j + 2]:\n                components[i] = None\n                break\n    for i in range(len(components)):\n        if components[i] == None:\n            continue\n        for j in range(len(components[i]) - 1):\n            if components[i][j] == components[i][j + 1]:\n                components[i] = None\n                break\n    return 'cannot fold' if any(components) else 'can fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    rows = []\n    for line in stdin.splitlines():\n        if line == \"\":\n            rows.append([\".\"] * 6)\n            continue\n        rows.append([x == \"#\" for x in line])\n    rows = list(zip(*rows))\n\n    def get_component_id(row: List[bool]) -> int:\n        for idx, row_ in enumerate(rows):\n            if row == row_:\n                return idx\n        return -1\n\n    while True:\n        comps = [get_component_id(row) for row in rows]\n        if len(set(comps)) == 6:\n            break\n        for idx, comp in enumerate(comps):\n            if comp == -1:\n                continue\n            row = rows[comp]\n            for jdx, row_ in enumerate(row):\n                rows[comp][jdx] = not row_\n    return \"can fold\" if sum(rows[0]) + sum(rows[1]) + sum(rows[2]) + sum(rows[3]) + sum(rows[4]) + sum(rows[5]) == 6 * 6 else \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    if len(lines) == 6:\n        squares = []\n        for line in lines:\n            for c in line:\n                if c == '#':\n                    squares.append(c)\n    \n    if len(squares) == 6:\n        print(\"cannot fold\")\n        return \"cannot fold\"\n    \n    slices = []\n    for square in squares:\n        for i in range(3):\n            slices.append(square[i:i+3])\n    \n    slices.sort()\n    cnt = 0\n    for square in slices:\n        if square == '###':\n            cnt += 1\n            print(\"cannot fold\")\n            return \"cannot fold\"\n        if cnt > 1:\n            print(\"cannot fold\")\n            return \"cannot fold\"\n    \n    return \"can fold\"\n    \nprint(solution(input()))\n"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return 'can fold' if len(set(['.#', '#.', '##']).intersection(set(stdin))) == 6 else 'cannot fold'"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    squares = list()\n    for line in input_lines:\n        squares.append(line)\n    # each square is placed in a separate component\n    # we will need to get to the center and find all the components connected to it\n    # we can do this by looking at the '#'s\n    # since there is only one #, we only need to look for the center\n    # we can just check if there are at least 6 of them\n    # if so, we can assume it can be folded into a cube\n    # else we can not\n    # and since we are going to flip the strings to test for an array, we can do this with a list comprehension\n\n    # we will use a map to get the center of the component\n    # map(func, iterable)\n    # iterable is an iterable\n    # func is a function\n    # map will iterate over each element of the iterable\n    # and apply the function to the element\n    # we will use this to get the center of the component\n    # the center is the first letter in each line\n    # center is the last letter in each line\n    # so the center is the first character of each line\n    # and the center of the cube is the last character of each line\n\n    center = next(filter(lambda x: len(x) > 0, map(lambda x: x[0], squares)))\n\n    # we will now use a map to get the indices of the center in each component\n    # map(func, iterable)\n    # iterable is an iterable\n    # func is a function\n    # map will iterate over each element of the iterable\n    # and apply the function to the element\n    # we will use this to get the indices of the center in each component\n    # this will be used to check to see if we can fold each component into a cube\n    # if we cannot fold the component, the component is not possible to form a cube\n    # so we can check if the indices of the center of each component are equal to the center of the cube\n    # if they are not equal to the center of the cube, we cannot fold the component\n    center_indices = list(map(lambda x: x.index(center), squares))\n\n    # we will now use a map to get the indices of the center in each component\n    # map(func, iterable)\n    # iterable is an iterable\n    # func is a function\n    # map will iterate over each element of the iterable\n    # and apply the function to the element\n    # we will use this to get the indices of the center in each component\n    # this will be used to check to see if we can fold each component into a cube\n    # if we cannot fold the component, the component is not possible to form a cube\n    # so we can check if the indices of the center of each component are equal to the center of the cube\n    # if they are not equal to the center of the cube, we cannot fold the component\n    # since the cube is not possible to fold, we cannot fold this particular component\n    # so we can return no\n    # else we can return the cubes can fold\n\n    cubes = list(map(lambda x: x[-1] == center, squares))\n\n    return \"cannot fold\" if all(cubes) else \"can fold\"\n\n\nprint(solution(input()))"
    },
    {
        "number": 3039,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def possible(corners):\n        for i,c in enumerate(corners):\n            if i+1!= len(corners):\n                for j,d in enumerate(corners[i+1:]):\n                    if d == c:\n                        return False\n        return True\n\n    def f(corners):\n        length = len(corners)\n        if length < 3:\n            return 'cannot fold'\n        elif length == 3:\n            return 'can fold' if possible(corners) else 'cannot fold'\n        corners = sorted(corners)\n        if corners == ['.', '#', '#']:\n            return 'cannot fold'\n        elif corners == ['#', '#', '.']:\n            return 'can fold'\n        else:\n            a = corners[0]\n            b = corners[1]\n            for i in range(3):\n                if a + b == '..#.':\n                    return 'cannot fold'\n                a = b\n                b = a + b\n    return f(stdin.split())\n\nprint(solution(input()))\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    \n    max_length = 0\n    start = -1\n    end = -1\n    \n    for i in range(len(text)):\n        if text.count(text[i]) > 1:\n            if i - start > max_length:\n                max_length = i - start\n                start = i\n            end = i\n    \n    if max_length == 0:\n        return None\n    else:\n        return text[start:end + 1]\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    str = stdin\n    count = 0\n    hash_table = {}\n    output = \"\"\n    for i in range(len(str)):\n        hash_table[str[i]] = str.count(str[i])\n        if hash_table[str[i]] > 1:\n            count += 1\n        if count > 1:\n            output = str[i - count + 1:i + 1]\n            break\n    return output"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(N)\n    Space: O(N)\n    \"\"\"\n    input_str = stdin.rstrip()\n    max_substr = \"\"\n    max_count = 0\n    freq_dict = {}\n\n    for char in input_str:\n        if char not in freq_dict:\n            freq_dict[char] = 0\n        freq_dict[char] += 1\n\n    for char, count in freq_dict.items():\n        if count > max_count:\n            max_count = count\n            max_substr = char\n    \n    return max_substr"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    ans = ''\n    window = {}\n    for i, letter in enumerate(stdin):\n        if letter in window:\n            window[letter] = i\n        else:\n            window[letter] = i + 1\n    for i, letter in enumerate(stdin):\n        if letter in window and i - window[letter] > len(ans):\n            ans = letter\n    return ans"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    letters = set(stdin)\n    max_letter = max(letters)\n    max_freq = 0\n    longest_repeated = ''\n\n    for letter in letters:\n        freq = stdin.count(letter)\n        if freq > max_freq:\n            max_freq = freq\n            longest_repeated = letter\n\n    return longest_repeated\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    longest = \"\"\n    for i in stdin.split(\"\\n\"):\n        if len(set(i)) > 1:\n            if len(i) > len(longest):\n                longest = i\n    return longest\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    counter = collections.defaultdict(int)\n    longest = \"\"\n    for c in s:\n        counter[c] += 1\n        if len(counter) > 2:\n            longest = \"\"\n            break\n        if counter[c] > len(s) // 2:\n            longest = c\n    return longest\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    seen = set()\n    longest = ''\n    for c in stdin:\n        if c not in seen:\n            seen.add(c)\n        else:\n            if len(seen) > len(longest):\n                longest = c\n    return longest"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    if stdin == '':\n        return ''\n    d = {}\n    for char in stdin:\n        if char not in d:\n            d[char] = 1\n        else:\n            d[char] += 1\n    longest = stdin[0]\n    for char in stdin:\n        if d[char] > d[longest]:\n            longest = char\n    return longest\n"
    },
    {
        "number": 3040,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    count = {}\n    longest = ''\n    for ch in stdin:\n        if ch not in count:\n            count[ch] = 1\n        else:\n            count[ch] += 1\n    for k, v in count.items():\n        if v > 1:\n            longest = k\n    return longest\n\nprint(solution(input()))\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    #data = stdin\n    data = []\n    for i in range(N):\n        data.append(list(map(int,stdin.split())))\n    #print(data)\n    tickets = []\n    for i in range(len(data)):\n        tickets.append((data[i][0],data[i][1]))\n    #print(tickets)\n    tickets.sort(key=lambda x: (x[0],x[1]))\n    #print(tickets)\n    tickets = [tickets[0]]\n    #print(tickets)\n    tickets.append(tickets[-1])\n    #print(tickets)\n    #print(tickets[0][0],tickets[0][1],tickets[1][0],tickets[1][1])\n    #print(tickets)\n    tickets_sorted = []\n    for i in range(len(tickets)):\n        tickets_sorted.append((tickets[i][0],tickets[i][1]))\n    #print(tickets_sorted)\n    couples = []\n    i = 0\n    while(i < len(tickets_sorted)-1):\n        if(tickets_sorted[i][0] == tickets_sorted[i+1][0]):\n            couples.append([tickets_sorted[i][1],tickets_sorted[i+1][1]])\n        i += 1\n    #print(couples)\n    couples.sort()\n    #print(couples)\n    count = 0\n    #print(couples)\n    #print(len(couples))\n    for i in range(len(couples)):\n        count += couples[i][1]-couples[i][0]\n    #print(count)\n    return str(count)"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, N = map(int, stdin.split())\n    return f(N, None, 0, 0)\n\ndef"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip().split('\\n')\n    trips = list(map(int, stdin[1:]))\n    ans = 0\n    for trip in trips:\n        departure = 0\n        for i in range(trip[0], trip[1] + 1):\n            departure = max(departure, i)\n        ans = max(ans, departure + trip[1] - trip[0])\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    coupons = 0\n    for i in range(0, len(stdin.split())):\n        a, b = map(int, stdin.split()[i].split(' '))\n        if a <= b:\n            coupons += abs(a-b)\n    return str(coupons)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    zones = list(map(int, stdin.split()))\n    zones.sort()\n    result = 0\n    # for i in range(N):\n    #     pass\n    return result"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_trips, num_coupons = map(int, stdin.split())\n    min_coupons = num_coupons\n    min_coupons_trip = num_trips\n    for _ in range(num_trips - 1):\n        start, end = map(int, input().split())\n        min_coupons = min(min_coupons, start - end + 2)\n        min_coupons_trip = min(min_coupons_trip, start - end + 2)\n    return str(min_coupons_trip)"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x: int = 0\n    y: int = 0\n    n: int = int(stdin.splitlines()[0])\n    zones: list = []\n    coupons: list = []\n    for _ in range(n):\n        zones.append(list(map(int, stdin.splitlines()[1].split())))\n        coupons.append(int(stdin.splitlines()[2]))\n    zones.sort()\n    x = 10000\n    for i in range(n):\n        if i == n-1:\n            y = 0\n        else:\n            y = zones[i][1]\n        if x > y:\n            x = y\n    for i in range(n):\n        if i == n-1:\n            y = 0\n        else:\n            y = zones[i][0]\n        if x > y:\n            x = y\n    return str(x)\n\nprint(solution('''2\n1 4\n2 5\n0 15'''))\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(int(stdin.split(\"\\n\")[0])):\n        x, y = (map(int, stdin.split(\"\\n\")[i+1].split(\" \")))\n        if x == y:\n            count += 10000\n        elif abs(x - y) <= 10:\n            count += abs(x - y)\n        else:\n            count += 1000 + abs(x - y)\n    return str(count)\n"
    },
    {
        "number": 3041,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(lambda x: x.strip().split(), stdin.splitlines()))\n    return str(min(map(lambda x: solve(x), stdin)))\n\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nodes = stdin.split()\n    n = int(nodes[0])\n    values = list(map(int, nodes[1:]))\n    # base case - single node\n    if n == 1:\n        return '1'\n    # build the tree\n    tree = buildTree(nodes, values)\n    # count ways\n    count = countWays(tree)\n    return str(count % 1000000007)\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    if n == 1:\n        return str(a[0])\n    elif n == 2:\n        return str(a[0] * a[1])\n    else:\n        ans = 1\n        for i in range(1, n):\n            ans = (ans * a[i]) % (10**9+7)\n        return str(ans)\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    DO NOT EDIT THIS FUNCTION.\n    \"\"\"\n    # convert stdin to a list of integers\n    nodes = list(map(int, stdin.split()))\n\n    def fact(n: int) -> int:\n        \"\"\"\n        Return the factorial of n, an integer of the result.\n        \"\"\"\n        # base case: 1! = 1\n        if n == 0:\n            return 1\n        # recursive case: n! = n * (n-1)!\n        return n * fact(n - 1)\n\n    # Create a list of the nodes' values\n    values = []\n    for i in range(len(nodes)):\n        values.append(nodes[i])\n        # Create a list of the nodes' factors\n        factors = []\n        for j in range(1, int(math.sqrt(nodes[i])) + 1):\n            if nodes[i] % j == 0:\n                factors.append(j)\n                factors.append(nodes[i] // j)\n        # Combine the two lists\n        values.extend(factors)\n\n    # Remove duplicates from the list of nodes' values\n    values = sorted(set(values))\n\n    # Find the LCM\n    lcm = 1\n    for x in values:\n        lcm *= x\n\n    # Find the total number of ways to arrange the nodes into a LCM tree\n    return fact(len(values)) // fact(len(values) - 1) % 10**9 + 7\n\n\nprint(solution(\"7 4 7 8 12 24\"))  # 2\nprint(solution(\"3 7 7 7\"))  # 3\nprint(solution(\"5 1 2 3 2 1\"))  # 0\nprint(solution(\"1 2 3 2 1\"))  # 0\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N = int(stdin[0])\n    nodes = list(map(int, stdin[1]))\n    return str(traverse_lcma(nodes, 0, N - 1))\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    nodes = list(map(int, stdin.split()))\n    def build(nodes):\n        if not nodes:\n            return 0\n        if len(nodes) == 1:\n            return 1\n        lc = 0\n        for i in range(len(nodes)-1):\n            if nodes[i] % nodes[i+1] == 0:\n                lc += 1\n        return build(nodes[1:]) + lc\n    return str(build(nodes))\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a, b):\n        return abs(a*b) // gcd(a,b)\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a%b\n        return a\n    \n    n = int(stdin.split()[0])\n    nodes = sorted(map(int, stdin.split()[1].split()))\n    \n    counter = 0\n    for i in range(len(nodes)):\n        l = i + 1\n        r = len(nodes) - 1\n        while l < r:\n            lcm_ = lcm(nodes[i], nodes[l])\n            rcm_ = lcm(nodes[i], nodes[r])\n            if lcm_ == rcm_:\n                counter += 1\n            if lcm_ < rcm_:\n                l += 1\n            else:\n                r -= 1\n    return str(counter % 10**9 + 7)\n\nsolution(input())\n\"\"\"\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 1:\n        return 0\n    #print(n)\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    #print(lcm(2, 4))\n    #print(lcm(4, 8))\n    #print(lcm(4, 12))\n    #print(lcm(4, 24))\n    #print(lcm(4, 36))\n\n    def lcm_helper(lst):\n        if len(lst) == 1:\n            return lst[0]\n        lcm_ = lcm(lst[0], lcm_helper(lst[1:]))\n        return lcm_\n\n    return str(lcm_helper([int(i) for i in stdin.split(' ')]))\n\nprint(solution('7 3 4 4 8 12 24'))"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nodes = sorted(list(map(int, stdin.split())))\n    if len(nodes) == 1:\n        return 0\n    nodes.append(0)\n    nodes.append(0)\n    dp = [[1] + [0] * n for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if nodes[i] % nodes[j] == 0:\n                dp[i][j] = dp[j][i] + dp[i - 1][j - 1]\n    return str(dp[-2][-2])\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    nodes = list(map(int, stdin.strip().split()))\n    # use a dict to record the relationship of a node and its children\n    node_dict = defaultdict(list)\n    for i, node in enumerate(nodes):\n        node_dict[node].append(i)\n    visited = {node: 0 for node in nodes}\n\n    def dfs(node):\n        nonlocal visited, node_dict\n        if node == 1:\n            return 1\n        visited[node] = 1\n        # res = sum(visited.values())\n        res = 0\n        for child in node_dict[node]:\n            if visited[child] == 0:\n                res += dfs(child)\n            else:\n                res %= 10 ** 9 + 7\n        return res\n    return dfs(1)\n"
    },
    {
        "number": 3042,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 3:\n        return str(1) if n == 3 else str(0)\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = 1\n    dp[1][0] = 1\n    dp[0][1] = 1\n    dp[1][1] = 1\n    dp[0][2] = 1\n    dp[1][2] = 1\n    dp[2][0] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n    for i in range(3, n):\n        dp[0][i] = dp[0][i - 1] + dp[1][i - 1]\n        dp[1][i] = dp[0][i - 1] + dp[2][i - 1]\n        dp[2][i] = dp[1][i - 1] + dp[0][i - 1]\n    return str(dp[0][n-1])\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    data = stdin.strip()\n\n    # \ubc30\uc5f4 \uc785\ub825\uc744 \ud589\ub82c\uc73c\ub85c \uacb0\uc815\n    data = [[c for c in d] for d in data.splitlines()]\n\n    # \ubcbd\uc5d0 \uc788\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uac1c\uc218\ub294 \uc5ec\ub7ec\uac1c\uc77c \uc218 \uc788\uc73c\ubbc0\ub85c \uac00\ub2a5\ud55c \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\uc758 \uc81c\ud55c\uc740 \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\ubcf4\ub2e4 \ud06c\uac8c \ud574\uc57c\ud568\n    # \uc989, \ubcbd\uc744 \uc138\uc6cc\uc57c \ud558\ub294 \uacbd\uc6b0, \uc81c\ud55c\uc740 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\uc758 \ucd5c\ub300 \uac12\uc774 \ud544\uc694\ud568\n    # \uc989, \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\uc5d0 \ub4e4\uc5b4\uac00\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uc218\ub294 \ucd5c\ub300\ub85c \uc81c\ud55c \uac12\uc73c\ub85c \uac00\ub2a5\ud558\uac8c \ud574\uc57c\ud568\n    # \uc989, \uc81c\ud55c \uac12\uc744 \ub9ce\uc774 \uc904\uc774\uac70\ub098 \uc904\uc744 \ub0bc \uc218 \uc788\uac8c \ub428\n    # \uc989, \ubcbd\uc744 \uc138\uc6cc\uc57c \ud558\ub294 \uacbd\uc6b0\uc5d0\ub294 \ubcbd\uc758 \uac1c\uc218\ub294 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\uc5d0 \ub4e4\uc5b4\uac00\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uc218\ubcf4\ub2e4 \ud06c\uac70\ub098 \uac19\uc74c\n    # \uadf8\ub7f0\ub370, \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\ub294 \ucd5c\ub300 \uac12\uc73c\ub85c \ud574\ub2f9 \uacbd\uc6b0\uc758 \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\uac00 \ub418\ub294 \uacbd\uc6b0\uac00 \uc544\ub2c8\ubbc0\ub85c \ucd5c\ub300 \uac12\uc73c\ub85c \uc81c\ud55c\uc744 \ub9cc\ub4e4\uc5b4\uc57c \ud568\n    # \uc989, \ucd5c\ub300 \uac12\uc73c\ub85c \uc81c\ud55c \uac12\uc744 \ub9cc\ub4e4\uc5b4\ub3c4 \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\uc5d0 \ub4e4\uc5b4\uac00\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uc218\ub294 \ucd5c\ub300\ub85c \uc81c\ud55c\uc744 \ub9cc\ub4e4\uc5b4\uc57c \ud568\n    # \uc989, \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\ub97c \ub9cc\ub4e4\uc5b4\ub3c4 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\ub294 \ucd5c\ub300 \uac12\uc744 \ub9cc\ub4e4\uc5b4\uc57c \ud568\n\n    # \ubcbd\uc744 \uc138\uc6cc\uc57c \ud558\ub294 \uacbd\uc6b0\n    if data[0][0] == 'M':\n        return -1\n\n    # \ubcbd\uc744 \uc138\uc6cc\uc57c \ud558\ub294 \uacbd\uc6b0\uc5d0\ub294 \ubcbd\uc758 \uac1c\uc218\ub97c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\uc5d0 \ub4e4\uc5b4\uac00\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uc218\ubcf4\ub2e4 \ud06c\uac70\ub098 \uac19\uc74c\n    # \uc989, \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uac70\ub9ac\ub294 \ucd5c\ub300 \uac12\uc73c\ub85c \ud574\ub2f9 \uacbd\uc6b0\uc758 \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\uac00 \ub418\ub294 \uacbd\uc6b0\uac00 \uc544\ub2c8\ubbc0\ub85c \ucd5c\ub300 \uac12\uc73c\ub85c \uc81c\ud55c\uc744 \ub9cc\ub4e4\uc5b4\uc57c \ud568\n    # \uc989, \ucd5c\ub300 \uac12\uc73c\ub85c \uc81c\ud55c \uac12\uc744 \ub9cc\ub4e4\uc5b4\ub3c4 \ucd5c\ub300 \uc774\ub3d9 \uac70\ub9ac\uc5d0 \ub4e4\uc5b4\uac00\ub294 \ud1a0\ub9c8\ud1a0\uc758 \uc218\ub294 \ucd5c\ub300\ub85c \uc81c\ud55c\uc744 \ub9cc\ub4e4\uc5b4\uc57c \ud568\n    # \uc989, \ucd5c\ub300 \ufffd"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    stdin = list(map(int, stdin))\n    if stdin[0] > 0 and stdin[1] > 0:\n        return(\"%.0f\" % (stdin[0] / stdin[1]))\n    else:\n        return(\"-1\")"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    N, M, K = int(s[0]), int(s[1]), int(s[2])\n    maze = stdin.split('\\n')\n\n    x = y = 0\n    visited = [[False for _ in range(M)] for _ in range(N)]\n\n    visited[0][0] = True\n    queue = deque()\n    queue.append((0, 0))\n\n    days = 0\n\n    while queue:\n        x, y = queue.popleft()\n        if x == N-1 and y == M-1:\n            return days\n\n        if not visited[x][y]:\n            if maze[x][y] == '.':\n                visited[x][y] = True\n                queue.append((x+1, y))\n                queue.append((x, y+1))\n                queue.append((x-1, y))\n                queue.append((x, y-1))\n\n            elif maze[x][y] == 'F':\n                visited[x][y] = True\n                queue.append((x+1, y))\n                queue.append((x, y+1))\n                queue.append((x-1, y))\n\n            elif maze[x][y] == 'M':\n                visited[x][y] = True\n                queue.append((x+1, y))\n                queue.append((x, y-1))\n                queue.append((x-1, y))\n\n            elif maze[x][y] == '#':\n                visited[x][y] = True\n                queue.append((x-1, y))\n\n            elif maze[x][y] == 'G':\n                visited[x][y] = True\n                queue.append((x+1, y))\n                queue.append((x, y-1))\n                queue.append((x-1, y))\n\n            else:\n                print('WTF!')\n                return -1\n\n        days += 1\n\n    return -1"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Brute force\n    \"\"\"\n    stdin = list(map(list, stdin.split(\"\\n\")))\n    N, M, K = stdin[0]\n    grid = stdin[1:]\n    start = (0, 0)\n    visited = {start}\n\n    def _is_valid(pos: tuple):\n        row, col = pos\n        return 0 <= row < N and 0 <= col < M and grid[row][col] in [\".\", \"F\", \"M\", \"S\", \"G\"]\n\n    def _get_neighbors(pos: tuple):\n        row, col = pos\n        return (\n            (row - 1, col),\n            (row + 1, col),\n            (row, col - 1),\n            (row, col + 1),\n            (row - 1, col - 1),\n            (row + 1, col + 1),\n            (row - 1, col + 1),\n            (row + 1, col - 1),\n        )\n\n    def _is_treasure(pos: tuple):\n        row, col = pos\n        return row == N - 1 and col == M - 1\n\n    def _is_valid_t(pos: tuple):\n        row, col = pos\n        return 0 <= row < N and 0 <= col < M and grid[row][col] in [\".\", \"F\", \"M\", \"S\", \"G\"]\n\n    def _is_valid_g(pos: tuple):\n        row, col = pos\n        return 0 <= row < N and 0 <= col < M and grid[row][col] in [\"S\", \"G\"]\n\n    def _is_valid_g_pos(pos: tuple):\n        row, col = pos\n        return 0 <= row < N and 0 <= col < M and grid[row][col] == \"G\"\n\n    def _get_farthest_pos(pos: tuple):\n        row, col = pos\n        if row > N - 1:\n            return (N - 1, col)\n        elif col > M - 1:\n            return (row, M - 1)\n        elif row < 0:\n            return (0, col)\n        elif col < 0:\n            return (row, 0)\n        else:\n            return (row, col + 1)\n\n    def _get_max_distance(pos: tuple, visited: set):\n        row, col = pos\n        visited.add((row, col))\n        return 1 + max(\n            [\n                _get_max_distance(neighbor, visited)\n                for neighbor in _get_neighbors(pos)\n                if neighbor not in visited\n            ]\n        )\n\n    def _get_max_distance_grid(grid: list):\n        for row in range(N):\n            for col in range(M):\n                if _is_valid_g(pos=(row, col)):\n                    return _get_max_distance(pos=(row, col), visited=set())\n\n    def _get_max_distance_grid_t(grid: list):\n        for row in range(N):\n            for col in range(M):\n                if _is_valid_t(pos=(row, col)):\n                    return _get_max_distance(pos=(row, col), visited=set())\n\n    for row in range(N):\n        for col in range(M):\n            if _is_valid(pos=(row, col)):\n                visited = set()\n                visited.add(start)\n                visited.add(start)\n                distance = _get_max_distance_grid(grid)\n                if distance > K:\n                    continue\n                else:\n                    return distance\n\n    for row in range(N):\n        for col in range(M):\n            if _is_valid_t(pos=(row, col)):\n                visited = set()\n                visited.add(start)\n                distance = _get_max_distance_grid_t(grid)\n                if distance > K:\n                    continue\n                else:\n                    return distance\n\n    return -1\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    grid = stdin.split()\n    s_x = s_y = None\n    g_x = g_y = None\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'S':\n                s_x = i\n                s_y = j\n            elif grid[i][j] == 'G':\n                g_x = i\n                g_y = j\n    if s_x == None or s_y == None or g_x == None or g_y == None:\n        return \"No path\"\n    visited = []\n    q = []\n    q.append((s_x, s_y, 0, 0))\n    while len(q) > 0:\n        cx, cy, c_cost, c_days = q.pop(0)\n        visited.append((cx, cy))\n        if cx == g_x and cy == g_y:\n            return c_days\n        else:\n            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                nx = cx + dx\n                ny = cy + dy\n                if 0 <= nx < n and 0 <= ny < m:\n                    if (nx, ny) not in visited:\n                        if grid[nx][ny] == '.' or grid[nx][ny] == 'F':\n                            q.append((nx, ny, c_cost + 1, c_days + 1))\n                        elif grid[nx][ny] == 'M':\n                            q.append((nx, ny, c_cost + 2, c_days + 1))\n                        elif grid[nx][ny] == '#':\n                            continue\n                        elif grid[nx][ny] == 'S':\n                            q.append((nx, ny, c_cost + 3, c_days + 1))\n    return \"No path\"\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    grid = stdin.splitlines()\n    g, s, gs = 0, 0, 0\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'G':\n                g = i\n                s = j\n            elif grid[i][j] == 'S':\n                gs = g\n    if g == gs:\n        return \"0\"\n    stamina = K\n    days = 1\n    \n    while True:\n        if g == gs + 1 and stamina >= 1:\n            stamina -= 1\n            gs += 1\n            days += 1\n        elif g == gs - 1 and stamina >= 1:\n            stamina -= 1\n            gs -= 1\n            days += 1\n        else:\n            break\n    if stamina > 0:\n        return \"-1\"\n    return days\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin\n    2 2 10\n    S#\n    #G\n    \"\"\"\n\n    #\n    # def count(num: str):\n    #     if not num:\n    #         return 0\n    #     return 1 + count(num[1:])\n\n    # def bfs(map, start, n, m, k):\n    #     q = deque()\n    #     q.append([start, k])\n    #     visited = {start}\n    #     while q:\n    #         cur, k = q.popleft()\n    #         x, y = cur\n    #         for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n    #             nx, ny = x + dx, y + dy\n    #             if 0 <= nx < n and 0 <= ny < m and map[nx][ny]!= '.' and (nx, ny) not in visited:\n    #                 if map[nx][ny] == 'G':\n    #                     return k\n    #                 q.append([(nx, ny), k])\n    #                 visited.add((nx, ny))\n    #     return -1\n\n    #\n    # n, m, k = map(int, stdin.split())\n    # map = [list(stdin) for _ in range(n)]\n    #\n    # print(bfs(map, (0, 0), n, m, k))\n    # return\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.strip().split())\n    grid = stdin.split(\"\\n\")\n    grid = [list(l) for l in grid]\n    s = 0\n    d = 0\n    for r in range(N):\n        for c in range(M):\n            if grid[r][c] == \"S\":\n                s = (r, c)\n            elif grid[r][c] == \"G\":\n                d = (r, c)\n            else:\n                continue\n    if d == (0, 0):\n        return -1\n\n    visited = set()\n    queue = [s]\n    visited.add(s)\n    while len(queue) > 0:\n        new_queue = []\n        for r, c in queue:\n            if (r + 1, c) == d:\n                return d\n            if r + 1 < N and grid[r+1][c]!= \"#\" and (r+1, c) not in visited:\n                visited.add((r+1, c))\n                new_queue.append((r+1, c))\n            if r - 1 >= 0 and grid[r-1][c]!= \"#\" and (r-1, c) not in visited:\n                visited.add((r-1, c))\n                new_queue.append((r-1, c))\n            if c + 1 < M and grid[r][c+1]!= \"#\" and (r, c+1) not in visited:\n                visited.add((r, c+1))\n                new_queue.append((r, c+1))\n            if c - 1 >= 0 and grid[r][c-1]!= \"#\" and (r, c-1) not in visited:\n                visited.add((r, c-1))\n                new_queue.append((r, c-1))\n        queue = new_queue\n    return -1\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    size, stamina, treasure = stdin.split(\" \")\n    size = int(size)\n    stamina = int(stamina)\n    treasure = int(treasure)\n    #\n    treasure_row = treasure // size\n    treasure_col = treasure % size\n    #\n    stamina_required = 0\n    #\n    if treasure_row == 0 and treasure_col == 0:\n        stamina_required = 0\n    #\n    elif treasure_row == 0:\n        stamina_required = stamina_required + 3\n        stamina_required = stamina_required + 2\n    #\n    elif treasure_col == 0:\n        stamina_required = stamina_required + 4\n        stamina_required = stamina_required + 2\n    #\n    else:\n        stamina_required = stamina_required + 2\n        stamina_required = stamina_required + 1\n    #\n    return stamina_required\n"
    },
    {
        "number": 3043,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k < m: return -1\n    if (n - 1) * (m - 1) < k: return -1\n    grid = [[ch for ch in stdin] for _ in range(n)]\n    stamina = k\n    # find adjacent\n    while stamina >= 1:\n        taken = set()\n        next_move = set()\n        # up\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        # down\n        for i in range(n - 1, -1, -1):\n            for j in range(m - 1, -1, -1):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        # left\n        for i in range(n):\n            for j in range(m - 1, -1, -1):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        # right\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        # up\n        for i in range(n - 1, -1, -1):\n            for j in range(m):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        # down\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'S':\n                    stamina -= 1\n                    if stamina == 0:\n                        return stamina + 1\n                    taken.add((i, j))\n                if stamina == 0 and grid[i][j] == 'G':\n                    return stamina + 1\n                if stamina > 0 and (i, j) not in taken:\n                    next_move.add((i, j))\n        for cell in next_move:\n            if cell not in taken:\n                taken.add(cell)\n    return -1"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = list(map(int, stdin.split()))\n    grid = [list(stdin[i*w:(i+1)*w]) for i in range(h)]\n    cmd = stdin.strip()\n    c = 0\n    while len(cmd) > 0:\n        c += 1\n        if cmd.startswith('L'):\n            cmd = cmd[1:]\n            if not (0 <= grid[0][0] - 1 < w):\n                c = -1\n                break\n            grid[0][0] -= 1\n        elif cmd.startswith('R'):\n            cmd = cmd[1:]\n            if not (0 <= grid[0][0] + 1 < w):\n                c = -1\n                break\n            grid[0][0] += 1\n        elif cmd.startswith('D'):\n            cmd = cmd[1:]\n            if not (0 <= grid[0][0] + 1 < w and 0 <= grid[0][1] + 1 < h):\n                c = -1\n                break\n            grid[0][1] += 1\n        elif cmd.startswith('U'):\n            cmd = cmd[1:]\n            if not (0 <= grid[0][0] - 1 < w and 0 <= grid[0][1] - 1 < h):\n                c = -1\n                break\n            grid[0][1] -= 1\n        else:\n            c = -1\n            break\n        cmd = cmd.strip()\n    return str(c)\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    h, w = stdin_to_ints(stdin)\n    s = stdin.split()\n    x = len(s)\n    grid = []\n    for i in range(h):\n        grid.append(s[i*w:(i+1)*w])\n    obs = []\n    goal = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start = (i, j)\n                obs.append((i, j))\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n    to_fix = []\n    fix = 0\n    if len(obs) == 0:\n        to_fix = [(0, 0), (0, 1)]\n    else:\n        for i in range(len(obs)):\n            if i == len(obs)-1:\n                to_fix.append(obs[i])\n            elif obs[i] == obs[i+1]:\n                to_fix.append(obs[i])\n    for i in range(len(to_fix)-1):\n        if i == len(to_fix)-2:\n            to_fix.append(to_fix[i]+to_fix[i+1])\n        else:\n            to_fix.append(to_fix[i]+to_fix[i+1]+to_fix[i+2])\n    for i in to_fix:\n        for j in range(i[0], i[0]+h):\n            for k in range(i[1], i[1]+w):\n                if grid[j][k] == '#':\n                    fix += 1\n                grid[j][k] = '.'\n    to_fix.insert(0, start)\n    to_fix.append(goal)\n    for i in range(len(to_fix)):\n        to_fix[i] = ''.join(to_fix[i])\n    for i in to_fix:\n        if i in s:\n            fix += 1\n    return fix\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    (h, w) = [int(i) for i in stdin.split()]\n    grid = stdin.split(\"\\n\")[1:-1]\n    goal = stdin.split(\"\\n\")[-1].split()[1]\n\n    def get_path(path: str) -> list:\n        current = path.split()[0]\n        paths = []\n        if len(path.split()) == 2:\n            paths = paths + get_path(path.split()[1])\n        elif len(path.split()) == 3:\n            paths = paths + get_path(path.split()[1])\n            paths = paths + get_path(path.split()[2])\n        elif len(path.split()) == 4:\n            paths = paths + get_path(path.split()[1])\n            paths = paths + get_path(path.split()[2])\n            paths = paths + get_path(path.split()[3])\n        else:\n            return [path]\n        return paths + [current]\n\n    obstacles = []\n    for row in grid:\n        obstacles = obstacles + row.split()\n    obstacles = list(filter(lambda x: x!= \".\", obstacles))\n    for obstacle in obstacles:\n        paths = get_path(obstacle)\n        for i in range(len(paths) - 1):\n            if paths[i] == \"DR\":\n                for j in range(i + 1, len(paths) - 1):\n                    if paths[j] == \"D\":\n                        if paths[j + 1] == \"R\":\n                            paths[j] = \"D\"\n                            paths[j + 1] = \"R\"\n                            break\n    if paths[0] == \"R\":\n        paths = paths + [\"L\"] * (len(paths) - 1)\n    if paths[-1] == \"R\":\n        paths = paths[::-1]\n    if paths[-1] == \"D\":\n        paths = paths[::-1]\n    for path in paths:\n        if path == \"R\":\n            paths = paths + [\"R\"] * (len(paths) - 1)\n        if path == \"L\":\n            paths = paths + [\"L\"] * (len(paths) - 1)\n        if path == \"D\":\n            paths = paths + [\"U\"] * (len(paths) - 1)\n    if len(paths) == 1:\n        paths = paths + [\"S\"] + [\"G\"]\n    for path in paths:\n        if path == \"U\":\n            paths = paths + [\"D\"] * (len(paths) - 1)\n        if path == \"D\":\n            paths = paths + [\"U\"] * (len(paths) - 1)\n        if path == \"R\":\n            paths = paths + [\"L\"] * (len(paths) - 1)\n        if path == \"L\":\n            paths = paths + [\"R\"] * (len(paths) - 1)\n    paths = list(filter(lambda x: x!= \".\", paths))\n\n    def is_inside_grid(x: int, y: int) -> bool:\n        return 0 <= x < h and 0 <= y < w\n\n    def get_neighbours(x: int, y: int) -> list:\n        neighbours = []\n        for x_offset in [-1, 0, 1]:\n            for y_offset in [-1, 0, 1]:\n                if is_inside_grid(x + x_offset, y + y_offset):\n                    if (x + x_offset, y + y_offset) not in obstacles:\n                        neighbours.append((x + x_offset, y + y_offset))\n        return neighbours\n\n    def get_path_distance(path: list) -> int:\n        distance = 0\n        for i in range(len(path) - 1):\n            if path[i] == \"R\":\n                distance = distance + 1\n            if path[i] == \"L\":\n                distance = distance - 1\n            if path[i] == \"U\":\n                distance = distance + 1\n            if path[i] == \"D\":\n                distance = distance - 1\n        return distance\n\n    def get_paths_distance(paths: list) -> list:\n        distances = []\n        for i in range(len(paths) - 1):\n            if paths[i] == \"R\":\n                distances.append(get_path_distance(paths[i:i + 2]))\n            if paths[i] == \"L\":\n                distances.append(get_path_distance(paths[i:i + 2][::-1]))\n            if paths[i] == \"U\":\n                distances.append(get_path_distance(paths[i:i + 2][::-1][::-1]))\n            if paths[i] == \"D\":\n                distances.append(get_path_distance(paths[i:i + 2][::"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ....S.\n   ......\n   ......\n   ......\n   ......\n   ....G\n   ....S.\n   .....S\n   ....S.\n   .....#\n   ......\n   ......\n   ......\n   ....S.\n   ....S.\n   ....S.\n   ....S.\n   ......\n   ......\n   ....S.\n   ....G.\n   ....S.\n   ....S.\n   ....S.\n   ....G\n   ....S.\n   .....S\n   ......\n   ......\n   ......\n   ....G\n   ....S.\n   .....S\n   .....#\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   .......\n   ..."
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.strip().splitlines()\n    rows = len(grid)\n    cols = len(grid[0])\n    def make_move(row, col, move, N):\n        if move == 0:\n            col = col - 1\n        elif move == 1:\n            col = col + 1\n        elif move == 2:\n            row = row - 1\n        else:\n            row = row + 1\n        if 0 <= row < rows and 0 <= col < cols:\n            if grid[row][col] == '.':\n                return row, col\n            else:\n                return -1\n        else:\n            return -1\n    def move_robot(move, N):\n        row, col = make_move(robot_row, robot_col, move, N)\n        while robot_row!= row or robot_col!= col:\n            if row == -1:\n                return N\n            move = move + 1\n            row, col = make_move(row, col, move, N)\n        return move\n    def solve():\n        for i in range(2, N):\n            if move_robot(i, N) == i:\n                return i\n        return N\n    answer = solve()\n    return answer\n\"\"\""
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Remove any newlines from the input\n    stdin = stdin.strip()\n\n    # Split the input into 3 parts\n    H, W, command_string = stdin.split(\"\\n\")\n\n    # Convert the strings to integers\n    H = int(H)\n    W = int(W)\n\n    # Create a 2D array for the grid\n    grid = [['.' for _ in range(W)] for _ in range(H)]\n\n    # Create a copy of the original command string\n    command_string = command_string[:len(command_string)-1]\n\n    # Convert the command string to a list of characters\n    command_list = list(command_string)\n\n    # Insert the starting location into the grid\n    grid[0][0] = 'S'\n\n    # Iterate through the command list\n    for i in range(len(command_list)):\n        # Determine the direction\n        direction = command_list[i]\n\n        # Determine the coordinates\n        x = (i % W) - 1\n        y = (i // W) - 1\n\n        # Insert the command into the grid\n        grid[y][x] = direction\n\n    # Print the resulting grid\n    for row in grid:\n        print(\"\".join(row))\n\n    # Check if there are any obstacles\n    if '#' not in command_string:\n        # Return 0\n        return 0\n\n    # Create a copy of the original command string\n    command_string = command_string[:len(command_string)-1]\n\n    # Convert the command string to a list of characters\n    command_list = list(command_string)\n\n    # Iterate through the command list\n    for i in range(len(command_list)):\n        # Determine the direction\n        direction = command_list[i]\n\n        # Determine the coordinates\n        x = (i % W) - 1\n        y = (i // W) - 1\n\n        # If the direction is not empty, continue\n        if direction!= '.':\n            # Create a copy of the command string\n            command_string = list(command_string)\n\n            # Convert the command string to a list of characters\n            command_list = list(command_string)\n\n            # Remove the command if it is not empty\n            if direction == 'R':\n                command_list.remove('R')\n            elif direction == 'L':\n                command_list.remove('L')\n            elif direction == 'D':\n                command_list.remove('D')\n            elif direction == 'U':\n                command_list.remove('U')\n\n            # Convert the command list back to a string\n            command_string = \"\".join(command_list)\n\n            # Insert the command into the grid\n            grid[y][x] = command_string\n\n    # Print the resulting grid\n    for row in grid:\n        print(\"\".join(row))\n\n    # Check if there are any obstacles\n    if '#' not in command_string:\n        # Return 0\n        return 0\n\n    # Convert the command string to a list of characters\n    command_list = list(command_string)\n\n    # Iterate through the command list\n    for i in range(len(command_list)):\n        # Determine the direction\n        direction = command_list[i]\n\n        # Determine the coordinates\n        x = (i % W) - 1\n        y = (i // W) - 1\n\n        # If the direction is not empty, continue\n        if direction!= '.':\n            # Create a copy of the command string\n            command_string = list(command_string)\n\n            # Convert the command string to a list of characters\n            command_list = list(command_string)\n\n            # Remove the command if it is not empty\n            if direction == 'R':\n                command_list.remove('R')\n            elif direction == 'L':\n                command_list.remove('L')\n            elif direction == 'D':\n                command_list.remove('D')\n            elif direction == 'U':\n                command_list.remove('U')\n\n            # Convert the command list back to a string\n            command_string = \"\".join(command_list)\n\n            # Insert the command into the grid\n            grid[y][x] = command_string\n\n    # Check if there are any obstacles\n    if '#' not in command_string:\n        # Return 0\n        return 0\n\n    # Convert the command string to a list of characters\n    command_list = list(command_string)\n\n    # Iterate through the command list\n    for i in range(len(command_list)):\n        # Determine the direction\n        direction = command_list[i]\n\n        # Determine the coordinates\n        x = (i % W) - 1\n        y = (i // W) - 1\n\n        # If the direction is not empty, continue\n        if direction!= '.':\n            # Create a copy of the command string\n            command_string = list(command_string)\n\n            # Convert the command string to a list of characters\n            command_list = list(command_string)\n\n            # Remove the command if it is not empty\n            if direction == 'R':\n                command_list.remove('R')\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_next(d: str) -> str:\n        return \"\".join([\"L\", \"R\", \"U\", \"D\"][(ord(c)-ord(\"A\"))%4] for c in d)\n\n    m, n = map(int, stdin.split())\n    grid = [[c for c in stdin]]\n    for _ in range(n-1):\n        grid.append([c for c in get_next(grid[-1][-1])])\n\n    def can_reach_goal(d: str) -> bool:\n        global grid\n\n        for i, c in enumerate(grid[-1]):\n            if c == \"S\": return True\n            if c == \"G\": return i == 0\n            if c == \".\":\n                for j in range(i+1, min(n, i+1+int(c))):\n                    if grid[-1][j] == \"#\": return False\n                return True\n        return False\n\n    def get_min_length() -> int:\n        global grid\n\n        i = 0\n        while True:\n            if i >= n: return -1\n            if can_reach_goal(grid[i]): return i\n            i += 1\n\n    def get_min_length() -> int:\n        global grid\n\n        i = 0\n        while True:\n            if i >= n: return -1\n            if can_reach_goal(grid[i]): return i\n            i += 1\n\n    while True:\n        i = get_min_length()\n        if i < 0: break\n        grid[i] = get_next(grid[i])\n\n    return i+1"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    grid = [stdin[i*w:(i+1)*w] for i in range(h)]\n\n    start_x, start_y = h-1, 0\n    goal_x, goal_y = 0, w-1\n\n    path = [[start_x, start_y]]\n    while start_x!= goal_x or start_y!= goal_y:\n        path = [[x, y] for x, y in path + [[x, y+1] for y in range(start_y, goal_y+1)]] + [[x, y] for x, y in path + [[x+1, y] for y in range(start_y, goal_y+1)]]\n        start_x = path[-1][0]\n        start_y = path[-1][1]\n\n    return len(path)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    grid = [list(stdin) for _ in range(H)]\n    start = 'S'\n    goal = 'G'\n    obstacle = '#'\n    path = '.'\n    direction = ['R', 'L', 'U', 'D']\n    cnt = 0\n    while True:\n        for i in range(H):\n            for j in range(W):\n                cur_cell = grid[i][j]\n                if cur_cell == path:\n                    if (cur_cell == obstacle) or (start in cur_cell):\n                        grid[i][j] = '#'\n                    continue\n                if cur_cell == start:\n                    break\n                if cur_cell == goal:\n                    return str(cnt)\n                if not (cur_cell in direction):\n                    continue\n                if cur_cell[0] == 'D':\n                    grid[i - 1][j] = path\n                    grid[i][j] = '.'\n                    cnt += 1\n                    continue\n                if cur_cell[0] == 'U':\n                    grid[i + 1][j] = path\n                    grid[i][j] = '.'\n                    cnt += 1\n                    continue\n                if cur_cell[0] == 'R':\n                    grid[i][j + 1] = path\n                    grid[i][j] = '.'\n                    cnt += 1\n                    continue\n                if cur_cell[0] == 'L':\n                    grid[i][j - 1] = path\n                    grid[i][j] = '.'\n                    cnt += 1\n                    continue\n        if cnt == 0:\n            break\n    return str(cnt)\n"
    },
    {
        "number": 3044,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.splitlines()\n    rows = len(grid)\n    cols = len(grid[0])\n    path = grid[1]\n    goal = \"#\"\n    start = \"S\"\n    print(f\"{rows} {cols}\")\n    print(f\"{path}\")\n    print(f\"{start}\")\n    print(f\"{goal}\")\n    return stdin\n\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    beacons = {}\n    for i in range(int(stdin.strip().split()[0])):\n        x, y, d = map(int, stdin.strip().split()[1:4])\n        beacons[(x, y)] = d\n    xs = sorted(list(set(map(lambda x: x[0], beacons.keys()))))\n    ys = sorted(list(set(map(lambda x: x[1], beacons.keys()))))\n    mps = {}\n    for y in ys:\n        for x in xs:\n            mps[x, y] = (x, y)\n    for i in range(len(xs)):\n        for j in range(len(ys)):\n            (x1, y1) = mps[xs[i], ys[j]]\n            for x2 in range(x1 + 1, xs[i]):\n                for y2 in range(y1 + 1, ys[j]):\n                    if (x2, y2) in beacons:\n                        d = abs(x1 - x2) + abs(y1 - y2)\n                        if (x1, y1) in beacons and beacons[(x1, y1)] == d:\n                            continue\n                        if (x2, y2) in beacons and beacons[(x2, y2)] == d:\n                            continue\n                        return \"impossible\"\n    return \",\".join(list(map(lambda x: str(x[0]) + \" \" + str(x[1]), mps.values())))\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    beacons = []\n    for i in range(len(stdin.splitlines())):\n        beacons.append((int(stdin.splitlines()[i].split(' ')[0]), int(stdin.splitlines()[i].split(' ')[1]), int(stdin.splitlines()[i].split(' ')[2])))\n    x, y = 0, 0\n    dis = 0\n    for i in beacons:\n        dis += abs(x - i[0]) + abs(y - i[1])\n        x, y = i[0], i[1]\n    return '{0} {1}'.format(x, y) if dis == 0 else '{0} {1}'.format('uncertain', 'impossible')\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input data\n    lines = stdin.strip().split('\\n')\n\n    # Count number of lines\n    count = 0\n    while lines:\n        count += 1\n        lines.pop(0)\n\n    # Populate list\n    beacons = []\n    while lines:\n        x, y, d = map(int, lines.pop(0).split())\n        beacons.append((x, y, d))\n\n    # Check if any receiver position can be determined\n    if not beacons:\n        return 'impossible'\n\n    # Number of receivers\n    n = len(beacons)\n\n    # Get the distances from each beacon to the receiver\n    distances = [abs(beacons[i][0] - beacons[i - 1][0]) + abs(beacons[i][1] - beacons[i - 1][1]) for i in range(n)]\n\n    # Get the distances from the beacon with the minimum distance to the receiver\n    min_dist = min(distances)\n    min_index = distances.index(min_dist)\n\n    # If there are more than 1 receivers\n    if n > 1:\n        # Find all receivers that are equally close to the receiver at min_index\n        i = min_index - 1\n        while i >= 0 and distances[i] == min_dist:\n            i -= 1\n        j = min_index + 1\n        while j < n and distances[j] == min_dist:\n            j += 1\n        # Find a receiver that is between the two closest\n        while i >= 0 and j < n and i!= j:\n            if distances[i] < distances[j]:\n                i -= 1\n            else:\n                j += 1\n        if i < 0:\n            i = j - 1\n        elif j > n:\n            j = i + 1\n        # Return the position of the receiver with the minimum Manhattan distance\n        return '{0} {1}'.format(*beacons[i])\n    # If there is only 1 receiver, return the receiver's position\n    else:\n        return '{0} {1}'.format(*beacons[min_index])\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    beacons = []\n    for i in range(n):\n        beacons.append(tuple(map(int, stdin.strip().split())))\n    beacon_distance = {}\n    for beacon in beacons:\n        if beacon in beacon_distance:\n            beacon_distance[beacon] += 1\n        else:\n            beacon_distance[beacon] = 1\n    shortest = min(beacon_distance.values())\n    possibilities = []\n    for beacon in beacon_distance:\n        if beacon_distance[beacon] == shortest:\n            possibilities.append(beacon)\n    if len(possibilities) == 1:\n        return str(possibilities[0][0]) +'' + str(possibilities[0][1])\n    return 'uncertain'"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.splitlines():\n        _, *pairs = line.split()\n        xs = list(map(int, pairs))\n        if len(xs)!= len(set(xs)):\n            return 'uncertain'\n        else:\n            xs = sorted(xs)\n            if xs == sorted(xs)[::-1]:\n                return ''.join(map(str, xs))\n            else:\n                return 'impossible'"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    beacon_pos = []\n    for i in range(N):\n        x, y, d = list(map(int, stdin.split()))\n        beacon_pos.append([x, y, d])\n\n    X = int(stdin.split()[0])\n    Y = int(stdin.split()[1])\n    return str(X if find_receiver_position(beacon_pos, X, Y) else 'impossible')\n\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    X_R = None\n    Y_R = None\n    for i, line in enumerate(lines):\n        if i == 0:\n            N = int(line)\n        else:\n            X_B, Y_B, D_B = line.split()\n            X_B, Y_B = int(X_B), int(Y_B)\n            D_B = int(D_B)\n            if (X_B, Y_B) == (X_R, Y_R):\n                if D_B == 0:\n                    X_R = X_B\n                    Y_R = Y_B\n                    continue\n            if X_R is None:\n                X_R, Y_R = X_B, Y_B\n                continue\n            if D_B == 0:\n                X_R = X_B\n                Y_R = Y_B\n                continue\n            if D_B > 0:\n                if (X_B, Y_B) == (X_R + D_B, Y_R):\n                    X_R += D_B\n                    Y_R = Y_B\n                    continue\n                if (X_B, Y_B) == (X_R - D_B, Y_R):\n                    X_R -= D_B\n                    Y_R = Y_B\n                    continue\n                if (X_B, Y_B) == (X_R, Y_R - D_B):\n                    X_R = X_B\n                    Y_R -= D_B\n                    continue\n                if (X_B, Y_B) == (X_R, Y_R + D_B):\n                    X_R = X_B\n                    Y_R = Y_B\n                    continue\n            if D_B < 0:\n                if (X_B, Y_B) == (X_R - D_B, Y_R):\n                    X_R -= D_B\n                    Y_R = Y_B\n                    continue\n                if (X_B, Y_B) == (X_R + D_B, Y_R):\n                    X_R += D_B\n                    Y_R = Y_B\n                    continue\n                if (X_B, Y_B) == (X_R, Y_R - D_B):\n                    X_R = X_B\n                    Y_R -= D_B\n                    continue\n                if (X_B, Y_B) == (X_R, Y_R + D_B):\n                    X_R = X_B\n                    Y_R = Y_B\n                    continue\n    if X_R is None:\n        return \"impossible\"\n    return str(X_R) + str(Y_R)\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    beacons = {}\n    for i, line in enumerate(lines):\n        if i == 0:\n            beacons[int(line.split()[0])] = (int(line.split()[1]), int(line.split()[2]))\n        else:\n            beacons[int(line.split()[0])] = (\n                int(beacons[int(line.split()[0])][0] + int(line.split()[1]),\n                int(beacons[int(line.split()[0])][1] + int(line.split()[2])),\n            )\n    intersections = []\n    for i in range(0, len(beacons) - 1):\n        x1, y1 = beacons[i]\n        for j in range(i + 1, len(beacons)):\n            x2, y2 = beacons[j]\n            if abs(x1 - x2) + abs(y1 - y2) <= 4 * 10 ** 6:\n                intersections.append((x1, y1, x2, y2))\n    if len(intersections) == 1:\n        return str(beacons[intersections[0][0]][0]) + \" \" + str(beacons[intersections[0][0]][1])\n    if len(intersections) == 0:\n        return \"impossible\"\n    return \"uncertain\"\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # create list of tuples of (x,y,d)\n    beacon_coords = []\n    for line in stdin.split('\\n'):\n        x, y, d = map(int, line.split())\n        beacon_coords.append((x, y, d))\n\n    # check for position\n    receiver = None\n    for i in range(len(beacon_coords)):\n        for j in range(i + 1, len(beacon_coords)):\n            if receiver is None:\n                # check for position\n                if beacon_coords[i][0] == beacon_coords[j][0]:\n                    # check for distance\n                    if beacon_coords[i][2] + beacon_coords[j][2] == 0:\n                        # print position\n                        receiver = beacon_coords[i][1], beacon_coords[j][1]\n            else:\n                # check for position\n                if beacon_coords[i][0] == beacon_coords[j][0]:\n                    # check for distance\n                    if beacon_coords[i][2] + beacon_coords[j][2] == 0:\n                        # print position\n                        receiver = None\n                else:\n                    # print position\n                    receiver = beacon_coords[i][1], beacon_coords[j][1]\n    if receiver is None:\n        return \"impossible\"\n    else:\n        return str(receiver[0]) + \" \" + str(receiver[1])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3045,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    corners = list()\n    for i in range(n):\n        corners.append([int(i) for i in stdin.strip().split()])\n    corners.sort()\n    return '\\n'.join(\n        '{} {}'.format(\n            corners[i][0],\n            corners[i][1])\n        for i in range(n))"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2\n   ... 4 7\n   ... 9 8\n   ... 14 17\n   ... 19 18\n   ... ''')\n    '2'\n    >>> solution('''2\n   ... 4 7\n   ... 9 8\n   ... 14 17\n   ... 19 18\n   ... ''')\n    '1'\n    \"\"\"\n    def find_corner_pairs(corners):\n        # corners = [(r1, c1), (r2, c2),... ]\n        assert len(corners) > 1\n        # corner_pairs = {(r1, c1): 1, (r2, c2): 2,... }\n        corners = sorted(corners)\n        corner_pairs = {(r1, c1): 1 for r1, c1 in corners}\n        corner_pairs.update({(r2, c2): 2 for r2, c2 in corners})\n        return corner_pairs\n\n    # your code goes here\n    n = int(stdin.readline())\n    corners = []\n    for i in range(n):\n        r, c = list(map(int, stdin.readline().split()))\n        corners.append((r-1, c-1))\n    corner_pairs = find_corner_pairs(corners)\n    s = sorted(list(corner_pairs.keys()))\n    if s == sorted(list(corner_pairs.values())):\n        return ''.join(str(i+1) for i in s)\n    else:\n        return'syntax error'\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    output = ''\n    input_n = int(stdin)\n    for i in range(1, input_n + 1):\n        r, c = list(map(int, stdin.split()))\n        if r == 1 or r == input_n or c == 1 or c == input_n:\n            output += f'{i} {1}'\n        else:\n            output += f'{i} {r + 1} {c + 1}'\n    return output\nprint(solution(input()))\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_matching_pair(n: int, A: List[int]) -> bool:\n        for i in range(0, len(A) - 1):\n            for j in range(i + 1, len(A)):\n                if A[i] == A[j]:\n                    return True\n        return False\n\n    def is_unique_list(n: int, A: List[int]) -> bool:\n        count = 0\n        for i in range(0, len(A)):\n            if A[i] == count:\n                return False\n            count += 1\n        return True\n\n    def is_intersecting_pair(n: int, A: List[int], B: List[int]) -> bool:\n        for i in range(0, len(A)):\n            for j in range(0, len(B)):\n                if A[i] == B[j]:\n                    return True\n        return False\n\n    def is_border_intersecting(n: int, A: List[int], B: List[int]) -> bool:\n        for i in range(0, len(A)):\n            for j in range(0, len(B)):\n                if A[i] == B[j]:\n                    if i == 0 or i == len(A) - 1 or j == 0 or j == len(B) - 1:\n                        return True\n        return False\n\n    def find_rectangle(n: int, A: List[int]) -> bool:\n        for i in range(0, len(A) - 1):\n            if not is_border_intersecting(n, A, A[i:i + 2]):\n                return False\n        return True\n\n    def find_intersecting_rectangle(n: int, A: List[int], B: List[int]) -> bool:\n        if not is_intersecting_pair(n, A, B):\n            return False\n        if not is_border_intersecting(n, A, A[:1]):\n            return False\n        if not is_border_intersecting(n, A, A[-1:]):\n            return False\n        if not is_border_intersecting(n, A[:1], A):\n            return False\n        if not is_border_intersecting(n, A[-1:], A):\n            return False\n        return True\n\n    def solve(n: int, A: List[int], B: List[int]):\n        return find_matching_pair(n, A) and is_unique_list(n, A) and find_rectangle(n, A) and find_rectangle(n, A[:1]) and find_rectangle(n, A[-1:]) and find_rectangle(n, A[:1][:1]) and find_rectangle(n, A[-1:][:1]) and find_rectangle(n, A[:1][:1][:1]) and find_rectangle(n, A[-1:][:1][:1]) and find_intersecting_rectangle(n, A, B)\n\n    for i in range(0, int(stdin)):\n        n = int(stdin.readline())\n        A = list(map(int, stdin.readline().split()))\n        B = list(map(int, stdin.readline().split()))\n        if solve(n, A, B):\n            print(str(n))\n            for i in range(0, n):\n                print(str(i + 1) + \" \", end=\"\")\n            print(\"\")\n        else:\n            print(\"syntax error\")\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    corners = []\n    for _ in range(n):\n        corners.append(tuple(map(int, stdin.strip().split())))\n    corners = sorted(corners)\n    \n    # Find the set of rows that are equal to the row of the first corner\n    row_dict = {corner: corner[0] for corner in corners}\n\n    # Find the set of rows that are equal to the row of the second corner\n    row_dict_ = {corner: corner[1] for corner in corners}\n\n    # Find the union of the two sets\n    union = set(row_dict.keys()) | set(row_dict_.keys())\n\n    # Check if there are any matches between the union and the sets of rows\n    if any(row_dict[row] == row_dict_[row] for row in union):\n        # If there is, then the answer is the union\n        return \"\".join(str(row) for row in union)\n    else:\n        # If there is no match, the answer is -1\n        return -1\n\nimport sys\nimport re\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d = {\n        '1': '0',\n        '2': '1',\n        '3': '2',\n        '4': '3',\n        '5': '4',\n        '6': '5',\n        '7': '6',\n        '8': '7',\n        '9': '8',\n        '10': '9',\n        '11': '10',\n        '12': '11',\n        '13': '12',\n        '14': '13',\n        '15': '14',\n        '16': '15',\n        '17': '16',\n        '18': '17',\n        '19': '18',\n        '20': '19',\n        '21': '20',\n        '22': '21',\n        '23': '22',\n        '24': '23',\n        '25': '24',\n        '26': '25',\n        '27': '26',\n        '28': '27',\n        '29': '28',\n        '30': '29',\n        '31': '30',\n        '32': '31',\n        '33': '32',\n        '34': '33',\n        '35': '34',\n        '36': '35',\n        '37': '36',\n        '38': '37',\n        '39': '38',\n        '40': '39',\n        '41': '40',\n        '42': '41',\n        '43': '42',\n        '44': '43',\n        '45': '44',\n        '46': '45',\n        '47': '46',\n        '48': '47',\n        '49': '48',\n        '50': '49',\n        '51': '50',\n        '52': '51',\n        '53': '52',\n        '54': '53',\n        '55': '54',\n        '56': '55',\n        '57': '56',\n        '58': '57',\n        '59': '58',\n        '60': '59',\n        '61': '60',\n        '62': '61',\n        '63': '62',\n        '64': '63',\n        '65': '64',\n        '66': '65',\n        '67': '66',\n        '68': '67',\n        '69': '68',\n        '70': '69',\n        '71': '70',\n        '72': '71',\n        '73': '72',\n        '74': '73',\n        '75': '74',\n        '76': '75',\n        '77': '76',\n        '78': '77',\n        '79': '78',\n        '80': '79',\n        '81': '80',\n        '82': '81',\n        '83': '82',\n        '84': '83',\n        '85': '84',\n        '86': '85',\n        '87': '86',\n        '88': '87',\n        '89': '88',\n        '90': '89',\n        '91': '90',\n        '92': '91',\n        '93': '92',\n        '94': '93',\n        '95': '94',\n        '96': '95',\n        '97': '96',\n        '98': '97',\n        '99': '98',\n        '100': '99',\n        '101': '100',\n        '102': '101',\n        '103': '102',\n        '104': '103',\n        '105': '104',\n        '106': '105',\n        '107': '106',\n        '108': '107',\n        '109': '108',\n        '110': '109',\n        '111': '110',\n        '112': '111',\n        '113': '112',\n        '114': '113',\n        '115': '114',\n        '116': '115',\n        '117': '116',\n        '118': '117',\n        '119': '118',\n        '120': '119',\n        '121': '120',\n        '122': '121',\n        '123': '122',\n        '124': '123',\n        '125': '124',\n        '126': '125',\n        '127': '126',\n        '128': '127',\n        '129': '128',\n        '130': '129',\n        '131': '130',\n        '132': '131',\n        '133': '132',\n        '134': '133',\n        '135': '134',\n        '136': '135',\n        '137': '136',\n        '138': '137',\n        '139': '138',\n        '140': '139',\n        '141': '140',\n        '142': '141',\n        '143': '142',\n        '144': '143',\n        '145': '144',\n        '146': '145',\n        '147': '146',\n        '148': '147',\n        '149': '148',\n        '150': '149',\n        '151': '150',\n        '152': '151',\n        '153': '152',\n        '154': '153',\n        '155': '154',\n        '156': '155',\n        '157': '156',\n        '158': '157',\n        '159': '158',\n        '160': '159',\n        '161': '160',\n        '162': '161',\n        '163': '162',\n        '164': '163',\n        '165': '164',\n        "
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    for _ in range(n):\n        stdin = list(map(int, stdin.split()))\n        if len(stdin)!= 2:\n            return \"syntax error\"\n        top_left = (stdin[0], stdin[1])\n        bottom_right = (stdin[0], stdin[1])\n        result.append(top_left)\n        result.append(bottom_right)\n    if result:\n        result.sort()\n        print(*result)\n    return ''.join(str(n) for n in result)\n"
    },
    {
        "number": 3046,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"\".join(sorted(stdin.split()))\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    trans = {\n        \"_\": 1,\n        \"0\": 0,\n        \"1\": 1,\n        \"2\": 2,\n        \"3\": 3,\n        \"4\": 4,\n        \"5\": 5,\n        \"6\": 6,\n        \"7\": 7,\n        \"8\": 8,\n        \"9\": 9,\n        \"10\": 10,\n        \"11\": 11,\n        \"12\": 12,\n        \"13\": 13,\n        \"14\": 14,\n        \"15\": 15,\n        \"16\": 16,\n        \"17\": 17,\n        \"18\": 18,\n        \"19\": 19,\n        \"20\": 20,\n        \"21\": 21,\n        \"22\": 22,\n        \"23\": 23,\n        \"24\": 24,\n        \"25\": 25,\n        \"26\": 26,\n        \"27\": 27,\n        \"28\": 28,\n        \"29\": 29,\n        \"30\": 30,\n        \"31\": 31,\n        \"32\": 32,\n        \"33\": 33,\n        \"34\": 34,\n        \"35\": 35,\n        \"36\": 36,\n        \"37\": 37,\n        \"38\": 38,\n        \"39\": 39,\n        \"40\": 40,\n        \"41\": 41,\n        \"42\": 42,\n        \"43\": 43,\n        \"44\": 44,\n        \"45\": 45,\n        \"46\": 46,\n        \"47\": 47,\n        \"48\": 48,\n        \"49\": 49,\n        \"50\": 50,\n        \"51\": 51,\n        \"52\": 52,\n        \"53\": 53,\n        \"54\": 54,\n        \"55\": 55,\n        \"56\": 56,\n        \"57\": 57,\n        \"58\": 58,\n        \"59\": 59,\n        \"60\": 60,\n        \"61\": 61,\n        \"62\": 62,\n        \"63\": 63,\n        \"64\": 64,\n        \"65\": 65,\n        \"66\": 66,\n        \"67\": 67,\n        \"68\": 68,\n        \"69\": 69,\n        \"70\": 70,\n        \"71\": 71,\n        \"72\": 72,\n        \"73\": 73,\n        \"74\": 74,\n        \"75\": 75,\n        \"76\": 76,\n        \"77\": 77,\n        \"78\": 78,\n        \"79\": 79,\n        \"80\": 80,\n        \"81\": 81,\n        \"82\": 82,\n        \"83\": 83,\n        \"84\": 84,\n        \"85\": 85,\n        \"86\": 86,\n        \"87\": 87,\n        \"88\": 88,\n        \"89\": 89,\n        \"90\": 90,\n        \"91\": 91,\n        \"92\": 92,\n        \"93\": 93,\n        \"94\": 94,\n        \"95\": 95,\n        \"96\": 96,\n        \"97\": 97,\n        \"98\": 98,\n        \"99\": 99,\n    }\n    for i in range(n):\n        for j in range(i, n):\n            plates = lines[i + 1].split(\" \")\n            for k in range(len(plates)):\n                plates[k] = trans[plates[k]]\n            # print(plates)\n            if plates[0]!= plates[1] and plates[1]!= plates[2] and plates[0]!= plates[2] and plates[0]!= plates[1] and plates[1]!= plates[2] and plates[0]!= plates[1] and plates[1]!= plates[2] and plates[0]!= plates[1]:\n                print(plates[0], plates[1], plates[2])\n                return \"many\"\n    print(n)\n    return \"1\"\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    top = stdin[0].split(\" \")\n    bottom = stdin[1].split(\" \")\n    count = 0\n    grid = {}\n    for i in range(3):\n        for j in range(2):\n            grid[top[i]+bottom[j]] = {\"top\":top[i],\"bottom\":bottom[j]}\n    print(grid)\n    for i in range(2,len(top)):\n        print(grid[top[i]][\"top\"],grid[top[i]][\"bottom\"])\n        if grid[top[i]][\"top\"] == \"\":\n            grid[top[i]][\"top\"] = i\n        if grid[top[i]][\"bottom\"] == \"\":\n            grid[top[i]][\"bottom\"] = i\n    for i in range(len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = int(grid[top[i]][\"top\"])\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = int(grid[top[i]][\"bottom\"])\n    for i in range(2,len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] - grid[top[i-1]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] - grid[top[i-1]][\"bottom\"]\n    for i in range(2,len(top)):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i-1]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i-1]][\"bottom\"]\n    for i in range(2,len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i-1]][\"top\"] - grid[top[i-2]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i-1]][\"bottom\"] - grid[top[i-2]][\"bottom\"]\n    for i in range(2,len(top)):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i-1]][\"bottom\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i-1]][\"top\"]\n    for i in range(2,len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i-1]][\"bottom\"] - grid[top[i-2]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i-1]][\"top\"] - grid[top[i-2]][\"bottom\"]\n    print(grid)\n    for i in range(len(top)-3):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i+1]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i+1]][\"bottom\"]\n    print(grid)\n    for i in range(len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i+1]][\"bottom\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i+1]][\"top\"]\n    for i in range(2,len(top)-2):\n        if grid[top[i]][\"top\"]!= \"\":\n            grid[top[i]][\"top\"] = grid[top[i]][\"top\"] * grid[top[i-1]][\"top\"] - grid[top[i-2]][\"top\"]\n        if grid[top[i]][\"bottom\"]!= \"\":\n            grid[top[i]][\"bottom\"] = grid[top[i]][\"bottom\"] * grid[top[i"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.splitlines()\n    plates = []\n    for i in range(len(rows)):\n        plates.append([])\n        rows[i] = rows[i].split()\n        for j in range(len(rows[i])):\n            if rows[i][j]!= '_':\n                plates[i].append(int(rows[i][j]))\n    \n    for i in range(len(plates)):\n        plates[i].sort()\n    \n    \n    n = 1\n    while n == 1:\n        diffs = []\n        for i in range(len(plates)):\n            if len(plates[i]) > 0:\n                diffs.append(plates[i][-1] - plates[i][-2])\n        if len(diffs) > 0:\n            n = len(diffs)\n        for i in range(len(plates)):\n            if len(plates[i]) > 0:\n                plates[i].pop()\n    \n    return str(n)\nprint(solution(input()))"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.splitlines()\n    widths = rows[0]\n    widths = widths.split()\n    widths = list(map(int, widths))\n    rows = rows[1:]\n    for i in range(len(rows)):\n        rows[i] = rows[i].split()\n    ans = 0\n    for i in range(1, len(rows)):\n        if rows[0][i] == rows[1][i]:\n            ans += widths[i-1]\n    return str(ans)"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    n = len(data)\n    if n == 0:\n        return str(0)\n    if n == 1:\n        return str(1)\n    result = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            result[i][j] = result[i - 1][j] + result[i][j - 1]\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if data[i - 1] == \"0\" or data[j - 1] == \"0\":\n                result[i][j] = 0\n    for i in range(n + 1):\n        result[i][n] = 0\n    for i in range(n + 1):\n        result[n][i] = 0\n    for i in range(n + 1):\n        for j in range(n + 1):\n            result[i][j] = result[i][j] + result[i - 1][j] + result[i][j - 1] - result[i - 1][j - 1]\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if data[i - 1] == \"0\" or data[j - 1] == \"0\":\n                result[i][j] = 0\n    #print(result)\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if result[i][j] == 0:\n                return str(0)\n    return str(result[n][n])"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    plates = stdin.split('\\n')\n    plates = [[int(i) for i in j.split()] for j in plates]\n\n    left = 0\n    right = 1\n    top = len(plates) - 2\n    bottom = len(plates) - 1\n\n    while left <= top and right <= bottom:\n        left_sum = plates[left][0] + plates[left + 1][0]\n        right_sum = plates[right][0] + plates[right - 1][0]\n        if left_sum == right_sum:\n            left += 1\n            right -= 1\n        else:\n            left += 1\n            right -= 1\n\n    return left == top and right == bottom\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rows = list(map(lambda row: row.split(), stdin.splitlines()))\n    # rows = stdin.splitlines()\n    # print(rows)\n    N = len(rows)\n    # print(N)\n    for i in range(N):\n        for j in range(N):\n            # print(rows[i])\n            rows[i][j] = int(rows[i][j])\n    # print(rows)\n    print(rows)\n    # print(N)\n    return \"many\"\n\n\nprint(solution(\"_ 90 22 _ 6 _ _ _ _ 81\\n_ 40 _ _ _ 12 60 _ 90 _\\n\"))\nprint(solution(\"_ 85 55 _ 99 51 _ _ _ _ 170\\n_ _ _ _ _ _ _ 85 63 153\\n\"))\nprint(solution(\"160 _ _ 136 _ _ _ _ _ 170\\n_ _ _ _ 120 _ _ 144 _ _\\n\"))"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    table = {\n        \"90\": {\n            \"88\": [\"_\", \"_\"],\n            \"40\": [\"_\", \"_\"],\n            \"20\": [\"_\", \"_\"]\n        },\n        \"55\": {\n            \"90\": [\"_\", \"_\"],\n            \"40\": [\"_\", \"_\"],\n            \"20\": [\"_\", \"_\"]\n        },\n        \"101\": {\n            \"99\": [\"_\", \"_\"],\n            \"51\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"51\": {\n            \"99\": [\"_\", \"_\"],\n            \"51\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"52\": {\n            \"120\": [\"_\", \"_\"],\n            \"144\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"88\": {\n            \"136\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"130\": {\n            \"_\": [\"_\", \"_\"]\n        },\n        \"85\": {\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"116\": {\n            \"_\": [\"_\", \"_\"]\n        },\n        \"_\": {\n            \"_\": [\"_\", \"_\"]\n        },\n        \"_\": {\n            \"_\": [\"_\", \"_\"]\n        }\n    }\n    table2 = {\n        \"_\": {\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"_\": {\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        },\n        \"_\": {\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"],\n            \"_\": [\"_\", \"_\"]\n        }\n    }\n    for i in stdin.split(\"\\n\"):\n        x = i.split()\n        table[x[0]][x[2]] = x[4:6]\n    s = \"\"\n    for i in range(3, -1, -1):\n        for j in range(1, 10):\n            s += str(int(table2[\"_\"][table[str(i)][str(j)]]))\n        s += \"\\n\"\n    return s.rstrip(\"\\n\")\nprint(solution(stdin))\n"
    },
    {
        "number": 3047,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    top, bottom = stdin.split('\\n')\n    top_b, top_i, bottom_b, bottom_i = map(lambda x: [int(y) for y in x.split(' ')], [top, bottom])\n    ans = {'top': top_b, 'bottom': bottom_b}\n    for row in range(1, len(top_i)):\n        ans[f'top{row}'] = top_i[row] - ans[f'top{row - 1}']\n        ans[f'bottom{row}'] = bottom_i[row] - ans[f'bottom{row - 1}']\n    ans['top0'] = top_i[0] - ans['top1']\n    ans['bottom0'] = bottom_i[0] - ans['bottom1']\n    ans['top1'] = top_i[1] - ans['top0']\n    ans['bottom1'] = bottom_i[1] - ans['bottom0']\n    return'many' if ans[0] == 0 else str(ans[0])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    roads = {}\n    junctions = {}\n    for i in range(1, N + 1):\n        junctions[i] = i\n    for line in stdin.splitlines():\n        u, v = int(line.split()[0]), int(line.split()[1])\n        if u in roads and v not in roads[u]:\n            roads[u].append(v)\n        else:\n            roads[u] = [v]\n        if v in roads and u not in roads[v]:\n            roads[v].append(u)\n        else:\n            roads[v] = [u]\n        if u in junctions and v in junctions:\n            junctions[u], junctions[v] = min(u, v), max(u, v)\n    ans = 0\n    for j in range(1, N + 1):\n        if j in junctions and j!= junctions[j]:\n            for i in roads[junctions[j]]:\n                if i!= junctions[j]:\n                    ans += 1\n            for i in roads[j]:\n                if i!= junctions[j]:\n                    ans += 1\n    return str(ans)"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.strip())\n    if N == 2:\n        return '2'\n    \n    # create a directed graph with adjacency list\n    # the nodes will be just junctions and each edge is the length of the road from one to the other\n    G: Dict[int, List[int]] = {}\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        if u not in G:\n            G[u] = []\n        G[u].append(v)\n\n    def dfs(u, visited, path):\n        visited.add(u)\n        path.append(u)\n        if u in G:\n            for v in G[u]:\n                if v not in visited:\n                    dfs(v, visited, path)\n\n    ans: int = 0\n    visited: Set[int] = set()\n    path: List[int] = []\n    dfs(0, visited, path)\n    for u in range(1, N):\n        for v in G[u]:\n            if v in visited:\n                ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    import numpy as np\n    N = int(stdin.split('\\n')[0])\n    M = int(stdin.split('\\n')[1])\n    junctions = np.array([[int(x) for x in stdin.split('\\n')[2].split()] for _ in range(N)])\n    for j in junctions:\n        if j[0]!= j[1]:\n            raise ValueError(\"junctions are not connected\")\n    roads = [[int(x) for x in stdin.split('\\n')[3 + 2*j].split()] for j in range(N - 1)]\n    for r in roads:\n        if r[0]!= r[1]:\n            raise ValueError(\"junctions are not connected\")\n    return str(len(find_optimal_paths(junctions, roads)))\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 2:\n        return str(2)\n    else:\n        res = 0\n        if n == 3:\n            res = 4\n        else:\n            for i in range(n):\n                for j in range(i+1, n):\n                    res += 1\n                    if stdin.split()[i+1] == stdin.split()[j]:\n                        res += 1\n                        break\n        return str(res)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    f = lambda n: n * (n + 1) // 2\n    return f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f("
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    N = int(stdin)\n    ans = 0\n    for _ in range(N - 1):\n        u, v = map(int, stdin.split())\n        if u == v:\n            continue\n        ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    paths = []\n    for _ in range(N - 1):\n        paths.append(list(map(int, input().split())))\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    for _ in range(N):\n        for i in range(N):\n            dp[i + 1][i + 1] = 1\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if paths[i][0] == paths[j][1] and paths[i][1] == paths[j][0]:\n                    dp[i + 1][j + 1] = 1\n                elif paths[i][0] == paths[j][1]:\n                    dp[i + 1][j + 1] = dp[i][j + 1] + dp[j + 1][i]\n                elif paths[i][1] == paths[j][0]:\n                    dp[i + 1][j + 1] = dp[j + 1][i] + dp[i][j + 1]\n    return str(dp[1][-1])"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    paths = [[] for _ in range(N)]\n    for i in range(1, N + 1):\n        u, v = map(int, lines[i].split())\n        paths[u].append(v)\n        paths[v].append(u)\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if i!= j:\n                if len(paths[i]) <= 2 or len(paths[j]) <= 2:\n                    continue\n                if paths[i][1] == paths[j][0] or paths[i][-1] == paths[j][-1]:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    junctions = []\n    for line in stdin.strip().split('\\n'):\n        junctions.append([int(j) for j in line.split()])\n    total = 0\n    for i in range(len(junctions)):\n        for j in range(len(junctions)):\n            if i == j:\n                continue\n            if junctions[i][0] == junctions[j][0] or junctions[i][0] == junctions[j][1] or junctions[j][0] == junctions[i][1]:\n                continue\n            d = junctions[i][1] - junctions[j][0]\n            if d == 1:\n                continue\n            if d == 2:\n                total += 1\n    return str(total)\n\n\nprint(solution(\"\"\"\n3\n1 2\n1 3\n\"\"\"))\n\nprint(solution(\"\"\"\n5\n2 1\n1 5\n3 1\n4 3\n\"\"\"))\n"
    },
    {
        "number": 3048,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # if n <= 2:\n    #     return str(n - 1)\n    if n <= 5:\n        return str(n - 1)\n    # if n <= 7:\n    #     return str(n - 2)\n    # if n <= 9:\n    #     return str(n - 3)\n    return str(n - 2)"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin\n    m = re.findall('(.)+', message)\n    x = re.sub('[a-z]', '', m[0])\n    y = re.sub('[a-z]', '', m[1])\n    if x == y:\n        print(str(len(message)-len(y)))\n    else:\n        print(str(len(message)-len(m[0])))\n    return stdin"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, decrypt = stdin.splitlines()\n    # Decrypt the message\n    decrypt = decrypt.replace(' ', '')\n    decrypt = decrypt.replace('\\n', '')\n    decrypt = decrypt.replace('\\t', '')\n    decrypt = decrypt[::-1]\n    decrypt = decrypt.lower()\n\n    # Check if the message fragments can be found in the ciphertext\n    cipher = list(decrypt)\n    if decrypt in encrypt:\n        return decrypt\n    else:\n        return str(len(encrypt))\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.splitlines()\n    print(stdin)\n    stdin = list(stdin)\n    print(stdin)\n    for i in range(len(stdin)):\n        for j in range(len(stdin)):\n            print(i,j)\n            if stdin[i][j] == stdin[j][i]:\n                stdin[i] = stdin[i].replace(stdin[i], \"\")\n                print(stdin[i])\n    print(stdin)\n    return''.join(stdin)\n\nprint(solution(\"oranges boot\"))\n'''\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin\n    substring = stdin\n\n    if substring in message:\n        return str(message.find(substring))\n    else:\n        return str(message.count(substring))\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''a\n   ... b\n   ... c\n   ... d\n   ... e\n   ... f\n   ... g\n   ... h\n   ... i\n   ... j\n   ... k\n   ... l\n   ... m\n   ... n\n   ... o\n   ... p\n   ... q\n   ... r\n   ... s\n   ... t\n   ... u\n   ... v\n   ... w\n   ... x\n   ... y\n   ... z''')\n    'xvq'\n    >>> solution('''A\n   ... B\n   ... C\n   ... D\n   ... E\n   ... F\n   ... G\n   ... H\n   ... I\n   ... J\n   ... K\n   ... L\n   ... M\n   ... N\n   ... O\n   ... P\n   ... Q\n   ... R\n   ... S\n   ... T\n   ... U\n   ... V\n   ... W\n   ... X\n   ... Y\n   ... Z''')\n    'ZY'\n    >>> solution('''a\n   ... a\n   ... b\n   ... c\n   ... d\n   ... e\n   ... f\n   ... g\n   ... h\n   ... i\n   ... j\n   ... k\n   ... l\n   ... m\n   ... n\n   ... o\n   ... p\n   ... q\n   ... r\n   ... s\n   ... t\n   ... u\n   ... v\n   ... w\n   ... x\n   ... y\n   ... z''')\n    'a'\n    \"\"\"\n    cipher_text = stdin.split()\n    cipher_text = ''.join(cipher_text)\n    decoded = ''\n    for i in range(1, len(cipher_text)):\n        letter = cipher_text[i]\n        letter = chr(ord(letter) - 1)\n        decoded = decoded + letter\n    if cipher_text.count(decoded)!= 1:\n        return '0'\n    else:\n        return decoded\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin.split()[1]\n    fragment = stdin.split()[2]\n    messages = []\n    fragments = []\n    for i in range(0, len(message)):\n        if message[i] == '@':\n            messages.append(message[:i])\n            message = message[i+1:]\n    for i in range(0, len(fragment)):\n        if fragment[i] == '@':\n            fragments.append(fragment[:i])\n            fragment = fragment[i+1:]\n    if len(messages)!= len(fragments):\n        return \"0\"\n    matches = 0\n    for i in range(0, len(messages)):\n        if messages[i] == fragments[i]:\n            matches += 1\n    return str(matches)"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    message = stdin[1]\n    fragment = stdin[2]\n    if not message:\n        raise ValueError\n    if not fragment:\n        raise ValueError\n    if not all(x.islower() for x in fragment):\n        raise ValueError\n    if len(message) < len(fragment):\n        raise ValueError\n    if not all(x in message for x in fragment):\n        raise ValueError\n\n    # create dict to hold indexes of occurrences\n    occurrence_dict = {}\n    # create a list of all the indexes to search\n    search_list = list(range(len(fragment)))\n\n    # for each letter in message\n    for idx, letter in enumerate(message):\n        # if letter is in occurrence_dict\n        if occurrence_dict.get(letter) is None:\n            # if it isn't in dict, it's a new occurrence\n            occurrence_dict[letter] = [idx]\n        # otherwise, it's an occurrence\n        else:\n            # add to the occurrence_dict\n            occurrence_dict[letter].append(idx)\n    # search the occurrences for fragment\n    # if fragment appears in the list of all occurrences\n    for idx in search_list:\n        if fragment in occurrence_dict.get(message[idx]):\n            # return message and index where the fragment is\n            return message[idx] + \" at position \" + str(idx)\n    # if there are no occurrences\n    return str(len(search_list))\n"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    c = stdin.split('\\n')[0]\n    d = stdin.split('\\n')[1]\n    \n    n = len(c)\n    c = list(c)\n    d = list(d)\n\n    if len(c)!= len(d):\n        return \"0\"\n\n    new_str = ''\n    for i in range(len(c)):\n        new_str += c[i]\n        if c[i]!= d[i]:\n            new_str = new_str.replace(c[i], d[i])\n\n    return new_str\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    alphas = \"abcdefghijklmnopqrstuvwxyz\"\n    data = stdin.split(\"\\n\")\n    text_raw = data[0]\n    text = \"\".join(x for x in text_raw if x not in alphas)\n    text = \"\".join(text)\n    text = text.replace(\" \", \"\")\n    fragment = data[1]\n    fragment = \"\".join(x for x in fragment if x not in alphas)\n    fragment = fragment.replace(\" \", \"\")\n    count = 0\n    for i in range(len(text)):\n        for j in range(len(fragment)):\n            if text[i+j]!= fragment[j]:\n                count += 1\n            else:\n                continue\n        if count == 0:\n            return text[i:i+len(fragment)]\n        else:\n            count = 0\n    return count\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    field = stdin.splitlines()[1:]\n    possible_trails = []\n    for i in range(len(field)):\n        for j in range(len(field[i])):\n            if field[i][j] == '#':\n                continue\n            elif field[i][j] == '.':\n                field[i][j] = 'R'\n            elif field[i][j] == 'R':\n                field[i][j] = '.'\n            else:\n                field[i][j] = '#'\n    for i in range(len(field)):\n        possible_trails.append(field[i])\n    for i in range(len(possible_trails)):\n        for j in range(len(possible_trails)):\n            if i!= j:\n                # print(possible_trails[i], possible_trails[j])\n                if possible_trails[i][0] == possible_trails[j][0] and possible_trails[i][-1] == possible_trails[j][-1]:\n                    if len(possible_trails[i]) > len(possible_trails[j]):\n                        possible_trails[i] = possible_trails[j]\n    for i in range(len(possible_trails)):\n        possible_trails[i] = possible_trails[i][::-1]\n    for i in range(len(possible_trails)):\n        possible_trails[i] = possible_trails[i].replace('R', '#')\n    for i in range(len(possible_trails)):\n        possible_trails[i] = possible_trails[i].replace('.', '#')\n    # print(possible_trails)\n    # print(possible_trails[0])\n    # print(possible_trails[1])\n    # print(possible_trails[2])\n    # print(possible_trails[3])\n    return len(possible_trails[0])\n\nprint(solution(stdin))\n\n\"\"\"\n\nimport sys\nimport itertools\nfrom collections import deque"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    field = stdin.split()\n    trail = ''\n    cell = field[0]\n    i = 1\n    while i < len(field):\n        cell = cell.replace(field[i], '')\n        trail += field[i]\n        i += 1\n    trail += cell\n    if len(trail) == 0:\n        return '1'\n    if len(trail) == len(set(trail)):\n        return '1'\n    else:\n        return str(len(trail) - len(set(trail)))\n\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''>^<^\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    grid = []\n    for line in stdin.split(\"\\n\"):\n        grid.append(list(line.strip()))\n    return str(min(len(trail) for trail in solve(grid)))\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    if N == 0:\n        return \"\"\n    grid = stdin.split()[1]\n    trail = []\n    i = 0\n    while i < N:\n        j = 0\n        while j < N and grid[i]!= \"#\":\n            if grid[i] == \"<\":\n                trail.append(\"<\")\n                j += 1\n            elif grid[i] == \">\":\n                trail.append(\">\")\n                j += 1\n            elif grid[i] == \"^\":\n                trail.append(\"^\")\n                j += 1\n            elif grid[i] == \"v\":\n                trail.append(\"v\")\n                j += 1\n            grid = grid[:i] + grid[j:]\n            i += 1\n        trail.append(\".\" if i < N else \"\")\n    return len(trail)\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n\n    stdin = stdin.strip()\n    stdin = deque(stdin)\n\n    def evolve_world():\n        global stdin\n        if stdin:\n            if stdin[0] == '<':\n                stdin.popleft()\n            elif stdin[0] == '>':\n                stdin.pop()\n            elif stdin[0] == 'v':\n                stdin.pop()\n            elif stdin[0] == '^':\n                stdin.popleft()\n        else:\n            stdin.append('>')\n            stdin.append('^')\n\n    trail = []\n    while len(trail)!= 0:\n        evolve_world()\n        if len(trail)!= 0:\n            trail.pop()\n        if len(trail) == 0:\n            break\n    if len(trail) == 0:\n        return \"1\"\n    return str(min([len(trail), max([len(trail), 2])]))\n\n\nprint(solution(input()))"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(row_index, col_index, grid, char):\n        if 0 <= row_index < len(grid) and 0 <= col_index < len(grid[0]):\n            if grid[row_index][col_index] == char:\n                return True\n        return False\n    grid = stdin.split('\\n')\n    visited_cells = set()\n    row_index = 0\n    col_index = 0\n    while True:\n        if row_index == len(grid):\n            return 1\n        if col_index == len(grid[0]):\n            col_index = 0\n            row_index += 1\n            continue\n        char = grid[row_index][col_index]\n        if char == 'R':\n            return 1\n        if char == '#':\n            continue\n        row_index += 1\n        continue\n        if char == '>':\n            col_index += 1\n            continue\n        if char == '<':\n            col_index -= 1\n            continue\n        if char == '^':\n            row_index -= 1\n            continue\n        if char == 'v':\n            row_index += 1\n            continue\n        visited_cells.add((row_index, col_index))\n        row_index += 1\n        col_index += 1\n        continue\n    return 1\nprint(solution(stdin))"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n    N, L = map(int, stdin.pop(0).split())\n    grid = [[c for c in stdin.pop(0)] for _ in range(N)]\n    for n in range(N):\n        if grid[n][0] == '#':\n            grid[n][0] = 'R'\n            break\n    print(grid)\n    trail = []\n    while len(trail) < L:\n        trail.append(''.join(grid[i][j] for j in range(N)))\n        curr = ''.join(grid[i][j] for i in range(N) if grid[i][j]!= '#' and i!= 0 and j!= 0)\n        if curr in trail:\n            return f'{len(trail) - 1}'\n        if curr in trail[-1]:\n            trail = trail[:-1]\n        else:\n            trail.append(curr)\n    return f'{len(trail) - 1}'\n\nprint(solution(''))\nprint(solution(''))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n'.join(['#.'*3 + '\\n' + '#.'*3]*3)))\nprint(solution('\\n"
    },
    {
        "number": 3050,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def move_right():\n        global path\n        x = path.pop()\n        if x == '>':\n            path = 'v' + path\n        elif x == '^':\n            path = '<' + path\n        elif x == '<':\n            path = '^' + path\n        elif x == 'v':\n            path = '>' + path\n\n    def move_down():\n        global path\n        x = path.pop()\n        if x == '^':\n            path = '>' + path\n        elif x == 'v':\n            path = '<' + path\n        elif x == '<':\n            path = '^' + path\n        elif x == '>':\n            path = 'v' + path\n\n    def move_left():\n        global path\n        x = path.pop()\n        if x == '<':\n            path = '>' + path\n        elif x == '>':\n            path = 'v' + path\n        elif x == '^':\n            path = '<' + path\n        elif x == 'v':\n            path = '^' + path\n\n    def move_up():\n        global path\n        x = path.pop()\n        if x == 'v':\n            path = '^' + path\n        elif x == '>':\n            path = 'v' + path\n        elif x == '^':\n            path = '<' + path\n        elif x == '<':\n            path = '>' + path\n\n    path = stdin\n    while len(path)!= 1:\n        move_right()\n        move_down()\n        move_left()\n        move_up()\n    return path[0]\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    nets = []\n    for i in range(1, int(lines[0])+1):\n        params = lines[i].split()\n        nets.append([int(params[0]), int(params[1]), int(params[2]), int(params[3]), int(params[4]), int(params[5]), int(params[6])])\n\n    count = 0\n\n    nets = sorted(nets, key=lambda x: x[0])\n    nets_sorted = sorted(nets, key=lambda x: x[1])\n    nets_sorted = sorted(nets_sorted, key=lambda x: x[2])\n    nets_sorted = sorted(nets_sorted, key=lambda x: x[3])\n    nets_sorted = sorted(nets_sorted, key=lambda x: x[4])\n    nets_sorted = sorted(nets_sorted, key=lambda x: x[5])\n    nets_sorted = sorted(nets_sorted, key=lambda x: x[6])\n\n    nets = []\n    nets.append(nets_sorted[0])\n    nets.append(nets_sorted[1])\n\n    nets = sorted(nets, key=lambda x: x[1])\n    nets = sorted(nets, key=lambda x: x[2])\n    nets = sorted(nets, key=lambda x: x[3])\n    nets = sorted(nets, key=lambda x: x[4])\n    nets = sorted(nets, key=lambda x: x[5])\n    nets = sorted(nets, key=lambda x: x[6])\n\n    for i in range(1, len(nets)):\n        if (nets[i-1][1] + nets[i-1][6] == nets[i][1]) or (nets[i-1][1] + nets[i-1][6] == nets[i][1] + nets[i][5]):\n            nets[i][1] = nets[i-1][1] + nets[i-1][6]\n            nets[i][2] = nets[i-1][2] + nets[i-1][6]\n            nets[i][3] = nets[i-1][3] + nets[i-1][6]\n            nets[i][4] = nets[i-1][4] + nets[i-1][6]\n            nets[i][5] = nets[i-1][5] + nets[i-1][6]\n            nets[i][6] = nets[i-1][6]\n        elif nets[i][1] + nets[i][6"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = [x.split() for x in stdin.split('\\n') if x]\n    n = int(input_lines[0][0])\n    i = 1\n    while i < len(input_lines):\n        m = int(input_lines[i][0])\n        d = int(input_lines[i][1])\n        l = int(input_lines[i][2])\n        r = int(input_lines[i][3])\n        h = int(input_lines[i][4])\n        delta_x = int(input_lines[i][5])\n        delta_h = int(input_lines[i][6])\n        n_missed = 0\n        for j in range(n):\n            if j == 0:\n                if r >= l:\n                    if r >= r:\n                        if m >= m:\n                            x_max = r + (m - 1) * delta_x\n                            x_min = l + (m - 1) * delta_x\n                        else:\n                            x_max = r + m * delta_x\n                            x_min = l + m * delta_x\n                    else:\n                        x_max = r + delta_x\n                        x_min = l + delta_x\n                else:\n                    x_max = r + delta_x\n                    x_min = l + delta_x\n                h_max = h + delta_h\n                h_min = h\n            else:\n                if r >= l:\n                    if r >= r:\n                        if m >= m:\n                            x_max = r + (m - 1) * delta_x\n                            x_min = l + (m - 1) * delta_x\n                        else:\n                            x_max = r + m * delta_x\n                            x_min = l + m * delta_x\n                    else:\n                        x_max = r + delta_x\n                        x_min = l + delta_x\n                else:\n                    x_max = r + delta_x\n                    x_min = l + delta_x\n            if x_min < 0:\n                continue\n            if x_max > 10**8:\n                continue\n            if x_max < x_min:\n                continue\n            n_missed += 1\n        i += 1\n    return str(n_missed)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *fogs = map(int, stdin.split())\n    return str(count_fogs(fogs))\n\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def fogs(m, x1, r1, h1, d, x2, r2, h2):\n        def bottom_right_point(a, b):\n            return (a, b) if a < b else (b, a)\n        x1, x2, r1, r2 = sorted((x1, x2, r1, r2))\n        x1, x2 = bottom_right_point(x1, x2)\n        h1, h2 = bottom_right_point(h1, h2)\n        return sum(1 for i in range(x1, x2) for j in range(h1, h2)) - m\n\n    fogs_counts = {}\n    for i in range(int(stdin)):\n        m, x1, r1, h1, d, x2, r2, h2 = map(int, stdin.strip().split())\n        s = solution(f'{m} {x1} {r1} {h1} {d} {x2} {r2} {h2}')\n        fogs_counts[s] = fogs_counts.get(s, 0) + 1\n    return''.join(map(str, sorted(fogs_counts.values())))\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def process(num: int, inp: str) -> str:\n        inp = [int(n) for n in inp.split()]\n        out = \" \".join([str(n) for n in inp])\n        return out\n\n    return process(int(stdin.split()[0]), process(*stdin.split()[1:]))"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    nets = []\n    for _ in range(n):\n        line = stdin.strip().split()\n        nums = (int(line[0]), int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5]), int(line[6]))\n        nets.append(nums)\n    return str(count_nets(nets))\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def fogs_to_rectangles(fogs):\n        height = []\n        width = []\n        for f in fogs:\n            height.append(f[2])\n            width.append(f[3])\n\n        rectangles = {}\n        for i in range(len(height)):\n            h = height[i]\n            w = width[i]\n            if not h in rectangles:\n                rectangles[h] = []\n            rectangles[h].append([width[i-1] if i > 0 else 0, w])\n\n        rectangles = rectangles.values()\n        max_y = max(height)\n        return rectangles, max_y\n\n    rectangles = []\n    max_y = 0\n    rectangles, max_y = fogs_to_rectangles(stdin.split())\n\n    rectangles = sorted(rectangles, key=lambda x: x[0])\n    max_y = max_y - 1\n    rectangles = sorted(rectangles, key=lambda x: x[1])\n    max_y = max_y - 1\n\n    rectangles = sorted(rectangles, key=lambda x: (x[1], -x[0]))\n    max_y = max_y - 1\n    return str(max_y)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nets = []\n    for _ in range(n):\n        nets.append(list(map(int, stdin.split())))\n    nets = sorted(nets, key=lambda x: (x[0], x[1], x[2]))\n    skip = 0\n    area = 0\n    for i in range(n):\n        if skip!= 0:\n            skip -= 1\n        else:\n            skip = nets[i][3]\n        if nets[i][4] < nets[i][5]:\n            area += (nets[i][4] - nets[i][2]) * (nets[i][5] - nets[i][2])\n    return str(area)\n"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # For time-complexity, see the comment above solution().\n    return str(solution_recursive(int(stdin.split()[0]), stdin.split()[1:]))\n    # Alternatively, a simpler version that is O(n^2)\n    # import itertools\n    # return sum(itertools.accumulate(solution_recursive(int(i), j) for i, j in (i.split() for i in stdin.splitlines())))\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    originators = [[int(x) for x in stdin.split()[i + 1:i + 5]] for i in range(n)]\n    days = int(stdin.split()[-1])\n    patches = [(0, 0, 0, 0, 0, 0, 0)]\n    fogs = 0\n    while True:\n        for i in range(n):\n            p = patches[-1]\n            nfogs = 0\n            if p[0] == 0:\n                if days == 0:\n                    return fogs\n                days -= 1\n            if p[0] == 0 and p[3] <= days:\n                nfogs = p[1] - p[2] + 1\n                if p[3] == days:\n                    nfogs += p[4]\n            if p[0] == p[3] and p[0] + p[4] < days:\n                nfogs = p[1] - p[2] + 1\n                if p[0] + p[4] == days:\n                    nfogs += p[5]\n            if p[0]!= 0 and p[0] + p[3] == days and p[5] > p[4]:\n                nfogs = p[1] - p[2] + 1\n                if p[5] == p[4]:\n                    nfogs += p[5]\n            if p[0]!= 0 and p[3] == days and p[4] > p[5]:\n                nfogs = p[1] - p[2] + 1\n                if p[4] == p[5]:\n                    nfogs += p[4]\n            if p[0]!= 0 and p[3]!= days:\n                nfogs = p[1] - p[2] + 1\n            if nfogs > 0:\n                patches.append((p[0], nfogs, p[1], p[2], p[3], p[4], p[5]))\n            fogs += nfogs\n        if len(patches) == 1:\n            break\n    return fogs\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    points = [float(x) for x in stdin.split(\"\\n\")]\n    \n    N = int(points.pop(0))\n    \n    conveyors = []\n    \n    for _ in range(N):\n        points = [float(x) for x in stdin.split(\"\\n\")]\n        conveyors.append((float(points[0]), float(points[1]), float(points[2]), float(points[3])))\n    \n    XA = float(points[0])\n    YA = float(points[1])\n    XB = float(points[2])\n    YB = float(points[3])\n    \n    if XB - XA == 0:\n        return \"infinity\"\n    \n    if YB - YA == 0:\n        return \"infinity\"\n    \n    results = []\n    results.append(distance(XA, YA, XB, YB))\n    \n    for i in range(1, N):\n        \n        distance1 = distance(conveyors[i-1][0], conveyors[i-1][1], conveyors[i][0], conveyors[i][1])\n        distance2 = distance(conveyors[i-1][2], conveyors[i-1][3], conveyors[i][2], conveyors[i][3])\n        distance3 = distance(conveyors[i][0], conveyors[i][1], conveyors[i-1][2], conveyors[i-1][3])\n        distance4 = distance(conveyors[i][2], conveyors[i][3], conveyors[i-1][0], conveyors[i-1][1])\n        \n        distance = min(distance1, distance2, distance3, distance4)\n        \n        results.append(distance)\n        \n    return str(min(results))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # use stdin\n    pass\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    f_a, f_b = list(map(float, stdin.split()))\n    # print(f\"f_a = {f_a}\")\n    # print(f\"f_b = {f_b}\")\n    x_a = round(f_a, 6)\n    y_a = round(f_b, 6)\n    # print(f\"x_a = {x_a}\")\n    # print(f\"y_a = {y_a}\")\n\n    x_b = round(f_a + f_b, 6)\n    y_b = round(f_b - f_a, 6)\n    # print(f\"x_b = {x_b}\")\n    # print(f\"y_b = {y_b}\")\n\n    # A == (X_A, Y_A)\n    # B == (X_B, Y_B)\n    # (A, B) = ((X_A, Y_A), (X_B, Y_B))\n    # (X_B, Y_B) = (X_A, Y_A)\n\n    # A == (X_A, Y_A)\n    # B == (X_B, Y_B)\n    # ((A, B) == ((X_A, Y_A), (X_B, Y_B)))\n\n    # X_B = X_A + (X_B - X_A)\n    # Y_B = Y_A + (Y_B - Y_A)\n    # (X_A, Y_A) = (X_B, Y_B)\n\n    x_1 = round(x_a + (x_b - x_a), 6)\n    y_1 = round(y_a + (y_b - y_a), 6)\n    # print(f\"x_1 = {x_1}\")\n    # print(f\"y_1 = {y_1}\")\n\n    x_2 = round(x_1 + (x_a - x_1), 6)\n    y_2 = round(y_1 + (y_a - y_1), 6)\n    # print(f\"x_2 = {x_2}\")\n    # print(f\"y_2 = {y_2}\")\n\n    x_3 = round(x_2 + (x_a - x_2), 6)\n    y_3 = round(y_2 + (y_a - y_2), 6)\n    # print(f\"x_3 = {x_3}\")\n    # print(f\"y_3 = {y_3}\")\n\n    x_4 = round(x_3 + (x_a - x_3), 6)\n    y_4 = round(y_3 + (y_a - y_3), 6)\n    # print(f\"x_4 = {x_4}\")\n    # print(f\"y_4 = {y_4}\")\n\n    x_5 = round(x_4 + (x_a - x_4), 6)\n    y_5 = round(y_4 + (y_a - y_4), 6)\n    # print(f\"x_5 = {x_5}\")\n    # print(f\"y_5 = {y_5}\")\n\n    x_6 = round(x_5 + (x_a - x_5), 6)\n    y_6 = round(y_5 + (y_a - y_5), 6)\n    # print(f\"x_6 = {x_6}\")\n    # print(f\"y_6 = {y_6}\")\n\n    x_7 = round(x_6 + (x_a - x_6), 6)\n    y_7 = round(y_6 + (y_a - y_6), 6)\n    # print(f\"x_7 = {x_7}\")\n    # print(f\"y_7 = {y_7}\")\n\n    x_8 = round(x_7 + (x_a - x_7), 6)\n    y_8 = round(y_7 + (y_a - y_7), 6)\n    # print(f\"x_8 = {x_8}\")\n    # print(f\"y_8 = {y_8}\")\n\n    x_9 = round(x_8 + (x_a - x_8), 6)\n    y_9 = round(y_8 + (y_a - y_8), 6)\n    # print(f\"x_9 = {x_9}\")\n    # print(f\"y_9 = {y_9}\")\n\n    x_10 = round(x_9 + (x_a - x_9), 6)\n    y_10 = round(y_9 + (y_a - y_9), 6)\n    # print(f\"x_10 = {x_10}\")\n    # print(f\"y_10 = {y_10}\")\n\n    x_11 = round(x_10 + (x_a - x_10), 6)\n    y_11 = round(y_10 + (y_a - y_10), 6)\n    # print(f\"x_11 = {x_11}\")\n    # print(f\"y_11"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    passengers = list(map(lambda x: (float(x[0]), float(x[1])), stdin.split('\\n')))\n    passengers.sort(key=lambda x: x[0])\n\n    passengers.sort(key=lambda x: x[1])\n\n    conveyors = []\n\n    for i in range(int(input())):\n        X = float(input())\n        Y = float(input())\n        W = float(input())\n        E = float(input())\n        conveyors.append((X, Y, W, E))\n\n    conveyors.sort(key=lambda x: x[0])\n    conveyors.sort(key=lambda x: x[1])\n\n    halls = [(passengers[0][0], passengers[0][1], 0)]\n\n    for passenger in passengers[1:]:\n        if passenger[0] > hall[0] and passenger[1] > hall[1]:\n            halls.append((passenger[0], passenger[1], hall[2] + 1))\n        else:\n            halls.append((hall[0], hall[1], hall[2] + 1))\n            hall = (passenger[0], passenger[1], 0)\n\n    halls.sort(key=lambda x: x[2])\n\n    i = 0\n    j = len(halls) - 1\n\n    while i <= j:\n        if halls[i][2] + halls[j][2] > 0:\n            if halls[i][0] < hall[0] < halls[j][0]:\n                if halls[i][1] > hall[1]:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] - 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] - 1, hall[2] + 1)\n                else:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] + 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] + 1, hall[2] + 1)\n            elif halls[i][0] < hall[0] < halls[j][0]:\n                if halls[i][1] > hall[1]:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] - 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] - 1, hall[2] + 1)\n                else:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] + 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] + 1, hall[2] + 1)\n            elif halls[i][0] > hall[0] > halls[j][0]:\n                if halls[i][1] > hall[1]:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] - 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] - 1, hall[2] + 1)\n                else:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] + 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] + 1, hall[2] + 1)\n            elif halls[i][0] > hall[0] > halls[j][0]:\n                if halls[i][1] > hall[1]:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] - 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] - 1, hall[2] + 1)\n                else:\n                    if halls[i][2] - 1 < hall[2]:\n                        hall = (hall[0], hall[1] + 1, hall[2] - 1 + halls[i][2] - 1)\n                    else:\n                        hall = (hall[0], hall[1] + 1, hall[2] + 1)\n        else:\n            hall = (hall[0], hall[1], hall[2] + 1)\n        i += 1\n        j -= 1\n\n    return str(hall[2] + 1)\n\n\nsolution(\"60.0 0.0 50.0 170.0\\n3\\n40.0 0.0 0.0 0.0\\n5.0 20.0 5.0 170.0\\n95.0 0.0 95.0 80.0\")\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = list(map(float, stdin.split()))\n    X_A, Y_A = data[0], data[1]\n    X_B, Y_B = data[2], data[3]\n    N = data[4]\n    ans = None\n\n    def is_on_board(x: float, y: float) -> bool:\n        if x < 0 or x > 1000:\n            return False\n        if y < 0 or y > 1000:\n            return False\n        return True\n\n    def is_in_range(x: float, y: float) -> bool:\n        if x < 0 or x > 1000:\n            return False\n        if y < 0 or y > 1000:\n            return False\n        return True\n\n    def is_convex(x: float, y: float) -> bool:\n        if x == 0 or y == 0:\n            return False\n        return True\n\n    def is_on_conveyor(X: float, Y: float, n: int) -> bool:\n        if X == 0 or Y == 0:\n            return False\n        if n >= N:\n            return False\n        return True\n\n    def is_straight_line(x1: float, y1: float, x2: float, y2: float) -> bool:\n        if x1 == x2 and y1 == y2:\n            return True\n        return False\n\n    def get_min_time(X: float, Y: float, n: int) -> float:\n        if X == 0 or Y == 0:\n            return float(\"inf\")\n        if n >= N:\n            return float(\"inf\")\n        return 0\n\n    def travel(X: float, Y: float, n: int) -> float:\n        if is_convex(X, Y):\n            if is_in_range(X, Y):\n                if n == 1:\n                    return 1\n                return travel(X, Y, n-1)\n            return float(\"inf\")\n        return float(\"inf\")\n\n    def move_forward(X: float, Y: float, n: int) -> float:\n        if is_straight_line(X, Y, X_A, Y_A):\n            if n == 0:\n                return float(\"inf\")\n            return travel(X, Y, n-1)\n        return float(\"inf\")\n\n    def move_backward(X: float, Y: float, n: int) -> float:\n        if is_straight_line(X, Y, X_B, Y_B):\n            if n == 0:\n                return float(\"inf\")\n            return travel(X, Y, n-1)\n        return float(\"inf\")\n\n    # if not (is_on_board(X_A, Y_A) and is_on_board(X_B, Y_B)):\n    #     return \"invalid\"\n\n    if not is_convex(X_A, Y_A) or not is_straight_line(X_A, Y_A, X_B, Y_B):\n        return \"invalid\"\n\n    if not is_convex(X_B, Y_B) or not is_straight_line(X_B, Y_B, X_A, Y_A):\n        return \"invalid\"\n\n    if X_A == X_B:\n        ans = get_min_time(X_A, Y_A, N)\n    elif Y_A == Y_B:\n        ans = get_min_time(X_A, Y_A, N)\n    else:\n        dist_a = travel(X_A, Y_A, N) + get_min_time(X_B, Y_B, N)\n        dist_b = get_min_time(X_A, Y_B, N) + travel(X_B, Y_B, N)\n        ans = min(dist_a, dist_b)\n\n    return str(ans)\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X_A, Y_A, X_B, Y_B = map(float, stdin.split())\n    D = math.sqrt((X_B - X_A) ** 2 + (Y_B - Y_A) ** 2)\n    return str(round(D / 1.1513 * 3600, 4))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    x1, y1, x2, y2 = map(float, stdin[0].split())\n    N = int(stdin[1])\n    conveyors = []\n    for i in range(2, N+2):\n        x1, y1, x2, y2 = map(float, stdin[i].split())\n        conveyors.append((x1, y1, x2, y2))\n\n    if len(conveyors) == 0:\n        return str(0)\n    else:\n        f_last = 0\n        t_last = 0\n        for i in range(1, len(conveyors)):\n            f_last = max(f_last,\n                         math.ceil(abs(conveyors[i][0]-conveyors[i-1][0])/2) +\n                         abs(conveyors[i][0]-conveyors[i-1][2]))\n            t_last = max(t_last,\n                         math.ceil(abs(conveyors[i][1]-conveyors[i-1][1])/2) +\n                         abs(conveyors[i][1]-conveyors[i-1][3]))\n        return str(max(f_last, t_last))\n"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, k = list(map(float, stdin.split()))\n    min_time = math.ceil(x / k) + math.ceil(((y - z) / k) - math.ceil((x - z) / k))\n    return str(min_time)"
    },
    {
        "number": 3052,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B = list(map(float, stdin.strip().split()))\n    N = int(stdin.strip().split()[1])\n    return str(min(abs(A - B) / (B - A), abs(A - B) / (B - A) + (B - A) / (2 * N) * 1.2))\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = list(map(int, stdin.split()))\n    result = ''\n    for s in range(N, K-1, -1):\n        if len(set(stdin[0:s])) == N and len(set(stdin[s:P])) == N and len(set(stdin[P:K])) == N:\n            result = stdin[s:P] + stdin[P:K] + stdin[0:s]\n            break\n    if len(result) == 0:\n        result = 'IMPOSSIBLE'\n    return result"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = list(map(int, stdin.split()))\n    if n!= k or n!= p:\n        return \"IMPOSSIBLE\"\n    return list(string.ascii_lowercase)[:n] + list(reversed(list(string.ascii_lowercase)[:n]))\n\n-----Explanation-----\nn = # of distinct characters in the string,\nk = # of identical characters in the middle of the string,\np = # of identical characters at the end of the string\n\nFor a string to satisfy all requirements, one of the following must be true:\n- n must be exactly $N$,\n- p must be exactly $P$,\n- the middle k characters must be exactly $K$ distinct characters\n- the middle p characters must be exactly $K$ distinct characters.\n\nIf not, the string is impossible to satisfy.\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N, K, P = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    return 'IMPOSSIBLE' if N < K or K < 1 or N < P else 'rarity'\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = (int(x) for x in stdin.split())\n    if N < K or N < P:\n        return \"IMPOSSIBLE\"\n    # A palindrome is a string that reads the same forwards and backwards\n    # HINT: You can easily get the length of a string by counting the number of characters\n    #       with a built-in function like `len(mystring)`.\n    # HINT: You can convert a string into a list of characters like so:\n    #       mystring_list = list(mystring)\n    # HINT: You can convert a list of characters into a string like so:\n    #       mystring = ''.join(mystring_list)\n    # HINT: You can use `len(mystring) == len(mystring)` to test if a string is a palindrome.\n    #       You can use `mystring == mystring[::-1]` to check if a string is a palindrome\n    #       as well.\n    res = \"rarity\"\n    while len(res) < N:\n        res = res + res\n    return res[:N]"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split()\n    N, K, P = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    for i in range(1, 10001):\n        for j in range(1, 10001):\n            if len(set(str(i))) == K and len(str(i)) == N and str(i) == str(i)[::-1]:\n                for k in range(1, 10001):\n                    if len(set(str(k))) == K and len(str(k)) == N and str(k) == str(k)[::-1]:\n                        if str(i) + str(k) + str(j) == str(i)[::-1] + str(k)[::-1] + str(j)[::-1]:\n                            return str(i) + str(k) + str(j)\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = (int(x) for x in stdin.split())\n    strs = []\n\n    for i in range(1, N + 1):\n        if len(set(stdin.lower()[i - 1:i + K - 1])) == K:\n            strs.append(stdin[i - 1:i + K])\n\n    if len(strs) < P or (P == 1 and len(set(stdin.lower()[:N - K + 1])) == N):\n        return \"IMPOSSIBLE\"\n\n    for str1 in strs:\n        for str2 in strs:\n            if str1!= str2 and is_palindrome(str1 + str2) and len(str1) + len(str2) == N:\n                return str1\n\n    return \"IMPOSSIBLE\"\n\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    a = \"\".join(sorted(set(stdin))).replace(\" \", \"\")\n    if len(a) < n:\n        return \"IMPOSSIBLE\"\n    for i in range(len(a)):\n        s = a[i: i + n]\n        if s == s[::-1]:\n            l = len(s)\n            if l < p:\n                continue\n            if l == p:\n                if l == k:\n                    return s\n            elif l > k:\n                return s[:k]\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = list(map(int, stdin.split()))\n    result = ''\n    for i in range(N, 0, -1):\n        if K == len(set(stdin[i - K:i])):\n            for j in range(i - P, i):\n                result += stdin[j]\n    print(result)\n    return result\n\nsolution(input())\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    s = input()\n    s1 = set(s)\n    if len(s1) == 1:\n        return \"IMPOSSIBLE\"\n    else:\n        ans = []\n        for i in range(n-k+1):\n            ans.append(s[i:i+k])\n        ans1 = []\n        for i in range(len(ans)):\n            if len(ans[i])!= p:\n                continue\n            else:\n                ans1.append(ans[i])\n        for i in range(len(ans1)):\n            ans2 = []\n            for j in range(len(ans1[i])):\n                if ord(ans1[i][j]) in s1:\n                    ans2.append(ans1[i][j])\n            if len(ans2) == p:\n                ans.append(''.join(ans2))\n        if len(ans) == 0:\n            return \"IMPOSSIBLE\"\n        return max(ans, key=len)\n"
    },
    {
        "number": 3053,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n  # replace this with your code\n  return stdin\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    def convert_to_syllable(string: str) -> str:\n        syllable_count = 0\n        for letter in string:\n            if letter == \" \":\n                syllable_count += 1\n        return str(syllable_count)\n    \n    line = stdin.split()\n    syllable_line = []\n    for word in line:\n        syllable_line.append(convert_to_syllable(word))\n    if sum(syllable_line) > 5:\n        return \" \".join(line)\n    else:\n        return \" \".join(line[0:1])"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\n   ...     \"Blue Ridge mountain road. Leaves, glowing in autumn sun, fall in Virginia.\"\n   ... )\n    'Blue Ridge mountain road.\\nLeaves, glowing in autumn sun,\\nfall in Virginia.'\n    >>> solution(\n   ...     \"Who would know if we had too few syllables?\\nProgrammers have fun!.\\n\"\n   ... )\n    'Who would know if we had too few syllables?\\nProgrammers have fun!.'\n    >>> solution(\n   ...     \"International contest- motivation high Programmers have fun!.\\n\"\n   ... )\n    'International contest- motivation high\\nProgrammers have fun!'\n    \"\"\"\n    lines = stdin.strip().split(\"\\n\")\n    new_lines = []\n    for line in lines:\n        words = line.split()\n        if len(words) > 3:\n            new_lines.append(line)\n            continue\n        words = line.split()\n        if len(words) == 1:\n            words = line.split()\n            if len(words) > 3:\n                new_lines.append(line)\n                continue\n            new_lines.append(line)\n            continue\n        words = line.split()\n        if len(words) == 3:\n            new_lines.append(line)\n            continue\n        words = line.split()\n        if len(words) == 2:\n            new_lines.append(line)\n            continue\n        words = line.split()\n        if len(words) == 1:\n            new_lines.append(line)\n            continue\n        new_lines.append(line)\n\n    for line in new_lines:\n        print(line)\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns a haiku of the given input line\n    '''\n    from haiku_lib import get_haiku\n    return get_haiku(stdin)\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    lines = list(map(lambda x: x.split(\" \"), lines))\n    lines = list(map(lambda x: list(map(lambda y: y.strip(\",!?.\"), x)), lines))\n    lines = list(map(lambda x: x[0] + \" \" + x[1], lines))\n    lines = list(filter(lambda x: x.isalpha() or x == \" \", lines))\n    lines = list(filter(lambda x: x!= \"\", lines))\n    lines = list(filter(lambda x: len(x.split()) > 2, lines))\n    for word in lines:\n        syllables = 0\n        for c in word:\n            syllables += 1\n            if c =='':\n                syllables += 1\n        if syllables > 0:\n            print(word, end=(\" \"))\n        else:\n            print(word, end=\"\\n\")\n    return \"\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    if len(lines) == 1 and len(lines[0]) == 0:\n        return ''\n    elif len(lines) == 1 and len(lines[0]) > 0:\n        return lines[0]\n    else:\n        return '\\n'.join(haiku(l.split()) for l in lines)\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    count_lines = stdin.splitlines()\n    for i, line in enumerate(count_lines):\n        words = line.split()\n        if len(words) > 3:\n            word_cnt = len(words)\n            lines = []\n            for j in range(word_cnt):\n                words_j = words[j].split(' ')\n                for k in range(len(words_j)):\n                    words_j[k] = words_j[k].strip()\n                if len(words_j) > 1:\n                    lines.append(words_j)\n            # print(lines)\n            print_lines = []\n            for j in range(len(lines)):\n                line_cnt = len(lines[j])\n                if line_cnt <= 3:\n                    print_lines.append(lines[j])\n                    continue\n                # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                for k in range(line_cnt):\n                    if k == 0:\n                        # print(lines[j][k], lines[j][k+1])\n                        if is_consonant(lines[j][k], lines[j][k + 1]):\n                            lines[j][k] = lines[j][k] + lines[j][k + 1]\n                        # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                        if is_vowel(lines[j][k], lines[j][k + 1]):\n                            lines[j][k] = lines[j][k] + lines[j][k + 1]\n                        # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                    elif k == line_cnt - 1:\n                        if is_consonant(lines[j][k], lines[j][k - 1]):\n                            lines[j][k] = lines[j][k] + lines[j][k - 1]\n                        # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                        if is_vowel(lines[j][k], lines[j][k - 1]):\n                            lines[j][k] = lines[j][k] + lines[j][k - 1]\n                        # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                    elif is_vowel(lines[j][k], lines[j][k + 1]):\n                        lines[j][k] = lines[j][k] + lines[j][k + 1]\n                    # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                    else:\n                        if k > 1:\n                            if is_consonant(lines[j][k], lines[j][k - 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k - 1]\n                            # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                            if is_vowel(lines[j][k], lines[j][k - 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k - 1]\n                            # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                        if k < line_cnt - 2:\n                            if is_consonant(lines[j][k], lines[j][k + 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k + 1]\n                            # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                            if is_vowel(lines[j][k], lines[j][k + 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k + 1]\n                            # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                        if k == 0:\n                            if is_consonant(lines[j][k], lines[j][k + 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k + 1]\n                            # print('j=', j, 'line_cnt=', line_cnt, lines[j])\n                            if is_vowel(lines[j][k], lines[j][k + 1]):\n                                lines[j][k] = lines[j][k] + lines[j][k + 1]\n"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip()"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    all_lines = stdin.splitlines()\n    # remove leading and trailing whitespace\n    all_lines = [line.strip() for line in all_lines]\n    haiku_lines = []\n    lines = []\n    syllables = 0\n\n    for line in all_lines:\n        if syllables > 0 and syllables < 11 and line!= \"\":\n            lines.append(line)\n        else:\n            haiku_lines.append(lines)\n            lines = []\n        syllables += len(line.split())\n    haiku_lines.append(lines)\n\n    output = \"\"\n    for haiku in haiku_lines:\n        first = haiku[0]\n        rest = haiku[1:]\n        output += first\n        for line in rest:\n            output += \" \" + line\n        output += \"\\n\"\n    return output\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n  return stdin"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''ThoreTiemann\n   ... ThoreHusfeldt\n   ... JohanSannemo''')\n    'ThoreH'\n    >>> solution('''ThoreTiemann\n   ... ThoreHusfeldt\n   ... ThoreHusfeldt''')\n    'ThoreHusfeldt'\n    \"\"\"\n    names = stdin.splitlines()\n    names.sort(key=lambda x: x[0])\n    prefix = None\n    result = \"\"\n    for name in names:\n        prefix = name[0]\n        if prefix!= \"Thore\":\n            break\n    if prefix is None:\n        prefix = \"\"\n    for name in names:\n        prefix = name[0]\n        if prefix == \"Thore\":\n            return result\n        elif prefix in result:\n            break\n        result += prefix\n    return result\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    name = stdin\n    name = name.splitlines()\n    name = name[0]\n    name = name.split(' ')\n    name = name[0]\n    return name\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    names = set()\n    for name in stdin.split('\\n'):\n        names.add(name)\n    for name in names:\n        if name == 'ThoreHusfeldt':\n            return 'Thore is awesome'\n    return 'Thore sucks'\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    names = []\n    for _ in range(n):\n        names.append(stdin.strip())\n    return 'Thore is awesome' if 'ThoreHusfeldt' in names else 'Thore sucks'"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    #check if there is ThoreHusfeldt on the top\n    if not lines[0] == 'ThoreHusfeldt':\n        return 'Thore sucks'\n    #check if there are more ThoreHusfeldts than ThoreTiemanns\n    if lines[1] == 'ThoreTiemann':\n        return 'Thore is awesome'\n    #check if there is more ThoreHusfeldts than ThoreHusfeldt\n    if lines[1] == 'ThoreHusfeldt':\n        return lines[1]\n    #there is a tie, search for the ThoreTiemann, but with the prefix that is not equal to ThoreHusfeldt\n    for i in range(2,len(lines)):\n        if lines[i] == 'ThoreTiemann':\n            prefix = lines[0]\n            for j in range(1,i):\n                prefix = prefix + lines[j]\n            if prefix!= lines[1]:\n                return lines[1]\n    return lines[1]\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    answer: str = \"\"\n    names = set()\n    \n    for name in stdin.split('\\n'):\n        if name == \"ThoreHusfeldt\":\n            answer = \"Thore is awesome\"\n            break\n        if name in names:\n            answer = \"Thore sucks\"\n            break\n        if len(name) >= 2 and name[0] == \"T\" and name[1] == \"h\" and name[2] == \"a\" and name[3] == \"l\" and name[4] == \"d\":\n            answer = \"Thore sucks\"\n            break\n        else:\n            names.add(name)\n    return answer\n"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.strip())\n    candidates: List[str] = list(stdin.strip().split('\\n'))\n    thore = None\n    for candidate in candidates:\n        prefix = candidate[0:n-1]\n        if candidate == candidate[::-1]:\n            if thore is None:\n                thore = prefix\n            elif prefix < thore:\n                thore = prefix\n    if thore is not None:\n        return 'Thore is awesome'\n    return 'Thore sucks'"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Write a function that takes in a string consisting of the names of people,\n    and returns the prefix that uniquely determines each person on the scoreboard.\n    In other words, find the smallest prefix of each person that uniquely determines\n    the person on the scoreboard, and output each of these prefixes as one line\n    of output.\n\n    Each person's prefix only contains characters from the set $\\big [\\text {a-zA-Z}\\big ]$,\n    i.e. lower and upper case English letters.\n\n    Each person must be on the scoreboard.\n\n    If there is no one above a person, the person should be output as \u201cThore is awesome\u201d.\n    '''\n\n    # Write your code below this comment\n    return"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = []\n    for _ in range(n):\n        names.append(stdin.replace(\"\\n\", \"\"))\n    names.sort(key=lambda x: x.split(\" \")[0])\n    for name in names:\n        if name.split(\" \")[0] == \"Thore\":\n            if name.split(\" \")[-1] == \"Husfeldt\":\n                return \"Thore is awesome\"\n        elif name.split(\" \")[0] == \"ThoreHusfeldt\":\n            if name.split(\" \")[-1]!= \"Husfeldt\":\n                return \"Thore sucks\"\n\n    return \"Thore is awesome\"\n\n\ndef"
    },
    {
        "number": 3055,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    if stdin == 'ThoreHusfeldt':\n        return 'Thore is awesome'\n    lines = stdin.splitlines()\n    n = int(lines.pop(0))\n    names = set()\n    best = ''\n    worst = ''\n    while len(lines) > 0:\n        line = lines.pop(0)\n        if line not in names:\n            names.add(line)\n            if line.startswith('Thore'):\n                worst = line\n            else:\n                best = line\n    if best == worst:\n        return 'Thore sucks'\n    else:\n        prefixes = [x.split()[0] for x in names]\n        prefixes.sort()\n        prefixes.reverse()\n        for prefix in prefixes:\n            if prefix == worst or prefix == best:\n                continue\n            if prefix in names:\n                return prefix"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_all_walks(num_nodes: int, pattern: str) -> str:\n        if num_nodes == 0:\n            return pattern\n        elif num_nodes == 1:\n            return pattern + \"LL\"\n        else:\n            return pattern + \"LR\" + get_all_walks(num_nodes - 1, pattern + \"L\") + get_all_walks(num_nodes - 1, pattern + \"R\")\n\n    walks = get_all_walks(len(stdin), \"\")\n    print(walks)\n    return walks.count(\"LLR\") + walks.count(\"LRR\") + walks.count(\"LPR\") + walks.count(\"RPR\") + walks.count(\"RRR\")\n\nprint(solution(\"P*P\"))\nprint(solution(\"L*R\"))\nprint(solution(\"**\"))\nprint(solution(\"\"))\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    a = stdin.split('\\n')\n    b = []\n    for i in range(len(a)):\n        if a[i] == '*':\n            a[i] = 3\n        else:\n            a[i] = int(a[i])\n        b.append(a[i])\n    x = 0\n    n = len(b)\n    ans = 0\n    while x < n:\n        if b[x] == 3:\n            ans += (b[x + 1] * 2) + (b[x + 2])\n            x += 3\n        elif b[x] == 1:\n            ans += (b[x + 1] * 2)\n            x += 2\n        else:\n            ans += (b[x + 1])\n            x += 1\n    return ans"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    set = {stdin}\n    while True:\n        new = set.copy()\n        for walk in set:\n            if walk[0] == 'L' and walk[-1] == 'R':\n                new.add(walk[1:-1]+'P')\n                new.add(walk[1:-1]+'*')\n            if walk[0] == 'R' and walk[-1] == 'L':\n                new.add(walk[1:-1]+'P')\n                new.add(walk[1:-1]+'*')\n            if walk[0] == 'L' and walk[-1] == 'R':\n                new.add(walk[1:-1]+'P')\n                new.add(walk[1:-1]+'*')\n            if walk[0] == 'R' and walk[-1] == 'L':\n                new.add(walk[1:-1]+'P')\n                new.add(walk[1:-1]+'*')\n        if not new:\n            break\n        set = new\n    return str(len(set))"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    queue = deque()\n    queue.append((1, 0, 'L'))\n    queue.append((2, 0, 'R'))\n    queue.append((3, 0, 'P'))\n    queue.append((4, 0, '*'))\n    while len(queue) > 0:\n        node, step, move = queue.popleft()\n        if move == '*':\n            if node == 1:\n                queue.append((2 * node, step + 1, 'R'))\n                queue.append((2 * node + 1, step + 1, 'L'))\n            else:\n                queue.append((2 * node - 1, step + 1, 'R'))\n                queue.append((2 * node, step + 1, 'L'))\n        else:\n            if move == 'L':\n                queue.append((node - 1, step + 1, 'R'))\n            elif move == 'R':\n                queue.append((node + 1, step + 1, 'L'))\n            else:\n                queue.append((node, step + 1, 'P'))\n    return str(step)\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    str = stdin\n    str = str.replace('*', '2')\n    str = str.replace('L', '1')\n    str = str.replace('R', '2')\n    return str\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdout\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return sum([int(i[2]) for i in stdin.split()])\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(sum(int(i) for i in stdin.split('*')))\n"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    first, second = stdin.split()\n    count = 0\n    if '*' in second:\n        count += 1\n    if '*' in first:\n        count += 1\n    if count == 2:\n        return 'Invalid'\n    elif count == 0:\n        return first\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second\n    elif count == 1:\n        return second"
    },
    {
        "number": 3056,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return 0\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = [line.rstrip() for line in stdin.splitlines()]\n    consistent = True\n    for i in range(len(words) - 1):\n        if words[i] == words[i + 1]:\n            consistent = False\n            break\n    if consistent:\n        return \"yes\"\n    if not consistent:\n        return \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return \"yes\" if n == len(set(stdin.split())) else \"wait what\"\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For this problem, the time limit has been reduced, hence a much shorter solution using stack and if statements is given.\n    \"\"\"\n    stdin = stdin.splitlines()\n    stmt = []\n    for i in stdin:\n        stmt.append(i.split())\n    print(stmt)\n    # stack = []\n    # stack_stmt = []\n    # for i in stmt:\n    #     stack.append(i)\n    #     if len(stack) >= 3:\n    #         if'and'in stack:\n    #             stack_stmt.append(stack.pop())\n    #             stack_stmt.append(stack.pop())\n    #             stack_stmt.append(stack.pop())\n    #             stack_stmt.append(stack.pop())\n    #             stack.append(stack_stmt)\n    #             stack_stmt = []\n    # print(stack)\n    # print(stmt)\n    ans = \"\"\n    for i in stmt:\n        # print(i)\n        if'and'in i:\n            if ''.join(i[:2]) in i and ''.join(i[-2:]) in i:\n                ans = \"yes\"\n            else:\n                ans = \"wait what?\"\n            break\n        else:\n            if ''.join(i[:2]) in i and ''.join(i[-2:]) in i:\n                ans = \"yes\"\n            else:\n                ans = \"wait what?\"\n    return ans\n\nprint(solution(input()))\n\n\n\n\"\"\"\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    dict_rhyme = {}\n    for stmt in stdin.splitlines():\n        name = stmt.split()[0]\n        name_last_char = name[-1]\n        if name_last_char in dict_rhyme:\n            dict_rhyme[name_last_char].append(name)\n        else:\n            dict_rhyme[name_last_char] = [name]\n\n    for stmt in stdin.splitlines():\n        name = stmt.split()[0]\n        name_last_char = name[-1]\n        if name_last_char in dict_rhyme:\n            for rhyme in dict_rhyme[name_last_char]:\n                if rhyme in stmt.split()[1]:\n                    print('yes')\n                    return 'yes'\n    print('wait what?')\n    return 'wait what?'\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return \"yes\"\n    elif N == 1:\n        return \"wait what?\"\n    else:\n        stdin = stdin.strip().splitlines()\n        result = \"yes\"\n        for _ in range(N):\n            a, b = stdin.pop(0).split(\"is\")\n            if len(a) < 3:\n                a += \"*\"\n            if len(b) < 3:\n                b += \"*\"\n            if a == b:\n                result = \"wait what?\"\n        return result\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    # data = sys.stdin.read().split(\"\\n\")\n    # data = stdin.split(\"\\n\")\n    # data = data.split(\"\\n\")\n    for idx, line in enumerate(data):\n        if line == \"\":\n            data.pop(idx)\n        data[idx] = line.split(\" \")\n        for idx, word in enumerate(data[idx]):\n            if len(word) < 1:\n                data[idx].pop(idx)\n                data[idx].append(\"\")\n        if len(data[idx]) < 2:\n            data.pop(idx)\n    if len(data) < 2:\n        return \"yes\"\n    if len(data) == 1:\n        return \"yes\"\n    for idx in range(len(data)-2):\n        print(data)\n        if data[idx][-1] == data[idx+1][-1] and data[idx][-1] == data[idx+2][-1]:\n            data[idx][-1] = data[idx][-1].lower()\n            data[idx+1][-1] = data[idx+1][-1].lower()\n            data[idx+2][-1] = data[idx+2][-1].lower()\n            for idx, word in enumerate(data[idx]):\n                if len(word) < 1:\n                    data[idx].pop(idx)\n                    data[idx].append(\"\")\n            for idx, word in enumerate(data[idx+1]):\n                if len(word) < 1:\n                    data[idx+1].pop(idx)\n                    data[idx+1].append(\"\")\n            for idx, word in enumerate(data[idx+2]):\n                if len(word) < 1:\n                    data[idx+2].pop(idx)\n                    data[idx+2].append(\"\")\n            if len(data[idx]) == 1 and len(data[idx+1]) == 1 and len(data[idx+2]) == 1:\n                return \"yes\"\n    return \"wait what?\"\n\nstdin = \"\"\"2\noskar not lukas\noskar is poptart\nlukas is smart\"\"\".strip(\"\\n\")\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def check(x):\n        for i in range(1, min(len(x), 3)):\n            if x[-i:] == x[-i-1:]:\n                return True\n        return False\n\n    ans = 'yes'\n    for line in stdin.splitlines():\n        line = line.strip()\n        if line[0] == line[-1]:\n            ans = 'wait what?'\n        elif line.count('$') == 1:\n            line = line.split('$')\n            if not check(line[0]) and not check(line[1]):\n                ans = 'wait what?'\n    return ans\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"yes\" if consistent(stdin) else \"wait what?\"\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    list_of_statements = stdin.strip().splitlines()\n    if len(list_of_statements) < 2:\n        return \"wait what?\"\n    for statement in list_of_statements:\n        if len(statement) < 3:\n            continue\n        if statement[0]!= \"is\":\n            continue\n        if statement[-1]!= \":\":\n            continue\n        if (len(statement[1:-1]) >= 3 and statement[1] == \"a\" and statement[2] == \"b\"):\n            return \"yes\"\n    return \"wait what?\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your solution goes here\n    \"\"\"\n\n    i = 0\n    s = stdin.split('\\n')\n    s.pop()\n    s = s[:1000]\n\n    for elem in s:\n        a, b = elem.split()\n        if a == b:\n            continue\n        else:\n            i += 1\n        if i > 0:\n            return 'wait what?'\n    if i == 0:\n        return 'yes'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin[: stdin.index(\"\\n\") + 1]"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    species = stdin\n    while species!= \"impossible\":\n        species = stdin.split('\\n')\n        for index in range(0, len(species)):\n            species[index] = species[index].replace(species[index][0], 'A')\n            species[index] = species[index].replace(species[index][-1], 'A')\n            species[index] = species[index].replace(species[index][0], 'C')\n            species[index] = species[index].replace(species[index][-1], 'C')\n            species[index] = species[index].replace(species[index][0], 'M')\n            species[index] = species[index].replace(species[index][-1], 'M')\n        print(species)\n    return species\nprint(solution(stdin))\n\nclass NucleotideSequence:\n    def __init__(self, sequence):\n        self.sequence = sequence\n        self.dict = {}\n\n    def __str__(self):\n        return str(self.sequence)\n    \n    def get_count(self, nucleotide):\n        return self.dict[nucleotide]\n\n    def increment_count(self, nucleotide):\n        if nucleotide in self.dict.keys():\n            self.dict[nucleotide] += 1\n        else:\n            self.dict[nucleotide] = 1\n\nclass Partition:\n    def __init__(self, num_strings, num_patterns, num_alphabets):\n        self.num_strings = num_strings\n        self.num_patterns = num_patterns\n        self.num_alphabets = num_alphabets\n        self.strings = []\n        for i in range(0, num_strings):\n            self.strings.append(NucleotideSequence(''))\n        self.patterns = []\n        for i in range(0, num_patterns):\n            self.patterns.append(NucleotideSequence(''))\n        self.alphabets = []\n        for i in range(0, num_alphabets):\n            self.alphabets.append(NucleotideSequence(''))\n    \n    def add_string(self, string):\n        string = string.replace('\\n', '')\n        string = string.replace(' ', '')\n        self.strings[len(self.strings) - 1].sequence = string\n        \n    def add_pattern(self, pattern):\n        pattern = pattern.replace('\\n', '')\n        pattern = pattern.replace(' ', '')\n        self.patterns[len(self.patterns) - 1].sequence = pattern\n    \n    def add_alphabet(self, alphabet):\n        alphabet = alphabet.replace('\\n', '')\n        alphabet = alphabet.replace(' ', '')\n        self.alphabets[len(self.alphabets) - 1].sequence = alphabet\n\n    def get_num_strings(self):\n        return self.num_strings\n\n    def get_num_patterns(self):\n        return self.num_patterns\n\n    def get_num_alphabets(self):\n        return self.num_alphabets\n\n    def get_strings(self):\n        return self.strings\n    \n    def get_patterns(self):\n        return self.patterns\n    \n    def get_alphabets(self):\n        return self.alphabets\n    \n    def print(self):\n        for i in range(0, self.num_strings):\n            print('String: {}'.format(self.strings[i]))\n        for i in range(0, self.num_patterns):\n            print('Pattern: {}'.format(self.patterns[i]))\n        for i in range(0, self.num_alphabets):\n            print('Alphabet: {}'.format(self.alphabets[i]))\n    \nclass NucleotidePatternMatching:\n    def __init__(self, num_strings, num_patterns, num_alphabets):\n        self.partition = Partition(num_strings, num_patterns, num_alphabets)\n    \n    def add_string(self, string):\n        self.partition.add_string(string)\n    \n    def add_pattern(self, pattern):\n        self.partition.add_pattern(pattern)\n    \n    def add_alphabet(self, alphabet):\n        self.partition.add_alphabet(alphabet)\n\n    def get_num_strings(self):\n        return self.partition.get_num_strings()\n    \n    def get_num_patterns(self):\n        return self.partition.get_num_patterns()\n    \n    def get_num_alphabets(self):\n        return self.partition.get_num_alphabets()\n    \n    def get_strings(self):\n        return self.partition.get_strings()\n    \n    def get_patterns(self):\n        return self.partition.get_patterns()\n    \n    def get_alphabets(self):\n        return self.partition.get_alphabets()\n    \n    def print(self):\n        self.partition.print()\n        \ndef"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    first_seq: str = stdin.split()[1]\n    next_seqs: List[str] = stdin.split()[2:]\n    next_seqs.sort(key=lambda x: x[0])\n    next_seqs.sort(key=lambda x: x[1])\n    return f'{len(next_seqs)}\\n' \\\n           f'{first_seq}\\n' + '\\n'.join([\n                f'{i[0]} {i[1]}' for i in next_seqs\n            ])\n\n\nprint(solution(input()))\n\nSample Input 4:\n5\nAAACAA\nAACAA\nAAA\nA\nSample Output 4:\n2 4\nAAACAA\nAACAA\nA\nA\nSample Input 5:\n1\nAC\nSample Output 5:\nimpossible\n'''\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5\n   ... AACCMMAA\n   ... ACA\n   ... MM\n   ... ACMAA\n   ... AA\n   ... A\n   ... Sample Output 1:\n   ... 1 4\n   ... MM\n   ... A\n   ... AA\n   ... ACA\n   ... ACMAA\n   ... ''')\n    '1 4\\nMM\\nA\\nAA\\nACA\\nACMAA\\n'\n    >>> solution('''2\n   ... A\n   ... A\n   ... Sample Output 2:\n   ... impossible\n   ... impossible\n   ... ''')\n    'impossible\\nimpossible\\n'\n    >>> solution('''1\n   ... A\n   ... Sample Output 3:\n   ... impossible\n   ... ''')\n    'impossible\\n'\n    \"\"\"\n    n = int(stdin)\n    a = stdin.split()\n    n1, n2 = 0, 0\n    for i in range(n):\n        if 'A' in a[i] and 'C' in a[i] and 'M' in a[i]:\n            n1 += 1\n        if 'A' in a[i] and 'C' in a[i] and 'M' not in a[i]:\n            n2 += 1\n    if n1 == n2:\n        return '1'+ str(n1) +'' + str(n2)\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = stdin.splitlines()\n    a = list(map(str, a))\n    b = a[0]\n    c = a[1]\n    if len(b)!= len(c) or len(c) == 0:\n        return 'impossible'\n    res = []\n    for i in range(len(b)):\n        if b[i]!= c[i]:\n            res.append(i)\n            res.append(len(b))\n    return''.join(map(str, res))"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    n = int(stdin)\n    seqs = stdin.split(\"\\n\")\n    for seq in seqs:\n        seq = seq.strip()\n        if len(seq) > 4000:\n            continue\n        res = seq.upper()\n        if res in seqs:\n            print(seq, \",\", seqs.index(res))\n            return"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, seq1 = stdin.splitlines()\n    n = int(n)\n    seq1 = seq1.strip()\n    seq2 = \"\".join(sorted(set(seq1)))\n    seq2 = \"\".join(sorted(set(seq2)))\n    seq2 = \"\".join(sorted(set(seq2)))\n    seq2 = \"\".join(sorted(set(seq2)))\n    seq2 = \"\".join(sorted(set(seq2)))\n    if seq1 == seq2:\n        return \"impossible\"\n    return f\"{n} {seq1} {seq2}\""
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    seq = stdin.splitlines()\n    # print(seq)\n    s1 = seq[0]\n    s2 = seq[1]\n    s1s2 = set(s1) | set(s2)\n    s1s2 = list(s1s2)\n    s1s2.sort()\n    # print(s1s2)\n    return f'{len(s1s2)} {len(s1s2)}'"
    },
    {
        "number": 3058,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, species = stdin.splitlines()\n    assert 1 <= int(n) <= 4000\n    species = species.strip()\n    # First test\n    if len(species)!= len(set(species)):\n        return 'impossible'\n    # Second test\n    if (len(species) == len(set(species)) == len(species)):\n        return 'impossible'\n    # Third test\n    result = []\n    for index in range(len(species)):\n        if species[index] in 'AAC':\n            result.append(species[index])\n    if len(result) == 2:\n        return '{} {}'.format(len(result), ''.join(sorted(result)))\n    return 'impossible'\nprint(solution(input()))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = list(map(int, stdin.split()))\n    trick_success_prob = list(map(float, stdin.split()))\n    trick_fail_prob = list(map(float, stdin.split()))\n    trick_fail_prob_len = len(trick_fail_prob)\n\n    trick_fail_prob_sum = [0 for _ in range(trick_fail_prob_len)]\n    trick_fail_prob_sum[0] = trick_fail_prob[0]\n    for i in range(1, trick_fail_prob_len):\n        trick_fail_prob_sum[i] = trick_fail_prob[i] + trick_fail_prob_sum[i-1]\n\n    min_time = n\n    curr_time = n\n    total_time = 0\n    max_time = 0\n    while curr_time <= r:\n        trick_time = curr_time + (m - curr_time) * trick_fail_prob_sum[trick_fail_prob_len-1]\n        if trick_time > r:\n            curr_time = r\n        else:\n            curr_time = trick_time\n        total_time += curr_time\n        if total_time > max_time:\n            max_time = total_time\n    return str(max_time)\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = sorted(list(map(lambda x: (x[0], x[1], x[2]), map(int, stdin.split()))))\n    best = r\n    for t, p, d in tricks:\n        p = 0 if p == 1 else 1 - p\n        if t > n:\n            continue\n        t = min(r, t)\n        if t > r:\n            break\n        if best < t:\n            best = t\n    return str(best)"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = list(map(int, stdin.split()))\n    tricks = []\n    for _ in range(m):\n        t, p, d = list(map(int, input().split()))\n        tricks.append((t, p, d))\n    tricks = sorted(tricks, key=lambda x: x[0])\n    total_success = 0\n    total_failure = 0\n    total_time = 0\n    for t, p, d in tricks:\n        if t > r:\n            break\n        total_success += p\n        total_failure += 1 - p\n        total_time += t + d\n    print(total_time)\n    return total_success > total_failure\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    # $2 \\le n < r$\n    # $1 \\le m \\le 50$\n    # n \\le m \\le 5000\n    n, r, m = map(int, lines[0].split())\n    m = int(m)\n    # $2 \\le t, p, d \\le n$\n    # $1 \\le t < n$\n    # $0 < p < 1$\n    # $1 \\le d < 1000$\n    trick = {}\n    for i in range(m):\n        t, p, d = map(float, lines[i + 1].split())\n        t = int(t)\n        if (t not in trick):\n            trick[t] = {'p': p, 'd': d}\n        else:\n            if (trick[t]['p'] > p):\n                trick[t]['p'] = p\n                trick[t]['d'] = d\n    # print(trick)\n    # print(n,r,m)\n    # print(trick.keys())\n    trick = sorted(trick.keys())\n    # print(trick)\n    # print(trick[0], trick[1])\n    # print(trick)\n    # print(trick[0], trick[1])\n    # print(trick)\n    # print(trick[0], trick[1])\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print(trick)\n    # print"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = sorted(map(int, stdin.split()))\n    tricks.reverse()\n    if m == 0:\n        return str(r)\n    n_mins = n\n    r_mins = r\n    for t in tricks:\n        if n_mins < r_mins:\n            r_mins = n_mins\n            break\n        if n_mins < r_mins + t:\n            r_mins += t\n    return str(r_mins)"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    _, d = map(float, stdin.split())\n    tricks = sorted([int(x) for x in stdin.split()])\n    for i in range(m):\n        t, p, d = map(float, stdin.split())\n        if t in tricks:\n            print(float(t) * p / d)\n    return float('inf')\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.strip().split())\n    tricks = sorted([[int(i), float(j), int(k)] for i, j, k in map(str.strip, stdin.splitlines()[1:])])\n    res = 0\n    used = 0\n    for i, j, k in tricks:\n        if used > r:\n            break\n        if j * 100 < k:\n            used += i\n            res = max(res, i + k)\n        else:\n            used += k\n    return f\"{res:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = {}\n    ticks = {}\n    for i in range(m):\n        t, p, d = map(float, stdin.split())\n        ticks[t] = d\n        if t not in tricks:\n            tricks[t] = 0\n        tricks[t] += 1\n    curr = r\n    opt = r\n    for t in sorted(tricks.keys()):\n        curr += ticks[t]\n        if curr > r:\n            return str(opt)\n        opt = max(opt, t*(1-p) + ticks[t]*(p))\n    return str(opt)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    trick = list()\n    for _ in range(m):\n        t, p, d = map(float, stdin.split())\n        trick.append((t, p, d))\n    trick.sort()\n    trick = list(set(trick))\n    trick.sort(key=lambda x: x[0])\n    print(sum([t[0] for t in trick]) + len(trick) * (r - n))\n    return '%.6f' % (sum([t[0] for t in trick]) + len(trick) * (r - n))\n"
    },
    {
        "number": 3059,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = stdin.split(' ')\n    n, r, m = int(n), int(r), int(m)\n\n    r_ = float(r)\n    m_ = float(m)\n    if n == r:\n        return str(r_)\n\n    tricks_ = []\n    for _ in range(m):\n        t_, p_, d_ = stdin.split(' ')\n        t_ = int(t_)\n        p_ = float(p_)\n        d_ = int(d_)\n        tricks_.append((t_, p_, d_))\n\n    tricks = sorted(tricks_, key=lambda t: t[0])\n    tricks = sorted(tricks, key=lambda t: t[2])\n\n    for i in range(m):\n        if tricks[i][1] <= m_:\n            continue\n        return str(r_ + (tricks[i][0] - n) * m_)\n\n    return str(r_ + (max(0, n - r) * m_))\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    seq = []\n    for i in range(1, n):\n        seq.append(i)\n    for i in range(k):\n        seq.append(n)\n        seq.sort()\n    return str(seq[k - 1])"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given an integer n, return the nth element of a sequence of 2n+1 integers in lexicographical order\n    \"\"\"\n    n = int(stdin.strip())\n    if n == 2:\n        return '1 2'\n    if n == 1:\n        return '1'\n    if n == 3:\n        return '2 1 2'\n    seq = [0] * (2 * n + 1)\n    start = 2 * n\n    end = 2 * n + 1\n    for i in range(start, end):\n        seq[i] = i + 1\n    seq =''.join(map(str, seq))\n    return seq\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    for i in range(k+1):\n        if (i+1)*(n-1) % (i+1) == 0 and i!= 0:\n            return str(i)+\" \"+str(i+1)\n    else:\n        return \"0 0\"\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    flower_dict = {i+1: i for i in range(n)}\n    result = []\n    for i in range(1, n):\n        first_valid = flower_dict.get(i-1)\n        second_valid = flower_dict.get(i)\n        third_valid = flower_dict.get(i+1)\n        if (first_valid+1!= second_valid and first_valid+2!= second_valid and first_valid+3!= second_valid and\n            first_valid+4!= second_valid and first_valid+5!= second_valid and first_valid+6!= second_valid and\n            first_valid+7!= second_valid and first_valid+8!= second_valid and first_valid+9!= second_valid and\n            first_valid+10!= second_valid and first_valid+11!= second_valid and first_valid+12!= second_valid):\n            result.append(first_valid+1)\n            result.append(second_valid+1)\n        else:\n            result.append(first_valid+2)\n    return''.join(map(str, result))\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    n_in_order = [x for x in range(1, n + 1)]\n    n_in_order.sort()\n    result = []\n    count = 1\n    for i in range(1, n + 1):\n        if i!= n_in_order[i - 1]:\n            result.append(str(count))\n            result.append(str(n_in_order[i - 1]))\n            count = 1\n        else:\n            count += 1\n    return''.join(result[:k])\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    results = [(x, x - 1) for x in range(1, n + 1)]\n    for x in range(1, n):\n        if x % 2 == 0:\n            results.remove((x, x + 1))\n        else:\n            results.remove((x + 1, x))\n    results.sort()\n    return''.join(str(x) for x in results[k - 1])"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    if n == 1:\n        return '1'\n    # n = 3, k = 5\n    # 1 2 1\n    # 1 3 1\n    # 1 4 1\n    # 1 5 1\n    # 2 1 2\n    # 2 2 1\n    # 2 3 1\n    # 2 4 1\n    # 2 5 1\n    # 3 1 2\n    # 3 2 1\n    # 3 4 1\n    # 3 5 1\n    # 4 1 2\n    # 4 2 1\n    # 4 3 1\n    # 4 5 1\n    # 5 1 2\n    # 5 2 1\n    # 5 3 1\n    # 5 4 1\n    a = range(n - 1)\n    b = list(range(k, n))\n    while len(b) > 0:\n        p = []\n        for i in range(k):\n            p.append(b[0])\n            del b[0]\n        for i in range(k):\n            p.append(a[0])\n            del a[0]\n        b = list(set(b + p))\n    return''.join(map(str, p))\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    flower_list = list(range(1, n+1))\n    res = \"\"\n    for _ in range(k):\n        tmp = flower_list.pop(0)\n        res += str(tmp) + \" \"\n    return res[:-1]\nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return str(1)\n    p_i = 2\n    a = n-1\n    while a > 0:\n        a = int(a / p_i)\n        p_i += 1\n    a = k - 1\n    while a >= 1:\n        a -= 1\n        b = (n-1) - a\n        print(f\"{a} {b} {p_i-1}\")\n    return str(p_i-1)\n"
    },
    {
        "number": 3060,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    (n, k) = map(int, stdin.split())\n    flower_list = []\n    \n    # # 1st try\n    # for i in range(n):\n    #     flower_list.append(i+1)\n    #     if i == 0:\n    #         flower_list = flower_list[:-1]\n    #         flower_list.append(flower_list[-1]*(n-1))\n    #     else:\n    #         flower_list = flower_list[:-1]\n    #         flower_list.append(flower_list[-1]*(n-i-1))\n\n    # 2nd try\n    flower_list = list(range(n))\n    flower_list = flower_list[:-1]\n    flower_list.append(flower_list[-1]*(n-1))\n    flower_list = flower_list[:-1]\n    flower_list.append(flower_list[-1]*(n-2))\n    flower_list.sort()\n    return''.join([str(flower_list[k-1]) for k in range(1, k+1)])\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stations, roads = map(int, stdin.split())\n    stations = set(range(stations + 1))\n    roads = set(map(tuple, stdin.split()))\n\n    def find_path(stations, roads):\n        min_path = float('inf')\n        ans_path = []\n        while stations:\n            min_road = float('inf')\n            ans_path.clear()\n            for road in roads:\n                if road[1] in stations:\n                    if road[0] < min_road:\n                        min_road = road[0]\n                        ans_path = road\n            ans_path.append(stations.pop())\n            min_path = min(min_path, len(ans_path))\n        return min_path\n\n    return str(find_path(stations, roads))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    num_stations, num_roads = list(map(int, stdin.split()))\n\n    if num_stations == 1 or num_roads == 1:\n        return str(1)\n    station_to_roads = defaultdict(list)\n    for road in map(int, stdin.split()):\n        station_to_roads[road[0]].append(road[1])\n        station_to_roads[road[1]].append(road[0])\n\n    max_roads = max(num_stations * (num_stations - 1) // 2, num_stations)\n\n    def find_path_length(cur_station, road, path):\n        cur_station = road[1] if cur_station == road[0] else road[0]\n        if cur_station == num_stations:\n            return path[-1]\n        path_len = len(path)\n        for next_station in station_to_roads[cur_station]:\n            if next_station in path:\n                continue\n            if len(station_to_roads[next_station]) > path_len:\n                path_len = len(station_to_roads[next_station])\n            new_path = path + [next_station]\n            find_path_length(next_station, road, new_path)\n        return path_len\n\n    min_path_len = find_path_length(1, (1, 2), [])\n    for num_stations in range(2, num_stations + 1):\n        for i in range(1, num_stations - 1):\n            road_to_block = (i, num_stations - 1)\n            if road_to_block in station_to_roads:\n                if len(station_to_roads[road_to_block]) > num_stations - 1:\n                    min_path_len = min(min_path_len, find_path_length(i, (i, num_stations - 1), []) + find_path_length(num_stations - 1, (num_stations - 1, num_stations), []))\n            if i > 1:\n                road_to_block = (1, i - 1)\n                if road_to_block in station_to_roads:\n                    if len(station_to_roads[road_to_block]) > i - 1:\n                        min_path_len = min(min_path_len, find_path_length(i, (i, i - 1), []) + find_path_length(i - 1, (i - 1, i), []))\n        if min_path_len == 0:\n            return str(0)\n    return str(min_path_len)\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    n, m = input[0], input[1]\n\n    def get_max(n):\n        max = 0\n        for i in range(1, n + 1):\n            temp = n - i\n            if temp >= 0:\n                max = max if max > temp else temp\n        return max\n\n    def swap(a, b):\n        a, b = b, a\n\n    def get_min(n, m):\n        if m == 1:\n            return 1\n        if n == 1:\n            return n\n        ans = n\n        for i in range(1, m):\n            ans = min(ans, get_max(n - i))\n        return ans\n\n    def get_result(a, b):\n        if a > b:\n            return b\n        else:\n            return a\n\n    def is_blocked(a, b, m):\n        for i in range(1, m):\n            if a + i == b:\n                return True\n        return False\n\n    if n == 1:\n        return \"1\"\n    if m == 1:\n        return \"1\"\n    if m == 2:\n        return \"1\"\n\n    n_is_odd = n & 1\n    m_is_odd = m & 1\n    n_is_even = n & 0x2\n\n    if n_is_odd:\n        n_is_odd = 0\n    if m_is_odd:\n        m_is_odd = 0\n    if n_is_even:\n        n_is_even = 1\n\n    if n_is_odd and m_is_odd:\n        if m > n:\n            return 0\n        else:\n            return \"1\"\n    if n_is_odd and m_is_even:\n        if n % 2 == 1:\n            return \"1\"\n        else:\n            return \"1\"\n    if n_is_even and m_is_odd:\n        if m > n:\n            return 0\n        else:\n            return \"1\"\n\n    if n_is_even and m_is_even:\n        if m > n:\n            return 0\n        else:\n            return \"1\"\n\n    n = n + 1\n    m = m + 1\n\n    n_even = n / 2\n    n_odd = n - n_even\n    m_even = m / 2\n    m_odd = m - m_even\n\n    ans = get_min(n_even, m_odd) + get_min(n_odd, m_even) + get_min(n_odd, m_odd) + get_min(n_even, m_odd)\n\n    n_even = (n / 2) + 1\n    n_odd = (n / 2) - 1\n    m_even = (m / 2) + 1\n    m_odd = (m / 2) - 1\n\n    ans = get_result(ans, get_min(n_even, m_odd) + get_min(n_odd, m_even) + get_min(n_odd, m_odd) + get_min(n_even, m_odd))\n\n    if is_blocked(1, 2, n):\n        return \"1\"\n    if is_blocked(1, 3, n):\n        return \"1\"\n    if is_blocked(1, 4, n):\n        return \"1\"\n    if is_blocked(2, 4, n):\n        return \"1\"\n    if is_blocked(2, 3, n):\n        return \"1\"\n\n    if ans == 1:\n        return \"1\"\n    else:\n        return str(ans)\n\n\n\nprint(solution(input))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes stdin and prints the minimal length of path\n    that can be taken if at most one road is blocked\n    \"\"\"\n    _, n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n\n    # map of all roads\n    roads = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        roads[u].append(v)\n        roads[v].append(u)\n\n    # The set of all paths\n    # of maximum length that are possible.\n    paths = set()\n\n    # To store all possible paths of maximum length\n    # that are possible.\n    path = (0,)\n    paths.add(path)\n\n    # To store all paths of maximum length\n    # that are possible after the blocked road.\n    # This is the key difference between this\n    # problem and other two problems in this\n    # problem set.\n    blocked_path = (0,)\n    paths.add(blocked_path)\n\n    # A dictionary to store all paths of maximum length\n    # that are possible. It is a cache to increase the performance\n    # and decrease the time complexity.\n    cache = {}\n\n    # To store all paths of maximum length\n    # that are possible after the blocked road.\n    # This is the key difference between this\n    # problem and other two problems in this\n    # problem set.\n    cache_blocked_path = {}\n\n    # Count of paths with length 2\n    count_2 = 0\n\n    # Count of paths with length 3\n    count_3 = 0\n\n    # Count of paths with length 4\n    count_4 = 0\n\n    # Start with the first road\n    # (station 1)\n    # and find all the paths\n    # starting with station 2.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 2\n    # and station 3.\n    # If there is, then go to station 3\n    # and find all the paths\n    # starting with station 4.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 4\n    # and station 5.\n    # If there is, then go to station 5\n    # and find all the paths\n    # starting with station 6.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 6\n    # and station 7.\n    # If there is, then go to station 7\n    # and find all the paths\n    # starting with station 8.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 8\n    # and station 9.\n    # If there is, then go to station 9\n    # and find all the paths\n    # starting with station 10.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 10\n    # and station 11.\n    # If there is, then go to station 11\n    # and find all the paths\n    # starting with station 12.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 12\n    # and station 13.\n    # If there is, then go to station 13\n    # and find all the paths\n    # starting with station 14.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 14\n    # and station 15.\n    # If there is, then go to station 15\n    # and find all the paths\n    # starting with station 16.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 16\n    # and station 17.\n    # If there is, then go to station 17\n    # and find all the paths\n    # starting with station 18.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 18\n    # and station 19.\n    # If there is, then go to station 19\n    # and find all the paths\n    # starting with station 20.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 20\n    # and station 21.\n    # If there is, then go to station 21\n    # and find all the paths\n    # starting with station 22.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 22\n    # and station 23.\n    # If there is, then go to station 23\n    # and find all the paths\n    # starting with station 24.\n    # Then for each path,\n    # check if there is a road\n    # blocked in between station 24\n    # and station 25.\n    # If there is, then go to station 25\n    # and find"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def neighbours(station):\n        for (up, down) in ((station - 1, station), (station + 1, station)):\n            if 0 <= up < n and not visited[up]:\n                yield up\n            if 0 <= down < n and not visited[down]:\n                yield down\n        yield station\n\n    n, m = list(map(int, stdin.split()))\n    stations = [[i for i in map(int, stdin.split())] for _ in range(m)]\n    visited = [0 for _ in range(n)]\n    visited[0] = 1\n    ans = float('inf')\n\n    def dfs(path, time):\n        nonlocal ans\n        if time >= ans:\n            return\n        if len(path) == m:\n            ans = min(ans, time)\n            return\n        for station in neighbours(path[-1]):\n            if visited[station]:\n                continue\n            visited[station] = 1\n            dfs(path + [station], time + 1)\n            visited[station] = 0\n\n    for station in range(1, n):\n        dfs([station], 1)\n\n    return str(ans)\n\n\nstdin = \"4 4\"\nprint(solution(stdin))\nstdin = \"7 6\"\nprint(solution(stdin))\nstdin = \"7 5\"\nprint(solution(stdin))\nstdin = \"6 5\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n    stations = []\n    for i in range(n):\n        stations.append(i + 1)\n\n    roads = []\n    for i in range(m):\n        roads.append(list(map(int, stdin.strip().split())))\n\n    # adj = [[0] * n for _ in range(n)]\n    # for x, y in roads:\n    #     adj[x - 1][y - 1] = 1\n    #     adj[y - 1][x - 1] = 1\n\n    # dijk = [[0] * n for _ in range(n)]\n    # for i in range(n):\n    #     for j in range(i):\n    #         if adj[i][j] == 1:\n    #             dijk[i][j] = dijk[j][i] = 1\n\n    # heap = []\n    # for i in range(n):\n    #     heappush(heap, (0, i + 1))\n    #     dijk[i][i] = dijk[i][i] = 0\n    # while len(heap) > 1:\n    #     a, a_dist = heappop(heap)\n    #     b, b_dist = heappop(heap)\n    #     if a_dist + dijk[a][b] < dijk[a][b]:\n    #         a_dist += dijk[a][b]\n    #         heappush(heap, (a_dist, a))\n    #     if b_dist + dijk[b][a] < dijk[b][a]:\n    #         b_dist += dijk[b][a]\n    #         heappush(heap, (b_dist, b))\n    #     if dijk[a][b] == 1:\n    #         dijk[a][b] = a_dist\n    #         dijk[b][a] = b_dist\n    # return dijk[n - 1][n - 1]\n\n    adj = [[0] * n for _ in range(n)]\n    for x, y in roads:\n        adj[x - 1][y - 1] = 1\n        adj[y - 1][x - 1] = 1\n\n    def dfs(curr, seen, dist):\n        if curr == n - 1:\n            return dist\n        for i in range(n):\n            if adj[curr][i] == 1 and i not in seen:\n                seen.add(i)\n                dist = min(dist, dfs(i, seen, dist + 1))\n                seen.remove(i)\n        return dist\n\n    return str(dfs(0, set(), 0))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = list(map(int, stdin.strip().split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    # print(graph)\n    visited = set()\n    visited.add(1)\n    visited.add(7)\n    max_length = 1\n    best_path = None\n    while len(visited) < n:\n        # print(visited)\n        current_length = 1\n        for vertex in graph:\n            if vertex in visited:\n                continue\n            # print(vertex)\n            current_length += 1\n            # print(current_length)\n            if current_length > max_length:\n                max_length = current_length\n                best_path = vertex\n        visited.add(best_path)\n        graph[best_path] = []\n    # print(visited)\n    return str(max_length)\n\n\nprint(solution('''7 6\n1 2\n2 3\n2 5\n6 3\n7 2\n3 4'''))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n, m = map(int, stdin.split())\n    graph = {}\n    for i in range(m):\n        u, v = map(int, input().split())\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n        if v not in graph:\n            graph[v] = [u]\n        else:\n            graph[v].append(u)\n    visited = {1}\n    path = []\n    min_path_length = float(\"inf\")\n    for i in range(2, n + 1):\n        if i not in graph:\n            path.append(i)\n        else:\n            # print(graph[i])\n            for x in graph[i]:\n                if x not in visited:\n                    visited.add(x)\n                    if min_path_length > len(path):\n                        path = []\n                    path.append(x)\n                    min_path_length = min(min_path_length, len(path))\n                    # print(path)\n                    # print(min_path_length)\n    return str(min_path_length)\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stations = list(map(int, stdin.split()))\n    N, M = stations[0], stations[1]\n    visited = [False] * N\n    blocked = set()\n    min_length = float('inf')\n\n    def _dfs(node: int):\n        nonlocal visited, blocked, min_length\n\n        if node in blocked:\n            return 0\n\n        visited[node] = True\n        for neighbour in range(N):\n            if not visited[neighbour] and neighbour not in blocked:\n                min_length = min(_dfs(neighbour), min_length)\n\n        visited[node] = False\n        blocked.add(node)\n        return 1\n\n    _dfs(0)\n    return str(min_length)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3061,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    stations = []\n    for i in range(1, n + 1):\n        stations.append(i)\n    graph = [[] for _ in range(n)]\n    for line in lines[1:]:\n        u, v = map(int, line.split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    steps = 0\n    path = []\n    while n > len(path):\n        steps += 1\n        for station in stations:\n            if station not in path:\n                break\n        else:\n            continue\n        for graph_station in range(len(graph)):\n            if graph_station in path:\n                continue\n            if graph_station in path[:-1]:\n                continue\n            if graph_station in graph[path[-1]]:\n                continue\n            path.append(graph_station)\n            break\n    return steps\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    (x, y) = [float(x) for x in stdin.split()]\n    return '{:.8f}'.format((x ** 2 + y ** 2) ** 0.5)\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    v = float(stdin.split()[1])\n    w = float(stdin.split()[2])\n    x1, x2 = max(0, x), min(1000, x)\n    y1, y2 = max(0, y), min(1000, y)\n    delta_x = x2 - x1\n    delta_y = y2 - y1\n    v_total_seconds = (delta_x / v)\n    w_total_seconds = (delta_y / w)\n    total_seconds = v_total_seconds + w_total_seconds\n    return str(total_seconds)\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split(\"\\n\")\n    x, y, v, w = int(inp[0]), int(inp[1]), float(inp[2]), float(inp[3])\n    return \"{:.3f}\".format(min(((x-y)/v)+(v*(w/v)),(x+y)/w) - max((x-y)/v,(y-x)/w))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y = list(map(float, stdin.split()))\n    v = float(input())\n    w = float(input())\n    flats = list(map(float, stdin.split()))\n    min_time = (v * (flats[1] - flats[0])) / (1000 * w) + (flats[0] * (v - 0.01)) / (1000 * w)\n    return str(min_time)\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    in_vals = stdin.split()\n    x = int(in_vals[0])\n    y = int(in_vals[1])\n    v = float(in_vals[2])\n    w = float(in_vals[3])\n    \n    def get_speed(v, w):\n        '''\n        Function to return the speed\n        '''\n        return v * w\n    \n    def distance(x, y):\n        '''\n        Function to return the distance\n        '''\n        return (((x ** 2) + (y ** 2)) ** 0.5)\n    \n    def move_forward(x, y, speed, time):\n        '''\n        Function to move vehicle forward\n        '''\n        return x + speed * time\n    \n    def rotate(x, y, speed, time):\n        '''\n        Function to rotate vehicle\n        '''\n        return y + speed * time\n    \n    def min_time(x, y, speed, w, time):\n        '''\n        Function to calculate min time\n        '''\n        distance = distance(x, y)\n        time_forward = get_speed(speed, w) / speed\n        time_rotate = distance / speed\n        time_total = time_forward + time_rotate\n        return time_total\n\n    return '%.3f' % min_time(x, y, v, w, distance(x, y))\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    return str(min(((2 * x + y) / v) / w, (2 * y + x) / v / w))\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    xs, ys = stdin.split()\n    xs, ys = int(xs), int(ys)\n    v, w = map(float, stdin.split())\n    x, y = 0, 0\n    z = 0\n    time = 0\n    while x!= xs or y!= ys:\n        if x > xs:\n            if y > ys:\n                y = y - w\n            else:\n                y = y + w\n            x = x + v\n            time += w\n        else:\n            if y > ys:\n                y = y - w\n            else:\n                y = y + w\n            x = x - v\n            time += w\n    return f\"{time}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = stdin.strip().split()\n    x, y = int(x), int(y)\n    v, w = float(v), float(w)\n    return str(int(min(abs(x - x1), abs(x - x2)) / v + abs(y - y1) / v + abs(y - y2) / v - w / w) * 1000)\n"
    },
    {
        "number": 3062,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    v, w = map(float, stdin.split())\n    v, w = v, w\n    return str(round(2 * v * v * w + 4 * v * w * w + 0.5 * v * v * w * w * w, 3))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    inhabitants = list(map(lambda x: int(x) - 1, stdin.split()))\n\n    return sum(inhabitants)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    N = int(stdin.pop(0))\n    income_debts = {}\n    for _ in range(N):\n        A, B = map(int, stdin.pop(0).split())\n        if A in income_debts:\n            income_debts[A] += B\n        else:\n            income_debts[A] = B\n    return income_debts\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    [N, *payments] = stdin.split()\n    return str(sum(int(N) for N in payments))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    debts = sorted([int(i) for i in stdin.split(\"\\n\")])\n    current_debts = []\n    current_debt = 0\n    for i in range(n):\n        if debts[i] == current_debt:\n            current_debts.append(debts[i])\n        else:\n            current_debts.sort(reverse=True)\n            for j in range(len(current_debts)):\n                current_debts[j] = (current_debts[j] + current_debt) / 2\n                if current_debts[j] == debts[i]:\n                    break\n            current_debt = 0\n            current_debts = []\n    return sum(current_debts)\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    debts = [int(i) for i in stdin.split('\\n')[1:]]\n    debts.sort()\n    current = 0\n    possible = 0\n    while possible < N:\n        for debt in debts:\n            if current + debt <= N:\n                current += debt\n                debts.remove(debt)\n        possible += 1\n    return str(current)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    D = list(map(int, input().split()))\n    E = list(map(int, input().split()))\n    F = list(map(int, input().split()))\n    result = 0\n    for i in range(N):\n        if A[i] == i+1 and B[i] == i+1:\n            result += E[i]\n        elif A[i] == i+1 and B[i]!= i+1:\n            if D[i] <= result:\n                result += F[i]\n            else:\n                result += D[i]\n        elif A[i]!= i+1 and B[i] == i+1:\n            result += F[i]\n    return str(result)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inhabitants, debts = list(map(int, stdin.split()))\n    inhabitants += 2\n    inhabitants += 1\n    inhabitants += 1\n    inhabitants += 1\n    inhabitants = list(range(inhabitants))\n\n    debt_map = {}\n    for i, debt in enumerate(debts):\n        debt_map[i] = debt\n    \n    for _ in range(inhabitants - 1):\n        people_with_debt = []\n        debt_sums = {}\n        for i, person_debts in enumerate(debt_map):\n            person_debts = debt_map[i]\n            if person_debts in debt_sums:\n                debt_sums[person_debts] += 1\n                people_with_debt.append(person_debts)\n            else:\n                debt_sums[person_debts] = 1\n                people_with_debt.append(person_debts)\n\n        # print(people_with_debt)\n        # print(debt_sums)\n        people_with_debt.sort(key=lambda x: x, reverse=True)\n        people_with_debt = people_with_debt[:1]\n\n        # print(people_with_debt)\n\n        for person in people_with_debt:\n            debt_map[person] += 1\n            for i, person_debts in enumerate(debt_map):\n                person_debts = debt_map[i]\n                if person_debts == person:\n                    debt_map[i] = person_debts + 1\n                    break\n    return sum(debt_map.values())\n\nprint(solution(input()))\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # num_inhabitants = int(input())\n    # debts = stdin.strip().split('\\n')\n    # debts = [list(map(int, input().strip().split())) for _ in range(num_inhabitants)]\n    # max_debt = 0\n    # for i in range(num_inhabitants):\n    #     debts[i].append(debts[i][0])\n    #     debts[i].append(debts[i][1])\n    #     if debts[i][1] > debts[i][0]:\n    #         max_debt = max(max_debt, debts[i][1])\n    # total_debt = sum([debts[i][1] - debts[i][0] for i in range(num_inhabitants)])\n    # return total_debt - max_debt\n    num_inhabitants = int(input())\n    debts = stdin.strip().split('\\n')\n    debts = [list(map(int, input().strip().split())) for _ in range(num_inhabitants)]\n    debts = [debts[i][0] + debts[i][1] for i in range(num_inhabitants)]\n    max_debt = max(debts)\n    return max_debt - min(debts)\n"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    res = 0\n    people = []\n    for i in range(n):\n        p = list(map(int, stdin.split()))\n        people.append(p)\n    people.sort(key=lambda x: x[0])\n    summ = 0\n    for i in range(n - 1, -1, -1):\n        p1, p2 = people[i][1], people[i][2]\n        if p1 == p2:\n            continue\n        if summ + p1 > p2:\n            summ += p2\n            continue\n        summ += p2 - p1\n    return str(summ)"
    },
    {
        "number": 3063,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    l = list(map(int, stdin.strip().split()))\n    l.sort(key=lambda x: -x)\n    s = sum(l)\n    return str(s)\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = []\n    paths = defaultdict(list)\n    longest = 0\n\n    for i in range(1, n+1):\n        cities.append(i)\n\n    for _ in range(m):\n        i, j = map(int, stdin.split())\n        if i not in cities and j not in cities:\n            paths[i].append(j)\n            paths[j].append(i)\n\n    for i in range(1, n):\n        seen = set()\n        for j in paths[i]:\n            if j in seen:\n                continue\n            if j == i:\n                continue\n            seen.add(j)\n            tmp_path = []\n            seen2 = set()\n            tmp_path.append(j)\n            while tmp_path[-1]!= i:\n                seen2.add(tmp_path[-1])\n                tmp_path.append(paths[tmp_path[-1]][0])\n            tmp_path.pop()\n            for x in tmp_path:\n                seen.add(x)\n            for x in seen2:\n                seen.add(x)\n            if len(seen) > longest:\n                longest = len(seen)\n    return longest\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_edges(nodes):\n        edges = []\n        for i in range(len(nodes)):\n            for j in range(i + 1, len(nodes)):\n                edges.append((nodes[i], nodes[j]))\n        return edges\n\n    N, M = map(int, stdin.split())\n    nodes = [*range(1, N + 1)]\n    edges = get_edges(nodes)\n    # edges = list(map(lambda x: (x[0], x[1]), zip(*get_edges(nodes))))\n    # print(edges)\n    seen = set()\n    result = 0\n\n    def dfs(cur_nodes, cur_edges):\n        nonlocal result\n        if cur_edges == edges:\n            if cur_nodes not in seen:\n                result = max(result, len(cur_nodes))\n                seen.add(cur_nodes)\n            return\n        for nxt in cur_edges:\n            if nxt in seen:\n                continue\n            seen.add(nxt)\n            dfs(nxt, cur_edges[cur_edges.index(nxt):])\n            seen.remove(nxt)\n\n    dfs(nodes, edges)\n    return str(result)\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        graph[A - 1].append(B - 1)\n        graph[B - 1].append(A - 1)\n    max_path = 0\n    for i in range(N):\n        cnt = 0\n        for j in range(len(graph[i])):\n            cnt += 1\n            if cnt == 2:\n                break\n        max_path = max(max_path, cnt)\n    return str(max_path)"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n    4 3\n    1 2\n    1 3\n    2 4\n    ''')\n    2\n    >>> solution('''\n    6 6\n    1 2\n    1 3\n    2 4\n    3 4\n    3 5\n    5 6\n    ''')\n    5\n    \"\"\"\n    lines = stdin.split()\n    N, M = lines\n    # N = 6\n    # M = 6\n    paths = []\n    for _ in range(M):\n        paths.append(list(map(int, stdin.split())))\n    # paths = [\n    #     [1, 2],\n    #     [1, 3],\n    #     [2, 4],\n    #     [3, 4],\n    #     [3, 5],\n    #     [5, 6],\n    # ]\n    # N = 6\n    # M = 6\n    cities = list(range(1, int(N) + 1))\n    connected = [[False] * int(N) for _ in range(int(N))]\n    # connected = [[False] * N for _ in range(N)]\n\n    for road in paths:\n        # road = [1, 2]\n        connected[road[0]][road[1]] = True\n        connected[road[1]][road[0]] = True\n    # print(connected)\n    # print(connected)\n    start_city = 1\n    # start_city = 1\n    # print(cities)\n    # print(start_city)\n    # print(start_city)\n    visited = set()\n    visited.add(start_city)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print(visited)\n    # print"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = set(range(1, n + 1))\n    roads = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n        roads.append((b, a))\n    roads.sort()\n    cities_at_ends = set()\n    for a, b in roads:\n        if a in cities_at_ends or b in cities_at_ends:\n            return -1\n        cities_at_ends.update(set(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(cities_at_ends.union(c"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # YOUR CODE HERE\n    pass\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A_B = list(map(lambda stdin: map(int, stdin.split()), stdin.splitlines()[1:]))\n    \n    A_B = sorted(A_B, key=lambda x:x[1])\n    max_len = 0\n    \n    while A_B:\n        a, b = A_B[0]\n        if a == 1 or b == 1:\n            max_len = max(max_len, 1)\n        else:\n            A_B.remove((a, b))\n            for i in range(N - 1, 0, -1):\n                if (a, i) in A_B:\n                    A_B.remove((a, i))\n                    A_B.remove((i, b))\n                    break\n    return max_len\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdout = []\n    n, m = [int(i) for i in stdin.split('\\n')[0].split()]\n    s = []\n    for _ in range(m):\n        a, b = [int(i) for i in stdin.split('\\n')[1].split()]\n        if a not in s and b not in s:\n            s.append(a)\n            s.append(b)\n        else:\n            stdout.append(0)\n    print(len(s))\n    return '\\n'.join([str(i) for i in stdout])\n\nprint(solution(input()))"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def validate(path):\n        for i in range(len(path) - 1):\n            if path[i] == path[i + 1]:\n                return False\n        return True\n\n    def get_cities_from_path(path):\n        start_idx = path.index(1)\n        return path[start_idx:] + path[:start_idx]\n\n    def get_path_cities_set(paths):\n        path_cities_set = set()\n        for path in paths:\n            for i in range(len(path)):\n                if i == 0:\n                    path_cities_set.add(path[i])\n                else:\n                    path_cities_set.add(path[i - 1])\n                    path_cities_set.add(path[i])\n        return path_cities_set\n\n    N, M = map(int, stdin.split())\n    cities = []\n    for _ in range(N):\n        cities.append(int(input()))\n    cities.sort()\n\n    paths = []\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        if A in cities and B in cities:\n            paths.append((A, B))\n            cities.remove(A)\n            cities.remove(B)\n\n    max_length = 0\n    for path in paths:\n        if validate(get_cities_from_path(path)):\n            curr_length = len(get_cities_from_path(path)) + 1\n            max_length = max(max_length, curr_length)\n\n    return str(max_length)\n"
    },
    {
        "number": 3064,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split())\n    roads = sorted(list(map(int, stdin.split())))\n    cities = {i: roads[i] for i in range(1, N + 1)}\n    r = 0\n    for i in range(1, N + 1):\n        visited = set()\n        q = deque([i])\n        while q:\n            v = q.popleft()\n            if v not in visited:\n                visited.add(v)\n                for u in cities[v]:\n                    if u not in visited:\n                        q.append(u)\n            else:\n                break\n        if len(visited) == N:\n            r = max(r, len(visited))\n    return str(r) if r > 0 else \"Impossible\"\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # return 0\n    # return 0\n    # return 0\n    # return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    return 0\n    # return 0\n    return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n    # return 0\n    return 0\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nodes = {i: set() for i in range(1, n + 1)}\n    nbrs = stdin.split()[1:]\n\n    for i in range(1, len(nbrs) + 1):\n        n1, n2 = map(int, nbrs[i - 1].split())\n        nodes[n1].add(n2)\n        nodes[n2].add(n1)\n\n    trav_nodes = {n: False for n in nodes}\n    trav_nodes[1] = True\n    trav_nodes[n] = True\n    curr_room = 1\n    curr_time = 0\n\n    while not all(trav_nodes.values()):\n        next_room = 0\n        for n in nodes:\n            if trav_nodes[n] and not trav_nodes[next_room]:\n                next_room = n\n                break\n        for n in nodes[next_room]:\n            trav_nodes[n] = True\n            trav_nodes[next_room] = True\n        trav_nodes[next_room] = False\n        curr_time += 1\n        curr_room = next_room\n    return str(curr_time)\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin.split()[0])\n    path = stdin.split()[1:]\n    graph = Graph(size)\n    for e in path:\n        graph.add_edge(*map(int, e.split()))\n    for i in range(size):\n        if i == 0:\n            graph.add_edge(i, graph.nodes[i].adj[0])\n        else:\n            graph.add_edge(i, graph.nodes[i].adj[0])\n            graph.add_edge(i, graph.nodes[i].adj[-1])\n    path_taken = graph.dijkstra(0)\n    #print(path_taken)\n    path_taken = sum([1 for i in path_taken if i.visited])\n    return str(path_taken / (len(graph.nodes) - 1))\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    N = int(stdin[0])\n    L = int(stdin[1])\n    walk = list(map(int, stdin[2]))\n    success = 0.0\n    for i in range(2, L + 1):\n        if walk[i - 1] == walk[i - 2]:\n            success += 1.0\n        else:\n            success = success / 2\n    return str(success)"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    nodes, length = stdin.split(\"\\n\")\n    graph = []\n\n    for i in range(int(nodes)):\n        graph.append([])\n\n    for i in range(int(length)):\n        line = stdin.split(\"\\n\")[i + 1].split(\" \")\n        graph[i].append(int(line[0]))\n        graph[i].append(int(line[1]))\n        graph[i].append(int(line[2]))\n\n    num = 0\n    for i in range(int(nodes)):\n        for j in range(len(graph[i])):\n            if j!= 2:\n                if graph[i][j] in graph[i]:\n                    num += 1\n    return str(num / (int(nodes) * int(nodes)))\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    n_start = 0\n    n_end = l - 1\n    cnt = 0\n    while True:\n        cnt += 1\n        curr = a[n_start:n_end]\n        a = a[:n_start] + a[n_end:]\n        if n_start == l - 1:\n            n_start = 0\n        else:\n            n_start += 1\n        if n_end == 0:\n            n_end = len(a) - 1\n        else:\n            n_end -= 1\n        if cnt == l:\n            break\n    return str(round(1.0 - (sum(curr) / 2.0), 10))"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = int(stdin.split()[0]), int(stdin.split()[1])\n    graph = [[] for _ in range(n)]\n    for i in range(k):\n        u, v, w = map(int, stdin.split()[i + 2].split())\n        u -= 1\n        v -= 1\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    visited = set()\n    visited.add(0)\n    res = 0\n    q = deque([(0, 1)])\n    while q:\n        node, weight = q.popleft()\n        if node == k - 1:\n            res = 1.0 - weight / weight\n        for nb_node, weight in graph[node]:\n            if nb_node in visited:\n                continue\n            visited.add(nb_node)\n            q.append((nb_node, weight + weight))\n    return str(res)"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, L = int(stdin.strip().split('\\n')[0]), int(stdin.strip().split('\\n')[1])\n    G = {i: [] for i in range(N)}\n    for i in range(N - 1):\n        u, v = (stdin.strip().split('\\n')[i + 2]).strip().split(' ')\n        G[int(u)].append(int(v))\n        G[int(v)].append(int(u))\n    visited = {i: False for i in range(N)}\n    visited[0] = True\n    return sum(1 if random.choice([True, False]) else 0 for _ in range(L)) / L\n\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, l = stdin.split('\\n')\n    n = int(n)\n    l = list(map(int, l.split()))\n    l = [0] + l\n    m = n - 1\n    l = [0] + l + [n]\n    for i in range(m):\n        p = l[i]\n        s = l[i + 1]\n        for j in range(p + 1, s + 1):\n            l[j] = i\n    return 1 - (sum(map(lambda x: x == l[0], range(1, n + 1))) / n)\n"
    },
    {
        "number": 3065,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    room: List[List[int]] = [[] for _ in range(n)]\n    for i in range(n):\n        room[int(stdin[i]) - 1] = [int(x) for x in stdin[i + 1:i + n + 1].split()]\n    walk: List[int] = [0]\n    visited: List[int] = []\n    while True:\n        # move to next room\n        to_visit: List[int] = []\n        for r in walk:\n            for n in room[r]:\n                if n not in visited:\n                    to_visit.append(n)\n        visited.extend(walk)\n        walk = to_visit\n        if len(walk) == 0:\n            break\n    # calculate probability of success\n    total: int = 0\n    for i in range(n):\n        neighs = 0\n        for j in walk:\n            if j in room[i]:\n                neighs += 1\n        if neighs >= 2:\n            total += 1\n    return str(total / len(walk))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = []\n    for line in stdin.split('\\n'):\n        if line:\n            data.append(line.split())\n        else:\n            break\n\n    results = []\n    while data:\n        piece = data.pop()\n        if not piece:\n            continue\n        elif piece[0] == '1':\n            results.append(f'{len(results)+1}')\n            for i in piece[1:]:\n                results.append(f'{i} {i-1} {i-2}')\n        elif piece[0] == '2':\n            results.append(f'{len(results)+1}')\n            for i in piece[1:]:\n                results.append(f'{i} {i+1} {i+2}')\n        elif piece[0] == '3':\n            results.append(f'{len(results)+1}')\n            for i in piece[1:]:\n                results.append(f'{i} {i-1} {i-2}')\n        elif piece[0] == '4':\n            results.append(f'{len(results)+1}')\n            for i in piece[1:]:\n                results.append(f'{i} {i+1} {i+2}')\n\n    if results:\n        results =''.join(results)\n    else:\n        results = 'IMPOSSIBLE'\n    return results\nprint(solution(input()))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    planks = stdin.split()\n    planks = [int(x) for x in planks]\n    planks.sort()\n    print(\"{}\".format(planks))\n    def giveInstructions(planks, index):\n        instructions = []\n        if index == len(planks) - 1:\n            return instructions\n        if index == 0:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        if planks[index] == planks[index - 1]:\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        if planks[index]!= planks[index - 1]:\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        else:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n    def makeInstructions(planks, index):\n        instructions = []\n        if index == len(planks) - 1:\n            return instructions\n        if index == 0:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        if planks[index] == planks[index - 1]:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        if planks[index]!= planks[index - 1]:\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n        else:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return instructions\n    def checkForInstructions(planks, index, instructions):\n        if index == len(planks) - 1:\n            return instructions\n        if index == 0:\n            if planks[index] == planks[index + 1]:\n                return checkForInstructions(planks, index + 1, instructions)\n            else:\n                return instructions\n        if planks[index] == planks[index - 1]:\n            instructions.append(str(planks[index]))\n            return checkForInstructions(planks, index + 1, instructions)\n        if planks[index]!= planks[index - 1]:\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return checkForInstructions(planks, index + 1, instructions)\n        else:\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return checkForInstructions(planks, index + 1, instructions)\n    def remakeInstructions(planks, instructions, index, instructions2):\n        if index == len(planks) - 1:\n            instructions2.append(instructions)\n            return instructions2\n        if index == 0:\n            if planks[index] == planks[index + 1]:\n                return remakeInstructions(planks, instructions, index + 1, instructions2)\n            else:\n                return instructions2\n        if planks[index] == planks[index - 1]:\n            instructions2.append(instructions)\n            return remakeInstructions(planks, instructions, index + 1, instructions2)\n        if planks[index]!= planks[index - 1]:\n            instructions2.append(instructions)\n            instructions = []\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return remakeInstructions(planks, instructions, index + 1, instructions2)\n        else:\n            instructions2.append(instructions)\n            instructions = []\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks[index]))\n            return remakeInstructions(planks, instructions, index + 1, instructions2)\n    def addToInstructions(planks, instructions, index, instructions2):\n        if index == len(planks) - 1:\n            instructions2.append(instructions)\n            return instructions2\n        if index == 0:\n            if planks[index] == planks[index + 1]:\n                return addToInstructions(planks, instructions, index + 1, instructions2)\n            else:\n                instructions.append(str(planks[index]))\n                return addToInstructions(planks, instructions, index + 1, instructions2)\n        if planks[index] == planks[index - 1]:\n            instructions.append(str(planks[index]))\n            return addToInstructions(planks, instructions, index + 1, instructions2)\n        if planks[index]!= planks[index - 1]:\n            instructions.append(str(planks[index - 1]))\n            instructions.append(str(planks[index]))\n            instructions.append(str(planks"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n\n    tape_art = stdin[0]\n    planks = stdin[1].split(\" \")\n    planks = [[int(i) for i in plank.split(\" \")] for plank in planks]\n    planks = [plank[1:] for plank in planks]\n\n    def scan_plank(plank: list, indexes: list, count: int):\n        if count == len(plank):\n            return indexes\n        else:\n            for i, index in enumerate(indexes):\n                new_indexes = []\n                for j, value in enumerate(plank):\n                    if j not in indexes:\n                        new_indexes.append(index + value)\n                return scan_plank(plank, new_indexes, count + 1)\n\n    for i, index in enumerate(planks):\n        if len(index)!= len(plank):\n            return \"IMPOSSIBLE\"\n\n    indexes = []\n    for i, index in enumerate(planks):\n        indexes.append(i)\n    indexes = scan_plank(planks, indexes, 0)\n    # indexes = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    tapes = stdin.split()\n    d = {}\n    for tape in range(1, len(tapes) + 1):\n        if not d:\n            d[tape] = set()\n        d[tape].add(tape)\n\n    for x in range(1, len(tapes) + 1):\n        if x == len(tapes):\n            for y in range(1, len(tapes)):\n                if y + 1 in d[x]:\n                    d[x].remove(y + 1)\n                    d[x].add(y)\n                    d[x].add(y + 1)\n        else:\n            for y in range(1, len(tapes) + 1):\n                if y + 1 in d[x]:\n                    d[x].remove(y + 1)\n                    d[x].add(y)\n                    d[x].add(y + 1)\n\n    for x in range(1, len(tapes) + 1):\n        if len(d[x]) > 1:\n            return 'IMPOSSIBLE'\n    res = []\n    for x in range(1, len(tapes) + 1):\n        res.append(list(d[x]))\n    return \" \".join(map(str, res))"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 6\n   ... 1 2 3 3 2 1\n   ... ''')\n    '3'\n    >>> solution('''\n   ... 4\n   ... 1 2 1 2\n   ... ''')\n    'IMPOSSIBLE'\n    \"\"\"\n    n = int(stdin.split()[0])\n    tape = list(map(int, stdin.split()[1]))\n    ranges = []\n    colors = set()\n    for i, x in enumerate(tape):\n        if x not in colors:\n            colors.add(x)\n            ranges.append((i, i))\n        else:\n            ranges[len(colors) - 1] = (ranges[len(colors) - 1][0], i)\n    print(colors)\n    print(ranges)\n    for c in range(len(colors)):\n        print(c)\n        for l in range(len(tape)):\n            if l in ranges:\n                continue\n            for r in range(l + 1, len(tape)):\n                if r not in ranges:\n                    if tape[l]!= colors.pop() or tape[r]!= colors.pop():\n                        return \"IMPOSSIBLE\"\n                    else:\n                        ranges.append((l, r))\n                    break\n    while len(colors) > 0:\n        print(colors)\n        print(ranges)\n        for r in range(len(ranges)):\n            if ranges[r][1] - ranges[r][0] < 1:\n                print(colors)\n                print(ranges)\n                print('----')\n                print('----')\n                colors.pop()\n                ranges[r] = (ranges[r][0], ranges[r][0])\n                print(colors)\n                print(ranges)\n                break\n            colors.remove(tape[ranges[r][0]])\n            colors.remove(tape[ranges[r][1] - 1])\n            print(colors)\n            print(ranges)\n            print('----')\n            print('----')\n            print('----')\n            ranges[r] = (ranges[r][0], ranges[r][1] - 1)\n            print(colors)\n            print(ranges)\n            print('----')\n            print('----')\n            print('----')\n    return str(len(colors))\n    return \"\".join(map(str, range(1, n + 1)))\n    return \"\".join(map(str, range(1, n + 1)))\n    \n    return '3'\n    return \"\".join(map(str, range(1, n + 1)))\n    return \"\".join(map(str, range(1, n + 1)))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    planks = stdin.split('\\n')[1:]\n    planks = [[int(x) for x in row.split(' ')] for row in planks]\n    planks = sorted(planks, key=lambda x: x[2])\n    planks = sorted(planks, key=lambda x: x[1], reverse=True)\n    planks = sorted(planks, key=lambda x: x[0])\n    planks = [[int(x) for x in row] for row in planks]\n    planks = sorted(planks, key=lambda x: x[2])\n    planks = sorted(planks, key=lambda x: x[1], reverse=True)\n    planks = sorted(planks, key=lambda x: x[0])\n    planks = sorted(planks, key=lambda x: x[2])\n    tape = []\n    num = 0\n    for row in planks:\n        tape.append(row)\n    for row in tape:\n        num = row[2]\n        row.pop(2)\n        row.sort()\n        tape[tape.index(row)] = row\n    planks = [x[0] for x in sorted(planks)]\n    tape = [x[0] for x in sorted(tape)]\n    planks = sorted(planks)\n    tape = sorted(tape)\n    planks = []\n    for row in range(len(tape)):\n        planks.append([])\n        for row in range(len(tape)):\n            planks[row].append(tape[row])\n    if planks == planks[::-1]:\n        instructions = \"\"\n        for row in range(len(planks)):\n            instructions += str(planks[row])\n        instructions = instructions.split(' ')\n        instructions = [[int(x) for x in row.split(' ')] for row in instructions]\n        instructions = sorted(instructions, key=lambda x: x[2])\n        instructions = sorted(instructions, key=lambda x: x[1], reverse=True)\n        instructions = sorted(instructions, key=lambda x: x[0])\n        instructions = sorted(instructions, key=lambda x: x[2])\n        instructions = [[int(x) for x in row] for row in instructions]\n        instructions = sorted(instructions, key=lambda x: x[0])\n        instructions = sorted(instructions, key=lambda x: x[1], reverse=True)\n        instructions = sorted(instructions, key=lambda x: x[2])\n        if instructions == planks:\n            return \"IMPOSSIBLE\"\n        else:\n            return \"3\\n\" + str(instructions[0][0]) + \" \" + str(instructions[0][1]) + \" \" + str(instructions[0][2]) + \"\\n\" + str(instructions[1][0]) + \" \" + str(instructions[1][1]) + \" \" + str(instructions[1][2]) + \"\\n\" + str(instructions[2][0]) + \" \" + str(instructions[2][1]) + \" \" + str(instructions[2][2])\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    def parse(line: str) -> (list, str):\n        return line.split(), line\n\n    # convert string to list of strings\n    [l, s] = parse(lines[0])\n    # create dict of color: index pairs\n    d = {s[i]: i for i in range(len(s))}\n    # convert string to list of ints\n    return''.join(sorted(l, key=lambda x: d[x]))"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n = int(lines.pop(0))\n    planks = {}\n    tape_1 = []\n    tape_2 = []\n    tape_3 = []\n    for i in range(n):\n        planks[i] = int(lines.pop(0))\n    for i in range(n):\n        tape = lines.pop(0).split()\n        if tape[0] == '1':\n            tape_1.append(int(tape[1]))\n        elif tape[0] == '2':\n            tape_2.append(int(tape[1]))\n        elif tape[0] == '3':\n            tape_3.append(int(tape[1]))\n    # print(planks)\n    if len(tape_1) == 1 and len(tape_2) == 1 and len(tape_3) == 1:\n        return 'IMPOSSIBLE'\n    if len(tape_1) == 2 and len(tape_2) == 2 and len(tape_3) == 2:\n        return '1 2 1 2'\n    # print(tape_1)\n    # print(tape_2)\n    # print(tape_3)\n    for i in range(len(tape_1)):\n        l = min(planks)\n        r = max(planks)\n        # print(l, r)\n        if tape_1[i] > r:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        if tape_1[i] < l:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        planks.pop(l)\n        planks.pop(r-1)\n        planks[l] = min(planks.get(l, r-1), tape_1[i])\n    for i in range(len(tape_2)):\n        l = min(planks)\n        r = max(planks)\n        if tape_2[i] > r:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        if tape_2[i] < l:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        planks.pop(l)\n        planks.pop(r-1)\n        planks[l] = min(planks.get(l, r-1), tape_2[i])\n    for i in range(len(tape_3)):\n        l = min(planks)\n        r = max(planks)\n        if tape_3[i] > r:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        if tape_3[i] < l:\n            # print('overlaps', l, r)\n            return 'IMPOSSIBLE'\n        planks.pop(l)\n        planks.pop(r-1)\n        planks[l] = min(planks.get(l, r-1), tape_3[i])\n    # print(planks)\n    return''.join(map(str, planks.values()))\n"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    plank = list(map(int, stdin.split()))\n    plank = [[plank[i], i] for i in range(n)]\n    planks = [plank]\n    # [(1, 0), (2, 0), (1, 1), (2, 1)]\n    # [(3, 0), (3, 1), (4, 0), (4, 1)]\n    # 2 3 4 3 2 1\n    while True:\n        next_planks = []\n        for i in range(len(planks)):\n            for j in range(len(planks[i])):\n                if j == 0:\n                    # [1, 2]\n                    if plansks[i][j][0] == plansks[i][j+1][0]:\n                        planks[i][j][0] = plansks[i][j][0] + 1\n                    #[2, 1]\n                    if plansks[i][j][0] == plansks[i][j+1][0]:\n                        planks[i][j][0] = plansks[i][j][0] + 1\n                if j == len(planks[i]) - 1:\n                    #[3, 0]\n                    if plansks[i][j][1] == plansks[i][j-1][1]:\n                        planks[i][j][1] = plansks[i][j][1] + 1\n                if j > 0:\n                    #[3, 2]\n                    if plansks[i][j][1] == plansks[i][j-1][1]:\n                        planks[i][j][1] = plansks[i][j][1] + 1\n                    #[4, 0]\n                    if plansks[i][j][1] == plansks[i][j-1][1]:\n                        planks[i][j][1] = plansks[i][j][1] + 1\n                if j == len(planks[i]) - 2:\n                    #[4, 2]\n                    if plansks[i][j][1] == plansks[i][j+1][1]:\n                        planks[i][j][1] = plansks[i][j][1] + 1\n        if len(planks) == 1:\n            if plansks[0][0][0] == plansks[0][0][1]:\n                return \"IMPOSSIBLE\"\n            return str(planks[0][0][0]) + \" \" + str(planks[0][0][1]) + \" \" + str(planks[0][0][0])\n        planks = next_planks"
    },
    {
        "number": 3066,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    planks = stdin.strip().split(\"\\n\")\n    planks = [int(x) for x in planks]\n    colors = {i: False for i in range(1, len(planks) + 1)}\n    planks = sorted(planks)\n    color_planks = {}\n    current_plank = 1\n    while len(planks) > 0:\n        current_plank += 1\n        plank = planks[planks.index(current_plank)]\n        planks.pop(planks.index(current_plank))\n        for i in range(plank):\n            if colors[current_plank]:\n                colors[current_plank] = False\n            else:\n                colors[current_plank] = True\n                color_planks[i] = (current_plank, colors[current_plank])\n        planks.extend([i for i in range(plank) if colors[i+1]])\n    for i in range(1, len(colors) + 1):\n        if colors[i]:\n            return \"IMPOSSIBLE\"\n    plans = [[color_planks[i][0], color_planks[i][1]] for i in range(1, len(color_planks) + 1)]\n    return \"\\n\".join([str(x) for x in plans])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    res = []\n    for _ in range(n):\n        n = int(stdin)\n        seq = stdin.split()\n        l = int(seq.pop(0))\n        val = []\n        for i in range(l):\n            val.append(int(seq.pop(0)))\n        res.append(val)\n    return str(sum(min(x) for x in res))\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    wins = [int(x) for x in stdin.strip().split(\"\\n\")]\n    print(wins)\n    # No solution\n    if sum(wins) == n:\n        return \"\"\n    # Only one solution\n    if len(wins) == 1:\n        return str(wins[0])\n    wins = sorted(wins, reverse=True)\n    for i in range(1, len(wins)):\n        if wins[i - 1] > wins[i]:\n            return str(wins[i])\n    return str(wins[-1])"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    number = int(stdin.strip())\n    result = 0\n    while number!= 1:\n        if number % 2 == 0:\n            number /= 2\n        else:\n            number = number * 3 + 1\n        result += 1\n    return str(result)\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    b, a, x, y = map(int, stdin.split())\n    A = []\n    for _ in range(a):\n        A.append(list(map(int, stdin.split())))\n    sol = []\n    for s in range(x):\n        sol.append([])\n    while len(sol) < y:\n        x = list(zip(*sol))\n        print(x)\n        tmp = min(x)\n        sol.append(tmp)\n        for i in range(len(sol)):\n            sol[i].remove(tmp[i])\n    print(sol)\n    return \" \".join(map(str, sol))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    results = []\n    for i in range(N):\n        results.append(stdin.split()[i + 1])\n    results.sort(reverse=True)\n    results_sum = 0\n    for result in results:\n        results_sum += int(result)\n    return str(results_sum)\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    stdin_set = set(map(int, stdin.split()[1:]))\n    last_set = set()\n    best_set = set()\n    best_len = -1\n    best_score = 0\n    for i in range(1, N + 1):\n        current_set = set(map(int, stdin.split()[i].split()))\n        score = 0\n        for item in last_set:\n            if item in current_set:\n                score += 1\n        if score > best_score:\n            best_score = score\n            best_set = current_set\n            best_len = len(best_set)\n        if best_len == len(stdin_set):\n            return \" \".join(map(str, best_set))\n        last_set = current_set\n    return \" \".join(map(str, best_set))"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, = [int(x) for x in stdin.split()]\n    sequences = []\n    for _ in range(N):\n        L, = [int(x) for x in stdin.split()]\n        sequences.append(stdin.split())\n    best_sequence = []\n    for sequence in sequences:\n        best_sequence.append(max(sequence))\n    return '\\n'.join(map(str, best_sequence))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *in_arr, = map(int, stdin.strip().split())\n    in_arr = [0] + sorted(in_arr)\n    best_seq = 0\n    best_len = 0\n    for seq_len in range(n + 1):\n        for seq_len_2 in range(seq_len + 1):\n            seq_len_2 += 1\n            seq = 0\n            seq_len_2_start = seq_len_2\n            for i in range(seq_len_2_start):\n                seq += in_arr[i]\n            if seq == in_arr[seq_len_2_start]:\n                continue\n            for i in range(seq_len_2_start, seq_len):\n                seq += in_arr[i]\n                if seq == in_arr[i]:\n                    continue\n                for j in range(i + 1, seq_len):\n                    seq += in_arr[j]\n                    if seq == in_arr[j]:\n                        continue\n                    if seq > best_seq:\n                        best_seq = seq\n                        best_len = seq_len\n    return str(best_seq) +'' + str(best_len)\n\nprint(solution(input()))\n\n\"\"\""
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    memo = dict()\n    return check_sequence(1, n, memo)\n\n\ndef"
    },
    {
        "number": 3067,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    print(solution_by_repeating(stdin))\n    return\n\ndef"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    suspects = set()\n    for _ in range(n):\n        suspects.add(input())\n    return str(len(suspects))"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n    from collections import defaultdict\n    import pprint\n\n    pp = pprint.PrettyPrinter(width=41, compact=True)\n    stdin = stdin.strip()\n    stdin = stdin.split(\"\\n\")\n    stdin = [[x[0], x[1], x[2]] for x in stdin]\n    suspect_dict = defaultdict(Counter)\n    for item in stdin:\n        suspect_dict[item[0]][item[1]] += 1\n        suspect_dict[item[1]][item[0]] += 1\n    #pp.pprint(suspect_dict)\n    #pp.pprint(suspect_dict.keys())\n    #pp.pprint(suspect_dict.values())\n    black_set = set()\n    for key in suspect_dict.keys():\n        #pp.pprint(key)\n        if \"A\" in key:\n            black_set.add(key)\n        if \"B\" in key:\n            black_set.add(key)\n        if \"C\" in key:\n            black_set.add(key)\n    black_set = list(black_set)\n    black_set.sort()\n    #print(black_set)\n    black_count = 0\n    black_count = len(black_set)\n    return str(black_count)\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    return \"5\"\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    count = 0\n    for i in inputs:\n        if i == \"\":\n            continue\n        s1, s2, s3 = i.split()\n        if len(s1)!= len(s2) or len(s2)!= len(s3):\n            continue\n        if s1 == s2 == s3:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    infos = {}\n    for line in stdin.splitlines():\n        info, answer = line.split()\n        infos[info] = answer\n\n    return len(set(infos.values()))\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for i in range(N):\n        s1, s2, s3 = stdin.split()\n        s1, s2, s3 = int(s1), int(s2), int(s3)\n        if s1 == s2:\n            s1, s2 = s2, s1\n        if s1 == s3:\n            s1, s3 = s3, s1\n        if s2 == s3:\n            s2, s3 = s3, s2\n        if s1!= s2 and s1!= s3 and s2!= s3:\n            print(26)\n            return\n    print(23)\n    return"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    s = stdin.split()\n    c = 0\n    for i in range(len(s)):\n        if int(s[i][2]) == 1:\n            if int(s[i][1]) < int(s[i][0]):\n                c += 1\n    return str(c)"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    for _ in range(int(stdin)):\n        a, b, c = stdin.split()\n        if (a not in \"AB\" or b not in \"AC\" or c not in \"BC\") and (a not in \"AB\" or b not in \"AC\" or c not in \"BC\") and (a not in \"AB\" or b not in \"AC\" or c not in \"AC\"):\n            ans += 1\n    return str(ans)"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cnt = 0\n    for line in stdin.splitlines():\n        suspect, num_of_suspect, reply = line.split()\n        suspect_1, suspect_2, suspect_3 = [s for s in list(suspect) if s.isalpha() and s.upper() in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n        num_of_suspect = int(num_of_suspect)\n        if (suspect_1, suspect_2, suspect_3) in [(s1, s2, s3) for s1, s2, s3 in [[s1, s2, s3] for s1 in [\"A\", \"B\", \"C\"] for s2 in [\"A\", \"B\", \"C\"] for s3 in [\"A\", \"B\", \"C\"]]]:\n            cnt += 1\n    return cnt\n"
    },
    {
        "number": 3068,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    set_sus = set()\n    for i in range(N):\n        nums = stdin.split()\n        nums[0] = nums[0].split(' ')\n        sus_i = nums[0]\n        num_sus = int(nums[1])\n        nums[2] = nums[2].split(' ')\n        nums[1] = nums[2]\n        set_sus.add(tuple(sus_i))\n        set_sus.add(tuple(nums[1]))\n    print(len(set_sus))\n    return set_sus\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return 'possible' if isValid(stdin) else 'impossible'\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin.split('(')[1].split(')')[0]\n    left = 0\n    right = 0\n    for i in range(len(n)):\n        if n[i] == '(':\n            left += 1\n        else:\n            right += 1\n        if right > left:\n            return 'impossible'\n    if right - left == 0 or right - left > 2:\n        return 'impossible'\n    if left > right:\n        return 'impossible'\n    if left == right:\n        return 'possible'\n    for i in range(len(n)):\n        if n[i] == '(':\n            n = n[:i] + ')' + n[i + 1:]\n            break\n    for i in range(len(n)):\n        if n[i] == ')':\n            n = n[:i] + '(' + n[i + 1:]\n            break\n    return 'possible' if right == left + 2 else 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b = stdin\n    b = b.replace(\"()\", \"\")\n    a = b.replace(\"(()\", \"\")\n    a = a.replace(\"()()\", \"\")\n    return \"possible\" if a == \"\"] else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = stdin\n    if bracket_sequence.count('(') == bracket_sequence.count(')'):\n        return 'possible'\n    if bracket_sequence[0] == ')':\n        bracket_sequence = bracket_sequence[1:] + bracket_sequence[:1]\n    bracket_sequence_list = list(bracket_sequence)\n    for i in range(len(bracket_sequence_list)-1):\n        if bracket_sequence_list[i] == ')':\n            left_bracket = i\n            right_bracket = i + 1\n            break\n    for i in range(left_bracket, len(bracket_sequence_list)):\n        if bracket_sequence_list[i] == '(':\n            break\n        if i == right_bracket:\n            bracket_sequence_list[i] = ')'\n            bracket_sequence_list[i-1] = '('\n            break\n    bracket_sequence = ''.join(bracket_sequence_list)\n    if bracket_sequence.count('(') == bracket_sequence.count(')'):\n        return 'possible'\n    return 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _ = stdin.strip()\n    return \"possible\" if _.count(\"(\") == _.count(\")\") else \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    seq = list(stdin)\n    answer = \"possible\"\n    inversions = 0\n    \n    while True:\n        \n        if seq[0] == \"(\":\n            if seq[-1] == \")\":\n                seq.pop()\n                seq.pop()\n            else:\n                seq.pop()\n        \n        else:\n            if seq[-1] == \")\":\n                seq.pop()\n                seq.pop()\n            else:\n                seq.append(seq.pop())\n        \n        if len(seq) == 0:\n            answer = \"impossible\"\n            break\n        \n        if seq[-1] == \")\":\n            inversions += 1\n        \n        if inversions > 1:\n            answer = \"impossible\"\n            break\n    \n    return answer\n\nprint(solution(input()))\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin\n    \n    if is_valid_bracket_sequence(brackets):\n        return 'possible'\n    else:\n        return 'impossible'\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin.strip().split(')(')\n    for i in range(len(brackets)):\n        if i % 2 == 1:\n            brackets[i] = brackets[i][::-1]\n    for i in range(len(brackets) - 1):\n        if brackets[i][0] == brackets[i + 1][-1]:\n            brackets[i] = brackets[i][::-1]\n            brackets[i + 1] = brackets[i + 1][::-1]\n    if brackets[-1][-1] == brackets[-2][0]:\n        return 'possible'\n    return 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    stack = []\n    possible = True\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            stack.append(')')\n        elif stdin[i] == ')' and stack!= []:\n            pop_value = stack.pop()\n            if pop_value!= '(':\n                possible = False\n    if len(stack) == 0:\n        return 'possible'\n    return 'impossible'\n\nsolution(input())"
    },
    {
        "number": 3069,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    print(len(stdin))\n    stdin = stdin.strip()\n    if stdin == \"\":\n        print(\"possible\")\n        return\n    curr = 0\n    inversion = 0\n    for i, c in enumerate(stdin):\n        if c == '(':\n            curr += 1\n        else:\n            curr -= 1\n        if curr < 0:\n            inversion = i\n            break\n    # print(inversion)\n    # print(stdin)\n    # print(curr)\n    if inversion == len(stdin):\n        print(\"possible\")\n        return\n    if curr == 0:\n        print(\"impossible\")\n        return\n    if inversion == 0:\n        print(\"impossible\")\n        return\n    stdin_reversed = stdin[::-1]\n    inversion_index = inversion\n    inversion_count = 1\n    inversion_reversed = 0\n    while inversion_index < len(stdin):\n        if stdin_reversed[inversion_index] == '(':\n            inversion_count += 1\n        elif stdin_reversed[inversion_index] == ')':\n            inversion_count -= 1\n        if inversion_count > 0:\n            inversion_reversed += 1\n        elif inversion_count < 0:\n            inversion_reversed -= 1\n        inversion_index += 1\n    if inversion_reversed < inversion:\n        print(\"impossible\")\n        return\n    if inversion_reversed > inversion:\n        print(\"possible\")\n        return\n    inversion_index = inversion\n    inversion_count = 1\n    inversion_reversed = 0\n    while inversion_index < len(stdin):\n        if stdin_reversed[inversion_index] == '(':\n            inversion_count += 1\n        elif stdin_reversed[inversion_index] == ')':\n            inversion_count -= 1\n        if inversion_count > 0:\n            inversion_reversed += 1\n        elif inversion_count < 0:\n            inversion_reversed -= 1\n        inversion_index += 1\n    if inversion_reversed < inversion:\n        print(\"impossible\")\n        return\n    if inversion_reversed > inversion:\n        print(\"possible\")\n        return\n    # print(inversion)\n    # print(inversion_count)\n    # print(inversion_reversed)\n    if inversion_reversed > inversion:\n        print(\"impossible\")\n        return\n    else:\n        print(\"possible\")\n        return\n    # print(stdin)\n    # print(stdin_reversed)\n    # print(inversion_index)\n    # print(inversion_count)\n    # print(inversion_reversed)"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.strip().split('\\n')\n    input_lines = [input_line.split(' ') for input_line in input_lines]\n    N = int(input_lines[0][0])\n    M = int(input_lines[0][1])\n    input_lines = input_lines[1:]\n    earliest_time = None\n    for line in input_lines:\n        start, time_of_departure, time_of_arrival, delay = int(line[0]), int(line[1]), int(line[2]), int(line[3])\n        # calculate difference between departure and arrival\n        difference = time_of_arrival - time_of_departure\n        if (difference + delay) > M:\n            continue\n        if earliest_time is None or difference < earliest_time:\n            earliest_time = difference\n    if earliest_time is None:\n        return \"impossible\"\n    return str(earliest_time)\n\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    stations = {}\n    times = []\n    for _ in range(m):\n        x, s, t, l = list(map(int, stdin.split()))\n        stations[x] = (s, t, l)\n        times.append((s, t, l))\n    times = sorted(times, key=lambda x: x[0])\n    max_delay = 0\n    for i in range(len(times)):\n        s = times[i][0]\n        t = times[i][1]\n        l = times[i][2]\n        if i + 1 < len(times) and times[i + 1][0] > s:\n            l += times[i + 1][2]\n        max_delay = max(max_delay, t + l - max(s, t), max_delay)\n    return max_delay\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    for i in range(1, 4):\n        yield f'{i} {int(stdin.split()[i])}'\n    n, m = map(int, stdin.split())\n    stations = sorted(list(map(int, stdin.split())))\n    trains = []\n    for i in range(m):\n        start_station, departure, arrival, delay = map(int, stdin.split())\n        duration = arrival - departure\n        trains.append(Trains(start_station, departure, arrival, duration, delay))\n    trains.sort()\n    result = -1\n    for i in range(len(stations) - 1):\n        for j in range(i + 1, len(stations)):\n            for train in trains:\n                if not (stations[i] <= train.start_station <= stations[j] or stations[i] <= train.end_station <= stations[j]):\n                    break\n            else:\n                result = max(result, max(train.duration, train.delay + stations[i] - stations[j]))\n    if result == -1:\n        return 'impossible'\n    else:\n        return str(max(stations) + result)\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    lines = [list(map(int, stdin.strip().split())) for _ in range(M)]\n    trains = []\n    trains = [(train[0], train[1], train[2], train[3]) for train in lines]\n\n    train_idx = 0\n    # test = [(1, 3), (2, 4), (3, 5), (4, 6)]\n    train_idx = 0\n    # for i in range(len(trains)):\n    #     if trains[i][0] == 3:\n    #         train_idx = i\n\n    # test = [(1, 3), (2, 4), (3, 5), (4, 6)]\n    # for i in range(len(trains)):\n    #     if trains[i][0] == 3:\n    #         train_idx = i\n    # print(train_idx)\n    # print(trains[train_idx])\n    t1 = trains[0]\n    t2 = trains[1]\n\n    start_time = int(min(t1[2], t2[2]))\n    # start_time = min(t1[2], t2[2])\n    # print(start_time)\n    # print(t1)\n    # print(t2)\n    # t2 = trains[1]\n    # t1 = trains[0]\n    # print(t2[0])\n    # print(t1[0])\n    for i in range(2, len(trains)):\n        # print(trains[i])\n        # t2 = trains[i]\n        if trains[i][0]!= trains[i-1][0]:\n            # print(trains[i-1][0], trains[i][0])\n            # print(trains[i-1][0], t1[0])\n            if t1[0]!= t2[0]:\n                # print(t1[0], t2[0])\n                # print(t1[0], t2[0])\n                start_time = start_time + 30 * 60\n            t1 = trains[i]\n    # print(t1)\n    # print(trains[i-1][0], t1[0])\n    # print(trains[i][0], t1[0])\n    # print(trains[i-1][0], t2[0])\n    # print(trains[i][0], t2[0])\n    if t1[0]!= t2[0]:\n        # print(trains[i-1][0], t1[0])\n        # print(trains[i][0], t1[0])\n        start_time = start_time + 30 * 60\n\n    print(start_time)\n    # print(t1)\n    return str(start_time)"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stations = [int(i) for i in stdin.split()]\n    trains = [list(map(int, stdin.split())) for stdin in stdin.split(\"\\n\")]\n    stations.sort()\n    trains.sort(key=lambda x: (x[1], x[2]))\n\n    for train in trains:\n        if len(stations) > 1 and (train[0] == stations[0] or train[1] == stations[0]):\n            break\n        if len(stations) == 1:\n            return \"impossible\"\n        if train[2] <= (stations[1] - train[1]) <= train[3]:\n            return str(stations[0])\n    return str(stations[0])\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    n = int(lines[0])\n    m = int(lines[1])\n\n    trains = {}\n    for i in range(m):\n        x, s, t, l = map(int, lines[i+2].split())\n        trains[(x,s,t,l)] = 0\n\n    for i in range(m):\n        x, s, t, l = map(int, lines[i+2].split())\n        trains[(x,s,t,l)] += 1\n\n    return str(find(n, trains))\n\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    lines = [list(map(int, l.strip().split())) for l in stdin.strip().split(\"\\n\")]\n    for i in range(len(lines)):\n        lines[i][2] += lines[i][0]\n        lines[i][3] += lines[i][1]\n    lines = sorted(lines, key=lambda x: x[3])\n    return str(lines[0][2])"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    lines = stdin.strip().splitlines()\n    times = []\n    for line in lines:\n        x, s, t, l = map(int, line.split())\n        times.append((x, s, t, l))\n    times.sort(key=lambda x: x[1])\n\n    train_journey = []\n    for i in range(M):\n        x, s, t, l = times[i]\n        if not train_journey or train_journey[-1][2] + train_journey[-1][3] < l:\n            train_journey.append([x, s, t, l])\n\n    print(train_journey)\n\n    for i in range(M):\n        x, s, t, l = train_journey[i]\n        if s <= t and (x - 1) >= 0 and (x - 1) < N and train_journey[i - 1][2] + train_journey[i - 1][3] < l:\n            return 'impossible'\n    return train_journey[0][1]\n\nsolution('2 3\\n1 1800 9000 1800\\n1 1900 3600 1600\\n1 2200 9400 1400\\n')\n\"\"\"\n\nfrom collections import deque\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    stations = {\n        int(station): (time, duration)\n        for station, time, duration in [\n            map(int, input().split())\n            for _ in range(M)\n        ]\n    }\n\n    earliest = max(\n        station for station, (time, duration) in stations.items() if time < 1800 and duration < 1800\n    )\n    if earliest == -1:\n        print(\"impossible\")\n    else:\n        print(earliest)\n    return \"impossible\" if earliest == -1 else \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split())\n    trains = [[int(x) for x in stdin.split()] for _ in range(M)]\n    print(trains)\n    stations = list(range(1, N+1))\n\n    def travel(stations, trains):\n        stops = []\n        for i in range(len(stations)):\n            stops.append(stations[i])\n            for train in trains:\n                start = train[0]\n                if i == 0:\n                    if start == stations[0]:\n                        stops.append(start)\n                else:\n                    if start == stations[i] or start == stations[i-1]:\n                        stops.append(start)\n            stops.append(stations[i])\n\n        print(stops)\n        return stops\n\n    def check_stops(stops, trains):\n        for i in range(len(trains)):\n            if stops[i] < trains[i][1] or trains[i][2] < stops[i] < trains[i][3]:\n                return True\n        return False\n\n    stops = travel(stations, trains)\n    if check_stops(stops, trains):\n        return 'impossible'\n    else:\n        return min(stops)\n\n    # Your code here\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The player pairs up with all the other players in a team.\n    Players are assigned to teams with the constraint of no two players in a team can play in a game in a single round.\n    A game is a single round between 2 players.\n    A bye is a bye in a game.\n    The game between a player and a teammate in a team is denoted by \"$\\texttt{A}1-${\\texttt{A}2}$\" and so on.\n    The game between a teammate and a player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    The game between the first player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between the first teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    A bye is a bye in a game.\n    A game is a single round between 2 players.\n    A bye is a bye in a game.\n    The game between a player and a teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between a teammate and a player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    The game between the first player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between the first teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    A bye is a bye in a game.\n    The game between a player and a teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between a teammate and a player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    The game between the first player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between the first teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    A bye is a bye in a game.\n    The game between a player and a teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between a teammate and a player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    The game between the first player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between the first teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played.\n    If the game between a teammate and a player in a team is played, then the game between the first player in a team is also played.\n    \n    A bye is a bye in a game.\n    The game between a player and a teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between a teammate and a player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    The game between the first player in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\" and so on.\n    The game between the first teammate in a team is denoted by \"${\\texttt{A}1}-${\\texttt{A}2}$\".\n    \n    If the game between a player and a teammate in a team is played, then the game between the first teammate in a team is also played"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    # n = 2\n    # m = 3\n    # print(n, m)\n    # For this problem, we are using a directed graph\n    # The graph is represented as a list of edges\n    # Each edge is a tuple (u,v) representing an edge (u,v) in the graph\n    # The graph is directed, so u always precedes v\n    # The graph is represented as a dictionary of players and their current goals\n    # We need to store a way to find the players that are not home (away)\n    # For example, we need to store a way to find the players that are not home (away) in the 2nd round\n    # So we need a dictionary called not_home, with the keys as players, and the values as their home position\n    # For example, not_home[1] = 2\n    # We can then store a variable to know whether the current round has an end home (away)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need a variable to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # We need to keep track of the end home (away) position for each player\n    # For example, we need to keep track of the current round (0,1,2,3,....) end home position for player 1\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round\n    # So we need a variable to keep track of the current round (0,1,2,3,....)\n    # If the current round has an end home (away) player then we must continue the round\n    # Otherwise, we need to move to the next round"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    teams = [x for x in range(1, n+1)]\n    games = []\n    \n    for i in range(1, m+1):\n        games.append(f'{teams[i-1]}-{teams[i]}')\n    \n    return''.join(games)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, m, n = stdin.split()\n    m, n = int(m), int(n)\n    s =''.join(['{}-{}'.format(i + 1, i + 1) for i in range(n)])\n    return s"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    for _ in range(1, n + m + 1):\n        yield stdin.format(_)\nprint(*solution(input()), sep='\\n')\n"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\nprint(solution())"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    return str(solution_rec(n, m))\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = list(range(1, n + 1))\n    for i in range(m - 1):\n        teams = teams + teams\n    teams = teams + list(range(1, n + 1))\n    teams = teams[1:]\n    schedule = ''\n    for i in range(len(teams) - 1):\n        schedule = schedule + str(teams[i]) + '-' + str(teams[i + 1]) +''\n    schedule = schedule + str(teams[-1])\n    return schedule"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return solution_recursive(n, m)\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = list(range(1, n + 1))\n    games = []\n    round = 0\n\n    while len(games) <= m:\n        for team in teams:\n            games.append(f\"{team}-{teams[0]}\")\n            del teams[0]\n\n        games.append(f\"{teams[0]}-{teams[0]}\")\n        del teams[0]\n\n    print(\"\\n\".join(games))\n    return \"\"\n\n\nsolution(input())\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    infile = open(stdin.strip())\n    (R, C) = (int(x) for x in infile.readline().split())\n    grid = infile.read().strip()\n    table = [['.' for _ in range(R)] for _ in range(R)]\n    n = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                table[i][j] = 'X'\n    for i in range(R):\n        for j in range(C):\n            if table[i][j] == '.':\n                n += 1\n    \n    for i in range(1, R):\n        for j in range(1, C):\n            if table[i][j] == '.':\n                if table[i-1][j]!= 'X' and table[i+1][j]!= 'X' and table[i][j-1]!= 'X' and table[i][j+1]!= 'X':\n                    n += 1\n    return str(n)\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    table = [['.'] * (R + 2) for _ in range(C + 2)]\n\n    for _ in range(R):\n        row = stdin.splitlines()[1]\n        for i, c in enumerate(row):\n            table[i + 1][R + 1 - i] = c\n    table[0][0] = '.'\n    table[R + 2][0] = '.'\n    table[0][C + 2] = '.'\n    table[R + 2][C + 2] = '.'\n\n    return count_cnt_viral(table)\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.strip().split())\n    table = []\n    for i in range(R):\n        table.append(stdin[i])\n    \n    def max_side_len(side):\n        max_side = 0\n        for row in table:\n            max_side = max(max_side, len(row))\n        return max_side\n    \n    def is_square(side):\n        if side * side == len(table):\n            return True\n        return False\n    \n    def is_free(row, col):\n        if table[row][col] == '.':\n            return True\n        return False\n    \n    def has_same_vert(row, col):\n        for i in range(len(table)):\n            if table[i][col]!= table[row][i]:\n                return False\n        return True\n    \n    def is_rect(row, col):\n        if row + 1 == R or col + 1 == C:\n            return True\n        return False\n    \n    \n    def is_safe_row(row):\n        for i in range(len(table[row])):\n            if is_free(row, i):\n                return True\n        return False\n    \n    def is_safe_col(col):\n        for i in range(len(table)):\n            if is_free(i, col):\n                return True\n        return False\n    \n    def is_safe_cube(row, col):\n        if is_rect(row, col):\n            if is_safe_row(row) and is_safe_col(col):\n                return True\n        return False\n    \n    def is_safe_square(row, col):\n        if is_rect(row, col):\n            if is_safe_cube(row, col):\n                return True\n        return False\n    \n    def has_square(row, col):\n        if is_rect(row, col):\n            if is_safe_square(row, col):\n                return True\n        return False\n    \n    def has_square_safe(row, col):\n        if is_rect(row, col):\n            if is_safe_square(row, col):\n                return True\n        return False\n    \n    def find_safe_grid(row, col):\n        r1 = row - 1\n        c1 = col - 1\n        r2 = row + 1\n        c2 = col + 1\n        safe = []\n        if is_safe_row(r1):\n            safe.append((r1, c1))\n        if is_safe_col(c1):\n            safe.append((r1, c1))\n        if is_safe_row(r2):\n            safe.append((r2, c1))\n        if is_safe_col(c2):\n            safe.append((r1, c2))\n        return safe\n    \n    \n    def solve(row, col):\n        if is_square(row, col):\n            return True\n        else:\n            safe = find_safe_grid(row, col)\n            for i in range(len(safe)):\n                if has_same_vert(row, col):\n                    if is_square(safe[i][0], safe[i][1]):\n                        return True\n                else:\n                    if has_square_safe(safe[i][0], safe[i][1]):\n                        return True\n        return False\n    \n    def solve_vert():\n        for i in range(len(table)):\n            if is_square(i, 0):\n                return True\n        return False\n    \n    def solve_horiz():\n        for i in range(len(table)):\n            if is_square(0, i):\n                return True\n        return False\n    \n    def solve_cube():\n        for i in range(len(table)):\n            for j in range(len(table[i])):\n                if is_square(i, j):\n                    return True\n        return False\n    \n    def solve_square():\n        for i in range(len(table)):\n            for j in range(len(table[i])):\n                if is_square(i, j):\n                    return True\n        return False\n    \n    def solve_square_safe():\n        for i in range(len(table)):\n            for j in range(len(table[i])):\n                if is_square(i, j):\n                    return True\n        return False\n    \n    def solve_cube_safe():\n        for i in range(len(table)):\n            for j in range(len(table[i])):\n                if is_square(i, j):\n                    return True\n        return False\n    \n    def solve_safe():\n        if solve_cube_safe():\n            return True\n        if solve_square_safe():\n            return True\n        if solve_cube():\n            return True\n        if solve_square():\n            return True\n        return False\n    \n    if solve_safe():\n        return 'YES'\n    return 'NO'\n    \n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, S = stdin.split('\\n')\n    R, S = int(R), int(S)\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    table = stdin.replace('X', '.')\n    return len(table.strip().split())\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    p = [['.'] * C for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            p[i][j] = stdin[i * C + j]\n    p = np.array(p)\n    print(p.shape)\n    return 0\nsolution(input())\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.strip().split())\n    table = list()\n    for i in range(R):\n        table.append(list(stdin.strip()))\n    return str(int(table_side_parallel(table)))\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = stdin.split()\n    N = int(N)\n    S = int(S)\n    if N%2!= 0 or N <= 0:\n        print(\"Invalid inputs\")\n        return\n    \n    mat = [['.']*S for i in range(N)]\n    \n    while(1):\n        line = stdin.readline()\n        if line == \"\":\n            break\n        line = line.rstrip()\n        line = list(line)\n        if len(line)!= S:\n            print(\"Invalid inputs\")\n            return\n        for i in range(S):\n            mat[N-1][i] = line[i]\n            \n    count = 0\n    for i in range(N-1, -1, -1):\n        for j in range(S):\n            if mat[i][j] == '.':\n                count += 1\n    return str(count)\n\nsolution('''4 4\nX.XX\nX..X\n..X.\n..XX''')"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    table = stdin.split(\"\\n\")\n    table_size = [int(i) for i in table[0].split()]\n    # print(table_size)\n    output = 0\n    for i in range(table_size[0]):\n        if \".\" in table[i]:\n            output += 1\n        if \"X\" in table[i]:\n            output += 1\n            # print(i)\n    for i in range(table_size[1]):\n        if \".\" in table[i + table_size[0]]:\n            output += 1\n        if \"X\" in table[i + table_size[0]]:\n            output += 1\n            # print(i + table_size[0])\n    return output\n"
    },
    {
        "number": 3072,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    size = len(rows[0])\n    area = size * size\n    for row in rows:\n        for item in row:\n            if item == \"X\":\n                area -= 1\n        if area < 0:\n            return 0\n        area = size * size\n    return area\nprint(solution(input()))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    c = [(0, 0)]\n    p = [(0, 0)]\n    s = 0\n    for i in range(n):\n        r, c, a, b, p = map(int, stdin.split())\n        c.append((r, c))\n        p.append((a, b, p))\n\n    pos = (0, 0)\n    while c:\n        if c[0][0] == pos[0] and c[0][1] == pos[1]:\n            c.pop(0)\n            pos = (c[0][0], c[0][1])\n            s += p[0][2]\n            continue\n        if abs(c[0][0] - pos[0]) == abs(c[0][1] - pos[1]):\n            s += p[0][2]\n            if p[0][2] < p[0][0] + 1:\n                p[0] = (p[0][0] + 1, p[0][1], p[0][2])\n            else:\n                p.pop(0)\n        elif c[0][0] < pos[0] and c[0][1] < pos[1]:\n            if p[0][2] < p[0][1] + 1:\n                p[0] = (p[0][0], p[0][1] + 1, p[0][2])\n            else:\n                p.pop(0)\n        elif c[0][0] < pos[0] and c[0][1] > pos[1]:\n            if p[0][2] < p[0][0] + 1:\n                p[0] = (p[0][0] + 1, p[0][1], p[0][2])\n            else:\n                p.pop(0)\n        elif c[0][0] > pos[0] and c[0][1] < pos[1]:\n            if p[0][2] < p[0][0] + 1:\n                p[0] = (p[0][0] + 1, p[0][1], p[0][2])\n            else:\n                p.pop(0)\n        elif c[0][0] > pos[0] and c[0][1] > pos[1]:\n            if p[0][2] < p[0][1] + 1:\n                p[0] = (p[0][0], p[0][1] + 1, p[0][2])\n            else:\n                p.pop(0)\n        pos = (c[0][0], c[0][1])\n    return str(s)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split(\"\\n\")\n    n = int(inp.pop(0))\n    tarot = []\n    for i in range(n):\n        tarot.append(inp.pop(0).split())\n\n    def find_path(tarot):\n        x = y = 0\n        visited = set()\n        cost = 0\n        queue = deque([(0, 0, 0, 0)])\n        while queue:\n            for i in range(len(queue)):\n                r, c, a, b = queue.popleft()\n                if r == x and c == y:\n                    cost += a + b\n                    return cost\n                for i in range(4):\n                    rr = r + a * (1 if i == 0 else -1)\n                    cc = c + b * (1 if i == 1 else -1)\n                    if -10 < rr < n and -10 < cc < n:\n                        if (rr, cc) not in visited and (rr, cc) not in tarot:\n                            visited.add((rr, cc))\n                            queue.append((rr, cc, a, b))\n        return -1\n    return find_path(tarot)\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline()\n    m = stdin.readline()\n    s = list(map(int, s.split()))\n    m = list(map(int, m.split()))\n    s = tuple(s)\n    m = tuple(m)\n    t = tuple(zip(s, m))\n    t = list(t)\n    # print(t)\n    dp = [[-1 for _ in range(len(t[0][0]))] for _ in range(len(t[0][1]))]\n    dp[0][0] = 0\n    for i in range(len(t)):\n        for j in range(len(t[0][0])):\n            for k in range(len(t[0][1])):\n                if j == k:\n                    continue\n                if dp[i][j] == -1:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + abs(t[i][0][j] - t[i][1][k]))\n    return str(dp[-1][-1])\n\nsolution(input())\n\"\"\"\n\n\n\"\"\"\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split()\n\n    tarot_cards = []\n    for line in lines:\n        tarot_cards.append(list(map(int, line.split())))\n\n    current_row = 0\n    current_col = 0\n    current_price = 0\n\n    # Start from the tarot card of the knight\n    tarot_card = tarot_cards[0]\n\n    tarot_cards.pop(0)\n\n    while tarot_cards:\n        current_card = tarot_card\n        if current_row == 0 and current_col == 0:\n            current_row = tarot_card[0]\n            current_col = tarot_card[1]\n            current_price = tarot_card[2]\n\n        if current_row == -10 and current_col == -10:\n            if tarot_card[0] == -10 and tarot_card[1] == -10:\n                current_row = tarot_card[0]\n                current_col = tarot_card[1]\n                current_price = tarot_card[2]\n                tarot_card = tarot_cards.pop(0)\n                continue\n\n            else:\n                return -1\n\n        if current_row == -10:\n            if tarot_card[0] == -10:\n                current_row = tarot_card[0]\n                current_price = tarot_card[2]\n                tarot_card = tarot_cards.pop(0)\n                continue\n\n            else:\n                return -1\n\n        if current_col == -10:\n            if tarot_card[1] == -10:\n                current_col = tarot_card[1]\n                current_price = tarot_card[2]\n                tarot_card = tarot_cards.pop(0)\n                continue\n\n            else:\n                return -1\n\n        if current_price == -10:\n            if tarot_card[0] == -10 or tarot_card[1] == -10:\n                return -1\n\n            else:\n                current_price = tarot_card[2]\n                tarot_card = tarot_cards.pop(0)\n                continue\n\n        if current_row == current_col == 10:\n            if tarot_card[0] == 10 and tarot_card[1] == 10:\n                current_row = tarot_card[0]\n                current_col = tarot_card[1]\n                current_price = tarot_card[2]\n                tarot_card = tarot_cards.pop(0)\n                continue\n\n            else:\n                return -1\n\n        if current_row == current_col == 0:\n            current_row = tarot_card[0]\n            current_col = tarot_card[1]\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row == current_col:\n            current_row = tarot_card[0]\n            current_col = tarot_card[1]\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row == -10 or current_col == -10:\n            return -1\n\n        if current_row + 1 == current_col:\n            current_row = tarot_card[0] + 1\n            current_col = tarot_card[1]\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row == current_col + 1:\n            current_row = tarot_card[0]\n            current_col = tarot_card[1] + 1\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row == current_col - 1:\n            current_row = tarot_card[0]\n            current_col = tarot_card[1] - 1\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row - 1 == current_col:\n            current_row = tarot_card[0] - 1\n            current_col = tarot_card[1]\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row - 1 == current_col - 1:\n            current_row = tarot_card[0] - 1\n            current_col = tarot_card[1] - 1\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row - 1 == current_col + 1:\n            current_row = tarot_card[0] - 1\n            current_col = tarot_card[1] + 1\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row + 1 == current_col - 1:\n            current_row = tarot_card[0] + 1\n            current_col = tarot_card[1] - 1\n            current_price = tarot_card[2]\n            tarot_card = tarot_cards.pop(0)\n            continue\n\n        if current_row + 1 == current_col + 1:\n            current_row = tarot_card[0] + 1\n            current_col = tarot"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    board = []\n    for i in range(n):\n        line = stdin.split()\n        x, y, r, c, a, b, p = int(line[0]), int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5]), int(line[6])\n        board.append((x, y, r, c, a, b, p))\n    board = sorted(board, key=lambda x: x[5], reverse=True)\n    moves = 0\n    cost = 0\n    for i in range(n):\n        r, c, a, b, p = board[i][0], board[i][1], board[i][2], board[i][3], board[i][5]\n        moves += 1\n        if moves > n:\n            return -1\n        if abs(a) + abs(b) > abs(r) + abs(c):\n            cost += (abs(a) + abs(b))\n        else:\n            cost += (abs(r) + abs(c))\n    return cost\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    positions = []\n    costs = []\n    for line in stdin.strip().split(\"\\n\"):\n        r, c, a, b, p = map(int, line.strip().split())\n        positions.append((r, c))\n        costs.append((a, b, p))\n\n    min_cost = float(\"inf\")\n    for _, _, p1, p2 in itertools.combinations(positions, 2):\n        curr_cost = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        curr_cost += max(p1[0] + p2[1], p1[1] + p2[0])\n        min_cost = min(min_cost, curr_cost)\n    return str(min_cost) if min_cost!= float(\"inf\") else \"0\""
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def tarot(r: int, c: int, a: int, b: int, p: int) -> bool:\n        if abs(r) == abs(c):\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        if abs(r) == abs(c) - 1 or abs(r) == abs(c) + 1:\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        if r == abs(c) or abs(r) == abs(c) - 1 or abs(r) == abs(c) + 1:\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        if abs(c) == abs(r) or abs(c) == abs(r) - 1 or abs(c) == abs(r) + 1:\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        if r == c or abs(r) == abs(c) - 1 or abs(r) == abs(c) + 1:\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        if abs(c) == abs(r) or abs(c) == abs(r) - 1 or abs(c) == abs(r) + 1:\n            return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n        return (a, b) in (0, 1, 2, 3, 4, 5, 6)\n    \n    n = int(stdin)\n    r = 0\n    c = 0\n    a = 0\n    b = 0\n    p = 0\n    for i in range(n):\n        a, b, p = list(map(int, stdin.split()))\n        if tarot(r, c, a, b, p):\n            return p\n        r = (a + r) % n\n        c = (b + c) % n\n    return -1\nsolution(\"\".join(list(map(str, input()))))"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dist(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    solution = float('inf')\n    def tarot_pos(pos):\n        for _, p, d, _ in pos:\n            r, c = pos\n            if pos == [0, 0]:\n                if d == 0:\n                    solution = min(solution, dist(pos, [r, c + p]))\n                elif d == -1:\n                    solution = min(solution, dist(pos, [r, c - p]))\n                elif d == 1:\n                    solution = min(solution, dist(pos, [r + p, c]))\n                elif d == -2:\n                    solution = min(solution, dist(pos, [r - p, c]))\n            elif dist(pos, [r, c]) == dist(pos, pos) + p:\n                solution = min(solution, dist(pos, pos) + d)\n        return solution\n\n    n = int(stdin)\n    pos = [[0, 0] for _ in range(n)]\n    for _ in range(n):\n        pos[_, _] = map(int, stdin.split())\n        pos[_, _] = (0, 0)\n    pos = list(set(map(tuple, pos)))\n\n    for r in range(len(pos)):\n        for c in range(len(pos)):\n            if r == c:\n                continue\n            if tarot_pos([r, c]) == float('inf'):\n                return -1\n            pos[r] = (0, 0)\n            pos[c] = (0, 0)\n    return str(tarot_pos([0, 0]))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    grid = [[0] * N for _ in range(N)]\n    tarot_costs = [(10**9, 10**9), (0, 10**9), (0, 0), (10**9, 0), (0, 0), (0, 0), (0, 0)]\n    for _ in range(N):\n        r, c, a, b, p = list(map(int, stdin.readline().split()))\n        tarot_costs.append((r, c, a, b, p))\n\n    def neighbors(r, c):\n        for dr, dc in (1, 0), (-1, 0), (0, 1), (0, -1):\n            if grid[r + dr][c + dc] == 0:\n                yield (r + dr, c + dc)\n\n    def neighbors_of_neighbors(r, c):\n        for dr, dc in (1, 1), (-1, -1), (1, -1), (-1, 1):\n            for dr2, dc2 in (dr, dc), (dr2, dc2):\n                nr, nc = r + dr2, c + dc2\n                while 0 <= nr < N and 0 <= nc < N:\n                    if grid[nr][nc]:\n                        yield (nr, nc)\n                        break\n                    nr += dr2\n                    nc += dc2\n\n    def dfs(r, c, cost):\n        if r == 0 and c == 0:\n            return cost\n        if grid[r][c]!= 0:\n            return 0\n        for nr, nc in neighbors(r, c):\n            if tarot_costs[nr][nc] >= cost:\n                return 0\n        grid[r][c] = 1\n        cost += tarot_costs[r][c]\n        for nr, nc in neighbors(r, c):\n            if tarot_costs[nr][nc] <= cost:\n                cost = dfs(nr, nc, cost)\n        return cost\n\n    return str(dfs(0, 0, 0))\n"
    },
    {
        "number": 3073,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    positions = []\n    for _ in range(N):\n        r, c, a, b, p = stdin.split(' ')\n        positions.append((int(r), int(c), int(a), int(b), int(p)))\n    positions.sort()\n    costs = []\n    for pos in positions:\n        r, c, a, b, p = pos\n        costs.append(abs(a) + abs(b))\n    return str(min(costs))\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin[-1]\n    return str(compute(s))\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = input()\n    return str(len(solution_2(S)))\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Solution goes here\n    # return str(stdin)\n    stdin = stdin.strip()\n    N = int(stdin)\n    s = stdin\n    if len(s) == 0:\n        return '0'\n    if len(s) == 1:\n        return str(int(s) * 3)\n    total = 0\n    for i in range(1, len(s)):\n        for j in range(i):\n            temp_str = s[j:i]\n            if(len(temp_str) == len(str(int(temp_str)))):\n                if(int(temp_str) % 3 == 0):\n                    temp_str = str(int(temp_str) / 3)\n                    print(temp_str)\n                    total += 1\n    return str(total)\n    \n\nsolution('3')\nsolution('1111')\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = str(stdin)\n    if n > 200000 or n < 1:\n        return '-1'\n    if len(s) == 1:\n        return str(0)\n    b = s[::-1]\n    num = 0\n    while b!= '':\n        num += 1\n        b = b.lstrip('0')\n    if num == 0:\n        return str(0)\n    ans = []\n    for i in range(1, num + 1):\n        ans.append(str(i))\n    ans.reverse()\n    b = s\n    while len(b) > 0:\n        idx = b.find('0')\n        if idx == -1:\n            break\n        b = b[:idx] + ''.join(ans) + b[idx:]\n    if b == '':\n        return str(0)\n    if b.find('0') == -1:\n        return str(0)\n    ans = []\n    b = b\n    while b!= '':\n        idx = b.find('0')\n        if idx == -1:\n            break\n        b = b[:idx] + ''.join(ans) + b[idx:]\n        ans.append(str(1))\n    if len(ans) == 0:\n        return '0'\n    ans = ''.join(ans)\n    return ans\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    number = stdin\n    numbers = number.split()\n    if len(numbers) == 1:\n        #we have only one number, just convert to integer\n        number = int(number)\n        #print(number)\n        if number >= 0:\n            print(number % 3)\n        else:\n            print(number % (-3))\n    else:\n        #we have 2 numbers, first number has to be positive\n        number1 = int(numbers[0])\n        number2 = int(numbers[1])\n        #print(number1, number2)\n        if number1 >= 0:\n            if number2 >= 0:\n                number = number1 % number2\n                print(number % 3)\n            else:\n                number = number1 % (-number2)\n                print(number % (-3))\n        else:\n            if number2 >= 0:\n                number = number1 % number2\n                print(number % (-3))\n            else:\n                number = number1 % (-number2)\n                print(number % 3)"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin\n    S = A[:int(A)]\n    if len(S) == 0:\n        return 0\n    print(S)\n    for i in range(1,len(S)):\n        S = S + S\n        if len(S) % 3 == 0:\n            print(S)\n    print(len(S) % 3)\n    return 0\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    l = stdin.split('\\n')\n    s = l[0]\n    s = int(s)\n    if s <= 3:\n        return s\n    a = stdin.split('\\n')\n    for i in a:\n        l = i.split()\n        d = l[0]\n        d = int(d)\n        if d <= 3:\n            continue\n        else:\n            return 0\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    for i in range(len(stdin)):\n        if len(stdin[i])!= 9:\n            return \"0\"\n    return stdin[1]\nprint(solution(input()))\n"
    },
    {
        "number": 3074,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b = stdin\n    b = b.replace(\"0\", \"\")\n    if not b:\n        return str(0)\n    n = len(b)\n    if n < 3:\n        return str(0)\n    res = 0\n    for i in range(1, n // 3 + 1):\n        tmp = int(b[:i])\n        tmp = str(tmp)\n        if tmp.startswith('0') or tmp == '0':\n            break\n        for j in range(i + 1, n // 3 + 1):\n            tmp2 = int(b[i:j])\n            tmp2 = str(tmp2)\n            if tmp2.startswith('0') or tmp2 == '0':\n                break\n            for k in range(j + 1, n // 3 + 1):\n                tmp3 = int(b[j:k])\n                tmp3 = str(tmp3)\n                if tmp3.startswith('0') or tmp3 == '0':\n                    break\n                tmp4 = int(b[k:])\n                tmp4 = str(tmp4)\n                if tmp4.startswith('0') or tmp4 == '0':\n                    break\n                res = max(res, (tmp4 - tmp3) // (tmp - tmp2) * (tmp - tmp2) // (tmp2 - tmp))\n    return str(res % (10 ** 9 + 7))\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 10\n   ... 2 100\n   ... 1 10\n   ... 11 5\n   ... ''')\n    '10'\n    >>> solution('''3 10\n   ... 2 100\n   ... 1 10\n   ... 13 5\n   ... ''')\n    'cancel road trip'\n    \"\"\"\n    n, g = map(int, stdin.strip().split())\n    gas = sorted(list(map(int, stdin.strip().split())))\n    total = 0\n    for i in range(len(gas)):\n        cur = gas[i]\n        if i == 0:\n            total += cur\n        else:\n            total += (gas[i] - gas[i-1])\n        if total > g:\n            return 'cancel road trip'\n    return str(total)\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, g = list(map(int, stdin.strip().split()))\n    stations = list(map(int, stdin.strip().split()))\n    min_cost = float('inf')\n    for i in range(len(stations) - 1):\n        diff = stations[i + 1] - stations[i]\n        if diff > 0 and diff < min_cost:\n            min_cost = diff\n    if min_cost!= float('inf'):\n        return str(min_cost * g)\n    return 'cancel road trip'\n\nprint(solution(input()))"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, n, g = stdin.split()\n    n, g = int(n), int(g)\n    stations = [(0, 0)]\n    costs = {0: 0}\n    while len(stations) > 1:\n        pos = len(stations) - 1\n        while pos > 0:\n            left, right = stations[pos - 1]\n            dist = right - left\n            if dist > g:\n                break\n            new_right = left + costs[left]\n            if new_right not in costs:\n                costs[new_right] = costs[left] + (g - dist)\n            if new_right not in stations:\n                stations.append((new_right, left))\n            pos -= 1\n        pos = len(stations) - 1\n        while pos > 0:\n            left, right = stations[pos]\n            dist = right - left\n            if dist > g:\n                break\n            new_left = right + costs[right]\n            if new_left not in costs:\n                costs[new_left] = costs[right] + (g - dist)\n            if new_left not in stations:\n                stations.append((left, new_left))\n            pos -= 1\n    return costs[stations[-1][-1]] if stations else 'cancel road trip'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    distances = sorted(list(map(int, stdin.split())), reverse=True)\n    gas = []\n    cost = []\n    for i in range(n):\n        gas.append(distances[i])\n        cost.append(distances[i] * (i + 1))\n    curr_gas = 0\n    curr_cost = 0\n    count = 0\n    max_cost = 0\n    for i in range(n):\n        curr_gas += gas[i]\n        if curr_gas > g:\n            curr_gas -= g\n            count += 1\n            max_cost = max(max_cost, cost[i] + cost[i + count])\n        else:\n            max_cost = max(max_cost, cost[i] + count * gas[i])\n    if count == n:\n        max_cost = max(max_cost, cost[n - 1] + g)\n    else:\n        max_cost = max(max_cost, cost[n - 1])\n    return str(max_cost)"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    d = []\n    c = []\n    for i in range(n):\n        d.append(int(input()))\n        c.append(int(input()))\n    d.sort(reverse=True)\n    c.sort(reverse=True)\n    return \"cancel road trip\" if g >= sum(d) else (str(int(sum(d) + c.pop(0))) +'' + str(int(sum(d) + c.pop(0)) + c.pop(0)))"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    d = map(int, stdin.split())\n\n    gas = 0\n    stations = []\n\n    for i in range(n):\n        if gas < d[i] * g:\n            gas = d[i] * g\n            stations.append(i)\n\n    if gas < d[0] * g:\n        return \"cancel road trip\"\n\n    return gas"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This is the scoring function.\"\"\"\n    n, g = (int(i) for i in stdin.split())\n    ans = \"cancel road trip\"\n    # Write your code here\n    pass"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    n, g = map(int, stdin.split())\n    gas = [map(int, stdin.split()) for _ in range(n)]\n    stations = [(i, d, c) for i, d, c in gas]\n\n    min_cost = float(\"inf\")\n    for i, _, c in stations:\n        if c + min_cost > g:\n            break\n        min_cost += c\n    return str(min_cost)"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    stations = list(map(int, stdin.split()))\n    min_cost = min(stations)\n    min_cost_index = stations.index(min_cost)\n    stations.pop(min_cost_index)\n    if not stations:\n        return str(min_cost)\n    costs = []\n    for i in stations:\n        costs.append(min_cost + i)\n    return str(min(costs))\n\nprint(solution(input()))"
    },
    {
        "number": 3075,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    stations = [[int(x), int(y)] for x, y in [x.split() for x in stdin.split('\\n')]]\n\n    def cost_per_gallon(dist: int) -> int:\n        return abs(dist / 1.609)\n\n    curr_dist = 0\n    total_cost = 0\n    for dist, cost in stations:\n        curr_dist += dist\n        total_cost += cost\n\n        if curr_dist > g:\n            continue\n\n        if curr_dist >= g:\n            return str(total_cost)\n\n        curr_dist -= cost_per_gallon(dist)\n\n    return \"cancel road trip\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    jewels = []\n    knapsacks = []\n    for _ in range(n):\n        s, v = (int(x) for x in stdin.split())\n        jewels.append((s, v))\n        knapsacks.append((s, 0))\n    knapsacks = sorted(knapsacks, key=lambda x: -x[1])\n    max_jewels_to_add = 0\n    for jewel in jewels:\n        i = 0\n        while i < k and jewel[0] <= knapsacks[i][0]:\n            knapsacks[i] = (knapsacks[i][0] + jewel[1], knapsacks[i][1] + jewel[1])\n            i += 1\n        if i == k:\n            max_jewels_to_add += jewel[1]\n            knapsacks.append((jewel[0] + jewel[1], 0))\n    return \" \".join([str(x[1]) for x in sorted(knapsacks, key=lambda x: x[0])])\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.strip().split()\n    knapsacks = []\n    for _ in range(int(n)):\n        knapsacks.append([int(x) for x in stdin.strip().split()])\n    return''.join([' '.join(map(str, max_value(knapsacks, i))) for i in range(int(k))])\n\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    num_knapsacks = int(stdin.split()[0])\n    num_jewels = int(stdin.split()[1])\n    knapsacks = {}\n    jewels = {}\n    for _ in range(num_knapsacks):\n        knapsacks[int(_)] = [int(_)]\n    for i in range(num_knapsacks):\n        if i < num_knapsacks - 1:\n            knapsacks[i + 1] = []\n        for _ in range(num_jewels):\n            jewels[int(_)] = int(_)\n    for i in range(1, num_jewels + 1):\n        for j in range(num_knapsacks):\n            if i <= knapsacks[j][-1]:\n                knapsacks[j].append(i)\n                break\n        else:\n            knapsacks[j + 1].append(i)\n    max_values = {}\n    for i in range(1, num_knapsacks + 1):\n        max_values[i] = 0\n    for i in range(1, num_knapsacks + 1):\n        for j in range(i):\n            if knapsacks[i][-1] <= knapsacks[j][-1]:\n                max_values[i] = max(max_values[i], knapsacks[i][-1] + max_values[j])\n    #print(max_values)\n    answer = []\n    for i in range(1, num_knapsacks + 1):\n        answer.append(max_values[i])\n    return''.join(map(str, answer))"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    value = []\n    for i in range(n):\n        s, v = stdin.split()\n        s = int(s)\n        v = int(v)\n        value.append((s, v))\n    value.sort(key=lambda x: x[1])\n    dp = [[0 for i in range(k+1)] for j in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if j < value[i-1][0]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-value[i-1][0]] + value[i-1][1])\n    return str(dp[n][k])\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    n = int(input[0])\n    k = int(input[1])\n\n    jewels = [[int(i) for i in input[j].split()] for j in range(n)]\n\n    jewels = sorted(jewels, key=lambda x: x[1])\n\n    cache = []\n    for i in range(len(jewels)):\n        cache.append(jewels[i][1])\n        jewels[i][1] = 0\n\n    dp = [0] * k\n\n    for i in range(k):\n        for j in range(n):\n            if i >= jewels[j][0]:\n                dp[i] = max(dp[i], dp[i - jewels[j][0]] + jewels[j][1])\n\n    return''.join(str(i) for i in dp)\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    knapsacks = dict()\n    items = dict()\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        n, k = list(map(int, line.split()))\n        for i in range(n):\n            s, v = list(map(int, line.split()))\n            if s not in knapsacks:\n                knapsacks[s] = [[v]]\n            else:\n                knapsacks[s].append([v])\n    for k in sorted(knapsacks.keys(), reverse=True):\n        knapsacks[k] = sorted(knapsacks[k], reverse=True)\n        for i in knapsacks[k]:\n            items[tuple(i)] = items.get(tuple(i), 0) + 1\n    items = sorted(items.items(), reverse=True, key=lambda x: x[0])\n    return''.join(f'{item[0][0]} {item[0][1]}' for item in items)"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    jewels = list(map(int, stdin.split()))\n    # Write your code here\n    jewels = sorted(jewels, reverse=True)\n    jewels.append(0)\n    jewels = [(jewels[i], jewels[i + 1]) for i in range(0, len(jewels), 2)]\n    jewels.append((jewels[len(jewels) - 1][0] + jewels[len(jewels) - 1][1], jewels[len(jewels)][0] + jewels[len(jewels)][1]))\n    jewels = sorted(jewels, key=lambda x: x[0])\n    jewels = sorted(jewels, key=lambda x: x[1])\n    for jewel in jewels:\n        print(jewel[0], end=' ')\n    return \"\"\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = sorted([int(x) for x in stdin.split()], reverse=True)\n    dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(k + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = 0\n            elif jewels[i - 1] <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - jewels[i - 1]] + jewels[i - 1])\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return''.join([str(x) for x in dp[n][k]])\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the solution function\n    \"\"\"\n    input_value = stdin.split()\n    max_value = max(map(int, input_value))\n    return \" \".join(map(str, range(1, max_value + 1)))\n"
    },
    {
        "number": 3076,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_jewels, max_size = map(int, stdin.split())\n    jewels = sorted(list(map(int, stdin.split())), reverse=True)\n    k = 0\n    max_value = 0\n    for jewel_size in range(1, max_size + 1):\n        jewel_value = jewels[0]\n        jewel_in_knapsack = 0\n        for jewel_size in range(1, num_jewels + 1):\n            jewel_in_knapsack += jewel_size <= jewel_size\n            jewel_value = max(jewel_value, jewels[jewel_in_knapsack] + jewels[jewel_size])\n            if jewel_size == num_jewels:\n                break\n        if jewel_size == num_jewels and jewel_value > max_value:\n            max_value = jewel_value\n            k = jewel_size\n    return str(k) +'' + str(max_value) +'' + str(jewels[k - 1]) +'' + str(jewels[k]) +'' + str(jewels[k + 1]) +'' + str(jewels[k + 2]) +'' + str(jewels[k + 3])\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(i) for i in stdin.strip().split(' ')]\n    villages = []\n    for _ in range(n):\n        villages.append([int(i) for i in stdin.strip().split(' ')])\n    minions = []\n    for _ in range(m):\n        minions.append([int(i) for i in stdin.strip().split(' ')])\n    res = 0\n    for v in villages:\n        x, y, r = v\n        for m in minions:\n            m_x, m_y, m_r = m\n            if r > m_r:\n                continue\n            if r > abs(m_x - x) + abs(m_y - y):\n                continue\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n    for i in range(n):\n        villages.append([int(stdin.split()[i * 2]), int(stdin.split()[i * 2 + 1])])\n    for i in range(m):\n        minions.append([int(stdin.split()[i * 2 + n]), int(stdin.split()[i * 2 + n + 1])])\n    return str(max(map(lambda x: max(0, r - abs(x[0] - x[1])) / r, villages)))"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_closest_minion(minions: list, center_point: list):\n        closest = -1\n        closest_dist = 20000\n        for i in range(0, len(minions)):\n            dist = manhattan_distance(center_point, minions[i])\n            if dist < closest_dist:\n                closest = i\n                closest_dist = dist\n        return closest\n    n, m, r = stdin.split()\n    n, m, r = int(n), int(m), int(r)\n    villages = []\n    for i in range(0, n):\n        villages.append(list(map(int, stdin.split()[i*2:i*2+2])))\n    minions = []\n    for i in range(0, m):\n        minions.append(list(map(int, stdin.split()[i*2+1:i*2+3])))\n    closest_minion_index = find_closest_minion(minions, villages[0])\n    closest_village = villages[closest_minion_index]\n    if manhattan_distance(villages[0], villages[closest_minion_index]) <= r:\n        return closest_village[0]*100 + closest_village[1]\n    if manhattan_distance(villages[closest_minion_index], villages[0]) <= r:\n        return villages[0][0]*100 + villages[0][1]\n    if manhattan_distance(villages[closest_minion_index], villages[closest_village]) <= r:\n        return villages[closest_village][0]*100 + villages[closest_village][1]\n    i = 1\n    while i < len(villages):\n        # find closest village\n        closest_village = find_closest_minion(minions, villages[i])\n        # find closest minion\n        closest_minion = find_closest_minion(minions, villages[closest_village])\n        # find closest minion\n        closest_minion_dist = manhattan_distance(villages[i], villages[closest_village])\n        closest_minion_dist2 = manhattan_distance(villages[closest_village], villages[i])\n        if closest_minion_dist < r and closest_minion_dist2 <= r:\n            i += 1\n            continue\n        if closest_minion_dist2 > r:\n            closest_village = villages[i]\n        # attack\n        closest_village = villages[closest_village]\n        if manhattan_distance(villages[i], villages[closest_village]) > r:\n            return closest_village[0]*100 + closest_village[1]\n        i += 1\n    return villages[0][0]*100 + villages[0][1]\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = list(map(lambda x: x.strip(), stdin.split('\\n')))\n    lines = list(map(lambda x: x.split(), lines))\n    # return str(solve_first(lines))\n    return str(solve_second(lines))\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    for _ in range(n):\n        villages.append(list(map(int, stdin.split())))\n    minions = []\n    for _ in range(m):\n        minions.append(list(map(int, stdin.split())))\n    minions = sorted(minions, key=lambda x: x[1])\n    for minion in minions:\n        for village in villages:\n            if (minion[0] + minion[1]) ** 2 <= village[0] ** 2 + village[1] ** 2:\n                continue\n            if minion[0] ** 2 + minion[1] ** 2 > (village[0] + village[1]) ** 2 + r:\n                break\n        else:\n            return str(minion[2])\n    return '0'"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n    for i in range(n):\n        villages.append(list(map(int, stdin.split())))\n    for i in range(m):\n        minions.append(list(map(int, stdin.split())))\n    minions.sort(key=lambda x: x[1], reverse=True)\n    for i in range(m):\n        minions[i] = [villages[minions[i][0]-1][0], villages[minions[i][0]-1][1], villages[minions[i][0]-1][2], minions[i][1]]\n    villages = sorted(villages, key=lambda x: x[0])\n    count = 0\n    for village in villages:\n        for minion in minions:\n            if (minion[0] - village[0])**2 + (minion[1] - village[1])**2 <= minion[2]**2:\n                if minion[2] > r:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        points.append(list(map(int, stdin.split())))\n    for _ in range(m):\n        points.append(list(map(int, stdin.split())))\n\n    counter = 0\n    for vx, vy, vr in points:\n        for i in range(n):\n            for j in range(i+1, n):\n                if (i!= j):\n                    dist = abs(vx - points[i][0]) + abs(vy - points[i][1])\n                    dist += abs(vx - points[j][0]) + abs(vy - points[j][1])\n                    dist = min(dist, vr)\n                    if dist <= r:\n                        counter += 1\n                if (i!= j and i!= n-1 and j!= n-1):\n                    dist = abs(vx - points[i][0]) + abs(vy - points[i][1])\n                    dist += abs(vx - points[j][0]) + abs(vy - points[j][1])\n                    dist += abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                    dist = min(dist, vr)\n                    if dist <= r:\n                        counter += 1\n    return str(counter)\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of space-separated integers, each integer representing the location (x, y) and radius of a circle,\n    which denotes an area of effect attack.\n    It determines the maximum number of minions that can be destroyed without\n    intersecting or overlapping with any of the other villages.\n    \"\"\"\n    n, m, r = map(int, stdin.split())\n    villages = []\n    for _ in range(n):\n        villages.append((int(stdin.split()[2 * _]), int(stdin.split()[2 * _ + 1])))\n    minions = []\n    for _ in range(m):\n        minions.append((int(stdin.split()[2 * _ + 1]), int(stdin.split()[2 * _ + 2])))\n    minion_to_circle = {}\n    for minion in minions:\n        minion_to_circle[minion] = Circle(minion, 20000)\n    for village in villages:\n        minion_to_circle[village].add(Village(village))\n    solutions = 0\n    for minion in minions:\n        for circle in minion_to_circle.values():\n            if circle.does_intersect_circle(minion):\n                if circle.does_intersect_circle(village):\n                    solutions += 1\n    return str(solutions)\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    villages = set()\n    for i in range(int(stdin[0])):\n        villages.add((int(stdin[i + 1]), int(stdin[i + 2])))\n    for i in range(int(stdin[int(stdin[1]) + 1])):\n        x, y, radius = stdin[i + 3].split()\n        x = int(x)\n        y = int(y)\n        radius = int(radius)\n        if (x, y) in villages and radius > 0:\n            villages.remove((x, y))\n            radius -= 1\n            while radius > 0:\n                for dx, dy in ((0, -1), (0, 1), (-1, 0), (1, 0), (-1, 1), (1, -1), (-1, -1), (1, 1)):\n                    if -20000 <= x + dx <= 20000 and -20000 <= y + dy <= 20000:\n                        if (x + dx, y + dy) not in villages:\n                            villages.add((x + dx, y + dy))\n                            radius -= 1\n                radius -= 1\n    return len(villages)\n"
    },
    {
        "number": 3077,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x_max, y_max, r_max = map(int, stdin.split())\n    x_min, y_min, r_min = map(int, stdin.split())\n    x_center, y_center, r_center = -20000, -20000, 20000\n    x_radii = (x_min - x_center, x_max - x_center)\n    y_radii = (y_min - y_center, y_max - y_center)\n    r_radii = (r_min - r_center, r_max - r_center)\n    if x_radii[0] * x_radii[1] > 0 and y_radii[0] * y_radii[1] > 0 and r_radii[0] * r_radii[1] > 0:\n        if x_radii[0] == 0:\n            if x_radii[1] == 1 or x_radii[1] == 0:\n                if x_center - r_max < x_min <= x_center:\n                    return 1\n                elif x_center + r_max > x_max:\n                    return 1\n                else:\n                    return 1 + r_max - x_center\n            else:\n                return 1 + r_max - x_center\n        elif x_radii[1] == 0:\n            if x_radii[0] == 1 or x_radii[0] == 0:\n                if x_center - r_max < x_min <= x_center:\n                    return 1\n                elif x_center + r_max > x_max:\n                    return 1\n                else:\n                    return 1 + r_max - x_center\n            else:\n                return 1 + r_max - x_center\n        else:\n            if x_center - r_max < x_min <= x_center or x_center + r_max > x_max:\n                return 1\n            else:\n                return 1 + r_max - x_center\n    elif x_radii[0] == 0 and x_radii[1] == 0:\n        if y_radii[0] == 0:\n            if y_radii[1] == 1 or y_radii[1] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        elif y_radii[1] == 0:\n            if y_radii[0] == 1 or y_radii[0] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        else:\n            if y_center - r_max < y_min <= y_center or y_center + r_max > y_max:\n                return 1\n            else:\n                return 1 + r_max - y_center\n    elif x_radii[1] == 0 and x_radii[0] == 0:\n        if y_radii[0] == 0:\n            if y_radii[1] == 1 or y_radii[1] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        elif y_radii[1] == 0:\n            if y_radii[0] == 1 or y_radii[0] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        else:\n            if y_center - r_max < y_min <= y_center or y_center + r_max > y_max:\n                return 1\n            else:\n                return 1 + r_max - y_center\n    elif x_radii[0] == 0 and x_radii[1] == 0:\n        if y_radii[0] == 0:\n            if y_radii[1] == 1 or y_radii[1] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        elif y_radii[1] == 0:\n            if y_radii[0] == 1 or y_radii[0] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n                elif y_center + r_max > y_max:\n                    return 1\n                else:\n                    return 1 + r_max - y_center\n            else:\n                return 1 + r_max - y_center\n        else:\n            if y_center - r_max < y_min <= y_center or y_center + r_max > y_max:\n                return 1\n            else:\n                return 1 + r_max - y_center\n    elif x_radii[0] == 0 and x_radii[1] == 0:\n        if y_radii[0] == 0:\n            if y_radii[1] == 1 or y_radii[1] == 0:\n                if y_center - r_max < y_min <= y_center:\n                    return 1\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    dp = [0 for _ in range(n+1)]\n    dp[0] = 1\n    \n    for i in range(n):\n        for j in range(i, n):\n            if dp[i] and (arr[i] + dp[j]) <= s:\n                dp[j+1] = 1\n    \n    for i in range(n):\n        print(dp[i])\n    return ''\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = [int(i) for i in stdin.split()]\n    k, k_max = 0, 0\n    result = 0\n    for i in range(N):\n        while k < N and A[k] + A[k] <= S:\n            k_max = max(k_max, k)\n            k += 1\n        if k_max > k:\n            result = max(result, k - k_max)\n        k = 0\n    while k < N and A[k] + A[k] <= S:\n        k_max = max(k_max, k)\n        k += 1\n    if k_max > k:\n        result = max(result, k - k_max)\n    return str(result)\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = sorted(map(int, stdin.splitlines()))\n    ans = -1\n    for i in range(N):\n        l = r = i + 1\n        curr = 0\n        while l <= N and r <= N:\n            if A[l - 1] + A[r - 1] <= S:\n                curr += 1\n            l += 1\n            r += 1\n        if curr > ans:\n            ans = curr\n    return str(ans)"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n\n    for i in range(N - 1, -1, -1):\n        for j in range(i, N + 1):\n            if j == i:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i][j - 1] + 1\n                if A[i - 1] + dp[i][j] > S:\n                    dp[i][j] = 0\n\n    longest = 0\n    index = 0\n\n    for i in range(N, 0, -1):\n        if dp[N][i] > longest:\n            longest = dp[N][i]\n            index = i\n\n    return str(longest)\n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    dp = [[[0 for _ in range(2 * N + 1)] for _ in range(S + 1)] for _ in range(N + 1)]\n\n    for i in range(N + 1):\n        dp[i][0][0] = 1\n\n    for i in range(S + 1):\n        dp[0][i][0] = 0\n\n    for i in range(1, N + 1):\n        for j in range(S + 1):\n            for k in range(1, N + 1):\n                if dp[i][j][k] == 0:\n                    continue\n\n                if j + A[i - 1] <= S:\n                    dp[i][j + A[i - 1]][k] = max(dp[i][j + A[i - 1]][k], dp[i - 1][j][k] + 1)\n\n                if k + A[i - 1] <= 2 * N:\n                    dp[i][j][k + A[i - 1]] = max(dp[i][j][k + A[i - 1]], dp[i - 1][j][k] + 1)\n\n    max_len = 0\n    for i in range(S, N + 1):\n        if dp[-1][-1][i] > max_len:\n            max_len = dp[-1][-1][i]\n\n    return str(max_len) if max_len > 0 else \"0\""
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.strip().split())\n    seq = list(map(int, stdin.strip().split()))\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            if dp[i][j] > s:\n                break\n    print(dp)\n    res = []\n    for i in range(n - 1, -1, -1):\n        res.append(dp[i][n] if dp[i][n] > 0 else 0)\n    return '\\n'.join(map(str, res))\n    "
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = int(stdin.splitlines()[1])\n    a = list(map(int, stdin.splitlines()[2:]))\n    cnt = 0\n    for i in range(n):\n        if a[i] <= s:\n            cnt = max(cnt, dfs(a, i, s, 1, 0))\n    return str(cnt)\n\n\ndef"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N, S = int(stdin[0]), int(stdin[1])\n    A = map(int, stdin[2:])\n    #print(A, N, S)\n    #2 3 5 1 2 1\n    max_length = 0\n    dp = [[0 for i in range(S+1)] for j in range(N+1)]\n    for length in range(N+1):\n        for j in range(S+1):\n            if length == 0:\n                dp[0][j] = 0\n            elif length == 1:\n                dp[1][j] = 1\n            else:\n                dp[length][j] = 1\n                for i in range(1, length):\n                    dp[i][j] = dp[i][j-1]\n                    if j - A[i-1] >= 0:\n                        dp[i][j] = max(dp[i][j], dp[i-1][j-A[i-1]] + 1)\n                dp[length][j] += dp[length-1][j]\n                if dp[length][j] > max_length:\n                    max_length = dp[length][j]\n    return str(max_length)"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, s = [int(i) for i in stdin.split(' ')]\n    nums = [int(i) for i in stdin.split(' ')]\n    dp = [0 for _ in range(n)]\n    for i in range(n):\n        for j in range(i):\n            if nums[i] + nums[j] <= s:\n                dp[i] = max(dp[i], dp[j] + 1)\n    maxlen = 0\n    for i in range(n):\n        maxlen = max(maxlen, dp[i])\n    return str(maxlen)\n    \n"
    },
    {
        "number": 3078,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, S = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    best = 0\n    best_length = 0\n    for i in range(N):\n        lo = i\n        hi = i\n        while lo >= 0 and A[lo] < S:\n            lo -= 1\n        while hi < N and A[hi] < S:\n            hi += 1\n        if lo >= 0 and hi < N:\n            l = hi - lo + 1\n            if l > best_length:\n                best_length = l\n                best = i\n    if best == 0:\n        print(0)\n    else:\n        print(best_length)\n    return ''"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, text = stdin\n\n    n = len(text)\n\n    def beautiful(seq: str) -> bool:\n        return all(x <= seq[y] for x, y in zip(seq, seq[1:]))\n\n    def is_beautiful(seq: str) -> bool:\n        return n - seq.index(max(seq)) == seq.index(min(seq))\n\n    return 'DA' if beautiful(text) and is_beautiful(text) else 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('1\\nne')\n    'NE'\n    >>> solution('2\\nne')\n    'DA'\n    >>> solution('3\\nne')\n    'NE'\n    >>> solution('4\\nne')\n    'NE'\n    '''\n    sequence = stdin.split()\n    player_turn = 0\n    players_words = set()\n    player_word = sequence[player_turn]\n\n    while player_word and player_turn < len(sequence) - 1:\n        player_turn += 1\n        if player_turn % 2 == 0:\n            players_words.add(player_word)\n            player_word = sequence[player_turn]\n        else:\n            if player_word not in players_words:\n                players_words.add(player_word)\n                player_word = sequence[player_turn]\n\n    if player_word:\n        return 'DA' if player_turn % 2 == 0 else 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n < 2:\n        raise ValueError(f'Invalid input, length is less than 2: {n}')\n    if n % 2:\n        raise ValueError(f'Invalid input, length is not even: {n}')\n\n    prev = stdin[0]\n    for i in range(1, n, 2):\n        if stdin[i] > prev:\n            return 'DA'\n        prev = stdin[i]\n    return 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    n = int(stdin.pop(0))\n    seq = stdin.pop(0)\n    if seq[-1] > seq[-2]:\n        return \"DA\"\n    else:\n        return \"NE\""
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = list(stdin.split()[1])\n    h = {}\n    while len(p) > 0:\n        h[p.pop()] = True\n    while len(p) > 0:\n        h[p.pop()] = False\n    v = list(h.keys())\n    v.sort()\n    return 'DA' if h[v[-1]] else 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lst = []\n    for i in range(n):\n        lst.append(stdin[i])\n    lst.sort()\n    for i in range(n - 1):\n        if lst[i] > lst[i + 1]:\n            return \"DA\"\n    return \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    return 'DA' if len(words) > 1 else 'NE'"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = int(stdin.strip()), stdin.strip().split()\n\n    if N == 1:\n        return \"NE\"\n    else:\n        a = list(sequence)\n        index = (N // 2) - 1\n        if N % 2 == 0:\n            return \"DA\" if a[index] > a[index + 1] else \"NE\"\n        else:\n            return \"DA\" if a[index] < a[index + 1] else \"NE\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = list(stdin)\n    count = 0\n    best = None\n    while sequence:\n        if count % 2 == 0:\n            best = sequence[-1]\n        else:\n            best = sequence[0]\n        sequence.remove(best)\n        sequence.append(best)\n        count += 1\n    return \"DA\" if best >= 'a' else \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = stdin.split()\n    word = sequence[0]\n    remaining = sequence[1:]\n\n    if len(word) < len(remaining):\n        word = remaining[0]\n        remaining = remaining[1:]\n\n    for i in range(len(word) - 1, -1, -1):\n        if word[i] > word[i + 1]:\n            word = word[:i] + word[i + 1:]\n            break\n\n    print(word)\n    if len(word) == 0:\n        return \"NE\"\n    return \"DA\" if word[0] > word[-1] else \"NE\"\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = list(map(int, stdin.split()))\n    areas = sorted(list(set([x for x in range(1, n+1)]) - set([y for x in range(1, n+1) for y in range(x, n+1)])))\n    stdout = []\n    for _ in range(q):\n        a, b = list(map(int, stdin.split()))\n        a_ = a - 1\n        b_ = b - 1\n        while areas[a_]!= a:\n            a_ += 1\n        while areas[b_]!= b:\n            b_ += 1\n        print(sum(stdout))\n    return stdout\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    num_n, num_m, num_q = [int(x) for x in stdin.split()]\n    cache = {}\n    def dfs(curr_runs, curr_num_favorite_snack):\n        if curr_runs in cache:\n            return cache[curr_runs]\n        if curr_runs == num_m:\n            cache[curr_runs] = 1\n            return 1\n        curr_num_favorite_snack = curr_num_favorite_snack\n        curr_area_favorite_snack = {}\n        for i in range(curr_runs, num_m):\n            curr_area = i + 1\n            curr_area_favorite_snack[curr_area] = curr_num_favorite_snack\n            curr_num_favorite_snack += 1\n        curr_num_favorite_snack = 0\n        curr_runs = num_m\n        for favorite_snack, favorite_areas in curr_area_favorite_snack.items():\n            curr_area_runs = []\n            for run in range(favorite_areas + 1):\n                curr_area_runs.append(run)\n            curr_num_favorite_snack += dfs(curr_runs, curr_num_favorite_snack)\n        cache[curr_runs] = curr_num_favorite_snack\n        return curr_num_favorite_snack\n    \n    \n    return str(dfs(0, 0))\n    \n    \nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n, m, q = map(int, stdin[0].split())\n    query = [map(int, input().split()) for _ in range(m)]\n    area, result = 1, 0\n    for start, end in query:\n        result += count(start, end, n, area)\n        area = next_area(area, start, end, n)\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    result = 0\n    snack_stands = []\n    area_visited = set()\n    for _ in range(m):\n        x, y = map(int, input().split())\n        snack_stands.append((x, y))\n    for _ in range(q):\n        k, a = map(int, input().split())\n        for i in range(n):\n            if i + k <= n:\n                if i + a in area_visited:\n                    result -= 1\n                    break\n                else:\n                    if i + k in snack_stands:\n                        area_visited.add(i + k)\n                        break\n    print(result)\n\n\nsolution('''5 10 4\n1 2\n1 3\n2 4\n3 4\n1 1 4\n2 1 4\n1 1 3\n2 2 3 2''')"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n, m, q = map(int, stdin.pop(0).split())\n    areas = list(map(int, stdin.pop(0).split()))\n    guests = {}\n    for i in range(m):\n        a, b = map(int, stdin.pop(0).split())\n        if b not in guests:\n            guests[b] = a\n        if a not in guests:\n            guests[a] = b\n    snacks = {}\n    for i in range(n + 1):\n        if i in guests:\n            snacks[i] = snacks.get(i, set())\n            snacks[i].add(guests[i])\n    count = 0\n    for i in range(1, n + 1):\n        if i not in guests:\n            continue\n        if i in snacks:\n            snacks[i].update(snacks[i])\n        snacks[i] = {k for k in snacks[i] if k in snacks}\n        count += len(snacks[i])\n    return str(count)\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def solve(m, q):\n        if m == 0:\n            return '0'\n        elif m == 1:\n            return '1'\n        elif q == 1:\n            return '2'\n        else:\n            memo = {}\n            s = int(stdin.split()[0])\n            k = int(stdin.split()[1])\n            if k in memo:\n                return str(memo[k])\n            elif s == 0:\n                return str(0)\n            elif s == 1:\n                return str(1)\n            elif s < 0:\n                return str(0)\n            elif s == 1:\n                return str(1)\n            elif s > 0:\n                return solve(s, q) + '1'\n            else:\n                return \"0\"\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the the problem and\n    returns the solution as a single line of text.\n    \"\"\"\n\n    n, m, q = map(int, stdin.split())\n    results = []\n\n    for i in range(1, n + 1):\n        if i not in results:\n            results.append(i)\n\n    for _ in range(q):\n        x, y = map(int, input().split())\n        if x!= y:\n            results[x - 1] = y\n\n    ans = sum(results)\n\n    return str(ans)\n"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \" \".join(map(str, count_ways(stdin)))\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    f = list(map(lambda x: int(x), stdin.split()))\n    n, m, q = f[0], f[1], f[2]\n    g = [[] for _ in range(n)]\n    for i in range(1, m + 1):\n        f = list(map(lambda x: int(x) - 1, stdin.split()))\n        g[f[0]].append(f[1])\n    d = defaultdict(list)\n    for j in range(n):\n        d[j + 1].append(j + 1)\n    q_v = defaultdict(list)\n    for _ in range(q):\n        k, x = list(map(int, stdin.split()))\n        q_v[k] = x\n        for k, v in d.items():\n            if k in q_v.keys():\n                if v!= q_v[k]:\n                    d[k] = v\n    q_v_keys = list(q_v.keys())\n    q_v_values = list(q_v.values())\n    q_v_values = sorted(q_v_values, key=lambda x: x)\n    ans = 1\n    for i in range(len(q_v_keys)):\n        if q_v_values[i] in q_v_keys:\n            q_v_keys.remove(q_v_values[i])\n        else:\n            q_v_keys.append(q_v_values[i])\n        for j in q_v_keys:\n            ans *= len(d[j])\n            if d[j]!= []:\n                d[j].sort(key=lambda x: x + 1)\n    return str(ans)"
    },
    {
        "number": 3080,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    run_map = {}\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        run_map[(x, y)] = run_map.get((x, y), set())\n        run_map[(x, y)].add((x, y + 1))\n        run_map[(x, y + 1)].add((x, y))\n    # print(run_map)\n    res = 0\n    for query in map(int, stdin.split()):\n        q_map = {}\n        stack = [(1, 1)]\n        while stack:\n            area, found = stack.pop()\n            if (area, found) in q_map:\n                continue\n            q_map[(area, found)] = q_map.get((area, found), 0) + 1\n            for run in run_map.get((area, found), []):\n                stack.append((run, found + 1))\n        # print(q_map)\n        res += sum(q_map.values())\n        # print(q_map)\n    return str(res)\n\n\nprint(solution(\"\"\"5 3 4\n1 2\n1 3\n2 4\n3 4\n1 1 4\"\"\"), \"2\")\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # read in input, split by spaces\n    n, m = map(int, stdin.split())\n    data = stdin.split()\n\n    # create two arrays: one to store # of minutes to get to each airport, and the second to store # of minutes between each flight\n    travel_time = [0]*(n)\n    for i in range(m):\n        departure, destination, time = map(int, data[i].split())\n        travel_time[departure] = travel_time[departure] + time\n        travel_time[destination] = travel_time[destination] + time\n\n    # sort the travel times for easier comparison\n    travel_time.sort()\n\n    # variable to keep track of the minimum number of planes required to get to each airport\n    min_planes = 0\n\n    for i in range(n):\n        # if we are still not at the first airport, we need to look at the previous airport\n        if i > 0:\n            # if the travel time between our current airport and the previous airport is greater than 0,\n            # we need to add 1 to the number of planes to get to the current airport\n            if travel_time[i] - travel_time[i-1] > 0:\n                min_planes = min_planes + 1\n    return str(min_planes)"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flights = []\n    for _ in range(n):\n        flights.append(tuple(map(int, stdin.split())))\n    flights.sort()\n\n    # find the min number of planes needed\n    min_planes = 1\n    last_start = 0\n    last_end = 0\n    for _, start, end in flights:\n        if start!= last_start and end!= last_end:\n            min_planes += 1\n            last_start = start\n            last_end = end\n    return str(min_planes)"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    time = list(map(int, stdin.split()))\n    dp = [[float(\"inf\")] * (n + 1) for _ in range(n + 1)]\n    for k in range(1, n + 1):\n        dp[k][k] = 0\n    for k in range(1, n + 1):\n        for i in range(k, n + 1):\n            dp[i][k] = min(dp[i][k], dp[i][k - 1] + time[k - 1])\n    return str(min(dp[n][n], dp[n][n - 1]))"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of N numbers and prints the minimum number of planes necessary to fly all of the flights.\n    \"\"\"\n    #\n    #  Initialize the data structures used to store the required number of planes\n    #  and the number of flights per flight needed.\n    #\n    n = int(stdin[0])\n    m = int(stdin[1])\n    flight_time = [int(i) for i in stdin[2].split()]\n    f_needed = defaultdict(int)\n    plane_num = 0\n    #\n    #  Store the sum of the times each flight needs to fly.\n    #\n    for flight in stdin[2:]:\n        i, j, t = flight.split()\n        f_needed[(i, j)] = int(t)\n        f_needed[(j, i)] = int(t)\n    #\n    #  Populate the list of flights with the current times.\n    #\n    curr_flights = [0] * n\n    for i in range(n):\n        curr_flights[i] = flight_time[i]\n    #\n    #  Initialize the number of planes needed and the max flights needed.\n    #\n    num_planes_needed = 1\n    max_flights_needed = f_needed[(0, 1)]\n    #\n    #  The main while loop of the function.\n    #\n    while num_planes_needed < m:\n        #\n        #  The main while loop of the function.\n        #\n        for i in range(n):\n            #\n            #  If the current flight can be satisfied with the planes already\n            #  in the container, exit the while loop.\n            #\n            if curr_flights[i] >= max_flights_needed:\n                #\n                #  If the max flights needed is not the same as the max number\n                #  of flights needed so far, update the max flights needed.\n                #\n                if curr_flights[i] > max_flights_needed:\n                    max_flights_needed = curr_flights[i]\n                break\n            #\n            #  If the current flight can be satisfied with the planes already\n            #  in the container, exit the while loop.\n            #\n            #  If the current flight cannot be satisfied with the planes already\n            #  in the container, add the current flight to the container.\n            #\n            if curr_flights[i] + f_needed[(i, j)] <= max_flights_needed:\n                #\n                #  If the max flights needed is not the same as the max number\n                #  of flights needed so far, update the max flights needed.\n                #\n                if curr_flights[i] + f_needed[(i, j)] > max_flights_needed:\n                    max_flights_needed = curr_flights[i] + f_needed[(i, j)]\n                curr_flights[i] += f_needed[(i, j)]\n                num_planes_needed += 1\n                break\n    #\n    #  Return the minimum number of planes needed.\n    #\n    return str(min(num_planes_needed, m))\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split(' '))\n    time = [list(map(int, stdin.strip().split(' '))) for _ in range(n)]\n    print(time)\n\n    for i in range(n):\n        time[i][i] = 0\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            time[i][j] = time[i][j] + max(time[i][k] + time[k][j] for k in range(n) if k!= i and k!= j)\n    \n    for i in range(m):\n        s, f, t = map(int, stdin.strip().split(' '))\n        print(s, f, t)\n        \n    #!!! PUT YOUR CODE HERE!!!\n    # Write your code here"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flights = []\n    for _ in range(n):\n        flights.append(list(map(int, stdin.split())))\n    flights.sort(key=lambda x: x[0])\n    arrival = 0\n    passengers = 0\n    for a, d, t in flights:\n        while passengers >= m:\n            if arrival < a and d == arrival:\n                arrival += t\n                passengers -= 1\n            else:\n                arrival = max(arrival, d)\n                passengers += 1\n    return passengers\n\nprint(solution(input()))\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return(f'{solution_recursive(list(map(int,stdin.split())))}')\n\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    flights = stdin.split()\n    scheduled = {}\n    for flight in flights:\n        i, f, t = flight.split()\n        i = int(i)\n        f = int(f)\n        t = int(t)\n        if f in scheduled:\n            scheduled[f] += t\n        else:\n            scheduled[f] = t\n    unscheduled = []\n    for flight in flights:\n        i, f, t = flight.split()\n        i = int(i)\n        f = int(f)\n        t = int(t)\n        unscheduled.append((t, i, f))\n    unscheduled.sort(key=lambda x: (x[0], -x[1]))\n    # print(unscheduled)\n    scheduled_sum = 0\n    scheduled_sum = sum(scheduled.values())\n    unscheduled_sum = 0\n    unscheduled_sum = sum([t for t, i, f in unscheduled])\n    difference = unscheduled_sum - scheduled_sum\n    # print(difference)\n    return str(min(difference, unscheduled_sum))\n"
    },
    {
        "number": 3081,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, m = map(int, stdin.split())\n    flights = [[] for _ in range(s + 1)]\n    for _ in range(m):\n        a, b, t = map(int, stdin.split())\n        flights[a].append((b, t))\n        flights[b].append((a, t))\n\n    min_planes = 0\n    for a, fs in flights:\n        inspection_time = 0\n        if len(fs) == 0:\n            continue\n        elif len(fs) == 1:\n            inspection_time = fs[0][1]\n        elif len(fs) == 2:\n            inspection_time = max(fs[0][1], fs[1][1])\n        else:\n            inspection_time = min(fs[0][1], fs[1][1])\n            inspection_time = min(inspection_time, fs[2][1])\n        min_planes += 1 + inspection_time\n    return str(min_planes)\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse data\n    lines = stdin.split('\\n')\n    d, w = map(int, lines[0].split())\n    dishes = []\n    for i in range(1, d + 1):\n        dishes.append(lines[i])\n    if dishes[0][0] == 'D':\n        tastiness = map(int, dishes[0][1:].split())\n        decay = map(int, dishes[1].split())\n        # compute total\n        total = 0\n        for i in range(len(dishes)):\n            if i == 0:\n                continue\n            elif i == 1:\n                total += (tastiness[i] - (tastiness[i] - (tastiness[i - 1] - (tastiness[i - 1] * decay[i - 1])))) * w\n            else:\n                total += (tastiness[i] - (tastiness[i] - (tastiness[i - 1] - (tastiness[i - 1] * decay[i - 1])))) * w\n        return round(total, 6)\n    elif dishes[0][0] == 'C':\n        tastiness = map(int, dishes[0][1:].split())\n        decay = map(int, dishes[1].split())\n        total = 0\n        for i in range(len(dishes)):\n            if i == 0:\n                continue\n            elif i == 1:\n                total += (tastiness[i] - (tastiness[i] - (tastiness[i - 1] - (tastiness[i - 1] * decay[i - 1])))) * w\n            else:\n                total += (tastiness[i] - (tastiness[i] - (tastiness[i - 1] - (tastiness[i - 1] * decay[i - 1])))) * w\n        return round(total, 6)\n\n\ndef"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    dishes_weight, dishes_tastiness, dishes_decay = stdin.split()\n    dishes_weight = int(dishes_weight)\n    dishes_tastiness = int(dishes_tastiness)\n    dishes_decay = int(dishes_decay)\n\n    discrete_dishes_tastiness = []\n    continuous_dishes_tastiness = []\n    discrete_dishes_weight = []\n    continuous_dishes_weight = []\n    for i in range(dishes_weight + 1):\n        if i == 0:\n            discrete_dishes_tastiness.append(0)\n            discrete_dishes_weight.append(i)\n        else:\n            discrete_dishes_tastiness.append(dishes_tastiness * (i - 1) + (dishes_weight - i) * dishes_tastiness)\n            discrete_dishes_weight.append(i)\n    for i in range(dishes_weight):\n        continuous_dishes_tastiness.append(0)\n        continuous_dishes_weight.append(i + 1)\n    for i in range(1, dishes_weight + 1):\n        for j in range(dishes_weight - i + 1):\n            continuous_dishes_tastiness[i] += continuous_dishes_tastiness[i - 1] + dishes_tastiness * (i - j)\n            continuous_dishes_weight[i] += continuous_dishes_weight[i - 1] + dishes_weight - j\n    discrete_dishes_tastiness = discrete_dishes_tastiness[dishes_weight:]\n    continuous_dishes_tastiness = continuous_dishes_tastiness[dishes_weight:]\n    discrete_dishes_weight = discrete_dishes_weight[dishes_weight:]\n    continuous_dishes_weight = continuous_dishes_weight[dishes_weight:]\n\n    totals_discrete = sum(discrete_dishes_tastiness)\n    totals_continuous = sum(continuous_dishes_tastiness)\n    totals = totals_discrete + totals_continuous\n    if totals == dishes_weight:\n        return totals\n    if totals_discrete > totals_continuous:\n        return \"impossible\"\n    decays = []\n    for i in range(dishes_weight):\n        decays.append(dishes_decay * discrete_dishes_weight[i])\n    decays.append(dishes_decay * continuous_dishes_weight[-1])\n    decays.sort(reverse=True)\n    best_decay = 0\n    for i in range(dishes_weight):\n        best_decay = decays[i] + best_decay\n    return str(best_decay)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.split())\n    discrete = []\n    continuous = []\n    sum_discrete = 0\n    sum_continuous = 0\n    for _ in range(d):\n        _, weight, tastiness, _ = map(int, stdin.split())\n        discrete.append([tastiness, weight])\n        sum_discrete += tastiness\n    for _ in range(w):\n        continuous.append(stdin.split())\n        sum_continuous += int(continuous[-1][0])\n    if sum_discrete == sum_continuous:\n        return \"impossible\"\n    if sum_discrete > sum_continuous:\n        continuous.sort()\n        continuous = [float(x) for x in continuous]\n        return \"%.2f\" % sum_continuous\n    discrete.sort()\n    discrete = [float(x) for x in discrete]\n    return \"%.2f\" % sum_discrete"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, w = [int(x) for x in stdin.split()]\n    dishes = stdin.splitlines()\n    best = float('-inf')\n    for x in range(len(dishes)):\n        if dishes[x][0].isdigit():\n            if 'D' in dishes[x]:\n                tastiness, decay = [int(y) for y in dishes[x].split() if y.isdigit()]\n                best = max(best,tastiness - (x+1)*decay)\n            else:\n                tastiness = int(dishes[x].split()[0])\n                best = max(best,tastiness)\n    return str(best)\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def parse(line: str) -> tuple[int, int, int, float]:\n        d, w, *t, _, _ = line.split()\n        return int(d), int(w), int(t[0]), float(t[1])\n    dishes: list[tuple[int, int, int, float]] = []\n    for line in stdin.splitlines():\n        dishes.append(parse(line))\n    # write your code here\n    return answer"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    dishes, weight = stdin.split('\\n')\n    dishes = dishes.split('D')\n    tastinesses = []\n    for dish in dishes:\n        info = dish.split(' ')\n        if len(info) == 2:\n            # discrete\n            w, t = int(info[0]), int(info[1])\n            tastinesses.append(t - (t - 1) * t / w)\n        else:\n            # continuous\n            t, d = int(info[0]), int(info[1])\n            tastinesses.append(t - d * t / d)\n    tastiness = sum(tastinesses)\n    weight = int(weight)\n    return '%.2f' % (tastiness * weight / 10000)"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    weight_total = int(input_list[0])\n    dish_list = input_list[1:]\n\n    tastiness_matrix = []\n    for i in range(0, len(dish_list)):\n        row = []\n        dish = dish_list[i]\n        dish_tastiness_list = dish.split()\n        tastiness_list = []\n        for j in range(0, len(dish_tastiness_list)):\n            if dish_tastiness_list[j].isnumeric():\n                tastiness_list.append(int(dish_tastiness_list[j]))\n            else:\n                if dish_tastiness_list[j].isalpha():\n                    if dish_tastiness_list[j] == \"C\":\n                        tastiness_list.append(1)\n                    if dish_tastiness_list[j] == \"D\":\n                        tastiness_list.append(1.5)\n                else:\n                    raise Exception(\"Invalid Dish\")\n        tastiness_matrix.append(tastiness_list)\n\n    d_dict = dict()\n    for i in range(0, len(tastiness_matrix)):\n        d_dict[i] = {\n            \"tastiness\": sum(tastiness_matrix[i]),\n            \"d\": tastiness_matrix[i]\n        }\n\n    t_dict = dict()\n    for i in range(0, len(dish_list)):\n        t_dict[i] = {\n            \"tastiness\": tastiness_matrix[i][0],\n            \"d\": [i]\n        }\n\n    deli_matrix = []\n    for i in range(1, len(tastiness_matrix)):\n        t = tastiness_matrix[i]\n        t_upd = t.copy()\n        for j in range(0, len(t)):\n            if j == 0:\n                t_upd[j] = t_upd[j] - t[j]\n            else:\n                t_upd[j] = t_upd[j] - t[j] - t[j - 1]\n        deli_matrix.append(t_upd)\n\n    deli_dict = dict()\n    for i in range(0, len(dish_list)):\n        deli_dict[i] = {\n            \"deli\": deli_matrix[i],\n            \"tastiness\": tastiness_matrix[i][0],\n            \"d\": [i]\n        }\n\n    final_tastiness = []\n    for i in range(0, len(dish_list)):\n        final_tastiness.append([])\n        final_tastiness[i].append(d_dict[i])\n        final_tastiness[i].append(t_dict[i])\n        final_tastiness[i].append(deli_dict[i])\n        final_tastiness[i].append(t_dict[i][\"tastiness\"] + deli_dict[i][\"deli\"])\n\n    for i in range(0, len(dish_list)):\n        if final_tastiness[i][-1] == weight_total:\n            return \"Impossible\"\n        final_tastiness[i].sort(key=lambda x: x[2], reverse=True)\n        deli_copy = final_tastiness[i][1][\"deli\"].copy()\n        deli_copy.sort()\n        deli_copy.reverse()\n        deli_copy_set = set(deli_copy)\n        deli_copy_list = list(deli_copy_set)\n        deli_copy_list.sort()\n        deli_copy_list.reverse()\n        deli_copy_list = [\"{}\".format(int(x)) for x in deli_copy_list]\n        deli_copy = \" \".join(deli_copy_list)\n        final_tastiness[i][1][\"deli\"] = deli_copy\n        final_tastiness[i][1][\"tastiness\"] = final_tastiness[i][1][\"tastiness\"] + int(final_tastiness[i][1][\"deli\"])\n\n    final_"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    dishes = stdin.splitlines()\n    dish_index = 0\n    current_dish = dishes[dish_index]\n    while dish_index < len(dishes):\n        if not current_dish.startswith(\"D \"):\n            dish_index += 1\n            current_dish = dishes[dish_index]\n        else:\n            current_dish = dishes[dish_index].split()\n            try:\n                dish_name = int(current_dish[0])\n                dish_weight = int(current_dish[1])\n                dish_taste = int(current_dish[2])\n                dish_decay = int(current_dish[3])\n            except:\n                return \"Impossible\"\n            current_dish = dishes[dish_index + 1]\n            dish_index += 1\n            while current_dish.startswith(\"C \"):\n                current_dish = dishes[dish_index].split()\n                try:\n                    dish_name = int(current_dish[0])\n                    dish_weight = int(current_dish[1])\n                    dish_taste = int(current_dish[2])\n                    dish_decay = int(current_dish[3])\n                except:\n                    return \"Impossible\"\n                dish_index += 1\n            break\n    dish_index += 1\n    total_tastiness = 0\n    while dish_index < len(dishes):\n        current_dish = dishes[dish_index]\n        if current_dish.startswith(\"D \"):\n            dish_index += 1\n            continue\n        elif current_dish.startswith(\"C \"):\n            dish_index += 1\n            continue\n        else:\n            dish_index += 1\n            return \"Impossible\"\n    while dish_index < len(dishes):\n        current_dish = dishes[dish_index]\n        if current_dish.startswith(\"D \"):\n            current_dish = dishes[dish_index].split()\n            try:\n                dish_name = int(current_dish[0])\n                dish_weight = int(current_dish[1])\n                dish_taste = int(current_dish[2])\n                dish_decay = int(current_dish[3])\n            except:\n                return \"Impossible\"\n            current_dish = dishes[dish_index + 1]\n            dish_index += 1\n            while current_dish.startswith(\"C \"):\n                current_dish = dishes[dish_index].split()\n                try:\n                    dish_name = int(current_dish[0])\n                    dish_weight = int(current_dish[1])\n                    dish_taste = int(current_dish[2])\n                    dish_decay = int(current_dish[3])\n                except:\n                    return \"Impossible\"\n                dish_index += 1\n            break\n        else:\n            dish_index += 1\n            return \"Impossible\"\n    while dish_index < len(dishes):\n        current_dish = dishes[dish_index]\n        if current_dish.startswith(\"D \"):\n            current_dish = dishes[dish_index].split()\n            try:\n                dish_name = int(current_dish[0])\n                dish_weight = int(current_dish[1])\n                dish_taste = int(current_dish[2])\n                dish_decay = int(current_dish[3])\n            except:\n                return \"Impossible\"\n            current_dish = dishes[dish_index + 1]\n            dish_index += 1\n            while current_dish.startswith(\"C \"):\n                current_dish = dishes[dish_index].split()\n                try:\n                    dish_name = int(current_dish[0])\n                    dish_weight = int(current_dish[1])\n                    dish_taste = int(current_dish[2])\n                    dish_decay = int(current_dish[3])\n                except:\n                    return \"Impossible\"\n                dish_index += 1\n            break\n        else:\n            dish_index += 1\n            return \""
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_line(line: str) -> List[str]:\n        taste, weight = line.split()\n        weight, taste = int(weight), int(taste)\n        return taste, weight\n\n    dishes, _, weight = stdin.splitlines()\n    dishes, weight = list(map(parse_line, dishes.split('\\n'))), int(weight)\n    dishes = {dish_name: {'tastiness': 0, 'decay': 0} for dish_name in dishes}\n    for dish_name, dish_info in dishes.items():\n        for i in range(1, len(dish_info)):\n            if dish_info['tastiness'] == 0:\n                dish_info['tastiness'] += (dish_info['weight'] - (i - 1)) * dish_info['decay']\n            elif dish_info['decay'] == 0:\n                dish_info['decay'] += (dish_info['tastiness'] - (i - 1)) * dish_info['weight']\n    for dish_name, dish_info in dishes.items():\n        if dish_info['decay'] == 0:\n            return 'impossible'\n    return str(max(dish_info['tastiness'] for dish_info in dishes.values()))\n"
    },
    {
        "number": 3082,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    dishes, total_weight = map(int, stdin.strip().split())\n    cont_weight = 0\n    discrete_weight = 0\n    discrete_tastiness = 0\n    cont_tastiness = 0\n    for _ in range(dishes):\n        line = stdin.readline().strip()\n        if line.startswith(\"D\"):\n            _, dish_weight, dish_tastiness, dish_decay = map(int, line.split())\n            discrete_weight += dish_weight\n            discrete_tastiness += dish_tastiness - (dishes - 1) * dish_decay\n        else:\n            _, cont_tastiness, cont_decay = map(int, line.split())\n            cont_weight += cont_tastiness\n            cont_tastiness += cont_weight * cont_decay\n    if cont_weight > total_weight:\n        return \"impossible\"\n    return str(discrete_weight * discrete_tastiness + cont_weight * cont_tastiness)\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    The goal of this problem is to find the number of common songs.\n    \n    Given $N$ songs, the task is to find the number of common songs and the order of play.\n    \n    The input to the problem is the songs in the playlist.\n    \n    The order of play is an arbitrary ordering of the songs.\n    \n    For example, given the playlist $[(a, 2), (b, 1), (c, 2), (d, 1), (e, 1), (f, 1), (g, 2), (h, 0), (i, 1), (j, 1)]$ the output should be $4, 1 3 2 7 6 5 4 2 8 5 2 6 1 4 7 6 5 2 4 3 7 6 5 2 3 2 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7 6 5 2 4 3 7"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    mylist = []\n    for i in stdin:\n        mylist.append(list(map(int, i.split())))\n    mylist = sorted(mylist, key=lambda x: x[0])\n    n = len(mylist)\n    for i in range(n - 1):\n        if mylist[i][1] >= mylist[i + 1][1]:\n            return \"fail\"\n    res = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if mylist[i][1] + mylist[j][1] >= mylist[i][0] + mylist[j][0]:\n                res.append(mylist[i][1])\n                res.append(mylist[j][1])\n                break\n    if len(res) > 1:\n        return str(res[0]) + \" \" + str(res[1])\n    else:\n        return \"fail\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    songs = {int(line) for line in stdin.splitlines()}\n    songs = sorted(songs)\n    previous_song = None\n    for i in range(len(songs) - 1):\n        if songs[i + 1] - songs[i] == 1:\n            previous_song = songs[i]\n        elif songs[i + 1] - songs[i] > 1 and previous_song is not None and (songs[i + 1] - songs[i] + 1) % previous_song == 0:\n            songs.remove(songs[i])\n        else:\n            previous_song = None\n    if len(songs) > 8:\n        return \"fail\"\n    if len(songs) == 9:\n        return str(sorted(songs))\n    return \"fail\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    d = {str(i): i for i in range(1, n + 1)}\n    a = set()\n    ans = []\n    for i in range(n):\n        d = {str(j): j for j in range(1, n + 1)}\n        a.add(d[stdin[i]])\n    for i in range(1, n + 1):\n        if i not in a:\n            ans.append(i)\n    if len(ans) == 0:\n        return \"fail\"\n    else:\n        return''.join([str(i) for i in ans])\n\n\nprint(solution(input()))\n\n'''\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    if n < 1 or n > 100:\n        return \"fail\"\n    songs = []\n    songs_scores = {}\n    for i in range(n):\n        songs.append(stdin.split(\"\\n\")[i + 1].split())\n        songs_scores[songs[i][0]] = int(songs[i][1])\n        if len(songs[i]) == 3:\n            songs_scores[songs[i][2]] = int(songs[i][1])\n    songs_scores = list(songs_scores.items())\n    songs_scores.sort(key=lambda x: x[1], reverse=True)\n    for i in range(n):\n        songs_scores[i] = songs_scores[i][0]\n    songs_scores.reverse()\n    for i in range(n):\n        songs_scores.append(songs_scores[i])\n    for i in range(n):\n        if songs_scores[i] in songs_scores[i + 1:]:\n            return \"fail\"\n    result = \"\"\n    for i in range(n):\n        result += str(songs_scores[i]) + \" \"\n    return result"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split()[0])\n    a, b, c = map(lambda s: map(int, stdin.split()[s].split(' ')), range(1, 4))\n    songs = [a[0]]\n    if (not all(map(lambda x: x[0] - songs[-1][0] >= 0, a)) or\n            not all(map(lambda x: x[0] - songs[-1][0] >= 0, b)) or\n            not all(map(lambda x: x[0] - songs[-1][0] >= 0, c))):\n        return 'fail'\n    for song in a[1:]:\n        if song[0] - songs[-1][0] < 0:\n            songs.append(song)\n        else:\n            while songs and songs[-1][0] > song[0]:\n                songs.pop()\n            songs.append(song)\n    for song in b:\n        if song < songs[-1][1]:\n            songs.append(song)\n        else:\n            while songs and songs[-1][1] > song:\n                songs.pop()\n            songs.append(song)\n    for song in c:\n        if song < songs[-1][2]:\n            songs.append(song)\n        else:\n            while songs and songs[-1][2] > song:\n                songs.pop()\n            songs.append(song)\n    return''.join(map(str, songs))\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    songs = []\n    for _ in range(n):\n        a, b, c = stdin.split()\n        songs.append((a, int(b), int(c)))\n    songs.sort(key=lambda x: x[1], reverse=True)\n    chosen = {}\n    for song in songs:\n        if song[1] in chosen:\n            continue\n        for s in range(song[1], n + 1):\n            if s not in chosen:\n                break\n        else:\n            return song[0]\n    return 'fail'\n"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def play(song_list, count):\n        songs = set(song_list)\n        songs_to_play = set()\n        if len(songs_to_play) == len(songs):\n            return songs_to_play\n        song_num = 0\n        while len(songs_to_play) < len(songs):\n            if song_num not in songs:\n                return None\n            for i, s in enumerate(song_list):\n                if s == song_num and count[i] > 0:\n                    count[i] -= 1\n                    songs_to_play.add(song_num)\n                    songs.discard(song_num)\n                    break\n            song_num += 1\n        return songs_to_play\n    def get_song_list(num):\n        song_list = []\n        song_count = [0] * len(num)\n        for i in range(len(num)):\n            song_list.append([i + 1, num[i]])\n            song_count[i] = num[i]\n        return song_list, song_count\n    song_list, count = get_song_list(list(map(int, stdin.split('\\n'))))\n    for i in range(len(song_list)):\n        song_list[i][1] = song_list[i][1] - 1\n    songs = play(song_list, count)\n    if songs is None:\n        return \"fail\"\n    else:\n        return '\\n'.join(map(str, songs))\n\nprint(solution(input()))\n\"\"\"\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    songs = []\n    for _ in range(n):\n        artist, n_songs = stdin.strip().split()\n        songs.append((artist, int(n_songs)))\n    songs.sort()\n    prev = 0\n    res = []\n    for song in songs:\n        if prev + 1!= song[1]:\n            return 'fail'\n        prev = song[1]\n        res.append(song[0])\n    return''.join(map(str, res))"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    for _ in range(4):\n        stdin, stdout = stdin.split('\\n')\n        if stdout == '00:00':\n            ans += 1\n            stdout = stdout.split(' ')\n            if stdout[0] == stdout[1]:\n                stdout[0] = str(int(stdout[0]) - 1)\n            else:\n                stdout[0] = str(int(stdout[0]) + 1)\n            stdout =''.join(stdout)\n        print(stdout)\n    return ans\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    hour = int(stdin.split(':')[0])\n    minute = int(stdin.split(':')[1])\n    input_list = []\n    for i in range(hour, 24):\n        for j in range(minute, 60):\n            input_list.append(f'{i}:{j}')\n    output_list = []\n    for i in range(hour, 24):\n        for j in range(minute, 60):\n            if i == hour and j == minute:\n                output_list.append(stdin)\n                continue\n            elif i == hour and j > minute:\n                output_list.append(f'{i}:{j - 1}')\n            elif i < hour and j == minute:\n                output_list.append(f'{i + 1}:{j}')\n            elif i == hour and j < minute:\n                output_list.append(f'{i}:{j + 1}')\n            elif i < hour and j > minute:\n                output_list.append(f'{i + 1}:{j - 1}')\n    return len(set(input_list))"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # initializing clock\n    hour = 0\n    minute = 0\n\n    # initializing output\n    output = ''\n    \n    # looping over input\n    for time in stdin.split():\n        # checking the clock hour\n        if time[0] == '0' and len(time) == 3:\n            hour = 0\n        elif int(time[0]) < 0 or int(time[0]) > 23:\n            continue\n        else:\n            hour = int(time[0])\n\n        # checking the clock minute\n        if time[1] == '0' and len(time) == 3:\n            minute = 0\n        elif int(time[1]) < 0 or int(time[1]) > 59:\n            continue\n        else:\n            minute = int(time[1])\n\n        # checking if the hour is changed\n        if int(time[0])!= hour:\n            output += '{0}:{1}:{2}\\n'.format(hour, '9' * (2 - len(str(hour))), '0' * (2 - len(str(minute))))\n            hour = int(time[0])\n        # checking if the minute is changed\n        if int(time[1])!= minute:\n            output += '{0}:{1}:{2}\\n'.format(hour, '9' * (2 - len(str(minute))), '0' * (2 - len(str(minute))))\n            minute = int(time[1])\n        # checking if the minute is changed\n        if int(time[2])!= minute:\n            output += '{0}:{1}:{2}\\n'.format(hour, '9' * (2 - len(str(minute))), '0' * (2 - len(str(minute))))\n        \n    return output\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    counter = 0\n    for line in stdin.splitlines():\n        currentTime = line.split(\":\")\n        hour = int(currentTime[0])\n        minute = int(currentTime[1])\n        desiredTime = hour * 100 + minute\n        currentTime = (hour * 100 + minute) // 1000\n        increase = (desiredTime - currentTime) // 100\n        if increase > 0:\n            hour += increase\n        elif increase < 0:\n            hour -= increase\n        hour = hour % 24\n        minute = (desiredTime - currentTime) % 100\n        if minute > 0:\n            minute -= 1\n        else:\n            minute = 59\n        desiredTime = hour * 100 + minute\n        desiredTime = desiredTime // 1000\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime -= 1\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime = desiredTime // 100\n        desiredTime += 1\n        desiredTime = desiredTime % 100\n        desiredTime ="
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    times_seen = {}\n    for line in stdin.splitlines():\n        time = line.split(\":\")\n        if (time[0] == \"00\"):\n            times_seen[time[1]] = [time[2], \"00:00\"]\n        else:\n            times_seen[time[1]] = [time[2], time[1]]\n    clock_state = True\n    clock_time = times_seen[list(times_seen.keys())[0]]\n    for i in range(1,len(list(times_seen.keys()))):\n        current_time = times_seen[list(times_seen.keys())[i]]\n        if clock_time == current_time:\n            clock_state = True\n        else:\n            clock_state = False\n            for j in range(1, len(current_time)):\n                if clock_time[j] == \"9\":\n                    clock_time[j] = \"0\"\n                elif clock_time[j] == \"0\":\n                    clock_time[j] = \"9\"\n            clock_time = list(map(lambda x: int(x), clock_time))\n            for k in range(1, len(current_time)):\n                clock_time[k] -= 1\n                if clock_time[k] == -1:\n                    clock_time[k] = 59\n            clock_time = list(map(lambda x: str(x), clock_time))\n            clock_time = \":\".join(clock_time)\n            print(str(i) + \" \" + clock_time)\n            break\n    return(str(len(list(times_seen.keys()))))"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    stdin = stdin[1:]\n    times = {}\n    for line in stdin:\n        time = line.split(':')\n        hour = int(time[0])\n        minute = int(time[1])\n        if hour in times:\n            times[hour].append(minute)\n        else:\n            times[hour] = [minute]\n        #print(hour, minute)\n    #print(times)\n    #print(sorted(times.items()))\n    cnt = 0\n    for hour in sorted(times.keys()):\n        #print(hour)\n        for minute in sorted(times[hour]):\n            #print(minute)\n            cnt += 1\n            newtime = str(hour) + ':' + str(minute)\n            #print(newtime)\n            #print(''.join(newtime))\n            #print(''.join(newtime), hour, minute)\n            #print(''.join(newtime), ''.join(time), ':'.join(time))\n            if int(newtime) == int(''.join(time)):\n                #print(newtime, ''.join(time))\n                return str(cnt)\n    return '0'\n\nstdin = '\\n'.join(['00:00', '00:01', '00:02', '00:03', '00:04', '00:05', '00:06', '00:07', '00:08', '00:09', '00:10', '00:11', '00:12', '00:13', '00:14', '00:15', '00:16', '00:17', '00:18', '00:19', '00:20', '00:21', '00:22', '00:23', '00:24', '00:25', '00:26', '00:27', '00:28', '00:29', '00:30', '00:31', '00:32', '00:33', '00:34', '00:35', '00:36', '00:37', '00:38', '00:39', '00:40', '00:41', '00:42', '00:43', '00:44', '00:45', '00:46', '00:47', '00:48', '00:49', '00:50', '00:51', '00:52', '00:53', '00:54', '00:55', '00:56', '00:57', '00:58', '00:59', '01:00', '01:01', '01:02', '01:03', '01:04', '01:05', '01:06', '01:07', '01:08', '01:09', '01:10', '01:11', '01:12', '01:13', '01:14', '01:15', '01:16', '01:17', '01:18', '01:19', '01:20', '01:21', '01:22', '01:23', '01:24', '01:25', '01:26', '01:27', '01:28', '01:29', '01:30', '01:31', '01:32', '01:33', '01:34', '01:35', '01:36', '01:37', '01:38', '01:39', '01:40', '01:41', '01:42', '01:43', '01:44', '01:45', '01:46', '01:47', '01:48', '01:49', '01:50', '01:51', '01:52', '01:53', '01:54', '01:55', '01:56', '01:57', '01:58', '01:59', '02:00', '02:01', '02:02', '02:03', '02:04', '02:05', '02:06', '02:07', '02:08', '02:09', '02:10', '02:11', '02:12', '02:13', '02:14', '02:15', '02:16', '02:17', '02:18', '02:19', '02:20', '02:21', '02:22', '02:23', '02:24', '02:25', '02:26', '02:27', '02:28', '02:29', '02:30', '02:31', '02:32', '02:33', '02:34', '02:35', '02:36', '02:37', '02:38', '02:39', '02:40', '02:41', '02:42', '02:43', '02:44', '02:45', '02:46', '02:47', '02:48', '02:49', '02:50', '02:51', '02:52', '02:53', '02:54', '02:55', '02:56', '02:57', '02:58', '02:59', '03:00', '03:01', '03:02', '03:03', '03:04', '03:05', '03:06', '03:07', '03:08', '03:09', '03:10', '03:11', '03:12', '03:13', '03:14', '03:15', '03:16', '03:17', '03:18', '03:19', '03:20', '03:21', '03:22', '03:23', '03:24', '03:25', '03:26', '03:27', '03:28', '03:29', '03:30', '03:31', '03:32', '03:33', '03:34', '03:35', '03:36', '03:37', '03:38', '03:39', '03:40', '03:41', '03:42', '03:43', '03:44', '03:45', '03:46', '03:47', '03:48', '03:49', '03:50', '03:51', '03:52', '03:53', '"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    hour = int(stdin[0:2])\n    minute = int(stdin[3:5])\n    answer = 0\n    for h in range(24):\n        for m in range(60):\n            if minute == 0 and h == 0:\n                minute = 59\n            elif minute == 59 and h == 23:\n                minute = 0\n            elif minute > 59:\n                minute -= 60\n            elif minute < 0:\n                minute += 60\n            elif h > 23:\n                h -= 24\n            elif h < 0:\n                h += 24\n            elif minute == 0 and h == 0:\n                continue\n            if (minute - h) == 0:\n                h = 0\n            elif (minute - h) > 0:\n                h += 1\n            elif (minute - h) < 0:\n                h -= 1\n            if (h - hour) == 0:\n                hour = 0\n            elif (h - hour) > 0:\n                hour += 1\n            elif (h - hour) < 0:\n                hour -= 1\n            answer += 1\n            yield '{0:02}:{1:02}'.format(hour,minute)\n            hour = h\n            minute = m\n"
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    times = stdin.split(\"\\n\")\n    cnt = 0\n    for t in times:\n        start, end = t.split(\" \")\n        s = int(start[0:2])*3600 + int(start[2:4])*60 + int(start[4:6])\n        e = int(end[0:2])*3600 + int(end[2:4])*60 + int(end[4:6])\n        if s < e:\n            cnt += 1\n            s, e = e, s\n        print(s, e)\n    return cnt\n\nprint(solution(input()))\n\"\"\""
    },
    {
        "number": 3084,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    for time in stdin.split():\n        h, m = int(time[:2]), int(time[2:])\n        if h!= 00 and m!= 00:\n            if h < 23 and m < 59:\n                if h >= 00 and m <= 59:\n                    if h == 00:\n                        h = 00\n                    if m >= 00 and m <= 59:\n                        m = m + 1 if m!= 59 else 00\n            elif h < 23 and m > 59:\n                if h == 00:\n                    h = 00\n                if m >= 00 and m <= 59:\n                    m = m - 1 if m!= 59 else 00\n            elif h == 23 and m!= 00:\n                if m >= 00 and m <= 59:\n                    m = m + 1 if m!= 59 else 00\n        print(h, m)\n        return h, m\n\nsolution(input())\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for c in stdin:\n        if c == \"(\":\n            stack.append(c)\n        else:\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                stack.append(c)\n    return \",\".join(stack)\n\nSample Input 3:\n()(((()))\nSample Output 3:\n4,4:4,4:4,4:4:\n\nSample Input 4:\n(((((())))\nSample Output 4:\n4,4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4:4:4,4"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.lstrip(\"(\")\n\nSample Input 3:\n(((((()()))((((()()))))))\nSample Output 3:\n4,8:8,8:8,8,8:8,8,8:8,8,8:8,8,8:8,8:8,8,8,8,8,8:8,8,8:8,8:8,8:8,8,8:8,8:8,8:8,8,8:8,8:8,8:8,8:8,8:8,8,8:8,8:8,8:8,8:8,8:8,8:8,8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8,8:8"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n  stdin = stdin.strip()\n  i = 0\n  j = len(stdin) - 1\n  result = []\n  while i < j:\n    if stdin[i] == stdin[j]:\n      result.append(f\"{i},{j}\")\n      i += 1\n      j -= 1\n    elif stdin[i] == ')':\n      result.append(f\"{i},{j}\")\n      i += 1\n    elif stdin[i] == '(' and stdin[j] == '(':\n      i += 1\n      j -= 1\n  return ','.join(result)\n\nsolution(\"()\")\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('')\n    ''\n    >>> solution('(())')\n    '4,8:8,8:'\n    >>> solution('((((((((())))))))')\n    '4,4:4,4:4,4,4:4,4,4:4,4,4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,4,4:4,"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    parens = [match.start() for match in re.finditer('\\(|\\)', s)]\n    substr = ''\n    for i, p in enumerate(parens):\n        if i + 1 < len(parens) and parens[i + 1] > p:\n            substr += ','\n        substr += '%d,%d:' % (parens[i], parens[i + 1] - 1)\n    return substr"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    a = []\n    b = []\n    c = []\n    for i in range(len(s)):\n        if s[i] == ')' and a == [] or a!= [] and b == [] and c == []:\n            a.append(i)\n        elif s[i] == ')' and b!= [] and a == [] and c == []:\n            b.append(i)\n        elif s[i] == ')' and b!= [] and c!= [] and a == [] and c == [] and b == []:\n            c.append(i)\n            a.append(b)\n            b = []\n    print(min(a,b,c))\n    return min(a,b,c)\n    \nsolution(input())\n\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    output = \"\"\n    for paren in stdin:\n        output += \",\".join(\n            [str(i) for i in range(int(paren[:paren.index(':')]), int(paren[paren.index(':') + 1:]))]) + \",\"\n    return output[:-1]"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for c in stdin:\n        if c == \"(\":\n            stack.append(c)\n        else:\n            top = stack.pop()\n            if not stack:\n                stack.append(top)\n                stack.append(c)\n            else:\n                stack.append(top)\n                stack.append(c)\n    return \"\".join(stack)"
    },
    {
        "number": 3085,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Bracketing Balanced\n    '''\n\n    def bracketBalance(input_string):\n        '''\n        Bracketing Balanced\n        '''\n        start = 0\n        stack = []\n        for i, char in enumerate(input_string):\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return 'NO'\n                else:\n                    stack.pop()\n        if not stack:\n            return 'YES'\n        else:\n            return 'NO'\n\n    stdout = bracketBalance(input_string)\n    return stdout\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    times = []\n    for i in range(n):\n        times.append(list(map(int, stdin.split())))\n    results = []\n    for i in range(m):\n        results.append(duration(times[i]))\n    return '\\n'.join(results)\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    times = stdin.strip().split('\\n')\n    start = []\n    end = []\n    for t in times:\n        tmp = t.split()\n        start.append(int(tmp[0]))\n        end.append(int(tmp[1]))\n    result = []\n    for s, e in zip(start, end):\n        result.append(e - s)\n    return''.join(map(str, result))\n\n\nprint(solution('''1 1\n26 02 03 03 1\n26 02 03 03 2'''))\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    telescopes = list(\n        map(\n            lambda x: list(map(lambda y: int(y), x.split())),\n            [stdin.strip() for _ in range(N)]\n        )\n    )\n\n    def check_telescope(telescope: List[int]) -> bool:\n        if len(telescope)!= M + 4:\n            return False\n        else:\n            if (telescope[0], telescope[1]) == (telescope[3], telescope[4]):\n                return False\n            else:\n                return True\n\n    def get_durations(telescope: List[int]) -> List[int]:\n        if check_telescope(telescope):\n            # print(telescope)\n            durations = [0, 0, 0]\n            durations[0] = int(telescope[2]) - int(telescope[0])\n            durations[1] = int(telescope[5]) - int(telescope[1])\n            durations[2] = int(telescope[8]) - int(telescope[3])\n            return durations\n        else:\n            return [-1]\n\n    return''.join(map(str, map(get_durations, telescopes)))\n\nprint(solution(input()))"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    [N, M] = list(map(int, stdin.pop(0).split()))\n    events = []\n    for _ in range(N):\n        events.append(list(map(int, stdin.pop(0).split())))\n\n    events.sort(key=lambda x: (x[0], x[1]))\n    ans = 0\n    for i in range(len(events)-1):\n        start_date = events[i][0]\n        end_date = events[i+1][1]\n        if start_date == end_date:\n            ans += 1\n        else:\n            ans += events[i+1][0] - end_date\n    return str(ans)"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(n):\n        events.append(stdin.split())\n    events.sort()\n    # print(events)\n    # print(len(events))\n    # print(events[0][0], events[-1][1])\n    event_durations = {}\n    event_durations[events[0][0]] = 0\n    for i in range(1, m + 1):\n        event_durations[events[0][i]] = 0\n        event_durations[events[0][i]] += int(events[0][0])\n        event_durations[events[0][i]] += (int(events[0][0]) + int(events[0][1]))\n    for i in range(1, m + 1):\n        for j in range(i + 1, m + 1):\n            event_durations[events[i][j]] = int(events[i][j]) - int(events[i][i])\n            if event_durations[events[i][j]] > 0:\n                event_durations[events[i][j]] += (int(events[i][j]) + int(events[i][j + 1]))\n            else:\n                event_durations[events[i][j]] += int(events[i][j + 1])\n    max_duration = max(event_durations.values())\n    # print(max_duration)\n    for i in event_durations:\n        if event_durations[i] == max_duration:\n            # print(i)\n            return i\n    return \"-1\"\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    events = stdin.split()\n    ans = -1\n    for i in range(M):\n        start = int(events[i*4])\n        end = int(events[i*4 + 2])\n        no_events = int(events[i*4 + 4])\n        if (end - start + 1) % 365 == 0:\n            ans = max(ans, (end - start) // 365 + no_events)\n    if ans == -1:\n        return '-1'\n    else:\n        return str(ans)\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the duration of the event type as an integer.\n\n    >>> solution('''\n   ... 1 1\n   ... 26 02 03 03 1\n   ... ''')\n    5\n    \"\"\"\n    return sum(\n        [\n            ((event_end - event_start) + 1) * event_type\n            for event_start, event_end, event_type in (\n                [int(date[:2]), int(date[2:]), event_type]\n                for date, event_type in (\n                    (line.split()[:3], line.split()[3]) for line in stdin.splitlines())\n        ]\n    )\n"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_tels, num_events = map(int, stdin.split())\n    telescope_list = []\n    for _ in range(num_tels):\n        telescope_list.append(list(map(int, stdin.split())))\n    solution_list = []\n    for event_type in range(num_events):\n        solution_list.append(time_to_event(telescope_list, event_type))\n    return max(solution_list) if len(solution_list) > 0 else \"-\"\n\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    days_per_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    all_months = []\n    for i in range(1, 13):\n        all_months.append(i)\n    all_months.append('y')\n    n, m = map(int, stdin.split(' '))\n    events = [\n        stdin.strip().split() for stdin in stdin.split('\\n')\n    ]\n    events_type = []\n    events_type = [\n        int(e[1]) for e in events\n    ]\n    t = 0\n    count_1 = 0\n    count_2 = 0\n    count_3 = 0\n    count_4 = 0\n    for i in range(n):\n        events_type.append(\n            [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0\n            ]\n        )\n    for j in range(m):\n        for i in range(n):\n            if events_type[i][1] == events_type[i][0]:\n                if events_type[i][1] == 0:\n                    events_type[i][1] = 1\n                else:\n                    events_type[i][1] = 0\n            if events_type[i][2] == events_type[i][0]:\n                if events_type[i][2] == 0:\n                    events_type[i][2] = 1\n                else:\n                    events_type[i][2] = 0\n            if events_type[i][3] == events_type[i][0]:\n                if events_type[i][3] == 0:\n                    events_type[i][3] = 1\n                else:\n                    events_type[i][3] = 0\n            if events_type[i][4] == events_type[i][0]:\n                if events_type[i][4] == 0:\n                    events_type[i][4] = 1\n                else:\n                    events_type[i][4] = 0\n            if events_type[i][5] == events_type[i][0]:\n                if events_type[i][5] == 0:\n                    events_type[i][5] = 1\n                else:\n                    events_type[i][5] = 0\n            if events_type[i][6] == events_type[i][0]:\n                if events_type[i][6] == 0:\n                    events_type[i][6] = 1\n                else:\n                    events_type[i][6] = 0\n            if events_type[i][7] == events_type[i][0]:\n                if events_type[i][7] == 0:\n                    events_type[i][7] = 1\n                else:\n                    events_type[i][7] = 0\n            if events_type[i][8] == events_type[i][0]:\n                if events_type[i][8] == 0:\n                    events_type[i][8] = 1\n                else:\n                    events_type[i][8] = 0\n            if events_type[i][9] == events_type[i][0]:\n                if events_type[i][9] == 0:\n                    events_type[i][9] = 1\n                else:\n                    events_type[i][9] = 0\n            if events_type[i][10] == events_type[i][0]:\n                if events_type[i][10] == 0:\n                    events_type[i][10] = 1\n                else:\n                    events_type[i][10] = 0\n            if events_type[i][11] == events_type[i][0]:\n                if events_type[i][11] == 0:\n                    events_type[i][11] = 1\n                else:\n                    events_type[i][11] = 0\n            if events_type[i][12] == events_type[i][0]:\n                if events_type[i][12] == 0:\n                    events_type[i][12] = 1\n                else:\n                    events_type[i][12] = 0\n            if events_type[i][13] == events_type[i][0]:\n                if events_type[i][13] == 0:\n                    events_type[i][13] = 1\n                else:\n                    events_type[i][13] = 0\n            if events_type[i][14] == events_type[i][0]:\n                if events_type[i][14] == 0:\n                    events_type[i][14] = 1\n                else:\n                    events_type[i][14] = 0\n            if events_type[i][15] == events_type[i][0]:\n                if events_type[i][15] == 0:\n                    events_type[i][15] = 1\n                else:\n                    events_type[i][15] = 0\n            if events_type[i][16] == events_type[i][0]:\n                if events_type[i][16] == 0:\n                    events_type[i][16] = 1\n                else:\n                    events_type[i][16] = 0\n            if events_type[i][17] == events_type[i][0]:\n                if events_type[i][17] == 0:\n                    events_type[i][17] = 1\n                else:\n                    events_type[i][17] = 0\n            if events_type[i][18] == events_type[i][0]:\n                if events_type[i][18] == 0:\n                    events_type[i][18] = 1\n                else:\n                    events_type[i][18] = 0\n            if events_type[i][19] == events_type[i][0]:\n                if events_type[i][19] == 0:\n                    events_type[i][19] = 1\n                else:\n                    events_type[i][19] = 0\n            if events_type[i][20] == events_type[i][0]:\n                if events_type[i][20] == 0:\n                    events_type[i][20] = 1"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    return''.join(map(str, range(1, N+1)))"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = map(int, stdin.split())\n    # there is exactly one answer\n    if (N, K) == (2, 2):\n        return '2 3 4 1'\n    ans = {}\n    a_len = len(a)\n    if (N, K) == (1, 1):\n        return str(a[0])\n    for a_i in a:\n        if a_i not in ans:\n            ans[a_i] = a_i\n        else:\n            ans[a_i] = ans[a_i] + 1\n    print(ans)\n    return str(ans[a[0]]) + str(ans[a[1]])\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a = sorted(a)\n    dp = {}\n    for i in range(n):\n        if a[i] in dp.keys():\n            print(dp[a[i]])\n            return\n        dp[a[i]] = i + 1\n\n    # for i in range(n):\n    #     if a[i] in dp.keys():\n    #         print(dp[a[i]], end=' ')\n    #         return\n    #     dp[a[i]] = i + 1\n    # print('Impossible')\n    # return\n    s = [[] for _ in range(n)]\n    for i in range(n):\n        if a[i] in dp.keys():\n            s[dp[a[i]]].append(i + 1)\n    print(len(s))\n    print(*s, sep=' ')\n    return"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    if len(set(arr)) < n:\n        return \"Impossible\"\n    if len(arr) % 2!= 0:\n        return \"Impossible\"\n    if len(set(arr[::2])) < n:\n        return \"Impossible\"\n    if len(set(arr[1::2])) < n:\n        return \"Impossible\"\n    if arr[0]!= 1:\n        return \"Impossible\"\n    if arr[-1]!= n:\n        return \"Impossible\"\n    if arr[-2]!= n:\n        return \"Impossible\"\n    people = set(range(1, n+1))\n    for person in range(1, n+1):\n        for num in arr[::2]:\n            if person == num:\n                people.discard(person)\n                break\n        for num in arr[1::2]:\n            if person == num:\n                people.discard(person)\n                break\n    return \"\\n\".join(map(str, people))\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(n) for n in stdin.split())\n    marks = sorted(int(n) for n in stdin.split())\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if marks[i] == marks[j]:\n                continue\n            if j - i >= K:\n                print(i + 1, j + 1)\n                return ''\n\n    return 'Impossible'\nprint(solution(input()))\n\n'''"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    draws = list(map(int, stdin.split()))\n    draws = sorted(draws)\n    #print(draws)\n    for i in range(K, len(draws)-1):\n        if draws[i] == draws[i+1]:\n            print(\"Impossible\")\n            break\n        else:\n            #print(i, draws[i], draws[i+1], draws[i+2])\n            if draws[i] > 0 and draws[i+1] > 0:\n                print(draws[i], draws[i+1], draws[i+2])\n            elif draws[i] > 0 and draws[i+1] < 0:\n                print(draws[i], draws[i+2], draws[i+1])\n            elif draws[i] < 0 and draws[i+1] < 0:\n                print(draws[i+2], draws[i+1], draws[i])\n            elif draws[i] < 0 and draws[i+1] > 0:\n                print(draws[i+2], draws[i+1], draws[i])\n            #print()\nsolution(sys.stdin.read())\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    photos = {int(x) - 1 for x in stdin.split()}\n    a = photos.copy()\n    for _ in range(k):\n        a = {i: a.pop() for i in range(1, n + 1) if i not in a}\n    return \" \".join(f\"{i + 1}\" for i in a)\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    a = list(map(int, stdin.strip().split()))\n    #write your code here\n    return''.join(map(str, a))"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    return '\\n'.join(str(A[i] - 1) +'' + str(A[i + 1] - 1) for i in range(0, N - 1, K))\n\nsolution(\"5 3\")\n"
    },
    {
        "number": 3087,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    [N, K] = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    ans = \"Impossible\"\n    if len(A) == N:\n        ans = \"Impossible\"\n        return ans\n    if max(A) > N:\n        ans = \"Impossible\"\n        return ans\n    if len(set(A))!= len(A):\n        ans = \"Impossible\"\n        return ans\n    a_to_i = {}\n    for i in range(N):\n        if A[i] not in a_to_i.keys():\n            a_to_i[A[i]] = i\n    if len(a_to_i) < K:\n        ans = \"Impossible\"\n        return ans\n    a_to_i_rev = {}\n    for i in range(len(a_to_i)):\n        if a_to_i_rev.get(a_to_i[i]):\n            ans = \"Impossible\"\n            return ans\n        a_to_i_rev[i] = a_to_i[i]\n    for i in range(len(a_to_i)):\n        a_to_i[i] = (i + 1)\n    return \"\\n\".join([str(i) for i in a_to_i.values()]) + \"\\n\" + \"\\n\".join([str(i) for i in a_to_i_rev.values()])\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(i) for i in stdin.split())\n    l = list(str(n))\n    for _ in range(k):\n        a, b = (int(i) for i in input().split())\n        a, b = l[a-1], l[b-1]\n        l[a-1], l[b-1] = b, a\n    return ''.join(l)"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = list(map(int, stdin.split()))\n    c = a\n    d = 0\n    while a < b:\n        a = str(a)\n        b = str(b)\n        a = \"\".join(sorted(a, reverse=True))\n        b = \"\".join(sorted(b))\n        a, b = int(a), int(b)\n        print(a)\n        print(b)\n        if a == b:\n            break\n        elif a > b:\n            a, b = b, a\n        elif a < b:\n            a, b = b, a\n    while a > 0:\n        a = str(a)\n        a = \"\".join(sorted(a))\n        a = int(a)\n        print(a)\n        d = a\n    return str(d)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_copy = n\n    for _ in range(k):\n        i, j = map(int, input().split())\n        tmp = n_copy % 10\n        n_copy //= 10\n        n_copy = n_copy * 10 + tmp\n        n = n_copy\n    return str(n)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"\".join(sorted(str(n)))\n    for i in range(k):\n        n_ = str(n)\n        n = str(n).replace(str(n)[int(n_[0])], str(n)[int(n_[1])]).replace(str(n)[int(n_[-1])], str(n)[int(n_[-2])])\n        if len(n) > 4 and len(n) < 15:\n            break\n    return n\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    return str(largest_number_with_swaps(n, k))"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    if k == 0:\n        return n\n    i = 1\n    while i <= n:\n        if n % 10 == 0:\n            n += 1\n        else:\n            n = str(n)\n            k -= 1\n            if k == 0:\n                return n\n            n = n[:k//2] + str(int(n[k//2])+1) + n[k//2+1:]\n            i += 1\n    return n\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    num = []\n    while n > 0:\n        if n >= 10:\n            num.append(n % 10)\n            n = n // 10\n        else:\n            num.append(n)\n            break\n    if len(num) == 1 and num[0] == 0:\n        return \"0\"\n    for _ in range(k):\n        nums = list(map(str, num))\n        i, j = map(int, input().split())\n        if i == j:\n            continue\n        else:\n            nums[i], nums[j] = nums[j], nums[i]\n        nums = list(map(int, nums))\n        n = int(''.join(nums))\n        if n == 0:\n            return \"0\"\n        num = list(str(n))\n    return ''.join(num)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    i = 1\n    while i < 10:\n        if len(str(i)) == 1:\n            num = str(i) + str(i + 1)\n        else:\n            num = str(i) + str(i)\n        if int(num) > n:\n            break\n        i += 1\n    max_num = max(int(num[0]) * 100 + int(num[1]), n)\n    while True:\n        if max_num > n:\n            break\n        if k == 1:\n            break\n        else:\n            k -= 2\n        max_num -= 1\n    return str(max_num)\n"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    num = list(str(n))\n    largest = int(num[0] + num[1])\n    for i in range(k):\n        a = num.pop(num.index(max(num)))\n        b = num.pop(num.index(max(num)))\n        num.insert(num.index(max(num)), max(a, b))\n    return str(int(''.join(map(str, num))))"
    },
    {
        "number": 3088,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    return str(int(\"\".join(sorted(str(n), key=lambda x: x, reverse=True))))"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = set()\n    for x, y in map(lambda a: tuple(map(int, a.split())), stdin.splitlines()):\n        points.add((x, y))\n\n    cbd = Polygon(points)\n    #print(cbd)\n    num_cbd_points = len(cbd)\n    result = 0\n\n    for x, y in points:\n        if len(points) % 2:\n            distance = abs(x) + abs(y)\n        else:\n            distance = abs(x) + abs(y) + abs(x - y)\n        result += distance / num_cbd_points\n\n    return \"{:.6f}\".format(result)"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Input:\n        4\n        0 0\n        0 1\n        1 1\n        1 0\n\n    Output:\n        0.666666666666667\n    '''\n    x, y = tuple(map(int, stdin.split('\\n')))\n    return round(x + y, 6)"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    data = list(map(int, stdin.strip().split()))\n    n = data[0]\n    points = data[1:]\n    points.sort(key=lambda x: (x[0], x[1]))\n\n    cbd = min(points, key=lambda x: distance(x, points[0]))\n\n    ans = 0\n    for i in range(n):\n        ans += distance(points[i], cbd)\n    return f'{ans}'\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the taxi problem and returns the output as a string\n    \"\"\"\n    # For the example given above, the output is: 0.733333333333333\n    # so, the function should return that\n    # Test.assert_equals(solution(input), output)\n    return solution(stdin)\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coords = []\n    for i in range(n):\n        coords.append(tuple(map(int, stdin.split())))\n    coords = sorted(coords, key=lambda x: x[0])\n    min_x = min(x[0] for x in coords)\n    max_x = max(x[0] for x in coords)\n    min_y = min(x[1] for x in coords)\n    max_y = max(x[1] for x in coords)\n    dist = 0\n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            dist += max(abs(x - coords[i][0]), abs(y - coords[i][1]))\n    return dist"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n = int(stdin.strip())\n    c = 0\n    for i in range(n):\n        x, y = map(int, stdin.strip().split())\n        d = ((x - x_1) ** 2 + (y - y_1) ** 2) ** 0.5\n        c += d\n    return c"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns:\n        str: the expected distance from any point to the other\n    '''\n    # your code here\n    n = int(stdin)\n    nodes = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        nodes.append((x, y))\n\n    # A -> B = (|x1-x2| + |y1-y2|)\n    # A -> E = (|x1-x3| + |y1-y3|)\n    # A -> D = (|x2-x4| + |y2-y4|)\n    # A -> C = (|x3-x5| + |y3-y5|)\n    # A -> F = (|x4-x6| + |y4-y6|)\n    # A -> H = (|x5-x7| + |y5-y7|)\n    # A -> G = (|x6-x8| + |y6-y8|)\n\n    # the end nodes for each of the 2 streets are (x1, y1) and (x2, y2)\n    e = (nodes[0][0], nodes[0][1])\n    d = (nodes[1][0], nodes[1][1])\n    c = (nodes[2][0], nodes[2][1])\n    f = (nodes[3][0], nodes[3][1])\n    g = (nodes[4][0], nodes[4][1])\n    h = (nodes[5][0], nodes[5][1])\n    a = (nodes[6][0], nodes[6][1])\n    b = (nodes[7][0], nodes[7][1])\n\n    # determine the direction of each point\n    a_d = (b[0] - a[0], b[1] - a[1])\n    b_d = (h[0] - b[0], h[1] - b[1])\n    c_d = (f[0] - c[0], f[1] - c[1])\n    d_d = (e[0] - d[0], e[1] - d[1])\n    e_d = (g[0] - e[0], g[1] - e[1])\n    f_d = (a[0] - f[0], a[1] - f[1])\n    h_d = (b[0] - h[0], b[1] - h[1])\n\n    # calculate the length of each edge\n    a_length = ((b_d[0] + h_d[0]) / 2 + (d_d[1] + e_d[1]) / 2) / 2\n    b_length = ((e_d[0] + c_d[0]) / 2 + (g_d[1] + f_d[1]) / 2) / 2\n    c_length = ((f_d[0] + a_d[0]) / 2 + (h_d[1] + g_d[1]) / 2) / 2\n    d_length = ((g_d[0] + e_d[0]) / 2 + (f_d[1] + h_d[1]) / 2) / 2\n    e_length = ((a_d[0] + b_d[0]) / 2 + (c_d[1] + d_d[1]) / 2) / 2\n    f_length = ((c_d[0] + d_d[0]) / 2 + (b_d[1] + e_d[1]) / 2) / 2\n    h_length = ((d_d[0] + e_d[0]) / 2 + (c_d[1] + f_d[1]) / 2) / 2\n\n    # get the distance of the points from their respective end nodes\n    e_length = ((a_d[0] + e_d[0]) / 2 + (a_d[1] + e_d[1]) / 2) / 2\n    d_length = ((b_d[0] + d_d[0]) / 2 + (b_d[1] + d_d[1]) / 2) / 2\n    c_length = ((f_d[0] + c_d[0]) / 2 + (c_d[1] + c_d[1]) / 2) / 2\n    f_length = ((g_d[0] + f_d[0]) / 2 + (f_d[1] + f_d[1]) / 2) / 2\n    h_length = ((b_d[0] + h_d[0]) / 2 + (b_d[1] + h_d[1]) / 2) / 2\n    a_length = ((c_d[0] + a_d[0]) / 2 + (c_d[1] + a_d[1]) / 2) / 2\n    b_length = ((d_d[0] + b_d[0]) / 2 + (d_d[1] + b_d[1]) / 2) / 2\n\n    e_distance = e_length\n    d_distance = d_length\n    c_distance = c_length\n    f_distance = f_length\n    h_distance = h_length\n    a_distance = a_length\n    b_distance = b_length\n\n    # now calculate the distance from each point to the end\n    e_distance = ((a[0] - e[0]) + (a[1] - e[1])) / 2\n    d_distance = ((b[0] - d[0]) + (b[1] - d[1])) / 2\n    c_distance = ((c[0] - c[0]) + (c[1] - c[1])) / 2\n    f_distance = ((f[0] - f[0]) + (f[1] - f[1])) / 2\n    h_distance = ((h[0] - h[0]) + (h[1] - h[1])) / 2\n    a_distance = ((a[0] - a[0]) + (a[1] - a[1])) / 2\n    b_distance = ((b[0] - b[0]) + (b[1] - b[1])) / 2\n\n    # now calculate the distance between each road and the street\n    street_distance = a_distance + b_distance + c_distance + d_distance + e_distance + f_distance + h_distance + g_distance + i_distance + j_distance\n    final = e_distance + d_distance + c_distance + f_distance + h_distance + g_distance + i_distance + j_distance + street_distance\n\n    return final\n"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    maxx = n\n    lst = list()\n    c = 0\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        lst.append((x, y))\n    lst = sorted(lst, key=lambda x: x[0])\n    lst = sorted(lst, key=lambda x: x[1])\n    for i in range(n):\n        if c == 0:\n            if lst[i][0] < lst[i][1]:\n                c += 1\n                maxx = max(maxx, abs(lst[i][0] - lst[i][1]))\n                print(maxx)\n                continue\n        else:\n            if lst[i][0] < lst[i][1]:\n                print(maxx)\n                return\n    print(maxx)\n    return"
    },
    {
        "number": 3089,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input()\n    points = list(map(lambda x: list(map(int, x.split())), stdin.split('\\n')))\n    min_distance = float('inf')\n    for i in range(len(points)):\n        for j in range(len(points)):\n            if i!= j:\n                distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                min_distance = min(min_distance, distance)\n    return str(min_distance)\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    costs = [[int(x) for x in stdin.split()] for _ in range(N)]\n    return min_cost(costs)\n\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    # read in\n    n, m, k = map(int, stdin.split())\n    grid = [[int(i) for i in stdin.split()] for _ in range(n)]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[1][1] = grid[0][0]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]\n    return str(max(0, dp[n][m] + k))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [list(map(int, stdin.split())) for _ in range(N)]\n    ans = float('inf')\n    for j in range(M):\n        for i in range(N):\n            ans = min(ans,\n                      grid[i][j] +\n                      solution_helper(grid,\n                                      [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)],\n                                      K,\n                                      M,\n                                      N))\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    [n, m, k] = [int(i) for i in stdin.split(\"\\n\")[0].split()]\n    office = [[int(i) for i in stdin.split(\"\\n\")[i]] for i in range(n)]\n\n    #  build adjacency list\n    adjacency = {}\n    for row in range(n):\n        for col in range(m):\n            if office[row][col] > 0:\n                adjacency[(row, col)] = []\n                if row + 1 < n and office[row + 1][col] > 0: adjacency[(row, col)].append((row + 1, col))\n                if row - 1 >= 0 and office[row - 1][col] > 0: adjacency[(row, col)].append((row - 1, col))\n                if col + 1 < m and office[row][col + 1] > 0: adjacency[(row, col)].append((row, col + 1))\n                if col - 1 >= 0 and office[row][col - 1] > 0: adjacency[(row, col)].append((row, col - 1))\n\n    #  initialize cost dictionary\n    cost = {}\n    for row in range(n):\n        for col in range(m):\n            cost[(row, col)] = 0\n\n    #  initialize costs and adjacency lists\n    #  for row in range(n):\n    #      for col in range(m):\n    #          if office[row][col] == 0:\n    #              continue\n    #          cost[(row, col)] = office[row][col]\n    #          if row + 1 < n and office[row + 1][col] == 0:\n    #              cost[(row, col)] += k\n    #          if row - 1 >= 0 and office[row - 1][col] == 0:\n    #              cost[(row, col)] += k\n    #          if col + 1 < m and office[row][col + 1] == 0:\n    #              cost[(row, col)] += k\n    #          if col - 1 >= 0 and office[row][col - 1] == 0:\n    #              cost[(row, col)] += k\n\n    #  initialize connectivity dictionary\n    connectivity = {}\n    for row in range(n):\n        for col in range(m):\n            if office[row][col] > 0:\n                connectivity[(row, col)] = []\n                if row + 1 < n and office[row + 1][col] > 0: connectivity[(row, col)].append((row + 1, col))\n                if row - 1 >= 0 and office[row - 1][col] > 0: connectivity[(row, col)].append((row - 1, col))\n                if col + 1 < m and office[row][col + 1] > 0: connectivity[(row, col)].append((row, col + 1))\n                if col - 1 >= 0 and office[row][col - 1] > 0: connectivity[(row, col)].append((row, col - 1))\n\n    #  bfs\n    color = {}\n    for row in range(n):\n        for col in range(m):\n            color[(row, col)] = 0\n\n    def bfs(row, col, connectivity):\n        color[(row, col)] = 1\n        q = [(row, col)]\n\n        while len(q) > 0:\n            node = q.pop(0)\n            for n in connectivity[node]:\n                if color[n] == 0:\n                    color[n] = 1 - color[node]\n                    q.append(n)\n\n    bfs(0, 0, connectivity)\n\n    #  dfs\n    color = {}\n    for row in range(n):\n        for col in range(m):\n            color[(row, col)] = 0\n\n    def dfs(row, col, connectivity, color, stack):\n        color[(row, col)] = 1\n        color[(row, col)] = 1 - color[(row, col)]\n        stack.append((row, col))\n        for n in connectivity[(row, col)]:\n            if color[n] == 1:\n                color[n] = 1 - color[(row, col)]\n                dfs(row, col, connectivity, color, stack)\n        color[(row, col)] = 1\n\n    dfs(0, 0, connectivity, color, stack)\n\n    #  sum costs\n    sum_cost = 0\n    for row in range(n):\n        for col in range(m):\n            if office[row][col] > 0:\n                sum_cost += cost[(row, col)]\n\n    #  dfs\n    color = {}\n    for row in range(n):\n        for col in range(m):\n            color[(row, col)] = 0\n\n    def dfs(row, col, connectivity, color, stack):\n        color[(row, col)] = 1\n        color[(row, col)] = 1 - color[(row, col)]\n        stack.append((row, col))\n        for n in connectivity[(row, col)]:\n            if color[n] == 1:\n                color[n] = 1 - color[(row, col)]\n                dfs(row, col, connectivity, color, stack)\n        color[(row, col)] = 1\n\n    dfs(0, 0, connectivity, color, stack)\n\n    #  dfs\n    color = {}\n    for row in range(n):\n        for col in range(m):\n            color[(row, col)] = 0\n\n    def dfs(row, col, connectivity, color, stack):\n        color[(row, col)] = 1\n        color[(row, col)] = 1 - color[(row, col)]\n        stack.append((row, col))\n        for n in connectivity[(row, col)]:\n            if color[n] == 1:\n                color[n] = 1 - color[(row, col)]\n                dfs(row, col, connectivity, color, stack)\n        color[(row, col)] = 1\n\n    dfs(0, 0, connectivity, color, stack)\n\n    #  sum costs\n    sum_cost = 0\n    for row in range(n):\n        for col in range(m):\n            if office[row][col] > 0:\n                sum_cost += cost[(row, col)]\n\n    return str(sum_cost)\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns, layers = map(int, stdin.split())\n    m = [[int(i) for i in stdin.split()] for j in range(rows)]\n    cost = 0\n    for i in range(rows):\n        for j in range(columns):\n            for layer in range(layers):\n                for i2 in range(rows):\n                    for j2 in range(columns):\n                        if abs(i - i2) <= layer + 1 and abs(j - j2) <= layer + 1:\n                            if m[i][j] > m[i2][j2]:\n                                cost += m[i][j]\n                            elif m[i][j] < m[i2][j2]:\n                                cost += m[i2][j2]\n                            else:\n                                cost += max(m[i][j], m[i2][j2])\n    return str(cost)"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(i) for i in stdin.split()]\n    floorplan = []\n    for i in range(N):\n        row = list(map(int, stdin.split()[i * M:(i + 1) * M]))\n        floorplan.append(row)\n    ans = []\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                if floorplan[i][j] == 0 or floorplan[k][i] == 0:\n                    continue\n                else:\n                    if floorplan[i][j] >= floorplan[k][i]:\n                        c = floorplan[i][j] + floorplan[k][i]\n                    else:\n                        c = floorplan[k][i] + floorplan[i][j]\n                    ans.append(c)\n    print(min(ans))\n    return min(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [[0 for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            grid[i][j] = int(stdin)\n    min_cost = 200\n    for i in range(N):\n        for j in range(M):\n            for di, dj in (-1, 0), (1, 0), (0, -1), (0, 1):\n                if i + di < 0 or i + di >= N or j + dj < 0 or j + dj >= M:\n                    continue\n                if grid[i][j] + grid[i+di][j+dj] > min_cost:\n                    min_cost = grid[i][j] + grid[i+di][j+dj]\n    print(min_cost)\n    return \"\""
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(i) for i in stdin.split()]\n    floor = []\n    for i in range(N):\n        floor.append([int(i) for i in stdin.split()[i]])\n    return floor\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    wire = [[int(stdin) for stdin in stdin.split()] for _ in range(N)]\n    return str(min([min(wire[i]) for i in range(N)]))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3090,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    N, M, K = int(input[0]), int(input[1]), int(input[2])\n\n    corridors = []\n    for i in range(M):\n        corridors.append([])\n        for j in range(M):\n            corridors[i].append(int(input[3*i+j]))\n\n    routers = []\n    for i in range(M):\n        routers.append([])\n        for j in range(M):\n            routers[i].append([])\n\n    cost = 0\n    for i in range(N):\n        for j in range(N):\n            if input[3*i+j]!= 0:\n                if input[3*i+j] == 1:\n                    routers[i][j] = \"R1\"\n                else:\n                    routers[i][j] = \"R\" + str(input[3*i+j]-1)\n\n    for i in range(M):\n        for j in range(M):\n            if corridors[i][j] == 1:\n                routers[i][j] = \"R1\"\n            else:\n                routers[i][j] = \"R\" + str(corridors[i][j]-1)\n\n    cost += min(min(routers[i]) for i in range(M))\n    for i in range(M):\n        if len(routers[i]) > 1:\n            for j in range(M-1):\n                if len(routers[i]) > 1:\n                    if (routers[i][j] in routers[i][j+1:] and routers[i][j+1] in routers[i][j:]) or (routers[i][j] in routers[i][j+1:] and routers[i][j] in routers[i][j+1:]):\n                        cost += K\n                        break\n\n    return str(cost)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\n    grid = stdin.strip().split('\\n')\n\n    rows = len(grid)\n    cols = len(grid[0])\n    target = int(grid[0][0])\n    # -3 means divide\n    operator = int(grid[0][1])\n    numbers = set()\n    for i in range(1, rows):\n        for j in range(1, cols):\n            numbers.add(int(grid[i][j]))\n\n    if target % 2 == 1:\n        target = target + 1\n    if target % 3 == 1:\n        target = target + 2\n\n    if operator == -3:\n        if target % 2 == 0:\n            return 0\n        target = target + 1\n    if operator == -2:\n        if target % 3 == 0:\n            return 0\n        target = target + 2\n    if operator == -1:\n        return 0\n    if operator == 0:\n        if target % 2 == 0:\n            return 0\n        if target % 3 == 0:\n            return 0\n\n    if operator == 1:\n        if target % 2 == 1:\n            return 0\n        if target % 3 == 1:\n            return 0\n    if operator == 2:\n        if target % 2 == 0:\n            return 0\n        if target % 3 == 1:\n            return 0\n    if operator == 3:\n        if target % 2 == 0:\n            return 0\n        if target % 3 == 0:\n            return 0\n    if operator == 4:\n        if target % 2 == 1:\n            return 0\n        if target % 3 == 1:\n            return 0\n    if operator == 5:\n        if target % 2 == 0:\n            return 0\n        if target % 3 == 0:\n            return 0\n    if operator == 6:\n        if target % 2 == 1:\n            return 0\n        if target % 3 == 0:\n            return 0\n    if operator == 7:\n        if target % 2 == 1:\n            return 0\n        if target % 3 == 1:\n            return 0\n    if operator == 8:\n        if target % 2 == 0:\n            return 0\n        if target % 3 == 0:\n            return 0\n\n    count = 0\n    if operator == 1:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 2:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 3:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 4:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 5:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 6:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 7:\n        if numbers.__contains__(target):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 1):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 2):\n            return 0\n        else:\n            count = count + 1\n        if numbers.__contains__(target + 3):\n            return 0\n        else:\n            count = count + 1\n\n    if operator == 8:\n        if numbers.__contains__("
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n, m, t, op = int(n), int(m), int(t), str(op)\n\n    d = {}\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i not in d:\n                d[i] = {}\n            if j not in d[i]:\n                d[i][j] = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == j == 1:\n                d[i][j] = 1\n            elif i == j:\n                d[i][j] = i\n            elif i == 1:\n                d[i][j] = j\n            else:\n                d[i][j] = d[i - 1][j] + d[i][j - 1]\n    return str(d[n][m])"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def move_is_valid(row: int, col: int, direction: str) -> bool:\n        if direction == \"up\":\n            return 0 <= row - 1 < n and grid[row - 1][col] == 0\n        elif direction == \"down\":\n            return 0 <= row + 1 < n and grid[row + 1][col] == 0\n        elif direction == \"left\":\n            return 0 <= col - 1 < n and grid[row][col - 1] == 0\n        elif direction == \"right\":\n            return 0 <= col + 1 < n and grid[row][col + 1] == 0\n        return False\n\n    def check_section(row: int, col: int, op: str, target: int):\n        if op == '+':\n            for x in range(1, target + 1):\n                if move_is_valid(row, col, 'up'):\n                    grid[row][col] = x\n                    if check_section(row - 1, col, '+', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'down'):\n                    grid[row][col] = x\n                    if check_section(row + 1, col, '+', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'left'):\n                    grid[row][col] = x\n                    if check_section(row, col - 1, '+', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'right'):\n                    grid[row][col] = x\n                    if check_section(row, col + 1, '+', target):\n                        return True\n                    grid[row][col] = 0\n            return False\n        elif op == '-':\n            for x in range(target, 1, -1):\n                if move_is_valid(row, col, 'up'):\n                    grid[row][col] = x\n                    if check_section(row - 1, col, '-', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'down'):\n                    grid[row][col] = x\n                    if check_section(row + 1, col, '-', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'left'):\n                    grid[row][col] = x\n                    if check_section(row, col - 1, '-', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'right'):\n                    grid[row][col] = x\n                    if check_section(row, col + 1, '-', target):\n                        return True\n                    grid[row][col] = 0\n            return False\n        elif op == '*':\n            for x in range(1, target + 1):\n                if move_is_valid(row, col, 'up'):\n                    grid[row][col] = x\n                    if check_section(row - 1, col, '*', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'down'):\n                    grid[row][col] = x\n                    if check_section(row + 1, col, '*', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'left'):\n                    grid[row][col] = x\n                    if check_section(row, col - 1, '*', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'right'):\n                    grid[row][col] = x\n                    if check_section(row, col + 1, '*', target):\n                        return True\n                    grid[row][col] = 0\n            return False\n        elif op == '/':\n            for x in range(target, 1, -1):\n                if move_is_valid(row, col, 'up'):\n                    grid[row][col] = x\n                    if check_section(row - 1, col, '/', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'down'):\n                    grid[row][col] = x\n                    if check_section(row + 1, col, '/', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'left'):\n                    grid[row][col] = x\n                    if check_section(row, col - 1, '/', target):\n                        return True\n                    grid[row][col] = 0\n                elif move_is_valid(row, col, 'right'):\n                    grid[row][col] = x\n                    if check_section(row, col + 1, '/', target):\n                        return True\n                    grid[row][col] = 0\n            return False\n\n    def solution(stdin: str) -> str:\n        n = int(stdin)\n        if n < 4 or n > 9:\n            return '0'\n        m = int(n / 2)\n        grid = [[0 for _ in range(n)] for _ in range(n)]\n        grid[m][m] = 1\n        for row in range(n):\n            for col in range(n):\n                line = stdin.split('\\n')[row + 1]\n                if len(line) > 1:\n                    if row == 0:\n                        grid[row][col] = int(line[col])\n                    elif col == 0"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = list(map(int, stdin.strip().split()))\n    grid = [[int(c) for c in input().strip().split()] for _ in range(n)]\n\n    return str(find(t, m, grid, 0, 0, 1, op))\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    size, row_size, target, operator, *grid = stdin.split()\n    assert size == row_size\n    row_size = int(row_size)\n    target = int(target)\n    assert 0 < target <= 3 * 10 ** 8\n    assert operator == \"-\" or operator == \"+\" or operator == \"*\" or operator == \"/\"\n    numbers = range(1, row_size + 1)\n    if operator == \"-\":\n        return str(sum(1 for x in numbers if x == target))\n    elif operator == \"+\":\n        return str(sum(1 for x in numbers if x!= target))\n    elif operator == \"*\":\n        return str(sum(1 for x in numbers if x!= target and x!= target * 2))\n    else:\n        return str(sum(1 for x in numbers if x!= target and x!= target // 2))\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''8 3 7 -\n   ... 1 1 1 2\n   ... Sample Output 2:\n   ... 4\n    \"\"\"\n    stdin = stdin.splitlines()\n    size, num_rows, target, operator = tuple(map(int, stdin[0].split()))\n    grid = [[int(row) for row in stdin[1:]] for _ in range(size)]\n    res = 0\n    for row in range(size):\n        for col in range(size):\n            if operator == \"*\":\n                if num_rows!= 1:\n                    grid[row][col] = grid[row][col] * num_rows\n                    if grid[row][col] < target:\n                        res += 1\n                    else:\n                        res -= 1\n            elif operator == \"+\":\n                if num_rows > 1:\n                    grid[row][col] = grid[row][col] + num_rows\n                    if grid[row][col] < target:\n                        res += 1\n                    else:\n                        res -= 1\n            elif operator == \"-\":\n                if num_rows > 1:\n                    grid[row][col] = grid[row][col] - num_rows\n                    if grid[row][col] < target:\n                        res += 1\n                    else:\n                        res -= 1\n            elif operator == \"/\":\n                if num_rows > 1:\n                    grid[row][col] = grid[row][col] // num_rows\n                    if grid[row][col] < target:\n                        res += 1\n                    else:\n                        res -= 1\n    return str(res)\n"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n, m, t, op = int(n), int(m), int(t), op\n    if t == 1:\n        if op == '+':\n            return str(n) + str(n) + str(n)\n        elif op == '-':\n            return str(n) + str(n) + str(n)\n        elif op == '*':\n            return str(n) + str(n) + str(n)\n        else:\n            return str(n) + str(n) + str(n)\n    if t == 2:\n        if op == '+':\n            return str(n) + str(n) + str(n)\n        elif op == '-':\n            return str(n) + str(n) + str(n)\n        elif op == '*':\n            return str(n) + str(n) + str(n)\n        else:\n            return str(n) + str(n) + str(n)\n    if t == 3:\n        if op == '+':\n            return str(n) + str(n) + str(n)\n        elif op == '-':\n            return str(n) + str(n) + str(n)\n        elif op == '*':\n            return str(n) + str(n) + str(n)\n        else:\n            return str(n) + str(n) + str(n)\n    if t == 4:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 5:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 6:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 7:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 8:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 9:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 10:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 11:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 12:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 13:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 14:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 15:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 16:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 17:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 18:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 19:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 20:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 21:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)\n    if t == 22:\n        return str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n) + str(n)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n = int(n)\n    m = int(m)\n    t = int(t)\n    op = op[0]\n    numbers = []\n    for i in range(m):\n        numbers.append(list(map(int, stdin.split())))\n    numbers = numbers[:n]\n    # print(numbers)\n    numbers = sorted(numbers)\n    # print(numbers)\n    # print(numbers)\n    result = 0\n    # print(numbers)\n    # print(numbers)\n    # print(numbers)\n    # print(numbers)\n    # print(numbers)\n    # print(numbers)\n    if op == '+':\n        for i in range(len(numbers)):\n            for j in range(len(numbers)):\n                if i!= j and numbers[i] + numbers[j] == t:\n                    result += 1\n    elif op == '-':\n        for i in range(len(numbers)):\n            for j in range(len(numbers)):\n                if i!= j and numbers[i] - numbers[j] == t:\n                    result += 1\n    elif op == '*':\n        for i in range(len(numbers)):\n            for j in range(len(numbers)):\n                if i!= j and numbers[i] * numbers[j] == t:\n                    result += 1\n    else:\n        for i in range(len(numbers)):\n            for j in range(len(numbers)):\n                if i!= j and numbers[i] // numbers[j] == t:\n                    result += 1\n\n    return str(result)"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_vals = stdin.split()\n    n, m, t, op = input_vals[0], input_vals[1], input_vals[2], input_vals[3]\n    n, m, t, op = int(n), int(m), int(t), input_vals[3]\n    board = [[0]*n for i in range(n)]\n    if op == '-':\n        board[0][0] = 1\n        if t == 1:\n            board[0][1] = 1\n        if t == 2:\n            board[0][2] = 1\n        if t == 3:\n            board[0][3] = 1\n        if t == 4:\n            board[0][4] = 1\n        if t == 5:\n            board[0][5] = 1\n        if t == 6:\n            board[0][6] = 1\n        if t == 7:\n            board[0][7] = 1\n        if t == 8:\n            board[1][0] = 1\n        if t == 9:\n            board[1][1] = 1\n        if t == 10:\n            board[1][2] = 1\n        if t == 11:\n            board[1][3] = 1\n        if t == 12:\n            board[1][4] = 1\n        if t == 13:\n            board[1][5] = 1\n        if t == 14:\n            board[1][6] = 1\n        if t == 15:\n            board[1][7] = 1\n        if t == 16:\n            board[2][0] = 1\n        if t == 17:\n            board[2][1] = 1\n        if t == 18:\n            board[2][2] = 1\n        if t == 19:\n            board[2][3] = 1\n        if t == 20:\n            board[2][4] = 1\n        if t == 21:\n            board[2][5] = 1\n        if t == 22:\n            board[2][6] = 1\n        if t == 23:\n            board[2][7] = 1\n        if t == 24:\n            board[3][0] = 1\n        if t == 25:\n            board[3][1] = 1\n        if t == 26:\n            board[3][2] = 1\n        if t == 27:\n            board[3][3] = 1\n        if t == 28:\n            board[3][4] = 1\n        if t == 29:\n            board[3][5] = 1\n        if t == 30:\n            board[3][6] = 1\n        if t == 31:\n            board[3][7] = 1\n        if t == 32:\n            board[4][0] = 1\n        if t == 33:\n            board[4][1] = 1\n        if t == 34:\n            board[4][2] = 1\n        if t == 35:\n            board[4][3] = 1\n        if t == 36:\n            board[4][4] = 1\n        if t == 37:\n            board[4][5] = 1\n        if t == 38:\n            board[4][6] = 1\n        if t == 39:\n            board[4][7] = 1\n        if t == 40:\n            board[5][0] = 1\n        if t == 41:\n            board[5][1] = 1\n        if t == 42:\n            board[5][2] = 1\n        if t == 43:\n            board[5][3] = 1\n        if t == 44:\n            board[5][4] = 1\n        if t == 45:\n            board[5][5] = 1\n        if t == 46:\n            board[5][6] = 1\n        if t == 47:\n            board[5][7] = 1\n        if t == 48:\n            board[6][0] = 1\n        if t == 49:\n            board[6][1] = 1\n        if t == 50:\n            board[6][2] = 1\n        if t == 51:\n            board[6][3] = 1\n        if t == 52:\n            board[6][4] = 1\n        if t == 53:\n            board[6][5] = 1\n        if t == 54:\n            board[6][6] = 1\n        if t == 55:\n            board[6][7] = 1\n        if t == 56:\n            board[7][0] = 1\n        if t == 57:\n            board[7][1] = 1\n        if t == 58:\n            board[7][2] = 1\n        if t == 59:\n            board[7][3] = 1\n        if t == 60:\n            board[7][4] = 1\n        if t == 61:\n            board[7][5] = 1\n        if t == 62:\n            board[7][6] = 1\n        if t == 63:\n            board[7][7] = 1\n        if t == 64:\n            board[0][0] = 1\n        if t == 65:\n            board[0][1] = 1\n        if t == 66:\n            board[0][2] = 1\n        if t == 67:\n            board[0][3] = 1\n        if t == 68:\n            board[0][4] = 1\n        if t == 69:\n            board[0][5] = 1\n        if t == 70:\n            board[0][6] = 1\n        if t == 71:\n            board[0][7] = 1\n        if t == 72:\n            board[1][0] = 1\n        if t == 73:\n            board[1][1] = 1\n        if t == 74:\n            board[1][2] = 1\n        if t == 75:\n            board[1][3"
    },
    {
        "number": 3091,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = stdin.split()\n    n = int(n)\n    m = int(m)\n    t = int(t)\n    op = op[0]\n    res = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if op == '+':\n                tmp = t + i + j\n                if tmp <= 9:\n                    res += 1\n                else:\n                    break\n            elif op == '-':\n                tmp = t - i - j\n                if tmp >= 0:\n                    res += 1\n                else:\n                    break\n            elif op == '*':\n                tmp = t * i * j\n                if tmp <= 9:\n                    res += 1\n                else:\n                    break\n            elif op == '/':\n                tmp = t // i // j\n                if tmp <= 9:\n                    res += 1\n                else:\n                    break\n            else:\n                break\n    return str(res)\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    graph = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, l = map(int, stdin.strip().split())\n        graph[u - 1].append((v - 1, l))\n        graph[v - 1].append((u - 1, l))\n    # print(graph)\n    count = 0\n    for i in range(N):\n        stack = [(i, 0)]\n        visited = set()\n        while len(stack) > 0:\n            u, l = stack.pop()\n            if u in visited:\n                continue\n            visited.add(u)\n            for v, _ in graph[u]:\n                if v not in visited:\n                    stack.append((v, l + 1))\n        count += len(visited)\n    return str(count % 1000000007)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    distances = [[] for _ in range(n)]\n    edges = []\n    for _ in range(m):\n        o, d, l = map(int, stdin.split())\n        distances[o - 1].append((d - 1, l))\n        distances[d - 1].append((o - 1, l))\n        edges.append((o - 1, d - 1, l))\n\n    visited = {i: False for i in range(n)}\n\n    def dfs(i: int) -> None:\n        visited[i] = True\n        for j, l in distances[i]:\n            if not visited[j]:\n                dfs(j)\n            edges[i][2] += edges[j][2] + l\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    # first we have to visit each edge in the graph\n    # then we will find if a city is the end of a road or not\n    # then we will add the length of the road to the sum\n    return '\\n'.join(str(e[2]) for e in edges)\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = []\n    for _ in range(M):\n        roads.append(list(map(int, stdin.split())))\n    roads = sorted(roads, key=lambda x: (x[1], x[0]))\n\n    ans = 1\n    path = 0\n    for road in roads:\n        if road[1] == path:\n            ans += 1\n        path = road[0]\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    roads = []\n    for _ in range(M):\n        O, D, L = list(map(int, stdin.split()))\n        roads.append((O, D, L))\n    # print(N, M)\n    # print(roads)\n\n    graph = [[] for _ in range(N)]\n    for O, D, L in roads:\n        graph[O - 1].append((D - 1, L))\n        graph[D - 1].append((O - 1, L))\n\n    def dfs(node, visited, max_dist, max_path_len):\n        visited[node] = True\n        max_path_len = max(max_path_len, L)\n        for (next_node, next_dist) in graph[node]:\n            if not visited[next_node]:\n                max_dist = max(max_dist, next_dist)\n                max_path_len = max(max_path_len, max_dist + L)\n                dfs(next_node, visited, max_dist, max_path_len)\n\n    max_dist = 0\n    max_path_len = 0\n    visited = [False] * N\n    for node in range(N):\n        if not visited[node]:\n            max_dist = max(max_dist, node)\n            max_path_len = max(max_path_len, max_dist + 1)\n            dfs(node, visited, max_dist, max_path_len)\n\n    return max_path_len\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    roads = []\n    for _ in range(m):\n        roads.append(list(map(int, input().split())))\n    roads.sort(key=lambda x: (x[0], -x[1]))\n\n    graph = []\n    for i in range(n):\n        graph.append([False]*n)\n\n    for road in roads:\n        graph[road[0]][road[1]] = True\n        graph[road[1]][road[0]] = True\n\n    count = 0\n    for row in graph:\n        count += row.count(False)\n    return str(count % 1000000007)\n\nsolution('')"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(M)]\n\n    s = set()\n    for road in roads:\n        s.add(road[1])\n        s.add(road[2])\n\n    res = 0\n    for road in roads:\n        if road[0] not in s:\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        _, a, b, l = map(int, input().split())\n        roads[a].append((b, l))\n        roads[b].append((a, l))\n    ans = []\n    for i in range(1, n + 1):\n        if not roads[i]:\n            ans.append(0)\n        else:\n            paths = []\n            roads_t = tuple(roads[i])\n            for j in roads[i]:\n                roads_t = tuple(sorted(roads_t + (j,)))\n                if roads_t in paths:\n                    break\n                else:\n                    paths.append(roads_t)\n            ans.append(len(paths))\n    return \"\\n\".join([str(i) for i in ans])\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = (int(x) for x in stdin.split())\n    ways = {\n        1: 0,\n        2: 0,\n        3: 0,\n    }\n    for _ in range(n):\n        s, e, l = (int(x) for x in stdin.split())\n        ways[2] += 1\n        ways[3] += 1\n        ways[l] += 1\n    for _ in range(m):\n        s, e, l = (int(x) for x in stdin.split())\n        ways[1] += 1\n        ways[e] += 1\n        ways[l] += 1\n    return''.join(map(str, (ways[1] % 1000000007, ways[2] % 1000000007, ways[3] % 1000000007)))\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Examples\n    --------\n    >>> solution(\"2 3\\n2 3 5\\n3 4 5\\n1 4 8\")\n    '4'\n    >>> solution(\"4 4\\n1 2 5\\n2 3 5\\n3 4 5\\n1 4 8\")\n    '3'\n    '''\n    N, M = map(int, stdin.split())\n    roads = []\n    count = 0\n    for _ in range(M):\n        roads.append(list(map(int, stdin.split())))\n    roads.sort(key=lambda x: (x[0], -x[1]))\n\n    def longest_path(roads):\n        longest_path_count = 0\n        end = roads[-1][1]\n        for start in roads:\n            if start[0] > end:\n                break\n            start_path = longest_path(roads[roads.index(start):]) + 1\n            end = max(end, start[1])\n            if start_path > longest_path_count:\n                longest_path_count = start_path\n        return longest_path_count\n\n    return str(longest_path(roads))\n"
    },
    {
        "number": 3092,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = []\n    for i in range(M):\n        A, B, L = map(int, stdin.split())\n        roads.append((A, B, L))\n    for i in range(len(roads)):\n        roads[i] = (roads[i][2], roads[i][0], roads[i][1])\n    roads.sort()\n    return str(roads)\nprint(solution(input()))\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    #TODO\n    return \"\""
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(i) for i in stdin.split())\n    f = [int(i) for i in stdin.split()]\n    MOD = 10 ** 9 + 7\n    dp = [[[0 for _ in range(K + 1)] for _ in range(N + 1)] for _ in range(N + 1)]\n    for i in range(N + 1):\n        for j in range(K + 1):\n            if i == 0:\n                dp[i][0][j] = 1\n            elif j == 0:\n                dp[i][0][j] = 1\n            else:\n                dp[i][0][j] = 0\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[i][0][j] = 0\n            for k in range(1, N + 1):\n                dp[i][k][j] = (dp[i][k - 1][j] + dp[i - 1][k][j] + dp[i - 1][k - 1][j - 1] - dp[i - 1][k - 1][j - 1]) % MOD\n    return str(dp[N][N][K])\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    f = [int(stdin) for stdin in stdin.split()]\n    nums = range(1, N + 1)\n    f = dict(zip(nums, f))\n    res = 0\n    for i in nums:\n        if i in f:\n            res += f[i] * (f[i] - 1) // 2\n        if i > 1:\n            for j in range(i, N + 1):\n                if j in f and i!= j and j - i == 1:\n                    res += f[j]\n    return str(res % 1000000007)"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    #2 2\n    #1 1\n    #1 1\n    #1 1\n    #1 1\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    #0 0\n    dp = {}\n    dp[0] = 1\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, N+1):\n        dp[i] = dp[i-1] + dp[i-2]\n    print(dp[N])"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    dp = [[0] * k for _ in range(n)]\n    dp[0][a[0]] = 1\n    for i in range(1, n):\n        for j in range(k):\n            if j!= a[i]:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n    return str(dp[-1][-1])"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, _, N, K = stdin.split()\n    N = int(N)\n    K = int(K)\n    f = list(map(int, stdin.split()))\n\n    res = 0\n    def dfs(n, k, a):\n        if n == K:\n            if a == N:\n                nonlocal res\n                res += 1\n            return\n\n        for i in range(N):\n            dfs(n+1, k, a | (1 << i))\n    \n    dfs(0, 0, 0)\n    return str(res % (10**9 + 7))"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    max_int = int(1e9)\n    fact = [1] * (max_int + 1)\n    for i in range(1, max_int + 1):\n        fact[i] = fact[i - 1] * i\n    def factorial(n):\n        if n == 0:\n            return 1\n        return fact[n]\n    return str(factorial(k) // (factorial(k - n) * factorial(n)))\n\nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    return str(solution_r(N, K))\n\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def isvalid(i, j, k):\n        return i <= j and j <= k and i > 0 and k > 0 and k < j\n\n    N, K = list(map(int, stdin.split()))\n    d = {}\n    for i in range(1, N + 1):\n        d[i] = 0\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if j == 0:\n                continue\n            if isvalid(i, j, j - 1):\n                dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j]\n            if j - 1!= 0 and isvalid(i, j - 1, j):\n                dp[i][j] += dp[i - 1][j - 1] + dp[i - 1][j]\n        for j in range(K + 1):\n            if j == 0:\n                continue\n            if isvalid(i, j - 1, j):\n                dp[i][j] += dp[i - 1][j]\n    print(dp[N][K])\n    return dp[N][K] % 1000000007\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3093,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    dp = [0] * (k + 1)\n    dp[0] = 1\n\n    for i in range(1, k + 1):\n        temp = 0\n        for j in range(n):\n            if i == arr[j]:\n                temp += dp[i - 1]\n            dp[i] += temp\n    return dp[-1] % 1000000007\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    res = 0\n    for i in range(n):\n        res += (1 << (i - 1)) * (1 << (n - i - 1)) * (s[i] - 1)\n    return res % (10**9 + 7)"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t_a = list(map(int, stdin.split()))\n    t_a.sort()\n    ways = [1, 1]\n    for i in range(n - 1):\n        if t_a[i] == t_a[i + 1]:\n            ways[0] += 1\n            ways[1] += 1\n    return str(ways[0] % 1000000007)\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        count += (1 + (n - 1) // t[i])\n    return str(count % 1000000007)\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1]))\n    s = {}\n    if n == 1:\n        s[1] = 1\n    else:\n        s[1] = 1\n        s[2] = 2\n        for i in range(2, n):\n            s[i] = 1 + s[i - 1] + s[i - 2]\n    return str(s[n])"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    table = {}\n\n    for i in range(1, n + 1):\n        table[i] = 0\n\n    for i in range(1, n + 1):\n        table[i] = table[i - 1] + 1\n\n        for j in range(1, i):\n            table[i] = min(table[i], table[j] + table[i - j])\n\n    return table[n] % 1000000007\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    d = defaultdict(int)\n    d[a[0]] = 1\n    total = 0\n    for i in range(1, n):\n        for j in range(i):\n            if a[j] < a[i]:\n                d[a[i]] = (d[a[i]] + d[a[j]]) % (10**9 + 7)\n        total += d[a[i]]\n        d[a[i]] = 0\n    return str(total % (10**9 + 7))"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.split()[0])\n    seats: list = list(map(int, stdin.split()[1]))\n    left = {x - 1 for x in range(1, n + 1)}\n    right = {x + 1 for x in range(1, n + 1)}\n    seats = sorted(seats)\n    for i in range(1, n):\n        if seats[i] == seats[i - 1]:\n            left.remove(seats[i - 1])\n        if seats[i] == seats[i - 1]:\n            right.remove(seats[i - 1])\n    return len(left) * len(right) % 1000000007\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    chair = list(map(int, stdin[1].split()))\n    chair.sort()\n    visited = {}\n    visited[chair[0]] = 1\n    visited[chair[1]] = 1\n    visited[chair[2]] = 1\n    queue = deque([[chair[0], 1], [chair[1], 1], [chair[2], 1]])\n    while queue:\n        start = queue.popleft()\n        if start[0] == chair[0]:\n            visited[start[0]] = 0\n            continue\n        if start[0] == chair[1]:\n            visited[start[0]] = 0\n            continue\n        if start[0] == chair[2]:\n            visited[start[0]] = 0\n            continue\n        if start[0] == chair[2] and start[1] == 2:\n            visited[start[0]] = 0\n            continue\n        if start[1] == 1:\n            if start[0] == chair[1]:\n                visited[start[0]] = 0\n                continue\n            if start[0] == chair[2]:\n                visited[start[0]] = 0\n                continue\n        if start[1] == 1 and start[0] == chair[2]:\n            visited[start[0]] = 0\n            continue\n        if start[1] == 2:\n            if start[0] == chair[1]:\n                visited[start[0]] = 0\n                continue\n            if start[0] == chair[2]:\n                visited[start[0]] = 0\n                continue\n        if start[0] == chair[1] and start[1] == 1:\n            visited[start[0]] = 0\n            continue\n        if start[0] == chair[2] and start[1] == 1:\n            visited[start[0]] = 0\n            continue\n        queue.append([start[0], start[1] + 1])\n        queue.append([start[0] + 1, start[1]])\n        queue.append([start[0] + 1, start[1] + 1])\n    return len(visited)\n"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    table = {}\n    for i in range(1,n+1):\n        table[i] = i\n\n    per_table = {}\n    for i in range(1,n+1):\n        per_table[i] = i\n\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            per_table[i] = min(per_table[i], min(table[i], table[j]))\n\n    answer = 1\n    for i in range(1,n+1):\n        answer = (answer*per_table[i])%10**9 + 7\n    return answer"
    },
    {
        "number": 3094,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    data = list(map(int, stdin.split()[1]))\n\n    def move(data, i):\n        if i < 1:\n            return 0\n        if i == 1:\n            return 1\n        if data[i-1] == i:\n            return move(data, i-1)\n        else:\n            return move(data, data[i-1]) + move(data, i-1)\n\n    return move(data, n) % (10**9 + 7)"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.strip().split())\n    A = [[int(i) for i in stdin.strip().split()] for _ in range(R)]\n    #rows, cols = range(R), range(S)\n    return str(max([count_cool_submatrices(R, S, A) for _ in range(R)]))\ndef"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n\n    A = list(map(int, stdin.split()))\n\n    cool_submatrix = 0\n\n    for i in range(R):\n        for j in range(S):\n            if cool_submatrix < abs(A[i][j] - sum([A[i][m] * A[m][j] for m in range(j + 1, S)] + [A[i][n] * A[n][j] for n in range(j + 1, R)])):\n                cool_submatrix = abs(A[i][j] - sum([A[i][m] * A[m][j] for m in range(j + 1, S)] + [A[i][n] * A[n][j] for n in range(j + 1, R)]))\n\n    return cool_submatrix\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_cool(matrix):\n        if matrix[0][0] + matrix[0][1] > matrix[1][0] + matrix[1][1]:\n            return False\n        for i in range(1, R - 1):\n            if (matrix[i][0] + matrix[i][1]) > (matrix[i - 1][0] + matrix[i - 1][1]):\n                return False\n        for i in range(1, S - 1):\n            if (matrix[0][i] + matrix[1][i]) > (matrix[0][i - 1] + matrix[1][i - 1]):\n                return False\n        return True\n\n    def get_submatrix(matrix, r1, c1, r2, c2):\n        return matrix[r1:r2+1, c1:c2+1]\n\n    max_cool_submatrix_size = 0\n    for i in range(1, R - 1):\n        for j in range(1, S - 1):\n            submatrix = get_submatrix(matrix, i, j, i+1, j+1)\n            if is_cool(submatrix):\n                max_cool_submatrix_size = max(max_cool_submatrix_size, len(submatrix))\n    return str(max_cool_submatrix_size) if max_cool_submatrix_size > 0 else '0'\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = [[int(i) for i in stdin.split()[j]] for j in range(R)]\n    n_rows = len(A)\n    n_cols = len(A[0])\n    res = 0\n\n    for r in range(2, n_rows):\n        for c in range(2, n_cols):\n            if A[r - 1][c - 1] + A[r - 1][c] + A[r - 1][c - 1] <= A[r - 1][c - 1] + A[r - 1][c] + A[r - 1][c - 1]:\n                break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r > 1 and r + c < n_cols - 1:\n                if r - 1 < n_rows and r + c < n_cols - 1 and A[r - 1][c] + A[r][c + 1] <= A[r - 1][c] + A[r][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r > 0 and r + c < n_cols - 1:\n                if r - 1 < n_rows and r + c < n_cols - 1 and A[r][c] + A[r + 1][c] <= A[r][c] + A[r + 1][c]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r > 0 and r + c < n_cols - 1:\n                if r - 1 < n_rows and r + c < n_cols - 1 and A[r][c] + A[r - 1][c] <= A[r][c] + A[r - 1][c]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r + c < n_cols - 1:\n                if r + 1 < n_rows and r + c < n_cols - 1 and A[r][c] + A[r][c + 1] <= A[r][c] + A[r][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r + c < n_cols - 1:\n                if r + 1 < n_rows and r + c < n_cols - 1 and A[r][c] + A[r + 1][c] <= A[r][c] + A[r + 1][c]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r + c < n_cols - 1:\n                if r + 1 < n_rows and r + c < n_cols - 1 and A[r][c] + A[r][c + 1] <= A[r][c] + A[r][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if c > 0 and c + 1 < n_cols:\n                if r + 1 < n_rows and r + c < n_cols and A[r][c] + A[r + 1][c + 1] <= A[r][c] + A[r + 1][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if r + 1 < n_rows and r + c < n_cols:\n                if r + 1 < n_rows and r + c < n_cols and A[r][c] + A[r + 1][c] <= A[r][c] + A[r + 1][c]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if c > 0 and c + 1 < n_cols:\n                if r + 1 < n_rows and r + c < n_cols and A[r][c] + A[r][c + 1] <= A[r][c] + A[r][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    for r in range(n_rows):\n        for c in range(n_cols):\n            if c > 0 and c + 1 < n_cols:\n                if r + 1 < n_rows and r + c < n_cols and A[r][c] + A[r][c + 1] <= A[r][c] + A[r][c + 1]:\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n    else:\n        res = 0\n    return str(res)\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for _ in range(R):\n        A.append(list(map(int, stdin.split())))\n\n    M = max([max(row) for row in A])\n    N = max([max(col) for col in zip(*A)])\n\n    return '{}'.format(max([M + N - A[i][j] for i in range(R) for j in range(S)]))\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = [[int(x) for x in stdin.split()] for i in range(R)]\n\n    def cool(A):\n        res = 0\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if j >= 2:\n                    if A[i][j] > A[i][j-1] + A[i][j-2]:\n                        return False\n                if i >= 2:\n                    if A[i][j] > A[i-1][j] + A[i-2][j]:\n                        return False\n        return True\n\n    def isCool(A):\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if i >= 2:\n                    if A[i][j] > A[i-1][j] + A[i-2][j]:\n                        return False\n                if j >= 2:\n                    if A[i][j] > A[i][j-1] + A[i][j-2]:\n                        return False\n        return True\n\n    def isCool2(A):\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if i >= 2 and j >= 2:\n                    if A[i][j] > A[i-1][j] + A[i-2][j]:\n                        return False\n                if i >= 2 and j >= 1:\n                    if A[i][j] > A[i-1][j] + A[i-2][j-1]:\n                        return False\n                if j >= 2 and i >= 1:\n                    if A[i][j] > A[i][j-1] + A[i-1][j-2]:\n                        return False\n                if i >= 2 and j >= 1:\n                    if A[i][j] > A[i-1][j] + A[i-2][j-1]:\n                        return False\n        return True\n\n    def isCool3(A):\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if i >= 2:\n                    if A[i][j] > A[i-1][j]:\n                        return False\n                if j >= 2:\n                    if A[i][j] > A[i][j-1]:\n                        return False\n        return True\n\n    def isCool4(A):\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if i >= 2:\n                    if A[i][j] > A[i-1][j]:\n                        return False\n                if j >= 2:\n                    if A[i][j] > A[i][j-1]:\n                        return False\n        return True\n\n    def isCool5(A):\n        for i in range(len(A)):\n            for j in range(len(A[i])):\n                if j >= 2:\n                    if A[i][j] > A[i][j-1]:\n                        return False\n                if i >= 2:\n                    if A[i][j] > A[i-1][j]:\n                        return False\n        return True\n\n    for i in range(len(A)):\n        for j in range(len(A[i])):\n            if cool(A):\n                res += 1\n            if isCool(A):\n                res += 1\n            if isCool2(A):\n                res += 1\n            if isCool3(A):\n                res += 1\n            if isCool4(A):\n                res += 1\n            if isCool5(A):\n                res += 1\n    print(res)\n    return res\n\nsolution(input())"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = [list(map(int, stdin.split())) for _ in range(R)]\n    result = 0\n\n    def cool(r, s, i, j, A):\n        if r == 0 or s == 0:\n            return False\n        if (A[i][0] + A[r - 1][s - 1]) > (A[i][s - 1] + A[r - 1][0]):\n            return False\n        if A[0][0] + A[r - 1][0] > A[0][s - 1] + A[0][0]:\n            return False\n        if r < 2 or s < 2:\n            return True\n        if cool(r - 2, s - 2, i, j, A) and cool(r - 2, s - 1, i, j, A) and cool(r - 1, s - 2, i, j, A) and cool(r - 1, s - 1, i, j, A):\n            return True\n\n    def veryCool(i, j, A):\n        result = 0\n        for r in range(i, len(A)):\n            for s in range(j, len(A[0])):\n                if A[r][s] == 1:\n                    if r < 2 or s < 2:\n                        result += 1\n                    if cool(r, s, i, j, A):\n                        result += veryCool(r, s, A)\n        return result\n\n    return str(veryCool(0, 0, A))\n"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = [[int(i) for i in stdin.split()] for _ in range(R)]\n    return max([sum(r) + sum(s) for r in range(R) for s in range(S - 2) if r + 2 < R and s + 2 < S and sum(A[r]) + sum(A[r + 2]) <= sum(A[r + 1]) + sum(A[r + 2 + 1]) and sum(A[s]) + sum(A[s + 2]) <= sum(A[s + 1]) + sum(A[s + 2 + 1]) and max(r, s) + 1 > min(r, s)] or 0)"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    matrix = [[int(x) for x in stdin.split()] for _ in range(R)]\n    ans = 0\n    for i in range(R):\n        for j in range(S):\n            if i == 0 and j == 0:\n                continue\n            if i > 0 and j == 0:\n                if matrix[i][j] > matrix[i - 1][j]:\n                    ans += 1\n            elif j > 0 and i == 0:\n                if matrix[i][j] > matrix[i][j - 1]:\n                    ans += 1\n            else:\n                if matrix[i][j] > matrix[i - 1][j] + matrix[i][j - 1]:\n                    ans += 1\n    return str(ans)"
    },
    {
        "number": 3095,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    r, s = map(int, stdin.pop(0).split())\n    arr = [[int(i) for i in stdin.pop(0).split()] for _ in range(r)]\n    max_ = 0\n    for row in range(r):\n        for col in range(s):\n            for next_row in range(row + 1, r):\n                if arr[row][col] + arr[next_row][s - 1 - col] > arr[next_row][col]:\n                    break\n            else:\n                max_ = max(max_, (row + 1) * (s - 1 - col))\n    for col in range(s):\n        for next_col in range(col + 1, s):\n            for next_row in range(r - 1, -1, -1):\n                if arr[row][col] + arr[r - 1 - next_row][next_col] > arr[r - 1 - next_row][col]:\n                    break\n            else:\n                max_ = max(max_, (col + 1) * (r - 1 - next_row))\n    return str(max_)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    V = stdin.split()[1]\n    d = {}\n    for i in range(len(V)):\n        if d.get(V[i]):\n            d[V[i]] = d[V[i]] + 1\n        else:\n            d[V[i]] = 1\n    d = sorted(d.items(), key=lambda x: x[0])\n    i = 0\n    ans = 1\n    while i < len(d):\n        if d[i][1] > 1:\n            if d[i][0] - d[i - 1][0] == 1 or d[i][0] - d[i - 1][0] == -1:\n                ans += 1\n        i += 1\n    return str(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N = int(stdin)\n    V = list(map(int, stdin.split()))\n    V.sort()\n    k = 1\n    f = 0\n    while k < N:\n        for i in range(k - 1):\n            if V[i] == V[i + 1]:\n                f += 1\n        if f == 0:\n            return \"0\"\n        k += 1\n        f = 0\n    return \"2\""
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    print(sorted(list(map(int, stdin[0].split(\" \")))))\n    #print(sorted(list(map(int, stdin[1].split(\" \")))))\n    #print(sorted(list(map(int, stdin[2].split(\" \")))))\n    #print(sorted(list(map(int, stdin[3].split(\" \")))))\n    d = {}\n    for x in stdin[0]:\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n    for x in stdin[1]:\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n    for x in stdin[2]:\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n    for x in stdin[3]:\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n    #print(d)\n    tot = 0\n    for i in range(len(stdin)-4):\n        if len(stdin[i]) == len(stdin[i+1]):\n            a = sorted(list(map(int, stdin[i].split(\" \"))))\n            b = sorted(list(map(int, stdin[i+1].split(\" \"))))\n            if a == b:\n                continue\n            tot += 1\n    return str(tot)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return len(set(tuple(map(int, stdin.split()))))\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split()\n    N = int(inputs[0])\n    for i in range(1, N + 1):\n        if inputs[i] == '1':\n            continue\n        id_s = int(inputs[i])\n        jokes = list(map(int,inputs[i+1].split()))\n        for j in range(len(jokes) - 1):\n            if jokes[j] > jokes[j+1]:\n                break\n        else:\n            print(j+1)\n    return '\\n'\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    V = list(map(int, stdin.strip().split()))\n    R = [0] * (max(V) + 1)\n    for i in range(1, N):\n        R[V[i]] += 1\n    ans = 0\n    for i in range(1, N):\n        if V[i] - V[i - 1] > 1:\n            if R[V[i]] > 1:\n                ans += (R[V[i]] - 1)\n        if V[i - 1]!= V[i] - 1 and R[V[i]] > 0:\n            ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    l = list(map(int, stdin.split()))\n    supers = {}\n    jokes = {}\n    cnt = 0\n    for i in range(n):\n        if l[i] not in supers:\n            supers[l[i]] = set()\n        else:\n            supers[l[i]].add(l[i])\n        if l[i] not in jokes:\n            jokes[l[i]] = set()\n        else:\n            jokes[l[i]] = jokes[l[i]] | set([l[i]])\n    for i in range(n):\n        if i!= l[i]:\n            if l[i] not in jokes[l[i]]:\n                jokes[l[i]] = jokes[l[i]] | set([l[i]])\n    for k, v in supers.items():\n        if k == 1 and v:\n            continue\n        if k == 1 and not v:\n            continue\n        if len(v) > 1:\n            return \"-1\"\n        if 1 in v:\n            for j in v:\n                if jokes[j]:\n                    if len(jokes[j]) > 1:\n                        return \"-1\"\n                    elif len(jokes[j]) == 1:\n                        cnt += 1\n        if 1 not in v:\n            if 1 in v:\n                for j in v:\n                    if jokes[j]:\n                        if len(jokes[j]) > 1:\n                            cnt += 1\n    return str(cnt)\n    '''\n    # wrong answer\n    supers = {}\n    jokes = {}\n    cnt = 0\n    for i in range(n):\n        if l[i] not in supers:\n            supers[l[i]] = set()\n        else:\n            supers[l[i]].add(l[i])\n        if l[i] not in jokes:\n            jokes[l[i]] = set()\n        else:\n            jokes[l[i]] = jokes[l[i]] | set([l[i]])\n    for i in range(n):\n        if i!= l[i]:\n            if l[i] not in jokes[l[i]]:\n                jokes[l[i]] = jokes[l[i]] | set([l[i]])\n    for k, v in supers.items():\n        if k == 1 and v:\n            continue\n        if k == 1 and not v:\n            continue\n        if len(v) > 1:\n            return \"-1\"\n        if 1 in v:\n            for j in v:\n                if jokes[j]:\n                    if len(jokes[j]) > 1:\n                        return \"-1\"\n                    elif len(jokes[j]) == 1:\n                        cnt += 1\n        if 1 not in v:\n            if 1 in v:\n                for j in v:\n                    if jokes[j]:\n                        if len(jokes[j]) > 1:\n                            cnt += 1\n    return str(cnt)\n    '''\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.strip())\n    V = list(map(int, stdin.strip().split()))\n    V.sort()\n    d = {}\n    for i in V:\n        if i in d.keys():\n            d[i] += 1\n        else:\n            d[i] = 1\n    sets = 0\n    for k,v in d.items():\n        if v==1:\n            continue\n        if (v-1)%2==0:\n            sets+=v//2\n        else:\n            sets+=v//2+1\n    return sets"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    V = list(map(int, stdin.split()))\n    V = sorted(V)\n    sets = []\n    for i in range(1, N+1):\n        if V.count(i) > 1:\n            continue\n        sets.append(i)\n    for i in range(1, N):\n        if V[i] - V[i-1]!= 1:\n            if V[i-1] - V[i] > 1:\n                if V[i] in sets:\n                    sets.remove(V[i])\n            else:\n                if V[i] in sets:\n                    sets.remove(V[i])\n    return len(sets)\n"
    },
    {
        "number": 3096,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    n_sets = 0\n    for _ in range(n-1):\n        if _ % 2 == 0:\n            continue\n        n_sets += (\n            _ + 1\n            - sum(\n                1\n                for j in range(1, n + 1)\n                if j > 1 and j < _ and (j + 1) % j == 0\n            )\n        )\n    return str(n_sets)\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    ans = x\n    while x >= 10:\n        ans += x % 10\n        x //= 10\n    return str(ans)\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Q: int = int(stdin.split()[0])\n    queries = [[int(i) for i in stdin.split()[1:]] for _ in range(Q)]\n    cache: Dict[Tuple[int, int], int] = dict()\n    # first answer, # of appearances\n    # then, # of appearances of the left\n    # and then, # of appearances of the right\n    # in each interval\n    ans: int = 0\n    left: int = 0\n    right: int = 0\n    for query in queries:\n        # left\n        if query[0] - left > 0:\n            ans += query[0] - left\n        else:\n            ans += 0\n        # right\n        if query[1] - right > 0:\n            ans += query[1] - right\n        else:\n            ans += 0\n        # total\n        ans += 1\n        # increment left\n        if query[0] < left:\n            left = query[0]\n        # increment right\n        if query[1] > right:\n            right = query[1]\n    # return the answer\n    return str(ans)"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.split()[0])\n    for i in range(Q):\n        [a, b] = list(map(int, stdin.split()[i+1].split(' ')))\n        cnt = 0\n        for j in range(a, b+1):\n            cnt += j//2\n        print(cnt)"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin)\n    for i in range(q):\n        n1, n2 = list(map(int, stdin.strip().split()))\n        a = n1\n        b = n2\n        ans = 1\n        while a <= b:\n            ans *= a\n            a += 1\n        print(ans)\n    return '\\n'\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return ''.join(str(sum(1 for i in range(int(j)) if int(i) < int(k)) for j, k in zip(*(iter(stdin.strip()),) * 2)))\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    q: int = int(stdin.split('\\n')[0])\n    all_q: list = []\n    for _ in range(q):\n        a, b = map(int, stdin.split('\\n')[1].split())\n        all_q.append([a, b])\n    return str(sum([x[1] - x[0] + 1 for x in all_q]))\n"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    Q = int(stdin.split()[0])\n    assert 1 <= Q <= 10 ** 5\n    assert len(stdin.split()) == 2 * Q\n    return '\\n'.join(str(answer) for answer in range(1, 101))"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin)\n    for _ in range(Q):\n        A, B = map(int, stdin.split())\n        print(count_elements_in_range(A, B))\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 1 10\n   ... 5 8\n   ... ''')\n    '18'\n    >>> solution('''\n   ... 2 17\n   ... 121 121\n   ... 89 98\n   ... ''')\n    '265'\n    \"\"\"\n    N = int(stdin.strip())\n    rows = {}\n    for i in range(1, 10):\n        rows[i] = [1, 1]\n\n    for i in range(2, 10):\n        rows[i][0] = rows[i - 1][0] + rows[i - 1][1]\n        rows[i][1] = rows[i - 1][0]\n        rows[i][0] = rows[i][0] + rows[i - 1][1]\n\n    def count(left, right):\n        if left <= 1 or left > right:\n            return 0\n        if left == right:\n            return rows[left][0]\n        return rows[left][0] + rows[left][1] + count(left + 1, right)\n\n    return str(count(1, N))\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def triang(x0, y0, x1, y1, x2, y2):\n        return abs(x0 * y1 - x1 * y0 - x2 * y0 + x2 * y1 + x1 * y2 - x0 * y2) / 2.0\n\n    n, k = map(int, stdin.split())\n    points = [list(map(float, stdin.split())) for _ in range(n)]\n\n    ans = 0.0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if triang(points[i][0], points[i][1], points[j][0], points[j][1], points[k][0], points[k][1]):\n                    ans += 1.0\n\n    return \"{:.6f}\".format(ans / 6.0)\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cake = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        cake.append([x, y])\n    cake.sort()\n    cake.reverse()\n    b = cake[k-1]\n    c = cake[k]\n    d = cake[k+1]\n    a = (b[0] - c[0])*(d[1] - a[1]) - (b[1] - c[1])*(a[0] - d[0])\n    return a\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cake = []\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        cake.append([a, b])\n    cake.sort()\n\n    x, y = cake[0]\n    z = cake[-1]\n    r = -1\n    for i in range(n):\n        if cake[i][0] > x and cake[i][1] > y:\n            r = i\n        elif cake[i][0] < x and cake[i][1] < y:\n            r = i\n            break\n\n    def checkCollinear(vertices, vertices_no):\n        m = len(vertices)\n        if m <= 2:\n            return False\n        if m == 3:\n            return True\n\n        for i in range(m - 2):\n            for j in range(i + 1, m - 1):\n                for k in range(j + 1, m):\n                    x1 = vertices[i][0]\n                    y1 = vertices[i][1]\n                    x2 = vertices[j][0]\n                    y2 = vertices[j][1]\n                    x3 = vertices[k][0]\n                    y3 = vertices[k][1]\n                    if (x1, y1) == (x2, y2):\n                        return True\n                    if (x1, y1) == (x3, y3):\n                        return True\n                    if (x1, y1) == (x2, y2):\n                        return True\n                    if (x2, y2) == (x3, y3):\n                        return True\n\n    if k == 3:\n        return 0.5\n    x = cake[r][0]\n    y = cake[r][1]\n    z = cake[-1][0]\n    p = cake[-1][1]\n    if r == 0:\n        if cake[1][0] - cake[0][0] == 0:\n            m = abs(cake[1][0] - cake[0][0])\n            if m == 0:\n                return 0.5\n            else:\n                return 0\n        else:\n            return (p - y) / (x - cake[1][0])\n    if r == n - 1:\n        if cake[-2][0] - cake[-1][0] == 0:\n            m = abs(cake[-2][0] - cake[-1][0])\n            if m == 0:\n                return 0.5\n            else:\n                return 0\n        else:\n            return (p - y) / (x - cake[-2][0])\n    if cake[1][0] - cake[0][0] == 0:\n        return 0.5\n    if cake[-1][0] - cake[r][0] == 0:\n        return 0.5\n    x = cake[r][0]\n    y = cake[r][1]\n    z = cake[-1][0]\n    p = cake[-1][1]\n    a = cake[r][1]\n    b = cake[-1][1]\n    if cake[r][0]!= cake[-1][0]:\n        if cake[r][1] - cake[-1][1] == 0:\n            m = abs(cake[r][1] - cake[-1][1])\n            if m == 0:\n                return 0.5\n            else:\n                return 0\n        else:\n            return (p - y) / (x - cake[r][0])\n    else:\n        return (p - y) / (x - cake[r][0])\n    if checkCollinear(cake, r):\n        return (p - y) / (x - cake[r][0])\n    else:\n        return 0.5\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n, k = map(int, stdin[0].split())\n    cake = []\n    for _ in range(n):\n        x, y = map(float, stdin[1 + _].split())\n        cake.append((x, y))\n    cake = sorted(cake, key=lambda x: x[0])\n    cake = sorted(cake, key=lambda x: x[1])\n    total_area = 0.0\n    count = 0\n    while count < k:\n        x, y = cake.pop(0)\n        new_area = x * (n - 1 - count) + y * count\n        total_area += new_area\n        count += 1\n    return '%.12lf' % total_area\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, k = map(int, stdin.strip().split())\n    cake = []\n    for _ in range(n):\n        x, y = map(float, stdin.strip().split())\n        cake.append((x, y))\n    area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = cake[i]\n            x2, y2 = cake[j]\n            a = (x2 - x1) * (y1 + y2)\n            area += a\n            for j in range(k):\n                x3, y3 = cake[(i + j) % n]\n                x4, y4 = cake[(i - j + n - 1) % n]\n                a = (x4 - x3) * (y3 + y4)\n                area += a\n            if i == j:\n                for j in range(k):\n                    x3, y3 = cake[(i + j) % n]\n                    x4, y4 = cake[(i - j + n - 1) % n]\n                    a = (x4 - x3) * (y3 + y4)\n                    area += a\n    return area\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    cake = []\n    for i in range(n):\n        x, y = map(float, stdin.strip().split())\n        cake.append((x, y))\n    cake.sort(key=lambda x: x[1])\n    res = 0.0\n    for i in range(k):\n        a, b = cake[i], cake[(i+1) % k]\n        l = max(0.0, a[1] - b[1])\n        r = min(a[0], b[0]) - a[0]\n        res += l * r\n    return \"{0:.10f}\".format(res)\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.strip().split()))\n    #c = []\n    #for i in range(n):\n    #    c.append(list(map(float, stdin.strip().split())))\n    \n    vertices = set()\n    while len(vertices) < k:\n        c = list(map(float, stdin.strip().split()))\n        vertices.update(c)\n    \n    def area(c):\n        return (abs(c[0][0] - c[1][0]) * abs(c[1][1] - c[2][1])\n                + abs(c[2][0] - c[3][0]) * abs(c[3][1] - c[0][1])) / 2\n    \n    return str(area(vertices))"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    x = []\n    y = []\n    for i in range(n):\n        x.append(float(stdin.strip().split()[i]))\n        y.append(float(stdin.strip().split()[n + i]))\n    vertices = [x, y]\n    vertices = sorted(vertices)\n    max_x = vertices[0][0]\n    min_x = vertices[0][0]\n    max_y = vertices[0][1]\n    min_y = vertices[0][1]\n    for i in range(n):\n        if vertices[i][0] > max_x:\n            max_x = vertices[i][0]\n        if vertices[i][1] > max_y:\n            max_y = vertices[i][1]\n        if vertices[i][0] < min_x:\n            min_x = vertices[i][0]\n        if vertices[i][1] < min_y:\n            min_y = vertices[i][1]\n    l = max_x - min_x\n    h = max_y - min_y\n    if l == 0 or h == 0:\n        return 0\n    pieces = 0\n    for i in range(k):\n        x1 = float(stdin.strip().split()[3 * i])\n        y1 = float(stdin.strip().split()[3 * i + 1])\n        x2 = float(stdin.strip().split()[3 * i + 2])\n        y2 = float(stdin.strip().split()[3 * i + 3])\n        if x1 == x2:\n            y = (y1 + y2) / 2\n            if y < min_y or y > max_y:\n                continue\n            if (x1 - min_x) * (y2 - y) > 0:\n                continue\n        elif y1 == y2:\n            x = (x1 + x2) / 2\n            if x < min_x or x > max_x:\n                continue\n            if (x2 - x1) * (y1 - min_y) > 0:\n                continue\n        pieces += 1\n    return l * h / pieces\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    vertices = sorted(list(map(float, stdin.split())))\n    return '{0:.10f}'.format((-vertices[0] + vertices[-1]) * (vertices[1] - vertices[0]))\n"
    },
    {
        "number": 3098,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    return f'{np.mean(np.array(np.array(list(map(float, stdin.split())), dtype=float).reshape((n, 2))[:k, :])):.10f}'\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nspies, nexte, num = map(int, stdin.split())\n    spy1 = set([i for i in range(nspies)])\n    spy2 = set([])\n    spy3 = set([])\n    spy4 = set([])\n    spies = [spy1, spy2, spy3, spy4]\n    connections = [set() for _ in range(nspies)]\n    for _ in range(nexte):\n        x, y = map(int, stdin.split())\n        connections[x].add(y)\n        connections[y].add(x)\n    for _ in range(num):\n        for i in range(len(connections)):\n            for j in connections[i]:\n                if j in spy1:\n                    spy1.discard(j)\n                    spies[i].add(j)\n                if j in spy2:\n                    spy2.discard(j)\n                    spies[i].add(j)\n                if j in spy3:\n                    spy3.discard(j)\n                    spies[i].add(j)\n                if j in spy4:\n                    spy4.discard(j)\n                    spies[i].add(j)\n    return len(spy1)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n_spies, n_enemies, n_connections = map(int, stdin.split())\n    connections = defaultdict(set)\n    enemies = set()\n\n    for _ in range(n_connections):\n        s1, s2 = map(int, stdin.split())\n        connections[s1].add(s2)\n        connections[s2].add(s1)\n\n    for _ in range(n_enemies):\n        s = int(stdin)\n        enemies.add(s)\n\n    spies_by_connections = defaultdict(set)\n    for s in range(1, n_spies + 1):\n        spies = set()\n        spies_by_connections[s] = spies\n        for s2 in connections[s]:\n            if s2!= s:\n                spies.add(s2)\n\n    spies_by_enemies = defaultdict(set)\n    for s in enemies:\n        spies = set()\n        spies_by_enemies[s] = spies\n\n    spies_by_enemies.update(spies_by_connections)\n\n    min_messages = n_enemies\n    for s in range(1, n_spies + 1):\n        spy = spies_by_enemies[s]\n        if len(spy) < min_messages:\n            min_messages = len(spy)\n\n    return str(min_messages)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = list(map(int, stdin.split()))\n    return str(min([s[0], s[1]]))\n\n\nprint(solution(input()))\nprint(solution(input()))\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s, e, c = map(int, stdin.split())\n    s_spy = [i for i in range(1, s + 1)]\n    e_spy = []\n    for i in range(e):\n        e_spy.append(int(stdin.split()[2 * i + 1]))\n    l = len(s_spy)\n    min_m = s * (s - 1) // 2 + s * (s - 2) // 2\n    for i in range(len(s_spy)):\n        for j in range(i + 1, len(s_spy)):\n            for k in range(len(s_spy)):\n                if s_spy[i] == s_spy[j] or s_spy[k] == s_spy[j] or s_spy[k] == s_spy[i]:\n                    continue\n                m = len(s_spy) - 1\n                if m > 2:\n                    for u in range(2, m + 1):\n                        if s_spy[i] < s_spy[j] < s_spy[u] or s_spy[j] < s_spy[i] < s_spy[u] or s_spy[i] < s_spy[k] < s_spy[u] or s_spy[k] < s_spy[i] < s_spy[u]:\n                            m = u\n                            break\n                if s_spy[i] == s_spy[j]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif s_spy[i] == s_spy[k]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif s_spy[i] == s_spy[m]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif s_spy[j] == s_spy[k]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif s_spy[j] == s_spy[m]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif s_spy[k] == s_spy[m]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif e_spy[i] == e_spy[j]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1) // 2 + s * (s - 2) // 2 + (s - 3) * (s - 2) // 2)\n                elif e_spy[j] == e_spy[k]:\n                    if s_spy[i] == e_spy[i] or s_spy[j] == e_spy[j] or s_spy[k] == e_spy[k] or s_spy[m] == e_spy[m]:\n                        min_m = min(min_m, s * (s - 1)"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n, e, c = (int(x) for x in stdin.split())\n    s = list(range(1, n+1))\n    l = []\n    m = 0\n    for i in range(c):\n        x = list(map(int, stdin.split()))\n        l.append(x)\n    a = set(s)\n    b = set()\n    c = []\n    for i in range(len(l)):\n        c.append(l[i][0])\n        b.add(l[i][1])\n    d = list(b.intersection(a))\n    e = len(d)\n    for i in range(len(c)):\n        if c[i] in d:\n            e += 1\n    if e <= e:\n        m = e\n    else:\n        m = e-1\n    return str(m)\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    (S,E,C) = map(int,stdin.split())\n    edges = collections.defaultdict(set)\n    enemies = collections.defaultdict(set)\n    for _ in range(E):\n        a,b = map(int,stdin.split())\n        edges[a].add(b)\n        edges[b].add(a)\n        enemies[a].add(b)\n        enemies[b].add(a)\n    visited = set()\n    visited.add(0)\n    def dfs(node):\n        visited.add(node)\n        if len(visited) == S+1:\n            return True\n        for nei in edges[node]:\n            if nei not in visited and dfs(nei):\n                return True\n        return False\n    return sum(1 for v in enemies.values() if dfs(v))\n\nsolution(\"4 1 3\")\nsolution(\"4 0 4\")\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2, s3 = map(int, stdin.strip().split())\n    c1 = 0\n    c2 = 0\n    res = 0\n    for i in range(s1):\n        for j in range(s2):\n            for k in range(s3):\n                if i!= j and j!= k and i!= k:\n                    c1 += 1\n    for i in range(s1):\n        for j in range(s2):\n            if i!= j:\n                c2 += 1\n    if c1 >= c2:\n        res = c1\n    else:\n        res = c2\n    return str(res)"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    spies = {}\n    n_spies = 0\n    n_enemies = 0\n    connections = {}\n    for _ in range(int(stdin.split()[0])):\n        line = stdin.split()[1:]\n        n_spies += 1\n        n_enemies += 1\n        spies[line[0]] = int(line[1])\n        connections[line[0]] = set()\n        for i in range(2, len(line), 2):\n            connections[line[0]].add(line[i])\n            connections[line[i]].add(line[0])\n    cnt_spy_emitters = 0\n    for connection in connections.values():\n        if len(connection) == 1:\n            cnt_spy_emitters += 1\n    cnt_spy_emitters = cnt_spy_emitters // 2\n    cnt_spy_messages = 0\n    for connection in connections.values():\n        cnt_spy_messages += (len(connection) - 1) * cnt_spy_emitters\n    return str(cnt_spy_messages)\n"
    },
    {
        "number": 3099,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # To start the timer\n    start = time()\n    # Parse the input\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    # Ensure that k is smaller than n, else we can't get to it\n    if k > n - 1:\n        return\n    # Sort the a array\n    a.sort()\n    # To make sure that we get k\n    a.append(n + 1)\n    # To start from the end and iterate for n times\n    i = n - 1\n    # Keep on iterating until we find the point that we want\n    while i >= k - 1:\n        # Make sure that we don't get to the end\n        if a[i] == n + 1:\n            i -= 1\n        else:\n            # Print the number of elements we need to send\n            print(n - a[i] + 1)\n            # Decrement the count\n            i -= 1\n    # Print the number of elements we need to send\n    print(n - a[i])\n    # Return the time taken\n    return time() - start"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    return str(int(2**(a+c+m)*factorial(a+c)/factorial(a)/factorial(c)\n                    /factorial(m)))"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mul = 1\n    for i in range(A, C+1, 1):\n        mul *= i\n    for i in range(A, M+1, 1):\n        mul *= i\n    for i in range(C, M+1, 1):\n        mul *= i\n    mul %= (10**9+7)\n    return mul\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    a, c, m = map(int, stdin[0].split())\n    if a!= c or a!= m or a == c == m:\n        return 0\n    elif c!= m:\n        return (a * (c - 1) + m * (m - 1)) % 1000000007\n    else:\n        return (a * (c - 1) * 2 + m * (m - 1)) % 1000000007\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    return str(int((math.factorial(A) / (math.factorial(A - 2) * math.factorial(C) * math.factorial(M - 2)))) % (10**9 + 7))"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    return str(dp_memo_dp(A, C, M))\n\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n_a, n_c, n_m = stdin.split()\n    n_a, n_c, n_m = int(n_a), int(n_c), int(n_m)\n    total_mangos = n_m\n    total_cherries = n_m * 3 + n_a\n    total_apples = n_a + n_c\n    combinations = []\n    while total_mangos > 0:\n        # Apples can be taken from both sides.\n        if total_cherries > 0 and total_apples > 0:\n            combinations.append('a')\n            total_cherries -= 1\n            total_apples -= 1\n        # Mangos can be taken from either side.\n        elif total_mangos > 0:\n            combinations.append('m')\n            total_mangos -= 1\n        # Cherry can be taken from either side.\n        elif total_cherries > 0:\n            combinations.append('c')\n            total_cherries -= 1\n        # Apples can be taken from either side.\n        elif total_apples > 0:\n            combinations.append('a')\n            total_apples -= 1\n    return len(combinations) % 1000000007\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    a_i = 1\n    c_i = 1\n    m_i = 1\n    while True:\n        c_next = c_i + (c_i - 1) % c\n        m_next = m_i + (m_i - 1) % m\n        a_next = a_i + (a_i - 1) % a\n        if a_next == a_next + c_next:\n            return 0\n        elif m_next == m_next + c_next:\n            return 0\n        elif a_next == a_next + m_next:\n            return 0\n        else:\n            c_i = c_next\n            m_i = m_next\n            a_i = a_next\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    dp = [[0]*(M+1) for _ in range(C+1)]\n    for a in range(1, A+1):\n        for c in range(1, C+1):\n            for m in range(1, M+1):\n                if a == 1 and c == 1 and m == 1:\n                    dp[a][m] = 1\n                else:\n                    dp[a][m] = (dp[a-1][m] + dp[a][m-1] + dp[a-1][m-1]) % 1000000007\n    return str(dp[A][M])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def fact(n: int) -> int:\n        if n == 1:\n            return 1\n        else:\n            return n * fact(n-1)\n    \n    A, C, M = map(int, stdin.split())\n    \n    num_apples = fact(A)\n    num_cherries = fact(C)\n    num_mangos = fact(M)\n    \n    num_boxes = []\n    \n    for apple in range(num_apples + 1):\n        for cherry in range(num_cherries + 1):\n            for mango in range(num_mangos + 1):\n                if apple + cherry + mango!= 0:\n                    if apple == cherry and apple == mango:\n                        continue\n                    if apple + mango == cherry and apple == apple:\n                        continue\n                    if cherry + mango == apple and cherry == apple:\n                        continue\n                    num_boxes.append(apple + cherry + mango)\n    \n    if len(num_boxes) == 0:\n        return 0\n    \n    p = int(fact(len(num_boxes))/10**9 + 7)\n    \n    return sum(map(lambda x: x % p, num_boxes))\n"
    },
    {
        "number": 3100,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def apple(apple, cherry):\n        if apple == 0 or cherry == 0:\n            return 0\n        if apple == 1 and cherry == 1:\n            return 2\n        elif apple == 1 or cherry == 1:\n            return 3\n        else:\n            return apple + cherry + apple + cherry + apple + cherry\n    \n    def cherry(apple, cherry):\n        if apple == 0 or cherry == 0:\n            return 0\n        if apple == 1 and cherry == 1:\n            return 2\n        elif apple == 1 or cherry == 1:\n            return 3\n        else:\n            return apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry\n    \n    def mango(apple, cherry):\n        if apple == 0 or cherry == 0:\n            return 0\n        if apple == 1 or cherry == 1:\n            return 2\n        else:\n            return apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry + apple + cherry +"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    for x in range(len(stdin)):\n        test = stdin.splitlines()\n        new = []\n        for y in range(len(test[x])):\n            if test[x][y]!= 0:\n                if y == 0:\n                    new.append(0)\n                else:\n                    new.append(int(test[x][y-1]) + int(test[x][y]))\n            else:\n                if y == 0:\n                    new.append(0)\n                else:\n                    new.append(int(test[x][y-1]))\n        if test[x] == new:\n            print('impossible')\n        else:\n            print(''.join(map(str, new)))\n    return"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    input = [int(i) for i in stdin.split()]\n    if len(input) == n:\n        return \"impossible\"\n    input.sort()\n    for i in range(n):\n        if input[i]!= input[i - 1] + 1:\n            if input[i]!= input[i - 1] + 2:\n                return \"impossible\"\n    return \" \".join(str(i) for i in input)\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split('\\n')\n    length = int(instructions[0])\n    numbers = instructions[1].split()\n    numbers = list(map(int, numbers))\n    #print(length)\n    #print(numbers)\n    for i in range(len(numbers)):\n        #print(i)\n        if numbers[i] < 0:\n            continue\n        elif numbers[i] > 10**15:\n            return \"impossible\"\n        elif numbers[i] == numbers[i+1]:\n            return \"impossible\"\n        elif numbers[i] == numbers[i+2]:\n            return \"impossible\"\n        elif numbers[i] == numbers[i+3]:\n            return \"impossible\"\n    return''.join(map(str, numbers))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n = int(inputs[0])\n    inputs = inputs[1].split(' ')\n    result = []\n    for i in range(n):\n        result.append(int(inputs[i]))\n    if result!= sorted(result):\n        return \"impossible\"\n    inputs = inputs[n:]\n    for i in range(len(inputs)):\n        inputs[i] = int(inputs[i])\n    for i in range(len(inputs)):\n        if inputs[i] % 10!= 0:\n            return \"impossible\"\n        else:\n            inputs[i] = inputs[i]//10\n    result = []\n    for i in range(n):\n        result.append(inputs[i])\n    result = sorted(result)\n    for i in range(n):\n        result[i] = result[i] * 10\n    return result\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, a = stdin\n    x = sorted([int(i) for i in a.split()])\n    for i in range(len(x)):\n        for j in range(len(x)):\n            if x[i]!= x[j] and x[i] < x[j]:\n                x[i], x[j] = x[j], x[i]\n                break\n        else:\n            return \"impossible\"\n    return''.join([str(i) for i in x])"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.strip().split()))\n    while True:\n        if a == sorted(a):\n            break\n        i = a.index(max(a))\n        a[i] = a[i] + 1\n        if a[i] == 10:\n            a[i] = 0\n            a[i - 1] += 1\n        if a == sorted(a):\n            break\n    return''.join(map(str, a))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *answers = stdin.split()\n    answers = list(map(int, answers))\n    answers.sort()\n    return \"impossible\" if answers == sorted(answers) else \" \".join(map(str, answers))"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    numbers = stdin.split()\n    if n == 1:\n        return 'impossible'\n    elif n == 2:\n        if int(numbers[0]) > int(numbers[1]):\n            return numbers[1] + numbers[0]\n        elif int(numbers[0]) == int(numbers[1]):\n            return 'impossible'\n        else:\n            return numbers[0] + numbers[1]\n    else:\n        numbers = stdin.split()\n        for i in range(len(numbers)):\n            numbers[i] = int(numbers[i])\n        numbers = sorted(numbers)\n        for i in range(1, n - 1):\n            for j in range(i + 1, n):\n                if numbers[i] % 10 == numbers[j] % 10:\n                    return 'impossible'\n                if numbers[i] % 10 < numbers[j] % 10:\n                    numbers[i], numbers[j] = numbers[j], numbers[i]\n        return''.join(map(str, numbers))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    l = list(map(int, stdin.split()))\n    if sorted(l) == l:\n        return \"impossible\"\n    return \" \".join(map(str, sorted(l, reverse=True)))\n"
    },
    {
        "number": 3101,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    input_list = list(map(int, stdin.split()))\n    input_list = input_list[:n]\n    input_list.sort()\n    for i in range(len(input_list)):\n        if input_list[i]!= input_list[i-1]:\n            return \"impossible\"\n    return \" \".join(str(num) for num in input_list)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    houses = list(range(L, R + 1))\n    num_houses = 0\n    for house in houses:\n        if not contains_numbers(str(house), 4) or digit_counts(str(house), 6) == digit_counts(str(house), 8):\n            num_houses += 1\n    return str(num_houses)\n\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    count = 0\n    for num in range(l, r + 1):\n        if num == 1 or num == 7:\n            count += 1\n            continue\n        digits = [int(x) for x in list(str(num))]\n        if digits[0]!= 4:\n            count += 1\n        if digits[1]!= 8:\n            count += 1\n        if digits[2]!= 6:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    if R - L == 1:\n        return \"1\"\n    if R - L == 2:\n        if R % 6 == L % 6 == 1:\n            return \"1\"\n        else:\n            return \"0\"\n    cnt = 0\n    for i in range(L, R + 1):\n        if i % 6 == 1:\n            if (i + 1) % 6 == 1:\n                if (i + 2) % 6 == 1:\n                    cnt += 1\n        elif i % 6 == 2:\n            if (i + 1) % 6 == 2:\n                if (i + 2) % 6 == 2:\n                    cnt += 1\n        elif i % 6 == 3:\n            if (i + 1) % 6 == 3:\n                if (i + 2) % 6 == 3:\n                    cnt += 1\n        elif i % 6 == 4:\n            if (i + 1) % 6 == 4:\n                if (i + 2) % 6 == 4:\n                    cnt += 1\n    return str(cnt % 1000000007)\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    return str(L+R-2)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, R = list(map(int, stdin.strip().split()))\n    ans = 0\n    while (L + 1) < R:\n        # count the number of 6s and 8s\n        n6 = 0\n        n8 = 0\n        n = L\n        while (n := L) < R:\n            if ('6' in str(n) or '8' in str(n)) and str(n)!= str(n):\n                if n6 == 0 and n8 == 0:\n                    n6 += 1\n                    n8 = n\n                else:\n                    n8 = n\n                    break\n            else:\n                break\n        # the number of digits in n6 + n8 = n = L + 1\n        # the number of digits in n6 = n - L - 1\n        # the number of digits in n8 = R - n - 1\n        # the number of digits in L = L - n = L - 1 - n - 1\n        # the number of digits in R = R - n - 1 - n\n        # the number of digits in ans = (L - 1) + (R - 1 - n) = (L - 1) + (R - 1) - (n + 1)\n        # the number of digits in ans = (L - 1) - (R - 1 - n) = (L - 1) - (R - 1 - n)\n        ans = (L - 1) - (R - 1 - n)\n        if ans > 10 ** 9 + 7:\n            return \"impossible\"\n        ans += 1\n    return str(ans)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    # TODO: Write your code here\n    houses = []\n    for i in range(int(stdin[0]), int(stdin[1]) + 1):\n        count = 0\n        digits = list(map(str, list(str(i))))\n        if digits[0]!= '4':\n            count += 1\n        for digit in digits:\n            if digit == '6' or digit == '8':\n                count += 1\n        if count == len(digits):\n            houses.append(i)\n    return str(len(houses))"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.hackerrank.com/challenges/divisible-sum-pairs/problem?h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=warmup\"\"\"\n    stdin = stdin.split()\n    stdin = sorted(stdin, reverse=True)\n    lo = int(stdin[0])\n    hi = int(stdin[1])\n    num = lo + 1\n    count = 0\n    while lo <= hi:\n        if lo + num < hi + num:\n            count += 1\n            if lo + num == hi + num:\n                count -= 1\n        else:\n            num += 1\n        lo += 1\n    print(count % 1000000007)\n    return count % 1000000007\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, R = stdin.split()\n    L, R = int(L), int(R)\n    ans = 0\n    if L == R:\n        return str(L)\n    else:\n        for house in range(L, R + 1):\n            house_str = str(house)\n            if not any([c in house_str for c in '468']):\n                if not any([c in house_str for c in '6 8']):\n                    ans += 1\n    return str(ans)"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    houses = set(range(L, R + 1))\n    houses = list(houses)\n    houses = sorted(houses)\n\n    presents = 0\n    for i, num in enumerate(houses):\n        if not any(num.startswith(n) for n in ('4', '6', '8')):\n            if houses[i] - houses[i - 1] == houses[i - 1] - houses[i - 2]:\n                presents += 1\n    return f'{presents % (10**9 + 7)}'\n"
    },
    {
        "number": 3102,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, R = stdin.split()\n    return str(R % (10**9+7))\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    if X <= 0 or Y <= 0:\n        return \"begin repairs\"\n    f = [[0] * X for _ in range(Y)]\n    f[0][x_init] = 1\n    dx, dy = [0, 1, 0, -1], [1, 0, -1, 0]\n\n    for y in range(Y):\n        for x in range(X):\n            if f[y][x]!= 0:\n                for k in range(4):\n                    nx, ny = x + dx[k], y + dy[k]\n                    if 0 <= nx < X and 0 <= ny < Y:\n                        if f[ny][nx] == 0:\n                            f[ny][nx] = f[y][x] + 1\n\n    possible_solutions = []\n    for x in range(X):\n        for y in range(Y):\n            if f[y][x] == 0:\n                possible_solutions.append(f[y][x])\n    print(len(possible_solutions))\n    if len(possible_solutions) == 0:\n        return \"begin repairs\"\n    return reduce(lambda x, y: x + y, possible_solutions) % 1000003\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    (Y, X, x_init) = map(int, stdin.split())\n    if X < Y:\n        return \"begin repairs\"\n    X = X + 1\n    X = Y - X\n    if (x_init + 1) >= X or (x_init - 1) <= 0:\n        return \"begin repairs\"\n    x_init = x_init + 1 if x_init + 1 < X else x_init - 1\n    boat_map = {}\n    for y in range(Y):\n        row = stdin.replace('\\n', '')\n        for x in range(X):\n            if row[x] == '>':\n                boat_map[x] = 1\n            elif row[x] == '<':\n                boat_map[x] = -1\n            elif row[x] == '@':\n                boat_map[x] = 0\n            elif row[x] == '#':\n                boat_map[x] = 0\n            elif row[x] == '~':\n                boat_map[x] = 0\n    x_init_boat_map = {x_init}\n    solutions = []\n    if len(boat_map.keys()) == 0:\n        return \"begin repairs\"\n    else:\n        for x in range(x_init, X):\n            x_init_boat_map.add(x)\n            solutions.append(x_init_boat_map)\n            if not check_solution(x_init_boat_map, boat_map):\n                x_init_boat_map.remove(x)\n            else:\n                x_init_boat_map.remove(x)\n        for y in range(Y):\n            if y not in solutions:\n                return \"begin repairs\"\n    return solutions\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, x, y, _, _ = stdin.split()\n    x, y = int(x), int(y)\n    return (\n        'begin repairs'\n        if x == 0 or y == 0 or x == x or y == y\n        else len(set([\n            (i, j)\n            for i in range(0, x)\n            for j in range(0, y)\n            if stdin[i][j] in ('~', '#', '>', '<')\n        ])) % 1000003)\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.strip().split()\n    Y = int(board[0])\n    X = int(board[1])\n    x_init = int(board[2])\n\n    if x_init < 0:\n        return 'begin repairs'\n    elif x_init > X:\n        return 'begin repairs'\n\n    current_position = [x_init, 0]\n    boat_position = [x_init, 0]\n    #solution_board = [[' '] * X for _ in range(Y)]\n\n    board[0] = '>'\n    board[1] = '<'\n    current_symbol = '>'\n    boat_symbol = '<'\n    boat_position[1] = X - 1\n    count = 0\n    first_direction = True\n    count_solution = 0\n\n    while True:\n        # print(f'current position {current_position}')\n        if current_symbol == '>':\n            boat_position[0] += 1\n            current_position[1] += 1\n            # boat_position = (boat_position[0], boat_position[1] + 1)\n        elif current_symbol == '<':\n            boat_position[0] -= 1\n            current_position[1] += 1\n            # boat_position = (boat_position[0], boat_position[1] + 1)\n        else:\n            boat_position[0] += 1\n            current_position[1] -= 1\n            # boat_position = (boat_position[0], boat_position[1] - 1)\n        # print(f'boat position {boat_position}')\n        # print(f'current position {current_position}')\n        # print(f'boat position {boat_position}')\n        # solution_board[current_position[0]][current_position[1]] = current_symbol\n        if not (0 <= current_position[0] < Y) or not (0 <= current_position[1] < X):\n            # print('break')\n            break\n        # print(f'current position {current_position}')\n        # print(f'boat position {boat_position}')\n        # print(f'current position {current_position}')\n        if board[current_position[0]][current_position[1]] == '>' or board[current_position[0]][current_position[1]] == '<':\n            # print('skip')\n            count += 1\n            # print(f'count {count}')\n            # print(f'count_solution {count_solution}')\n            if count == count_solution:\n                # print('hit')\n                # print(f'count {count}')\n                # print(f'count_solution {count_solution}')\n                count_solution += 1\n                if count_solution == 1000003:\n                    count_solution = 0\n                continue\n            # print('continue')\n            continue\n        elif board[current_position[0]][current_position[1]] == '@':\n            # print('break')\n            break\n        # elif current_position == boat_position:\n        #     print('break')\n        #     break\n        # solution_board[current_position[0]][current_position[1]] = current_symbol\n        if board[current_position[0]][current_position[1]] == '#':\n            # print('break')\n            break\n        elif first_direction:\n            current_symbol = board[current_position[0]][current_position[1]]\n            first_direction = False\n        elif current_symbol == '>' and board[current_position[0]][current_position[1]] == '<' and first_direction:\n            # print('break')\n            break\n        elif current_symbol == '<' and board[current_position[0]][current_position[1]] == '>' and first_direction:\n            # print('break')\n            break\n        else:\n            # print('skip')\n            count += 1\n            # print(f'count {count}')\n            # print(f'count_solution {count_solution}')\n            if count == count_solution:\n                # print('hit')\n                # print(f'count {count}')\n                # print(f'count_solution {count_solution}')\n                count_solution += 1\n                if count_solution == 1000003:\n                    count_solution = 0\n                continue\n            # print('continue')\n            continue\n\n    solution = str()\n    solution += str(count)\n    return solution\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x = map(int, stdin.split())\n    stdin = stdin.strip().splitlines()\n    ship = [(i, x) for i, x in enumerate(stdin[0]) if x in '~#@']\n    if len(ship)!= 1:\n        raise Exception('Ship is not valid')\n\n    top = Y - 1\n    left = X - 1\n    right = X - 1\n    bottom = 0\n\n    for y in range(Y):\n        for x in range(X):\n            if stdin[y][x] == '@':\n                top = y\n                left = x\n            elif stdin[y][x] in '<>^':\n                right = x\n            elif stdin[y][x] in '~#':\n                bottom = y\n    if bottom > top or right > left:\n        return 'begin repairs'\n\n    def possible(x, y):\n        if y == 0:\n            return False\n\n        if stdin[y - 1][x] == '~' or stdin[y - 1][x] == '#':\n            return False\n\n        if y == bottom:\n            return False\n\n        return True\n\n    def possible_right(x, y):\n        if x == 0:\n            return False\n\n        if stdin[y][x - 1] == '~' or stdin[y][x - 1] == '#':\n            return False\n\n        if x == left:\n            return False\n\n        return True\n\n    def possible_left(x, y):\n        if x == X - 1:\n            return False\n\n        if stdin[y][x + 1] == '~' or stdin[y][x + 1] == '#':\n            return False\n\n        if x == right:\n            return False\n\n        return True\n\n    def possible_top(x, y):\n        if y == top:\n            return False\n\n        if stdin[y][x] == '~' or stdin[y][x] == '#':\n            return False\n\n        return True\n\n    def possible_bottom(x, y):\n        if y == bottom:\n            return False\n\n        if stdin[y][x] == '~' or stdin[y][x] == '#':\n            return False\n\n        return True\n\n    def possible_any(x, y):\n        if possible_top(x, y):\n            return True\n        if possible_bottom(x, y):\n            return True\n        if possible_left(x, y):\n            return True\n        if possible_right(x, y):\n            return True\n\n        return False\n\n    def go_right(x, y):\n        if stdin[y][x + 1] == '#':\n            return False\n\n        return True\n\n    def go_left(x, y):\n        if stdin[y][x - 1] == '#':\n            return False\n\n        return True\n\n    def go_top(x, y):\n        if stdin[y - 1][x] == '#':\n            return False\n\n        return True\n\n    def go_bottom(x, y):\n        if stdin[y + 1][x] == '#':\n            return False\n\n        return True\n\n    def possible_dir(x, y, d):\n        if d == '<':\n            if not possible_left(x, y):\n                return False\n        elif d == '>':\n            if not go_right(x, y):\n                return False\n        elif d == '^':\n            if not go_top(x, y):\n                return False\n        elif d == 'v':\n            if not go_bottom(x, y):\n                return False\n        else:\n            raise Exception('Invalid direction')\n\n        if y == 0 or y == top:\n            return False\n\n        if not possible_top(x, y):\n            return False\n\n        return True\n\n    def all_possible(x, y):\n        if possible_any(x, y):\n            return True\n\n        if possible_dir(x, y, '<'):\n            return True\n        if possible_dir(x, y, '>'):\n            return True\n        if possible_dir(x, y, '^'):\n            return True\n        if possible_dir(x, y, 'v'):\n            return True\n\n        return False\n\n    if all_possible(left, top):\n        return str(1)\n\n    ans = 0\n    stack = [(left, top)]\n    while stack:\n        x, y = stack.pop()\n        if all_possible(x, y):\n            ans += 1\n            continue\n        for dx, dy in (1, 0), (-1, 0), (0, 1), (0, -1):\n            if all_possible(x + dx, y + dy):\n                stack.append((x + dx, y + dy))\n\n    return str(ans)"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    boat_y, boat_x, curr_y, curr_x, dirs, rows = list(map(int, stdin.split()))\n    boat_y -= 1\n    boat_x -= 1\n    curr_y -= 1\n    curr_x -= 1\n    dirs = dirs % 4\n    if dirs == 0:\n        dirs = 2\n    if dirs == 1:\n        dirs = 0\n    if dirs == 2:\n        dirs = 3\n    if dirs == 3:\n        dirs = 1\n    if dirs == 0:\n        for _ in range(1, rows):\n            if curr_y == 0:\n                return 'begin repairs'\n            curr_y -= 1\n            curr_x += 1\n        curr_y += 1\n        curr_x -= 1\n        return curr_y\n    if dirs == 1:\n        curr_y += 1\n        curr_x += 1\n        for _ in range(1, rows):\n            if curr_y == rows-1:\n                return 'begin repairs'\n            curr_y += 1\n            curr_x -= 1\n        curr_y -= 1\n        curr_x -= 1\n        return curr_y\n    if dirs == 2:\n        curr_y -= 1\n        curr_x += 1\n        for _ in range(1, rows):\n            if curr_y == 0:\n                return 'begin repairs'\n            curr_y -= 1\n            curr_x += 1\n        curr_y += 1\n        curr_x -= 1\n        return curr_y\n    if dirs == 3:\n        curr_y += 1\n        curr_x -= 1\n        for _ in range(1, rows):\n            if curr_y == rows-1:\n                return 'begin repairs'\n            curr_y += 1\n            curr_x += 1\n        curr_y -= 1\n        curr_x += 1\n        return curr_y\n    else:\n        return 'begin repairs'"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    y, x, x_init = map(int, stdin.split())\n\n    if x < x_init:\n        x = x_init\n    if x > 50000:\n        x = 50000\n    if y > 300:\n        y = 300\n    if y < 0:\n        y = 0\n\n    return \"{}\".format(find_paths(y, x, x_init))\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.strip().split())\n\n    directions = ['>', '<', '^', 'v']\n\n    # init x and y to ship\n    x = x_init\n    y = 0\n\n    boat_direction = '^'  # North\n\n    # iterate through each row in stdin\n    for row in stdin.strip().splitlines():\n\n        # if a #, get the index and continue\n        if row[0] == '#':\n            index = int(row[1:])\n            continue\n\n        # if it's a space, get the next x and y\n        else:\n            next_x = index\n            next_y = int(row[1:])\n\n            # if the next index is a #, get the index and continue\n            if next_x == '#':\n                index = int(next_y)\n                continue\n\n            # if the next index is <, >, or ^, move the boat\n            if next_x[0] == '<' or next_x[0] == '>' or next_x[0] == '^':\n                boat_direction = next_x[0]\n\n        # if the next index is in the boat direction, move the boat\n        if boat_direction == '^':\n            x += 1\n        elif boat_direction == '>':\n            y += 1\n        elif boat_direction == '<':\n            x -= 1\n        elif boat_direction == 'v':\n            y -= 1\n\n        # if the next index is >, <, or ^, return the index\n        if next_y[0] == '>' or next_y[0] == '<' or next_y[0] == '^':\n            return index\n\n    return 'begin repairs'\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, start_col = map(int, stdin.split())\n    sea = [['~' for _ in range(cols)] for _ in range(rows)]\n    sea[0][start_col] = '>'\n    for row in range(1, rows):\n        sea[row][0] = '<'\n    for col in range(1, cols):\n        sea[0][col] = '#'\n    for row in range(1, rows):\n        for col in range(1, cols):\n            sea[row][col] = sea[row-1][col] + sea[row][col-1]\n    return sea[rows-1][cols-1] % 1000003\n"
    },
    {
        "number": 3103,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = list(map(int, stdin.split()))\n\n    if x_init > X or x_init < 0:\n        return \"begin repairs\"\n\n    grid = []\n    for _ in range(Y):\n        grid.append(stdin.split())\n\n    count = 0\n\n    def east(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if x + 1 < X:\n            if grid[y][x + 1] == \"~\":\n                grid[y][x] = \">\"\n                return grid\n            elif grid[y][x + 1] == \"<\":\n                return grid\n            else:\n                count += 1\n                grid[y][x + 1] = \">\"\n                return east(grid, x + 1, y)\n\n        else:\n            return grid\n\n    def west(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if x - 1 >= 0:\n            if grid[y][x - 1] == \"~\":\n                grid[y][x] = \"<\"\n                return grid\n            elif grid[y][x - 1] == \">\":\n                return grid\n            else:\n                count += 1\n                grid[y][x - 1] = \"<\"\n                return west(grid, x - 1, y)\n\n        else:\n            return grid\n\n    def south(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y + 1 < Y:\n            if grid[y + 1][x] == \"~\":\n                grid[y][x] = \"^\"\n                return grid\n            elif grid[y + 1][x] == \"^\":\n                return grid\n            else:\n                count += 1\n                grid[y + 1][x] = \"^\"\n                return south(grid, x, y + 1)\n\n        else:\n            return grid\n\n    def north(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y - 1 >= 0:\n            if grid[y - 1][x] == \"~\":\n                grid[y][x] = \"v\"\n                return grid\n            elif grid[y - 1][x] == \"v\":\n                return grid\n            else:\n                count += 1\n                grid[y - 1][x] = \"v\"\n                return north(grid, x, y - 1)\n\n        else:\n            return grid\n\n    def northwest(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y - 1 >= 0 and x - 1 >= 0:\n            if grid[y - 1][x - 1] == \"~\":\n                grid[y][x] = \">\"\n                return grid\n            elif grid[y - 1][x - 1] == \"<\":\n                return grid\n            else:\n                count += 1\n                grid[y - 1][x - 1] = \">\"\n                return northwest(grid, x - 1, y - 1)\n\n        else:\n            return grid\n\n    def northeast(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y - 1 >= 0 and x + 1 < X:\n            if grid[y - 1][x + 1] == \"~\":\n                grid[y][x] = \"<\"\n                return grid\n            elif grid[y - 1][x + 1] == \">\":\n                return grid\n            else:\n                count += 1\n                grid[y - 1][x + 1] = \"<\"\n                return northeast(grid, x + 1, y - 1)\n\n        else:\n            return grid\n\n    def southwest(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y + 1 < Y and x - 1 >= 0:\n            if grid[y + 1][x - 1] == \"~\":\n                grid[y][x] = \"^\"\n                return grid\n            elif grid[y + 1][x - 1] == \"^\":\n                return grid\n            else:\n                count += 1\n                grid[y + 1][x - 1] = \"^\"\n                return southwest(grid, x - 1, y + 1)\n\n        else:\n            return grid\n\n    def southeast(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y + 1 < Y and x + 1 < X:\n            if grid[y + 1][x + 1] == \"~\":\n                grid[y][x] = \"v\"\n                return grid\n            elif grid[y + 1][x + 1] == \"v\":\n                return grid\n            else:\n                count += 1\n                grid[y + 1][x + 1] = \"v\"\n                return southeast(grid, x + 1, y + 1)\n\n        else:\n            return grid\n\n    def empty(grid, x, y):\n        if grid[y][x] == \"~\":\n            return grid\n\n        if y + 1 < Y and grid[y + 1][x] == \"~\":\n            grid[y][x] = \">\"\n            return grid\n        if x + 1 < X and grid[y][x + 1] == \"~\":\n            grid[y][x] = \"^\"\n            return grid\n        if y -"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split(\"=\")\n    A = list(map(int, A.strip()))\n    S = list(map(int, S.strip()))\n    A, S = sorted(A), sorted(S)\n    for i, n1 in enumerate(S):\n        for j, n2 in enumerate(A):\n            if n1 == n2:\n                A.remove(n1)\n                S.remove(n1)\n                A.append(0)\n                S.append(0)\n                S[i] += 1\n                break\n    A = \"\".join(map(str, A))\n    S = \"\".join(map(str, S))\n    print(A + \"=\" + S)\n    return A + \"=\" + S\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split(\"=\")\n    A = A.lstrip(\"0\")\n    S = S.lstrip(\"0\")\n\n    # Part 1\n    if A == S:\n        return stdin\n    else:\n        # Part 2\n        count = 0\n        i = 0\n        while i < len(A):\n            if A[i] == '0':\n                i += 1\n                continue\n\n            if A[i]!= S[i]:\n                count += 1\n                A = A[:i] + str(int(A[i]) + int(S[i])) + A[i+1:]\n            else:\n                i += 1\n        return A if count == 0 else stdin\n    return \"No Solution\"\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split('=')\n    equation = instructions[1].split()\n    \n    def add_operation(x,y):\n        return str(x)+str(y)\n    \n    def count_zero(x):\n        count = 0\n        for y in x:\n            if y == '0':\n                count += 1\n        return count\n    \n    def check(equation):\n        for i in range(len(equation)):\n            x = equation[i]\n            if x == '+':\n                if i!= len(equation) - 1:\n                    x_next = equation[i+1]\n                    if x_next == '+':\n                        if i == 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n            elif x == '-':\n                if i!= 0:\n                    x_next = equation[i-1]\n                    if x_next == '-':\n                        if i == 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n        return True\n    \n    def check_add(equation):\n        for i in range(len(equation)):\n            x = equation[i]\n            if x == '+':\n                if i!= len(equation) - 1:\n                    x_next = equation[i+1]\n                    if x_next == '+':\n                        if i!= 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n            elif x == '-':\n                if i!= 0:\n                    x_next = equation[i-1]\n                    if x_next == '-':\n                        if i!= 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n        return True\n    \n    def count_numbers(equation):\n        for i in range(len(equation)):\n            x = equation[i]\n            if x == '+':\n                if i!= len(equation) - 1:\n                    x_next = equation[i+1]\n                    if x_next == '+':\n                        if i!= 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n            elif x == '-':\n                if i!= 0:\n                    x_next = equation[i-1]\n                    if x_next == '-':\n                        if i!= 0 or count_zero(equation[:i]) > 0:\n                            return True\n                        else:\n                            return False\n                    else:\n                        return False\n                else:\n                    return False\n        return True\n    \n    def do_addition(equation):\n        if count_zero(equation) == 2:\n            equation = equation[:2]+'0'+equation[2:]\n        if count_zero(equation) == 3:\n            equation = equation[:3]+'0'+equation[3:]\n        if count_zero(equation) == 4:\n            equation = equation[:4]+'0'+equation[4:]\n        if count_zero(equation) == 5:\n            equation = equation[:5]+'0'+equation[5:]\n        return equation\n    \n    if check(equation):\n        equation = do_addition(equation)\n        print(equation)\n        return equation\n    else:\n        equation = equation[0:equation.index('+')]+'+0'+equation[equation.index('+')+1:]\n        print(equation)\n        equation = do_addition(equation)\n        print(equation)\n        return equation\n    "
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A,S=stdin.split(\"=\")\n    A=list(A)\n    S=int(S)\n    A.sort(reverse=True)\n    for a in A:\n        S=S-a\n        if S>0:\n            A.insert(0,S)\n            A.sort()\n            return \"\".join(str(a) for a in A)\n    A.insert(0,S)\n    A.sort()\n    return \"\".join(str(a) for a in A)\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your solution goes here!\n    \"\"\"\n    stdin = stdin.split('=')\n    A, S = stdin[0], stdin[1]\n    A = A.strip().split('+')\n    ans = ''\n    for i in A:\n        ans += (i+'+')\n    ans = ans[:-1]\n    ans = ans + '=' + S\n    return ans\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin\n    A = str(A)\n    S = str(S)\n    t = A + S\n    t = t.replace('0', '')\n    t = t.replace('1', '')\n    t = t.replace('2', '')\n    t = t.replace('3', '')\n    t = t.replace('4', '')\n    t = t.replace('5', '')\n    t = t.replace('6', '')\n    t = t.replace('7', '')\n    t = t.replace('8', '')\n    t = t.replace('9', '')\n    t = t.replace('0', '')\n    t = t.replace('.', '')\n    return t"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = stdin.split()\n    num1 = int(num1)\n    num2 = int(num2)\n\n    min_num = min(num1, num2)\n    max_num = max(num1, num2)\n    print(min_num)\n    print(max_num)\n    if min_num == max_num:\n        print(min_num)\n    else:\n        additions = 0\n        while min_num < max_num:\n            if min_num % 2 == 0:\n                min_num = min_num / 2\n                additions += 1\n            elif min_num % 2 == 1:\n                min_num = (min_num - 1) / 2\n                additions += 1\n        return str(additions)\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split(\"=\")\n    # This is a pythonic way to separate the two sides of the equation\n    a, s = inp[0].split(\"=\")\n    # Split a by = and s by = to separate the two sides of the equation\n    # Eliminate the leading zeros\n    a = int(a.lstrip(\"0\"))\n    s = int(s.lstrip(\"0\"))\n    # The leading zeros from a and s are eliminated\n    # Remove any leading 0 from a and s, then convert them to int\n    if a > s:\n        # If a is greater than s, make s = a\n        # By doing this, the result will be increasing, so we can start with s\n        s = a\n    while s > 0:\n        # Loop through until we reach zero\n        s -= a\n        # Subtract a from s\n        a += 1\n        # Add 1 to a\n    # When a == s, we have found the correct equation\n    return str(a) + \"=\" + str(s)\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A = int(stdin.split('=')[0])\n    S = int(stdin.split('=')[1])\n    if A == S:\n        return stdin\n    else:\n        left = str(S)\n        right = str(A)\n        ans = \"\"\n        if A > S:\n            for i in range(len(left)):\n                if i < len(right):\n                    ans += str(int(left[i]) + int(right[i]))\n                    right = right[1:]\n                else:\n                    ans += str(int(left[i]) + int(right))\n                    right = right[1:]\n        else:\n            for i in range(len(right)):\n                if i < len(left):\n                    ans += str(int(left[i]) + int(right[i]))\n                    left = left[1:]\n                else:\n                    ans += str(int(left) + int(right[i]))\n                    left = left[1:]\n        return ans\nprint(solution(input()))\n"
    },
    {
        "number": 3104,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A,S = stdin.split('=')\n    A = A.split('+')\n    S = S.split('+')\n    for i in range(len(A)):\n        A[i] = int(A[i])\n    for i in range(len(S)):\n        S[i] = int(S[i])\n    min_add = 0\n    for i in range(len(A)):\n        if A[i] - S[i] < 0:\n            min_add += abs(A[i]-S[i])\n    return '{}+{}='.format(A[0],min_add) + ''.join(str(a) for a in A[1:])\nsolution('143175=120')"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = sorted([int(i) for i in stdin.strip().split()])\n    d = dict()\n    res = []\n    for i, num in enumerate(S):\n        if num in d:\n            res.append(d[num])\n            d[num] = i + 1\n        else:\n            d[num] = i + 1\n    min_idx = min(res)\n    max_idx = max(res)\n    for i in range(min_idx, max_idx + 1):\n        if i not in d:\n            return f'{-1}'\n    return f'{res[0]} {res[1]}'\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin.split()[0])\n    N = S\n    while True:\n        if len(set([n for n in range(N+1)])) == N:\n            return '%d %d' % (N-1, N-2)\n        else:\n            N += 1"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    while True:\n        s = list(map(int, stdin.split()))\n        if len(s) == 1:\n            break\n        elif len(s) == 2:\n            if s[0] == s[1]:\n                print(-1)\n            else:\n                print(s[0], s[1])\n        elif len(s) > 2:\n            A = -1\n            B = -1\n            i = 0\n            while i < N:\n                if s[i] == s[i+1]:\n                    if s[i] < A:\n                        A = s[i]\n                    if s[i] < s[i+2]:\n                        B = s[i+2]\n                i += 1\n            if A!= -1 and B!= -1:\n                print(A, B)\n            elif A!= -1:\n                print(A)\n            else:\n                print(-1)\n        stdin = input()\n    return \"\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = -1, -1\n    for s in stdin.splitlines():\n        if a == -1 and b == -1 and len(set(s)) == len(s):\n            a, b = list(set(s))\n            b = min(b, s.index(a))\n            a = min(a, s.index(b))\n        elif s.count(a)!= s.count(b) or s.index(a)!= s.index(b):\n            return str(min(a, b)) + \" \" + str(max(a, b))\n    return str(a) + \" \" + str(b)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N == 1:\n        return \"-1\"\n    res = \"1 1\"\n    for i in range(2, N+1):\n        S = list(map(int, stdin.split()))\n        idx = 0\n        while idx < len(S) and S[idx] == 1:\n            idx += 1\n        curr = idx\n        while idx < len(S) and S[idx] == 2:\n            idx += 1\n        if idx == len(S):\n            break\n        res = min(res, str(S[idx-1]) + str(S[idx]) + str(S[idx-1]) + str(S[idx]))\n    return res\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = int(stdin)\n    b = int(stdin)\n    a_ind = b_ind = -1\n    for i in range(N):\n        if a == stdin[i]:\n            a_ind = i\n        if b == stdin[i]:\n            b_ind = i\n    if a_ind!= b_ind and a_ind!= -1 and b_ind!= -1:\n        if a_ind < b_ind:\n            a, b = b, a\n            a_ind, b_ind = b_ind, a_ind\n        for i in range(N):\n            if a == stdin[i]:\n                a_ind = i\n            if b == stdin[i]:\n                b_ind = i\n            if a_ind!= b_ind and a_ind!= -1 and b_ind!= -1:\n                if a_ind < b_ind:\n                    a, b = b, a\n                    a_ind, b_ind = b_ind, a_ind\n                if a_ind < b_ind:\n                    break\n    return \" \".join(map(str, [a, b]))\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lengths = sorted(map(int, stdin.strip().split()))\n    s = sum(lengths)\n    if s % 2!= 0:\n        return -1\n    t = s // 2\n    l = 0\n    r = n - 1\n    while l < r:\n        # print(l, r)\n        mid = (l + r) // 2\n        # print(mid)\n        if mid < t:\n            l = mid + 1\n        elif mid > t:\n            r = mid - 1\n        else:\n            break\n    # print(l, r)\n    if l < r:\n        res = l, r\n        # print(res)\n        return''.join(map(str, sorted(res)))\n    else:\n        return '-1'\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N = int(stdin[0])\n    sequence = list(map(int, stdin[1:]))\n    for i in range(N):\n        if sequence[i] == sequence[i + 1] and sequence[i]!= sequence[i + 2] and sequence[i]!= sequence[i + 3]:\n            print(sequence[i], sequence[i + 1])\n        elif sequence[i] == sequence[i + 2] and sequence[i]!= sequence[i + 3]:\n            print(sequence[i], sequence[i + 2])\n        elif sequence[i] == sequence[i + 3] and sequence[i]!= sequence[i + 2]:\n            print(sequence[i], sequence[i + 3])\n        elif sequence[i]!= sequence[i + 1] and sequence[i]!= sequence[i + 2] and sequence[i]!= sequence[i + 3]:\n            print(-1)\n\n    return''.join([str(x) for x in sequence])\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    count = {}\n    for i in range(n):\n        if s[i] in count:\n            count[s[i]] += 1\n        else:\n            count[s[i]] = 1\n    for k, v in count.items():\n        if v == 1:\n            return str(k) + \" \" + str(k + 1)\n    return \"-\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    for _ in range(N):\n        s = stdin.strip()\n        while not all(s.startswith(str(i)) for i in range(1, N + 1)):\n            s = ''.join(sorted(s))\n            if s.startswith(str(i) + str(i - 1) + str(i) for i in range(1, N + 1)):\n                break\n        else:\n            return '-1'\n        print(s, end=' ')\n    return ''"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0, 16: 0}\n    for i in stdin.split():\n        lights[i] += 1\n    for key in lights:\n        if lights[key] == 2:\n            lights[key] = 1\n    for i in range(len(lights)):\n        if lights[i] == 0:\n            return str(i)\n    return '0'\nsolution('111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lights = list(map(int, stdin.split('\\n')))\n    L = len(lights)\n    step = 0\n    for i in range(L):\n        # if light is off, change it on\n        if lights[i] == 0:\n            lights[i] = 1\n            step += 1\n            # only change the next iteration if the light is off\n            if i < L-1:\n                continue\n            # else we're done\n            # only change the next iteration if the light is off\n            if lights[i+1] == 0:\n                lights[i+1] = 1\n                step += 1\n    return str(step)\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('1101')\n    1\n    >>> solution('1011')\n    0\n    '''\n    buttons = stdin.replace('1', '1').replace('0', '0').replace('1', '1').replace('1', '1').replace('1', '1')\n\n    last_toggle = 0\n    toggle_max = 0\n    for i, b in enumerate(buttons):\n        if b == '1':\n            toggle_max = max(toggle_max, i - last_toggle)\n        last_toggle = i\n    \n    return max(0, toggle_max)"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    curr = 0\n    next = 0\n    lights = {}\n    for i in stdin:\n        if i == '1':\n            if next not in lights:\n                lights[next] = True\n                curr += 1\n            next += 1\n        else:\n            if next in lights:\n                lights[next] = False\n                curr += 1\n            next += 1\n    print(curr)\n    return\nsolution(stdin)\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n_lights = int(stdin)\n    light_on = True\n    light_states = {1: light_on}\n    time = 0\n    while light_on and time < n_lights:\n        if light_on:\n            time += 1\n            light_on = not light_on\n        else:\n            light_on = True\n            time += 1\n        light_states[time] = light_on\n    on_lights = light_states.keys()\n    print(' '.join(map(str, on_lights)))\n    return stdin\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    light_map = {\n        \"1\": True,\n        \"0\": False\n    }\n    buttons = []\n    current_lights = []\n    prev_state = \"\"\n    current_time = 0\n    for char in stdin:\n        if char == \"1\":\n            current_lights.append(True)\n        else:\n            current_lights.append(False)\n        buttons.append(char)\n        if len(current_lights) == len(light_map):\n            current_state = current_lights.copy()\n            while buttons:\n                button = buttons.pop()\n                if button == \"0\":\n                    current_state.remove(light_map[button])\n                else:\n                    current_state.append(light_map[button])\n            current_state = tuple(current_state)\n            if current_state!= prev_state:\n                prev_state = current_state\n                current_time += 1\n    return str(current_time)\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    return:\n    int: the earliest time at which all of the lights are on.\n    \"\"\"\n    s = stdin\n    print(s)\n    led = s.count(\"1\")\n    print(led)\n    return led\ns = solution(stdin)\nprint(s)\n"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def turn_on(light_id: int, state: bool) -> None:\n        lights[light_id] = state\n\n    lights = [False] * 16\n    for s in stdin.split('\\n'):\n        if s == '0':\n            turn_on(0, False)\n        if s == '1':\n            turn_on(1, True)\n    return sum(1 for light in lights if lights[light])\n\ndef"
    },
    {
        "number": 3106,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split()\n    for i in range(len(a)-1):\n        if a[i] == '1':\n            a[i] = '0'\n        else:\n            a[i] = '1'\n    return ''.join(a)"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    counts = 0\n    for i in range(N):\n        route = stdin.strip().split()\n        n = len(route)\n        for j in range(n-1):\n            if route[j+1] < route[j]:\n                counts += 1\n    for i in range(M):\n        a, b = map(int, stdin.strip().split())\n        if a <= b:\n            counts += a - b\n    return str(counts)\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 3\n   ... 3 1 3 1\n   ... 2 2 1\n   ... 3 3 1 3\n   ... 1 2\n   ... 2 3\n   ... 3 1\n   ... ''')\n    '1'\n    >>> solution('''10 2\n   ... 1 3 6 8 2 5 4 7 1 6 9 3 8\n   ... 10 2\n   ... 2 5\n   ... 9 8\n   ... 7 6\n   ... 8 4\n   ... 2 5\n   ... 3 1\n   ... 3 1\n   ... 2 1\n   ... 7 2\n   ... 5 1\n   ... 4 8\n   ... 7 3\n   ... 7 1\n   ... 7 2\n   ... 4 1\n   ... 7 3\n   ... 8 4\n   ... 2 5\n   ... 5 1\n   ... 4 8\n   ... 3 1\n   ... 1 5\n   ... 5 4\n   ... 1 4\n   ... 5 3\n   ... 8 5\n   ... 8 7\n   ... 1 4\n   ... 3 1\n   ... 5 3\n   ... 3 4\n   ... 2 5\n   ... 3 1\n   ... 5 4\n   ... 1 4\n   ... 5 1\n   ... 4 7\n   ... 5 4\n   ... 2 4\n   ... 4 5\n   ... 1 1\n   ... 8 5\n   ... 2 4\n   ... 3 4\n   ... 2 5\n   ... 4 1\n   ... 5 1\n   ... 2 3\n   ... 1 2\n   ... 4 1\n   ... 3 3\n   ... 4 2\n   ... 5 3\n   ... 6 3\n   ... 1 3\n   ... 3 2\n   ... 3 3\n   ... 3 3\n   ... 2 5\n   ... 6 3\n   ... 2 5\n   ... 3 1\n   ... 7 3\n   ... 7 4\n   ... 4 1\n   ... 3 5\n   ... 8 5\n   ... 5 1\n   ... 3 4\n   ... 8 7\n   ... 4 1\n   ... 5 1\n   ... 8 5\n   ... 5 7\n   ... 1 6\n   ... 1 5\n   ... 8 7\n   ... 4 3\n   ... 3 4\n   ... 4 4\n   ... 8 5\n   ... 2 4\n   ... 5 1\n   ... 2 4\n   ... 4 1\n   ... 2 2\n   ... 3 1\n   ... 5 3\n   ... 1 4\n   ... 3 4\n   ... 1 4\n   ... 4 3\n   ... 6 1\n   ... 2 3\n   ... 1 5\n   ... 1 5\n   ... 3 2\n   ... 4 4\n   ... 1 4\n   ... 3 3\n   ... 2 4\n   ... 5 5\n   ... 4 3\n   ... 3 5\n   ... 2 5\n   ... 4 3\n   ... 7 3\n   ... 1 5\n   ... 4 3\n   ... 5 3\n   ... 6 3\n   ... 4 3\n   ... 2 2\n   ... 6 5\n   ... 5 2\n   ... 2 3\n   ... 1 4\n   ... 4 3\n   ... 1 4\n   ... 4 4\n   ... 1 3\n   ... 5 2\n   ... 2 2\n   ... 2 5\n   ... 5 4\n   ... 4 1\n   ... 2 4\n   ... 4 4\n   ... 2 4\n   ... 4 3\n   ... 5 3\n   ... 2 5\n   ... 5 3\n   ... 1 6\n   ... 2 4\n   ... 4 3\n   ... 5 4\n   ... 3 4\n   ... 5 4\n   ... 4 4\n   ... 5 4\n   ... 1 2\n   ... 3 1\n   ... 1 4\n   ... 1 5\n   ... 2 1\n   ... 1 4\n   ... 1 4\n   ... 4 1\n   ... 3 1\n   ... 2 2\n   ... 1 2\n   ... 4 3\n   ... 1 3\n   ... 1 5\n   ... 1 5\n   ... 2 4\n   ... 2 3\n   ... 5 4\n   ... 4 1\n   ... 1 4\n   ... 3 2\n   ... 3 4\n   ... 2 3\n   ... 3 2\n   ... 3 2\n   ... 4 1\n   ... 3 2\n   ... 2 5\n   ... 4 4\n   ... 1 4\n   ... 2 4\n   ... 5 1\n   ... 4 3\n   ... 3 2\n   ... 4 1\n   ... 5 1\n   ... 4 4\n   ... 1 4\n   ... 1 4\n   ... 1 4\n   ... 4 3\n   ... 3 4\n   ... 1 4\n   ... 4 2\n   ... 5 4\n   ... 2 4\n   ... 1 4\n   ... 4 2\n   ... 3 4\n   ... 2 4\n   ... 5 4\n   ... 2 4\n   ... 3 4\n   ... 2 4\n   ... 4 4\n   ... 1 4\n   ... 4 4\n   ... 4 4\n   ... 3"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    map = {0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\"}\n    trucks = [(map[i], map[i + 1]) for i in range(1, 4)]\n    encounters = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            # If they are in the same city or in the same order\n            if map[i] == map[j]:\n                # If the route is not straight\n                if not (trucks[i][0] == map[i] and trucks[j][0] == map[j]):\n                    # If they can't turn\n                    if (map[i], map[j]) not in map.items():\n                        # If they're not standing still\n                        if not (trucks[i][1] == map[i] and trucks[j][1] == map[j]):\n                            # Increment encounters\n                            encounters += 1\n            # If they have different orders\n            elif (trucks[i][0], trucks[j][0]) in map.items():\n                # Increment encounters\n                encounters += 1\n    return str(encounters)\n\n\nprint(solution(input()))\n\nfrom itertools import combinations\n\nn, m = map(int, input().split())\n\nal = []\n\nfor i in range(n):\n    al.append(int(input()))\n\nall_combos = []\n\nfor i in range(1, n + 1):\n    all_combos.extend(list(combinations(al, i)))\n\nall_combos = list(set(all_combos))\nall_combos.sort()\n\ncombos = []\n\nfor i in range(len(all_combos)):\n    if all_combos[i][1] - all_combos[i][0] < m:\n        combos.append(all_combos[i])\n\ncombos.sort()\n\nfor i in combos:\n    print(i[0], i[-1])"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_route(nums: List[int]) -> bool:\n        curr = 0\n        for i in range(1, len(nums)):\n            if nums[i] <= nums[curr]:\n                return False\n            curr = i\n        return True\n    def merge(nums: List[int], a: List[int], b: List[int]) -> None:\n        i = j = k = 0\n        while i < len(a) and j < len(b):\n            if a[i] < b[j]:\n                nums[k] = a[i]\n                i += 1\n            else:\n                nums[k] = b[j]\n                j += 1\n            k += 1\n        while i < len(a):\n            nums[k] = a[i]\n            i += 1\n            k += 1\n        while j < len(b):\n            nums[k] = b[j]\n            j += 1\n            k += 1\n    def sort(nums: List[int]) -> None:\n        n = len(nums)\n        for i in range(n):\n            j = i + 1\n            while j < n and nums[j] < nums[i]:\n                j += 1\n            merge(nums, nums[i:j], nums[j:n])\n    try:\n        nums = [int(x) for x in stdin.split()]\n        if not is_valid_route(nums):\n            raise ValueError\n        sort(nums)\n        return \" \".join(map(str, nums))\n    except ValueError:\n        return \"Invalid Input\""
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    route = [(int(stdin.split()[i]), int(stdin.split()[i + 1])) for i in range(2, n * 2, 2)]\n    ans = [0 for _ in range(m)]\n    for i in range(len(route) - 1):\n        ans[route[i][1] - 1] += 1\n        ans[route[i + 1][1] - 1] += 1\n    return \" \".join(map(str, ans))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    \uc774 \ubb38\uc81c\ub294 \ubc18\ub4dc\uc2dc \ud30c\uc774\uc36c\uc758 \ud2b9\uc218\ud55c \ud568\uc218\uc5d0 \ub300\ud574 \uc54c\uc544\uc57c \ud558\ub294 \ubb38\uc81c\ub77c\uace0 \uc0dd\uac01\ud588\uc73c\uba70,\n    \ub9cc\uc57d \uc785\ub825\uc774 \uc5c6\ub294 \uacbd\uc6b0\uc5d0 \uc2e4\ud328\ud55c\ub2e4.\n    '''\n    N, M = map(int, stdin.split())\n    trucks = [list(map(int, stdin.split())) for _ in range(N)]\n    first_cities = []\n    for truck in trucks:\n        first_cities.append(truck[0])\n    first_cities = sorted(first_cities)\n    cities_visited = []\n    for i in range(M):\n        truck1, truck2 = list(map(int, stdin.split()))\n        if truck1 < truck2:\n            cities_visited += first_cities[truck1 - 1:truck2]\n        else:\n            cities_visited += first_cities[truck2 - 1:truck1]\n    cities_visited = sorted(cities_visited)\n    if len(cities_visited) == N:\n        return '\\n'.join(str(x) for x in cities_visited)\n    return str(len(cities_visited))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    K = 0\n    ans = 0\n    for i in range(M):\n        K, K1 = map(int, stdin.split())\n        if K == K1:\n            ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    m = int(stdin.split(\"\\n\")[1])\n    trucks = []\n    for i in range(n):\n        trucks.append(list(map(int, stdin.split(\"\\n\")[i + 1].split())))\n    pairs = []\n    for i in range(m):\n        pairs.append(list(map(int, stdin.split(\"\\n\")[i + n + 2].split())))\n    encounters = []\n    for i in range(m):\n        encounters.append(0)\n    for pair in pairs:\n        for i in range(n):\n            encounters[pair[1] - 1] += 1\n            encounters[pair[0] - 1] += 1\n    return \" \".join([str(encounters[i]) for i in range(m)])\nprint(solution(input()))\n"
    },
    {
        "number": 3107,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    routes = []\n    for _ in range(N):\n        route = list(map(int, stdin.split()))\n        routes.append(route)\n    counter = Counter()\n    for i in range(M):\n        r_start = routes[i][0]\n        r_end = routes[i][1]\n        if r_start <= r_end:\n            counter[(r_start, r_end)] += 1\n        else:\n            counter[(r_end, r_start)] += 1\n    return str(counter[tuple(routes[i][1:])] for i in range(len(routes)))"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    nums = list(map(int, stdin.split()))\n    #nums = sorted(nums)\n    total = 0\n    max_val = 0\n    for i in range(0, N - K + 1):\n        total += sum(nums[i:i + K])\n        if total > max_val:\n            max_val = total\n        total = total - sum(nums[i:i + K]) + nums[i + K - 1]\n    return str(max_val / N)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split()\n    N = int(a[0])\n    K = int(a[1])\n    a = a[2]\n    a = list(map(int, a.split()))\n    max = 0\n    sum = 0\n    count = 0\n    for i in range(len(a)):\n        sum += a[i]\n        if count == K:\n            count = 0\n        count += 1\n        if max < sum/K:\n            max = sum/K\n    return str(max)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    arr_sorted = sorted(arr)\n    prev_n_sum = 0\n    max_avg = 0\n    for n in range(1, n):\n        prev_n_sum += arr_sorted[n - 1]\n        if prev_n_sum >= k:\n            cur_avg = (prev_n_sum - arr_sorted[n - 1]) / n\n            if max_avg < cur_avg:\n                max_avg = cur_avg\n\n    return f\"{max_avg:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    nums = list(map(int, stdin.split()))\n    if k == 1:\n        return str(sum(nums)/n)\n    ans = float('-inf')\n    for i in range(1, n - k + 1):\n        subsum = sum(nums[i:i + k])\n        if subsum > 0 and subsum / k >= ans:\n            ans = subsum / k\n    return str(ans)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    array = list(map(int, stdin.split()))\n    best = 0\n    count = 0\n    for i in range(N):\n        count += array[i]\n        if count > best:\n            best = count\n        if count < best:\n            best = count\n        if count == best:\n            best = count\n            break\n    return str(best)\nprint(solution(input()))"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort()\n    prev_sum = 0\n    max_avg = 0\n    for i, a in enumerate(A):\n        prev_sum += a\n        if i+1-k>=0:\n            avg = prev_sum/k\n            if max_avg<avg:\n                max_avg = avg\n        else:\n            prev_sum = a\n    return str(max_avg)\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    avg = sum(arr[:K]) / K\n    max_avg = avg\n    for i in range(N - K + 1):\n        avg += (arr[i + K] - arr[i]) / K\n        if avg > max_avg:\n            max_avg = avg\n    return str(max_avg)"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    N = int(stdin[0])\n    K = int(stdin[1])\n    array = [int(x) for x in stdin[2].split()]\n    \n    max_average = -1\n    for i in range(1, len(array) - K + 1):\n        current_average = sum(array[i:i + K]) / K\n        if max_average < current_average:\n            max_average = current_average\n    return f\"{max_average:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(_) for _ in stdin.split())\n    arr = sorted(int(_) for _ in stdin.split())\n    cur_avg = sum(arr[i + 1] - arr[i] for i in range(N - K)) / K\n    return f\"{cur_avg:.5f}\""
    },
    {
        "number": 3108,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    N, K = map(int, stdin[0].split())\n    arr = stdin[1].split()\n    a = [int(e) for e in arr]\n    a.sort()\n    ans = 0\n    start = 0\n    end = 0\n    while start < len(a) and end < len(a):\n        if a[end] - a[start] > K:\n            end += 1\n        elif a[end] - a[start] == K:\n            ans = (ans + (a[end] - a[start])) / K\n            start = end\n            end += 1\n    return '%.3f' % ans\n\nprint(solution(input()))"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = stdin.split()\n    n = int(n)\n    m = int(m)\n    w = int(w)\n    h = int(h)\n    input = stdin.split()\n\n    heights = list(map(float, input[1:]))\n    # we want to minimize the difference\n    # between the height of the tallest sand section and the height of the lowest section\n    # so we want to find the tallest sand section and the lowest sand section\n    # so we have to look at the first n-1 sections\n    tallest = max(heights)\n    lowest = min(heights)\n    # return the difference between the tallest and lowest sand height\n    return '{:.3f}'.format(tallest - lowest)"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def peek(queue):\n        if len(queue) > 0:\n            return queue[0]\n        return None\n\n    # Parse inputs\n    num_sections = int(stdin[0])\n    num_colors = int(stdin[1])\n    width = int(stdin[2])\n    height = int(stdin[3])\n    sand_volumes = list(map(float, stdin[4].split(' ')))\n    section_widths = list(map(float, stdin[5].split(' ')))\n\n    # Initialize variables\n    sand_heights = []\n    section_heights = [[-1 for _ in range(num_colors)] for _ in range(num_sections)]\n    section_colors = [[] for _ in range(num_sections)]\n\n    for i in range(num_sections):\n        # Initialize variables\n        sand_height = -1\n        section_height = [-1 for _ in range(num_colors)]\n\n        for j in range(num_colors):\n            if sand_height < sand_volumes[j]:\n                sand_height = sand_volumes[j]\n                section_height = section_widths[i] / sand_height\n\n        section_height = max(section_height, -1)\n\n        for j in range(num_colors):\n            if section_height > section_widths[i]:\n                section_colors[i].append(j)\n                section_heights[i] = max(section_height, section_heights[i])\n\n    result = 0\n    for i in range(num_sections):\n        current_height = max(section_heights[i])\n        for j in range(num_colors):\n            if j in section_colors[i]:\n                if current_height > section_heights[i][j]:\n                    result += abs(current_height - section_heights[i][j])\n\n    return str(result)\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = list(map(int, stdin.split()))\n    sand = sorted(list(map(float, stdin.split()[1:])))\n    return str(max(abs(sand[0] - sand[1]), abs(sand[-1] - sand[-2]))/max(sand[0], sand[-1]))"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, m, w, h = stdin.split('\\n')\n    m = int(m)\n    w = int(w)\n    h = int(h)\n    n = w * h\n    stdin = stdin.split('\\n')\n    stdin = sorted(stdin, key=lambda x: x[0])\n    stdin = sorted(stdin, key=lambda x: x[1])\n    stdin = sorted(stdin, key=lambda x: x[2])\n    stdin = sorted(stdin, key=lambda x: x[3])\n    stdin = sorted(stdin, key=lambda x: x[4])\n    stdin = sorted(stdin, key=lambda x: x[5])\n    min = []\n    max = []\n    for i in range(n - 1):\n        if stdin[i][1] == stdin[i + 1][1]:\n            min.append(stdin[i][1])\n        else:\n            break\n    for i in range(n - 1):\n        if stdin[i][1] == stdin[i + 1][1]:\n            max.append(stdin[i][1])\n        else:\n            break\n    return str(min[0] - max[0])\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    (n, m, w, h) = stdin.split()\n    (n, m, w, h) = (int(n), int(m), int(w), int(h))\n    sand = sorted([float(i) for i in stdin.split()])\n    d = [[] for i in range(n - 1)]\n    for i in range(n - 1):\n        d[i] = sand.copy()\n        d[i].sort()\n    d.sort(key=lambda x: x[-1])\n    # print(sand)\n    # print(d)\n    # print(n, m, w, h)\n    # for i in d:\n    #     print(i)\n    #     print(len(i))\n    # exit()\n    # print(sand)\n    ans = 0\n    for i in range(n - 1):\n        # print(i)\n        # print(sand[i], d[i][-1], d[i][0])\n        ans = max(ans, d[i][-1] - d[i][0])\n    return '%.3f' % ans\n    # print(ans)\n    # print(sand)\n    # print(max(d[-1][-1] - d[-1][0], d[0][0] - d[0][-1]))\n    # return '%.3f' % max(d[-1][-1] - d[-1][0], d[0][0] - d[0][-1])\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = [int(x) for x in stdin.split()]\n    v = [float(x) for x in stdin.split()]\n    min_v = [float(x) for x in stdin.split()]\n    max_v = [float(x) for x in stdin.split()]\n    s = Solution()\n    return str(s.solution(n, m, w, h, v, min_v, max_v))"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = stdin.split()\n    n, m, w, h = int(n), int(m), int(w), int(h)\n    v = list(map(float, stdin.split()[1:]))\n    stdin = stdin.split('\\n')\n    min_vals = []\n    for i in range(n-1):\n        min_vals.append(float(stdin[i+1].split()[j]))\n    max_vals = []\n    for i in range(n):\n        max_vals.append(float(stdin[i+1].split()[j]))\n    min_vals = sorted(min_vals)\n    max_vals = sorted(max_vals)\n    output = 0\n    for i in range(n-1):\n        output += abs(min_vals[i] - max_vals[i])\n    return str(output)\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split())\n    sand = list(map(float, stdin.split()[1:]))\n    min_sand = list(map(float, stdin.split()[2:]))\n    max_sand = list(map(float, stdin.split()[3:]))\n    return str(min(sand) - max(sand))\nprint(solution(input()))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, x, *sand_volumes = stdin.split()\n    sand_volumes = list(map(float, sand_volumes))\n    sand_levels = sorted(sand_volumes)\n    divider_colors = {}\n    for i in range(n-1):\n        divider_colors[i] = {'min': float('inf'),'max': float('-inf')}\n    for i in range(n):\n        divider_colors[i]['min'] = sand_levels[i]\n        divider_colors[i]['max'] = sand_levels[i]\n    for line in stdin.splitlines():\n        color, *args = line.split()\n        color = float(color)\n        if color in divider_colors:\n            for arg in args:\n                arg = float(arg)\n                if arg < color:\n                    divider_colors[divider_colors['min']]['min'] = min(divider_colors['min']['min'], arg)\n                    divider_colors[divider_colors['min']]['max'] = max(divider_colors['min']['max'], arg)\n                if arg > color:\n                    divider_colors[divider_colors['max']]['min'] = min(divider_colors['max']['min'], arg)\n                    divider_colors[divider_colors['max']]['max'] = max(divider_colors['max']['max'], arg)\n    return str(min(abs(divider_colors[divider_colors['min']]['max'] - divider_colors[divider_colors['min']]['min']), abs(divider_colors[divider_colors['max']]['max'] - divider_colors[divider_colors['max']]['min'])))\n"
    },
    {
        "number": 3109,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = [*map(int, stdin.split())]\n    values = [*map(float, stdin.split())]\n    values.sort()\n    max_sand = 0\n    max_sand_index = 0\n    min_sand = 0\n    min_sand_index = 0\n    for index, value in enumerate(values):\n        max_sand = max(max_sand, value)\n        min_sand = min(min_sand, value)\n        if max_sand == value:\n            max_sand_index = index\n        if min_sand == value:\n            min_sand_index = index\n    sand_levels = [[0]*(max_sand_index + 1) for i in range(min_sand_index + 1)]\n    for i in range(1, min_sand_index + 1):\n        sand_levels[i][0] = sand_levels[i-1][0] + min_sand\n    for i in range(min_sand_index + 1, n):\n        sand_levels[i][0] = sand_levels[i-1][0] + values[i]\n    for i in range(1, min_sand_index + 1):\n        sand_levels[0][i] = sand_levels[0][i-1] + min_sand\n    for i in range(min_sand_index + 1, n):\n        sand_levels[0][i] = sand_levels[0][i-1] + values[i]\n    for i in range(1, n):\n        sand_levels[i][1] = sand_levels[i-1][1] + values[i]\n    for i in range(n - 1, min_sand_index - 1, -1):\n        sand_levels[i][n-1] = sand_levels[i + 1][n - 1] + min_sand\n    for i in range(n - 2, min_sand_index, -1):\n        sand_levels[i][n-2] = sand_levels[i + 1][n - 2] + min_sand\n    for i in range(min_sand_index + 1, n - 1):\n        sand_levels[i][n-3] = sand_levels[i + 1][n - 3] + min_sand\n    sand_levels[n-1][n-4] = sand_levels[n-2][n-3] + min_sand\n    sand_levels[n-2][n-5] = sand_levels[n-3][n-4] + min_sand\n    sand_levels[n - 3][n - 6] = sand_levels[n-4][n-5] + min_sand\n    sand_levels[n - 4][n - 7] = sand_levels[n-5][n-6] + min_sand\n    sand_levels[n - 5][n - 8] = sand_levels[n-6][n-7] + min_sand\n    sand_levels[n - 6][n - 9] = sand_levels[n-7][n-8] + min_sand\n    sand_levels[n - 7][n - 10] = sand_levels[n-8][n-9] + min_sand\n    sand_levels[n - 8][n - 11] = sand_levels[n - 9][n - 10] + min_sand\n    sand_levels[n - 9][n - 12] = sand_levels[n - 10][n - 11] + min_sand\n    sand_levels[n - 10][n - 13] = sand_levels[n - 11][n - 12] + min_sand\n    sand_levels[n - 11][n - 14] = sand_levels[n - 12][n - 13] + min_sand\n    sand_levels[n - 12][n - 15] = sand_levels[n - 13][n - 14] + min_sand\n    sand_levels[n - 13][n - 16] = sand_levels[n - 14][n - 15] + min_sand\n    sand_levels[n - 14][n - 17] = sand_levels[n - 15][n - 16] + min_sand\n    sand_levels[n - 15][n - 18] = sand_levels[n - 16][n - 17] + min_sand\n    sand_levels[n - 16][n - 19] = sand_levels[n - 17][n - 18] + min_sand\n    sand_levels[n - 17][n - 20] = sand_levels[n - 18][n - 19] + min_sand\n    sand_levels[n - 18][n - 21] = sand_levels[n - 19][n - 20] + min_sand\n    sand_levels[n - 19][n - 22] = sand_levels[n - 20][n - 21] + min_sand\n    sand_levels[n - 20][n - 23] = sand_levels[n - 21][n - 22] + min_sand\n    sand_levels[n - 21][n - 24] = sand_levels[n - 22][n - 23] + min_sand\n    sand_levels[n - 22][n - 25] = sand_levels[n - 23][n - 24] + min_sand\n    sand_levels"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    m, n = map(int, stdin.split())\n    if n!= 1:\n        print(0)\n        return\n    # part 1\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            p = 1\n            for k in range(i, m):\n                if k!= i and j!= 0:\n                    if p == 0:\n                        break\n                    elif str(p).count('0')!= 1:\n                        p = str(p).replace('0', '')\n                    if str(p).count('0')!= 1:\n                        break\n                p *= int(stdin[k * n + j])\n            if p!= 1:\n                p = str(p).replace('0', '')\n                p = str(p).replace('1', '')\n                p = int(p)\n            ans += p\n    print(ans)\n    # part 2\n    # i = 0\n    # while i < m * n:\n    #     i += 1\n    #     if i % 2 == 0:\n    #         print(i)\n    #         if i < m * n:\n    #             for j in range(n):\n    #                 if int(str(i).replace('0', '')) % j == 0:\n    #                     if int(str(i).replace('0', '')) // j!= 0:\n    #                         if int(str(i).replace('0', '')) // j == 1:\n    #                             print(i)\n    #                             return\n    #                 else:\n    #                     break\n    #         else:\n    #             print(i)\n    #     else:\n    #         print(i)\n    #         if i < m * n:\n    #             for j in range(n):\n    #                 if int(str(i).replace('0', '')) % j == 0:\n    #                     if int(str(i).replace('0', '')) // j!= 0:\n    #                         if int(str(i).replace('0', '')) // j == 1:\n    #                             print(i)\n    #                             return\n    #                 else:\n    #                     break\n    #         else:\n    #             print(i)"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    nums = map(int, stdin.split())\n    cnt = 0\n    for i in range(2, m + 1):\n        for j in range(n + 1):\n            if not(nums[i - 2] == 0 or nums[i - 1] == 0 or nums[i] == 0):\n                temp = nums[i - 1] * nums[i - 2]\n                if nums[i - 1] == 0 or nums[i] == 0 or nums[i - 2] == 0:\n                    temp = nums[i - 2] + nums[i - 1]\n                    if nums[i] == 0:\n                        temp = nums[i - 2] + nums[i - 1]\n                temp = temp % 10\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 1] + nums[i]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 1] - nums[i]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i] - nums[i - 1]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 2] - nums[i - 1]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 2] * nums[i]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 1] * nums[i - 2]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 2] * nums[i - 1]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n                temp = nums[i - 1] * nums[i - 2]\n                if temp == nums[j]:\n                    nums[j] = 0\n                    cnt += 1\n    return str(cnt)\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    m, n = map(int, stdin.split())\n    codes = []\n    for _ in range(m):\n        codes.append(list(map(int, stdin.split())))\n    \n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if codes[i][j]!= 0:\n                continue\n            \n            count = 0\n            for k in range(j):\n                if codes[i][k] == codes[i][j]:\n                    count += 1\n            for k in range(j, n):\n                if codes[i][k] == codes[i][j]:\n                    count += 1\n            for k in range(j+1, n):\n                if codes[i][k] == codes[i][j]:\n                    count += 1\n            \n            if codes[i][j] == codes[i][j+1]:\n                count += 1\n            \n            if count == 3:\n                for k in range(i+1, m):\n                    if codes[k][j] == 0:\n                        codes[k][j] = codes[i][j]\n                        break\n                res += 1\n    \n    return str(res)\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [[int(x) for x in stdin.split()] for _ in range(n)]\n    ans = 0\n    for i in range(m):\n        a, b = 0, 0\n        for j in range(n):\n            a = a*grid[j][i] + grid[j][i]\n            b = b*grid[j][i] + grid[j][i]\n        if a == 0 or b == 0 or a-b == 0:\n            ans += 1\n        else:\n            break\n    for i in range(n):\n        a, b = 0, 0\n        for j in range(m):\n            a = a*grid[i][j] + grid[i][j]\n            b = b*grid[i][j] + grid[i][j]\n        if a == 0 or b == 0 or a-b == 0:\n            ans += 1\n        else:\n            break\n    for i in range(m):\n        a, b = 0, 0\n        for j in range(n):\n            a = a*grid[j][i] + grid[j][i]\n            b = b*grid[j][i] + grid[j][i]\n        if a == 0 or b == 0 or a-b == 0:\n            ans += 1\n        else:\n            break\n    for i in range(n):\n        a, b = 0, 0\n        for j in range(m):\n            a = a*grid[i][j] + grid[i][j]\n            b = b*grid[i][j] + grid[i][j]\n        if a == 0 or b == 0 or a-b == 0:\n            ans += 1\n        else:\n            break\n    return str(ans)"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Return the number of complete codes if there is one.\n    # Return \"IMPOSSIBLE\" if there is no code.\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    print(len([solution_brute(n, m)]))\n    return ''\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split('\\n')\n    a.sort(key=lambda x: (len(x), int(x)))\n    m = int(a[0])\n    n = int(a[1])\n    arr = list(map(int, a[2].split(' ')))\n    res = 0\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if arr[i]!= 0:\n                u = arr[i]\n                if (u * j) % 10!= 0:\n                    if (u * j) % 10!= 1:\n                        res += 1\n                if (u * j) % 10!= 1:\n                    res += 1\n    return str(res)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split(\"\\n\")[0])\n    n = int(stdin.split(\"\\n\")[1])\n    grid = [[0 for _ in range(n)] for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            grid[i][j] = int(stdin.split(\"\\n\")[i + 2].split()[j])\n    # print(grid)\n    if m > 3 or n > 3:\n        return \"0\"\n    # print(m, n)\n    if m == 1 or n == 1:\n        return str(m * n)\n    codes = []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j]!= 0:\n                continue\n            # print(i, j)\n            codes.append(solve(i, j, grid, m, n))\n    # print(codes)\n    if len(codes) == 0:\n        return \"0\"\n    # print(codes)\n    return str(len(set(codes)))\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n\n    grid = [[int(c) for c in stdin.split()[i + 2]] for i in range(m)]\n\n    codes = 0\n\n    # Loop through all possible partial codes.\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            # Code is a series of integers that represent L.\n            code = list(range(1, 10))\n            for k in range(i):\n                if grid[i][j] * grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j, n):\n                if grid[i][j] * grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            for k in range(i + 1, m):\n                if grid[i][j] * grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j + 1, n):\n                if grid[i][j] * grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            if len(code) == 3:\n                # print(i, j, 'L', *code)\n                codes += 1\n\n            # Code is a series of integers that represent Sum.\n            code = list(range(1, 10))\n            for k in range(i):\n                if grid[i][j] + grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j, n):\n                if grid[i][j] + grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            for k in range(i + 1, m):\n                if grid[i][j] + grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j + 1, n):\n                if grid[i][j] + grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            if len(code) == 3:\n                # print(i, j, 'Sum', *code)\n                codes += 1\n\n            # Code is a series of integers that represent Diff.\n            code = list(range(1, 10))\n            for k in range(i):\n                if grid[i][j] - grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j, n):\n                if grid[i][j] - grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            for k in range(i + 1, m):\n                if grid[i][j] - grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j + 1, n):\n                if grid[i][j] - grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            if len(code) == 3:\n                # print(i, j, 'Diff', *code)\n                codes += 1\n\n            # Code is a series of integers that represent Prod.\n            code = list(range(1, 10))\n            for k in range(i):\n                if grid[i][j] * grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j, n):\n                if grid[i][j] * grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            for k in range(i + 1, m):\n                if grid[i][j] * grid[k][j]!= 0:\n                    code.remove(grid[k][j])\n            for k in range(j + 1, n):\n                if grid[i][j] * grid[i][k]!= 0:\n                    code.remove(grid[i][k])\n\n            if len(code) == 3:\n                # print(i, j, 'Prod', *code)\n                codes += 1\n    return str(codes)\n"
    },
    {
        "number": 3110,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    m, n = int(data[0]), int(data[1])\n    grid = []\n    for i in range(m):\n        grid.append([])\n        for j in range(n):\n            grid[i].append(int(data[2+i*n+j]))\n    solution = \"\"\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                solution += str(grid[i][j])\n            elif j == 0:\n                solution += str(grid[i][j])\n            elif i == 0:\n                solution += str(grid[i][j])\n            else:\n                if i == 0 and j == 0:\n                    if grid[i][j] == 0:\n                        solution += \"0\"\n                    elif grid[i][j] == 1:\n                        solution += \"0\"\n                    else:\n                        solution += \"1\"\n                else:\n                    if grid[i][j] == 0:\n                        solution += \"0\"\n                    elif grid[i][j] == 1:\n                        solution += \"0\"\n                    else:\n                        solution += \"1\"\n                        solution += \"0\"\n    solution = list(solution)\n    counter = 0\n    for i in range(len(solution)):\n        if solution[i] == \"0\":\n            solution[i] = \"2\"\n            counter += 1\n        elif solution[i] == \"1\":\n            solution[i] = \"3\"\n            counter += 1\n        else:\n            pass\n    solution = \"\".join(solution)\n    print(solution)\n    return solution\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    configuration = list(map(int, stdin.split()))\n    totalSum = 0\n    for i in range(M):\n        indexA, indexB = map(int, input().split())\n        firstSum = configuration[indexA - 1] + configuration[indexB - 1]\n        totalSum += firstSum\n        configuration[indexA - 1] = firstSum\n        configuration[indexB - 1] = firstSum\n    return str(totalSum)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split()))\n    return '\\n'.join(solution_helper(stdin))\n\n\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, m = list(map(int, stdin.split()))\n    dials = list(map(int, stdin.split()))\n    if n == 1:\n        return \"0\"\n    dials.sort()\n    res = \"\".join(map(str, dials))\n    lst = list(range(1, n + 1))\n    for i in range(m):\n        for j in range(0, n):\n            if dials[i] == lst[j]:\n                res = res[:j] + str(int(res[j]) + 1) + res[j + 1:]\n                lst[j] = int(res[j])\n    return res\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = [int(line) for line in stdin.strip().split('\\n')]\n    N, M = lines[:2]\n    initial = lines[2:]\n    dials = list(initial)\n\n    for i in range(M):\n        summed = sum(dials)\n        if summed >= 9:\n            summed -= 10\n        dials = [x + 1 for x in dials]\n        dials.append(summed)\n\n    return str(summed)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    m = int(stdin.splitlines()[1])\n    segments = stdin.splitlines()[2:]\n    dials = []\n    for i in range(n):\n        dials.append(list(map(int, stdin.splitlines()[i + 3].split())))\n    # add a large number so that dials can be compared\n    dials.sort(key=lambda x: x[0], reverse=True)\n    result = 0\n    for i in range(n):\n        result += dials[i][0]\n        if dials[i][1]:\n            result += dials[i][1]\n    for i in range(n):\n        result -= dials[i][0]\n        if dials[i][1]:\n            result -= dials[i][1]\n    return str(result)\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dials = []\n    for i in range(n):\n        dials.append(list(map(int, stdin.split())))\n    result = []\n    for i in range(m):\n        # Write your code below this line\n        sum_temp = 0\n        for j in range(n):\n            if dials[j][i] > 0:\n                sum_temp += dials[j][i]\n            if dials[j][i] == 9:\n                dials[j][i] = 0\n        result.append(sum_temp)\n    return''.join(list(map(str, result)))"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    stdin = stdin.split(\"\\n\")\n    N, M = map(int, stdin[0].split())\n    dials = []\n    for i in range(1, N + 1):\n        dials.append(stdin[i - 1])\n    sum1 = 0\n    sum2 = 0\n    for i in range(len(dials)):\n        num = int(dials[i])\n        if i == 0:\n            sum1 = num\n            sum2 = num\n        else:\n            sum1 = sum1 + num\n            sum2 = sum2 + sum1\n    for i in range(len(dials)):\n        num = int(dials[i])\n        sum2 = sum2 - num\n        print(sum2)\n    return str(sum2)\n\nsolution(\"\"\"\n4 3\n1234\n1 4\n1 4\n1 4\n\"\"\")\n"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = [line.rstrip() for line in stdin.splitlines()]\n    num_lines = int(input_lines[0])\n    input_digits = input_lines[1]\n    num_digits = len(input_digits)\n    possibilities = list(range(num_digits + 1))\n    all_sums = []\n    for i in range(num_lines):\n        a, b = map(int, input_lines[i + 2].split())\n        all_sums.append(solution_part_1(num_digits, possibilities, a, b))\n        for j in range(a, b + 1):\n            possibilities[j] = 0\n    return \"\\n\".join(map(str, all_sums))\n\n\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.strip().split()\n    n, m = int(n), int(m)\n    numbers = [int(x) for x in stdin.split()]\n    numbers.insert(0,0)\n    sheet = [[0 for i in range(n)] for j in range(m)]\n    for i in range(m):\n        for j in range(n):\n            sheet[i][j] = numbers[i*n + j + 1]\n    totals = []\n    for i in range(n + 1):\n        totals.append(sum([sheet[j][i] for j in range(m) if j!= i]))\n    for i in range(m):\n        for j in range(n):\n            if sheet[i][j] == 1:\n                if j == n - 1:\n                    totals[-1] -= 1\n                else:\n                    totals[j] -= 1\n                break\n    return '\\n'.join([str(x) for x in totals])\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = list(map(int, stdin.split()))\n    edges = set()\n    for _ in range(M):\n        a, b = list(map(int, stdin.split()))\n        edges.add((a,b))\n        edges.add((b,a))\n    print(solution_help(N, K, M, edges))\n    return ''\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # return 0\n    n, k, m = list(map(int, stdin.split()))\n    d = {}\n    for i in range(1, n+1):\n        d[i] = []\n    for _ in range(m):\n        i, j = list(map(int, input().split()))\n        d[i].append(j)\n        d[j].append(i)\n    max_prod = 0\n    max_prod_nums = []\n    for i in range(1, n+1):\n        if i not in d:\n            max_prod_nums.append(i)\n            max_prod += 1\n    print(max_prod)\n    # for i in range(1, n+1):\n    #     if i not in d:\n    #         max_prod_nums.append(i)\n    #         max_prod += 1\n    #\n    # print(max_prod)\n    # print(max_prod_nums)\n    return str(max_prod)"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    conveyor_belt = [(i, j) for i in range(1, n + 1) for j in range(1, n + 1)]\n\n    def distance(origin, destination):\n        return abs(origin[0] - destination[0]) + abs(origin[1] - destination[1])\n\n    def make_conveyor_belt_route(conveyor_belt):\n        n = len(conveyor_belt)\n        routes = {i: [] for i in range(1, n + 1)}\n\n        for i in range(n):\n            routes[i + 1].append(conveyor_belt[i])\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(routes[i + 1][-1], routes[j + 1][0]) <= 2:\n                    routes[i + 1] += routes[j + 1]\n                    routes[j + 1] = []\n\n        for i in range(n):\n            if len(routes[i + 1]) == 0:\n                return -1\n        return routes[1]\n\n    return str(len(make_conveyor_belt_route(conveyor_belt)))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = stdin.split(\" \")\n    n, k, m = int(n), int(k), int(m)\n    j = 1\n    i = 1\n    prod_queue = []\n    while i <= k:\n        prod_queue.append((j, i))\n        i += 1\n        j += 1\n    l = 0\n    ans = k + 1\n    while l < m:\n        if prod_queue:\n            q = prod_queue.pop(0)\n            l += 1\n            i = q[1]\n            j = q[0]\n            if j == k and i == k:\n                ans = min(ans, l)\n            elif j < k:\n                prod_queue.append((j + 1, i))\n            else:\n                prod_queue.append((j, i + 1))\n        else:\n            ans = min(ans, l)\n            break\n    return str(ans)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.strip().split())\n    s = 0\n    if K >= 2 and N >= 1:\n        for i in range(1, N+1):\n            s += (M-1) * (K-1)\n    if N >= 2 and K >= 2 and M >= 1:\n        for i in range(1, N+1):\n            for j in range(1, N+1):\n                if i!= j:\n                    s += (M-1) * (K-1)\n    return str(s)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K, M = map(int, stdin.split())\n    junctions = {j: None for j in range(1, N + 1)}\n    for _ in range(M):\n        i, j = map(int, stdin.split())\n        junctions[i] = j\n\n    # filter out the one-way conveyor belts\n    K = K - 1\n\n    # find out how many conveyor belts each producer needs\n    producers = []\n    for i in range(1, N + 1):\n        if junctions[i] is None:\n            producers.append(i)\n    producers.sort()\n\n    # find out how many time-scales each producer can run\n    time_scales = {}\n    for i in producers:\n        time_scales[i] = {}\n        for t in range(1, K + 1):\n            time_scales[i][t] = False\n    for i, j in junctions.items():\n        if j is not None:\n            time_scales[j][1] = True\n\n    # build a graph of conveyor belts\n    graph = collections.defaultdict(set)\n    for i in producers:\n        for t in range(1, K + 1):\n            if time_scales[i][t]:\n                graph[i].add(j for j in range(1, N + 1) if junctions[j] == t)\n\n    # find out how many products can be delivered to each producer\n    max_producers = 0\n    for i in producers:\n        if not graph[i]:\n            max_producers = max(max_producers, i)\n    return str(max_producers)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = stdin.strip().split()\n    N, K, M = int(N), int(K), int(M)\n    stdin = [(int(x), int(y)) for x, y in stdin.strip().split()]\n    conveyor_belt_dict = {}\n    for x, y in stdin:\n        if x in conveyor_belt_dict:\n            conveyor_belt_dict[x].append(y)\n        else:\n            conveyor_belt_dict[x] = [y]\n    ans = 0\n    visited = set()\n    p = 0\n    while len(visited) < N:\n        visited.add(p)\n        if p in conveyor_belt_dict:\n            for x in conveyor_belt_dict[p]:\n                if x not in visited:\n                    visited.add(x)\n                    if len(visited) == N:\n                        break\n        p += 1\n    return str(p - 1)\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    producers = []\n    for _ in range(K):\n        producers.append(tuple(map(int, stdin.split())))\n    # N, K, M = map(int, input().split())\n    # prods = []\n    # for _ in range(K):\n    #     prods.append(tuple(map(int, input().split())))\n    # prods = sorted(prods)\n    # N, K, M = prods\n    conveyor_belt_graph = {\n        (i, j): set() for i in range(1, N + 1) for j in range(i + 1, N + 1)\n    }\n    for i, j in map(tuple, stdin.split()):\n        conveyor_belt_graph[i].add(j)\n        conveyor_belt_graph[j].add(i)\n    products_at_junctions = {}\n    for junction in range(1, N + 1):\n        products_at_junctions[junction] = 0\n\n    def can_make_production(prod_junction, prod_prod_count):\n        if prod_prod_count >= products_at_junctions[prod_junction]:\n            return False\n        for conveyor_belt in conveyor_belt_graph[prod_junction]:\n            if conveyor_belt in products_at_junctions:\n                if products_at_junctions[conveyor_belt] > prod_prod_count:\n                    return False\n            else:\n                products_at_junctions[conveyor_belt] = prod_prod_count\n        return True\n\n    if can_make_production(1, products_at_junctions[1]):\n        prod_count = products_at_junctions[1]\n        for j, c in enumerate(producers):\n            if can_make_production(c[0], prod_count):\n                products_at_junctions[c[1]] = prod_count\n                prod_count = prod_count + c[1]\n            else:\n                prod_count = prod_count + products_at_junctions[c[0]]\n    return str(max(prod_count, 1))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    return str(int(max([N, K])))\n"
    },
    {
        "number": 3112,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    edges = {(i+1, j+1) for i in range(N) for j in range(i+1, N)}\n    print(edges)\n    \n    while len(edges) > 1:\n        min_queue = []\n        max_queue = []\n        for edge in edges:\n            if len(min_queue) == 0:\n                min_queue.append(edge)\n            else:\n                if min_queue[0][0] < edge[0]:\n                    min_queue.append(edge)\n                else:\n                    min_queue.append(min_queue[0])\n            if len(max_queue) == 0:\n                max_queue.append(edge)\n            else:\n                if max_queue[-1][0] > edge[0]:\n                    max_queue.append(edge)\n                else:\n                    max_queue.append(max_queue[-1])\n            if len(min_queue) == len(max_queue):\n                break\n        print(min_queue)\n        print(max_queue)\n        if len(min_queue) == len(max_queue):\n            break\n        #remove the edge that is no longer in the queue\n        min_queue.pop(0)\n        max_queue.pop(-1)\n        \n        \n        #check if any edge is in the queue\n        if len(min_queue) > 0 and max_queue[-1][0] >= min_queue[0][0]:\n            edges = set(edges).difference(set(min_queue).union(set(max_queue)))\n            print(edges)\n        else:\n            edges = set(edges).difference(set(min_queue).union(set(max_queue)))\n            print(edges)\n            \n    print(len(edges))\n    return str(len(edges))\n\nsolution(input())\n'''\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: implement this function\n    stdin = stdin.split('\\n')\n    Garry = stdin[0].split(' ')\n    Jerry = stdin[1].split(' ')\n    Garry = [int(i) for i in Garry]\n    Jerry = [int(i) for i in Jerry]\n    print(Garry)\n    print(Jerry)\n    def triangle(a,b,c):\n        return abs(a[0]-b[0]) + abs(a[1]-b[1]) + abs(a[2]-b[2]) <= 10**9 and abs(a[0]-c[0]) + abs(a[1]-c[1]) + abs(a[2]-c[2]) <= 10**9 and abs(b[0]-c[0]) + abs(b[1]-c[1]) + abs(b[2]-c[2]) <= 10**9\n    \n    def solve(x,y):\n        if triangle(Garry,x,y) and triangle(Garry,y,x):\n            if triangle(Jerry,x,y) and triangle(Jerry,y,x):\n                print('yes')\n                return\n        print('no')\n        return\n    for i in range(len(Garry)):\n        solve(Garry[i],Jerry[i])\n        solve(Jerry[i],Garry[i])\n    return"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x1, y1, x2, y2, x3, y3 = [int(i) for i in stdin.strip().split()]\n    cloud1 = set()\n    cloud2 = set()\n    for i in range(n):\n        if x1 <= x2 <= x3 <= x1 and y1 <= y2 <= y3 <= y1:\n            cloud1.add((x1, y1))\n            cloud1.add((x2, y2))\n            cloud1.add((x3, y3))\n        elif x1 <= x3 <= x2 <= x1 and y1 <= y3 <= y2 <= y1:\n            cloud1.add((x1, y1))\n            cloud1.add((x3, y3))\n            cloud1.add((x2, y2))\n        elif x2 <= x1 <= x3 <= x2 and y1 <= y2 <= y3 <= y1:\n            cloud1.add((x2, y2))\n            cloud1.add((x1, y1))\n            cloud1.add((x3, y3))\n        elif x2 <= x1 <= x3 <= x2 and y1 <= y3 <= y2 <= y1:\n            cloud1.add((x2, y2))\n            cloud1.add((x1, y3))\n            cloud1.add((x3, y3))\n        elif x3 <= x1 <= x2 <= x3 and y1 <= y2 <= y3 <= y1:\n            cloud1.add((x3, y3))\n            cloud1.add((x1, y1))\n            cloud1.add((x2, y2))\n        elif x3 <= x1 <= x2 <= x3 and y1 <= y2 <= y3 <= y1:\n            cloud1.add((x3, y3))\n            cloud1.add((x2, y2))\n            cloud1.add((x1, y1))\n        else:\n            cloud1.add((x1, y1))\n            cloud1.add((x2, y2))\n            cloud1.add((x3, y3))\n        x1, y1, x2, y2, x3, y3 = [int(i) for i in stdin.strip().split()]\n    cloud2 = set()\n    for i in range(n):\n        if x1 <= x2 <= x3 <= x1 and y1 <= y2 <= y3 <= y1:\n            cloud2.add((x1, y1))\n            cloud2.add((x2, y2))\n            cloud2.add((x3, y3))\n        elif x1 <= x3 <= x2 <= x1 and y1 <= y3 <= y2 <= y1:\n            cloud2.add((x1, y1))\n            cloud2.add((x3, y3))\n            cloud2.add((x2, y2))\n        elif x2 <= x1 <= x3 <= x2 and y1 <= y2 <= y3 <= y1:\n            cloud2.add((x2, y2))\n            cloud2.add((x1, y1))\n            cloud2.add((x3, y3))\n        elif x2 <= x1 <= x3 <= x2 and y1 <= y3 <= y2 <= y1:\n            cloud2.add((x2, y2))\n            cloud2.add((x1, y3))\n            cloud2.add((x3, y3))\n        elif x3 <= x1 <= x2 <= x3 and y1 <= y2 <= y3 <= y1:\n            cloud2.add((x3, y3))\n            cloud2.add((x1, y1))\n            cloud2.add((x2, y2))\n        elif x3 <= x1 <= x2 <= x3 and y1 <= y2 <= y3 <= y1:\n            cloud2.add((x3, y3))\n            cloud2.add((x2, y2))\n            cloud2.add((x1, y1))\n        else:\n            cloud2.add((x1, y1))\n            cloud2.add((x2, y2))\n            cloud2.add((x3, y3))\n    if cloud1 == cloud2:\n        return \"yes\"\n    else:\n        return \"no\"\n\nprint(solution(stdin.read()))\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.splitlines()[0])\n    for i in range(n):\n        Garry_Cloud = stdin.splitlines()[i*3+1].split()\n        Jerry_Cloud = stdin.splitlines()[i*3+2].split()\n        Garry_Cloud = [int(i) for i in Garry_Cloud]\n        Jerry_Cloud = [int(i) for i in Jerry_Cloud]\n        Garry_Cloud = sorted(Garry_Cloud)\n        Jerry_Cloud = sorted(Jerry_Cloud)\n        Garry_Cloud_Area = _area_of_triangle(Garry_Cloud)\n        Jerry_Cloud_Area = _area_of_triangle(Jerry_Cloud)\n        if Garry_Cloud_Area == 0 or Jerry_Cloud_Area == 0:\n            continue\n        if Garry_Cloud_Area == Jerry_Cloud_Area:\n            continue\n        if Garry_Cloud_Area - Jerry_Cloud_Area == 0:\n            continue\n        if Garry_Cloud_Area - Jerry_Cloud_Area == 1:\n            continue\n        if Garry_Cloud_Area - Jerry_Cloud_Area == -1:\n            continue\n        return 'yes'\n    return 'no'\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x1,y1,x2,y2,x3,y3 = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    x4,y4,x5,y5,x6,y6 = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    if (x1*x2 + y1*y2 + x3*x4 + y3*y4 + x5*x6 + y5*y6) == (x1*x5 + y1*y5 + x2*x6 + y2*y6):\n        return 'yes'\n    return 'no'"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.splitlines()\n    garry = stdin_lines.pop(0)\n    jerry = stdin_lines.pop(0)\n    garry_list = garry.split()\n    jerry_list = jerry.split()\n    triangles_garry = [(int(garry_list[i]), int(garry_list[i + 1]), int(garry_list[i + 2]), int(garry_list[i + 3]), int(garry_list[i + 4]), int(garry_list[i + 5])) for i in range(0, len(garry_list) - 6, 6)]\n    triangles_jerry = [(int(jerry_list[i]), int(jerry_list[i + 1]), int(jerry_list[i + 2]), int(jerry_list[i + 3]), int(jerry_list[i + 4]), int(jerry_list[i + 5])) for i in range(0, len(jerry_list) - 6, 6)]\n    seen_cloud_cover_garry = set()\n    seen_cloud_cover_jerry = set()\n    for triangle in triangles_garry:\n        seen_cloud_cover_garry.add(tuple(triangle))\n    for triangle in triangles_jerry:\n        seen_cloud_cover_jerry.add(tuple(triangle))\n    if seen_cloud_cover_jerry == seen_cloud_cover_garry:\n        return \"yes\"\n    else:\n        return \"no\"\nprint(solution(input()))\n\n'''\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    a = set()\n    b = set()\n    for i in range(len(stdin)):\n        x, y = map(int, stdin[i].split())\n        a.add((x, y))\n    for i in range(len(stdin)):\n        x, y = map(int, stdin[i].split())\n        b.add((x, y))\n    if a.intersection(b) or a.intersection(b) == a.intersection(b):\n        return \"no\"\n    else:\n        return \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n,m = map(int, stdin.split(\"\\n\"))\n    Garry = set()\n    Jerry = set()\n    for _ in range(n):\n        Garry.add(tuple(map(int, stdin.split(\"\\n\")[_].split())))\n    for _ in range(m):\n        Jerry.add(tuple(map(int, stdin.split(\"\\n\")[_].split())))\n\n    if len(Garry.intersection(Jerry)) == 0:\n        return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    #n = int(input())\n    #stdin = stdin.split()\n    #print(stdin)\n    stdin = stdin.split()\n    stdin = stdin[1:]\n    #print(stdin)\n    #return stdin\n    #stdin = list(map(int, stdin))\n    cloud1 = list(map(int, stdin[:n]))\n    cloud2 = list(map(int, stdin[n:]))\n    return \"yes\" if len(cloud1) == len(set(cloud1)) == len(cloud2) == len(set(cloud2)) else \"no\"\n    \n    #print(cloud1)\n    #print(cloud2)\n    #return \"yes\" if len(cloud1) == len(set(cloud1)) == len(cloud2) == len(set(cloud2)) else \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    Garry_lines = stdin.split()\n    Garry_list = []\n    for i in range(len(Garry_lines)):\n        Garry_list.append([int(Garry_lines[i][j]) for j in range(6)])\n    Jerry_lines = stdin.split()\n    Jerry_list = []\n    for i in range(len(Jerry_lines)):\n        Jerry_list.append([int(Jerry_lines[i][j]) for j in range(6)])\n    Garry_set = set()\n    Jerry_set = set()\n    for i in range(len(Garry_list)):\n        if (Garry_list[i][0], Garry_list[i][1]) in Gary_set:\n            Garry_set.add((Garry_list[i][0], Garry_list[i][1]))\n        else:\n            Garry_set.add((Garry_list[i][0], Garry_list[i][1]))\n        if (Garry_list[i][2], Garry_list[i][3]) in Gary_set:\n            Garry_set.add((Garry_list[i][2], Garry_list[i][3]))\n        else:\n            Garry_set.add((Garry_list[i][2], Garry_list[i][3]))\n        if (Garry_list[i][4], Garry_list[i][5]) in Gary_set:\n            Garry_set.add((Garry_list[i][4], Garry_list[i][5]))\n        else:\n            Garry_set.add((Garry_list[i][4], Garry_list[i][5]))\n    for i in range(len(Jerry_list)):\n        if (Jerry_list[i][0], Jerry_list[i][1]) in Jerry_set:\n            Jerry_set.add((Jerry_list[i][0], Jerry_list[i][1]))\n        else:\n            Jerry_set.add((Jerry_list[i][0], Jerry_list[i][1]))\n        if (Jerry_list[i][2], Jerry_list[i][3]) in Jerry_set:\n            Jerry_set.add((Jerry_list[i][2], Jerry_list[i][3]))\n        else:\n            Jerry_set.add((Jerry_list[i][2], Jerry_list[i][3]))\n        if (Jerry_list[i][4], Jerry_list[i][5]) in Jerry_set:\n            Jerry_set.add((Jerry_list[i][4], Jerry_list[i][5]))\n        else:\n            Jerry_set.add((Jerry_list[i][4], Jerry_list[i][5]))\n    if len(Garry_set) == len(Jerry_set):\n        return 'yes'\n    else:\n        return 'no'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3113,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Find out if the given cloud cover is equal to any of the given cloud cover.\n    '''\n    lines = [\n        line.strip().split()\n        for line in stdin.splitlines()\n    ]\n\n    garry = []\n    jerry = []\n    for i in range(len(lines)):\n        garry.append(\n            tuple(\n                [\n                    int(lines[i][j])\n                    for j in range(6)\n                ]\n            )\n        )\n        jerry.append(\n            tuple(\n                [\n                    int(lines[i][j])\n                    for j in range(6)\n                ]\n            )\n        )\n\n    if check_triangle(garry, jerry):\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [[False] * n for _ in range(n)]\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        a[x - 1][y - 1] = True\n        a[y - 1][x - 1] = True\n    for i in range(n):\n        for j in range(n):\n            if not a[i][j] and a[j][i]:\n                return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    arr = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = list(map(int, stdin.split()))\n        arr[x - 1].append(y - 1)\n        arr[y - 1].append(x - 1)\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            if check_cycle(i, arr, visited):\n                return \"YES\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N < 1 or N > 50:\n        return 'NO'\n    if M < 1 or M > (N * (N - 1) / 2):\n        return 'NO'\n\n    graph = {n: [] for n in range(1, N + 1)}\n    for n in range(M):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for node in range(1, N + 1):\n        if len(graph[node]) < 2:\n            return 'NO'\n\n    for node in range(1, N + 1):\n        for node2 in range(1, N + 1):\n            if node!= node2 and node2 in graph[node]:\n                return 'NO'\n    return 'YES'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cities = {}\n    for i in range(1, N + 1):\n        cities[i] = []\n    for _ in range(M):\n        x, y = map(int, stdin.split())\n        cities[x].append(y)\n        cities[y].append(x)\n    for i in range(1, N + 1):\n        if len(cities[i]) == 2:\n            if (cities[i][0] in cities[i][1:] and\n                cities[i][1] in cities[i][2:]):\n                return 'YES'\n    return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    cities = []\n    for i in range(int(stdin)):\n        cities.append(list(map(int, stdin.split())))\n    routes = [[] for _ in range(int(stdin))]\n    for i in range(int(stdin)):\n        for j in range(i + 1, int(stdin)):\n            if cities[i][0]!= cities[j][0]:\n                if i in routes[j] or j in routes[i]:\n                    return 'NO'\n                else:\n                    routes[i].append(j)\n                    routes[j].append(i)\n    return 'YES'"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n    for i in range(N):\n        if not any(j in edges[i] for j in range(N)):\n            return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n!= m:\n        return \"NO\"\n    nodes = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        nodes[u].append(v)\n        nodes[v].append(u)\n    dist = {}\n    q = {1}\n    seen = set(q)\n    while q:\n        node = q.pop()\n        if node in dist:\n            continue\n        dist[node] = 1\n        seen.add(node)\n        q.update(nodes[node])\n    for node in nodes:\n        if node not in seen:\n            return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    road_graph = {i: [] for i in range(1, N + 1)}\n    for i in range(M):\n        x, y = map(int, stdin.split())\n        road_graph[x].append(y)\n        road_graph[y].append(x)\n    for key, value in road_graph.items():\n        if len(value) == N - 1:\n            return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cities = [(i, i + 1) for i in range(1, N)] + [(i, i + 2) for i in range(1, N)]\n    roads = {}\n    for i in range(M):\n        x, y = map(int, stdin.split())\n        roads[(x, y)] = roads.get((x, y), 0) + 1\n        roads[(y, x)] = roads.get((y, x), 0) + 1\n\n    if len(roads) == N:\n        return 'NO'\n    for k in roads.keys():\n        if roads[k] > 1:\n            return 'NO'\n\n    possible = True\n    for x, y in roads:\n        if x not in cities or y not in cities:\n            possible = False\n            break\n    if possible:\n        for x, y in roads:\n            roads[(x, y)] -= 1\n            roads[(y, x)] -= 1\n        return 'YES'\n\n    return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m = list(map(int, lines.pop(0).split()))\n    if m < 1 or m > n * (n - 1) // 2:\n        return \"NO\"\n    all = []\n    for i in range(1, n + 1):\n        all.extend(list(map(int, lines.pop(0).split())))\n        if any(i not in all for i in list(map(int, lines.pop(0).split()))):\n            return \"NO\"\n    for i in range(1, m + 1):\n        if any(all.index(i) in lines[0].split()):\n            return \"NO\"\n    return \"YES\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    data = [list(map(int, input().split())) for _ in range(m)]\n    print('inconsistent') if n > 1 else print('consistent')\n    return 'inconsistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    matches = []\n    for _ in range(m):\n        K, L = map(int, stdin.strip().split())\n        matches.append([K, L])\n    # print(matches)\n    # print(matches[0][0], matches[0][1], matches[1][0], matches[1][1])\n    # print(matches[2][0], matches[2][1], matches[3][0], matches[3][1])\n    if matches[0][0] == matches[0][1]:\n        if matches[1][0] == matches[1][1]:\n            if matches[2][0] == matches[2][1]:\n                if matches[3][0] == matches[3][1]:\n                    return \"inconsistent\"\n                else:\n                    return \"inconsistent\"\n            else:\n                return \"inconsistent\"\n        else:\n            return \"inconsistent\"\n    elif matches[1][0] == matches[1][1]:\n        if matches[2][0] == matches[2][1]:\n            if matches[3][0] == matches[3][1]:\n                return \"inconsistent\"\n            else:\n                return \"inconsistent\"\n        else:\n            return \"inconsistent\"\n    elif matches[2][0] == matches[2][1]:\n        if matches[3][0] == matches[3][1]:\n            return \"inconsistent\"\n        else:\n            return \"inconsistent\"\n    else:\n        return \"inconsistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    matches = list(map(lambda line: line.split(), stdin.splitlines()[1:]))\n    players = {i: set() for i in range(N)}\n    for match in matches:\n        players[int(match[0])].add(int(match[1]))\n        players[int(match[1])].add(int(match[0]))\n    for player in players:\n        if len(players[player]) > 1:\n            return \"inconsistent\"\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    n, m = map(int, lines[0].split(' '))\n    reported = []\n    for line in range(1, m + 1):\n        k, l = map(int, lines[line].split(' '))\n        reported.append((k, l))\n    print(reported)\n    if len(reported) < n:\n        return 'inconsistent'\n    sorted_reported = sorted(reported, key=lambda x: (x[1], x[0]))\n    for i in range(len(sorted_reported) - 1):\n        if sorted_reported[i][1] == sorted_reported[i + 1][0]:\n            return 'inconsistent'\n    return 'consistent'\n\n\nprint(solution(input()))"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    players = set()\n    invalid_player = set()\n\n    for _ in range(M):\n        in_valid = set()\n        in_valid.add(int(stdin.split()[0]))\n        in_valid.add(int(stdin.split()[1]))\n        if in_valid == players:\n            return \"inconsistent\"\n        players.add(int(stdin.split()[0]))\n        players.add(int(stdin.split()[1]))\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    stats = [[] for _ in range(N)]\n    for _ in range(M):\n        K, L = map(int, stdin.split())\n        stats[K].append(L)\n    for idx, _ in enumerate(stats):\n        if len(_) > 0 and len(_) == 1:\n            _[0] = 1\n        if len(_) == 0:\n            if len(stats[idx - 1]) > 0:\n                stats[idx] = stats[idx - 1]\n    inconsistent = True\n    for idx, _ in enumerate(stats):\n        if len(_) == 1:\n            inconsistent = False\n    return 'inconsistent' if inconsistent else 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cnts = {i: 0 for i in range(N)}\n    for _ in range(M):\n        k, op, l = map(int, stdin.split())\n        cnts[k] += op == '>'\n        cnts[l] += op == '<'\n    for key, value in cnts.items():\n        if value!= 1:\n            return 'inconsistent'\n    return 'consistent'"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matches = [\n        [int(i) for i in stdin.split()[2*i].split(\">\")]\n        for i in range(m)\n    ]\n    return \"inconsistent\" if any(\n        [matches[i][0] == matches[i][1] for i in range(m)],\n        [\n            matches[i][0]!= matches[i][1] for i in range(m)\n        ],\n    ) else \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l = [int(x) for x in stdin.split()]\n    n, m = l[0], l[1]\n    l = l[2:]\n    x = [0]*n\n    y = [0]*n\n    for i in range(m):\n        k, l = l[i*2], l[i*2+1]\n        if k > l:\n            x[k] += 1\n            x[l] += 1\n            y[k] += 1\n            y[l] += 1\n        elif k < l:\n            x[k] += 1\n            x[l] += 1\n            y[k] += 1\n            y[l] += 1\n        else:\n            x[k] += 1\n            x[l] += 1\n            y[k] += 1\n            y[l] += 1\n    for i in range(n):\n        if x[i]!= y[i]:\n            return 'inconsistent'\n    return 'consistent'"
    },
    {
        "number": 3115,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    N, M = map(int, stdin.strip().split())\n    player_list = set()\n    match_list = set()\n    for player in range(N):\n        player_list.add(player)\n    for match in range(M):\n        K, L = map(int, stdin.strip().split())\n        if K in player_list and L in player_list:\n            match_list.add((K, L))\n    if len(match_list)!= len(player_list):\n        return 'inconsistent'\n    if len(match_list) == len(player_list):\n        for player in player_list:\n            if player in match_list:\n                match_list.remove(player)\n        if len(match_list) == 0:\n            return 'consistent'\n    return 'inconsistent'\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stars = stdin.split()\n    num_stars = int(stars.pop(0))\n    stars = list(map(lambda x: float(x), stars))\n    min_y = float('inf')\n    for i in range(num_stars):\n        min_y = min(stars[i], min_y)\n    min_x = float('inf')\n    min_z = float('inf')\n    for i in range(num_stars):\n        min_x = min(stars[i], min_x)\n        min_z = min(stars[i], min_z)\n    return min_y * min_x * min_z\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    n = int(stdin.pop(0))\n    stars = [(float(stdin.pop(0)), float(stdin.pop(0)), float(stdin.pop(0))) for _ in range(n)]\n    \n    x_comparator = lambda x: x[0]\n    y_comparator = lambda y: y[1]\n    z_comparator = lambda z: z[2]\n    \n    stars.sort(key=x_comparator)\n    stars.sort(key=y_comparator)\n    stars.sort(key=z_comparator)\n    \n    for x, y, z in stars:\n        if (x + y + z) >= 1000:\n            return '%.8f' % ((x + y + z) / 3)\n    return '%.8f' % 0\n\nprint(solution(input()))\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = []\n    for i in range(n):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n    points.sort()\n    upper_left = points[0]\n    lower_right = points[-1]\n    mid = (upper_left[0] + lower_right[0])/2, (upper_left[1] + lower_right[1])/2, (upper_left[2] + lower_right[2])/2\n    for i in range(n):\n        for j in range(i+1, n):\n            p1, p2 = points[i], points[j]\n            x, y, z = p1\n            w, h, v = p2\n            if mid[0] - x > w:\n                upper_left = p1\n            elif x - mid[0] > w:\n                lower_right = p2\n            elif mid[1] - y > h:\n                upper_left = p2\n            elif y - mid[1] > h:\n                lower_right = p1\n            elif mid[2] - z > v:\n                upper_left = p2\n            elif z - mid[2] > v:\n                lower_right = p1\n            else:\n                pass\n    l = lower_right\n    r = upper_left\n    x1 = (l[0] + r[0])/2\n    y1 = (l[1] + r[1])/2\n    z1 = (l[2] + r[2])/2\n    print(x1, y1, z1)\n    a = 0\n    b = 0\n    c = 0\n    for i in range(n):\n        a += (points[i][0] - x1)**2\n        b += (points[i][1] - y1)**2\n        c += (points[i][2] - z1)**2\n    a = (a / n) ** (0.5)\n    b = (b / n) ** (0.5)\n    c = (c / n) ** (0.5)\n    res = a + b + c\n    return \"{:.6f}\".format(res)\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stars = []\n    for line in stdin.splitlines():\n        stars.append([float(x) for x in line.split()])\n    stars = sorted(stars)\n    return math.pi * max(abs(stars[i][0]) for i in range(1, len(stars) - 1)) * max(abs(stars[i][1]) for i in range(1, len(stars) - 1)) * max(abs(stars[i][2]) for i in range(1, len(stars) - 1))"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split()\n    #print(instructions)\n    #instructions = list(map(lambda x: x.split(), stdin.split('\\n')))\n    #print(instructions)\n    #print(instructions[1])\n    sorted_instructions = sorted(instructions)\n    #print(sorted_instructions)\n    stars = []\n    for line in sorted_instructions:\n        #print(line)\n        #print(line[0], line[1], line[2])\n        stars.append((line[0], line[1], line[2]))\n    #print(stars)\n    return"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    stars = []\n    for i in range(n):\n        x, y, z = map(float, stdin.strip().split())\n        stars.append((x, y, z))\n    print(max_stars(stars))\n    return\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    stars = []\n    for _ in range(n):\n        stars.append(list(map(int, stdin.split())))\n    \n    radius = 1000\n    x, y, z = None, None, None\n    for i, j, k in stars:\n        if x == None:\n            x = i\n        elif y == None:\n            y = j\n        elif z == None:\n            z = k\n        else:\n            break\n    \n    if x == None:\n        x = 1\n    if y == None:\n        y = 1\n    if z == None:\n        z = 1\n    \n    if x == y or x == z or y == z:\n        return \"inf\"\n    \n    radius = abs(x) + abs(y) + abs(z)\n    \n    for i, j, k in stars:\n        if radius > abs(i) + abs(j) + abs(k):\n            radius = abs(i) + abs(j) + abs(k)\n    \n    return radius"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    ans = (float('inf'))\n    for i in range(3, n):\n        for j in range(i):\n            for k in range(j):\n                x, y, z = a[i]\n                l, m, n = a[j]\n                o, p, q = a[k]\n                if (l * m + m * n + n * o) * (l * p + p * q + q * o) == (x * y + y * z + z * o) * (x * p + p * q + q * o) and (x * y + y * z + z * o) * (x * l + l * m + m * n) * (x * p + p * q + q * o) > (x * y + y * z + z * o) * (x * l + l * m + m * n) * (x * p + p * q + q * o):\n                    ans = min(ans, (x * y + y * z + z * o) * (x * l + l * m + m * n) * (x * p + p * q + q * o))\n    return str(ans)\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    points = stdin.split(\"\\n\")\n    count = int(points[0])\n    stars = []\n    for i in range(1, count + 1):\n        x, y, z = map(int, points[i].split())\n        stars.append((x, y, z))\n    # Assume a cylinder is 2-dimensional.\n    # Create a 2-dimensional grid with $n^2$ points.\n    # Each point in the grid has coordinates of the form (x, y)\n    x = [(0, 0)] * (count ** 2)\n\n    # Count the number of stars in each cell in the grid.\n    # Store the number of stars in each cell in the array\n    # called \"grid\".\n    grid = [[0] * (count) for _ in range(count)]\n    for i, j in stars:\n        # Each star is in a cell with x, y, z coordinates of\n        # the form (x0, y0, z0)\n        x0 = (i, j)\n        grid[x0[0]][x0[1]] += 1\n        grid[x0[1]][x0[0]] += 1\n        grid[x0[0]][x0[1] - 1] += 1\n        grid[x0[1] - 1][x0[0]] += 1\n\n    # Add one to the number of stars in the \"north-east\"\n    # cell in the grid.\n    grid[0][count - 1] += 1\n    grid[count - 1][0] += 1\n\n    # The volume of a single cylinder with n-cubes is\n    # equal to n * pi * r ** 2.\n    # Create an array called \"v\" to hold the volume of each\n    # single cylinder.\n    # In each cell in the grid, store the volume of the\n    # corresponding single cylinder in the array called \"v\".\n    v = []\n    for i in range(count):\n        for j in range(count):\n            r = min(i, j) + 1\n            # Add the volume of a single cylinder with n-cubes to\n            # the array \"v\".\n            v.append(n * math.pi * r ** 2)\n\n    # In each cell in the grid, multiply the number of stars\n    # in that cell with the corresponding volume.\n    for i in range(count):\n        for j in range(count):\n            v[i * count + j] = v[i * count + j] * grid[i][j]\n\n    # Compute the volume of the \"north-east\" cylinder.\n    # This cylinder has a radius of 1 and a height of 2.\n    # Add all of the volumes of the cells in the grid that are\n    # in the \"north-east\" cylinder.\n    north_east = 0\n    for i in range(count):\n        if i + 1 < count:\n            north_east += v[i * count]\n        if i > 0:\n            north_east += v[i * count - 1]\n    return f'{north_east:.10f}'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3116,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x_s = set()\n    y_s = set()\n    z_s = set()\n    for _ in range(n):\n        x, y, z = stdin.split()\n        x = float(x)\n        y = float(y)\n        z = float(z)\n        x_s.add(x)\n        y_s.add(y)\n        z_s.add(z)\n    x_s = sorted(x_s)\n    y_s = sorted(y_s)\n    z_s = sorted(z_s)\n    x_d = 0\n    y_d = 0\n    z_d = 0\n    for i in x_s:\n        x_d = x_d + i\n    for j in y_s:\n        y_d = y_d + j\n    for k in z_s:\n        z_d = z_d + k\n    if z_d!= 0:\n        return f\"{z_d/2} {y_d/2} {x_d/2}\"\n    elif y_d!= 0:\n        return f\"{y_d/2} {x_d/2} 0\"\n    elif x_d!= 0:\n        return f\"0 0 {x_d/2}\"\n\n    return f\"{x_d/2} {y_d/2} 0\"\nprint(solution(input()))"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.split('\\n')\n    max = 0\n    for i in range(1, len(lst)):\n        strs = lst[i].split(' ')\n        for j in range(0, len(strs)):\n            if len(strs[j]) > max:\n                max = len(strs[j])\n    return max\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    length = len(text)\n    max_length = 0\n    for i in range(length):\n        for j in range(i + 1, length):\n            if text[i] == text[j]:\n                if j - i > max_length:\n                    max_length = j - i\n    return str(max_length)\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return len(set(stdin))"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    letter_counts = collections.Counter(stdin)\n    results = 0\n    for letter, count in letter_counts.items():\n        if count == 2:\n            results = max(results, len(letter))\n    return str(results) if results else \"0\"\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    maxLen = 0\n    counter = collections.Counter()\n    for c in stdin:\n        counter[c] += 1\n        maxLen = max(maxLen, counter[c])\n    return maxLen * 2 if maxLen > 1 else 0\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    length = len(stdin)\n    if length < 2:\n        return str(0)\n    letters = stdin[:2]\n    numbers = stdin[2:]\n    for i in range(length-2):\n        if numbers.count(letters) >= 2:\n            return str(i+1)\n    return str(0)\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return len(set(stdin))\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin\n    inp = inp.rstrip()\n    inp = inp.split(\"\\n\")\n    inp = inp[1]\n    inp = inp.replace(\" \", \"\")\n    inp = inp.replace(\"\\n\", \"\")\n    inp = inp.split(\";\")\n    inp = [s.strip() for s in inp]\n    inp = [s.replace(\" \", \"\") for s in inp]\n    inp = [s.replace(\"\\n\", \"\") for s in inp]\n    max_len = 0\n    for i in range(len(inp)):\n        if inp.count(inp[i]) > 1:\n            if len(inp[i]) > max_len:\n                max_len = len(inp[i])\n    return max_len\n\n\nprint(solution(inp))\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin\n    # data = '''6\n    # abc'''\n    lines = data.splitlines()\n    lines = [line.strip() for line in lines]\n    data = lines\n    data = list(data[0])\n    string = data\n    longest = []\n    for i in range(len(string)):\n        count = 0\n        for j in range(len(string)):\n            if i!= j:\n                if string[i] == string[j]:\n                    count += 1\n                    if count > 1:\n                        longest.append(string[i])\n        if count > 1:\n            longest.append(string[i])\n    if len(longest) > 0:\n        return len(longest[0])\n    else:\n        return 0\n"
    },
    {
        "number": 3117,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    max_length = 0\n    for word in words:\n        length = len(word)\n        if length in set(map(len, words)):\n            if length > max_length:\n                max_length = length\n    return str(max_length)"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    alice = stdin.split()[1]\n    bob = stdin.split()[2]\n    alice = [int(i) for i in alice]\n    bob = [int(i) for i in bob]\n    alice = sorted(alice)\n    bob = sorted(bob)\n    diff = 0\n    while alice!= bob:\n        diff += 1\n        if diff > 10**12:\n            return \"huge\"\n        alice, bob = alice[:], bob[:]\n        for i in range(n-1):\n            if alice[i] > bob[i]:\n                break\n            alice[i+1:], bob[i+1:] = bob[i:], alice[i+1:]\n    return str(diff)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    a.sort()\n    b.sort()\n\n    ans = 0\n    while a!= b:\n        ans += 1\n        a, b = b, a\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    alice,bob,thousand = stdin.split(\"\\n\")\n    n = len(alice)\n    a = list(map(int,alice.split()))\n    b = list(map(int,bob.split()))\n    t = 0\n    while a!= sorted(a) or b!= sorted(b):\n        t+=1\n        if a!= sorted(a):\n            a = sorted(a)\n            for i in range(n):\n                a[i],b[i] = b[i],a[i]\n        if b!= sorted(b):\n            b = sorted(b)\n            for i in range(n):\n                b[i],a[i] = a[i],b[i]\n    return str(t)\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    a = stdin[1].split()\n    b = stdin[2].split()\n    count = 0\n    cards = list(range(1, n+1))\n    for i in range(1, n):\n        cards[a[i-1]] = cards[b[i-1]]\n        cards[b[i-1]] = cards[a[i-1]]\n    for i in range(1, n+1):\n        if cards[i]!= i:\n            count += 1\n    if count == 0:\n        return \"huge\"\n    return str(count)\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.splitlines()\n    return str(helper(inputs))\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    shuffle_count = 0\n    alice_shuffle_count = 0\n    bob_shuffle_count = 0\n    while(shuffle_count < n):\n        a = list(map(int, stdin.split()))\n        b = list(map(int, stdin.split()))\n        a = sorted(a)\n        b = sorted(b)\n        if(a == b):\n            shuffle_count += 1\n        else:\n            a = sorted(a[::-1])\n            b = sorted(b[::-1])\n            if(a == b):\n                shuffle_count += 1\n            else:\n                alice_shuffle_count += 1\n        bob_shuffle_count += 1\n    print(\"{} {} {}\".format(alice_shuffle_count, bob_shuffle_count, shuffle_count))\n    return \"{} {} {}\".format(alice_shuffle_count, bob_shuffle_count, shuffle_count)"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [int(i) for i in stdin.split()]\n    b = [int(i) for i in stdin.split()]\n\n    # shuffle a\n    # check if sorted\n    # if not, shuffle b\n    # check if sorted\n    # if not, shuffle a\n    # check if sorted\n    # if not, shuffle b\n\n    # shuffle a\n\n    # check if sorted\n    # if not, shuffle b\n\n    # shuffle b\n\n    # check if sorted\n    # if not, shuffle a\n\n    # check if sorted\n    # if not, shuffle b\n\n    # return m\n\n\n\nsolution(\"2 2 1 3 1 2\")"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, *nums = stdin.split()\n    nums = list(map(int, nums))\n    alice, bob = 0, 0\n    cards = nums[:]\n    turn = 0\n    while alice < len(cards):\n        alice += 1\n        turn += 1\n        if alice == len(cards):\n            alice = 0\n        if turn > len(cards):\n            turn = 0\n        cards = list(map(lambda i: i + cards[alice], range(len(cards))))\n        if alice!= 0:\n            cards = list(map(lambda i: i - cards[alice], range(len(cards))))\n        if turn > len(cards):\n            turn = 0\n    if len(cards)!= 1:\n        cards = list(map(lambda i: i - cards[alice], range(len(cards))))\n    cards = nums[:]\n    turn = 0\n    while bob < len(cards):\n        bob += 1\n        turn += 1\n        if bob == len(cards):\n            bob = 0\n        if turn > len(cards):\n            turn = 0\n        cards = list(map(lambda i: i + cards[bob], range(len(cards))))\n        if alice!= 0:\n            cards = list(map(lambda i: i - cards[bob], range(len(cards))))\n        if turn > len(cards):\n            turn = 0\n    if len(cards)!= 1:\n        cards = list(map(lambda i: i - cards[bob], range(len(cards))))\n    cards = nums[:]\n    turn = 0\n    while alice < len(cards):\n        alice += 1\n        turn += 1\n        if alice == len(cards):\n            alice = 0\n        if turn > len(cards):\n            turn = 0\n        cards = list(map(lambda i: i + cards[alice], range(len(cards))))\n        if alice!= 0:\n            cards = list(map(lambda i: i - cards[alice], range(len(cards))))\n        if turn > len(cards):\n            turn = 0\n    if len(cards)!= 1:\n        cards = list(map(lambda i: i - cards[alice], range(len(cards))))\n    cards = nums[:]\n    turn = 0\n    while bob < len(cards):\n        bob += 1\n        turn += 1\n        if bob == len(cards):\n            bob = 0\n        if turn > len(cards):\n            turn = 0\n        cards = list(map(lambda i: i + cards[bob], range(len(cards))))\n        if alice!= 0:\n            cards = list(map(lambda i: i - cards[bob], range(len(cards))))\n        if turn > len(cards):\n            turn = 0\n    if len(cards)!= 1:\n        cards = list(map(lambda i: i - cards[bob], range(len(cards))))\n    if len(cards) == 1:\n        return \"huge\"\n    return turn\n\nprint(solution(input()))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    cards = input[1:]\n    a_positions = list(map(lambda x: int(x) - 1, input[1:]))\n    b_positions = list(map(lambda x: int(x) - 1, input[1:]))\n    a_positions.sort()\n    b_positions.sort()\n    \n    a_positions.reverse()\n    b_positions.reverse()\n    \n    m = 0\n    for i in range(len(a_positions)):\n        if a_positions[i]!= b_positions[i]:\n            m += 1\n    return str(m)\n\nprint(solution(input[0]))\n"
    },
    {
        "number": 3118,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    b = list(map(int, stdin.split(\"\\n\")[2].split()))\n    k = 0\n    while len(set(a))!= 1:\n        a = a + list(b)\n        a.sort()\n        k += 1\n    return str(k)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    notes = [*map(int, stdin.strip().split())]\n    max_score = 0\n    for i in range(len(notes) - 1):\n        if notes[i] + notes[i + 1] > max_score:\n            max_score = notes[i] + notes[i + 1]\n    return str(max_score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the solution as string.\n\n    >>> solution('''\n   ... 3 1\n   ... 0 10 20\n   ... 0 10\n   ... Sample Output 1:\n   ... 4\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 6 1\n   ... 0 10 20 26 40 50\n   ... 0 40\n   ... Sample Output 2:\n   ... 9\n   ... ''')\n    '9'\n    \"\"\"\n    notes_list, star_phrases_list = stdin.split('\\n')\n    notes_list = notes_list.split()\n    star_phrases_list = star_phrases_list.split()\n\n    notes = sorted(int(note) for note in notes_list)\n    star_phrases = sorted(tuple(sorted(int(start), int(end)) for start, end in zip(star_phrases_list, star_phrases_list[1:])), key=lambda x: x[0])\n\n    def scoring(note, star_phrase):\n        return (note + star_phrase[0]) * 2 if star_phrase[0]!= note else note\n\n    score = 0\n    for i in range(1, len(notes_list)):\n        current_note = notes[i]\n        current_star_phrases = sorted(sorted(star_phrases[j][0] for j in range(i)), key=lambda x: x <= current_note)\n        score_before_activation = sum(scoring(note, star_phrase) for note, star_phrase in zip(notes_list[i:], current_star_phrases))\n        if score_before_activation > score:\n            score = score_before_activation\n        for j in range(i, len(notes_list)):\n            if j - i >= len(current_star_phrases):\n                break\n            current_star_phrase = current_star_phrases[j - i]\n            current_note = notes[j]\n            current_star_phrase_active = (current_star_phrase[0] <= current_note)\n            score_before_activation = score_before_activation if not current_star_phrase_active else (\n                    score_before_activation - scoring(current_note, current_star_phrase))\n            if score_before_activation > score:\n                score = score_before_activation\n                break\n\n    return str(score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n    notes = sorted(list(map(int, stdin.strip().split()[1:])))\n    phrases = list()\n    sp = 0\n    for _ in range(m):\n        start, end = list(map(int, stdin.strip().split()[1:]))\n        sp += end - start\n        phrases.append((start, end))\n    return str(n * (notes[-1] - notes[0]) + sp)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # print(stdin)\n    notes = sorted(list(map(lambda x: int(x), stdin.split(\"\\n\")[0].split())))\n    sp_phrases = sorted(list(map(lambda x: list(map(int, x.split())), stdin.split(\"\\n\")[1:])))\n    # print(notes)\n    # print(sp_phrases)\n    score = 0\n    curr_pos = 0\n    sp_start = 0\n    sp_stop = 0\n    max_score = 0\n    sp_meter_now = 0\n    while sp_start < len(sp_phrases):\n        if sp_stop < 0:\n            sp_stop = sp_start + 1\n        if curr_pos < sp_phrases[sp_start][0]:\n            sp_start += 1\n        else:\n            if sp_start == sp_stop:\n                sp_stop += 1\n            while sp_stop < len(sp_phrases) and sp_phrases[sp_stop][0] - sp_phrases[sp_start][0] <= 0:\n                if sp_stop < len(sp_phrases) and sp_phrases[sp_stop][0] - sp_phrases[sp_start][0] > 0:\n                    sp_stop += 1\n                else:\n                    sp_stop += 1\n            if sp_stop - sp_start > 0:\n                sp_meter_now = sp_stop - sp_start\n                while sp_meter_now > 0:\n                    if sp_meter_now == 0:\n                        score += 2\n                    else:\n                        score += 1\n                    sp_meter_now -= 1\n            sp_start = sp_stop\n            sp_stop = sp_start\n            curr_pos = sp_phrases[sp_start][0]\n            max_score = max(max_score, score)\n            score = 0\n            sp_meter_now = 0\n    print(max_score)\n    return max_score\n\nsolution(stdin)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    notes = sorted(map(int, stdin.strip().split()))\n    phrases = []\n\n    while len(notes) > 0:\n        phrase = []\n        start, end = 0, 0\n        last = notes.pop()\n\n        while len(notes) > 0:\n            curr = notes.pop()\n            if curr == last:\n                phrase.append(last)\n                end = curr\n            else:\n                last = curr\n                phrase.append(curr)\n                end = curr\n                break\n        phrases.append(phrase)\n\n    phrases = sorted(phrases, key=lambda phrase: phrase[0])\n    score = 0\n    sp = 0\n    current_phrase = None\n    for i, phrase in enumerate(phrases):\n        if sp > 0 and current_phrase and sp >= current_phrase[1] - current_phrase[0]:\n            score += phrase[0]\n        else:\n            if current_phrase:\n                if current_phrase[0] + sp >= current_phrase[1]:\n                    if sp == current_phrase[1] - current_phrase[0]:\n                        score += phrase[0]\n                        sp = 0\n                    else:\n                        score += phrase[0] + sp\n                        sp = 0\n                else:\n                    score += phrase[0]\n            else:\n                score += phrase[0]\n        current_phrase = phrase\n\n    return str(score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p = list(map(int, stdin.split()))\n    notes = sorted(list(map(int, stdin.split())))\n    start, end = list(map(int, stdin.split()))\n    sp_phrases = []\n    sp_count = 0\n    star_power = []\n    for i in range(p):\n        sp_start, sp_end = list(map(int, stdin.split()))\n        sp_phrases.append((sp_start, sp_end))\n\n    notes = sorted(notes)\n    start = min(notes)\n    end = max(notes)\n    sp_phrases = sorted(sp_phrases)\n\n    while start < end:\n        if start in sp_phrases:\n            if start in star_power:\n                star_power.remove(start)\n                start += 2\n            else:\n                start += 1\n        else:\n            sp_count += 1\n            star_power.append(start)\n            start += 1\n\n    return str(sp_count)"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    notes = sorted(list(map(int, stdin.split())))\n    sp_phrases = []\n    for _ in range(p):\n        s, e = map(int, stdin.split())\n        sp_phrases.append((s, e))\n    sp_phrases.sort()\n    max_score = 0\n    sp_phrase_end = 0\n    for i in range(1, len(notes)):\n        if notes[i] - sp_phrase_end > 20000:\n            sp_phrase_start = sp_phrase_end + 20000\n            sp_phrase_end = notes[i]\n            sp_phrase_score = sp_phrase_end - sp_phrase_start\n            max_score = max(max_score, sp_phrase_score)\n        else:\n            sp_phrase_end = notes[i]\n    return str(max_score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_notes(positions: list):\n        notes = []\n        start_pos = positions[0]\n        end_pos = positions[1]\n        for pos in positions[2:]:\n            if pos - start_pos > end_pos - start_pos:\n                notes.append(start_pos)\n                start_pos = pos\n            end_pos = max(end_pos, pos)\n        notes.append(start_pos)\n        return notes\n    notes = []\n    positions = []\n    for pos in stdin.split():\n        positions.append(int(pos))\n    notes = get_notes(positions)\n    notes.sort()\n    # print(notes)\n    return sum([note * (notes.index(note) + 1) for note in range(1, len(notes) + 1)])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p = list(map(int, stdin.split()))\n    notes = list(map(int, stdin.split()))\n    times = []\n    for _ in range(n):\n        times.append(int(input()))\n    sp_phrases = []\n    for _ in range(p):\n        start, end = list(map(int, input().split()))\n        sp_phrases.append((start, end))\n    sp_phrases = sorted(sp_phrases)\n    time = 0\n    score = 0\n    for t in times:\n        if t >= time:\n            time = t + 10\n        else:\n            for sp in sp_phrases:\n                if time > sp[0]:\n                    time = sp[1]\n                    score += 2\n            time = t + 10\n    return str(score)"
    },
    {
        "number": 3119,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    notes_duration, phrases_duration = map(int, stdin.split())\n    notes = sorted(map(int, stdin.split()[1]))\n    notes = [(notes[i], notes[i + 1] - notes[i]) for i in range(0, len(notes), 2)]\n    notes = list(notes)\n    sp_phrases = [int(stdin.split()[2])]\n    while True:\n        for i in range(len(notes)):\n            notes[i] = (notes[i][0] + notes[i][1], max(notes[i][1], notes[i][1] + sp_phrases[0]))\n            if i == len(notes) - 1:\n                break\n            if notes[i][0] >= notes[i + 1][0]:\n                notes[i] = (notes[i][0], notes[i + 1][0])\n                break\n        sp_phrases.append(int(stdin.split()[3]))\n        if sp_phrases[-1] <= 0:\n            break\n    return len(notes)\n\nprint(solution(input()))"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Takes stdin and returns a String of the form 'equal' or 'not equal'\n    \n    >>> solution('shuffle([1,2,1,2]))\n    'not equal'\n    >>> solution('concat([3,2,1],[4,5,6]))\n    'equal'\n    >>> solution('sorted([1,2,3,4,5,6]))\n    'equal'\n    \"\"\"\n    A = stdin.split('\\n')[0]\n    B = stdin.split('\\n')[1]\n    A_1 = A.split('[')[1].split(']')[0].split(',')\n    A_2 = A.split('[')[1].split(']')[1].split(',')\n    A_3 = []\n    A_4 = []\n    for x in A_1:\n        A_3.append(int(x))\n    for x in A_2:\n        A_4.append(int(x))\n    A = A_3 + A_4\n    B_1 = B.split('[')[1].split(']')[0].split(',')\n    B_2 = B.split('[')[1].split(']')[1].split(',')\n    B_3 = []\n    B_4 = []\n    for x in B_1:\n        B_3.append(int(x))\n    for x in B_2:\n        B_4.append(int(x))\n    B = B_3 + B_4\n    if len(A)!= len(B):\n        return 'not equal'\n    else:\n        for i in range(len(A)):\n            A[i] = round(A[i] + B[i])\n    if A == B:\n        return 'equal'\n    else:\n        return 'not equal'"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip().splitlines()[1].split()[1]\n\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    #print(stdin)\n    #stdin =''.join(stdin.split())\n    #print(stdin)\n    #stdin = stdin.replace('[]','')\n    #stdin = stdin.replace('[','')\n    #stdin = stdin.replace(']','')\n    #stdin = stdin.replace(')','')\n    #stdin = stdin.replace('(','')\n    #stdin = stdin.replace('\\'','')\n    #stdin = stdin.replace(' ','')\n    #print(stdin)\n    #stdin = stdin.replace(' ','')\n    #print(stdin)\n    s = list(stdin.split())\n    print(s)\n    a = []\n    for i in range(len(s)):\n        if i%4 == 0:\n            if s[i] == '-':\n                b = sorted(s[i+1:i+4],reverse=True)\n                a.append(b)\n            else:\n                a.append(s[i+1:i+4])\n    print(a)\n    s1 = []\n    s2 = []\n    for i in range(len(a)):\n        if i%4 == 0:\n            s1.append(a[i])\n        else:\n            s2.append(a[i])\n    print(s1,s2)\n    b = []\n    c = []\n    d = []\n    for i in range(len(s1)):\n        b = s1[i][0]\n        d = s1[i][1]\n        for j in range(len(s2)):\n            if d == s2[j][0] or d == s2[j][1]:\n                c.append(d)\n                break\n    print(c)\n    #print(s1,s2)\n    #print(b,d)\n    #print(c)\n    if b == d:\n        print('equal')\n    else:\n        print('not equal')\n    #return b == d"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def combine(list1,list2):\n        return sorted(list1+list2)\n\n    def shuffle(list1,list2):\n        return list(shuffle(list(combine([i for i in range(len(list1))],list1)),list2))\n\n    def concat(list1,list2):\n        return list(list1+list2)\n\n    def sorted(list1):\n        return sorted(list1)\n    \n    program1 = stdin.splitlines()[1]\n    program2 = stdin.splitlines()[2]\n\n    program1_shuffle = shuffle(program1.split(\",\"),program2.split(\",\"))\n    program2_shuffle = shuffle(program2.split(\",\"),program1.split(\",\"))\n\n    program1_concat = concat(program1_shuffle,program2_shuffle)\n    program2_concat = concat(program2_shuffle,program1_shuffle)\n\n    program1_sorted = sorted(program1_concat)\n    program2_sorted = sorted(program2_concat)\n\n    if program1_sorted == program2_sorted:\n        return \"equal\"\n    else:\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return 'not equal' if stdin == solution(stdin) else 'equal'"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    program_1 = stdin.strip().split('\\n')\n    program_1 = [int(x) for x in program_1[0].split(',')]\n    program_2 = stdin.strip().split('\\n')\n    program_2 = [int(x) for x in program_2[1].split(',')]\n    if len(program_1)!= len(program_2):\n        return 'not equal'\n    if len(program_1) == 0:\n        return 'not equal'\n    if sorted(program_1) == sorted(program_2):\n        return 'equal'\n    return 'not equal'"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    first = stdin.split(\"\\n\")[0]\n    second = stdin.split(\"\\n\")[1]\n    first = first[5:].replace(\"[\",\"\").replace(\"]\",\"\")\n    second = second[5:].replace(\"[\",\"\").replace(\"]\",\"\")\n    if first == second:\n        return \"equal\"\n    else:\n        return \"not equal\"\nprint(solution(input()))\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin\n    # Write your code here\n    return 'equal' if A == stdin else 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l1 = stdin.split('\\n')[0]\n    l2 = stdin.split('\\n')[1]\n    l1 = eval(l1)\n    l2 = eval(l2)\n    if len(l1) == len(l2):\n        return 'equal'\n    else:\n        return 'not equal'\n    \nstdin = input()\nprint(solution(stdin))\n\"\"\"\n\nfrom math import sqrt\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    P1 = lines[0]\n    P2 = lines[1]\n    P1_s = P1.split('[')\n    P2_s = P2.split('[')\n    \n    P1_e = []\n    for i in P1_s[1:]:\n        P1_e.append(int(i))\n    P2_e = []\n    for i in P2_s[1:]:\n        P2_e.append(int(i))\n    \n    P1_d = {}\n    P2_d = {}\n    for i in P1_e:\n        P1_d[i] = P1_d.get(i, 0) + 1\n    for i in P2_e:\n        P2_d[i] = P2_d.get(i, 0) + 1\n    for i in P1_d:\n        P1_d[i] = P1_d[i] == P2_d[i]\n    for i in P2_d:\n        P2_d[i] = P1_d[i] == P2_d[i]\n    for i in P1_d:\n        P1_d[i] = P1_d[i] == 0\n    for i in P2_d:\n        P2_d[i] = P1_d[i] == 0\n    for i in P1_d:\n        P1_d[i] = P1_d[i] == 1\n    for i in P2_d:\n        P2_d[i] = P1_d[i] == 1\n    P1_d.pop('', None)\n    P2_d.pop('', None)\n    P1_e = []\n    P2_e = []\n    for i in P1_s[1:]:\n        P1_e.append(int(i))\n    for i in P2_s[1:]:\n        P2_e.append(int(i))\n    \n    P1_s = P1.split('[')\n    P2_s = P2.split('[')\n    P1_s_con = []\n    P2_s_con = []\n    for i in P1_s[1:]:\n        P1_s_con.append(i)\n    for i in P2_s[1:]:\n        P2_s_con.append(i)\n    \n    P1_con = []\n    P2_con = []\n    for i in range(len(P1_s_con)):\n        P1_con.append([P1_s_con[i],P1_s_con[i+1]])\n        P2_con.append([P2_s_con[i],P2_s_con[i+1]])\n    \n    #print(P1_con)\n    #print(P2_con)\n    #print(P1_e)\n    #print(P2_e)\n    for i in P1_con:\n        for j in P2_con:\n            if i[0] == j[0]:\n                if i[1] > j[1]:\n                    P1_d[i[0]] += 1\n                else:\n                    P2_d[j[0]] += 1\n    #print(P1_d)\n    #print(P2_d)\n    #print(P1_d == P2_d)\n    #print(P1_d[0],P2_d[0])\n    #print(P1_d[1],P2_d[1])\n    #print(P1_d[2],P2_d[2])\n    #print(P1_d[3],P2_d[3])\n    if P1_d == P2_d:\n        return 'equal'\n    else:\n        return 'not equal'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split())\n    n, m = map(int, input().split())\n    enemy = {}\n    for i in range(n):\n        enemy[i+1] = {}\n    for i in range(m):\n        a, b = map(int, input().split())\n        enemy[a][b] = (A, H)\n    for i in range(1, n+1):\n        if i in enemy:\n            for j in range(1, n+1):\n                if j in enemy:\n                    if i == j:\n                        pass\n                    elif j in enemy[i]:\n                        attack, health = enemy[i][j]\n                        enemy[i][j] = (attack - A, health - H)\n                    else:\n                        enemy[i][j] = enemy[i][j]\n    for i in range(1, n+1):\n        if i in enemy:\n            for j in range(1, n+1):\n                if j in enemy[i]:\n                    attack, health = enemy[i][j]\n                    if attack <= 0 and health <= 0:\n                        return 'Oh no'\n                    else:\n                        enemy[i][j] = attack, health\n    results = {}\n    for i in range(1, n+1):\n        if i in enemy:\n            for j in range(1, n+1):\n                if j in enemy[i]:\n                    attack, health = enemy[i][j]\n                    results[i] = attack, health\n    max_val = max(results.values())\n    for i in results:\n        if results[i] == max_val:\n            return i\n    return 'Oh no'\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    #m = 3\n    #print(m)\n    #print(stdin)\n    data = stdin.split()\n    #print(data)\n    #print(data[1])\n    print(\"Hello\")\n    #exit()\n    results = []\n    for i in range(m):\n        print(\"hello\")\n        a, b = map(int, data[i * 2:i * 2 + 2])\n        #print(a)\n        #print(b)\n        if(a == 1):\n            h = b\n        elif(b == 1):\n            h = a\n        else:\n            h = a + b\n        results.append(h)\n    print(\"hello\")\n    #exit()\n    #print(results)\n    maximum = -1\n    #print(\"hello\")\n    for i in results:\n        if(maximum < i):\n            maximum = i\n    print(maximum)\n    return maximum\n\nsolution(\"Hello\")\nsolution(\"\")\nsolution(\"Hello World\")\nsolution(\"Hello World Hello World\")\nsolution(\"1 2\")\nsolution(\"2 2\")\nsolution(\"1 2 1 2\")\nsolution(\"2 3 1 2\")\nsolution(\"1 3\")\nsolution(\"3 2\")\nsolution(\"1 3 1 2\")\nsolution(\"2 3 1 2\")\nsolution(\"\")\nsolution(\"1\")\nsolution(\"2\")\nsolution(\"3\")\nsolution(\"1 2\")\nsolution(\"2 3\")\nsolution(\"3 2\")\nsolution(\"2 3\")\nsolution(\"3\")\nsolution(\"3\")\nsolution(\"3\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\nsolution(\"\")\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, = list(map(int, stdin.split()))\n    paths = {}\n\n    def enemies(a, b):\n        return paths.get((a, b), None)\n\n    def add_enemy(a, b, attack_points, health_points):\n        paths[a, b] = (attack_points, health_points)\n\n    for _ in range(m):\n        a, b, attack_points, health_points = list(map(int, stdin.split()))\n        add_enemy(a, b, attack_points, health_points)\n\n    dp = {(1, 1): (n, 0)}\n\n    def recurse_for_a_b(a, b):\n        if (a, b) not in dp:\n            return dp[(a, b)]\n        attack_points, health_points = paths.get((a, b), (0, 0))\n        attack_points_remaining = attack_points - dp[(a, b)][1]\n        health_points_remaining = health_points - dp[(a, b)][1]\n        if attack_points_remaining <= 0 or health_points_remaining <= 0:\n            return dp[(a, b)]\n        max_health_at_a = min(dp[(a, b)][1], health_points)\n        max_health_at_b = min(dp[(a, b)][1], health_points)\n        if a == b:\n            max_health_at_a = min(max_health_at_a, health_points_remaining)\n        else:\n            max_health_at_a = min(max_health_at_a, attack_points_remaining)\n        if (a + 1, b) in dp:\n            dp[(a + 1, b)] = (dp[(a, b)][0], max_health_at_a)\n        else:\n            dp[(a + 1, b)] = (max_health_at_a, dp[(a, b)][0])\n        if (a, b + 1) in dp:\n            dp[(a, b + 1)] = (dp[(a, b)][0], max_health_at_b)\n        else:\n            dp[(a, b + 1)] = (max_health_at_b, dp[(a, b)][0])\n        return dp[(a, b)]\n\n    for a in range(1, n + 1):\n        for b in range(1, n + 1):\n            dp[(a, b)] = recurse_for_a_b(a, b)\n    return dp[(1, 1)][0]\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, H = list(map(int, stdin.split()))\n    n, m = list(map(int, stdin.split()))\n\n    paths = []\n    for _ in range(m):\n        paths.append(list(map(int, stdin.split())))\n\n    health = []\n    for i in range(n):\n        health.append([A, H])\n    for i in paths:\n        health[i[0] - 1][0] -= i[1]\n        health[i[0] - 1][1] -= i[2]\n        health[i[1] - 1][0] += i[1]\n        health[i[1] - 1][1] += i[2]\n\n    cnt = 0\n    for i in range(len(health)):\n        if health[i][1] > 0:\n            cnt = max(cnt, health[i][1])\n    return 'Oh no' if cnt == A else str(cnt)\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split())\n    passages = [[int(i) for i in stdin.split()] for stdin in stdin.split('\\n')]\n    visited = {1}\n    while len(visited) < A:\n        visited |= set(\n            [\n                k\n                for k, v in passages\n                if k not in visited\n                and sum([v for i, v in passages if i == k]) > 1\n            ]\n        )\n    return''.join([str(i) for i in sorted(visited)])\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = (int(i) for i in stdin.split())\n    cave = [(1, 1)]\n    for i in range(1, n):\n        cave.append((i, 0))\n    for i in range(1, m):\n        a, b = (int(i) for i in stdin.split())\n        cave.append((a, b))\n    for (a, b), (c, d) in zip(cave, cave[1:] + cave[:1]):\n        if c == b:\n            cave[a] = (c, d+1)\n    print(cave)\n    return ('' if len(cave) > 0 and cave[0][1] == 0 else 'Oh no')"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # parse stdin and set up variables\n    n, m = [int(x) for x in stdin.split()]\n    passages = [tuple(int(x) for x in stdin.split()) for _ in range(m)]\n    # set up variables for winning game\n    unar_health = n\n    enemy_health = m\n    # create a set with all the unar_health\n    unar_health_set = set(range(1, unar_health+1))\n    # create a set with all the enemy_health\n    enemy_health_set = set(range(1, enemy_health+1))\n    # loop through all the passages\n    for passage in passages:\n        # set up the opponents health\n        opponent_health = unar_health - passage[1]\n        # if the opponents health is less than 1 we can't win, so set winning game to False\n        if opponent_health < 1:\n            return 'Oh no'\n        # if the opponents health is greater than the unar_health we can't win, so set winning game to False\n        elif opponent_health > unar_health:\n            return 'Oh no'\n        # if the opponents health is equal to the unar_health we can win, so set winning game to True\n        elif opponent_health == unar_health:\n            return str(unar_health)\n        # if the unar_health is less than the enemies health we can't win, so set winning game to False\n        elif unar_health < passage[0]:\n            return 'Oh no'\n        # if the unar_health is greater than the enemies health we can't win, so set winning game to False\n        elif unar_health > passage[0]:\n            return 'Oh no'\n        # if the unar_health is equal to the enemies health we can win, so set winning game to True\n        elif unar_health == passage[0]:\n            return str(passage[0])"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, H = list(map(int, stdin.split()))\n    n, m = list(map(int, stdin.split()))\n    data = [[] for _ in range(n)]\n    for i in range(m):\n        data[int(stdin.split()[2 * i]) - 1].append((int(stdin.split()[2 * i + 1]), int(stdin.split()[2 * i + 2])))\n    # print(data)\n    for i in range(1, n):\n        a = set()\n        b = set()\n        for j in range(len(data[i])):\n            if data[i][j][0] > A:\n                a.add(j)\n            elif data[i][j][0] == A:\n                a.add(j)\n            else:\n                b.add(j)\n        # print(a, b)\n        if len(a) > len(b):\n            H = H - len(a)\n        elif len(a) < len(b):\n            H = H - len(b)\n        else:\n            H = H - len(a)\n    if H <= 0:\n        return \"Oh no\"\n    return H\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan(n1, m1, n2, m2):\n        return abs(n1 - n2) + abs(m1 - m2)\n\n    A, H = map(int, stdin.strip().split())\n    n, m = map(int, stdin.strip().split())\n    e, b, a, h = [list(map(int, stdin.strip().split())) for i in range(m)]\n\n    h = H\n    e = 1\n    while True:\n        for i in range(m):\n            h -= a[i]\n            if h <= 0:\n                return 'Oh no'\n        b.sort()\n        e += 1\n        for i in range(m):\n            h += b[i]\n            if h > H:\n                return 'Oh no'\n        b.sort(reverse=True)\n        for i in range(m):\n            h -= a[i]\n            if h <= 0:\n                return 'Oh no'\n        b.sort(reverse=True)\n        e += 1\n"
    },
    {
        "number": 3121,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, h, A, H, m = list(map(int, stdin.split()))\n    data = [list(map(int, stdin.split())) for _ in range(m)]\n    dp = [[0] * (H + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(H + 1):\n            if i == 1:\n                dp[i][j] = j\n            else:\n                if data[i - 1][0] <= j:\n                    dp[i][j] = max(dp[i - 1][j - data[i - 1][0]] + data[i - 1][1], dp[i - 1][j])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n    return 'Oh no' if dp[n][H] < A else str(dp[n][H] - A)\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # return 'impossible'\n    n, m = map(int, stdin.split())\n    # n = 4\n    # m = 4\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        # print(_)\n        a, b, c = map(int, stdin.split())\n        # a = 1\n        # b = 2\n        # c = 1\n        # print(a, b, c)\n        graph[a - 1].append((b - 1, c))\n        graph[b - 1].append((a - 1, c))\n\n    def dfs(i: int, seen: dict, curr: dict):\n        # print(i, seen, curr)\n        if i in seen:\n            return seen[i]\n        ans = 0\n        if i in curr:\n            ans += 1\n            for j in curr[i]:\n                ans += dfs(j, seen, curr)\n        seen[i] = ans\n        return ans\n\n    def dfs2(i: int, seen: dict, curr: dict):\n        # print(i, seen, curr)\n        if i in seen:\n            return seen[i]\n        ans = 0\n        if i in curr:\n            for j in curr[i]:\n                if j not in seen:\n                    ans += 1\n        seen[i] = ans\n        return ans\n\n    ans = 0\n    for i in range(n):\n        seen = {}\n        curr = {}\n        ans += dfs(i, seen, curr)\n    seen = {}\n    curr = {}\n    ans += dfs2(n - 1, seen, curr)\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    airports = list(map(int, stdin.strip().split()))\n    assert airports[0] == airports[1]\n    routes = [list(map(int, stdin.strip().split()))[1:] for _ in range(airports[0])]\n    n, m = airports[0], airports[1]\n    if n == 1:\n        return str(n)\n\n    # return str(getMinLounges(n, m, routes))\n    return str(getMinLounges_dp(n, m, routes))\n\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    n, m = int(inputs[0]), int(inputs[1])\n    requests = list()\n    for i in range(m):\n        requests.append([int(inputs[i*3+1]), int(inputs[i*3+2]), int(inputs[i*3+3])])\n    c = 1\n    k = 0\n    while k < n:\n        if (requests[k][1]-1) == (requests[k][2]-1) or (requests[k][2]-1) == (requests[k][1]-1):\n            c = 1\n            break\n        k += 1\n    return str(c)\n    \n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = [[int(i) for i in input().split()] for j in range(m)]\n    if n >= 3:\n        for i in routes:\n            if i[0]!= i[1] and i[0]!= i[2] and i[1]!= i[2]:\n                return \"impossible\"\n    if n == 3:\n        if any(i == 3 for i in routes) or any(i == 2 for i in routes):\n            return \"impossible\"\n    if n == 2:\n        if any(i == 3 for i in routes) or any(i == 2 for i in routes):\n            return \"impossible\"\n    if n == 1:\n        if any(i == 3 for i in routes) or any(i == 2 for i in routes) or any(i == 1 for i in routes):\n            return \"impossible\"\n    for i in routes:\n        if i[0]!= i[1] and i[0]!= i[2]:\n            return \"impossible\"\n    if any(i == 2 for i in routes):\n        return \"impossible\"\n    return str(len(set.intersection(*map(set, routes))))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Time: O(n*m*l)\n    Space: O(n*m)\n    '''\n    n, m = map(int, stdin.split())\n    airport_freq = defaultdict(int)\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        airport_freq[a] += c\n        airport_freq[b] += c\n    airport_freq = list(airport_freq.items())\n    airport_freq.sort(key=lambda x: x[1], reverse=True)\n    airport_freq = {i:j for i, j in airport_freq if j > 0}\n    total = 0\n    while airport_freq:\n        a, c = airport_freq.popitem()\n        total += c\n        a1 = a\n        a2 = a\n        while a1!= a2:\n            if a1 > a2:\n                a2 += 1\n            elif a1 < a2:\n                a1 += 1\n            else:\n                break\n        if a1 == a2:\n            if c == 1:\n                a2 -= 1\n                c -= 1\n            if c == 2:\n                a1 -= 1\n                c -= 2\n            if c == 3:\n                a2 -= 1\n                a1 -= 1\n                c -= 3\n            if a1 == a2:\n                total += c\n            else:\n                total += 2\n                if a1 < a2:\n                    a2 -= 1\n                else:\n                    a1 -= 1\n                a2 += 1\n                while a1!= a2:\n                    if a1 > a2:\n                        a2 += 1\n                    elif a1 < a2:\n                        a1 += 1\n                    else:\n                        break\n                total += c\n                a1, a2 = min(a1, a2), max(a1, a2)\n                if c == 2:\n                    total += 2\n                if c == 3:\n                    total += 1\n        else:\n            total += c\n    return total if total > 0 else 'impossible'\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    airports, routes = stdin.split(\"\\n\")\n    airports = [int(airport) for airport in airports.split()]\n    routes = [int(route) for route in routes.split()]\n    dp = [[float('inf')]*3 for _ in range(len(airports))]\n    dp[0][0] = 0\n    for route in routes:\n        dp[route[0]-1][0] = 0\n        dp[route[0]-1][1] = route[2]\n        dp[route[1]-1][2] = 0\n        dp[route[1]-1][1] = 0\n    for i in range(len(airports)):\n        for j in range(3):\n            if dp[i][j] < float('inf'):\n                dp[i][j] = min(dp[i][j], dp[i][j+1]+dp[i][j+2]+1)\n    ans = min(dp[i][j] for i in range(len(airports)) for j in range(3))\n    return str(ans) if ans!= float('inf') else \"impossible\"\nprint(solution(input()))\n\n'''\n\nfrom collections import deque\n\nairports, routes = input().split()\nairports = [int(airport) for airport in airports.split()]\nroutes = [int(route) for route in routes.split()]\ndp = [[float('inf')]*3 for _ in range(len(airports))]\ndp[0][0] = 0\nfor route in routes:\n    dp[route[0]-1][0] = 0\n    dp[route[0]-1][1] = route[2]\n    dp[route[1]-1][2] = 0\n    dp[route[1]-1][1] = 0\n\nfor i in range(len(airports)):\n    for j in range(3):\n        if dp[i][j] < float('inf'):\n            dp[i][j] = min(dp[i][j], dp[i][j+1]+dp[i][j+2]+1)\nans = min(dp[i][j] for i in range(len(airports)) for j in range(3))\nprint(ans)"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    reqs = {}\n    for _ in range(m):\n        a, b, c = map(int, stdin.strip().split())\n        reqs[(a, b)] = reqs.get((a, b), set()) | {c}\n        reqs[(b, a)] = reqs.get((b, a), set()) | {c}\n    possible = True\n    for a, b in reqs.keys():\n        if a == b:\n            if a == 1:\n                possible = False\n                break\n            elif a == 2:\n                possible = False\n                break\n            else:\n                possible = False\n                break\n        elif a!= b:\n            if (a, b) not in reqs:\n                possible = False\n                break\n            if a == 1:\n                if b == 2:\n                    possible = False\n                    break\n                else:\n                    possible = False\n                    break\n            elif a == 2:\n                if b == 1:\n                    possible = False\n                    break\n                else:\n                    possible = False\n                    break\n            else:\n                if a == 1:\n                    if b == 2:\n                        possible = False\n                        break\n                    else:\n                        possible = False\n                        break\n                elif b == 1:\n                    if a == 2:\n                        possible = False\n                        break\n                    else:\n                        possible = False\n                        break\n    if possible:\n        print(len(reqs))\n    else:\n        print(\"impossible\")\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3122,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # solution 1\n    # import sys\n    # import io\n    # sys.stdin = io.StringIO(stdin)\n    # n, m = map(int, input().split())\n    # routes = list(map(lambda x: map(int, input().split()), range(m)))\n    # l = len(routes)\n    # seen = set()\n    # # print(l)\n    # # print(routes)\n    # for i in range(l):\n    #     if routes[i][0] == routes[i][1]:\n    #         if routes[i][0] == routes[i][2]:\n    #             if routes[i][0] == 1:\n    #                 if routes[i][1] == 1:\n    #                     if routes[i][2] == 1:\n    #                         return str(routes[i][0])\n    #         if routes[i][0] == routes[i][2]:\n    #             if routes[i][0] == 1:\n    #                 if routes[i][1] == 1:\n    #                     if routes[i][2] == 1:\n    #                         return \"impossible\"\n    #         if routes[i][0] == 1 and routes[i][1] == 1 and routes[i][2] == 1:\n    #             return \"impossible\"\n    #     if (routes[i][0], routes[i][1]) not in seen:\n    #         seen.add((routes[i][0], routes[i][1]))\n    #         seen.add((routes[i][0], routes[i][2]))\n    #         seen.add((routes[i][1], routes[i][2]))\n    #\n    #\n    # if n == 1:\n    #     return str(1)\n    # if n == 2:\n    #     if routes[0][1] == 1:\n    #         if routes[0][2] == 1:\n    #             return \"impossible\"\n    #         else:\n    #             return str(1)\n    #     else:\n    #         if routes[0][2] == 1:\n    #             return str(1)\n    #         else:\n    #             return \"impossible\"\n    #\n    # routes.sort()\n    #\n    # n_airports = n\n    # routes = routes\n    # if routes[0][0]!= routes[0][1] and routes[0][1]!= routes[0][2] and routes[0][0]!= routes[0][2] and routes[0][1]!= routes[0][2]:\n    #     if routes[0][0] == 1:\n    #         if routes[0][1] == 1:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #         else:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #     else:\n    #         if routes[0][1] == 1:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #         else:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    # if routes[0][0] == routes[0][1]:\n    #     if routes[0][0] == routes[0][2]:\n    #         if routes[0][0] == 1:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #         else:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #     else:\n    #         if routes[0][0] == 1:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #         else:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #\n    # routes.sort(key=lambda x: (x[0], x[1]))\n    #\n    # if routes[0][0] == routes[0][1] and routes[0][0]!= routes[0][2]:\n    #     if routes[0][0] == 1:\n    #         if routes[0][1] == 1:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #         else:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #     else:\n    #         if routes[0][1] == 1:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    #         else:\n    #             if routes[0][2] == 1:\n    #                 return str(1)\n    # if routes[0][0] == routes[0][1]:\n    #     if routes[0][0] == routes[0][2]:\n    #         if routes[0][0] == 1:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #         else:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #     else:\n    #         if routes[0][0] == 1:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #         else:\n    #             if routes[0][1] == 1:\n    #                 if routes[0][2] == 1:\n    #                     return str(1)\n    #\n    # routes.sort(key=lambda x: (x[1], x[0]))\n    # if routes[0][0] == routes[0][1] and routes[0][0]!= routes[0][2]:\n    #     if routes[0][0] == 1:\n    #         if routes[0][1] == 1"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return max(\n        solution(stdin.replace(' ', '')) if stdin else 'no',\n        max(\n            solution(stdin.replace(' ', '')) if stdin else 'no',\n            solution(stdin.replace(' ', '')) if stdin else 'no',\n            solution(stdin.replace(' ', '')) if stdin else 'no',\n            solution(stdin.replace(' ', '')) if stdin else 'no',\n            solution(stdin.replace(' ', '')) if stdin else 'no'\n        )\n    )\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    n_list = list(map(int, stdin.split()[1:]))\n    max_level = 0\n    max_nested_level = 0\n    for level, nested_level in enumerate(n_list):\n        nested_level_str = str(nested_level)\n        if level == 0:\n            if nested_level_str!= '0':\n                return 'no quotation'\n            else:\n                max_level = 1\n                max_nested_level = 1\n        else:\n            if nested_level_str == '0':\n                max_level = max(max_level, level + 1)\n                max_nested_level = max(max_nested_level, level + 1)\n            elif nested_level_str[0]!= '0':\n                max_level = max(max_level, level + 1)\n                max_nested_level = max(max_nested_level, level + 1)\n            elif nested_level_str!= '0' and nested_level_str!= '1':\n                max_level = max(max_level, level + 1)\n                max_nested_level = max(max_nested_level, level + 1)\n    return '%s %s' % (max_level, max_nested_level)\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(max(len(s) for s in stdin.splitlines()) - 1)\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = stdin.readline().strip().split()\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = int(a[i - 1])\n    if n == 1:\n        return 'No'\n    a = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    k = 0\n    l = 0\n    while k < n and l <= k:\n        k += a[l][1]\n        l += 1\n    return str(l) if k == n else 'No'\n\n\nsolution(input())\n\nSample Input 2:\n2\n3\n6\nSample Output 2:\n1\n4"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_k = 0\n    for k in range(1, n+1):\n        cnt = 0\n        for char in stdin:\n            if char =='':\n                if cnt > max_k:\n                    max_k = cnt\n            elif char == ')':\n                cnt -= 1\n            elif char == '(':\n                cnt += 1\n            else:\n                cnt += 1\n    if max_k == 0:\n        return 'no'\n    else:\n        return str(max_k)\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, num_quotes = stdin.split()\n    return 'No quotation' if num_quotes < 2 else num_quotes\n\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    level = {}\n    \n    def helper(level, s):\n        k = len(s)\n        if k in level:\n            return level[k]\n        level[k] = 1\n        for i in range(1, k+1):\n            if s[:i] == '\"' * i:\n                level[k] = max(helper(level, s[i:])+1, level[k])\n            elif s[-i:] == '\"' * i:\n                level[k] = max(helper(level, s[:-i])+1, level[k])\n            else:\n                level[k] = max(helper(level, s[:i]+s[i+1:])+1, level[k])\n        return level[k]\n    \n    return str(helper(level, stdin))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    quotes = stdin.split()\n    quotes.pop(0)\n    k = 1\n    while k < len(quotes):\n        if k >= 2:\n            if quotes[k-1] =='':\n                k += 1\n        if k >= 3:\n            if quotes[k-2] =='':\n                k += 1\n        k += 1\n    if k == 1:\n        return None\n    return str(k-1)\n"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    output = 0\n    while n > 0:\n        x = int(input())\n        if x > output:\n            output = x\n        n -= 1\n    return str(output)\n\nprint(solution(input()))\n\nstdin = input()\nn = int(stdin)\n\nk = 0\noutput = 0\n\nwhile n > 0:\n    x = int(input())\n    if x > output:\n        output = x\n        k = 1\n    elif x == output:\n        k += 1\n    n -= 1\n\nprint(k)"
    },
    {
        "number": 3123,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = sorted(list(map(int, stdin.split())))\n    a.insert(0, 0)\n    n_min = max(a)\n    res = 0\n    while n_min - 1 > a[res]:\n        res += 1\n    return str(res)"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split('\\n')\n    N = int(inputs[0])\n    numbers = inputs[1]\n    numbers = numbers.split(' ')\n    numbers = set(map(int, numbers))\n    moves = 0\n    while True:\n        numbers = set(map(lambda n: n + 1, numbers))\n        numbers = set(map(lambda n: n - 1, numbers))\n        numbers = set(map(lambda n: n - 2, numbers))\n        numbers = set(map(lambda n: n - 3, numbers))\n        numbers = set(map(lambda n: n - 4, numbers))\n        numbers = set(map(lambda n: n - 5, numbers))\n        if len(numbers) == 1:\n            break\n        moves += 1\n    print(moves)\n    return moves\n"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    count = 0\n    for i in range(1, n):\n        if s[i - 1] > s[i]:\n            count += 1\n    print(count)\n    return"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def go(pos, odd):\n        if pos == N - 1:\n            if odd % 2 == 1:\n                return 1\n            else:\n                return 0\n\n        res = 0\n        for i in range(N):\n            if odd == 0:\n                res += go(pos + 1, odd + i + 1)\n            elif odd == 1:\n                res += go(pos + 1, odd - i + 1)\n\n        return res\n\n    N = int(stdin)\n    odd = 0\n    for i in stdin.split():\n        odd += 1 if int(i) % 2 == 1 else 0\n\n    return str(go(0, odd))"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    result = {}\n    for i in stdin.split(' '):\n        if i in result:\n            result[i] += 1\n        else:\n            result[i] = 1\n    return max(result, key=result.get)\n"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin.pop(0))\n    c = stdin.pop(0)\n    c = c.split()\n    c = sorted(c)\n    n = len(c)\n    c = [int(x) for x in c]\n    c = {i: (x, y) for i, (x, y) in enumerate(zip(c, c))}\n    s = n + 1\n    cnt = 0\n    while s > 0:\n        if cnt % 2 == 0:\n            s -= 1\n            a, b = c[s]\n            c[s] = (b, a)\n        else:\n            s -= 2\n            a, b = c[s]\n            c[s] = (a, b)\n        cnt += 1\n    cnt = 0\n    while True:\n        for x, y in c.values():\n            if x % 2 == 1:\n                cnt += 1\n        if cnt == n - 1:\n            break\n        cnt = 0\n    print(cnt)\n    return cnt\n"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    odd = [int(i) for i in stdin.split()]\n    odd = sorted(odd)\n    count = 1\n    idx = 0\n    while odd:\n        if odd[idx]%2 == 1:\n            if idx == 0:\n                odd.pop(0)\n            else:\n                odd.pop(idx)\n            idx -= 1\n        else:\n            count += 1\n            idx += 1\n    return str(count)"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N = int(stdin.split(\" \")[0])\n    numbers = stdin.split(\" \")[1:]\n    count = 0\n    for i in range(0, N):\n        for j in range(0, N):\n            if i!= j:\n                if numbers[i] % 2!= 0 and numbers[j] % 2!= 0:\n                    if numbers[i] > numbers[j]:\n                        count += 1\n    return str(count)\n    # your code here"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    for i in stdin.split('\\n'):\n        if len(i) == 1:\n            return i\n"
    },
    {
        "number": 3124,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    result = None\n    n, *data = stdin.split()\n    data = list(map(int, data))\n    result = 0\n    prev = data[0]\n    for x in data:\n        if x % 2 == 0 and prev % 2 == 0:\n            result += 1\n        prev = x\n    return str(result)\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For each string in stdin, determine the number of characters of each encoding, and if it is possible to get all of the strings together.\n    \"\"\"\n    I = stdin.strip()\n    I = I.replace('+', '+\\x00')\n    I = I.replace('-', '-\\x00')\n    I = I.replace(' ', '+\\x00')\n    I = I.replace('\"', '+\\x00')\n    I = I.replace('&', '+\\x00')\n    I = I.replace('/', '-\\x00')\n    I = I.replace('|', '|\\x00')\n    I = I.replace('\\\\', '\\x00')\n    I = I.replace('(', '\\x00')\n    I = I.replace(')', '\\x00')\n    I = I.replace('{', '\\x00')\n    I = I.replace('}', '\\x00')\n    I = I.replace('[', '\\x00')\n    I = I.replace(']', '\\x00')\n    I = I.replace('{', '\\x00')\n    I = I.replace('}', '\\x00')\n    I = I.replace('\\'', '\\x00')\n    I = I.replace(';', ';\\x00')\n    I = I.replace(':', ':\\x00')\n    I = I.replace('(', '\\x00')\n    I = I.replace(')', '\\x00')\n    I = I.replace('<', '\\x00')\n    I = I.replace('>', '\\x00')\n    I = I.replace('!', '\\x00')\n    I = I.replace('?', '\\x00')\n    I = I.replace(',', '\\x00')\n    I = I.replace('.', '\\x00')\n    I = I.replace('\\x00','')\n    I = I.replace('+', '+ ')\n    I = I.replace('-', '- ')\n    I = I.replace('&', '& ')\n    I = I.replace('/', '- ')\n    I = I.replace('|', '| ')\n    I = I.replace('\\\\', '- ')\n    I = I.replace('(', '(')\n    I = I.replace(')', ')')\n    I = I.replace('{', '{')\n    I = I.replace('}', '}')\n    I = I.replace('[', '[')\n    I = I.replace(']', ']')\n    I = I.replace('{', '{')\n    I = I.replace('}', '}')\n    I = I.replace('\\'', '\\'')\n    I = I.replace(';', ';')\n    I = I.replace(':', ':')\n    I = I.replace('(', '(')\n    I = I.replace(')', ')')\n    I = I.replace('<', '<')\n    I = I.replace('>', '>')\n    I = I.replace('!', '!')\n    I = I.replace('?', '?')\n    I = I.replace(',', ',')\n    I = I.replace('.', '.')\n\n    I_list = I.split(' ')\n    I_list = I_list[:-1]\n    I_list = [x for x in I_list]\n\n    str_encoding_dictionary = {\n        '+': 0,\n        '-': 0,\n       '': 0\n    }\n    str_encoding_dictionary_reversed = {\n        0: '+',\n        1: '-',\n        2:''\n    }\n\n    for i in I_list:\n        if str_encoding_dictionary[i] == 2:\n            str_encoding_dictionary[i] = 2\n        else:\n            str_encoding_dictionary[i] += 1\n\n    for key in str_encoding_dictionary.keys():\n        if str_encoding_dictionary[key] == 2:\n            str_encoding_dictionary[key] = 2\n        else:\n            str_encoding_dictionary[key] = 0\n\n    I_list = []\n    for i in I_list:\n        if str_encoding_dictionary[i] == 2:\n            I_list.append(i)\n\n    I_list = I_list[:-1]\n    I_list = [x for x in I_list]\n\n    I_list_encoded = []\n    for i in I_list:\n        I_list_encoded.append(str_encoding_dictionary_reversed[str_encoding_dictionary[i]])\n\n    if len(I_list_encoded) == 0:\n        I_list_encoded = '<empty>'\n    else:\n        I_list_encoded = ''.join(I_list_encoded)\n\n    return I_list_encoded\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given a string $stdin$ consisting of characters a, b, c, and d, determine the number of different encodings of the string $stdin$ in which a + b - c = d.\n    \"\"\"\n    return stdin"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin\n    output_list = []\n\n    # TODO - write your code here\n    return '\\n'.join(output_list)\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes in a string representing the string $I$ and $O$, and the strings for $a^{+}_ i$ and $a^{-}_ i$.\n\n    The function should return the string representing the encoded string $a^{+}_ i$ and $a^{-}_ i$.\n\n    >>> solution('a+b-c', 'a-b+d-c', '- +d-')\n    'a+b+d-'\n    >>> solution('a+b-c', 'a-b+d-c', '-')\n    'a-b+d+-'\n    >>> solution('a+b-c', 'a-b+d-c', '-')\n    'a+b+d-c'\n    >>> solution('a+b-c', 'a-b+d-c', '')\n    'a-b+d-c'\n    >>> solution('', '', '')\n    '<empty>'\n    >>> solution('', 'a', 'a')\n    '<any>'\n    \"\"\"\n    string = stdin.splitlines()\n    dictionary = {string[0]: string[1]}\n    try:\n        for a in range(len(string) - 1):\n            if string[a] in dictionary:\n                dictionary[string[a + 1]] = dictionary[string[a]] + string[a + 1]\n            else:\n                dictionary[string[a + 1]] = string[a + 1]\n    except IndexError:\n        return dictionary['']\n    return dictionary['']\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    output = []\n    if input[0] == '':\n        output.append(\"<empty>\")\n    else:\n        output.append(\"<any>\")\n    if input[1] == '':\n        output.append(\"<empty>\")\n    else:\n        output.append(\"<any>\")\n    for i in range(len(input)):\n        if input[i] == '':\n            output.append(\"<empty>\")\n        else:\n            output.append(\"<any>\")\n    return \"\\n\".join(output)\n\nstdin = \"\"\"knuthmorrispratt\nknuth-morris-pratt\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"knuthmorrispratt\nknoithmorrisprat\n\"\"\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.replace('+', '-').replace('-', '+')"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin if not stdin else stdin.replace('+', '-').replace('-', '+').replace(' ', '-').replace('\"', '').replace(\"'\", '')\n"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    for string in stdin.split('\\n'):\n        # parse the string into a list of symbols\n        # 1.split() will return a list of spaces or newlines\n        symbols = list(string.split())\n\n        # if there are any symbols left\n        if len(symbols) > 0:\n            for i in range(1, len(symbols)):\n                # if the front symbol is not +\n                if symbols[0]!= '+':\n                    # if the front symbol is -\n                    if symbols[0] == '-':\n                        # return <any>\n                        return '<any>'\n\n                    # check that the front + or - symbol is not in the rest of the string\n                    if symbols[0] in symbols[1:]:\n                        # return <empty>\n                        return '<empty>'\n                else:\n                    # if the front + or - symbol is in the rest of the string\n                    if symbols[0] not in symbols[1:]:\n                        # return <any>\n                        return '<any>'\n\n        # return <empty>\n        return '<empty>'\n\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Basic implementation of a solution for the daily contest.\n\n    Args:\n        stdin (str): input to read.\n\n    Returns:\n        str: The output.\n\n    \"\"\"\n    if not stdin:\n        return '<empty>'\n    if len(stdin) > 280:\n        return '<empty>'\n\n    return '- +d-\\n'\n    \n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = stdin.strip().split('\\n')\n    n, t, c = int(n), int(t), int(c)\n    data = []\n    for i in range(t):\n        data.append([*map(int, stdin.strip().split('\\n')[i * 2 + 1].split()), i])\n    return min(solution_rec(data, 0, 0, n), n)\n\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip().split()[2])\n    for _ in range(t):\n        stdin = stdin.strip().split('\\n')\n        if stdin[1].startswith('+'):\n            print(sum(i + 1 for i in range(int(stdin[2]) + 1)))\n        elif stdin[1].startswith('-'):\n            print(sum(i + 1 for i in range(int(stdin[2]) + 1)))\n        elif stdin[1].startswith('t'):\n            print(max(i + 1 for i in range(int(stdin[2]))))\n\n\nsolution(input())\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    towers = list(map(int, lines[1].split()))\n    changes = int(lines[2])\n    for _ in range(changes):\n        if lines[3] == \"+\":\n            towers.append(lines[4])\n        elif lines[3] == \"-\":\n            towers.remove(lines[4])\n        else:\n            towers = list(map(lambda x: x + int(lines[4]), towers))\n    return \" \".join(map(str, towers))\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, T = (int(i) for i in stdin.split())\n    frogs = [i for i in range(N)]\n    jumps = [0] * N\n    for i in range(T):\n        line = stdin.split()\n        if line[0] == 't':\n            frogs = [frogs[int(line[1])]] + frogs[:int(line[1])] + frogs[int(line[1]) + 1:]\n            jumps = [jumps[int(line[1])]] + jumps[:int(line[1])] + jumps[int(line[1]) + 1:]\n        elif line[0] == '+':\n            frogs = frogs + [frogs[-1]]\n            jumps = jumps + [jumps[-1]]\n        else:\n            frogs = frogs[:int(line[1])] + frogs[int(line[1]) + 1:]\n            jumps = jumps[:int(line[1])] + jumps[int(line[1]) + 1:]\n    return '\\n'.join(map(str, sorted(jumps)))"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    frogs, positions = stdin.splitlines()\n    frogs = list(map(int, frogs.split()))\n    positions = list(map(int, positions.split()))\n    n = len(frogs)\n    for command in range(int(positions[0])):\n        frogs.append(frogs[-1] + 1)\n    frogs.pop(0)\n    positions.pop(0)\n    for command in range(int(positions[0])):\n        frogs.append(frogs[-1] - 1)\n    frogs.pop(0)\n    positions.pop(0)\n    positions = list(map(lambda x: x - 1, positions))\n    t = int(positions[0])\n    positions.pop(0)\n    frogs = list(map(lambda x: x + t, frogs))\n    return '\\n'.join(map(lambda x: str(x), sorted(frogs)))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_frogs, place = map(int, stdin.split())\n    frogs = list(map(int, stdin.split()))\n\n    jumps = 0\n    for place in frogs:\n        jumps += 1\n\n    return str(jumps)\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_frogs = int(stdin.split()[0])\n    frog_pos = list(map(int, stdin.split()[1].split(\" \")))\n\n    res_jumps = 0\n    frog_jumps = []\n\n    for _ in range(num_frogs):\n        frog_jumps.append(0)\n\n    frog_id = 0\n    prev_pos = 0\n\n    while True:\n        for frog_pos_id in range(1, len(frog_pos)):\n            if frog_pos[frog_pos_id - 1] >= prev_pos and frog_pos[frog_pos_id] < prev_pos:\n                frog_jumps[frog_id] += 1\n                prev_pos = frog_pos[frog_pos_id - 1]\n                frog_id += 1\n                break\n        else:\n            if frog_pos[-1] == prev_pos:\n                break\n            else:\n                frog_jumps[frog_id] += 1\n                prev_pos = frog_pos[-1]\n                frog_id += 1\n\n    frog_jumps = sorted(frog_jumps)\n    for frog_id in range(num_frogs):\n        res_jumps += frog_jumps[frog_id]\n\n    return str(res_jumps)\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    frogs = stdin.split()[1:]\n    \n    def update(frogs, frog):\n        i = 0\n        while i < len(frogs):\n            if frogs[i] == frog:\n                frogs = frogs[:i] + frogs[i+1:]\n            i += 1\n        return frogs\n        \n    def get_len(frogs, frog):\n        if len(frogs) == 0:\n            return 0\n        return len(frogs)\n    \n    def get_tower(frogs):\n        return frogs[-1]\n    \n    def search(frogs, index, p):\n        if index < len(frogs):\n            if index == len(frogs) - 1:\n                if get_len(frogs, p) >= get_len(frogs, get_tower(frogs)):\n                    return get_len(frogs, p)\n                else:\n                    return get_len(frogs, get_tower(frogs))\n            elif index == 0:\n                return 0\n            else:\n                if get_len(frogs, p) >= get_len(frogs, get_tower(frogs)):\n                    return search(frogs, index + 1, p)\n                else:\n                    return search(frogs, index - 1, p)\n        else:\n            return 0\n    \n    for c in range(t):\n        if get_tower(frogs) == frogs[0]:\n            frogs = update(frogs, frogs[0])\n        elif get_tower(frogs) == frogs[-1]:\n            frogs = update(frogs, frogs[-1])\n        else:\n            new_index = search(frogs, 0, frogs[0])\n            if get_len(frogs, frogs[0]) < get_len(frogs, frogs[new_index]):\n                frogs = update(frogs, frogs[0])\n            else:\n                frogs = update(frogs, frogs[new_index])\n    return frogs\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = stdin.split()\n    N = int(N)\n    M = int(M)\n    K = int(K)\n    A = list(map(int, stdin.split()))\n    s = 0\n    for i in range(M):\n        if A[i] == 0:\n            A[i] = N\n            N += 1\n        elif A[i] == N:\n            A[i] = 0\n            N -= 1\n    for i in range(M, N):\n        if A[i] == 0:\n            A[i] = N\n            N += 1\n        elif A[i] == N:\n            A[i] = 0\n            N -= 1\n    for i in range(N, M):\n        if A[i] == 0:\n            A[i] = N\n            N += 1\n        elif A[i] == N:\n            A[i] = 0\n            N -= 1\n    for i in range(K):\n        if A[i] == 0:\n            A[i] = N\n            N += 1\n        elif A[i] == N:\n            A[i] = 0\n            N -= 1\n    return N\n"
    },
    {
        "number": 3126,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = stdin.split('\\n')\n    n = int(n)\n    t = int(t)\n    c = int(c)\n\n    frogs = [[int(i)] for i in stdin.split('\\n')[1:]]\n    for _ in range(c):\n        change = stdin.split('\\n')[1:]\n        for i in change:\n            if '+' in i:\n                frogs[int(i.split()[1])-1].append(int(i.split()[2]))\n            elif '-' in i:\n                frogs[int(i.split()[1]) - 1].remove(int(i.split()[2]))\n            elif 't' in i:\n                frogs.insert(int(i.split()[1]) - 1, [i.split()[2]])\n\n    return str(sum([sum(frog) for frog in frogs]))\n\n\nprint(solution(input()))"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_net(size: int) -> int:\n        net = size ** 2\n        return net\n    # Create a set of pairs\n    def find_pairs(s: int, e: int, n: int) -> set:\n        pairs = set()\n        for x in range(s, e + 1):\n            if x == n:\n                continue\n            pairs.add((s, x))\n            pairs.add((x, e))\n        return pairs\n    # Find all pairs\n    def find_all_pairs(pairs: set, s: int, e: int) -> set:\n        all_pairs = set()\n        for pair in pairs:\n            if pair[0] <= s and e <= pair[1]:\n                all_pairs.add(pair)\n        return all_pairs\n    # Find all valid pairs\n    def find_valid_pairs(all_pairs: set, n: int) -> set:\n        valid_pairs = set()\n        for pair in all_pairs:\n            if pair[0] == 1:\n                continue\n            if pair[1] == n:\n                continue\n            valid_pairs.add(pair)\n        return valid_pairs\n    # Find all valid paths\n    def find_valid_paths(valid_pairs: set, n: int) -> set:\n        valid_paths = set()\n        for pair in valid_pairs:\n            if pair[0]!= pair[1] and pair[0] > 1 and pair[1] < n - 1:\n                valid_paths.add((pair[0], pair[1]))\n        return valid_paths\n    # Find all possible paths\n    def find_all_possible_paths(valid_paths: set, n: int) -> set:\n        all_paths = set()\n        for path in valid_paths:\n            p = find_pairs(path[0], path[1], n)\n            p = find_all_pairs(p, path[0], path[1])\n            p = find_valid_pairs(p, n)\n            p = find_valid_paths(p, n)\n            all_paths.add(p)\n        return all_paths\n    # Calculate total paths\n    def calculate_total_paths(all_paths: set) -> int:\n        path_count = 0\n        for path in all_paths:\n            path_count += get_net(max(path))\n        return path_count\n    # Calculate maximum paths\n    def calculate_maximum_paths(all_paths: set, size: int) -> int:\n        max_path_count = 0\n        for path in all_paths:\n            if len(path) == size:\n                max_path_count += 1\n        return max_path_count\n    # Calculate minimum path\n    def calculate_minimum_path(all_paths: set, size: int) -> int:\n        min_path_count = size ** 2\n        for path in all_paths:\n            if len(path) == size:\n                min_path_count = min(min_path_count, size * (path[0] - 1) + size * (path[1] - 1))\n        return min_path_count\n    # Find optimal paths\n    def find_optimal_paths(all_paths: set, size: int) -> int:\n        # print(all_paths)\n        # print(size)\n        # print(calculate_maximum_paths(all_paths, size))\n        # print(calculate_minimum_path(all_paths, size))\n        if size == 1:\n            return calculate_maximum_paths(all_paths, size)\n        return min(calculate_maximum_paths(all_paths, size), calculate_minimum_path(all_paths, size))\n    # Find optimal paths\n    def find_optimal_paths(all_paths: set, size: int) -> int:\n        # print(all_paths)\n        # print(size)\n        # print(calculate_maximum_paths(all_paths, size))\n        # print(calculate_minimum_path(all_paths, size))\n        if size == 1:\n            return calculate_maximum_paths(all_paths, size)\n        return min(calculate_maximum_paths(all_paths, size), calculate_minimum_path(all_paths, size))\n    # Find optimal paths\n    def find_optimal_paths(all_paths: set, size: int) -> int:\n        # print(all_paths)\n        # print(size)\n        # print(calculate_maximum_paths(all_paths, size))\n        # print(calculate_minimum_path(all_paths, size))\n        if size == 1:\n            return calculate_maximum_paths(all_paths, size)\n        return min(calculate_maximum_paths(all_paths, size), calculate_minimum_path(all_paths, size))\n    # Find optimal paths\n    def find_optimal_paths(all_paths: set, size: int) -> int:\n        # print(all_paths)\n        # print(size)\n        # print(calculate_maximum_paths(all_paths, size))\n        # print(calculate_minimum_path(all_paths, size))\n        if size == 1:\n            return calculate_maximum_paths(all_paths, size)\n        return min(calculate_maximum_paths(all_paths"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    given \n    1 2 2\n    1 3 1\n    1 4 3\n    2 6 1\n    2 7 2\n    3 5 1\n    4 7 2\n    5 7 1\n    return\n    0\n    '''\n    # your code here\n    \n    def distance(a,b):\n        return abs(a-b)\n    \n    n,m = list(map(int,stdin.split()))\n    \n    graph = []\n    for i in range(1,n+1):\n        graph.append([])\n        for j in range(1,n+1):\n            graph[i-1].append([])\n    \n    for i in range(m):\n        a,b,c = list(map(int,stdin.split()))\n        graph[a-1][b-1].append(c)\n        graph[b-1][a-1].append(c)\n    \n    \n    \n    used = []\n    for i in range(1,n+1):\n        used.append(False)\n    \n    \n    for i in range(1,n+1):\n        if used[i]:\n            continue\n        \n        def dfs(i,used,graph,dist):\n            dist[i] = 0\n            used[i] = True\n            for j in graph[i]:\n                if used[j] or dist[j]!= 0:\n                    continue\n                dfs(j,used,graph,dist)\n                dist[i] += dist[j]\n            used[i] = False\n            \n        \n        dfs(i,used,graph,dist)\n        \n    \n    \n    count = 0\n    for i in range(1,n+1):\n        if dist[i]!= 0 and used[i]:\n            count += 1\n    \n    \n    return str(count)\n"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin_to_ints(stdin)\n    cables = stdin_to_cables(stdin)\n    return str(cables_to_switches(cables, n)) + '\\n' + str(cables_to_unused_switches(cables, n))\n\ndef"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0].split()[0])\n    m = int(lines[0].split()[1])\n\n    for i in range(1, m + 1):\n        x, y, l = lines[i].split()\n        x, y, l = int(x), int(y), int(l)\n        if x == y:\n            return str(0)\n\n        if x >= 1 and x <= n and y >= 1 and y <= n:\n            if x == y or l == 0:\n                continue\n            else:\n                if l > n:\n                    continue\n                else:\n                    x_ = x\n                    y_ = y\n\n                    while y_!= x_:\n                        y_ = n\n\n                        if x_ >= 1 and x_ <= n:\n                            if x_ == y_:\n                                continue\n                            else:\n                                if x_ == y:\n                                    x_ += 1\n                                else:\n                                    x_ += 1\n                                    if x_ == y:\n                                        y_ -= 1\n                                    else:\n                                        y_ -= 1\n                                        if y_ == x_:\n                                            continue\n                                        else:\n                                            break\n                                    break\n                    return str(0)\n                    break\n"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def transform(num: int) -> tuple:\n        return int(str(num)[::-1])\n    #n, m = map(int, stdin.split())\n    #sw = set(range(1, n+1))\n    #cab = defaultdict(list)\n    #for a, b, c in map(transform, stdin.split()):\n        #cab[(a, b)].append(c)\n        #sw.discard(a)\n        #sw.discard(b)\n    #sw = sorted(list(sw))\n    #ans = []\n    #for a, b in cab:\n        #if a not in sw:\n            #ans.append(a)\n        #if b not in sw:\n            #ans.append(b)\n    #return len(ans)\n    n, m = map(int, stdin.split())\n    cab = defaultdict(list)\n    for a, b, c in map(int, stdin.split()):\n        cab[(a, b)].append(c)\n        cab[(b, a)].append(c)\n    sw = set(range(1, n+1))\n    sw = list(sw)\n    ans = []\n    for i in range(m):\n        inlist = False\n        for a in sw:\n            if cab[(a, sw[i])]:\n                ans.append(a)\n                inlist = True\n                break\n        if not inlist:\n            ans.append(sw[i])\n        sw[i] = sw[i]+1\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_invalid(node: int) -> bool:\n        return not 0 < node < max(nodes) + 1\n\n    n, m = map(int, stdin.split())\n    edges = [[] for _ in range(n + 1)]\n    nodes = set()\n    for i in range(1, n + 1):\n        edges[i] = []\n\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        edges[a].append((b, c))\n        nodes.update([a, b])\n        edges[b].append((a, c))\n        nodes.update([b, a])\n\n    max_nodes = max(nodes)\n    _nodes = {n: set() for n in range(max_nodes)}\n    _nodes[1] = nodes\n\n    def _dfs(node: int) -> None:\n        for nei, _ in edges[node]:\n            _nodes[node].add(nei)\n            _dfs(nei)\n            _nodes[node].remove(nei)\n\n    _dfs(1)\n    for i in range(2, max_nodes + 1):\n        if is_invalid(i):\n            continue\n        if len(_nodes[i]) == 0:\n            return str(i)\n    return '0'\n"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split('\\n')\n    n, m = (int(i) for i in stdin_list[0].split())\n    if n < 2 or m < 2:\n        return '0'\n    cables = []\n    for i in range(m):\n        a, b, c = (int(i) for i in stdin_list[i + 1].split())\n        cables.append((a, b, c))\n    switches = set()\n    for a, b, c in cables:\n        switches.update([a, b])\n        switches.update([a, c])\n        switches.update([b, a])\n        switches.update([b, c])\n        switches.update([c, a])\n        switches.update([c, b])\n    switches = sorted(switches)\n    result = []\n    for i in switches:\n        if i == 1:\n            result.append(1)\n        else:\n            result.append(i)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [[] for _ in range(n)]\n    for i in range(m):\n        a, b, l = map(int, stdin.split())\n        edges[a].append([b, l])\n        edges[b].append([a, l])\n\n    switches_to_check = set()\n    for i in range(1, n):\n        if i not in switches_to_check:\n            switches_to_check.add(i)\n            for j in range(1, n):\n                if i == j:\n                    continue\n                path_to_i = find_path(i, j, edges)\n                if path_to_i:\n                    switches_to_check.add(j)\n    switches_to_check = list(switches_to_check)\n    switches_to_check.sort()\n    return '\\n'.join([str(i) for i in switches_to_check])\n\n\ndef"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 7 8\n   ... 1 2 2\n   ... 1 3 1\n   ... 1 4 3\n   ... 2 6 1\n   ... 2 7 2\n   ... 3 5 1\n   ... 4 7 2\n   ... 5 7 1\n   ... ''')\n    2\n    \"\"\"\n    [n, m] = map(int, input().split())\n    graph = {}\n    for i in range(m):\n        a, b, l = map(int, input().split())\n        if a in graph:\n            graph[a].append([b, l])\n        else:\n            graph[a] = [[b, l]]\n        if b in graph:\n            graph[b].append([a, l])\n        else:\n            graph[b] = [[a, l]]\n\n    switches = set()\n    for i in graph:\n        switches.add(i)\n\n    switches = list(switches)\n    switches.sort()\n\n    result = 0\n    for i in switches:\n        if i == 0:\n            continue\n        switches_to_remove = []\n        for j in graph:\n            if i in graph[j]:\n                switches_to_remove.append(j)\n        switches_to_remove = set(switches_to_remove)\n        switches_to_remove = list(switches_to_remove)\n        switches_to_remove.sort()\n        for k in switches_to_remove:\n            graph.pop(k)\n        nodes_to_remove = []\n        for j in graph:\n            if j in switches_to_remove:\n                nodes_to_remove.append(j)\n        nodes_to_remove = set(nodes_to_remove)\n        nodes_to_remove = list(nodes_to_remove)\n        nodes_to_remove.sort()\n        for k in nodes_to_remove:\n            switches.remove(k)\n        nodes_to_remove = []\n        for j in graph:\n            if j == 0:\n                continue\n            if j in switches_to_remove:\n                nodes_to_remove.append(j)\n        nodes_to_remove = set(nodes_to_remove)\n        nodes_to_remove = list(nodes_to_remove)\n        nodes_to_remove.sort()\n        for k in nodes_to_remove:\n            switches.remove(k)\n        switches = list(switches)\n        switches.sort()\n        result += 1\n        if result >= n:\n            break\n    return str(result)\n"
    },
    {
        "number": 3127,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    cables = []\n    for _ in range(m):\n        a, b, l = list(map(int, stdin.split()))\n        cables.append((a, b, l))\n    cables.sort(key=lambda x: (x[2], x[0], x[1]))\n\n    def score(p: list) -> int:\n        ret = 0\n        for i in range(len(p) - 1):\n            if p[i]!= p[i + 1]:\n                ret += 1\n        return ret\n\n    start = 1\n    used_nodes = set()\n    for c in cables:\n        start_node = c[0]\n        end_node = c[1]\n        if start_node not in used_nodes and end_node not in used_nodes:\n            used_nodes.add(start_node)\n            used_nodes.add(end_node)\n            if start == end_node:\n                print(score(used_nodes))\n                return\n            start += 1\n            used_nodes.remove(start_node)\n            used_nodes.remove(end_node)\n            used_nodes.add(end_node)\n\n    print(0)\n    return\n\n\nsolution(input())\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    order = [i + 1 for i in range(n + 1)]\n    for _ in range(int(stdin)):\n        command, *args = stdin.split()\n        if command == \"1\":\n            order[args[0]] = args[1]\n        else:\n            print(order.index(args[0]) + 1)\n    return stdin\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    input_list = stdin.split(\"\\n\")\n    result = []\n    total_movies = int(input_list[0])\n    for i in range(1, total_movies + 1):\n        result.append(i)\n    for movie in input_list[1:]:\n        movie_input = movie.split(\" \")\n        if movie_input[0] == \"1\":\n            for idx, val in enumerate(result):\n                if val == int(movie_input[1]):\n                    result.pop(idx)\n                    result.append(idx)\n        else:\n            result.sort()\n            print(result[int(movie_input[1]) - 1])\n    return \" \".join(map(str, result))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [[] for _ in range(n+1)]\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split())\n        a[y].append(x)\n        a[x].append(y)\n    return '\\n'.join(map(str, [a[x].pop(0) for x in range(1, n+1)]))\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n_movies = int(stdin)\n    movies = []\n    for i in range(1, n_movies + 1):\n        movies.append(i)\n\n    # Initialise ordered dictionary for movie order\n    movie_order = OrderedDict()\n\n    # Create a dictionary that contains all the plot index for movies in sorted order\n    plot_order = {}\n\n    # Insert movies in plot order\n    for movie_id in movies:\n        movie_order[movie_id] = movie_id\n\n    # Insert movie in plot order\n    movie_id = 1\n    while movie_id <= n_movies:\n        movie_order[movie_id] = movie_id\n        movie_id += 1\n\n    # Insert plot indices into movie_order in reverse order\n    for plot_id in range(1, n_movies + 1):\n        movie_order[plot_id] = plot_order[plot_id]\n    return movie_order[plot_order[1]]\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin)\n    movies = []\n    while len(movies) < Q:\n        movie = stdin.split()\n        movies.append(int(movie[0]))\n    \n    for i in range(len(movies)):\n        if movies[i]!= i+1:\n            return movies[i]"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    plot_order = 1\n    creation_order = 1\n    result = []\n    for line in stdin.strip().splitlines():\n        if line[0] == '1':\n            creation_order += int(line[2:])\n            result.append(str(plot_order))\n        else:\n            result.append(str(creation_order))\n            plot_order += int(line[2:])\n    return '\\n'.join(result)"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    Q = int(input)\n    output = []\n    for q in range(1, Q+1):\n        q = input.split()\n        q = list(map(int, q))\n        print(q)\n        for i in range(1, Q+1):\n            if q[0] == 1:\n                print(q[1])\n                output.append(q[1])\n    return \" \".join(map(str, output))\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin)\n    print(q)\n    for i in range(q):\n        q = stdin.split()\n        print(q)\n        if q[0] == '1':\n            p = int(q[1])\n            print(p)\n            if p > 4:\n                print(p)\n                print(1+p)\n            elif p > 3:\n                print(2+p)\n            elif p > 2:\n                print(3+p)\n            else:\n                print(4+p)\n        if q[0] == '2':\n            p = int(q[1])\n            if p > 4:\n                print(5+p)\n            elif p > 3:\n                print(6+p)\n            elif p > 2:\n                print(7+p)\n            else:\n                print(8+p)\n\nsolution(\"1 1\")"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    output = []\n    for i in range(n, 1, -1):\n        if i <= n + i:\n            output.append(i)\n        elif i > n + i:\n            diff = i - n - 1\n            output.append(n + i)\n            output.append(n + diff)\n    output.sort()\n    return''.join([str(i) for i in output])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3128,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.split(\"\\n\")\n    output = []\n    for query in x:\n        query = query.split()\n        if query[0] == \"1\":\n            y = int(query[1])\n            if y <= len(output):\n                output.insert(y - 1, y)\n            else:\n                output.append(y)\n        else:\n            y = int(query[1])\n            output.insert(y - 1, y)\n    return \" \".join(str(i) for i in output)\nprint(solution(input()))\n\n\u0414\u0430\u043d\u043e \u0434\u0432\u0430 \u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0445 \u0441\u043f\u0438\u0441\u043a\u0430 A \u0438 B \u0440\u0430\u0437\u043d\u043e\u0433\u043e \u0434\u043b\u0438\u043d\u044b, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0445 N \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432. \u0418\u0437 A \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u0430\u043a\u043e\u0439 \u0436\u0435 \u0441\u043f\u0438\u0441\u043e\u043a B, \u0442\u043e\u043b\u044c\u043a\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044f \u0438\u0445 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.\n\n\u041f\u0440\u0438\u043c\u0435\u0440:\n\u0410 = [1,2,3,4,5]\n\u0411 = [3,4,5,1,2]\n\u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0411 \u0438\u0437 A:\n[4,5,1,2,3]\n\"\"\"\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = stdin.strip()\n    steps = 0\n    while (hay_bales!= \"\".join(sorted(hay_bales))):\n        hay_bales = \"\".join(sorted(hay_bales))\n        steps += 1\n    return steps"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    hay_bal_list = stdin.split()\n    ret = []\n    ret.append(hay_bal_list)\n    steps = 0\n    if len(hay_bal_list) == 1:\n        return steps\n    for i in range(0, len(hay_bal_list)-2):\n        if hay_bal_list[i] == hay_bal_list[i+1]:\n            if hay_bal_list[i+2] == hay_bal_list[i+1]:\n                hay_bal_list.pop(i+2)\n                hay_bal_list.pop(i)\n                hay_bal_list.append(hay_bal_list.pop(i))\n                hay_bal_list.append(hay_bal_list.pop(i+1))\n            else:\n                hay_bal_list.pop(i+2)\n                hay_bal_list.pop(i)\n                hay_bal_list.append(hay_bal_list.pop(i))\n        else:\n            pass\n    ret.append(hay_bal_list)\n    return steps"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n == 1:\n        return \"0\"\n\n    if n == 2:\n        return \"1\"\n\n    result = \"0\"\n\n    while n > 3:\n        n -= 3\n        result = str(int(result) + 1)\n        n -= 1\n        result = \"2\" + result\n    return result\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdout = []\n    step = 0\n    haybales = list(stdin)\n    while haybales!= sorted(haybales):\n        for i in range(0, len(haybales)-2):\n            if haybales[i] > haybales[i+1]:\n                step += 1\n                haybales = haybales[:i+1] + sorted(haybales[i+1:]) + haybales[i+2:]\n    stdout = str(step)\n    return stdout\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    cnt = 0\n    while s!= \"\":\n        tmp = s[0]\n        if tmp == 'C':\n            s = s[1:] + tmp\n        elif tmp == 'P':\n            s = s[1:] + tmp\n            s = s[:-1]\n        else:\n            tmp = s[0]\n            s = s[1:] + tmp\n        cnt += 1\n    return str(cnt)\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    sequence = stdin\n    sequence = list(sequence)\n    i = 0\n    j = 0\n    while i < len(sequence) - 2:\n        if sequence[i] == 'C' and sequence[i + 1] == 'C' and sequence[i + 2] == 'C':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n            sequence.pop(i)\n        elif sequence[i] == 'C' and sequence[i + 1] == 'C' and sequence[i + 2] == 'P':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n        elif sequence[i] == 'C' and sequence[i + 1] == 'P' and sequence[i + 2] == 'C':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n            sequence.pop(i)\n        elif sequence[i] == 'C' and sequence[i + 1] == 'P' and sequence[i + 2] == 'P':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n        elif sequence[i] == 'P' and sequence[i + 1] == 'C' and sequence[i + 2] == 'C':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n            sequence.pop(i)\n        elif sequence[i] == 'P' and sequence[i + 1] == 'C' and sequence[i + 2] == 'P':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n        elif sequence[i] == 'P' and sequence[i + 1] == 'P' and sequence[i + 2] == 'C':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n            sequence.pop(i)\n        elif sequence[i] == 'P' and sequence[i + 1] == 'P' and sequence[i + 2] == 'P':\n            sequence.pop(i + 1)\n            sequence.pop(i)\n        i += 1\n    return ''.join(sequence)\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = stdin.split()\n    ops = 0\n\n    while len(hay_bales) > 3:\n        hay_bales.pop(0)\n        hay_bales.pop(len(hay_bales) - 1)\n        ops += 1\n\n    return str(ops)\n"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    arr = list(stdin)\n    if(len(arr) < 3):\n        return -1\n    ans = 0\n    while len(arr) > 2:\n        arr.pop(0)\n        arr.pop(0)\n        arr.pop(0)\n        arr = sorted(arr)\n        ans += 1\n    return ans"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    hb = list(stdin)\n    while True:\n        step = 0\n        for i in range(0, len(hb) - 2):\n            if hb[i] == 'C':\n                if hb[i + 1] == 'C':\n                    if hb[i + 2] == 'C':\n                        hb[i], hb[i + 1], hb[i + 2] = 'P', 'P', 'P'\n                        step += 3\n                else:\n                    hb[i], hb[i + 1], hb[i + 2] = 'P', 'P', 'P'\n                    step += 3\n            else:\n                hb[i], hb[i + 1], hb[i + 2] = 'C', 'C', 'C'\n                step += 3\n        if step == 0:\n            break\n    return str(step)"
    },
    {
        "number": 3129,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(min_operations(stdin))\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    if __name__ == '__main__':\n        print(solution(*(list(stdin.split()))))\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4 2 3\n   ... 1 3\n   ... 2 3\n   ... 2\n   ... ''')\n    '3'\n    >>> solution('''\n   ... 3 2 1\n   ... 1 3\n   ... 2 3\n   ... 3\n   ... ''')\n    '1 2 3 3'\n    >>> solution('''\n   ... 2\n   ... ''')\n    '1'\n    \"\"\"\n\n    def find_implications(rules):\n        def update_rules(rule_number, rule_dict):\n            if rule_number not in rule_dict:\n                rule_dict[rule_number] = set()\n            for item in rule_dict[rule_number]:\n                if item not in rule_dict:\n                    rule_dict[item] = set()\n                rule_dict[item].add(rule_number)\n        # replace\n        for i in range(len(rules)):\n            if rules[i] == '#':\n                rules[i] = '0'\n        # split\n        rules = rules.split()\n        rules = map(int, rules)\n        rules = list(rules)\n        rules.sort(reverse=True)\n        #print(rules)\n        # rules\n        rules_dict = {}\n        for rule_number in range(len(rules)):\n            if rule_number not in rules_dict:\n                rules_dict[rule_number] = set()\n            if rules[rule_number] == '0':\n                continue\n            else:\n                for next_rule in rules_dict[rule_number]:\n                    if rules[next_rule] == '0':\n                        continue\n                    if next_rule not in rules_dict:\n                        rules_dict[next_rule] = set()\n                    rules_dict[next_rule].add(rule_number)\n        # update\n        for rule_number in range(len(rules)):\n            if rules[rule_number] == '0':\n                continue\n            else:\n                if rule_number not in rules_dict:\n                    rules_dict[rule_number] = set()\n                if rule_number not in rules_dict:\n                    rules_dict[rule_number] = set()\n                if rule_number in rules_dict:\n                    update_rules(rule_number, rules_dict)\n        #return rules_dict\n        #print(rules_dict)\n        # result\n        result = ''\n        for item in rules_dict:\n            #print(item, rules_dict[item])\n            if len(rules_dict[item]) > 1:\n                result += str(item)\n                for item in rules_dict[item]:\n                    result +='' + str(item)\n        result = result.strip()\n        #print(result)\n        return result\n\n    # input\n    test_cases = int(stdin.split()[0])\n    stdin = stdin.split()[1]\n    implications = stdin.split('\\n')\n    implications = [int(x) for x in implications]\n    # rules\n    rules = stdin.split('\\n')\n    rules = [int(x) for x in rules]\n    #print(implications, rules)\n    # result\n    for i in range(test_cases):\n        #print(i, '\\n')\n        #print(implications, rules)\n        if i == 0:\n            result = '{' + find_implications(implications) + '}'\n        else:\n            result = result[1:] + ',' + '{' + find_implications(implications) + '}'\n    return result"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, n1, n2 = map(int, stdin.split())\n    d = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        d[a].append(b)\n        d[b].append(a)\n    s = {i for i in range(1, n + 1)}\n    e = set()\n    e.add(n1)\n    e.add(n2)\n    while len(e) > 0:\n        x = e.pop()\n        e |= set(d[x])\n    for i in range(1, n + 1):\n        if i in e:\n            continue\n        e.add(i)\n        e |= {i for i in d[i] if i not in e}\n    return \",\".join(map(str, sorted(e)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, input().split())\n    imps = [list(map(int, input().split())) for _ in range(M)]\n    cnts = [0] * (D + 1)\n    for imp in imps:\n        cnts[imp[0]] += 1\n        cnts[imp[1]] -= 1\n    # print(cnts)\n    events = []\n    for i in range(1, D + 1):\n        if cnts[i] == 0:\n            events.append(i)\n    print(*events)\n    return\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split())\n    I_set = set()\n    for _ in range(M):\n        I_set.add(tuple(map(int, stdin.split())))\n    E_set = set()\n    for _ in range(N):\n        E_set.add(int(stdin))\n    return \",\".join(str(e) for e in sorted(I_set & E_set))\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    import io\n    sys.stdin = io.StringIO(stdin)\n    D, M, N = map(int, input().split())\n    implications = [[] for _ in range(M)]\n    for i in range(M):\n        implications[i] = list(map(int, input().split()))\n\n    events = [[] for _ in range(N)]\n    for i in range(N):\n        events[i] = int(input())\n\n    # print(implications)\n    # print(events)\n    count = 0\n    for i in range(N):\n        if events[i] in events:\n            count += 1\n    print(count)\n    # return count"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 1\n   ... 1 2\n   ... 2 3\n   ... 2\n   ... ''')\n    '1 2 3'\n    >>> solution('''\n   ... 3 2 1\n   ... 1 3\n   ... 2 3\n   ... 3\n   ... ''')\n    '1 2 3'\n    >>> solution('''\n   ... 3 2 1\n   ... 1 3\n   ... 2 3\n   ... 3\n   ... ''')\n    '1 2 3'\n    \"\"\"\n    # Your code here\n    return''.join(map(str, range(1, int(stdin.split()[0]) + 1)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, d, m, n = stdin.split()\n    d = int(d)\n    m = int(m)\n    n = int(n)\n    s = set()\n    for _ in range(m):\n        s.add(tuple(map(int, stdin.split())))\n    for _ in range(n):\n        s.add(int(stdin))\n    return''.join(map(str, sorted(s)))"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split())\n    implications = list(map(lambda x: x.split(), stdin.split()[1:]))\n    events = list(map(lambda x: x[-1], stdin.split()[1:]))\n    return''.join(sorted(solve(D, M, implications, events)))\n\ndef"
    },
    {
        "number": 3130,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, m, n = map(int, stdin.split())\n    impl = []\n    for i in range(m):\n        impl.append(tuple(map(int, stdin.split())))\n    events = set()\n    for impl_1 in impl:\n        events.add(impl_1[0])\n        events.add(impl_1[1])\n    print(*[ev for ev in events if ev in stdin.split()])\n    return ''"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(x) for x in stdin.split())\n    a = sorted(int(x) for x in stdin.split())\n    ans = sum(a[k] for k in range(N) if k % K == 0) % 1000000007\n    return str(ans)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip().split()\n    n = int(stdin.pop(0))\n    values = list(map(int, stdin.pop(0)))\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    result += (min(values[i], values[j], values[k], values[l]))\n    return str(result % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Finds the remainder of the given integer modulo the\n    divisor.\n    '''\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    sum_a = 0\n    for k in range(K):\n        sum_a += max(a)\n\n    return str(sum_a % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = {}\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    # print(d)\n    ans = 0\n    for i in range(k):\n        # print(d)\n        ans = ans + max(d.values()) * pow(10, len(d) - 1)\n        for key, val in d.items():\n            if val > 0:\n                d[key] -= 1\n        # print(ans)\n    return str(ans % 1000000007)\n\n\nsolution(\"5 3\\n2 4 2 3 4\")\nsolution(\"5 1\\n1 0 1 1 1\")"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n == 1:\n        return sum(a)\n\n    d = {}\n    for i in range(n):\n        d[a[i]] = i + 1\n\n    a.sort()\n    max_val = a[-1]\n    i = k - 1\n    s = 0\n    while i < n:\n        s += max_val\n        max_val -= 1\n        i += k\n\n    if max_val > 0:\n        s += max_val\n\n    return s % 1000000007\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(x) for x in stdin.split()]\n    nums = list(map(int, stdin.split()))\n    res = 0\n    for i in range(N - K + 1):\n        res = res + max(nums[i:i + K])\n    return str(res % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    _list = list(map(int, stdin.split()))\n    _list.sort()\n    ans = 0\n    for i in range(N - 1):\n        ans += (2 * _list[i] - _list[i + 1])\n    ans %= 1000000007\n    return str(ans)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    c = [0] * n\n    c[0] = a[0]\n    c[1] = a[0]\n    for i in range(2, n):\n        c[i] = max(a[i], c[i - 1])\n    s = 0\n    for i in range(k):\n        s += c[n - 1]\n        for j in range(n - 1, 0, -1):\n            c[j] = max(a[j] + c[j - 1], c[j])\n    return str(s % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, N, K = stdin.split()\n    N, K = int(N), int(K)\n    values = list(map(int, stdin.split()))\n    values.sort()\n    print(values)\n    if K == 0:\n        return str(sum(values) % 1000000007)\n    else:\n        return str(sum(values[:-K]) % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, k = map(int, stdin.split())\n    a = sorted(map(int, stdin.split()))\n    ans = 0\n    ans_set = set()\n    for i in range(k):\n        ans += a[i]\n        ans_set.add(ans)\n    ans_set = sorted(ans_set)\n    return str(ans_set[0])\n    \n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = stdin.strip().split(\" \")\n    rows = int(rows)\n    cols = int(cols)\n    # rows, cols = 6, 6\n    buildings = [[char for char in stdin.strip()] for stdin in stdin.splitlines()]\n    # buildings = [['x', 'x', 'x', 'x', 'x', 'x'],\n    #               ['x', 'x', 'x', 'x', 'x', 'x'],\n    #               ['x', 'x', 'x', 'x', 'x', 'x'],\n    #               ['x', 'x', 'x', 'x', 'x', 'x'],\n    #               ['x', 'x', 'x', 'x', 'x', 'x'],\n    #               ['x', 'x', 'x', 'x', 'x', 'x']]\n    rows = len(buildings)\n    cols = len(buildings[0])\n    solutions = []\n    for building in range(rows):\n        for col in range(cols):\n            # x = False\n            for row in range(rows):\n                if buildings[row][col] == \"x\":\n                    break\n            # x = True\n            for col in range(cols):\n                if buildings[row][col] == \"x\":\n                    break\n            if x:\n                solutions.append((row, col, 1))\n            # x = False\n            for row in range(rows):\n                if buildings[row][col] == \"x\":\n                    break\n            # x = True\n            for col in range(cols):\n                if buildings[row][col] == \"x\":\n                    break\n            if x:\n                solutions.append((row, col, 1))\n            # x = False\n            for row in range(rows):\n                if buildings[row][col] == \"x\":\n                    break\n            # x = True\n            for col in range(cols):\n                if buildings[row][col] == \"x\":\n                    break\n            if x:\n                solutions.append((row, col, 1))\n            # x = False\n            for row in range(rows):\n                if buildings[row][col] == \"x\":\n                    break\n            # x = True\n            for col in range(cols):\n                if buildings[row][col] == \"x\":\n                    break\n            if x:\n                solutions.append((row, col, 1))\n    return \"\\n\".join([str(x) for x in solutions])\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # if stdin is empty, then return empty\n    if not stdin:\n        return \"\"\n\n    # parse stdin into a list\n    stdin = stdin.split()\n\n    # make sure we have a list of length 2\n    if len(stdin)!= 2:\n        return \"\"\n\n    # convert the stdin to an integer\n    rows, columns = map(int, stdin)\n\n    # check to make sure we have a valid number\n    if rows < 1 or columns < 1:\n        return \"\"\n\n    # create a list to store the possible locations\n    possible_locations = []\n\n    # for each row\n    for i in range(1, rows + 1):\n        # make a list of the columns\n        cols = []\n        # for each column\n        for j in range(1, columns + 1):\n            # if the row is a valid index\n            if i <= rows and j <= columns:\n                # add the location to the list\n                cols.append(i * columns + j)\n        # add the list of columns to the list of possible locations\n        possible_locations.append(cols)\n\n    # calculate the possible location based on the column\n    # make a list to store the locations\n    locations = []\n    # go through the possible locations\n    for i in range(len(possible_locations)):\n        # go through each column in the possible locations\n        for j in range(len(possible_locations[i])):\n            # if the location is not empty\n            if possible_locations[i][j]!= \"x\":\n                # add the location to the list\n                locations.append(possible_locations[i][j])\n\n    # find the minimum length\n    min_length = min(map(len, locations))\n    # sort the locations so we get the longest first\n    locations = sorted(locations)\n    # for each location\n    for i in range(len(locations)):\n        # remove the characters\n        char_remove = locations[i][min_length:]\n        # add a space to the location\n        char_add =''\n        # add the characters\n        location = char_remove + char_add\n        # return the location\n        return location\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    R, C = stdin[0].split()\n    R = int(R)\n    C = int(C)\n    R = R - 1\n    C = C - 1\n    res = []\n    for i in range(R):\n        for j in range(C):\n            if stdin[i + 1][j + 1] == 'x':\n                res.append((i + 1, j + 1, 2))\n            if stdin[i + 1][j + 1] == '.':\n                res.append((i + 1, j + 1, 1))\n    return '\\n'.join(map(str, res))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    L = []\n    for r in range(R):\n        L.append(stdin[r])\n    if R == 1:\n        return '0'\n    if R == 2:\n        if L[0] == 'x':\n            return '2'\n        else:\n            return '1'\n    if R == 3:\n        if L[0] == 'x':\n            return '2'\n        elif L[1] == 'x':\n            return '3'\n        else:\n            return '1'\n    else:\n        x = 0\n        res = ''\n        for r in range(R):\n            if L[r] == 'x':\n                x += 1\n                res = r\n        if x == 2:\n            return f'2 {res} 1'\n        else:\n            return f'1 {res} {x}'\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [[c for c in line] for line in stdin.split(\"\\n\")]\n    # print(grid)\n    visited = set()\n    # For each cell, check if any building was there or not, if so, then return size and row,col\n    def dfs(r, c, size, row, col, visited):\n        # Check if already visited, then return size\n        if (r, c, size) in visited:\n            return size\n        # Check if we are at bottom right, then return size and row,col\n        if r == R - 1 and c == C - 1:\n            return size, row, col\n        # Check if we are at bottom right\n        if r == R - 1 and c < C:\n            # If we find an empty cell, then we update size and row,col\n            if grid[r][c] == \".\":\n                size += 1\n                row = r\n                col = c\n                # Check if we are in top row\n                if r > 0:\n                    visited.add((r - 1, c, size))\n                    size, row, col = dfs(r - 1, c, size, row, col, visited)\n                # Check if we are in left column\n                if c > 0:\n                    visited.add((r, c - 1, size))\n                    size, row, col = dfs(r, c - 1, size, row, col, visited)\n        # Check if we are in top row\n        if r > 0:\n            # If we find an empty cell, then we update size and row,col\n            if grid[r][c] == \".\":\n                size += 1\n                row = r\n                col = c\n                # Check if we are in left column\n                if c > 0:\n                    visited.add((r - 1, c - 1, size))\n                    size, row, col = dfs(r - 1, c - 1, size, row, col, visited)\n                # Check if we are in top left corner\n                if r > 0 and c > 0:\n                    visited.add((r - 1, c, size))\n                    size, row, col = dfs(r - 1, c, size, row, col, visited)\n        # Check if we are in top left corner\n        if r > 0 and c > 0:\n            # If we find an empty cell, then we update size and row,col\n            if grid[r][c] == \".\":\n                size += 1\n                row = r\n                col = c\n                # Check if we are in left column\n                if c > 0:\n                    visited.add((r, c - 1, size))\n                    size, row, col = dfs(r, c - 1, size, row, col, visited)\n                # Check if we are in top right corner\n                if r > 0 and c < C - 1:\n                    visited.add((r - 1, c, size))\n                    size, row, col = dfs(r - 1, c, size, row, col, visited)\n        return size, row, col\n    # Initiate size, row,col\n    size, row, col = dfs(0, 0, 0, 0, 0, set())\n    # Remove space character from string and convert to list\n    # print(row, col, size)\n    print(\" \".join(str(size) for row in range(row, row + size) for col in range(col, col + size)))\n    return \" \".join(str(size) for row in range(row, row + size) for col in range(col, col + size))\nsolution(stdin)\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    for _ in range(R):\n        c = stdin.split()\n        for x in range(C):\n            if c[x] == \".\":\n                continue\n            elif c[x] == \"x\":\n                return \"0\"\n    return str(R) + \" \" + str(C) + \" \" + str(R * C)\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    cnt = 0\n    for row in range(r):\n        for col in range(c):\n            if stdin[row][col] == 'x':\n                cnt += 1\n    return str(r) +'' + str(c) +'' + str(cnt)"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split('\\n')\n    r, c = map(int, stdin_list[0].split())\n    s_build1 = stdin_list[1].strip()\n    s_build2 = stdin_list[2].strip()\n    # grid = [stdin_list[1:r]]\n    # for i in range(r):\n    #     grid.append(stdin_list[i + 1:i + 1 + c])\n\n    # print(grid)\n\n    build1_start = 0\n    build1_end = 0\n    build2_start = 0\n    build2_end = 0\n    i = 0\n    while i < r:\n        if s_build1[i] == 'x':\n            build1_start = i\n            break\n        i += 1\n\n    i = r - 1\n    while i >= 0:\n        if s_build1[i] == 'x':\n            build1_end = i\n            break\n        i -= 1\n\n    i = 0\n    while i < c:\n        if s_build2[i] == 'x':\n            build2_start = i\n            break\n        i += 1\n\n    i = c - 1\n    while i >= 0:\n        if s_build2[i] == 'x':\n            build2_end = i\n            break\n        i -= 1\n\n    print(build1_start, build1_end)\n    print(build2_start, build2_end)\n\n    return build1_start, build1_end, build2_start, build2_end\n\n\nprint(solution('1 2\\nxx.\\nxx.xxx'))\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, c = stdin.split(' ')\n    r = int(r)\n    c = int(c)\n    rows = []\n    for _ in range(r):\n        rows.append(stdin.replace('x', '.').replace('.', 'x'))\n    for i in range(r):\n        for j in range(c):\n            if rows[i][j] == '.':\n                rows[i][j] = 'o'\n            else:\n                rows[i][j] = 'x'\n    possible = []\n    for i in range(r):\n        if rows[i][0] == 'o':\n            possible.append([i, 0])\n    for i in range(r):\n        if rows[i][c - 1] == 'o':\n            possible.append([i, c - 1])\n    for i in range(c):\n        if rows[0][i] == 'o':\n            possible.append([0, i])\n    for i in range(c):\n        if rows[r - 1][i] == 'o':\n            possible.append([r - 1, i])\n    res = []\n    for i in range(len(possible)):\n        c_row, c_col = possible[i]\n        for j in range(c):\n            if rows[c_row][j] == 'x':\n                c_row += 1\n                break\n        for j in range(c - 1, -1, -1):\n            if rows[c_row][j] == 'x':\n                c_col -= 1\n                break\n        for j in range(c):\n            if rows[j][c_col] == 'x':\n                c_col += 1\n                break\n        for j in range(c - 1, -1, -1):\n            if rows[j][c_col] == 'x':\n                c_row -= 1\n                break\n        res.append([c_row, c_col, c_row * c_col])\n    return''.join(map(str, res))\n"
    },
    {
        "number": 3132,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, _, *rows = stdin.split()\n    cols = len(rows[0])\n    buildings = []\n    for row in rows:\n        buildings.append(row)\n    buildings.sort()\n\n    for i in range(len(buildings)):\n        for j in range(i+1, len(buildings)):\n            if buildings[i].find('.')!= -1:\n                if buildings[j].find('.')!= -1:\n                    continue\n                else:\n                    return \"0 0 0\"\n\n            if buildings[i].find('x')!= -1:\n                if buildings[j].find('x')!= -1:\n                    continue\n                else:\n                    return \"0 0 0\"\n\n            if buildings[j].find('x')!= -1:\n                if buildings[i].find('x')!= -1:\n                    continue\n                else:\n                    return \"0 0 0\"\n    return \"0 0 0\"\n"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    # Alice and Bob are travelling in Italy. They are travelling by car and unfortunately they took a wrong turn. Now they are stuck in the city centre of Pisa. (You may know that you need an allowance to drive in the city centre, so they are at risk of getting a fine.) As they were not fully prepared for this, they have a map, but no GPS. The map lists all intersections. At each intersection you can go either left or right (you cannot go straight or take a U-turn, as many streets are one-way).\n    # Of course, they paid attention when entering Pisa and tried to follow on the map. Unfortunately, Alice thinks they are at intersection $A$, while Bob believes they are now at intersection $B$. You can imagine this is quite a stressful situation. Instead of figuring out how to get out of Pisa, they want to know who is right first. On the map it is indicated from which intersections you can see the leaning tower of Pisa. So they believe they can conduct an experiment: drive a bit and take the same actions on the map starting from $A$ and $B$. They can trace the route they drive on the map for both of their starting points. As soon as the tower of Pisa should be visible for one of them but not for the other, they can look out of the window to see who is right. You may assume exactly one of them is right.\n    # In fact, to make Alice and Bob believe they are correct, they need to drive towards the intersection they are currently at. Their initial positions were $A = 1$, $B = 2$, and they are standing at $A$:\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 5$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 7$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 11$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 13$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 15$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 17$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 19$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 21$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 23$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 25$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 27$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 29$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 31$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 33$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 35$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 37$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 39$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 41$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 43$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 45$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 47$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 49$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 51$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 53$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 55$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 57$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 59$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 61$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 63$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 65$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 67$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 69$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 71$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 73$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^0 = 75$.\n    # $2^2 + 2^1 + 2^0 = 2^2 + 2^1 + 2^"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    INPUT = stdin.split()\n    N = int(INPUT[0])\n    A = int(INPUT[1])\n    B = int(INPUT[2])\n    if A == 0 or B == 0:\n        return 'indistinguishable'\n    if A == B:\n        return 'indistinguishable'\n    if N == 1:\n        if A == 0:\n            return '0'\n        else:\n            return '1'\n    f = [[0 for j in range(2 * N)] for i in range(2 * N)]\n    for i in range(N):\n        f[i][0] = 1\n    for i in range(2 * N - 1):\n        if i % 2 == 0:\n            f[i // 2][i] = 1\n            f[i + 1][i] = 1\n        else:\n            f[i // 2][i] = 1\n            f[i + 1][i] = 1\n    for i in range(2 * N):\n        for j in range(2 * N):\n            f[i][j] = f[i][j - 1] or f[i][j + 1] or f[i - 1][j] or f[i + 1][j]\n    f[0][1] = f[1][0] = 0\n    f[N - 1][N - 1] = 1\n    f[A][B] = 1\n    stack = [[A, 1]]\n    while stack:\n        s, r = stack.pop()\n        if s == B:\n            return r\n        if s == 0:\n            continue\n        for i in range(2):\n            if i == 0 and s - 1 >= 0:\n                if f[s - 1][i] and f[s - 1][i + 1]:\n                    stack.append([s - 1, r + 1])\n            if i == 1 and s + 1 < N:\n                if f[s + 1][i] and f[s + 1][i + 1]:\n                    stack.append([s + 1, r + 1])"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    result = \"indistinguishable\"\n    #your code here\n    return result"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [int(n) for n in stdin.split()]\n    if n == 1:\n        return \"indistinguishable\"\n    if a == b:\n        return \"indistinguishable\"\n    if a == 1 or b == 1:\n        return \"indistinguishable\"\n    if a == 2 or b == 2:\n        return \"indistinguishable\"\n    print(\"indistinguishable\")\n    return"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    int_intersections = int(stdin.split()[0])\n    int_alice = int(stdin.split()[1])\n    int_bob = int(stdin.split()[2])\n    turns_alice = 0\n    turns_bob = 0\n\n    # in both cases, first turn to the left is the same as first turn to right\n    turns_alice = turns_alice + 1\n\n    # find start of the experiment\n    for i in range(1, int_intersections):\n        if int_alice == i:\n            turns_alice += 1\n            break\n        if int_bob == i:\n            turns_bob += 1\n            break\n\n    # in both cases, the second turn to the left is the same as second turn to right\n    turns_bob = turns_bob + 1\n\n    # second turn to the right\n    # in the first case, bob got a left turn\n    if turns_alice < turns_bob:\n        print(turns_bob)\n        return turns_bob\n    # in the second case, alice got a right turn\n    else:\n        print(turns_alice)\n        return turns_alice\n"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n    3 1 2\n    1 2 1\n    0 2 0\n    0 1 0\n    ''')\n    indistinguishable\n    \"\"\"\n    n, a, b = map(int, stdin.split())\n    intersections = set()\n    turns = {}\n    turns[(0,0)] = (0,0)\n    for _ in range(n):\n        intersections.update({(l, r) for l, r in zip(map(int, stdin.split()[1::2]), map(int, stdin.split()[2::2]))})\n        turns.update(\n            {(l, r): (turns.get((r, l), (0,0))[0] + 1, turns.get((r, l), (0,0))[1] + (r-l)) for l, r in zip(map(int, stdin.split()[1::2]), map(int, stdin.split()[2::2]))}\n        )\n    turns_alice, turns_bob = 0, 0\n    while (alice, bob) not in intersections:\n        turns_alice, turns_bob = turns_alice + 1, turns_bob + 1\n        if turns_alice in turns:\n            alice = turns[turns_alice]\n        if turns_bob in turns:\n            bob = turns[turns_bob]\n    return turns_alice if a == alice else turns_bob if b == bob else 'indistinguishable'\n"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"A\" if stdin.split()[-1] == \"0\" else \"B\"\n"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    return \"indistinguishable\" if A == B else str(A - 1 - (B - A + 1) % 2)"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    left, right = map(int, stdin.split())\n    if left == a and right == b:\n        return 'indistinguishable'\n    if left == a or right == b:\n        return '0'\n    else:\n        return str(n - 1 - (right - left) // (2 - left))\n"
    },
    {
        "number": 3133,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = stdin.split()\n    n, a, b = int(n), int(a), int(b)\n    left = []\n    right = []\n    for i in range(n):\n        left.append(tuple(map(int, stdin.split()[i * 2])))\n        right.append(tuple(map(int, stdin.split()[i * 2 + 1])))\n    left.sort(key=lambda x: x[0])\n    right.sort(key=lambda x: x[0])\n    # print(left)\n    # print(right)\n    i = 0\n    j = 0\n    turns = 0\n    while i < n and j < n:\n        if left[i][0] == right[j][0]:\n            if left[i][1]!= right[j][1]:\n                turns += abs(left[i][1] - right[j][1]) + 1\n                i += 1\n                j += 1\n            else:\n                i += 1\n        elif left[i][0] < right[j][0]:\n            turns += abs(left[i][0] - right[j][0]) + 1\n            i += 1\n        else:\n            turns += abs(left[i][0] - right[j][0]) + 1\n            j += 1\n    if i == n:\n        return 'left'\n    elif j == n:\n        return 'right'\n    return str(turns)\n    # print(turns)\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin[0]\n    C = stdin[1]\n    #print(R,C)\n    if (len(R) == 0) and (len(C) == 0):\n        return -1\n    if (len(R) % 2!= 0) or (len(C) % 2!= 0):\n        return -1\n    parity = []\n    p = 1\n    for i in range(0,len(R)):\n        if R[i] == '1':\n            parity.append(p)\n        p = p * 2\n    \n    p = 1\n    for j in range(0,len(C)):\n        if C[j] == '1':\n            parity.append(p)\n        p = p * 2\n    #print(parity)\n    for k in parity:\n        if k == 1:\n            R = R + \"1\"\n        else:\n            R = R + \"0\"\n    if len(R) == len(C):\n        return R\n    else:\n        return -1\n    \n\nprint(solution(stdin))\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin\n    C = stdin\n    return str(is_even(R, C))\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin\n    C = stdin\n    s = R + C\n    x = \"00111000\"\n    y = \"00011101\"\n    z = \"01111001\"\n    t = \"10011011\"\n    n = int(len(R)/2)\n    k = int(len(R)/2)\n    j = 0\n    i = 0\n    r = []\n    while i < n:\n        r.append(s[k])\n        r.append(s[k+1])\n        k += 2\n        i += 1\n    while j < len(s):\n        if s[j] == \"1\":\n            if s[j+1] == \"0\":\n                if s[j+2] == \"1\":\n                    r.append(s[j+3])\n                    j += 4\n                else:\n                    r.append(s[j+2])\n                    j += 3\n            else:\n                r.append(s[j+1])\n                j += 2\n        else:\n            r.append(s[j+1])\n            j += 2\n    i = 0\n    while i < len(R):\n        if R[i] == \"1\":\n            if R[i+1] == \"1\":\n                if R[i+2] == \"1\":\n                    if R[i+3] == \"0\":\n                        r.append(z)\n                        i += 4\n                    else:\n                        r.append(y)\n                        i += 3\n                else:\n                    if R[i+2] == \"0\":\n                        r.append(x)\n                        i += 3\n                    else:\n                        r.append(y)\n                        i += 2\n            elif R[i+1] == \"0\":\n                if R[i+2] == \"1\":\n                    if R[i+3] == \"1\":\n                        r.append(z)\n                        i += 4\n                    else:\n                        r.append(t)\n                        i += 3\n                else:\n                    r.append(x)\n                    i += 2\n        else:\n            r.append(x)\n            i += 1\n    i = 0\n    while i < len(C):\n        if C[i] == \"1\":\n            if C[i+1] == \"1\":\n                if C[i+2] == \"1\":\n                    if C[i+3] == \"0\":\n                        r.append(z)\n                        i += 4\n                    else:\n                        r.append(y)\n                        i += 3\n                else:\n                    if C[i+2] == \"0\":\n                        r.append(x)\n                        i += 3\n                    else:\n                        r.append(y)\n                        i += 2\n            elif C[i+1] == \"0\":\n                if C[i+2] == \"1\":\n                    if C[i+3] == \"1\":\n                        r.append(z)\n                        i += 4\n                    else:\n                        r.append(t)\n                        i += 3\n                else:\n                    r.append(x)\n                    i += 2\n        else:\n            r.append(x)\n            i += 1\n    if len(r) == 0:\n        return \"-1\"\n    else:\n        return \"\".join(r)"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n,m=map(int,stdin.split())\n    if(n==m and n%2==0):\n        l=[]\n        for i in range(n):\n            l.append(list(stdin))\n        for i in range(n):\n            if(l[i].count('1')%2!=0):\n                for j in range(m):\n                    l[i][j]='0'\n            if(l[i].count('1')%2!=0):\n                for j in range(m):\n                    l[i][j]='1'\n        for i in range(n):\n            print(''.join(l[i]))\n        return ''.join(l)\n    else:\n        return -1\nsolution(stdin)\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R = list(stdin)\n    C = list(stdin)\n    for r in range(1, len(R)):\n        if R[r]!= 0:\n            break\n    else:\n        return -1\n    if R[0] == 1:\n        for c in range(1, len(C)):\n            if C[c] == 1:\n                continue\n            else:\n                return -1\n        return \"\".join(R[:r+1]) + \"\".join(R[:c+1])\n    else:\n        if len(C) % 2 == 0:\n            return -1\n        else:\n            r_idx = 0\n            c_idx = 0\n            while r_idx <= len(R):\n                if R[r_idx] == 1:\n                    r_idx += 2\n                    continue\n                else:\n                    break\n            while c_idx <= len(C):\n                if C[c_idx] == 1:\n                    c_idx += 2\n                    continue\n                else:\n                    break\n            if (r_idx - 1) == len(R):\n                return \"\".join(R) + \"\".join(C)\n            else:\n                if len(R) - 1 == r_idx:\n                    if (len(R) - r_idx) % 2 == 0:\n                        return \"\".join(R[:r_idx]) + \"\".join(C)\n                    else:\n                        return \"\".join(R[:r_idx]) + \"\".join(C)\n                else:\n                    if (len(C) - c_idx) % 2 == 0:\n                        return \"\".join(R) + \"\".join(C)\n                    else:\n                        return \"\".join(R) + \"\".join(C)\nstdin = \"010011\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin\n    C = stdin\n    if 1 in C:\n        return '-1'\n    R_s = [1 if x == '1' else 0 for x in R]\n    C_s = [1 if x == '1' else 0 for x in C]\n    return ''.join([str(R_s[i]) + str(C_s[i]) for i in range(len(R))])\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    rows = []\n    columns = []\n    for line in input.splitlines():\n        if line:\n            rows.append(line[0])\n            columns.append(line[1])\n    row_parity = sum([int(i) for i in rows])\n    column_parity = sum([int(i) for i in columns])\n    if abs(row_parity) == abs(column_parity):\n        return '\\n'.join(rows + columns)\n    else:\n        return '-1'\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin.split()[0]\n    C = stdin.split()[1]\n    row = 0\n    col = 0\n    final = ''\n    for i in R:\n        if i == '0':\n            row -= 1\n        else:\n            row += 1\n    for j in C:\n        if j == '0':\n            col -= 1\n        else:\n            col += 1\n    for i in range(0, row + 1):\n        for j in range(0, col + 1):\n            if i == 0:\n                final += '0'\n            elif j == 0:\n                final += '1'\n            else:\n                if final[i * col + j] == '0':\n                    final += '1'\n                else:\n                    final += '0'\n    return final\n"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r = stdin.split(\"\\n\")[0]\n    c = stdin.split(\"\\n\")[1]\n\n    if len(r) % 2 == 0:\n        n = int(len(r) / 2)\n        binary_n = str(bin(n)[2:])\n        binary_n = binary_n.zfill(len(c))\n        binary_r = str(bin(int(r, 2)))\n        binary_r = binary_r.zfill(len(c))\n        # print(binary_r)\n        # print(binary_n)\n        for i in range(len(binary_r)):\n            if binary_r[i] == \"1\" and binary_n[i] == \"1\":\n                binary_r = binary_r[:i] + \"0\" + binary_r[i + 1:]\n                binary_n = binary_n[:i] + \"0\" + binary_n[i + 1:]\n                break\n        if binary_r == binary_n:\n            print(\"\".join(binary_n))\n            return \"\".join(binary_n)\n\n    else:\n        n = int(len(r) / 2)\n        binary_n = str(bin(n)[2:])\n        binary_n = binary_n.zfill(len(c))\n        binary_r = str(bin(int(r, 2)))\n        binary_r = binary_r.zfill(len(c))\n        # print(binary_r)\n        # print(binary_n)\n        for i in range(len(binary_r)):\n            if binary_r[i] == \"1\" and binary_n[i] == \"1\":\n                binary_r = binary_r[:i] + \"0\" + binary_r[i + 1:]\n                binary_n = binary_n[:i] + \"0\" + binary_n[i + 1:]\n                break\n        if binary_r == binary_n:\n            print(\"\".join(binary_n))\n            return \"\".join(binary_n)\n    return \"\".join(binary_n)\n\n\nprint(solution(stdin))"
    },
    {
        "number": 3134,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin[0]\n    C = stdin[1]\n    row = []\n    row.extend(map(lambda x: 1 if x == '1' else 0, R))\n    row.extend([-1] * (len(C) - len(R)))\n    col = []\n    col.extend(map(lambda x: 1 if x == '1' else 0, C))\n    col.extend([-1] * (len(R) - len(C)))\n    rowparity = ''.join(map(str, row))\n    colparity = ''.join(map(str, col))\n    if (rowparity == colparity):\n        return ''.join(map(str, row))\n    else:\n        return '-1'\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    binary = stdin\n    n = int(binary, 2)\n    if n == 0:\n        return '+0'\n    if n == 1:\n        return '+1'\n    if n == -1:\n        return '-1'\n    s = [str(n), '+', str(n + 1), '-', str(n - 1)]\n    return '+'.join(s)\nsolution('01')\nsolution('11111')\nsolution('01')\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    if not stdin.isnumeric():\n        return -1\n    n = int(stdin)\n    n = \"{0:b}\".format(n)\n    min_num = []\n    while n:\n        min_num.append(n[-1])\n        n = n[:-1]\n    min_num.sort()\n    if min_num[0] == \"0\":\n        return \"-\" + \"\".join(min_num)\n    else:\n        return \"\".join(min_num)\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    number = int(stdin)\n    binary_representation = to_binary(number)\n    return \"\".join(binary_representation)\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    with open('out.txt', 'w') as f:\n        lines = stdin.splitlines()\n        max_num = 2 ** 63 - 1\n        for line in lines:\n            line = int(line)\n            line = format(line, 'b')\n            max_line = len(line)\n            for i in range(max_line):\n                if line[i] == '0':\n                    continue\n                if line[i] == '1':\n                    min_line = i\n                    break\n            for i in range(max_line):\n                if line[i] == '1':\n                    min_line = i\n                    break\n            # print(f'{i}')\n            if min_line > max_line // 2:\n                f.write('+')\n                for j in range(i):\n                    f.write('0')\n                f.write('-')\n                for j in range(max_line - i - 1):\n                    f.write('0')\n            else:\n                for j in range(i):\n                    f.write('0')\n                f.write('-')\n                for j in range(max_line - i - 1):\n                    f.write('0')\n        f.write('+')\n        for j in range(max_num):\n            f.write('0')\n        return ''.join(f.readlines())"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def convert(n):\n        if n == 0:\n            return ''\n        if n < 0:\n            return '-' + convert(-n)\n        if n < 2**31:\n            return str(n)\n        elif n <= 2**63-1:\n            return '+' + str(n)\n        elif n <= 2**128-1:\n            return '-' + str(n)\n        elif n <= 2**128:\n            return '0' + str(n)\n    return '+' + convert(n)\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    binary_string = str(bin(n))\n    binary_string = binary_string[2:]\n    output_string = ''\n    if binary_string.startswith('-'):\n        binary_string = binary_string[1:]\n        output_string = '-' + output_string\n    for i in range(len(binary_string)):\n        if binary_string[i] == '0':\n            binary_string = binary_string[:i] + '-' + binary_string[i + 1:]\n            output_string = '-' + output_string\n        else:\n            binary_string = binary_string[:i] + '+' + binary_string[i + 1:]\n            output_string = '+' + output_string\n    return output_string\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    while len(stdin) > 1:\n        num = int(stdin[:10], 2)\n        count += 1\n        stdin = stdin[10:]\n        if num < 0:\n            stdin = '-'.join(stdin.split('-'))\n        elif num > 0:\n            stdin = '+'.join(stdin.split('+'))\n    return stdin\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    while n:\n        n = n - n % 2\n        n = n // 2\n    return str(n)"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    binary = stdin.strip()\n    min_len = len(binary)\n\n    for power in range(1, 1001):\n        if 2 ** power > len(binary):\n            break\n    res = 0\n    for i in range(power):\n        if binary[i] == '1':\n            res = -res - 2 ** i\n        elif binary[i] == '0':\n            res = -res + 2 ** i\n        else:\n            return '-' + '-' * min_len\n    return '+' + ('-' * min_len) + str(res)\n"
    },
    {
        "number": 3135,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    i = 0\n    while i < len(s):\n        if s[i] == '-':\n            s = s[:i] + '+' + s[i + 1:]\n            i += 1\n        elif s[i] == '+':\n            s = s[:i] + '-' + s[i + 1:]\n            i += 1\n        elif s[i] == '0':\n            s = s[:i] + '1' + s[i + 1:]\n            i += 1\n        else:\n            s = s[:i] + '0' + s[i + 1:]\n            i += 1\n    return s"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        u, v = u - 1, v - 1\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    def find_neighbors(i: int, visited: list, dists: list) -> list:\n        for j, d in graph[i]:\n            if j not in visited:\n                visited.append(j)\n                dists.append(d)\n                find_neighbors(j, visited, dists)\n        return dists\n\n    tot_dist = 0\n    for i in range(s - 1, t - 1):\n        visited = set()\n        dists = find_neighbors(i, visited, [])\n        min_dist = float(\"inf\")\n        for d in dists:\n            min_dist = min(min_dist, d)\n        tot_dist += min_dist\n    return str(tot_dist)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = list(map(int, stdin.split()))\n    intersections = {}\n    roads = {}\n    for _ in range(m):\n        u, v, d = list(map(int, stdin.split()))\n        if u in intersections:\n            intersections[u].append((v, d))\n        else:\n            intersections[u] = [(v, d)]\n        if v in intersections:\n            intersections[v].append((u, d))\n        else:\n            intersections[v] = [(u, d)]\n        roads[(u, v)] = d\n    s_q = collections.deque()\n    s_q.append(('', 0, (0, 0)))\n    result = 0\n    while s_q:\n        s, cost, loc = s_q.popleft()\n        if s in intersections:\n            for i, d in intersections[s]:\n                if i in roads:\n                    if i in s_q:\n                        if s_q[i][2][0] > loc[0]:\n                            s_q.append((i, cost+roads[i], loc))\n                    else:\n                        if loc[0] > 0:\n                            s_q.append((i, cost+roads[i], loc))\n                else:\n                    if i in s_q:\n                        if s_q[i][2][0] > loc[0]:\n                            s_q.append((i, cost, loc))\n                    else:\n                        if loc[0] > 0:\n                            s_q.append((i, cost, loc))\n        if s == '-1':\n            if result < cost:\n                result = cost\n    return str(result)\n"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = list(map(int, stdin.split()))\n    edges = []\n    for _ in range(m):\n        u, v, d = list(map(int, stdin.split()))\n        edges.append((u, v, d))\n    return str(min_distance(n, m, s, t, edges))\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = [line.split() for line in stdin.strip().split('\\n')]\n    n, m, s, t = lines.pop(0)\n    n, m, s, t = int(n), int(m), int(s), int(t)\n    intersections = set()\n    roads = []\n    employees = []\n    clients = []\n    for i, (x, y) in enumerate(lines):\n        x, y = int(x), int(y)\n        if x > y:\n            x, y = y, x\n        if x == y:\n            continue\n        intersections.add(x)\n        intersections.add(y)\n        roads.append((x, y, 0))\n        roads.append((y, x, 0))\n    # roads = list(set(roads))\n    for i, (x, y, d) in enumerate(roads):\n        if x not in intersections:\n            continue\n        if y not in intersections:\n            continue\n        if x == y:\n            continue\n        roads[i] = (x, y, d + 1)\n        roads.append((y, x, d + 1))\n    # roads = list(set(roads))\n    employees = set([x for x in intersections if x > 1])\n    clients = set([x for x in intersections if x < len(intersections) - 1])\n    employees.add(2)\n    employees.add(1)\n    employees = list(employees)\n    clients = list(clients)\n    employees = [(x, y) for x, y in enumerate(employees)]\n    clients = [(x, y) for x, y in enumerate(clients)]\n    intersections.sort()\n    employees.sort()\n    clients.sort()\n    answer = 0\n    employees_lookup = {}\n    for i in employees:\n        employees_lookup[i] = set()\n    employees_lookup[len(employees) - 1].add(len(employees) - 1)\n    employees_lookup[len(employees) - 1].add(len(employees) - 2)\n    for i, (x, y) in enumerate(roads):\n        if x == y:\n            continue\n        if x in employees_lookup and y in employees_lookup:\n            employees_lookup[x].intersection_update(employees_lookup[y])\n        if x in employees_lookup and y == len(employees):\n            employees_lookup[x].intersection_update(employees_lookup[y])\n        if y in employees_lookup and x == len(employees):\n            employees_lookup[y].intersection_update(employees_lookup[x])\n        if x == len(employees) - 1 and y == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if x == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if y == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if len(employees_lookup[x]) > 1:\n            answer += roads[i][2] + roads[i][2] + 1\n        if len(employees_lookup[x]) == 1:\n            answer += roads[i][2] + roads[i][2]\n        if len(employees_lookup[y]) > 1:\n            answer += roads[i][2] + roads[i][2] + 1\n        if len(employees_lookup[y]) == 1:\n            answer += roads[i][2] + roads[i][2]\n    # print(employees_lookup)\n    # print(clients)\n    for i, (x, y) in enumerate(clients):\n        if x == y:\n            continue\n        if x in employees_lookup and y in employees_lookup:\n            employees_lookup[x].intersection_update(employees_lookup[y])\n        if x in employees_lookup and y == len(employees):\n            employees_lookup[x].intersection_update(employees_lookup[y])\n        if y in employees_lookup and x == len(employees):\n            employees_lookup[y].intersection_update(employees_lookup[x])\n        if x == len(employees) - 1 and y == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if x == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if y == len(employees) - 1:\n            answer += roads[i][2]\n            continue\n        if len(employees_lookup[x]) > 1:\n            answer += roads[i][2] + roads[i][2] + 1\n        if len(employees_lookup[x]) == 1:\n            answer += roads[i][2] + roads[i][2]\n        if len(employees_lookup[y]) > 1:\n            answer += roads[i][2] + roads[i][2] + 1\n        if len(employees_lookup[y]) == 1:\n            answer += roads[i][2] + roads[i][2]\n    return str(answer)\n"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, m, s, t = int(stdin[0]), int(stdin[1]), int(stdin[2]), int(stdin[3])\n    inp = stdin[4:]\n    nums = {nums for nums in inp}\n    s = {inp for inp in inp}\n    t = {inp for inp in inp}\n    m = {inp for inp in inp}\n    graph = [[] for _ in range(n)]\n    for inp in inp:\n        u, v = inp.split()\n        u = int(u)\n        v = int(v)\n        graph[u].append(v)\n        graph[v].append(u)\n    maxDist = 0\n    while m:\n        dist = {}\n        for key in m:\n            curr = m[key]\n            dist[curr] = 0\n        visited = set()\n        maxDist = max(maxDist, dfs(visited, graph, dist, m, n, 0, 0))\n    return str(maxDist)\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        roads.append((u, v, d))\n    intersections = []\n    for i in range(n):\n        intersections.append((i, (i, -1, -1)))\n    warehouses = []\n    for i in range(s):\n        warehouses.append(i)\n    employees = []\n    for i in range(t):\n        employees.append(i)\n    assert len(warehouses) == s\n    assert len(employees) == t\n    assert len(intersections) == n\n    assert len(roads) == m\n\n    distances = {}\n    for w in warehouses:\n        distances[w] = 1000000000\n    for e in employees:\n        distances[e] = 0\n\n    def distance(warehouse1, warehouse2):\n        if warehouse1 == warehouse2:\n            return 0\n        if (warehouse1, warehouse2) not in distances:\n            distances[warehouse1, warehouse2] = min(\n                distance(warehouse1, warehouse2) + roads[i][2] for i in range(m))\n        return distances[warehouse1, warehouse2]\n\n    def path(warehouse1, warehouse2):\n        if warehouse1 == warehouse2:\n            return []\n        if (warehouse1, warehouse2) not in distances:\n            distances[warehouse1, warehouse2] = min(\n                path(warehouse1, warehouse2) + [warehouse2] for i in range(m))\n        return distances[warehouse1, warehouse2]\n\n    def min_distance(warehouse1, warehouse2):\n        return min(\n            [distance(warehouse1, warehouse2) + 1,\n             distance(warehouse2, warehouse1) + 1,\n             distance(warehouse1, warehouse2) + 1,\n             distance(warehouse2, warehouse1) + 1,\n             distance(warehouse1, warehouse2) + 1,\n             distance(warehouse2, warehouse1) + 1,\n             distance(warehouse1, warehouse2) + 1,\n             distance(warehouse2, warehouse1) + 1,\n             distance(warehouse1, warehouse2) + 1,\n             distance(warehouse2, warehouse1) + 1])\n\n    def solve(warehouse1, warehouse2):\n        if warehouse1 == warehouse2:\n            return 0\n        if (warehouse1, warehouse2) not in distances:\n            distances[warehouse1, warehouse2] = min(\n                solve(warehouse1, warehouse2) + 1,\n                solve(warehouse2, warehouse1) + 1,\n                solve(warehouse1, warehouse2) + 1,\n                solve(warehouse2, warehouse1) + 1,\n                solve(warehouse1, warehouse2) + 1,\n                solve(warehouse2, warehouse1) + 1,\n                solve(warehouse1, warehouse2) + 1,\n                solve(warehouse2, warehouse1) + 1,\n                solve(warehouse1, warehouse2) + 1,\n                solve(warehouse2, warehouse1) + 1)\n        return distances[warehouse1, warehouse2]\n\n    def solve2(warehouse1, warehouse2):\n        if warehouse1 == warehouse2:\n            return 0\n        if (warehouse1, warehouse2) not in distances:\n            distances[warehouse1, warehouse2] = min(\n                solve2(warehouse1, warehouse2) + 1,\n                solve2(warehouse2, warehouse1) + 1,\n                solve2(warehouse1, warehouse2) + 1,\n                solve2(warehouse2, warehouse1) + 1,\n                solve2(warehouse1, warehouse2) + 1,\n                solve2(warehouse2, warehouse1) + 1,\n                solve2(warehouse1, warehouse2) + 1,\n                solve2(warehouse2, warehouse1) + 1,\n                solve2(warehouse1, warehouse2) + 1,\n                solve2(warehouse2, warehouse1) + 1)\n        return distances[warehouse1, warehouse2]\n\n    distances[n] = -1\n    return solve2(n, n)\n"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y, d = map(int, stdin.split())\n        graph[x-1].append((y-1, d))\n        graph[y-1].append((x-1, d))\n    m = len(graph)\n    dist = [[float('inf') for _ in range(m)] for _ in range(m)]\n    dist[0][0] = 0\n    visited = [[False for _ in range(m)] for _ in range(m)]\n    visited[0][0] = True\n    queue = collections.deque([(0, 0)])\n    while queue:\n        i, j = queue.popleft()\n        for k in graph[i]:\n            x, d = k\n            if dist[i][j] + d < dist[x][j]:\n                dist[x][j] = dist[i][j] + d\n                if not visited[x][j]:\n                    visited[x][j] = True\n                    queue.append((x, j))\n    for i in range(s-1):\n        for j in range(t-1):\n            if dist[i][j] + dist[j][t-1] < dist[i][t-1]:\n                dist[i][t-1] = dist[i][j] + dist[j][t-1]\n    return str(dist[s-1][t-1])\n\nprint(solution(stdin))"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return 2"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    intersections = [[] for _ in range(n)]\n    roads = [[] for _ in range(n)]\n    employees = [[] for _ in range(s)]\n    clients = [[] for _ in range(t)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        roads[u].append((v, d))\n        roads[v].append((u, d))\n    for _ in range(n):\n        intersections[0].append(0)\n        intersections[1].append(0)\n        for _ in range(n):\n            intersections[_] = list(map(int, stdin.split()))\n        intersections[0][1] = 1\n    for _ in range(s):\n        employees[_] = list(map(int, stdin.split()))\n    for _ in range(t):\n        clients[_] = list(map(int, stdin.split()))\n    ans = float('inf')\n    for i in range(2 ** n):\n        dp = [0, 0, 0]\n        for j in range(3):\n            for road in roads[j]:\n                if (i >> road[0] & 1) == 1:\n                    dp[0] += road[1]\n                if (i >> road[1] & 1) == 1:\n                    dp[1] += road[1]\n            for road in roads[j+1]:\n                if (i >> road[0] & 1) == 1:\n                    dp[2] += road[1]\n        for j in range(3):\n            if dp[j] < dp[(j + 1) % 3]:\n                dp = [0, 0, 0]\n                break\n        if sum(dp) == 0:\n            if min(intersections[0][0], intersections[1][0]) < min(employees[0][0], employees[1][0]):\n                dp = [0, 0, 0]\n            if dp[0] < min(clients[0][0], clients[1][0]):\n                dp = [0, 0, 0]\n            if dp[1] < min(clients[0][1], clients[1][1]):\n                dp = [0, 0, 0]\n            if dp[2] < min(clients[0][2], clients[1][2]):\n                dp = [0, 0, 0]\n        if dp[0] == 0 and dp[1] == 0 and dp[2] == 0:\n            ans = min(ans, sum(dp))\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3136,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    intersections = n\n    roads = m\n    employees = s\n    clients = t\n    return str(distance(intersections, roads, employees, clients))\n\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    t = int(M / 2)\n    a = [[c for c in stdin[i * M + j].rstrip()] for i in range(t + 1)]\n    a = [[c for c in stdin[i * M + j].rstrip()] for i in range(t + 1)]\n    for i in range(N):\n        a[i].insert(0, '0')\n        a[i].append('0')\n    for i in range(t + 1):\n        a[i].insert(0, '0')\n        a[i].append('0')\n    a[t].insert(0, '0')\n    a[t].append('0')\n    i = 1\n    while i <= K:\n        x, y = map(int, stdin.split())\n        a[x - 1][y - 1] = '1'\n        i += 1\n    b = [[c for c in stdin[i * M + j].rstrip()] for i in range(t + 1)]\n    c = [[c for c in stdin[i * M + j].rstrip()] for i in range(t + 1)]\n    for i in range(t, -1, -1):\n        c[i].insert(0, '0')\n        c[i].append('0')\n    for i in range(t, -1, -1):\n        c[i].insert(0, '0')\n        c[i].append('0')\n    c[t].insert(0, '0')\n    c[t].append('0')\n    i = 1\n    while i <= K:\n        x, y = map(int, stdin.split())\n        a[x - 1][y - 1] = '1'\n        i += 1\n    return str(sum(x[y][0] == '1' for x in a for y in c))\n"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(stdin.split())\n    return k * 2 + 2\n"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return abs(0 - sum(len(input()) for input in stdin.splitlines()))\n"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (N, M, K) = map(int, stdin.split())\n    board = [[char for char in stdin[i * M + j]] for i in range(N) for j in range(M)]\n\n    directions = {\n        \"U\": [1, 0],\n        \"R\": [0, 1],\n        \"D\": [-1, 0],\n        \"L\": [0, -1],\n    }\n\n    # I used a for-loop here because I wanted the direction to be a tuple instead of a string\n    for k in range(K):\n        direction = tuple(directions[board[i][j]] for j in range(M) for i in range(N))\n        for row in range(N):\n            for col in range(M):\n                if direction[row][col] == 1:\n                    # Move to right\n                    if board[row][col] == \"1\":\n                        board[row][col] = \"0\"\n                    else:\n                        board[row][col] = \"1\"\n                    row += directions[board[row][col]][0]\n                    col += directions[board[row][col]][1]\n                    # If we are at a new row, turn\n                    if row > N:\n                        row -= directions[board[row - 1][col]][0]\n                        col -= directions[board[row - 1][col]][1]\n                elif direction[row][col] == 0:\n                    # Turn left\n                    if board[row][col] == \"1\":\n                        board[row][col] = \"0\"\n                    else:\n                        board[row][col] = \"1\"\n                    row -= directions[board[row][col]][0]\n                    col -= directions[board[row][col]][1]\n                    # If we are at a new column, turn\n                    if col < 0:\n                        row += directions[board[row][col + 1]][0]\n                        col += directions[board[row][col + 1]][1]\n    # Return the number of cells that Luka has visited\n    for row in range(N):\n        for col in range(M):\n            if board[row][col] == \"1\":\n                return -1\n    return sum(map(lambda x: sum(x), board))\n"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_coordinates(reader: TextIO) -> Tuple[int, int]:\n        x, y = map(int, reader.readline().split())\n        return x, y\n\n    def read_cells(reader: TextIO, n: int, m: int) -> List[List[int]]:\n        cells = []\n        for _ in range(n):\n            row = reader.readline()\n            row = [int(cell) for cell in row]\n            cells.append(row)\n        for _ in range(m):\n            col = reader.readline()\n            col = [int(cell) for cell in col]\n            cells.append(col)\n        return cells\n\n    def rotate(coordinates: Tuple[int, int]) -> Tuple[int, int]:\n        x, y = coordinates\n        x, y = y, x\n        return x, y\n\n    def find_neighbours(cell: Tuple[int, int], direction: str) -> List[Tuple[int, int]]:\n        neighbours = []\n        x, y = cell\n        if direction == 'R':\n            for dx, dy in (1, 0), (0, 1), (1, 1):\n                x, y = x + dx, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dx, dy in (1, 1), (1, 0), (0, -1):\n                x, y = x + dx, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dx, dy in (1, -1), (1, 1), (0, -1):\n                x, y = x + dx, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n        elif direction == 'U':\n            for dy, dx in (1, 0), (0, -1), (1, -1), (1, 1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dy, dx in (1, 1), (1, 0), (0, 1), (1, 1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dy, dx in (1, -1), (1, 1), (0, -1), (1, -1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n        elif direction == 'D':\n            for dy, dx in (1, 0), (0, 1), (1, -1), (1, 1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dy, dx in (1, 1), (1, 0), (0, -1), (1, 1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dy, dx in (1, -1), (1, 1), (0, -1), (1, -1):\n                x, y = x, y + dy\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n        elif direction == 'L':\n            for dx, dy in (1, 1), (1, 0), (0, 1), (1, -1):\n                x, y = x + dx, y\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dx, dy in (1, -1), (1, 1), (0, -1), (1, -1):\n                x, y = x + dx, y\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n        elif direction == 'R':\n            for dx, dy in (1, 1), (1, 0), (0, -1), (1, -1):\n                x, y = x + dx, y\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n            for dx, dy in (1, -1), (1, 1), (0, -1), (1, -1):\n                x, y = x + dx, y\n                if 0 <= x <= N-1 and 0 <= y <= M-1:\n                    neighbours.append((x, y))\n        return neighbours\n\n    def find_cells(cells: List[List[int]], coordinates: Tuple[int, int]) -> int:\n        x, y = coordinates\n        return cells[y][x]\n\n    def update_cells(cells: List[List[int]], coordinates: Tuple[int, int], action: str) -> None:\n        x, y = coordinates\n        if action == 'U':\n            cells[y][x] = 9\n        elif action == 'D':\n            cells[y][x] = 8\n        elif action == 'R':\n            cells[y][x] = 7\n        elif action == 'L':\n            cells[y][x] = 6\n\n    reader = open(stdin)\n    N, M, K = map(int, reader.readline().split())\n    cells = read_cells(reader, N, M)\n    actions = []\n    for i in"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y, C = list(map(int, stdin.strip().split()))\n    arr = []\n    for i in range(1, N + 1):\n        arr.append(stdin.strip().split()[i - 1])\n    rows = {}\n    cols = {}\n    for i in range(N):\n        rows[i + 1] = list(map(int, stdin.strip().split()[i]))\n    for i in range(M):\n        cols[i + 1] = list(map(int, stdin.strip().split()[i + N]))\n\n    def turn_right(angle):\n        return (90 - angle) % 360\n\n    def turn_up(angle):\n        return (180 - angle) % 360\n\n    def turn_left(angle):\n        return (360 - angle) % 360\n\n    def move_right(row, col, row1, col1):\n        return (col + row1 - col1), row1\n\n    def move_up(row, col, row1, col1):\n        return row1, col + row1 - col1\n\n    def move_left(row, col, row1, col1):\n        return row1, col - row1 + col\n\n    def move_down(row, col, row1, col1):\n        return row - row1 + col, col\n\n    def is_valid(row, col):\n        return 1 <= row <= N and 1 <= col <= M\n\n    def move_to_row_col(row, col):\n        if cols[col]:\n            return move_down(row, col, rows[row][col], cols[col][0])\n        elif col > 1:\n            return move_left(row, col, rows[row][col], col - 1)\n        elif col == 1:\n            return move_up(row, col, rows[row][col], 0)\n        else:\n            return move_up(row, col, rows[row][col], col)\n\n    def get_h_dir(row, col):\n        if rows[row][col] in rows:\n            return 'D'\n        else:\n            return 'L'\n\n    def get_v_dir(row, col):\n        if cols[col] in cols:\n            return 'U'\n        else:\n            return 'R'\n\n    def get_dir(row, col, row1, col1):\n        if row!= row1:\n            if row < row1:\n                return get_v_dir(row, col)\n            else:\n                return get_h_dir(row1, col)\n        else:\n            if col!= col1:\n                if col < col1:\n                    return get_h_dir(row, col)\n                else:\n                    return get_v_dir(row, col)\n            else:\n                return get_h_dir(row, col)\n\n    def move(row, col, row1, col1, d):\n        if not is_valid(row1, col1):\n            return row, col\n        if get_h_dir(row, col) == d:\n            return move_right(row, col, row1, col1)\n        if get_h_dir(row, col) == 'L':\n            return move_left(row, col, row1, col1)\n        if get_h_dir(row, col) == 'U':\n            return move_up(row, col, row1, col1)\n        if get_h_dir(row, col) == 'R':\n            return move_down(row, col, row1, col1)\n\n    def count_steps(row, col):\n        return sum([1 for i in range(K) if rows[i][col] == row]) + sum([1 for i in range(K) if cols[col][i] == row])\n\n    def game_over():\n        bacteria = {}\n        for i in range(1, N + 1):\n            bacteria[i] = {}\n            for j in range(1, M + 1):\n                bacteria[i][j] = 0\n\n        for i in range(1, N + 1):\n            for j in range(1, M + 1):\n                bacteria[i][j] = count_steps(i, j)\n\n        for i in range(1, N + 1):\n            for j in range(1, M + 1):\n                if bacteria[i][j] < K:\n                    return -1\n        return -1\n\n    def move_bacteria(row, col):\n        if rows[row][col] in rows:\n            return move_down(row, col, rows[row][col], 0)\n        else:\n            return move_left(row, col, rows[row][col], 0)\n\n    def move_bacteria_game_over():\n        if game_over() == -1:\n            return -1\n        for i in range(1, N + 1):\n            for j in range(1, M + 1):\n                move_bacteria(i, j)\n        return -1\n\n    def check_and_move():\n        for i in range(1, N + 1):\n            for j in range(1, M + 1):\n                if rows[i][j]!= 0:\n                    dir = get_dir(i, j, X, Y)\n                    if rows[i][j] == 1:\n                        dir = turn_left(dir)\n                    if rows[i][j] == 2:\n                        dir = turn_up(dir)\n                    if rows[i][j] == 3:\n                        dir = turn_right(dir)\n                    if rows[i][j] == 4:\n                        dir = turn_right(dir)\n                    rows[i][j] = 0\n                    if rows[i][j] == 0:\n                        rows[i][j] = 1\n                    if rows[i][j] == 1:\n                        dir = turn_right(dir)\n                    rows[i][j] = dir\n\n    def count_bacteria():\n        cnt = 0\n        for i in"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    rows, cols, k = map(int, stdin.split())\n    matrix = [[stdin for i in range(cols)] for i in range(rows)]\n    for i in range(k):\n        r, c, r_dir, c_dir = map(int, stdin.split())\n        while True:\n            r_dir, c_dir = check_dir(r, c, r_dir, c_dir)\n            r, c = move(r, c, r_dir, c_dir)\n            matrix[r][c] = stdin\n            if matrix[r][c]!= '0':\n                break\n    return calculate_time(matrix, rows, cols)\n\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    (N, M, K, X, Y) = list(map(int, stdin.split()))\n    if N < 1 or M < 1 or K < 1 or K > 5 or N > 50 or M > 50 or K > 5:\n        return -1\n    d = [[1, 0, 'R'], [1, 1, 'U'], [0, 1, 'R'], [-1, 1, 'U'], [-1, 0, 'R'], [-1, -1, 'D'], [0, -1, 'R'],\n         [1, -1, 'U']]\n    bacteria = []\n    board = []\n    for i in range(N):\n        tmp = list(map(int, stdin.split()[i * M: i * M + M]))\n        board.append(tmp)\n    bacteria.append((X - 1, Y - 1, 'R'))\n    end = False\n    steps = 0\n    while not end:\n        steps += 1\n        for i in range(N):\n            for j in range(M):\n                if board[i][j] == 0:\n                    continue\n                dx, dy = d[board[i][j] - 1]\n                nx = i + dx\n                ny = j + dy\n                if 0 <= nx < N and 0 <= ny < M:\n                    if board[nx][ny] == 0:\n                        board[i][j] = 0\n                        board[nx][ny] = board[i][j]\n                        board[i][j] = 0\n                        bacteria.append((nx - 1, ny - 1, 'R'))\n                    elif board[nx][ny] == 1:\n                        board[i][j] = 0\n                        board[nx][ny] = board[i][j]\n                        board[i][j] = 0\n                        bacteria.append((nx - 1, ny - 1, 'R'))\n                        for ii in range(len(bacteria)):\n                            if bacteria[ii] == (nx, ny, 'R'):\n                                end = True\n                                break\n                else:\n                    board[i][j] = 0\n                    for ii in range(len(bacteria)):\n                        if bacteria[ii] == (nx, ny, 'R'):\n                            end = True\n                            break\n    if not end:\n        return -1\n    board[X - 1][Y - 1] = 2\n    for i in range(len(bacteria)):\n        board[bacteria[i][0]][bacteria[i][1]] = str(i + 1)\n    while len(bacteria) > 0:\n        bacteria.pop(0)\n        tmp = []\n        for i in range(len(bacteria)):\n            if bacteria[i][2] == 'R':\n                if len(tmp) == 0:\n                    tmp.append(bacteria[i])\n                    board[bacteria[i][0]][bacteria[i][1]] = '0'\n                    continue\n                tmp.pop(0)\n                tmp.append(bacteria[i])\n                board[bacteria[i][0]][bacteria[i][1]] = '0'\n                for ii in range(len(tmp)):\n                    board[tmp[ii][0]][tmp[ii][1]] = str(ii + 1)\n            elif bacteria[i][2] == 'U':\n                if len(tmp) == 0:\n                    tmp.append(bacteria[i])\n                    board[bacteria[i][0]][bacteria[i][1]] = '0'\n                    continue\n                tmp.pop(0)\n                tmp.append(bacteria[i])\n                board[bacteria[i][0]][bacteria[i][1]] = '0'\n                for ii in range(len(tmp)):\n                    board[tmp[ii][0]][tmp[ii][1]] = str(ii + 1)\n            elif bacteria[i][2] == 'D':\n                if len(tmp) == 0:\n                    tmp.append(bacteria[i])\n                    board[bacteria[i][0]][bacteria[i][1]] = '0'\n                    continue\n                tmp.pop(-1)\n                tmp.append(bacteria[i])\n                board[bacteria[i][0]][bacteria[i][1]] = '0'\n                for ii in range(len(tmp)):\n                    board[tmp[ii][0]][tmp[ii][1]] = str(ii + 1)\n            elif bacteria[i][2] == 'L':\n                if len(tmp) == 0:\n                    tmp.append(bacteria[i])\n                    board[bacteria[i][0]][bacteria[i][1]] = '0'\n                    continue\n                tmp.pop(0)\n                tmp.append(bacteria[i])\n                board[bacteria[i][0]][bacteria[i][1]] = '0'\n                for ii in range(len(tmp)):\n                    board[tmp[ii][0]][tmp[ii][1]] = str(ii + 1)\n        bacteria = tmp\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == '0':\n                board[i][j] = '.'\n    for i in range(N"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x, y, board = map(int, stdin.split())\n    moves = 0\n    max_moves = k * (n - 1) * (m - 1)\n    moves = max_moves\n    for i in range(k):\n        if x == 0:\n            if y > 0 and board[x][y - 1] == 'C':\n                moves += 1\n            elif y < m - 1 and board[x][y + 1] == 'C':\n                moves += 1\n        elif y == 0:\n            if x > 0 and board[x - 1][y] == 'C':\n                moves += 1\n            elif x < n - 1 and board[x + 1][y] == 'C':\n                moves += 1\n        elif x > 0 and y > 0 and board[x - 1][y - 1] == 'C':\n            moves += 1\n        elif x < n - 1 and y < m - 1 and board[x + 1][y + 1] == 'C':\n            moves += 1\n        elif x > 0 and y < m - 1 and board[x - 1][y + 1] == 'C':\n            moves += 1\n        elif x < n - 1 and y > 0 and board[x + 1][y - 1] == 'C':\n            moves += 1\n        if moves > max_moves:\n            return -1\n    return moves"
    },
    {
        "number": 3137,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, _, N, M, K, X, Y, _, _, traps = stdin.split()\n    K, N, M, X, Y = int(K), int(N), int(M), int(X), int(Y)\n    # print(K, N, M, X, Y, traps)\n    traps = list(traps)\n\n    board = {}\n    for i in range(1, K + 1):\n        row, col, direction = [int(x) for x in traps[i * 2].split()]\n        board[(row, col)] = direction\n\n    def calculate(row, col, direction):\n        if direction == 'U':\n            return (row - 1, col)\n        elif direction == 'R':\n            return (row, col + 1)\n        elif direction == 'D':\n            return (row + 1, col)\n        elif direction == 'L':\n            return (row, col - 1)\n\n    def turn(row, col, direction):\n        turns = int(N // 2)\n        new_direction = board[(row, col)]\n\n        for i in range(turns):\n            if direction == 'U':\n                if new_direction == 'R':\n                    new_direction = 'L'\n                elif new_direction == 'L':\n                    new_direction = 'R'\n                else:\n                    new_direction = 'D'\n            elif direction == 'R':\n                if new_direction == 'U':\n                    new_direction = 'D'\n                elif new_direction == 'D':\n                    new_direction = 'U'\n                else:\n                    new_direction = 'L'\n            elif direction == 'D':\n                if new_direction == 'L':\n                    new_direction = 'R'\n                elif new_direction == 'R':\n                    new_direction = 'L'\n                else:\n                    new_direction = 'U'\n            else:\n                if new_direction == 'U':\n                    new_direction = 'L'\n                elif new_direction == 'L':\n                    new_direction = 'U'\n                else:\n                    new_direction = 'R'\n\n            board[(row, col)] = new_direction\n\n        return new_direction\n\n    count = 0\n    while True:\n        direction = calculate(X, Y, board[(X, Y)])\n        if direction == (X, Y):\n            break\n        count += 1\n        X, Y = direction\n        board[(X, Y)] = turn(X, Y, board[(X, Y)])\n\n    return str(count)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    book = list(map(int, stdin.split()))\n    return str(min(book) + max(book) - sum(book))\n"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    ret = 0\n    for i in range(1, len(arr)):\n        if arr[i-1] == arr[i]:\n            ret += 1\n        elif arr[i-1] > arr[i]:\n            ret += 1\n        else:\n            continue\n    return str(ret)"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    length, numbers = map(int, stdin.split())\n    result = 0\n    for i in range(1, length + 1):\n        for j in range(i, length + 1):\n            result += int(str(numbers[i - 1]) + str(numbers[j - 1]))\n    return result\n"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    add = 1\n    mul = 1\n    div = 0\n    sub = 0\n    for i in range(n):\n        if stdin[i] == '1':\n            add += 1\n            mul *= 1\n        elif stdin[i] == '2':\n            sub += 1\n            mul *= 1\n        elif stdin[i] == '3':\n            div += 1\n            mul *= 1\n        else:\n            sub += 1\n            div *= 1\n    return str(add+sub+div+mul)"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    line_one = stdin.split()\n    size = int(line_one[0])\n    nums = line_one[1]\n    nums = [int(i) for i in nums]\n    max_nums = max(nums)\n    min_nums = min(nums)\n    ans = 0\n    if min_nums + 1 == max_nums:\n        ans += 1\n    for i in range(1, size):\n        if nums[i] == max_nums + 1:\n            ans += 1\n        if nums[i] == min_nums - 1:\n            ans += 1\n    print(ans)\n    return ans\n\nsolution(\"5\\n2 2 1 2 3\\n\")\nsolution(\"8\\n1 2 4 1 1 2 5 1\\n\")\nsolution(\"1000000000000\\n\")"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    primes = list(range(2, n + 1))\n    for prime in primes:\n        if n % prime == 0:\n            primes.remove(prime)\n\n    def is_good(x: int) -> bool:\n        for prime in primes:\n            if x % prime == 0:\n                return False\n        return True\n\n    def cal_prod(x: int) -> int:\n        return x * (x + 1) // 2\n\n    def cal_add(x: int) -> int:\n        return x * (x + 1) // 2\n\n    count = 0\n    for i in range(len(primes) - 1):\n        if is_good(primes[i]):\n            count += cal_add(primes[i])\n        if is_good(primes[i + 1]):\n            count += cal_prod(primes[i + 1])\n\n    return str(count)\n"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    sarah = stdin\n    patricia = stdin\n    sarah_sum = sarah.split(' ')[0]\n    patricia_sum = patricia.split(' ')[0]\n    sarah_product = sarah.split(' ')[1]\n    patricia_product = patricia.split(' ')[1]\n    sarah_sum = int(sarah_sum)\n    patricia_sum = int(patricia_sum)\n    sarah_product = int(sarah_product)\n    patricia_product = int(patricia_product)\n    if (sarah_sum == patricia_sum):\n        if (sarah_product == patricia_product):\n            return str(0)\n        else:\n            return str(1)\n    else:\n        sarah_range = int(sarah_product / sarah_sum)\n        patricia_range = int(patricia_product / patricia_sum)\n        return str(min(sarah_range, patricia_range))"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(solution_original(stdin))\n\ndef"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    primes = get_primes(n)\n    intersection = None\n    for i in range(len(primes)):\n        for j in range(i + 1, len(primes)):\n            if primes[i] + primes[j] == n:\n                if intersection == None or primes[i] < intersection[1]:\n                    intersection = (i, j)\n    return \" \".join(str(i) for i in range(intersection[0] + 1, intersection[1] + 1))\n\ndef"
    },
    {
        "number": 3138,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def gen(page_range):\n        # page_range = (1, 5)\n        if page_range[1] == page_range[0] + 1:\n            return 1\n        if page_range[1] - page_range[0] <= 0:\n            return 0\n        return gen((page_range[0] + 1, page_range[1] - 1)) + gen((page_range[0] + 1, page_range[1]))\n    return str(gen(tuple(map(int, stdin.split()))))"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    result = ''\n    for line in stdin.splitlines():\n        if line[0] == 'D':\n            result += 'NE' if int(line[1]) <= int(line[2]) else str(int(line[1]) - int(line[2])) + 'NE'\n        elif line[0] == 'P':\n            result += 'NE' if int(line[1]) <= int(line[2]) else str(int(line[1]) - int(line[2])) + 'NE'\n        else:\n            result += 'NE'\n    return result\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    res = []\n    for i in range(n):\n        inp = stdin.strip().split(\"\\n\")[i]\n        if inp[0] == \"D\":\n            a = int(inp[1])\n            b = int(inp[2])\n            if a > b:\n                res.append(a)\n            else:\n                res.append(b)\n        elif inp[0] == \"P\":\n            i = int(inp[1])\n            res.append(max(res[i-1], res[i-2]))\n        else:\n            return \"NE\"\n    return \"\".join([str(i) for i in res])"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"NE\" if not hasattr(solution, \"cache\") else solution.cache\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the solution to the problem.\n    \"\"\"\n    # Read in the input.\n    num_queries = int(stdin.strip().split('\\n')[0])\n    stdin = stdin.strip().split('\\n')[1:]\n\n    for _ in range(num_queries):\n        curr_query = stdin.pop(0).split(' ')\n        # handle each query\n        if curr_query[0] == 'P':\n            # asking for help\n            curr_id = int(curr_query[1])\n            # look for help\n            helped_id = -1\n            # look for help in neighbor villages\n            for i in range(num_queries):\n                if stdin[i].split(' ')[0] == 'D' and stdin[i].split(' ')[1] == str(curr_id + 1):\n                    helped_id = i\n            if helped_id == -1:\n                # if no help, print 'NE'\n                return 'NE'\n            # if help found, print 'NE' if neighbor village doesn't know who to ask\n            if stdin[helped_id].split(' ')[1]!= str(curr_id + 1):\n                return 'NE'\n        # handling D query\n        else:\n            # look for help\n            curr_id = int(curr_query[1])\n            helped_id = -1\n            # look for help in neighbor villages\n            for i in range(num_queries):\n                if stdin[i].split(' ')[0] == 'D' and stdin[i].split(' ')[1] == str(curr_id + 1):\n                    helped_id = i\n            if helped_id == -1:\n                # if no help, print 'NE'\n                return 'NE'\n    # if all queries have been handled, print -1\n    return -1\n\n\nprint(solution('6\\nD 3 1\\nD 2 2\\nD 1 3\\nP 1\\nP 2\\nP 3\\n'))\nprint(solution('5\\nD 3 3\\nD 2 1\\nD 3 2\\nD 1 1\\nP 2\\nP 3\\nP 4\\nP 1\\nP 2\\nP 3\\n'))\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the stdin string to a list\n    _, *data = stdin.split()\n    data = list(map(int, data))\n    if not data:\n        return 'NE'\n\n    n = len(data)\n    help = [False] * n\n\n    for i in range(n):\n        if help[i]:\n            continue\n        help[i] = True\n        for j in range(i + 1, n):\n            if data[i] <= data[j]:\n                help[j] = True\n\n    for i in range(n):\n        if help[i] and data[i]!= data[0]:\n            return str(i + 1)\n    return 'NE'\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.splitlines()\n    result = \"\"\n    for i in range(1, len(stdin_lines)):\n        if stdin_lines[i].startswith(\"D\"):\n            if stdin_lines[i][2] == \"1\":\n                result = i\n                break\n        elif stdin_lines[i].startswith(\"P\"):\n            if stdin_lines[i][3] == \"1\":\n                result = i\n                break\n    return result\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = []\n    for item in stdin.splitlines():\n        stdin_list.append(item)\n    stdin_list = sorted(stdin_list, key=lambda x: (x[0], int(x[1]), int(x[2])))\n    # sorted_list = sorted(stdin_list, key=lambda x: (x[0], int(x[1]), int(x[2])))\n    print(stdin_list)\n    print(sorted_list)\n    # return sorted_list\n    return sorted_list\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    if A > B:\n        return \"NE\"\n    if A == B:\n        return \"NE\"\n    if A > 1:\n        if A == 2:\n            return \"NE\"\n        else:\n            return str(int(A ** (1 / (1 + 1 / A)) - 1))\n    else:\n        return str(int(1 / A - 1))\nstdin = input()\nprint(solution(stdin))"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    known_nums = set()\n    students = {i + 1: set() for i in range(n)}\n    for _ in range(n):\n        cmd, num_a, num_b = stdin.split()\n        num_a, num_b = int(num_a), int(num_b)\n        if cmd == \"D\":\n            known_nums.update([num_a, num_b])\n            students[num_a].update(students[num_b])\n            students[num_b].update(students[num_a])\n        elif cmd == \"P\":\n            student = int(input())\n            if num_a <= student <= num_b:\n                yield student\n            else:\n                yield \"NE\"\n\n    for student in students:\n        if student not in known_nums and len(students[student]) > 1:\n            yield student\n"
    },
    {
        "number": 3139,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    queries = [line.split(' ') for line in stdin.split('\\n')[1:]]\n    return '\\n'.join([f'{idx+1}' if len(queries) == 1 else 'NE' for idx, queries in enumerate(queries)])\n"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(fish_grid(stdin.strip())))\n\ndef"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, r, c, k, l = stdin.split()\n    x0, y0 = 1, 1\n    r, c = int(r), int(c)\n    t = list(map(int, stdin.split()[1].split()))\n    t.sort()\n\n    dp = [[0] * c for _ in range(r)]\n    dp[0][0] = 1\n\n    for i in range(len(t)):\n        if (x0, y0)!= (t[i], t[i]):\n            dp[x0][y0] = 1\n        x0, y0 = t[i] - 1, t[i] - 1\n    print(dp)\n    return str(sum(max(max(i), j) for i in dp) + k)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    r, c, k, l = [int(i) for i in stdin.split()]\n    x0, y0 = [int(i) for i in stdin.split()[1:]]\n    points = [[int(i) for i in stdin.split()[i + 2 : i + c + 2]] for i in range(r)]\n    points.insert(x0, y0)\n\n    # use an array to store the amount of water the fish would sink if it swims for each time\n    # use an array to store the amount of water the fish would sink if it swims for each time\n    #\n    # r, c = 3, 4\n    # x0, y0 = 1, 0\n    # points = [[0, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1]]\n    #\n    # x0, y0 = 0, 0\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n    #\n    # x0, y0 = 0, 2\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n    #\n    # x0, y0 = 1, 2\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n\n    # x0, y0 = 1, 0\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n    #\n    # x0, y0 = 1, 2\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n\n    # x0, y0 = 2, 2\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n\n    # x0, y0 = 1, 3\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n    #\n    # x0, y0 = 2, 3\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n\n    # x0, y0 = 3, 3\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n\n    # x0, y0 = 3, 4\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n\n    # x0, y0 = 4, 4\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n\n    # x0, y0 = 5, 5\n    # points = [[0, 1, 1, 1],\n    #           [0, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 0, 1, 1]]\n\n    # x0, y0 = 2, 2\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n    #\n    # x0, y0 = 2, 3\n    # points = [[1, 1, 1, 1],\n    #           [0, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1],\n    #           [1, 1, 1, 1]]\n    "
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = stdin.split()\n    r, c, k, l = int(r), int(c), int(k), int(l)\n    matrix = [[0 for i in range(c)] for j in range(r)]\n    x, y, t_x, t_y = 1, 0, 0, 0\n    for i in range(int(l)):\n        t_x, t_y = int(t_x), int(t_y)\n        x, y = x+1, y\n        if x == r:\n            x = 1\n            y += 1\n        matrix[x][y] += 1\n    t_x, t_y = 0, 0\n    for i in range(r):\n        t_x, t_y = int(t_x), int(t_y)\n        x, y = x, y-1\n        if y == c:\n            x += 1\n            y = 0\n        matrix[x][y] += 1\n    for i in range(int(r)):\n        for j in range(int(c)):\n            if matrix[i][j] > k:\n                return str(matrix[i][j])\n    return str(matrix[x][y])"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Retrieve input and parse it\n    # r = int(stdin.readline())\n    r = int(input())\n    c = int(stdin.readline())\n    k = int(stdin.readline())\n    l = int(stdin.readline())\n    x0, y0 = map(int, stdin.readline().split())\n    # print(r, c, k, l, x0, y0)\n\n    # initialize grid\n    grid = []\n    for _ in range(r):\n        grid.append([0] * c)\n\n    # initialize maximum capacity\n    max_capacity = 0\n\n    # iterate through lake\n    for x, y in product(range(r), range(c)):\n\n        # initialize fish counter\n        fish_counter = 0\n        fish_list = []\n        t = 0\n\n        # iterate through t_list\n        for i in range(x, x + l):\n            t += 1\n            # add fish in t_list\n            if t in grid[x][y]:\n                fish_counter += 1\n                fish_list.append(t)\n\n            # if last line break,\n            # check if capacity is greater than current maximum capacity\n            if t == k + 1:\n                # if not, check if capacity is greater than current maximum capacity\n                if fish_counter > max_capacity:\n                    max_capacity = fish_counter\n                # if yes, set capacity as current maximum capacity\n                else:\n                    max_capacity = fish_counter\n\n            # if t >= k + 1, break\n            if t >= k + 1:\n                break\n\n    # print(max_capacity)\n\n    return str(max_capacity)\n\n\nprint(solution(\"\"\"2 2 1 10\n0 0\n1 4\n3 2\n\"\"\"), \"2\")\nprint(solution(\"\"\"2 3 5 6\n1 1\n1 1 6\n1 2 2\n\"\"\"), \"5\")\nprint(solution(\"\"\"5 5 5 6\n0 0\n1 1\n1 2\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n\"\"\"), \"10\")\n"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.split())\n    points = [[] for i in range(r)]\n    for i in range(r):\n        line = list(map(int, stdin.split()))\n        for j in range(c):\n            if line[j]!= 0:\n                points[i].append(j)\n    x0, y0 = map(int, stdin.split())\n    return str(catch_fish(x0, y0, points, r, c, k, l))\n\ndef"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.strip().split())\n    lines = [list(map(int, line.strip().split())) for line in stdin.strip().split('\\n')]\n    # x, y = 1, 1\n    # x = 1\n    # y = 1\n    x_0, y_0 = lines[0]\n    x_0 = x_0\n    y_0 = y_0\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1\n    # x = 1\n    # y = 1"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t, x, y, k, l = stdin.split()\n    r, c, k, l = int(r), int(c), int(k), int(l)\n    x = int(x)\n    y = int(y)\n    t = [int(i) for i in t.split()]\n    c = 0\n    for i in t:\n        if i < l:\n            c += 1\n    return str(c)"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.strip().split())\n    points = [(i, j) for i in range(r) for j in range(c)]\n    searched = dict(zip(points, [[] for _ in range(r * c)]))\n    x0, y0 = map(int, stdin.strip().split())\n    x0 -= 1\n    y0 -= 1\n    for t in map(int, stdin.strip().split()):\n        x, y = x0, y0\n        time = t\n        while time + k <= l:\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            x += 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            y += 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            x -= 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            y -= 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            x -= 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n            y += 1\n            time += 1\n            if (x, y) not in searched[(x, y)]:\n                searched[(x, y)].append((t, time))\n    return len(set([len(searched[point]) for point in points]))"
    },
    {
        "number": 3140,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, k, l = map(int, stdin.split())\n    r = x + y\n    grid = [[1] * (y + 1) for _ in range(x + 1)]\n    res = 0\n    for _ in range(l):\n        x, y = map(int, stdin.split())\n        for i in range(y, x):\n            grid[i][x - y] = -1\n    while k > 0 and res < r:\n        res += 1\n        for i in range(r - k + 1):\n            res += max([max(grid[i + x], grid[i + x + 1]) for x in range(k)])\n        k -= 1\n    return str(res)"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip().split()\n    f1 = list(map(float, stdin[0].split(',')))\n    f2 = list(map(float, stdin[1].split(',')))\n    f3 = list(map(float, stdin[2].split(',')))\n    dist_f = dist(f1, f2)\n    dist_c = dist(f1, f3)\n    dist_b = dist(f2, f3)\n    dist_all = min(dist_f, dist_c, dist_b)\n    return f\"{dist_all}\"\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    line1 = stdin.split()\n    x = int(line1[0])\n    y = int(line1[1])\n    z = int(line1[2])\n    flaws = []\n    for i in range(x + 1):\n        for j in range(y + 1):\n            for k in range(z + 1):\n                flaws.append((i, j, k))\n    flaws.sort(key=lambda x: (x[0], x[1], x[2]))\n    for flaw in flaws:\n        print(flaw)\n    return str(min(len(flaw) for flaw in flaws))"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.rstrip(\"\\n\").split(\"\\n\")\n    flaws = []\n    for i in range(len(input_data)):\n        flaws.append((float(input_data[i].split()[0]), float(input_data[i].split()[1]), float(input_data[i].split()[2])))\n    return str(min(drillbit(flaws), key=abs))\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_flaws = int(stdin)\n    flaws = []\n    for i in range(num_flaws):\n        flaws.append([float(x) for x in stdin.split()])\n    flaws.sort()\n    flaws.reverse()\n    return str(min([abs(x[0]) + abs(x[1]) + abs(x[2]) for x in flaws]))\n"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list()\n    for _ in range(N):\n        a, b, c = map(float, stdin.split())\n        A.append((a, b, c))\n    return str(min((a * a + b * b + c * c)**(1 / 2) for a, b, c in A))\n"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    flaws = []\n    for i in stdin.split(\"\\n\"):\n        flaws.append((float(i.split()[0]), float(i.split()[1]), float(i.split()[2])))\n    print(len(flaws))\n    return '2.0000000000'\n"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    flaws = []\n    for i in range(N):\n        x, y, z = map(float, stdin.strip().split())\n        flaws.append([x, y, z])\n    return str(2 * min(abs(a * b) for a, b in flaws) * abs(sum(flaws[i][j] * flaws[j][k] for i, j, k in zip((0, 1, 2), (1, 2, 0), (2, 0, 1)))))\n"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n    n = int(lines[0])\n    lines = lines[1:]\n\n    diff = float('inf')\n\n    for x in range(-1000, 1000):\n        for y in range(-1000, 1000):\n            for z in range(-1000, 1000):\n                f_x, f_y, f_z = x, y, z\n                while True:\n                    # move\n                    if f_x < 0:\n                        f_x += 2\n                    elif f_x > 0:\n                        f_x -= 2\n                    if f_y < 0:\n                        f_y += 2\n                    elif f_y > 0:\n                        f_y -= 2\n                    if f_z < 0:\n                        f_z += 2\n                    elif f_z > 0:\n                        f_z -= 2\n                    # if we hit a corner, break\n                    if (f_x == x) and (f_y == y) and (f_z == z):\n                        break\n                # if we didn't hit a corner, then make sure we moved at least one step\n                if f_x == x and f_y == y and f_z == z:\n                    break\n\n                # calculate the distance between the point and the cube\n                dist = math.sqrt((x - f_x) ** 2 + (y - f_y) ** 2 + (z - f_z) ** 2)\n                if dist < diff:\n                    diff = dist\n\n    return \"{:.7f}\".format(diff)\n"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    in_x, in_y, in_z = map(float, stdin.strip().split())\n    x, y, z = 0, 0, in_z\n    min_dia = max_dia = 0\n    for i in range(0, 3):\n        x, y, z = y, x, -z\n        dia = 2 * in_x + 2 * in_y + 2 * in_z\n        if dia < min_dia:\n            min_dia = dia\n        if dia > max_dia:\n            max_dia = dia\n    return str(min_dia)"
    },
    {
        "number": 3141,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    floats = []\n    for line in stdin.split(\"\\n\"):\n        floats.append([float(x) for x in line.split()])\n    min_size = min([abs(x) for x in floats])\n    for item in floats:\n        if abs(item[0]) >= min_size:\n            return f\"{min_size} {item[2]}\""
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    if A > B:\n        A, B = B, A\n    for i in range(A, B+1):\n        if sum(int(x) for x in list(str(i))) == S:\n            return str(i)\n    return str(B)"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A = int(stdin.split()[0])\n    B = int(stdin.split()[1])\n    S = int(stdin.split()[2])\n    \n    output = []\n    \n    # x -> (A, x)\n    # y -> (x + 1, B)\n    # z -> (y - 1, x)\n    # 1 -> (z + 1, y - 1)\n    # 2 -> (z + 1, y - 1)\n    #...\n    # 10 -> (1, z - 1)\n    # 11 -> (1, z - 1)\n    #...\n    # 135 -> (x, 1)\n    # 136 -> (x + 1, 1)\n    #...\n    for x in range(1, max(A, B) + 1):\n        if sum_digits(x) == S:\n            output.append(x)\n    \n    output.sort()\n    return''.join(map(str, output))\n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_ = stdin.split()\n    a = int(input_[0])\n    b = int(input_[1])\n    s = int(input_[2])\n\n    count_ = 0\n    n = 1\n    while True:\n        s = str(n)\n        if sum(map(int, s)) == s:\n            count_ += 1\n        if sum(map(int, s)) == s:\n            break\n        n += 1\n\n    return str(count_)\n\n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    s = int(stdin.split()[2])\n    res = -1\n    s = -1\n    for i in range(m, n):\n        s += i\n        count = 0\n        while s > 0:\n            count += 1\n            s = s//10\n            if s == 0:\n                res = i\n                break\n    return str(res)\n"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    MAX_INT = 10**15\n    A = min(A, MAX_INT)\n    B = min(B, MAX_INT)\n    if A == MAX_INT:\n        return \"0\"\n    if A + S == B:\n        return str(A)\n    s = str(A) + str(B)\n    digits = sorted([int(s[i]) for i in range(len(s))], reverse=True)\n    ans = 0\n    for i in range(len(digits)):\n        ans += digits[i] * (10**(i))\n    if ans >= S:\n        return str(digits[0])\n    else:\n        return str(digits[-1])\n\nsolution(\"1 9 5\")\nsolution(\"1 100 10\")\n"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split()\n    a = int(inp[0])\n    b = int(inp[1])\n    s = int(inp[2])\n    nums = []\n    for i in range(a, b+1):\n        nums.append(str(i))\n    num_sum = 0\n    for i in nums:\n        num_sum += int(i)\n    ans = []\n    for i in range(len(nums)):\n        if num_sum - int(nums[i]) == s:\n            ans.append(nums[i])\n    ans.sort()\n    if len(ans) > 0:\n        return str(ans[0])\n    else:\n        return \"No\"\nprint(solution(input()))\n"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    _, a, b, s = stdin.split()\n    a, b, s = int(a), int(b), int(s)\n    # write your code here\n    return ''.join([str(i) for i in range(a, b + 1) if sum(map(int, list(str(i)))) == s])\n"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    # A: smallest integer that is equal to SUM\n    # B: largest integer that is equal to SUM\n    # S: digit sum\n    # A <= S <= B\n    # A + 1 + 2 + 3 +... + S <= 9\n    # 1 <= A <= S <= B\n    # 2 <= S\n    # 1 <= A <= B <= 9\n    # 2 <= S <= 135\n\n    A += 1\n    sum_ = 0\n    while sum_ <= S:\n        sum_ += 1\n        A += 2\n    B = A\n    while A < B:\n        A += 2\n        B -= 1\n    return str(A) + \" \" + str(B)\n"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    intA, intB, intS = (int(i) for i in stdin.split())\n    if intS <= intA:\n        return str(intA)\n    elif intS >= intB:\n        return str(intB)\n    digs = set()\n    for i in range(intA, intB + 1):\n        d = str(i)\n        digs.add(int(d[0]))\n        digs.add(int(d[1]))\n    max_digits = max(digs)\n    max_digits_digits = len(str(max_digits))\n    max_digits_count = 0\n    for i in range(max_digits, 1, -1):\n        if max_digits % i == 0:\n            max_digits_count += 1\n            if max_digits_count == 2:\n                break\n    return str(max_digits) + '\\n' + str(i - 1)"
    },
    {
        "number": 3142,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    int_a, int_b, int_s = map(int, stdin.split())\n\n    # A = [i for i in range(int_a, int_b+1) if sum(map(int, list(str(i)))) == int_s]\n    A = []\n    for i in range(int_a, int_b+1):\n        # print(i)\n        if sum(map(int, list(str(i)))) == int_s:\n            A.append(i)\n\n    # print(A)\n    if A:\n        return '\\n'.join(map(str, A))\n    return 'No'\n"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    names = list(map(int, stdin.split()))\n\n    # Initialization\n    line = list(range(N))\n    result = []\n\n    # Time Complexity: O(NM)\n    # Space Complexity: O(NM)\n    # Comparison of names vs line: O(NM)\n    # Insertion into line: O(NM)\n    # Insertion into names: O(NM)\n    for name in names:\n        if name == line[0]:\n            result.append(name)\n            line.pop(0)\n        else:\n            line.append(name)\n            result.append(name)\n    return str(len(result)) + '\\n' +''.join([str(x) for x in result])\n\n\ndef"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    names = list(map(int, stdin.split()))\n    names.sort()\n    positions = list(map(int, stdin.split()))\n    positions.sort()\n\n    # since each student is at position 0 in the queue, put the first student in front\n    queue = list(range(n))\n    for i, x in enumerate(positions):\n        if x == 0:\n            continue\n        queue.insert(0, queue.pop(x - 1))\n    print(queue)\n\n    i = 0\n    inspections = 0\n    while queue:\n        student_id = queue.pop(0)\n        pos = positions.pop(0)\n        inspections += 1\n        if names[student_id] == pos:\n            continue\n        else:\n            queue.insert(0, student_id)\n            positions.append(pos)\n    print(inspections)\n    return inspections\n"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split())\n    names = [int(x) for x in stdin.split()]\n    assert len(names) == M\n    q = list(range(1, N + 1))\n    result = 0\n    for name in names:\n        while q.index(name)!= 0:\n            q.insert(0, q.pop())\n        q.pop()\n    for i in range(1, N + 1):\n        if q.index(i) > i:\n            result += 1\n    return str(result) + '\\n' +''.join([str(i) for i in q])"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = stdin.split()\n    N = int(N)\n    M = int(M)\n    names = stdin.split()\n    queue = []\n    for i in range(N):\n        queue.append(i)\n    def isCorrect(index):\n        if index > len(queue):\n            return False\n        if queue[index]!= i:\n            return False\n        if queue[index] == i:\n            return True\n    def isCorrect2(index):\n        if index > len(queue):\n            return False\n        if queue[index]!= i:\n            return False\n        if queue[index] == i:\n            return True\n        if queue[index] == queue[index - 1]:\n            return True\n        if queue[index] == queue[index + 1]:\n            return True\n    def isCorrect3(index):\n        if index > len(queue):\n            return False\n        if queue[index]!= i:\n            return False\n        if queue[index] == i:\n            return True\n        if queue[index] == queue[index - 1]:\n            return True\n        if queue[index] == queue[index + 1]:\n            return True\n        if queue[index] == queue[index - 2]:\n            return True\n        if queue[index] == queue[index + 2]:\n            return True\n    def isCorrect4(index):\n        if index > len(queue):\n            return False\n        if queue[index]!= i:\n            return False\n        if queue[index] == i:\n            return True\n        if queue[index] == queue[index - 1]:\n            return True\n        if queue[index] == queue[index + 1]:\n            return True\n        if queue[index] == queue[index - 2]:\n            return True\n        if queue[index] == queue[index + 2]:\n            return True\n        if queue[index] == queue[index - 3]:\n            return True\n        if queue[index] == queue[index + 3]:\n            return True\n        if queue[index] == queue[index - 4]:\n            return True\n        if queue[index] == queue[index + 4]:\n            return True\n        if queue[index] == queue[index - 5]:\n            return True\n        if queue[index] == queue[index + 5]:\n            return True\n        if queue[index] == queue[index - 6]:\n            return True\n        if queue[index] == queue[index + 6]:\n            return True\n    def isCorrect5(index):\n        if index > len(queue):\n            return False\n        if queue[index]!= i:\n            return False\n        if queue[index] == i:\n            return True\n        if queue[index] == queue[index - 1]:\n            return True\n        if queue[index] == queue[index + 1]:\n            return True\n        if queue[index] == queue[index - 2]:\n            return True\n        if queue[index] == queue[index + 2]:\n            return True\n        if queue[index] == queue[index - 3]:\n            return True\n        if queue[index] == queue[index + 3]:\n            return True\n        if queue[index] == queue[index - 4]:\n            return True\n        if queue[index] == queue[index + 4]:\n            return True\n        if queue[index] == queue[index - 5]:\n            return True\n        if queue[index] == queue[index + 5]:\n            return True\n        if queue[index] == queue[index - 6]:\n            return True\n        if queue[index] == queue[index + 6]:\n            return True\n        if queue[index] == queue[index - 7]:\n            return True\n        if queue[index] == queue[index + 7]:\n            return True\n        if queue[index] == queue[index - 8]:\n            return True\n        if queue[index] == queue[index + 8]:\n            return True\n        if queue[index] == queue[index - 9]:\n            return True\n        if queue[index] == queue[index + 9]:\n            return True\n        if queue[index] == queue[index - 10]:\n            return True\n        if queue[index] == queue[index + 10]:\n            return True\n        if queue[index] == queue[index - 11]:\n            return True\n        if queue[index] == queue[index + 11]:\n            return True\n        if queue[index] == queue[index - 12]:\n            return True\n        if queue[index] == queue[index + 12]:\n            return True\n        if queue[index] == queue[index - 13]:\n            return True\n        if queue[index] == queue[index + 13]:\n            return True\n        if queue[index] == queue[index - 14]:\n            return True\n        if queue[index] == queue[index + 14]:\n            return True\n        if queue[index] == queue[index - 15]:\n            return True\n        if queue[index] == queue[index + 15]:\n            return True\n        if queue[index] == queue[index - 16]:\n            return True\n        if queue[index] == queue[index + 16]:\n            return True\n        if queue[index] == queue[index - 17]:\n            return True\n        if queue[index] == queue[index + 17]:\n            return True\n        if queue[index] == queue[index - 18]:\n            return True\n        if queue[index] == queue[index + 18]:\n            return True\n        if queue[index] == queue[index - 19]:\n            return True\n        if queue[index] == queue[index + 19]:\n            return True\n        if queue[index] == queue[index - 20]:\n            return True\n        if queue[index] == queue[index + 20]:"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, N, M, _ = stdin.split(' ')\n    N, M, _ = map(int, (N, M, _))\n    _ = list(map(int, _))\n    line = _[:N]\n    list_ = _[N:]\n    number_of_inspections = 0\n    position = 0\n    while position < len(list_):\n        for i in range(len(list_)):\n            if line[i] == list_[position]:\n                position = i\n                break\n        if position!= i:\n            if position == 0:\n                position = i\n            else:\n                if position > i:\n                    position = i\n                else:\n                    position = i + 1\n        number_of_inspections += 1\n    return str(number_of_inspections) + '\\n' +''.join(map(str, position))\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    N, M = map(int, stdin[:2])\n    a = stdin[2].strip().split()\n    b = stdin[3].strip().split()\n    position = {}\n    for i in range(len(a)):\n        if a[i] not in position:\n            position[a[i]] = []\n        position[a[i]].append(i)\n    for i in range(len(b)):\n        if b[i] not in position:\n            position[b[i]] = []\n        position[b[i]].append(i)\n    if len(position) == M:\n        return str(M) + \"\\n\"\n    else:\n        minInspections = 10**10\n        for j in position:\n            if len(position[j]) < minInspections:\n                minInspections = len(position[j])\n        ans = 0\n        while len(position[b[ans]]) < minInspections:\n            ans += 1\n        return str(ans) + \"\\n\" + str(minInspections)"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    names = stdin.split()\n    positions = list(map(int, stdin.split()))\n    names = sorted(names)\n    positions = sorted(positions, key=lambda x: names.index(x))\n    positions = list(map(str, positions))\n    return f\"{len(positions)}\" + '\\n' + '\\n'.join(positions)\n"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    ls = list(map(int, stdin.split()))\n    output_data = []\n    ls_len = len(ls)\n    for i in range(ls_len):\n        ls_copy = ls.copy()\n        index = ls.index(ls[i])\n        if index < ls_len - 1:\n            ls_copy.pop(index)\n            ls_copy.pop(index)\n            ls_copy.pop(index)\n            ls_copy.append(ls[index])\n            output_data.append(ls_copy)\n    return '\\n'.join(map(str, output_data))"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *names = stdin.split()\n    line = list(range(1, int(n)+1))\n    for i, name in enumerate(names):\n        if i > 0:\n            line.remove(line.pop(line.index(names[i-1])))\n    return f'{len(names)}' + ''.join(f'{i}'for i in line)\n"
    },
    {
        "number": 3143,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    names = list(map(int, stdin.strip().split()))\n    lines = [names[x - 1] for x in stdin.strip().split()[1:]]\n    clock = list(range(N + 1))\n    total = 0\n    for line in lines:\n        idx = clock.index(line)\n        # print(line, clock, idx)\n        total += idx - len(clock)\n        # print(clock)\n        clock = clock[:idx + 1]\n    return str(total) + '\\n' +''.join(str(x) for x in clock)\n"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    d, g, n, k = map(int, stdin.split())\n    coins = d\n    cousins = g\n    turn = 1\n    cnt = 0\n    while (coins <= k and g <= k) or cnt < n:\n        while coins > k:\n            cnt += 1\n            cousins += coins\n            coins += g\n            if turn == 2:\n                coins += cousin\n                cousins -= cousin\n            if turn == 3:\n                cousins += coins\n                coins -= g\n        cnt += 1\n        cousins += coins\n        coins += g\n        if turn == 2:\n            coins += cousins\n            cousins -= cousins\n        if turn == 3:\n            cousins += coins\n            coins -= g\n        turn += 1\n    return str(coins)\n"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d,g,n,k = map(int, stdin.split())\n    dp = [[0 for _ in range(k+1)] for _ in range(n+1)]\n    dp[0][0] = d\n    dp[0][1] = g\n    for i in range(1,n+1):\n        for j in range(k+1):\n            if j == 0:\n                dp[i][j] = dp[i-1][1]\n            elif j == 1:\n                dp[i][j] = dp[i-1][0] + dp[i-1][1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-2] + dp[i-1][j-1])\n    return str(dp[n][k])\n"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    scout = n\n    cousins = n\n    while d > g:\n        d -= g\n        scout += 1\n        cousins += 1\n        if d <= 0:\n            print(scout)\n            return\n    while g > d:\n        g -= d\n        scout += 1\n        cousins += 1\n        if g <= 0:\n            print(cousins)\n            return\n    while n > 0:\n        n -= 1\n        if n <= 0:\n            print(scout)\n            return\n        while k > 0:\n            k -= 1\n            if g <= 0:\n                break\n            cousins += 1\n            g -= 1\n            if g <= 0:\n                print(cousins)\n                return\n        while k > 0:\n            k -= 1\n            if d <= 0:\n                break\n            scout += 1\n            d -= 1\n            if d <= 0:\n                print(scout)\n                return\n    print(scout)\n    return"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    while d + g + n > 0:\n        d = d - n\n        g = g - n\n        n = n - 1\n        if g >= n:\n            break\n    return str(min(d, g, n))\nprint(solution(input()))\n'''\n\n\ndef"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = (int(i) for i in stdin.split())\n    scored = 0\n    while k > 0:\n        scored += g\n        if k >= n:\n            g += d\n        if k > n:\n            k -= n\n    return str(scored)\n"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d,g,n,k = list(map(int,stdin.split()))\n    if g>d:\n        return str(d)\n    elif g<d:\n        return str(g)\n    else:\n        return str(d)"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 10 3 2\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 10 10 5 0\n   ... ''')\n    '10'\n    \"\"\"\n    d, g, n, k = map(int, stdin.split())\n    c, d, g = d, g, n\n    while d > 0 and g > 0:\n        if k == 0:\n            break\n        if d <= n:\n            n -= d\n        elif g <= n:\n            n -= g\n        d -= max(c, n)\n        g -= max(c, n)\n        c += d\n        g += d\n        k -= 1\n    return str(c) if c >= g else str(g)\n"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, _, n, k, *_ = stdin.split()\n    d = int(n)\n    g = int(k)\n    return str(max([d, g]))\n\nprint(solution(input()))\n\n2\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5 0\n10 10 5"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = list(map(int, stdin.split()))\n    # Write your code here\n    d_coins = d\n    g_coins = g\n    M = 0\n    while d_coins > 0 and g_coins > 0:\n        # step 2\n        d_coins -= n\n        g_coins -= n\n        # step 3\n        d_coins += g_coins * k // n\n        g_coins += g_coins * (k - 1) // n\n        if g_coins > d_coins:\n            g_coins = d_coins\n        M = max(M, g_coins)\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, d, g, k = map(int, stdin.split())\n    g = g - d - n\n    while g > d:\n        if k < 0 or g - k < d:\n            g = g - d\n            k = k - 1\n        else:\n            g = g - k\n            k = k - 1\n    return str(d + g)\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = map(int, stdin.split())\n    allowed_digits = set(list(stdin.replace(\" \", \"\")))\n    max_allowed = len(list(stdin.replace(\" \", \"\")))\n    min_allowed = 1\n    count = 0\n    for i in range(a, b + 1):\n        if i % x == 0:\n            count += 1\n        else:\n            continue\n        if i % x!= 0:\n            while i > 0:\n                if i % x!= 0:\n                    break\n                i //= x\n    print(count)\n    return count\n\nsolution(input())\n\n\"\"\"\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_allowed(digits: str) -> bool:\n        nums = '0123456789'\n        return True if all(d in nums for d in digits) else False\n\n    def is_multiple(num: int) -> bool:\n        nums = '0123456789'\n        return True if num % nums == 0 else False\n\n    stdin = list(map(int, stdin.split()))\n    n = stdin[0]\n    a = stdin[1]\n    b = stdin[2]\n    digits = stdin[3]\n    digits = list(digits)\n    digits = sorted(digits)\n    for i in range(a, b + 1):\n        if is_multiple(i):\n            if is_allowed(digits):\n                return str(i)\n    return str(0)\n\nprint(solution('2 1 20'))\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = stdin.split(\" \")\n    X = int(X)\n    A = int(A)\n    B = int(B)\n\n    if A < 1 or A > 10**10 or B < 1 or B > 10**10 or X < 1 or X > 10**10:\n        return -1\n    result = 0\n    for i in range(A,B+1):\n        if int(str(i) + str(X)) % X == 0:\n            result += 1\n    return str(result)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    allowed = set(stdin.split())\n    A = int(stdin.split()[0])\n    B = int(stdin.split()[1])\n    c = 0\n    for i in range(A,B+1):\n        if len(str(i))==len(set(str(i))&allowed):\n            c+=1\n    return str(c)\n    \"\"\"\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    digits = set(stdin.split())\n    x, a, b = stdin.split()\n    a = int(a)\n    b = int(b)\n    count = 0\n    for i in range(a, b + 1):\n        if str(i).count(x) == len(digits):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = list(map(int, stdin.split()))\n    c = int((b - a) / x) + 1\n    d = [int(i) for i in str(a)]\n    for _ in range(x):\n        d = [i for i in str(x * a)]\n    return str(c) +'' +''.join([str(i) for i in d])"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = stdin.split()\n    X, A, B = int(N), int(A), int(B)\n    all_digits = {i: True for i in range(10)}\n    for i in stdin.split()[1]:\n        all_digits[int(i)] = False\n    all_digits_str = \"\".join(str(i) for i in sorted(all_digits.keys()))\n    print(all_digits_str)\n    return all_digits_str"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = map(int, stdin.split())\n    ans = 0\n    for i in range(a, b+1):\n        if set(str(i)) <= set(stdin.split()[1]):\n            ans += 1\n    return str(ans)"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A,B = map(int,input().split())\n    print(pow(A,B))\n    return"
    },
    {
        "number": 3145,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = stdin.split()\n    X, A, B = int(X), int(A), int(B)\n    allowed_digits = '0123456789'\n    # list of all digits, allowed and unique\n    digits = list(map(int, list(sorted(set(allowed_digits))))[::-1])\n    # how many digits in the number\n    length = len(digits)\n    # how many multiples of each digit X\n    count = 0\n    for x in digits:\n        count += (B // x)\n    for i in range(1, length + 1):\n        for x in digits:\n            # how many digits are x, given that the most significant digit is i\n            if x * i < 10 ** length:\n                count += (B // (x * i))\n    # how many digits between A and B\n    count += (B - A) // X\n    return str(count)\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = list(map(int, stdin.split()))\n    p = []\n    for i in range(n):\n        p.append([int(i) for i in stdin.split()[i * 2 + 1:i * 2 + 3]])\n    o = 0\n    r = 0\n    while p:\n        tot_time = 0\n        while p:\n            if p[0][0] < tot_time + p[0][1]:\n                p.append(p[0])\n                p.pop(0)\n                continue\n            else:\n                p.pop(0)\n                if p[0][1] == 0:\n                    tot_time += p[0][0]\n                else:\n                    tot_time += p[0][0] + p[0][1]\n                p.pop(0)\n                break\n        o += tot_time\n        r += 1\n    if len(p) == 0:\n        return str(o)\n    while p:\n        if p[0][0] < tot_time + p[0][1]:\n            p.append(p[0])\n            p.pop(0)\n            continue\n        else:\n            p.pop(0)\n            if p[0][1] == 0:\n                tot_time += p[0][0]\n            else:\n                tot_time += p[0][0] + p[0][1]\n            p.pop(0)\n            break\n    o += tot_time\n    r += 1\n    return str(o / r)\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes in a string consisting of lines consisting of a prescription, drop-off time, and customer type and returns the average completion time for the in-store and remote prescriptions.\n    \"\"\"\n    # Solution\n    # Your code here\n    line = stdin.split()\n    if len(line) > 1:\n        num_prescription = int(line[0])\n        num_technicians = int(line[1])\n        prescription_dict = {}\n        for i in range(0, num_prescription):\n            if line[2 + i] == 'R':\n                prescription_dict[i] = 'R'\n            else:\n                prescription_dict[i] = 'S'\n        prescription_dict = dict(sorted(prescription_dict.items(), key=lambda x: x[1]))\n        counter = 1\n        time = 0\n        if len(prescription_dict.keys()) == 0:\n            return 0, 0\n        while True:\n            for i in range(counter, len(prescription_dict.keys())):\n                if (time + prescription_dict[i + counter]) <= (num_prescription - counter):\n                    counter += 1\n                    time += prescription_dict[i + counter]\n                    if counter == len(prescription_dict.keys()):\n                        break\n                else:\n                    counter -= 1\n                    time += (num_prescription - counter)\n                    break\n            if counter == len(prescription_dict.keys()):\n                break\n        return round(time / (num_prescription - counter), 6), round(time / counter, 6)\n    else:\n        return 0, 0\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    prescriptions = []\n    num_prescriber = 0\n    prescriber_first = True\n    total_t = 0\n    \n    for _ in range(n):\n        line = stdin.split()\n        \n        if prescriber_first:\n            if line[1] == 'S':\n                total_t = 0\n                prescriber_first = False\n                prescriber_num = int(line[0])\n        else:\n            total_t += int(line[0])\n            if line[1] == 'R':\n                total_t = 0\n                prescriber_first = True\n        \n        prescriptions.append(line)\n    \n    for line in prescriptions:\n        if line[1] == 'R':\n            num_prescriber += 1\n    \n    return str(total_t/num_prescriber) +'' + str(total_t)"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_dropoffs, num_technicians = map(int, stdin.split())\n    dropoffs = [0] * num_dropoffs\n    in_store_technicians = []\n    remote_technicians = []\n    for i in range(num_dropoffs):\n        dropoff = stdin.split()[i]\n        dropoff_type, time_to_fill = dropoff[0], int(dropoff[1:])\n        if dropoff_type == 'R':\n            remote_technicians.append((time_to_fill, i))\n        else:\n            in_store_technicians.append((time_to_fill, i))\n    if not remote_technicians and not in_store_technicians:\n        return '0 0'\n    total_time = sum(x[0] for x in remote_technicians) + sum(x[0] for x in in_store_technicians)\n    median = total_time // 2\n    in_store_technicians.sort(key=lambda x: x[0])\n    remote_technicians.sort(key=lambda x: x[0], reverse=True)\n    remote_technicians_filled = set()\n    for i in range(num_dropoffs):\n        if i < len(in_store_technicians):\n            total_time -= in_store_technicians[i][0]\n            remote_technicians_filled.add(in_store_technicians[i][1])\n        else:\n            total_time -= remote_technicians[i - len(in_store_technicians)][0]\n            remote_technicians_filled.add(remote_technicians[i - len(in_store_technicians)][1])\n        while total_time < median:\n            if i < len(in_store_technicians):\n                total_time += in_store_technicians[i][0]\n                remote_technicians_filled.add(in_store_technicians[i][1])\n            else:\n                total_time += remote_technicians[i - len(in_store_technicians)][0]\n                remote_technicians_filled.add(remote_technicians[i - len(in_store_technicians)][1])\n    return str(median) +'' + str(max(0, total_time - median))\n    pass\n    # Write your code here\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    n, t = map(int, input.split())\n    prescriptions = {}\n    for i in range(n):\n        prescriptions[i] = input.split()[i]\n\n    in_store = 0\n    remote = 0\n\n    for i in range(n):\n        if prescriptions[i][0] == 'R':\n            in_store += float(prescriptions[i][1:])\n        elif prescriptions[i][0] == 'S':\n            remote += float(prescriptions[i][1:])\n    if in_store + remote == 0:\n        return 0, 0\n    else:\n        return (in_store / (in_store + remote)), (remote / (in_store + remote))\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    in_store_count = 0\n    remote_count = 0\n    in_store_time = 0\n    remote_time = 0\n    for i in range(len(stdin.splitlines())):\n        if stdin.splitlines()[i].split()[1] == 'R':\n            in_store_count += 1\n            in_store_time += int(stdin.splitlines()[i].split()[2])\n        elif stdin.splitlines()[i].split()[1] == 'S':\n            remote_count += 1\n            remote_time += int(stdin.splitlines()[i].split()[2])\n    if remote_count == 0:\n        return str(0)\n    else:\n        return str(in_store_time / in_store_count)\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    prescriptions = []\n    for _ in range(n):\n        d, r, k = map(int, stdin.split())\n        prescriptions.append((d, r, k))\n    prescriptions.sort(key=lambda x: x[0])\n    prescriptions_in_store = [x for x in prescriptions if x[1] == \"R\"]\n    prescriptions_remote = [x for x in prescriptions if x[1] == \"S\"]\n    total_in_store_completion_time = 0\n    total_remote_completion_time = 0\n    for prescription in prescriptions_in_store:\n        total_in_store_completion_time += prescription[0]\n        prescription[0] = (total_in_store_completion_time, prescription[2])\n    for prescription in prescriptions_remote:\n        total_remote_completion_time += prescription[0]\n        prescription[0] = (total_remote_completion_time, prescription[2])\n    if not prescriptions_in_store and not prescriptions_remote:\n        return '0 0'\n    total_in_store_completion_time = float(total_in_store_completion_time)\n    total_remote_completion_time = float(total_remote_completion_time)\n    return f\"{total_in_store_completion_time:.6f} {total_remote_completion_time:.6f}\"\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the answer as a string, if any.\n\n    Otherwise return None.\n    \"\"\"\n    stdin_list = stdin.splitlines()\n\n    n, t = map(int, stdin_list[0].split())\n\n    presc = {}\n\n    for i in range(1, n+1):\n        presc[str(i)] = int(stdin_list[i])\n\n    pres_sorted = sorted(presc.items(), key=lambda x: (x[0], x[1]))\n    for i in range(n):\n        if pres_sorted[i][0]!= \"S\":\n            if pres_sorted[i][1] == 0:\n                o = 0\n            else:\n                o = round(pres_sorted[i][1] / t, 6)\n        else:\n            o = round(pres_sorted[i][1] / t, 6)\n        r = round(pres_sorted[i][1] / t, 6)\n        yield str(o) +'' + str(r)\n"
    },
    {
        "number": 3146,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, t = int(stdin[0]), int(stdin[1])\n    prescription_times = []\n    for i in range(n):\n        prescription_times.append(stdin[i + 2].split())\n\n    prescription_times.sort(key=lambda x: x[1])\n    in_store_prescription_times = []\n    remote_prescription_times = []\n    for i in range(len(prescription_times)):\n        if prescription_times[i][0] == \"S\":\n            in_store_prescription_times.append(prescription_times[i])\n        else:\n            remote_prescription_times.append(prescription_times[i])\n    # if not in_store_prescription_times:\n    #     return \"0\" + \" 0\"\n    sum_o = sum_r = 0\n    if not remote_prescription_times:\n        return \"0\" + \" 0\"\n    for i in range(len(remote_prescription_times)):\n        if remote_prescription_times[i][0] == \"S\":\n            sum_r += remote_prescription_times[i][1]\n    for i in range(len(in_store_prescription_times)):\n        if in_store_prescription_times[i][0] == \"S\":\n            sum_o += in_store_prescription_times[i][1]\n    if t == 1:\n        return \"0\" + str(sum_r)\n    else:\n        return str(sum_o / t) + str(sum_r / t)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    squares = [[int(i) for i in stdin[i * (R // 2) : (i + 1) * (R // 2)]] for i in range(R // 2)]\n    for square in squares:\n        square.sort()\n    squares.sort(key=len)\n    squares.sort(key=len, reverse=True)\n    return str(len(squares[0])) if squares else str(-1)\nprint(solution(input()))\n'''\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = (int(x) for x in stdin.split(' '))\n    memory = []\n    for i in range(R):\n        memory.append(stdin.replace('\\n', ''))\n    killers = []\n    for i in range(R):\n        for j in range(i + 1, C):\n            if memory[i][j] == '1':\n                killers.append(memory[i][j:j + C])\n    maxSize = -1\n    for killer in killers:\n        killerSize = killer.count('0')\n        killerSize += killer.count('1')\n        if killerSize > maxSize:\n            maxSize = killerSize\n    return str(maxSize)\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    #\n    # WRITE YOUR CODE HERE\n    #\n    return ''\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = [\n        list(stdin)\n        for _ in range(R)\n    ]\n    min_killer_size = -1\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == '0':\n                matrix[i][j] = '1'\n                for x in range(i-1, i+2):\n                    for y in range(j-1, j+2):\n                        if x > -1 and x < R and y > -1 and y < C and matrix[x][y] == '0':\n                            matrix[x][y] = '1'\n                killer_size = 0\n                for x in range(i, i+3):\n                    for y in range(j, j+3):\n                        if x == i and y == j:\n                            continue\n                        if matrix[x][y] == '1':\n                            killer_size += 1\n                if killer_size > min_killer_size:\n                    min_killer_size = killer_size\n                matrix[i][j] = '0'\n    if min_killer_size == -1:\n        return -1\n    else:\n        return min_killer_size\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    M = []\n    for r in range(R):\n        M.append(stdin.replace(\"0\", \".\").replace(\"1\", \"X\").split(\".\"))\n    for r in range(R):\n        for c in range(C):\n            M[r][c] = M[r][c][::-1]\n    killer_map = {}\n    for r in range(R):\n        for c in range(C):\n            killer_map[(r, c)] = []\n            if M[r][c] in killer_map:\n                killer_map[M[r][c]].append((r, c))\n            else:\n                killer_map[M[r][c]] = [(r, c)]\n    def is_square_killer(matrix: List[List[str]]) -> bool:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        killer = False\n        for row in range(rows):\n            for col in range(cols):\n                if killer and not is_square_killer_helper(matrix, row, col, killer):\n                    return False\n                if killer:\n                    killer_id = killer.id\n                    killer = killer_id in killer_map and killer_id in killer_map[killer_id]\n                    if killer:\n                        killer = killer[0][0] == row and killer[0][1] == col\n                        break\n        return killer\n    def is_square_killer_helper(matrix: List[List[str]], row: int, col: int, killer: int) -> bool:\n        for r in range(max(row - 1, 0), min(row + 2, len(matrix))):\n            for c in range(max(col - 1, 0), min(col + 2, len(matrix[0]))):\n                if matrix[r][c]!= killer:\n                    continue\n                if (r, c) in killer_map:\n                    killer_id = killer_map[(r, c)]\n                    if killer_id in killer_map[killer_id]:\n                        killer = True\n                        return True\n        return False\n    return str(is_square_killer(M))\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3 6\n   ... 101010\n   ... 111001\n   ... 101001\n   ... ''')\n    '3'\n    >>> solution('''\n   ... 4 5\n   ... 10010\n   ... 01010\n   ... 10101\n   ... 01001\n   ... ''')\n    '3'\n    \"\"\"\n    return str(largestSquareKiller(stdin))\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R = int(stdin.split()[0])\n    C = int(stdin.split()[1])\n    grid = stdin.split('\\n')\n    grid = [[int(i) for i in line] for line in grid]\n    return max([len(max(sublist, key=len)) for sublist in grid])\n\nsolution(\"3 6\\n10010\\n01010\\n10101\\n01001\")\n\nSample Input 3:\n4 4\n00010\n00101\n01100\n1000\nSample Output 3:\n3\n\"\"\"\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(x) for x in stdin.split()]\n    matrix = []\n    killer = 0\n    for i in range(R):\n        matrix.append([int(x) for x in stdin.split()[i]])\n\n    for i in range(R):\n        for j in range(C):\n            # print(matrix[i][j], end=' ')\n            if matrix[i][j] == 1:\n                killer = max(killer, j - i + 1)\n            elif matrix[i][j] == 0:\n                killer = max(killer, j + i)\n\n    # print(killer)\n    return str(killer)"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    R = int(lines[0])\n    C = int(lines[1])\n    memory = []\n    for line in stdin.splitlines():\n        memory.append(list(line))\n    maxSize = 0\n    for row in range(R):\n        for col in range(C):\n            if memory[row][col] == \"0\" and (row < C and memory[row + 1][col] == \"1\" or\n                                            row > 0 and memory[row - 1][col] == \"1\" or\n                                            col < C and memory[row][col + 1] == \"1\" or\n                                            col > 0 and memory[row][col - 1] == \"1\"):\n                size = 1\n                while row + size < R and col + size < C and memory[row + size][col + size] == \"1\":\n                    size += 1\n                maxSize = max(maxSize, size)\n    return str(maxSize)\n\nsolution(input())\n"
    },
    {
        "number": 3147,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    m = int(n ** 0.5)\n    # print(m)\n    for i in range(m):\n        for j in range(i, n, m):\n            subset = stdin[i:j]\n            if all(set(subset).issubset(set(stdin))):\n                return str(len(subset))\n    return '-1'\n\nsolution(input())\n\n\n\"\"\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.strip().split()\n    n = int(inp[0])\n    ans = []\n    l = []\n    i = 1\n    while i < n + 1:\n        l.append(list(map(int, inp[i].split())))\n        i += 1\n    print(l)\n    print(n)\n    for i in range(n):\n        for j in range(n):\n            print(i,j)\n            print(l[i][j], l[j][i])\n            if i == j:\n                ans.append(i)\n                continue\n            if abs(l[i][j]) == abs(l[j][i]):\n                ans.append(i)\n                continue\n            if abs(l[i][j]) == abs(l[j][i]) and abs(i - j) == abs(l[i][j]):\n                ans.append(i)\n                continue\n    print(ans)\n    return str(min(ans)) +'' + str(max(ans))\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x, y = stdin.split()\n    return str(int(x)) + \" \" + str(int(y))\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \"1\" + \" 1\"\n    else:\n        return \"1\" + \" 1\" + \" 2\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    list_of_swimmers = stdin.split('\\n')\n    swimmers = {}\n    swimmers_distance = {}\n\n    for swimmers_info in list_of_swimmers:\n        info = swimmers_info.split()\n        swimmers[(int(info[0]), int(info[1]))] = swimmers.get((int(info[0]), int(info[1]))) + 1 if swimmers.get((int(info[0]), int(info[1]))) else 1\n\n    min_distance = min(swimmers, key=swimmers.get)\n    max_distance = max(swimmers, key=swimmers.get)\n\n    min_distance = abs(min_distance[0] - min_distance[1])\n    max_distance = abs(max_distance[0] - max_distance[1])\n\n    swimmers_distance[min_distance] = min_distance\n    swimmers_distance[max_distance] = max_distance\n\n    for swimmers_info in list_of_swimmers:\n        info = swimmers_info.split()\n        distance_to_you = abs(int(info[0]) - int(info[1]))\n        distance_to_coworker = abs(int(info[0]) - int(info[1]))\n        if distance_to_coworker in swimmers_distance and distance_to_you in swimmers_distance:\n            if distance_to_coworker == distance_to_you:\n                distance_to_coworker = swimmers_distance[distance_to_coworker]\n                distance_to_you = swimmers_distance[distance_to_you]\n            if swimmers_distance[distance_to_coworker] < swimmers_distance[distance_to_you]:\n                return f'{distance_to_coworker} {distance_to_you}'\n            else:\n                return f'{distance_to_you} {distance_to_coworker}'\n        elif distance_to_coworker in swimmers_distance:\n            distance_to_coworker = swimmers_distance[distance_to_coworker]\n            if distance_to_you == distance_to_coworker:\n                return f'{distance_to_coworker} {distance_to_coworker}'\n            elif distance_to_you == distance_to_coworker + 1:\n                return f'{distance_to_you} {distance_to_coworker}'\n            else:\n                return f'{distance_to_you} {distance_to_coworker}'\n        else:\n            distance_to_coworker = swimmers_distance[distance_to_coworker]\n            if distance_to_you == distance_to_coworker + 1:\n                return f'{distance_to_you} {distance_to_coworker}'\n            else:\n                return f'{distance_to_you} {distance_to_coworker}'"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    distances = []\n    locations = []\n    for i in range(n):\n        x, y = list(map(int, input().split()))\n        distances.append((x, y))\n        locations.append((x, y))\n    distances = sorted(distances, key=lambda item: item[1])\n    for i in range(n):\n        if distances[i][0] == -1:\n            locations[i] = (n+1, n+1)\n            continue\n        locations[i] = (distances[i][0] + 1, distances[i][1])\n    print(*locations)\n    return"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        swimmers.append([x, y])\n\n    swimmers.sort(key=lambda x: x[1])\n    closest_leader = None\n    dist_to_closest_leader = None\n    for sw in swimmers:\n        if not closest_leader:\n            closest_leader = sw\n            dist_to_closest_leader = sw[0] - sw[1]\n        elif sw[0] - sw[1] == dist_to_closest_leader:\n            closest_leader = sw\n        elif sw[0] - sw[1] < dist_to_closest_leader:\n            closest_leader = sw\n            dist_to_closest_leader = sw[0] - sw[1]\n        elif sw[0] - sw[1] > dist_to_closest_leader:\n            break\n\n    dist_to_closest_leader = closest_leader[0] - closest_leader[1]\n    x = closest_leader[1]\n    y = closest_leader[0]\n\n    print(x, y)\n    return x, y"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    swimmers = [list(map(int, stdin.split(\"\\n\"))) for _ in range(n)]\n\n    # Sort the swimmers by their position\n    swimmers.sort(key=lambda x: x[0])\n\n    # Total distance\n    total_distance = 0\n\n    # For each swimmer\n    for swimmer in swimmers:\n        # Find the closest swimmer\n        closest_swimmer = swimmer[0]\n        for swimmer2 in swimmers:\n            if swimmer2!= swimmer:\n                if abs(swimmer2[0] - closest_swimmer) < abs(swimmer[0] - closest_swimmer):\n                    closest_swimmer = swimmer2[0]\n        # Find the amount of swimmers\n        amount_swimmers = 0\n        for swimmer2 in swimmers:\n            if swimmer2!= swimmer:\n                if abs(swimmer2[0] - closest_swimmer) == abs(swimmer[0] - closest_swimmer):\n                    amount_swimmers += 1\n        # Print the location\n        total_distance += amount_swimmers * (swimmer[0] - closest_swimmer)\n    return str(total_distance)\n"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    arr = list(map(int, stdin.split()))\n    x, y = arr[0], arr[1]\n    arr = list(map(int, stdin.split()))\n    n = arr[0]\n    arr = arr[1:]\n    groups = [set()]\n    i = 0\n    while i < n:\n        left_group = groups[-1]\n        left_group.add(arr[i])\n        right_group = groups[-1]\n        right_group.add(arr[i])\n        groups.append(left_group.union(right_group))\n        i += 1\n    min_dist = math.inf\n    min_x, min_y = -1, -1\n    for i in groups:\n        dist = 0\n        for j in i:\n            dist += abs(x-j) + abs(y-j)\n        if dist < min_dist:\n            min_dist = dist\n            min_x = x\n            min_y = y\n    return str(min_x) + \" \" + str(min_y)"
    },
    {
        "number": 3148,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    swimmers: List[List[int]] = []\n    for i in range(n):\n        swimmers.append(list(map(int, stdin.split())))\n\n    groups = 0\n    while n > 1:\n        print(groups, n)\n        n = 2 * groups\n        groups += 1\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[0], x[1]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        swimmers = sorted(swimmers, key=lambda x: (x[1], x[0]))\n        n = 3 * groups\n        print(groups, n)\n    print(swimmers)\n    return \" \".join(map(str, swimmers[0])) + \" \" + \" \".join(map(str, swimmers[1]))\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v_0, theta, w = map(float, stdin.split())\n    a = 9.81\n    v = v_0*math.cos(math.radians(theta))\n    t = a/v*math.sin(math.radians(theta))\n    y = (n-1)*w/v\n    x_1 = (n-1)*w/v - y\n    x_2 = (n-1)*w/v + y\n    x_3 = w/v\n    x_4 = w/v - y\n    x_5 = w/v + y\n    x_6 = w/v\n    x_7 = w/v + y\n    x_8 = w/v - y\n    x_9 = w/v\n    x_10 = w/v + y\n    x_11 = w/v\n    x_12 = w/v - y\n    x_13 = -w/v\n    x_14 = -w/v + y\n    x_15 = -w/v\n    x_16 = -w/v - y\n    x_17 = -w/v\n    x_18 = -w/v + y\n    x_19 = -w/v\n    x_20 = -w/v - y\n    x_21 = w/v - y\n    x_22 = w/v + y\n    x_23 = w/v\n    x_24 = w/v - y\n    x_25 = w/v\n    x_26 = w/v + y\n    x_27 = w/v\n    x_28 = w/v - y\n    x_29 = w/v\n    x_30 = w/v + y\n    x_31 = w/v\n    x_32 = w/v - y\n    x_33 = w/v\n    x_34 = w/v + y\n    x_35 = w/v\n    x_36 = w/v - y\n    x_37 = w/v\n    x_38 = w/v + y\n    x_39 = w/v\n    x_40 = w/v - y\n    x_41 = w/v\n    x_42 = w/v + y\n    x_43 = w/v\n    x_44 = w/v - y\n    x_45 = w/v\n    x_46 = w/v + y\n    x_47 = w/v\n    x_48 = w/v - y\n    x_49 = w/v\n    x_50 = w/v + y\n    x_51 = w/v\n    x_52 = w/v - y\n    x_53 = w/v\n    x_54 = w/v + y\n    x_55 = w/v\n    x_56 = w/v - y\n    x_57 = w/v\n    x_58 = w/v + y\n    x_59 = w/v\n    x_60 = w/v - y\n    x_61 = w/v\n    x_62 = w/v + y\n    x_63 = w/v\n    x_64 = w/v - y\n    x_65 = w/v\n    x_66 = w/v + y\n    x_67 = w/v\n    x_68 = w/v - y\n    x_69 = w/v\n    x_70 = w/v + y\n    x_71 = w/v\n    x_72 = w/v - y\n    x_73 = w/v\n    x_74 = w/v + y\n    x_75 = w/v\n    x_76 = w/v - y\n    x_77 = w/v\n    x_78 = w/v + y\n    x_79 = w/v\n    x_80 = w/v - y\n    x_81 = w/v\n    x_82 = w/v + y\n    x_83 = w/v\n    x_84 = w/v - y\n    x_85 = w/v\n    x_86 = w/v + y\n    x_87 = w/v\n    x_88 = w/v - y\n    x_89 = w/v\n    x_90 = w/v + y\n    x_91 = w/v\n    x_92 = w/v - y\n    x_93 = w/v\n    x_94 = w/v + y\n    x_95 = w/v\n    x_96 = w/v - y\n    x_97 = w/v\n    x_98 = w/v + y\n    x_99 = w/v\n    x_100 = w/v - y\n    x_101 = w/v\n    x_102 = w/v + y\n    x_103 = w/v\n    x_104 = w/v - y\n    x_105 = w/v\n    x_106 = w/v + y\n    x_107 = w/v\n    x_108 = w/v - y\n    x_109 = w/v\n    x_110 = w/v + y\n    x_111 = w/v\n    x_112 = w/v - y\n    x_113 = w/v\n    x_114 = w/v + y\n    x_115 = w/v\n    x_116 = w/v - y\n    x_117 = w/v\n    x_118 = w/v + y\n    x_119"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v0, theta, w, a, b = map(float, stdin.split())\n    # n = 5\n    # omega = 6.28\n    # v0 = 2.12\n    # theta = 45\n    # w = 45\n    # a = 0\n    # b = -1\n\n    h = abs(a - b)\n    if n == 1:\n        return str(h)\n    v = n * v0\n    x = (1 - omega) * v0\n    y = (omega * v0) * math.cos(math.radians(theta))\n    while abs(x) < h:\n        # print(x, y)\n        if x + w * math.sin(math.radians(theta)) >= h:\n            break\n        x += w * math.sin(math.radians(theta))\n        y += w * math.cos(math.radians(theta))\n        # print(x, y)\n\n    return str(math.degrees(math.atan2(y, x))) +'' + str(math.degrees(math.atan2(w, a)))\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    cookies = [[int(x) for x in stdin.split()] for i in range(5)]\n    T = []\n    for cookie in cookies:\n        sides = []\n        for i in range(len(cookie)):\n            sides.append(tuple((cookie[i], i)))\n        sides.sort()\n        angles = []\n        for i in range(len(sides) - 1):\n            angle = sides[i + 1][0] - sides[i][0]\n            angle = (angle + 360) % 360\n            angles.append(angle)\n        T.append(angles)\n    return str(sides[0]) +'' + str(sides[-1]) +'' + str(angles) +'' + str(min(T)) + '\\n'\n\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    [n, omega, v0, theta, w, x] = stdin.split()\n    [n, omega, v0, theta, w, x] = map(lambda x: float(x), [n, omega, v0, theta, w, x])\n    n = int(n)\n    t0 = math.atan2(w - x, v0) + math.pi\n    for i in range(n):\n        t0 += (math.pi * 2) * (1 - float(i) / float(n)) * (omega)\n    t1 = math.atan2(w + x, v0) - math.pi\n    for i in range(n):\n        t1 += (math.pi * 2) * (1 - float(i) / float(n)) * (omega)\n    t = max(t0, t1)\n    return f\"{t:.8f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) **.5\n    n, omega, v0, theta, w = list(map(float, stdin.split()))\n    w = math.radians(w)\n    a, b = math.cos(w), math.sin(w)\n    c, d = -a * v0, -b * v0\n    v = math.sqrt(omega * omega + c * c + d * d)\n    t0 = (a * a + b * b - c * c - d * d) / (2 * a * d)\n    t = 0\n    c = 1\n    for i in range(1, n + 1):\n        x, y = a * t0 * c + i * a * v, b * t0 * c + i * b * v\n        x = int(x)\n        y = int(y)\n        if abs(x) >= 20 or abs(y) >= 20:\n            return \"No\"\n        elif x >= 0 and y >= 0:\n            t += dist([0, 0], (x, y))\n        else:\n            t += dist([0, 0], (x, -y))\n        if abs(t - t0) < 10 ** (-3):\n            return str(i) + \" \" + str(t)\n    return \"No\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v0, theta, w = map(float, stdin.split())\n    v = v0 * math.cos(theta * math.pi / 180)\n    omega_ = omega / 3600\n    h = omega_ * v\n    return \"%.4f\" % (v / math.sqrt(h ** 2 + (h * w / math.sin(omega_ * math.pi / 180)) ** 2) + w)\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from datetime import datetime\n    n, omega, v0, theta, w, x_i, y_i = map(float, stdin.strip().split())\n    T = 0\n    for i in range(1, n + 1):\n        x_i = 0\n        y_i = 0\n        if i == 1:\n            T = T + (1/2) * (x_i + 1) / (omega * v0)\n        else:\n            T = T + (1/2) * (x_i + 1) / (omega * v0) + (1 / 2) * (x_i + 1) ** 2 / ((omega ** 2) * v0 * (omega ** 2 + v0 ** 2))\n    for i in range(1, n):\n        x_i = x_i + (x_i - x_i * (omega * v0 * theta / n) + y_i) / (omega * v0)\n        y_i = y_i + (y_i - y_i * (omega * v0 * theta / n) - x_i) / (omega * v0)\n        T = T + (1 / 2) * (x_i + 1) / (omega * v0)\n    return f\"{i} {T:.3f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(float, stdin.split()))\n    n = inputs[0]\n    w = inputs[3]\n    x0 = inputs[1]\n    y0 = inputs[2]\n    x1 = inputs[4]\n    y1 = inputs[5]\n    if x0 == x1:\n        return \"\"\n    theta = math.atan((y1 - y0) / (x1 - x0))\n    if theta > 0:\n        theta = -theta\n    else:\n        theta = theta\n    t = (theta * w / (2 * math.pi) - theta * x0 / (2 * math.pi)) / (math.sqrt(math.pow(x1 - x0, 2) + math.pow(y1 - y0, 2)) - math.pow(x1 - x0, 2) + math.pow(y1 - y0, 2))\n    return str(math.ceil(t))"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, w, v0, theta, omega, v, t = int(inputs[0]), float(inputs[1]), float(inputs[2]), float(inputs[3]), float(inputs[4]), float(inputs[5]), float(inputs[6])\n    f = lambda x, y: 1.5 * x * (x ** 2 + y ** 2) ** 0.5\n    x0, y0 = float(inputs[7]), float(inputs[8])\n    x1, y1 = float(inputs[9]), float(inputs[10])\n    x2, y2 = float(inputs[11]), float(inputs[12])\n    x3, y3 = float(inputs[13]), float(inputs[14])\n    x4, y4 = float(inputs[15]), float(inputs[16])\n    polygon = Polygon([Point(x0, y0), Point(x1, y1), Point(x2, y2), Point(x3, y3), Point(x4, y4)])\n    corners = [Point(x, y) for x, y in [(x1, y1), (x0, y0), (x3, y3), (x4, y4)]]\n    while True:\n        t += 1\n        polygon.move_by(v0 * t, theta * t, 0)\n        v0 += omega * t\n        if v0 > v:\n            v0 = v\n            v = (v + v * omega) / 2\n        if t > t_max:\n            break\n    for corner in corners:\n        if polygon.distance(corner) <= w:\n            break\n    else:\n        return f'{corners[0].x}, {corners[0].y}', 0\n    for corner in corners:\n        if polygon.distance(corner) <= w:\n            break\n    else:\n        return f'{corners[1].x}, {corners[1].y}', 0\n    for corner in corners:\n        if polygon.distance(corner) <= w:\n            break\n    else:\n        return f'{corners[2].x}, {corners[2].y}', 0\n    for corner in corners:\n        if polygon.distance(corner) <= w:\n            break\n    else:\n        return f'{corners[3].x}, {corners[3].y}', 0\n    for corner in corners:\n        if polygon.distance(corner) <= w:\n            break\n    else:\n        return f'{corners[4].x}, {corners[4].y}', 0\n    return f'{corner.x}, {corner.y}', t\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3149,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    shape = []\n    shape_area = 0\n    for i in range(3):\n        x, y = map(float, stdin.split())\n        shape.append((x, y))\n        if i == 0:\n            continue\n        shape_area += (shape[i][0] - shape[i-1][0]) * (shape[i][1] + shape[i-1][1])\n    if len(shape) == 3:\n        shape_area += (shape[0][0] - shape[1][0]) * (shape[0][1] + shape[1][1])\n    distances = []\n    for i in range(len(shape)-1):\n        distances.append(math.sqrt((shape[i+1][0] - shape[i][0])**2 + (shape[i+1][1] - shape[i][1])**2))\n    velocity = 0\n    angle = 0\n    #if len(distances) == 0:\n    #    return 0\n    for i in range(len(distances)-1):\n        velocity += distances[i] * distances[i+1]\n        angle += distances[i] * distances[i+1] * math.sin(math.radians(distances[i+1]))\n        if velocity <= (shape_area * math.pi) / 6:\n            return i\n            #break\n    return -1\n"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines: List[List[int]] = []\n    for i in range(0, len(stdin), 1):\n        lines.append(list(map(int, stdin[i].split())))\n    return f'{solution_part2(lines)}'\n\ndef"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    trenches = []\n    for i in range(N):\n        trenches.append(list(map(int, stdin.readline().strip().split())))\n\n    def get_overlap(trench_a, trench_b):\n        x_overlap = max(trench_a[0], trench_b[0]) < min(trench_a[2], trench_b[2])\n        y_overlap = max(trench_a[1], trench_b[1]) < min(trench_a[3], trench_b[3])\n\n        return x_overlap and y_overlap\n\n    def get_size(trench):\n        return trench[2] - trench[0]\n\n    trenches.sort(key=lambda x: x[0])\n    trenches.sort(key=lambda x: x[1])\n    trenches.sort(key=lambda x: x[2])\n    trenches.sort(key=lambda x: x[3])\n\n    cache = dict()\n\n    def get_cache(trench):\n        if trench in cache:\n            return cache[trench]\n        overlaps = 0\n        trench_size = get_size(trench)\n        for i in range(N - 1):\n            trench_a = trenches[i]\n            trench_b = trenches[i + 1]\n\n            if not get_overlap(trench, trench_a):\n                continue\n\n            if not get_overlap(trench, trench_b):\n                continue\n\n            if get_overlap(trench, trench_a) and get_overlap(trench, trench_b):\n                continue\n\n            if get_overlap(trench, trench_a):\n                overlaps += trench_size\n            else:\n                overlaps += trench_size\n                overlaps += trench_size\n            cache[trench] = overlaps\n\n        return overlaps\n\n    for i in range(N):\n        get_cache(trenches[i])\n\n    cache = dict()\n\n    def get_cache(trench):\n        if trench in cache:\n            return cache[trench]\n        overlaps = 0\n        trench_size = get_size(trench)\n        for i in range(N - 1):\n            trench_a = trenches[i]\n            trench_b = trenches[i + 1]\n\n            if not get_overlap(trench, trench_a):\n                continue\n\n            if not get_overlap(trench, trench_b):\n                continue\n\n            if get_overlap(trench, trench_a) and get_overlap(trench, trench_b):\n                continue\n\n            if get_overlap(trench, trench_a):\n                overlaps += trench_size\n            else:\n                overlaps += trench_size\n                overlaps += trench_size\n            cache[trench] = overlaps\n\n        return overlaps\n\n    for i in range(N):\n        get_cache(trenches[i])\n    return len(cache)\nprint(solution(stdin))\n"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    trenches = stdin.splitlines()\n    n = int(trenches[0])\n\n    # create a list of tuples of the form (x, y)\n    trenches = [\n        (int(x), int(y))\n        for x, y in (trench.split() for trench in trenches[1:])\n    ]\n\n    # sort the list by the x coordinate\n    trenches.sort(key=lambda x: x[0])\n\n    # the last trench is the base case\n    # the last trench has exactly one way to put guards\n    # if there is an even number of trenches then there is one way to put guards otherwise there is zero\n    if n == 1:\n        return 1\n    # elif n == 2:\n    #     if trenches[0][0] == trenches[1][0]:\n    #         return 0\n    #     return 1\n    # elif n == 3:\n    #     if trenches[0][0] == trenches[1][0] or trenches[0][0] == trenches[1][0] or trenches[0][0] == trenches[2][0]:\n    #         return 0\n    #     if trenches[0][0] == trenches[1][1] or trenches[0][0] == trenches[2][1] or trenches[0][1] == trenches[1][1] or trenches[0][1] == trenches[2][1]:\n    #         return 0\n    #     return 1\n\n    def solution(n):\n        if n == 1:\n            return 1\n        if n == 2:\n            if trenches[0][0] == trenches[1][0]:\n                return 0\n            return 1\n        if n == 3:\n            if trenches[0][0] == trenches[1][0] or trenches[0][0] == trenches[1][0] or trenches[0][0] == trenches[2][0]:\n                return 0\n            if trenches[0][0] == trenches[1][1] or trenches[0][0] == trenches[2][1] or trenches[0][1] == trenches[1][1] or trenches[0][1] == trenches[2][1]:\n                return 0\n            return 1\n\n    return solution(n)\n"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    cache = {}\n    return\n    for i in range(n):\n        x1, y1, x2, y2 = stdin.split()\n        x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)\n        key = (x1, y1, x2, y2)\n        if key not in cache:\n            cache[key] = 1\n            return\n        return cache[key]"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    lines = list(map(int, lines))\n    trenches = lines[1:]\n    \n    n = len(trenches)\n    dp = [[0 for x in range(n + 1)] for y in range(n + 1)]\n    \n    for i in range(n - 1):\n        x1, y1, x2, y2 = trenches[i]\n        for j in range(i, n):\n            x3, y3, x4, y4 = trenches[j]\n            if x1 == x3 or y1 == y3:\n                if x1 == x2 or y1 == y2:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = dp[i][j]\n            elif x1 == x4 or y1 == y4:\n                if x1 == x2 or y1 == y2:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = dp[i][j]\n            else:\n                if x1 == x2 or y1 == y2:\n                    dp[i + 1][j + 1] = dp[i][j] + 1\n                else:\n                    dp[i + 1][j + 1] = dp[i][j]\n    \n    return dp[n][n]\n\nsolution(stdin)"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    trenches = []\n    for i in range(n):\n        trenches.append(list(map(int, stdin.split())))\n    ways = 0\n    if n <= 3:\n        for trench in trenches:\n            ways += 1\n    else:\n        for i in range(n):\n            x1 = trenches[i][0]\n            y1 = trenches[i][1]\n            for j in range(i + 1, n):\n                x2 = trenches[j][0]\n                y2 = trenches[j][1]\n                for k in range(j + 1, n):\n                    x3 = trenches[k][0]\n                    y3 = trenches[k][1]\n                    for l in range(k + 1, n):\n                        x4 = trenches[l][0]\n                        y4 = trenches[l][1]\n                        if x4 == x3 or x4 == x2 or x4 == x1:\n                            continue\n                        if abs(x1 - x2) + abs(y1 - y2) == abs(x4 - x3) + abs(y4 - y3):\n                            ways += 1\n    return str(ways)"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdout = \"\"\n    stdout += \"1\"\n    return stdout\n"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split())\n    trenches = []\n    for i in range(rows):\n        x, y = map(int, stdin.split())\n        trenches.append((x, y))\n\n    guards = {}\n\n    trenches.sort(key=lambda t: t[0])\n    guards[trenches[0]] = (trenches[1], trenches[2])\n    guards[trenches[1]] = (trenches[2], trenches[3])\n\n    return guards"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def isValid(N: int, x: int, y: int, r: int, c: int):\n        cnt = 0\n        for i in range(r):\n            cnt += (i + 1) // 2\n        for j in range(c):\n            cnt += (j + 1) // 2\n        if cnt > N:\n            return False\n        for i in range(r):\n            if (i + 1) // 2!= (i + 1) // 2:\n                return False\n            for j in range(c):\n                if (j + 1) // 2!= (j + 1) // 2:\n                    return False\n        return True\n\n    def isValidLine(x1: int, y1: int, x2: int, y2: int):\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0 and dy == 0:\n            return True\n        if dx == 0 and dy == 1:\n            return True\n        if dx == 1 and dy == 0:\n            return True\n        if dx == -1 and dy == 0:\n            return True\n        if dx == 0 and dy == -1:\n            return True\n        if dx == -1 and dy == 1:\n            return True\n        return False\n\n    trenches = list()\n    trenches.append(list(map(int, stdin.split())))\n    N = len(trenches)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                x1, y1 = trenches[i][0], trenches[i][1]\n                x2, y2 = trenches[j][0], trenches[j][1]\n                x3, y3 = trenches[k][0], trenches[k][1]\n                if isValidLine(x1, y1, x2, y2) and isValidLine(x2, y2, x3, y3):\n                    return '\\n'.join([str(x) for x in (x1, y1, x2, y2, x3, y3)])\n    return '\\n'.join([str(x) for x in [0, 0, 0, 0]])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3150,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    trenches = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, stdin.strip().split())\n        trenches.append((x1, y1, x2, y2))\n\n    # start_trench = trenches[0]\n    # for i in range(1, N):\n    #     start_trench = intersect(start_trench, trenches[i])\n\n    start_trench = (0, 0, 0, 0)\n\n    for i in range(N):\n        start_trench = intersect(start_trench, trenches[i])\n    # print(start_trench)\n    return str(len(start_trench))\n\ndef"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = int((n **.5) - 1)\n    k = int(n **.5)\n    if (m ** 2) - k ** 2 == n:\n        return str(m) +'' + str(k)\n    return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1,int(math.sqrt(n))+1):\n        m = i**2 - n\n        k = (i-1)**2 + (i-1)**2\n        if m == n:\n            return str(i) +'' + str(i)\n        elif m < n:\n            continue\n        else:\n            return 'impossible'\n    return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = n**0.5\n    k = (n**0.5) + 1\n    while m > k:\n        m -= 1\n        k += 1\n    return str(m) +'' + str(k)"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sq = n * n\n    p = n // 4\n    k = n // 2\n    if n % 4!= 0:\n        return 'impossible'\n    if sq - p*p == k*k:\n        return str(p) + \" \" + str(k)\n    else:\n        return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n = int(stdin.pop(0))\n    m = k = 0\n    while m * m - k * k!= n:\n        m += 1\n        k += 1\n    if m == k == 0:\n        return \"impossible\"\n    else:\n        return f\"{m} {k}\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    squares = []\n    for m in range(n):\n        squares.append(m*m)\n    squares = set(squares)\n    for k in range(n):\n        if k*k in squares:\n            return str(m) + \" \" + str(k)\n    return \"impossible\"\nprint(solution(input()))\n"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 4!= 0:\n        return 'impossible'\n    for m in range(n+1):\n        k = n - m**2\n        if k == 0:\n            return f'{m} {k}'\n    return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''7\n   ... 1\n   ... ''')\n    impossible\n    >>> solution('''10\n   ... 1\n   ... ''')\n    '''3'''\n    \"\"\"\n    n = int(stdin)\n    m = n**0.5\n    k = n**0.5\n    if m == k:\n        print(m, k)\n        return\n    if m > k:\n        k_sqr = k**2\n        m_sqr = m**2\n        k_minus_m = k_sqr - m_sqr\n        k_minus_m_sqr = k_minus_m**2\n        k_minus_m_m_sqr = k_minus_m_sqr\n        if k_minus_m_m_sqr < n:\n            print(k, k)\n            return\n        if k_minus_m_m_sqr > n:\n            print(m, m)\n            return\n        print(k_sqr, m_sqr)\n        return\n    if k > m:\n        m_sqr = m**2\n        k_sqr = k**2\n        m_minus_k = m_sqr - k_sqr\n        m_minus_k_sqr = m_minus_k**2\n        m_minus_k_m_sqr = m_minus_k_sqr\n        if m_minus_k_m_sqr < n:\n            print(k, k)\n            return\n        if m_minus_k_m_sqr > n:\n            print(m, m)\n            return\n        print(m_sqr, k_sqr)\n        return\n"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    n = int(stdin)\n    for m in range(n, 1, -1):\n        k = n - m * m\n        if k % m == 0:\n            return f'{m} {k}'\n    return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_square(num):\n        return math.ceil(math.sqrt(num)) == math.floor(math.sqrt(num))\n    if stdin.isnumeric():\n        n = int(stdin)\n        m = 1\n        while is_square(m**2 - n**2) and m < n:\n            m += 1\n        k = 1\n        while is_square(k**2 - n**2) and k < n:\n            k += 1\n        return '{} {}'.format(m, k) if is_square(m**2 - n**2) and is_square(k**2 - n**2) else 'impossible'\n    return stdin\n\nprint(solution(input()))\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    arr = []\n    for _ in range(N):\n        arr.append(int(stdin))\n    total = 0\n    for i in range(len(arr)):\n        total += (arr[i] * (i+1))\n    print(int(str(total)[-9:]))\n    return str(total)[-9:]"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    min_int = min(arr)\n    max_int = max(arr)\n    sum = 0\n    for i in range(n):\n        sum += arr[i]\n    pow_min = min_int * min_int * max_int * max_int\n    pow_max = max_int * max_int * min_int * max_int\n    return str(pow_min + pow_max - sum)"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    stdin = stdin.split(\"\\n\")\n    array = []\n    for element in stdin:\n        array.append(int(element))\n    return sum(array)/len(array)\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    numbers = sorted(map(int, stdin.split()))\n    return str(sum(numbers[i] * numbers[i + 1] * numbers[i + 2] * numbers[i + 3] for i in range(len(numbers) - 3)) // min(numbers) // max(numbers) // N)\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    x = 0\n    for i in range(N):\n        x += int(stdin[i])\n    x = x * (N - 1)\n    return str(x)\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return '0'\n    if n == 2:\n        return '16'\n    min_n = min(int(stdin) for stdin in stdin.split())\n    max_n = max(int(stdin) for stdin in stdin.split())\n    n = len(str(max_n))\n    array = sorted(list(map(int, stdin.split())))\n    sum_n = 0\n    for i in range(1, n + 1):\n        prices = 0\n        if i <= 2:\n            for j in range(i):\n                prices += max_n\n        else:\n            prices = max_n\n        for j in range(i):\n            prices += min_n\n        sum_n += prices\n    return str(sum_n)[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def sum_maxmin(array, sum_of_digits: int) -> str:\n        array.sort()\n        min = array[0]\n        max = array[len(array)-1]\n        return str(min * max * (max-min)) + sum_of_digits\n\n    total = 0\n    for num in stdin.split('\\n'):\n        total += int(sum_maxmin(list(map(int, num.split())), 0))\n    return str(total)\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    prices = []\n    for i in stdin.split(\"\\n\"):\n        prices.append(int(i))\n    prices.sort()\n    first_min = prices[0]\n    second_min = prices[1]\n    return str((first_min + second_min) * (min(len(prices), 9)))[:-1]\n"
    },
    {
        "number": 3152,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return ''.join(map(str, sum(int(num) * (num + 1) / 2 for num in map(int, stdin.split()))))"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # the number of cards each child has\n    cards = list(map(int, stdin.split()))\n    # the number of purchases made by each child\n    purchases = list(map(int, stdin.split()))\n    # the number of purchases made by each child\n    l, r = 0, n-1\n    # the number of purchases made by each child\n    while l < r:\n        # find out which child wins and store that info\n        winner = 1 if cards[l] == cards[r] else 2 if cards[l] + cards[r] <= m else 3\n        # we need to clear the loser, because they won't be able to buy cards\n        cards[l] = cards[r] = 0\n        # increase the l and r variables to know which is going to be the winner\n        l += 1\n        r -= 1\n        # if winner is 1, the loser wins and gets one card\n        if winner == 1:\n            cards[l] += 1\n        # if winner is 2, the loser gets two cards\n        if winner == 2:\n            cards[l] += 2\n            cards[r] += 2\n        # if winner is 3, the loser gets four cards\n        if winner == 3:\n            cards[l] += 4\n            cards[r] += 4\n    # the final count of cards for the children\n    ans = sum(cards)\n    # write the result in the first line\n    print(ans)\n    # write the answer in the rest of the lines\n    for i in range(1, n+1):\n        # we don't need to count the number of cards of the winner, since they already got one of the cards\n        if i!= winner:\n            print('{} {} {}'.format(i, cards[i-1], 0))\n    return ans\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    if len(cards)!= n:\n        return 'ERROR'\n    if len(cards) == 0:\n        return 'ERROR'\n    if len(cards) == 1:\n        return str(n)\n    if len(cards) == 2:\n        return str(n)\n    cards = collections.Counter(cards)\n    for i in range(len(cards)):\n        cards[i] //= 2\n        if i + 1 < len(cards):\n            cards[i + 1] += cards[i] // 2\n        else:\n            cards[i + 1] = cards[i] // 2\n    print(cards)\n    return str(sum(cards.values()))"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_cards_each, num_children = map(int, stdin.split())\n    cards_each = list(map(int, stdin.split()))\n    purchases = []\n    for i in range(num_children):\n        purchases.append((i, 0))\n    for i in range(num_children):\n        purchases.append((i, 0))\n    for i in range(num_children):\n        purchases.append((i, 0))\n    purchases.sort(key=lambda x: x[1])\n    for p, c in purchases:\n        cards_each[p] += c\n    return str(num_children)\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    count = int(lines[0])\n    cards_by_child = lines[1].split()\n    cards_by_child = [(int(c), i) for i, c in enumerate(cards_by_child)]\n    print(cards_by_child)\n    winners = []\n    print(cards_by_child)\n    while len(cards_by_child) > 1:\n        child1_cards = cards_by_child.pop(0)\n        child2_cards = cards_by_child.pop(0)\n        if child1_cards[1] == child2_cards[1]:\n            winner = child1_cards\n        else:\n            winner = child1_cards if child1_cards[0] > child2_cards[0] else child2_cards\n        winners.append(winner)\n        print(winners)\n        cards_by_child = [(c, i) for i, c in enumerate(cards_by_child) if c!= winner]\n        print(cards_by_child)\n    if cards_by_child:\n        winner = cards_by_child.pop(0)\n        winners.append(winner)\n        print(winners)\n    print(len(winners))\n    for i in range(len(winners)):\n        print(winners[i], end=\" \")\n    return count\n\nprint(solution(input()))\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    children = list(map(int, stdin.split()))\n    cards = 0\n    for i in range(N):\n        cards += children[i]\n    purchases = 0\n    while cards > 0:\n        children.sort()\n        for child in range(N):\n            if children[child]!= 0:\n                children[child] -= 1\n                cards -= 1\n                break\n        for i in range(child + 1, N):\n            if children[i]!= 0:\n                children[i] -= 1\n                cards -= 1\n                break\n        purchases += 1\n    return str(purchases)\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *c = map(int, stdin.split())\n    children = {i: i for i in range(1, n + 1)}\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        c = min(c, c - children[a - 1])\n        c = max(c, c - children[b - 1])\n        children[a - 1] += c\n        children[b - 1] += c\n    return str(sum(children.values()))\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 3\n   ... 5 1\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... '''.strip())\n    '3'\n    >>> solution('''\n   ... 4 3\n   ... 5 3 1 1\n   ... 1 3\n   ... 2 3\n   ... 4 1\n   ... Sample Output 2:\n   ... 5\n   ... 1 3 1\n   ... 2 3 2\n   ... 4 1 0\n   ... 2 4 1\n   ... 3 1 0\n    '''.strip())\n    '4'\n    \"\"\"\n    n, m = map(int, stdin.strip().split())\n    cards = [0] * n\n    cnt = 0\n    for _ in range(m):\n        a, b = map(int, input().strip().split())\n        if a < b:\n            cards[a - 1] += 1\n            cards[b - 1] += 1\n        else:\n            cards[a - 1] += 2\n            cards[b - 1] += 2\n    for i in range(n):\n        if cards[i] == 2:\n            cnt += 1\n    print(cnt)\n    return cnt\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    children = list(map(int, stdin.split()))\n    purchases = []\n    count_children = 0\n    while count_children < n:\n        purchases.append([children[count_children], children[count_children + 1]])\n        count_children += 2\n    for purchase in purchases:\n        first, second = purchase\n        if first == second:\n            count = 2\n        else:\n            count = 1\n        children[first] += count\n        children[second] -= count\n    return count_children\n\n\nprint(solution(input()))\n\nThe input contains the parameters:\n\n\u2022 The first integer $N$ \u2013 the number of children.\n\u2022 The second integer $M$ \u2013 the number of purchases.\n\u2022 The next $M$ integers are the labels of the children who made the purchases.\n\nThe output should be a single integer describing the number of purchases.\n\nThe purchase description consists of three integers:\n\n\u2022 The two distinct labels of the children that made the purchase.\n\u2022 The number $0$, $1$ or $2$ describing how many cards the first child got after the race.\n\nIn the first example, the total number of purchases is 3.\n\nSample Input 2:\n4 3\n5 3 1 1\n1 3\n2 3\n4 1\nSample Output 2:\n5\n1 3 1\n2 3 2\n4 1 0\n2 4 1\n3 1 0\n"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = stdin.split()\n    N = int(N)\n    M = int(M)\n    cards = list(map(int, stdin.split()))\n    print(len(cards))\n    while M > 0:\n        M -= 2\n        cards[cards.index(min(cards))] += 2\n        cards[cards.index(max(cards))] += 2\n    cards = sorted(cards)\n    print(\" \".join(map(str, cards)))\n    return \" \".join(map(str, cards))"
    },
    {
        "number": 3153,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    ch1 = cards[:N // 2]\n    ch2 = cards[N // 2:]\n    cards = ch1 + ch2\n    c1, c2 = 0, 0\n    for i in range(M):\n        if cards[i] == 1:\n            c1 += 1\n        else:\n            c2 += 1\n    if c1 <= c2:\n        for i in range(len(cards)):\n            if cards[i] == 1:\n                cards[i] = 0\n            else:\n                cards[i] = 1\n    else:\n        for i in range(len(cards)):\n            if cards[i] == 2:\n                cards[i] = 0\n            else:\n                cards[i] = 2\n    return str(sum(cards))\n"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = [(i, int(x), int(y)) for i, x, y in [map(int, stdin_line.split()) for stdin_line in stdin.strip().splitlines()]]\n    events.sort(key=lambda x: x[2])\n    last_kid_played_with_toy = 0\n    for t, kid, toy in events:\n        if kid!= last_kid_played_with_toy:\n            last_kid_played_with_toy = kid\n            yield toy"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    x.sort()\n    if not x:\n        print(\"impossible\")\n        return\n\n    total_dur = int(stdin.split()[1])\n    events = []\n    for s, k, t in stdin.split()[2:]:\n        events.append((int(s), int(k), int(t)))\n    events = sorted(events, key=lambda x: (x[0], x[1], x[2]))\n    if events[0][2] == 0:\n        events = events[1:]\n\n    tot_kids = n\n    tot_toys = m\n\n    events_acc = deque()\n    events_acc.append((events[0][0], events[0][1], events[0][2]))\n    cur_time = events_acc[0][0]\n    cur_kid = events_acc[0][1]\n    cur_toy = events_acc[0][2]\n    can_play = True\n    play_time = 0\n    while True:\n        play_time += 1\n        if play_time == total_dur:\n            break\n        if not can_play:\n            break\n        if cur_time == events[0][0]:\n            if cur_time == events[0][0]:\n                if cur_kid == events_acc[0][1]:\n                    can_play = False\n                    break\n                if cur_kid == events_acc[0][1]:\n                    cur_kid = events_acc[0][1]\n                    cur_toy = events_acc[0][2]\n                    events_acc.popleft()\n                    cur_time = events_acc[0][0]\n                    play_time = 0\n                    continue\n            if cur_kid == events_acc[0][1]:\n                cur_kid = events_acc[0][1]\n                cur_toy = events_acc[0][2]\n                events_acc.popleft()\n                cur_time = events_acc[0][0]\n                play_time = 0\n                continue\n        if cur_toy == 0:\n            can_play = False\n            break\n        events_acc.append((events[0][0], events[0][1], events[0][2]))\n        cur_time = events_acc[-1][0]\n        cur_kid = events_acc[-1][1]\n        cur_toy = events_acc[-1][2]\n    if not can_play:\n        return \"impossible\"\n    return \" \".join(str(i) for i in x[:tot_kids] if i)"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d, e = map(int, stdin.split())\n    events = []\n    for _ in range(e):\n        s, k, t = map(int, stdin.split())\n        events.append((s, k, t))\n    return \"\"\n"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    d, e = list(map(int, stdin.split()))\n\n    events = []\n    for _ in range(e):\n        s, k, t = list(map(int, stdin.split()))\n        events.append((s, k, t))\n\n    events.sort(key=lambda x: x[0])\n    print(\"events: \", events)\n\n    kids = []\n    toys = []\n    for _ in range(n):\n        kids.append(0)\n        toys.append(0)\n\n    for e in events:\n        if e[2] == 0:\n            kids[e[1]] = e[1]\n            toys[e[1]] = e[2]\n        else:\n            kids[e[1]] = e[2]\n            toys[e[1]] = e[1]\n\n    print(\"kids: \", kids)\n    print(\"toys: \", toys)\n    print(\"-------------\")\n    for e in events:\n        if e[2] == 0:\n            if toys[e[1]] > 0:\n                toys[e[1]] -= 1\n            else:\n                print(\"impossible\")\n                return \"impossible\"\n        else:\n            if kids[e[1]] > 0:\n                kids[e[1]] -= 1\n            else:\n                print(\"impossible\")\n                return \"impossible\"\n\n    return str(min(kids)) + \" \" + str(min(toys))\n\nstdin = \"\"\"3 2\n1 1 1\n2 2 2\n2 1 3\n\"\"\"\n\nprint(solution(stdin))"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(int(stdin.splitlines()[1])):\n        s, k, t = map(int, stdin.splitlines()[2].split())\n        events.append((s, k, t))\n    events.sort(key=lambda x: x[0])\n    results = []\n    last_d = 0\n    while events and events[0][0] <= last_d:\n        s, k, t = events.pop(0)\n        if t == 0:\n            if len(results) < n:\n                results.append(k)\n            else:\n                print(\"impossible\")\n                return\n        last_d = max(last_d, s + 1)\n    return \" \".join([str(i) for i in results])\n"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, e = (int(x) for x in stdin.split())\n    in_playtime = defaultdict(list)\n    for i in range(m):\n        s, k, t = (int(x) for x in input().split())\n        in_playtime[k].append((s, k, t))\n    in_playtime = {k: sorted(v) for k, v in in_playtime.items()}\n    in_playtime = {k: sorted(v, reverse=True) for k, v in in_playtime.items()}\n    toys = set(range(m))\n    events = []\n    for t, k in e:\n        events.append((t, k, 0))\n    events.sort(key=lambda x: x[0])\n    events = {k: v for k, v in Counter(e).items()}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[1], reverse=True)}\n    for _ in range(d):\n        events = {k: v for k, v in Counter(events).items() if v == 1}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v >= 2}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v in sorted(events.items(), key=lambda x: x[0])}\n    events = {k: v for k, v in events.items() if v == max(events.values())}\n    events = {k: v for k, v"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    last_times = [[int(i) for i in stdin.split()] for i in range(n)]\n\n    events = []\n    for day in range(m):\n        for kid in range(n):\n            if day in last_times[kid]:\n                continue\n            events.append((day, kid, last_times[kid][day - 1]))\n    events.sort(key=lambda x: x[2])\n\n    seen = set()\n    candidates = []\n    # candidates = []\n    for day, kid, last_time in events:\n        if day not in seen:\n            seen.add(day)\n            candidates.append(kid)\n\n    if len(candidates) > n:\n        return \"impossible\"\n\n    return \" \".join([str(i) for i in candidates])\n"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(s: str, t: str) -> bool:\n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == len(s)\n\n    N, M = map(int, stdin.split())\n    toys = list(map(int, stdin.split()))\n    events = [int(line) for line in stdin.split('\\n')[1:]]\n    events = sorted(events, key=lambda k: k[2])\n    for e in events:\n        if is_subsequence(toys, str(e[0])):\n            if is_subsequence(toys, str(e[1])):\n                toys.remove(e[1])\n            else:\n                toys.remove(e[0])\n            if is_subsequence(toys, str(e[2])):\n                toys.remove(e[2])\n            else:\n                toys.remove(e[1])\n            if not toys:\n                return 'impossible'\n    return''.join(map(str, toys))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    t_d = []\n    for _ in range(n):\n        t, d, e = list(map(int, stdin.split()))\n        t_d.append((t, d, e))\n    t_d.sort()\n    res = []\n    for t, d, e in t_d:\n        for s, k, t_ in t_d:\n            if s < d:\n                if t == 0:\n                    continue\n                if k!= t:\n                    break\n            else:\n                if k == t:\n                    break\n        else:\n            res.append(t)\n    if len(res) > 0:\n        return''.join(map(str, res))\n    else:\n        return 'impossible'"
    },
    {
        "number": 3154,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    kids = list(map(int, stdin.split()))\n    s, m = kids[0], kids[1]\n    events = sorted((i, k, t) for i, k, t in zip(*[map(int, stdin.split()) for stdin in stdin[1:].split('\\n')]))\n    last_d = 0\n    cur_d = events[0][0]\n    toy_assignments = []\n    # print(events)\n    for k, t, e in events:\n        # print(k, t, e)\n        if e - cur_d > m:\n            break\n        if e - cur_d > last_d:\n            toy_assignments.append(-1)\n        elif e - cur_d <= last_d:\n            toy_assignments.append(t)\n        last_d = e - cur_d\n        cur_d = e\n    if len(toy_assignments) > 0:\n        return''.join(str(a) for a in toy_assignments)\n    else:\n        return 'impossible'\n\n\nprint(solution(input()))"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    def b(n):\n        if n == 1:\n            return 1\n        return n * b(n - 1)\n\n    def z(n, k):\n        return b(n) / (b(k) * b(n - k))\n\n    return str(round(z(n, n // 2)))"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    c = 0\n    a = 0\n    b = 1\n    while True:\n        c = a + b\n        a = b\n        b = c\n        if c == int(stdin):\n            return str(a) +'' + str(b)"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split(' ')))\n    for i, n in enumerate(stdin):\n        for k in range(n+1):\n            if k * (n-k) == n:\n                return str(n) +'' + str(k)\nprint(solution(input()))\n"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    for n in range(1, 10**10):\n        for k in range(1, 10**10):\n            if n*k == X:\n                return str(n) + \" \" + str(k)"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n\n    # (n,k) = [(n-1)/k, n/k]\n    # n_fact = n * (n-1) / 2\n    # k_fact = k * (k-1)\n    # nk_fact = n * k\n    # nk_fact == X\n    n = X - 1\n    k = X\n\n    n_fact = (n-1) / 2\n    k_fact = (k-1) / 2\n    nk_fact = n * k\n\n    def bin_n(n):\n        # Return nth binomial coefficient\n        if n == 0:\n            return 1\n        elif n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return (n*(n-1))//2\n\n    def bin_k(k):\n        # Return kth binomial coefficient\n        if k == 0:\n            return 1\n        elif k == 1:\n            return 1\n        elif k == 2:\n            return 2\n        else:\n            return bin_n(k-1)\n\n    while (n_fact > n or k_fact > k) or (nk_fact!= X):\n        if n_fact > n or k_fact > k:\n            n = n - 1\n            n_fact = n * (n-1) / 2\n            k = k - 1\n            k_fact = k * (k-1)\n            nk_fact = n * k\n        elif nk_fact == X:\n            k = k - 1\n            k_fact = k * (k-1)\n            nk_fact = n * k\n        else:\n            n = n - 1\n            n_fact = n * (n-1) / 2\n            k = k - 1\n            k_fact = k * (k-1)\n            nk_fact = n * k\n\n        n_fact = n * (n-1) / 2\n        k_fact = k * (k-1)\n        nk_fact = n * k\n\n    return f\"{n} {k}\""
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if x <= 1 or x > 10 ** 100:\n        raise ValueError('invalid x')\n    dp = [-1] * (n + 1)\n    dp[1] = 1\n    for k in range(2, n + 1):\n        for j in range(k):\n            if j == 0 or dp[k - 1]!= 0:\n                dp[k] += dp[k - 1]\n    return str(dp[n])"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    x = int(n)\n    y = int(k)\n    if x == y:\n        return f\"{x} {y}\"\n    else:\n        if x > y:\n            return f\"{x} {y}\"\n        else:\n            return f\"{y} {x}\""
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    for n in range(1, x + 1):\n        for k in range(1, n + 1):\n            if n * k == x:\n                return str(n) + \" \" + str(k)\n\nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for n in range(1,10):\n        for k in range(1, 10):\n            if n*k == N:\n                return str(n) +'' + str(k)"
    },
    {
        "number": 3155,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    n = n % 20\n    return str(n) +'' + str(n)\n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    inventory = {'chocolate': int(stdin.split()[1]), 'icecream': int(stdin.split()[2]), 'cookies': int(stdin.split()[3])}\n    inventory = {k: v for k, v in sorted(inventory.items(), key=lambda item: item[0])}\n    stores = {i: [] for i in range(n)}\n    for i, j in inventory.items():\n        stores[j].append(i)\n    is_unique = False\n    while not is_unique:\n        is_unique = True\n        for i in range(n):\n            if len(stores[i]) == 1:\n                is_unique = False\n                stores[i][0] = stores[i][0].replace(' ', '')\n                print(stores[i][0], end='')\n                break\n        if is_unique:\n            return 'unique'\n    return 'impossible'"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split()[0])\n    # stores = list(map(lambda x: int(x), stdin.strip().split()[1:]))\n    stores = []\n    for i in range(n):\n        stores.append(stdin.strip().split()[i+1])\n    stores.sort()\n    inventory = {}\n    for i in range(len(stores)):\n        inventory[str(i)] = stores[i]\n    visited_stores = set()\n    stores_seen = set()\n    current_store_index = 0\n    # index = 0\n    all_visited = False\n    while len(visited_stores)!= n and not all_visited:\n        visited_stores.add(stores[current_store_index])\n        current_store_index += 1\n        store_items = inventory[str(current_store_index-1)]\n        for i in range(len(store_items)):\n            store_item = store_items[i]\n            if store_item in inventory and str(i) not in visited_stores:\n                # if the item can be found in the inventory, check if it was seen before\n                if str(i) not in stores_seen:\n                    visited_stores.add(str(i))\n                    stores_seen.add(str(i))\n                    all_visited = all_visited or (i == len(store_items)-1)\n    if all_visited:\n        return 'unique'\n    return 'ambiguous'\n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n ...\n  \n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_supermarkets, num_baskets = map(int, stdin.split())\n\n    store_inventory = {}\n    for i in range(num_supermarkets):\n        store_inventory[i] = set(input().split())\n\n    orders = []\n    for i in range(num_baskets):\n        orders.append(input().split())\n\n    stores = []\n    for order in orders:\n        if order[1] in store_inventory[int(order[0])]:\n            stores.append(int(order[0]))\n\n    if len(set(stores)) == 1:\n        return \"unique\"\n    else:\n        return \"ambiguous\"\n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inp = [i.split() for i in stdin.splitlines()]\n    stores = {}\n    for i in inp[1]:\n        stores[i[0]] = int(i[1])\n    ans = []\n    for i in inp[2]:\n        if i[0] not in ans:\n            ans.append(i[0])\n    res = []\n    if len(inp) == 1:\n        if len(ans) == 1:\n            res.append(ans[0])\n        return res\n    if len(ans) == 1:\n        return res\n    for i in range(len(ans)):\n        for j in range(len(ans)):\n            if i!= j:\n                tmp = [str(i) + str(j)]\n                tmp.append(ans[i])\n                tmp.append(ans[j])\n                tmp.append(stores[ans[i]] + stores[ans[j]])\n                res.append(tmp)\n    tmp = []\n    tmp.append(ans[0])\n    tmp.append(ans[1])\n    tmp.append(stores[ans[0]] + stores[ans[1]])\n    res.append(tmp)\n    return res"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    inventory = []\n    for _ in range(N):\n        inventory.append(input())\n    all_stores = {}\n    for i, item in enumerate(inventory):\n        store = (i+1, item)\n        all_stores[store[0]] = store[1]\n    items = {}\n    for item in all_stores.values():\n        items[item] = items.get(item, 0) + 1\n    stores = {}\n    for i in range(len(inventory)):\n        for j in range(len(inventory)):\n            if inventory[j] in items:\n                if i == j:\n                    continue\n                item = inventory[j]\n                store = (i+1, item)\n                if item not in stores:\n                    stores[item] = stores.get(item, 0) + 1\n                else:\n                    stores[item] += 1\n    for item, count in items.items():\n        if item not in stores:\n            return \"impossible\"\n        elif count > stores[item]:\n            return \"impossible\"\n        elif count == stores[item]:\n            return \"unique\"\n    return \"ambiguous\""
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin.pop(0))\n    inf = float('inf')\n    nodes = {}\n    for i in range(n):\n        if stdin[i] == \"chocolate\":\n            nodes[i] = inf\n        else:\n            nodes[i] = int(stdin.pop(0))\n    # print(nodes)\n    costs = {}\n    for i in range(n):\n        costs[i] = []\n    for i in range(n):\n        costs[i].append(nodes[i])\n    for _ in range(n-1):\n        for i in range(n):\n            for j in range(i+1, n):\n                if costs[i] < costs[j]:\n                    costs[i] = costs[j]\n                    costs[i].append(nodes[i])\n                    costs[j] = costs[i]\n                    costs[j].append(nodes[j])\n    shortest = inf\n    shortest_node = None\n    for i in range(n):\n        if costs[i] < shortest:\n            shortest = costs[i]\n            shortest_node = i\n    if shortest == inf:\n        return \"impossible\"\n    else:\n        return str(shortest_node) +'' + str(shortest)\n\nsolution(input())\n\n\"\"\"\n\nclass Solution:\n    def retraceSteps(self, stdin):\n        # Write your code here\n        if stdin == \"impossible\":\n            return \"impossible\"\n        else:\n            node_list = stdin.split()\n            n = int(node_list.pop(0))\n            node_dict = {}\n            for i in range(n):\n                if node_list[i] == \"chocolate\":\n                    node_dict[i] = 0\n                else:\n                    node_dict[i] = int(node_list.pop(0))\n            cost_list = {}\n            for i in range(n):\n                cost_list[i] = []\n            for i in range(n):\n                cost_list[i].append(node_dict[i])\n            for i in range(n-1):\n                for j in range(i+1, n):\n                    if cost_list[i] < cost_list[j]:\n                        cost_list[i] = cost_list[j]\n                        cost_list[i].append(node_dict[i])\n                        cost_list[j] = cost_list[i]\n                        cost_list[j].append(node_dict[j])\n            node_set = set()\n            for i in range(n):\n                node_set.add(node_dict[i])\n            \n            if len(node_set) < 2:\n                return \"impossible\"\n            else:\n                return str(node_dict[0]) +'' + str(node_dict[-1])\n            \n                \n                \n            \n        \n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    inventory = {i: set() for i in range(N)}\n    for i in range(M):\n        _, item = stdin.split()\n        inventory[i].add(item)\n    stores = sorted(inventory.keys())\n    path = \"\"\n    for store in stores:\n        inventory = {item: set() for item in inventory}\n        path += f\"{store} \"\n        for item in inventory.keys():\n            inventory[item] = inventory[item].union(inventory[store])\n            inventory[item] = inventory[item].difference(inventory[store])\n    return path[:-1] if len(path) else \"impossible\"\n"
    },
    {
        "number": 3156,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the correct answer.\n    \"\"\"\n    # Your code here\n    stdin = stdin.strip()\n    data = [list(map(int, l.split())) for l in stdin.split('\\n')]\n    M = data[0][0]\n    stores = data[1:]\n    n = len(stores)\n    visited = [0]*n\n    paths = []\n    def get_paths(index, visited):\n        if index == n:\n            paths.append(visited)\n            return\n        for i in range(len(stores[index])):\n            if not visited[i]:\n                visited[i] = 1\n                get_paths(index+1, visited)\n                visited[i] = 0\n    get_paths(0, visited)\n    print(paths)\n    return \"ambiguous\" if len(paths) > 1 else \"unique\" if len(paths) == 1 else \"impossible\""
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    m += 1\n    modulo = 2 ** m\n    res = 0\n    while k:\n        k %= modulo\n        k *= 33\n        k %= modulo\n        res += k // modulo\n        k %= modulo\n    return str(res)\n    \n    \n"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    return str(N-1)\n"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    if N == 0 and K == 0 and M == 0:\n        return '0'\n\n    # Upper bound of length is 10^11\n    # Lower bound is 10^(10 - (M - 1))\n    lower_bound = 10 ** (10 - (M - 1))\n    upper_bound = (10 ** M) - 1\n    count = 0\n    for word in range(lower_bound, upper_bound + 1):\n        if is_valid(word, N, M):\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    return str(N - len(filter(lambda w: hash(w) == K, range(N))))"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    return str(bin(K).count(\"1\"))"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    count = 0\n    for k in range(1, 2**M + 1):\n        if k % 2 == 0:\n            continue\n        count += (k + K) * pow(33, M - 2, 2**M) * (K % 2)\n        count %= 2**M\n    return str(count)\n"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = stdin.split(\" \")\n    return str(sum([int((K ** (i + 1)) % int(M)) * int(ord(c)) % int(M) for i, c in enumerate(N)]))"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    hash = lambda word: sum([(ord(c) - ord('a') + 1) * 33 for c in word]) % M\n    return sum(1 for word in range(N) if hash(word) == K)\nsolution(input())\n"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split()\n    n = int(tokens[0])\n    k = int(tokens[1])\n    m = int(tokens[2])\n    # Your code here\n    a = 0\n    while a <= k:\n        a = a * 33 % (2 ** m)\n    return str(a)"
    },
    {
        "number": 3157,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2**M\n    num_words = 0\n    # Base case\n    if K == 0:\n        return str(num_words)\n    # Recursive case\n    for word in stdin.split():\n        word_length = len(word)\n        remainder = K % mod\n        # 1, 2, 3,..., 26\n        # ord_letter = ord(word[0])\n        # for letter in word:\n        #     ord_letter = (ord_letter * 33) % mod\n        #     ord_letter = ord_letter + ord(letter)\n        ord_letter = K % mod\n        if word_length == 1:\n            ord_letter = (ord_letter * 33) % mod\n        elif word_length == 2:\n            ord_letter = (ord_letter * 33 * 2) % mod\n            ord_letter = ord_letter + ord(word[1])\n        else:\n            ord_letter = (ord_letter * 33 * 2) % mod\n            ord_letter = ord_letter + ord(word[1])\n            ord_letter = (ord_letter * 33 * 2) % mod\n            ord_letter = ord_letter + ord(word[2])\n        ord_letter = (ord_letter * 33 * 2) % mod\n        ord_letter = ord_letter + ord(word[3])\n        num_words += 1\n        K = K // mod\n    return str(num_words)"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    grip1, grip2 = lines[0].split(\"...\"), lines[1].split(\"...\")\n    grip1_t, grip2_t = [], []\n    for i in range(len(grip1)):\n        grip1_t.append(grip1[i].split(\" \"))\n    for i in range(len(grip2)):\n        grip2_t.append(grip2[i].split(\" \"))\n    for i in range(len(grip1_t)):\n        grip1_t[i].append(1)\n        grip2_t[i].append(1)\n    grip1_t = sorted(grip1_t, key=lambda x: x[0])\n    grip2_t = sorted(grip2_t, key=lambda x: x[0])\n    for i in range(len(grip1_t)):\n        grip1_t[i].append(1)\n        grip2_t[i].append(1)\n    grip1_t = sorted(grip1_t, key=lambda x: x[1])\n    grip2_t = sorted(grip2_t, key=lambda x: x[1])\n    grip_t = []\n    for i in range(len(grip1_t)):\n        grip_t.append(grip1_t[i] + grip2_t[i])\n    grip_t = sorted(grip_t, key=lambda x: x[0])\n    distance = 0\n    for i in range(len(grip_t)):\n        distance += abs(grip_t[i][1] - grip_t[i][0])\n    if distance < 10000 and distance > 10000:\n        distance = 10000\n    if abs(grip_t[0][0] - grip_t[1][0]) < 10000 and abs(grip_t[0][1] - grip_t[1][1]) < 10000:\n        distance = 10000\n    if distance < 20000 and distance > 20000:\n        distance = 20000\n    if abs(grip_t[0][0] - grip_t[len(grip_t) - 1][0]) < 20000 and abs(grip_t[0][1] - grip_t[len(grip_t) - 1][1]) < 20000:\n        distance = 20000\n    if distance < 10000 and distance > 10000:\n        distance = 10000\n    if abs(grip_t[0][0] - grip_t[len(grip_t) - 1][0]) < 10000 and abs(grip_t[0][1] - grip_t[len(grip_t) - 1][1]) < 10000:\n        distance = 10000\n    if distance < 10000:\n        return distance\n    else:\n        return distance\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    list = stdin.split(\"\\n\")\n    initial = list[0]\n    final = list[1]\n\n    initial = initial.split()\n    final = final.split()\n\n    initial = list[0].split()\n    final = list[1].split()\n\n    # initial = list[0].split()\n    # final = list[1].split()\n\n    initial = initial[1:]\n    final = final[1:]\n\n    # initial = list[0].split()\n    # final = list[1].split()\n    # print(initial)\n    # print(final)\n    initial = set(initial)\n    final = set(final)\n    initial = list(initial)\n    final = list(final)\n\n    # initial = []\n    # final = []\n\n    for i in range(len(initial)):\n        initial[i] = tuple(initial[i])\n        final[i] = tuple(final[i])\n\n    initial = set(initial)\n    final = set(final)\n    # print(initial)\n    # print(final)\n    initial = list(initial)\n    final = list(final)\n    # print(initial)\n    # print(final)\n    touch = []\n    # print(initial)\n    # print(final)\n    for i in range(len(initial)):\n        touch.append(tuple(initial[i]))\n    for i in range(len(final)):\n        touch.append(tuple(final[i]))\n    # print(touch)\n\n    touch = set(touch)\n\n    # print(touch)\n\n    final = []\n\n    for i in range(len(initial)):\n        final.append(tuple(final[i]))\n    for i in range(len(initial)):\n        final.append(tuple(final[i]))\n    final = set(final)\n    # print(final)\n\n    grip = []\n    for i in range(len(touch)):\n        grip.append(tuple(touch[i]))\n    grip = set(grip)\n\n    # print(grip)\n    final = list(final)\n    touch = list(touch)\n\n    # print(touch)\n    touch = set(touch)\n    # print(touch)\n    # print(touch)\n    final = list(final)\n    # print(touch)\n\n    touch = list(touch)\n    touch = set(touch)\n\n    # print(touch)\n\n    touch = set(touch)\n    touch = list(touch)\n\n    # print(touch)\n    # print(final)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    # print(touch)\n    touch = list(touch)\n\n    touch = set(touch)\n\n    # print(touch)\n    # print(touch)\n    touch = set(touch)\n    # print(touch)\n    touch = tuple(touch)\n    # print(touch)\n    touch = list(touch)\n\n    touch = set(touch)\n    touch = tuple(touch)\n    # print(touch)\n    # print(touch)\n    touch = tuple(touch)\n    # print(touch)\n    # print(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    # print(touch)\n    # print(touch)\n    touch = tuple(touch)\n    # print(touch)\n\n    # print(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    # print(touch)\n    # print(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    # print(touch)\n    # print(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)\n    touch = set(touch)\n    touch = tuple(touch)\n    touch = list(touch)"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    lines = len(stdin)\n    if lines <= 1:\n        raise Exception('The input does not contain any images.')\n    if lines == 2:\n        # A single image.\n        image1 = stdin[0].strip()\n        image2 = stdin[1].strip()\n        if (len(image1)!= 15 * 30) or (len(image2)!= 15 * 30):\n            raise Exception('The input images do not contain the right number of pixels.')\n        if (image1[0]!= '.') or (image2[0]!= '.'):\n            raise Exception('The input images contain incorrect characters.')\n        if (image1[-1]!= '.') or (image2[-1]!= '.'):\n            raise Exception('The input images contain incorrect characters.')\n\n        pan_distance = pan(image1, image2)\n        zoom_distance = zoom(image1, image2)\n        rotation_distance = rotation(image1, image2)\n\n        pan_type = classify(pan_distance)\n        zoom_type = classify(zoom_distance)\n        rotation_type = classify(rotation_distance)\n\n        if pan_type == 'pan':\n            pan_direction = pan_direction(pan_distance)\n            if pan_direction == 'out':\n                zoom_direction = 'in'\n            else:\n                zoom_direction = 'out'\n        else:\n            pan_direction = 'out'\n            zoom_direction = zoom_direction(zoom_distance)\n            if zoom_direction == 'in':\n                rotation_direction = 'out'\n            else:\n                rotation_direction = 'in'\n\n        return (str(pan_distance) +'' + pan_type +'' + pan_direction +\n               '' + str(zoom_distance) +'' + zoom_type +'' + zoom_direction +\n               '' + str(rotation_distance) +'' + rotation_type +'' + rotation_direction)\n    else:\n        # A pair of images.\n        # Find images.\n        lines = len(stdin)\n        image1 = stdin[0].strip()\n        image2 = stdin[1].strip()\n        if (len(image1)!= 15 * 30) or (len(image2)!= 15 * 30):\n            raise Exception('The input images do not contain the right number of pixels.')\n        if (image1[0]!= '.') or (image2[0]!= '.'):\n            raise Exception('The input images contain incorrect characters.')\n        if (image1[-1]!= '.') or (image2[-1]!= '.'):\n            raise Exception('The input images contain incorrect characters.')\n\n        initial_pan_distance = pan(image1, image2)\n        final_pan_distance = pan(image2, image1)\n        initial_zoom_distance = zoom(image1, image2)\n        final_zoom_distance = zoom(image2, image1)\n        initial_rotation_distance = rotation(image1, image2)\n        final_rotation_distance = rotation(image2, image1)\n\n        # Find direction.\n        if (initial_zoom_distance < initial_pan_distance) or (\n                initial_zoom_distance < final_pan_distance):\n            # The first image is zoomed.\n            initial_pan_direction = 'out'\n            initial_zoom_direction = zoom_direction(initial_zoom_distance)\n            initial_rotation_direction = 'out'\n            final_pan_direction = 'in'\n            final_zoom_direction = 'in'\n            final_rotation_direction = rotation_direction(final_rotation_distance)\n\n        else:\n            initial_pan_direction = pan_direction(initial_pan_distance)\n            initial_zoom_direction = zoom_direction(initial_zoom_distance)\n            initial_rotation_direction = rotation_direction(initial_rotation_distance)\n            final_pan_direction = pan_direction(final_pan_distance)\n            final_zoom_direction = zoom_direction(final_zoom_distance)\n            final_rotation_direction = rotation_direction(final_rotation_distance)\n\n        initial_pan_type = classify(initial_pan_distance)\n        final_pan_type = classify(final_pan_distance)\n        initial_zoom_type = classify(initial_zoom_distance)\n        final_zoom_type = classify(final_zoom_distance)\n        initial_rotation_type = classify(initial_rotation_distance)\n        final_rotation_type = classify(final_rotation_distance)\n\n        if (initial_pan_type == 'pan') and (final_pan_type == 'pan'):\n            pan_direction = initial_pan_direction\n            zoom_direction = final_zoom_direction\n            rotation_direction = final_rotation_direction\n        elif (initial_pan_type == 'pan') and (initial_zoom_type == 'pan'):\n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\\n\")\n    stdin = stdin[1:]\n\n    zoom = []\n    pan = []\n    rotation = []\n    for i in range(len(stdin)):\n        image = stdin[i].split()\n        image = image[1:-1]\n\n        first_row = []\n        second_row = []\n        for j in range(len(image)):\n            first_row.append(image[j][0])\n            second_row.append(image[j][-1])\n\n        if i == 0:\n            zoom.append(first_row)\n            zoom.append(second_row)\n        elif i == 1:\n            pan.append(first_row)\n            pan.append(second_row)\n        else:\n            rotation.append(first_row)\n            rotation.append(second_row)\n\n    zoom = sorted(zoom, key=lambda x: x.index(\".\"))\n    pan = sorted(pan, key=lambda x: x.index(\".\"))\n    rotation = sorted(rotation, key=lambda x: x.index(\".\"))\n\n    ans = \"\"\n    if len(zoom) == 1:\n        ans += \"1 zoom out\"\n    elif len(zoom) == 2:\n        if abs(int(zoom[0].index(\".\")) - int(zoom[1].index(\".\"))) < 15:\n            ans += \"1 zoom out\"\n        elif abs(int(zoom[0].index(\".\")) - int(zoom[1].index(\".\"))) > 15:\n            ans += \"2 zoom in\"\n        else:\n            ans += \"0 zoom\"\n    else:\n        ans += \"0 zoom\"\n    ans += \"\\n\"\n\n    if len(pan) == 1:\n        ans += \"1 pan\"\n    elif len(pan) == 2:\n        if abs(int(pan[0].index(\".\")) - int(pan[1].index(\".\"))) < 15:\n            ans += \"1 pan\"\n        elif abs(int(pan[0].index(\".\")) - int(pan[1].index(\".\"))) > 15:\n            ans += \"2 pan\"\n        else:\n            ans += \"0 pan\"\n    else:\n        ans += \"0 pan\"\n    ans += \"\\n\"\n\n    if len(rotation) == 1:\n        ans += \"1 rotate\"\n    elif len(rotation) == 2:\n        if abs(int(rotation[0].index(\".\")) - int(rotation[1].index(\".\"))) < 15:\n            ans += \"1 rotate\"\n        elif abs(int(rotation[0].index(\".\")) - int(rotation[1].index(\".\"))) > 15:\n            ans += \"2 rotate\"\n        else:\n            ans += \"0 rotate\"\n    else:\n        ans += \"0 rotate\"\n\n    return ans\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns \n    [int, str]\n    '''\n    res = stdin.split('\\n\\n')\n    res.remove('')\n    res.remove('\\n')\n    result = []\n    for image in res:\n        result.append(list(map(int, image.split('\\n'))))\n    return res\n\n    \n    \n    \n    \n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    img1 = lines[0]\n    img2 = lines[1]\n    img1 = img1.replace(\".\", \"\")\n    img1 = img1.replace(\"X\", \"1\")\n    img2 = img2.replace(\".\", \"\")\n    img2 = img2.replace(\"X\", \"1\")\n\n    img1 = img1.split(\" \")\n    img2 = img2.split(\" \")\n\n    x1, y1, x2, y2 = 0, 0, 0, 0\n    for i in range(len(img1)):\n        if img1[i] == \"1\":\n            x1 = i\n            break\n\n    for i in range(len(img2)):\n        if img2[i] == \"1\":\n            x2 = i\n            break\n\n    for i in range(len(img1)):\n        if img1[i] == \"1\":\n            y1 = i\n            break\n\n    for i in range(len(img2)):\n        if img2[i] == \"1\":\n            y2 = i\n            break\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    if x1 < 0:\n        x1 = 0\n    if y1 < 0:\n        y1 = 0\n    if x2 < 0:\n        x2 = 0\n    if y2 < 0:\n        y2 = 0\n\n    pan = abs(x1 - x2)\n    zoom = abs(y1 - y2)\n    if pan > zoom:\n        zoom = pan\n    if x1 < x2:\n        zoom *= -1\n    rotation = 0\n    if pan > zoom:\n        rotation = 0\n    else:\n        rotation = 90 if x1 > x2 else -90\n    r_value = rotation * math.pi / 180\n    if y1 > y2:\n        r_value = -r_value\n    final = abs((y1 * math.cos(r_value) + y2 * math.cos(r_value)) -\n                (x1 * math.sin(r_value) + x2 * math.sin(r_value)))\n    return f\"{pan} {zoom} {rotation} {final}\"\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # print(stdin)\n    # print(\"solution\")\n    # print(stdin.count(\"X\"))\n    # print(stdin[::3])\n    # print(stdin[1::3])\n    # print(stdin[2::3])\n    # print(stdin[0::3])\n    # print(stdin[1::3])\n    # print(stdin[2::3])\n    # print(stdin[3::3])\n\n    # print(stdin)\n    # print(len(stdin))\n\n    # print(stdin.count(\"X\"))\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n\n    # print(stdin.count(\"X\"))\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n\n    # print(stdin.count(\"X\"))\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n\n    # print(len(stdin) / 3)\n    # print(len(stdin) / 2)\n    # print(len(stdin) / 3)\n    "
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   .....XXXX.\n   ....XXXXX.\n   ....X.XXX.\n   ......X.XX.\n   .......XX.\n   ....XXX.XX\n   .....X.X..\n   ......XXXX.\n   .....XXXXX\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n   .....XXX.\n"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split(\"\\n\")\n    if len(lines) == 1:\n        return \"0 pan\"\n\n    stdout = \"\"\n\n    image_a = lines[0]\n    image_b = lines[1]\n\n    # Get pixel values\n    image_a_pixels = get_pixels(image_a)\n    image_b_pixels = get_pixels(image_b)\n\n    pan_touch = [0, 0, 0, 0, 0]\n    zoom_touch = [0, 0, 0, 0, 0]\n    rotate_touch = [0, 0, 0, 0, 0]\n    pan_touch_dir = \"\"\n    zoom_touch_dir = \"\"\n    rotate_touch_dir = \"\"\n\n    # 1 pan\n    pan_touch[0] = (\n        get_distance(get_pixel(image_a_pixels, 1, 4), get_pixel(image_a_pixels, 5, 4))\n        + get_distance(get_pixel(image_a_pixels, 1, 5), get_pixel(image_a_pixels, 2, 5))\n        + get_distance(get_pixel(image_a_pixels, 1, 2), get_pixel(image_a_pixels, 3, 2))\n        + get_distance(get_pixel(image_a_pixels, 1, 3), get_pixel(image_a_pixels, 4, 3))\n        + get_distance(get_pixel(image_a_pixels, 1, 4), get_pixel(image_a_pixels, 1, 2))\n    )\n\n    # 2 zoom out\n    zoom_touch[0] = (\n        get_distance(get_pixel(image_b_pixels, 1, 1), get_pixel(image_b_pixels, 2, 1))\n        + get_distance(get_pixel(image_b_pixels, 1, 2), get_pixel(image_b_pixels, 3, 2))\n        + get_distance(get_pixel(image_b_pixels, 1, 3), get_pixel(image_b_pixels, 4, 3))\n        + get_distance(get_pixel(image_b_pixels, 1, 4), get_pixel(image_b_pixels, 1, 2))\n        + get_distance(get_pixel(image_b_pixels, 1, 5), get_pixel(image_b_pixels, 2, 5))\n        + get_distance(get_pixel(image_b_pixels, 1, 6), get_pixel(image_b_pixels, 3, 6))\n        + get_distance(get_pixel(image_b_pixels, 1, 7), get_pixel(image_b_pixels, 4, 7))\n        + get_distance(get_pixel(image_b_pixels, 1, 8), get_pixel(image_b_pixels, 1, 2))\n        + get_distance(get_pixel(image_b_pixels, 1, 9), get_pixel(image_b_pixels, 2, 9))\n        + get_distance(get_pixel(image_b_pixels, 1, 10), get_pixel(image_b_pixels, 3, 10))\n        + get_distance(get_pixel(image_b_pixels, 1, 11), get_pixel(image_b_pixels, 4, 11))\n        + get_distance(get_pixel(image_b_pixels, 1, 12), get_pixel(image_b_pixels, 1, 3))\n        + get_distance(get_pixel(image_b_pixels, 1, 13), get_pixel(image_b_pixels, 2, 3))\n        + get_distance(get_pixel(image_b_pixels, 1, 14), get_pixel(image_b_pixels, 3, 3))\n        + get_distance(get_pixel(image_b_pixels, 1, 15), get_pixel(image_b_pixels, 4, 3))\n        + get_distance(get_pixel(image_b_pixels, 1, 16), get_pixel(image_b_pixels, 1, 4))\n        + get_distance(get_pixel(image_b_pixels, 1, 17), get_pixel(image_b_pixels, 2, 4))\n        + get_distance(get_pixel(image_b_pixels, 1, 18), get_pixel(image_b_pixels, 3, 4))\n        + get_distance(get_pixel(image_b_pixels, 1, 19), get_pixel(image_b_pixels, 4, 4))\n        + get_distance(get_pixel(image_b_pixels, 1, 20), get_pixel(image_b_pixels, 1, 5))\n        + get_distance(get_pixel(image_b_pixels, 1, 21), get_pixel(image_b_pixels, 2, 5))\n        + get_distance(get_pixel(image_b_pixels, 1, 22), get_pixel(image_b"
    },
    {
        "number": 3158,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data_list = stdin.split()\n    image_a = data_list[0]\n    image_b = data_list[1]\n    result = 0\n    grip_a = get_grip_points(image_a)\n    grip_b = get_grip_points(image_b)\n    grip_a_pan, grip_a_zoom = get_grip_speeds(grip_a)\n    grip_b_pan, grip_b_zoom = get_grip_speeds(grip_b)\n    if grip_a_zoom > grip_b_zoom:\n        result += 1\n    if grip_a_pan > grip_b_pan:\n        result += 1\n    if abs(grip_a_pan - grip_b_pan) > abs(grip_a_zoom - grip_b_zoom):\n        result += 1\n    if abs(grip_a_pan - grip_b_pan) == abs(grip_a_zoom - grip_b_zoom):\n        result += 1\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    web = stdin.rstrip().split('\\n')\n\n    for h_index in range(h - 1):\n        if len(web[h_index])!= len(web[h_index + 1]):\n            return 'Invalid Image'\n        for w_index in range(w):\n            if not all(web[h_index][w_index] == web[h_index + 1][w_index] for w_index in range(w)):\n                return 'Invalid Image'\n\n    if len(web) == 1:\n        return 'Invalid Image'\n    for w_index in range(w - 1):\n        if not all(web[h_index][w_index] == web[h_index][w_index + 1] for h_index in range(h)):\n            return 'Invalid Image'\n    return '\\n'.join(\n        ''.join(web[i][j] for i in range(h))\n        for j in range(w)\n    )\n"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    ..."
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _ = stdin()\n    return stdout()"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string representing a web page, and returns the web page with\n    all ads removed.\n    \"\"\"\n    lines = stdin.split(\"\\n\")\n    # We cannot remove all the ads from the web page, we can only remove\n    # images that have ad characters\n    lines = list(filter(lambda x: x!= \"\", lines))\n    lines = list(filter(lambda x: len(x) >= 3, lines))\n    lines = list(filter(lambda x: x[0]!= \"+\", lines))\n    lines = list(filter(lambda x: x[-1]!= \"+\", lines))\n    for i in range(len(lines)):\n        lines[i] = lines[i][1:-1]\n\n    # We are removing characters in the middle of the image\n    for i in range(len(lines)):\n        lines[i] = list(filter(lambda x: x in ascii_characters, lines[i]))\n        # If we find an image that contains only one character, remove it\n        if len(lines[i]) == 1:\n            lines[i] = \" \"\n        elif len(lines[i]) == 0:\n            lines[i] = \" \"\n\n    # We are removing the borders of the image\n    lines = list(map(lambda x: x[1:-1], lines))\n\n    # We are removing any character that is not allowed in images\n    for i in range(len(lines)):\n        lines[i] = list(filter(lambda x: x in banned_characters, lines[i]))\n\n    # We are removing any character that is not allowed in the image and that is not surrounded by other characters\n    lines = list(filter(lambda x: len(x) > 0 and (x[0] not in banned_characters), lines))\n    lines = list(filter(lambda x: len(x) > 0 and (x[-1] not in banned_characters), lines))\n\n    # We are removing any character that is not allowed in the image, but not in the border\n    lines = list(filter(lambda x: len(x) > 0, lines))\n    lines = list(map(lambda x: x[1:-1], lines))\n    lines = list(filter(lambda x: x not in banned_characters, lines))\n    lines = list(filter(lambda x: x not in banned_characters, lines))\n\n    # We are removing any character that is not allowed in the image, but not in the border, and not in the image\n    lines = list(filter(lambda x: len(x) > 0, lines))\n    lines = list(map(lambda x: x[1:-1], lines))\n    lines = list(filter(lambda x: x not in banned_characters, lines))\n    lines = list(filter(lambda x: x not in banned_characters, lines))\n\n    return \"\\n\".join(lines)\n"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    lines = list()\n    for i in range(n):\n        lines.append(stdin.strip().replace(\"\\n\", \"\").replace(\" \", \"\").replace(\"+\", \"*\"))\n    lines.sort()\n    new_lines = lines[:]\n    for i in range(len(lines) - 1):\n        if lines[i] == lines[i + 1] and lines[i]!= \" \" and lines[i]!= \"\\n\":\n            new_lines.remove(lines[i])\n    for i in range(len(lines) - 1):\n        if len(lines[i]) == len(lines[i + 1]) and lines[i]!= lines[i + 1] and lines[i]!= \" \" and lines[i]!= \"\\n\":\n            new_lines.remove(lines[i])\n    for i in range(len(lines) - 1):\n        if lines[i] == lines[i + 1]:\n            new_lines.remove(lines[i])\n    answer = \"\".join(new_lines)\n    return answer\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    stdin = stdin.split()\n    image = stdin[0]\n    t = stdin[1:]\n    for i in t:\n        if re.match(r\"\\s\", i):\n            pass\n        else:\n            image = image.replace(i, \"\")\n    return image"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, n = list(map(int, stdin.split()))\n    res = []\n    ans = ''\n\n    for i in range(m):\n        res.append(input().rstrip())\n        for j in range(n):\n            if res[i][j] == '$':\n                if res[i - 1][j] == '$':\n                    res[i] =''\n                    res[i - 1] =''\n                if res[i + 1][j] == '$':\n                    res[i] =''\n                    res[i + 1] =''\n                if res[i][j + 1] == '$':\n                    res[i] =''\n                    res[i + 1] =''\n                if res[i][j - 1] == '$':\n                    res[i] =''\n                    res[i + 1] =''\n    for i in range(m):\n        ans += res[i] + '\\n'\n    return ans\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    h, w = list(map(int, lines.pop(0).split()))\n    new_lines = []\n    for line in lines:\n        if line == '+++':\n            continue\n        new_lines.append(line)\n    return '\\n'.join(new_lines)\n"
    },
    {
        "number": 3159,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # return # Replace this.\n    H, W = stdin.split()\n    H = int(H)\n    W = int(W)\n    my_image = []\n    for x in range(H):\n        my_image.append(stdin.replace(\"++++\", \" \").replace(\"++\", \" \").replace(\"+\", \" \"))\n    my_image = '\\n'.join(my_image)\n    return my_image\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return str(0)\n    else:\n        l = 0\n        for i in range(1, n):\n            l += i\n        return str(l)\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    # Your code here\n    return s"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    def gen_sequence(N, operation, turn):\n        sequence = []\n        for i in range(N):\n            sequence.append(operation)\n            if turn == 'H':\n                if i == 0:\n                    sequence.append('?')\n                elif sequence[i-1] == '?':\n                    sequence.append('H')\n            else:\n                sequence.append('T')\n            if i == N-1:\n                sequence.append('T')\n            turn = 'T' if turn == 'H' else 'H'\n        return sequence\n    turn = 'H'\n    sequence = gen_sequence(N, 'TH', turn)\n    average = 0\n    for i in range(1, N):\n        average += gen_sequence(N, sequence[i], turn)\n    return str(average/(N*(N-1)/2))\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin\n    input_lst = []\n    for i in range(len(input_str)):\n        if input_str[i]!= '?':\n            input_lst.append(input_str[i])\n    if len(input_lst) == 0:\n        input_lst.append('H')\n    if len(input_lst) == 1:\n        input_lst.append('H')\n    input_lst.append('H')\n    lst_len = len(input_lst)\n    for i in range(lst_len-1):\n        for j in range(lst_len-i-1):\n            if input_lst[j] == '?' and input_lst[j+1] == '?' and input_lst[j+2] == '?':\n                input_lst[j], input_lst[j+1], input_lst[j+2] = input_lst[j+2], input_lst[j+1], input_lst[j]\n                return ''.join(input_lst)\n    input_lst[0] = input_lst[0].replace('?','H')\n    return ''.join(input_lst)"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = int(s.split()[0])\n    i = 1\n    ans = 0\n    while i <= n:\n        if s[i] == \"H\":\n            ans += 1\n        i += 1\n    print(ans / n)\n    return \"%.5f\" % (ans / n)\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    lines = lines[1:]\n    count = 0\n    for line in lines:\n        # remove all `\\n`\n        line = line.strip('\\n')\n        line_arr = line.split('H')\n        # print(line_arr)\n        # check line length\n        if len(line_arr) < 2:\n            continue\n        # if length = 3, H -> HH\n        if len(line_arr) == 2:\n            if line_arr[0] == '?':\n                count += 2\n            else:\n                count += 1\n            continue\n        # remove H at index 0\n        line_arr.pop(0)\n        if len(line_arr) == 2:\n            # if length = 3, H -> HH\n            if line_arr[0] == '?':\n                count += 2\n            else:\n                count += 1\n            continue\n        if len(line_arr) == 3:\n            if line_arr[0] == '?':\n                count += 2\n            else:\n                count += 1\n            if line_arr[1] == '?':\n                count += 2\n            else:\n                count += 1\n            if line_arr[2] == '?':\n                count += 2\n            else:\n                count += 1\n            continue\n\n    print(count/len(lines))\n    return str(count/len(lines))"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    if not stdin:\n        return '0.0'\n    a = stdin.count('H')\n    b = stdin.count('?')\n    return str(a / (b + 0.5))\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d = {}\n    s = stdin\n    # Write your code here\n    while True:\n        print(d)\n        if 'H' in s:\n            if 'T' in s:\n                c = s.index('H')\n                s = s[:c] + 'T' + s[c+1:]\n        else:\n            print(s)\n            break\n    return s\n"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *coins = map(int, stdin.split())\n    ans = 0\n    for i in range(2, m + 1):\n        ans += (n // i + 1) * (i // 2) // 2\n    for i in range(m - 2):\n        ans += (n // i + 1) * (i // 2) // 2\n    return f\"{ans / m:.2f}\"\nfor _ in range(int(input())):\n    print(solution(input()))"
    },
    {
        "number": 3160,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # replace this for solution\n    return repr(a)"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    number = int(stdin)\n    res = []\n    if number == 1:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n    if number == 2:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 3:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 4:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 5:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 6:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 7:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 8:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 9:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 10:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 11:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 12:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 13:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 14:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 15:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 16:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n    if number == 17:\n        for i in range(1,number+1):\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n            res.append(i)\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n = int(stdin.pop(0))\n    squares = stdin\n    paintings = []\n    min_diff = n ** 2\n    while squares:\n        paintings.append(squares.pop(0))\n        squares = squares[1:]\n        if len(paintings) % 2 == 0:\n            diff = sum(paintings[0::2])\n            paintings.append(paintings[0])\n            paintings.append(paintings[1])\n            diff += sum(paintings[2::2])\n        else:\n            diff = sum(paintings[0::2]) + sum(paintings[1::2])\n        min_diff = min(min_diff, diff)\n        paintings.clear()\n    return str(min_diff)\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if not n & 1:\n        print(0)\n        return\n    n = n >> 1\n    for i in range(1 << n):\n        p = i\n        pixels = [[0] * n for _ in range(n)]\n        for j in range(n):\n            pixels[j][j] = 1\n        for j in range(n):\n            if p & 1:\n                pixels[j][j - 1] = 1\n            p >>= 1\n        for j in range(n):\n            if p & 1:\n                pixels[j - 1][j] = 1\n            p >>= 1\n        for j in range(n):\n            if p & 1:\n                pixels[j][j + 1] = 1\n            p >>= 1\n        for j in range(n):\n            if p & 1:\n                pixels[j + 1][j] = 1\n            p >>= 1\n        for j in range(n):\n            for k in range(n):\n                if pixels[j][k]!= pixels[k][j]:\n                    return \"ERROR\"\n        if stdin[0]!= 'ERROR':\n            return \"ERROR\"\n        for k in range(1 << n):\n            pixels_new = [[0] * n for _ in range(n)]\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j - 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j + 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j - 1][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j + 1][j] = 1\n            for j in range(n):\n                for k in range(n):\n                    if pixels_new[j][k]!= pixels[j][k]:\n                        return \"ERROR\"\n        if stdin[0]!= 'ERROR':\n            return \"ERROR\"\n        for k in range(1 << n):\n            pixels_new = [[0] * n for _ in range(n)]\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j - 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j + 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j - 1][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j + 1][j] = 1\n            for j in range(n):\n                for k in range(n):\n                    if pixels_new[j][k]!= pixels[j][k]:\n                        return \"ERROR\"\n        if stdin[0]!= 'ERROR':\n            return \"ERROR\"\n        for k in range(1 << n):\n            pixels_new = [[0] * n for _ in range(n)]\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j - 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j + 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j - 1][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j + 1][j] = 1\n            for j in range(n):\n                for k in range(n):\n                    if pixels_new[j][k]!= pixels[j][k]:\n                        return \"ERROR\"\n        if stdin[0]!= 'ERROR':\n            return \"ERROR\"\n        for k in range(1 << n):\n            pixels_new = [[0] * n for _ in range(n)]\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j - 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j + 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j - 1][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j + 1][j] = 1\n            for j in range(n):\n                for k in range(n):\n                    if pixels_new[j][k]!= pixels[j][k]:\n                        return \"ERROR\"\n        if stdin[0]!= 'ERROR':\n            return \"ERROR\"\n        for k in range(1 << n):\n            pixels_new = [[0] * n for _ in range(n)]\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j - 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j][j + 1] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j - 1][j] = 1\n            for j in range(n):\n                if k & (1 << j):\n                    pixels_new[j + 1][j] = 1\n            for j in range(n):\n                for k in range(n):\n                    if pixels_new[j][k]!= pixels[j][k]:\n                        return"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines.pop(0))\n    paintings = []\n    while len(lines) > 0:\n        square = []\n        for i in range(N):\n            square.append(lines.pop(0))\n        paintings.append(square)\n    min_diff = float('inf')\n    for x in range(2 ** N):\n        for y in range(2 ** N):\n            diff = 0\n            for i in range(N):\n                if (paintings[x][i]!= square[i]) ^ (paintings[y][i]!= square[i]):\n                    diff += 1\n            if diff < min_diff:\n                min_diff = diff\n    return min_diff\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    res = 0\n    n = int(stdin)\n    while n > 1:\n        res += (n & 1)\n        n >>= 1\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    picture_dict = {\n        '0001':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [0, 0, 0]],\n        '0011':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [0, 0, 0]],\n        '1111':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [0, 0, 0]],\n        '1101':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [0, 0, 0]],\n        '0111':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [0, 0, 0]],\n        '0001':\n            [[1, 1, 1],\n             [1, 1, 1],\n             [1, 1, 1]]\n    }\n\n    picture_list = []\n    for i in range(len(stdin)):\n        picture_list.append(picture_dict[stdin[i]])\n\n    def compare_pixels(picture1, picture2):\n        for i in range(len(picture1)):\n            for j in range(len(picture1)):\n                if picture1[i][j]!= picture2[i][j]:\n                    return i, j\n\n    def solution(picture_list):\n        # dictionary contains for each number of squares the difference\n        # between the pairs of squares in the corresponding position\n        pairs_dict = {}\n        for picture in picture_list:\n            if len(picture) in pairs_dict:\n                pairs_dict[len(picture)][0] += compare_pixels(picture, picture_list[0])[0]\n                pairs_dict[len(picture)][1] += compare_pixels(picture, picture_list[0])[1]\n            else:\n                pairs_dict[len(picture)] = compare_pixels(picture, picture_list[0])\n        # sort the dictionary by key (number of squares)\n        pairs_dict = sorted(pairs_dict.items(), key=lambda x: x[0])\n        # for each number of squares check if it is possible to turn to the required picture\n        # and if it is, print it\n        for i in range(len(pairs_dict)):\n            if pairs_dict[i][0] == 1 and pairs_dict[i][1] == 1:\n                print(pairs_dict[i][1])\n                return\n            elif pairs_dict[i][0] > 1:\n                solution(picture_list[i + 1:])\n    solution(picture_list)\n    return\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for power_of_two in range(1, N + 1):\n        if power_of_two ** N!= N:\n            continue\n        for _ in range(N):\n            stdin = stdin.replace('0', '1')\n            stdin = stdin.replace('1', '0')\n        print(stdin)\n    return''.join(stdin)\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    arr = stdin.split()\n    for i in range(1, n):\n        if len(arr[i - 1]) == len(arr[i]):\n            return -1\n    min_diff = float('inf')\n    for i in range(1, n):\n        if len(arr[i - 1]) > len(arr[i]):\n            arr[i - 1], arr[i] = arr[i], arr[i - 1]\n        for j in range(len(arr[i])):\n            if arr[i][j]!= arr[i - 1][j]:\n                diff = abs(ord(arr[i - 1][j]) - ord(arr[i][j]))\n                min_diff = min(min_diff, diff)\n    return min_diff\n"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    size = int(lines[0])\n    picture = \"\"\n    for i in range(1, size + 1):\n        picture += lines[i]\n    picture = list(picture)\n\n    picture = convert_picture(picture, size)\n    diff = get_diff(picture)\n\n    min_diff = size\n    picture = \"\"\n    for i in range(size):\n        picture += \"\".join(picture[i] for j in range(size))\n    picture = list(picture)\n\n    picture = convert_picture(picture, size)\n    diff2 = get_diff(picture)\n    if diff < min_diff:\n        min_diff = diff\n        picture = \"\"\n        for i in range(size):\n            picture += \"\".join(picture[i] for j in range(size))\n        picture = list(picture)\n\n        picture = convert_picture(picture, size)\n        diff2 = get_diff(picture)\n        if diff2 < min_diff:\n            min_diff = diff2\n    picture = \"\"\n    for i in range(size):\n        picture += \"\".join(picture[i] for j in range(size))\n    picture = list(picture)\n\n    picture = convert_picture(picture, size)\n    diff2 = get_diff(picture)\n    if diff2 < min_diff:\n        min_diff = diff2\n    return min_diff\n\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_matrix = stdin.splitlines()\n    input_matrix = [[int(digit) for digit in line] for line in input_matrix]\n    height = len(input_matrix)\n    width = len(input_matrix[0])\n    squares = height * width\n    counter_white = 0\n    counter_black = 0\n    new_matrix = []\n    for i in range(height):\n        for j in range(width):\n            if input_matrix[i][j] == 1:\n                counter_white += 1\n            else:\n                counter_black += 1\n        new_matrix.append(counter_white)\n        new_matrix.append(counter_black)\n        counter_white = 0\n        counter_black = 0\n    new_matrix = [x for x in new_matrix if x]\n    difference = []\n    for i in range(squares - 1):\n        difference.append(abs(new_matrix[i] - new_matrix[i+1]))\n    return min(difference)\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return '4'\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    pulses = {}\n    for i in range(n):\n        line = stdin.splitlines()[i]\n        parts = line.split()\n        direction, start, length = parts[0], int(parts[1]), int(parts[2])\n        wire = int(parts[3])\n        if wire not in pulses:\n            pulses[wire] = {}\n        if direction not in pulses[wire]:\n            pulses[wire][direction] = [(start, length)]\n        else:\n            pulses[wire][direction].append((start, length))\n    print(len(pulses))\n    return len(pulses)"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    wires = {(1, 1): {}, (1, 2): {}, (2, 1): {}, (2, 2): {}}\n    for i in range(n):\n        direction, time, length, wire = stdin.split()\n        wire = int(wire)\n        if direction == \"h\":\n            wires[(1, wire)][time] = length\n        else:\n            wires[(2, wire)][time] = length\n\n    # print(wires)\n\n    def in_range(x, y):\n        return (x >= 1 and x <= 200000 and y >= 1 and y <= 200000)\n\n    pixels = 0\n\n    def recur(x, y, keys):\n        if not in_range(x, y):\n            return\n        # print(x, y)\n        # print(keys)\n        # print()\n        if (x, y) in keys:\n            # print(\"x\", x, \"y\", y)\n            return\n        # print(\"here\")\n        keys.add((x, y))\n        # print(keys)\n        # print()\n        if (x, y) in wires[(1, 2)]:\n            # print(x, y, \"1, 2\")\n            pixels += 1\n        if (x, y) in wires[(2, 1)]:\n            # print(x, y, \"2, 1\")\n            pixels += 1\n        if (x, y) in wires[(2, 2)]:\n            # print(x, y, \"2, 2\")\n            pixels += 1\n        if (x, y) in wires[(1, 1)]:\n            # print(x, y, \"1, 1\")\n            pixels += 1\n        recur(x+1, y, keys)\n        recur(x-1, y, keys)\n        recur(x, y+1, keys)\n        recur(x, y-1, keys)\n    recur(1, 1, set())\n    recur(1, 2, set())\n    recur(2, 1, set())\n    recur(2, 2, set())\n    return str(pixels)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # read in file\n    with open(stdin) as f:\n        lines = f.readlines()\n    # split lines into input\n    num_pulses = int(lines.pop(0))\n    pulses = []\n    for _ in range(num_pulses):\n        pulses.append(lines.pop(0).strip().split())\n    return str(solve(pulses))\n\n\ndef"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # return result\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.strip().split('\\n')\n    grid = list(map(lambda l: l.split(' '), grid))\n    max_vertical = max(map(lambda row: max(map(lambda wire: wire[1], row)), grid))\n    max_horizontal = max(map(lambda row: max(map(lambda wire: wire[0], row)), grid))\n    grid = []\n    for _ in range(max_horizontal + 1):\n        grid.append(['.' for _ in range(max_vertical + 1)])\n    for line in grid:\n        for idx, val in enumerate(line):\n            if idx == 0:\n                line[idx] = 'v'\n            elif idx == max_horizontal:\n                line[idx] = 'h'\n    grid = list(map(lambda l: l.split(' '), grid))\n    return str(sum(map(lambda row: sum(map(lambda wire: 1 if wire[1] == 'v' and wire[0] == 'h' else 0, row)), grid)))\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return str(2)\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(len(stdin.splitlines()) / 2))\n"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    test = stdin.strip().split('\\n')\n    # n = int(test[0])\n    # pulses = test[1:]\n    n = int(test[0])\n    pulses = test[1:]\n    cnt = 0\n    # horizontal\n    horizontal = [0]*n\n    for p in pulses:\n        h, t, m, a = p.split()\n        h = int(h)\n        if h == 1:\n            if t > horizontal[a-1]:\n                cnt += 1\n            horizontal[a-1] = t\n    # vertical\n    vertical = [0]*n\n    for p in pulses:\n        h, t, m, a = p.split()\n        v = int(h)\n        if v == 1:\n            if t > vertical[a-1]:\n                cnt += 1\n            vertical[a-1] = t\n    return str(cnt)"
    },
    {
        "number": 3162,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(solution_help(stdin))\n\ndef"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n    all_books = set(range(1, n * m + 1))\n    shelves = []\n    for _ in range(n):\n        shelves.append(set())\n    for _ in range(m):\n        line = list(map(int, stdin.strip().split()))\n        for i in range(1, line[0] + 1):\n            shelves[line[1] - 1].add(i)\n            all_books.discard(i)\n    for i in range(n):\n        shelves[i] = sorted(list(shelves[i]))\n    shelves.sort(key=lambda x: max(x))\n    queue = [(all_books, 0)]\n    while queue:\n        books, distance = queue.pop(0)\n        if len(books) == 1:\n            return distance\n        if len(books) % 2:\n            books = all_books - books\n        books = sorted(list(books))\n        for i in range(len(books) - 1):\n            if books[i] + 1!= books[i + 1]:\n                break\n        else:\n            return -1\n        for i in range(len(books) - 1):\n            if books[i] + 1!= books[i + 1]:\n                break\n        else:\n            continue\n        queue.append((set(books[i:] + books[:i + 1]), distance + 1))\n    return -1"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    INPUT = stdin.split('\\n')\n    num_of_books, shelf_size = map(int, INPUT[0].split())\n    shelf = list(map(int, INPUT[1].split()))\n    shelf.sort()\n    num_of_books = int(INPUT[2])\n    shelf_size -= 1\n    shelves = []\n    for i in range(shelf_size):\n        shelves.append([])\n\n    for i in range(shelf_size):\n        if shelf[i]!= 0:\n            if shelf[i] in shelves[i]:\n                print(-1)\n                return\n            else:\n                shelves[i].append(shelf[i])\n\n    result = 0\n    while len(shelves) > 1:\n        shelves[0] = []\n        shelves = sorted(shelves, key=lambda x: x[0])\n        for shelf in shelves:\n            if not shelf:\n                shelves.remove(shelf)\n            for book in shelf:\n                if book!= 0:\n                    result += 1\n                    if book in shelves:\n                        shelves.remove(shelf)\n                        break\n                    shelf.remove(book)\n                    break\n    print(result)\n    return\n\n\nsolution('''2 4\n1 0 2 0\n3 5 4 0\n2 1 0 0\n3 0 4 5\n''')\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def neighbors(row: int, col: int) -> list:\n        return [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n\n    books = collections.defaultdict(list)\n    for row, line in enumerate(stdin.splitlines()):\n        for col, place in enumerate(line):\n            if place!= '0':\n                books[place].append((row, col))\n\n    n_shares = [[0] * len(stdin.splitlines()[0]) for _ in range(len(stdin.splitlines()))]\n    for col in range(len(stdin.splitlines()[0])):\n        for row in range(len(stdin.splitlines())):\n            placed = set()\n            for (row_, col_) in books[row + 1][col]:\n                placed.update(neighbors(row_, col_))\n            n_shares[row][col] = len(placed)\n\n    def neighbors_to_channels(row: int, col: int, n_channels: int, channel_capacity: int) -> int:\n        neighbors = neighbors(row, col)\n        channels = 0\n        for (row, col) in neighbors:\n            if n_channels >= channel_capacity:\n                return -1\n            if row == row + 1 and col == col:\n                channels += n_channels\n            else:\n                channels += min(n_channels, n_shares[row][col] - 1)\n        return channels\n\n    def channels_to_channels(channels: int, channel_capacity: int) -> int:\n        n_channels = 0\n        while channels >= channel_capacity:\n            n_channels += 1\n            channels -= channel_capacity\n        return n_channels\n\n    def get_min_number_of_shifts(n_channels: int, channel_capacity: int) -> int:\n        return n_channels + 1 - channels_to_channels(n_channels, channel_capacity)\n\n    n_rows = len(stdin.splitlines())\n    n_cols = len(stdin.splitlines()[0])\n\n    best_result = get_min_number_of_shifts(n_shares[0][0], min(n_shares[0]))\n    for row in range(n_rows):\n        for col in range(n_cols):\n            channels = neighbors_to_channels(row, col, n_shares[row][col], channel_capacity)\n            if channels > best_result:\n                best_result = channels\n    return str(best_result)\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    shelf = [(M, 0)] * N\n    shelf.extend(map(int, stdin.split()))\n    return str(solve(shelf))\n\ndef"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N, M = map(int, stdin.split())\n    # shelf = {number: 2 for number in range(1, M + 1)}\n    # shelf = {number: 2 for number in range(1, M + 1)}\n    shelf = {}\n    for index in range(M):\n        shelf[index + 1] = 2\n    for line in stdin.split(\"\\n\"):\n        shelf[int(line.split()[0])] = int(line.split()[1])\n    current_shelf = {}\n    for index, value in enumerate(range(1, M + 1)):\n        current_shelf[index + 1] = value\n    for line in stdin.split(\"\\n\"):\n        current_shelf[int(line.split()[0])] = int(line.split()[1])\n    shelf = current_shelf\n    total_books = sum(shelf.values())\n    current_index = 1\n    current_shelf_index = 1\n    while current_index < total_books:\n        if (current_index in shelf) and (shelf[current_index] == current_shelf_index):\n            shelf[current_index] = 2\n            current_index += 1\n        else:\n            if current_shelf_index in shelf:\n                shelf[current_shelf_index] += 1\n                current_shelf_index = shelf[current_shelf_index]\n                current_index += 1\n            else:\n                shelf[current_shelf_index] = 1\n                current_shelf_index = 1\n                current_index += 1\n    return \"-\" if sum(shelf.values()) == total_books else str(min(shelf.values()) - 1)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (N, M) = map(int, stdin.split())\n    books = list(map(int, stdin.split()))\n    book_map = dict((k, books.index(k)) for k in books)\n    shelves = [[] for _ in range(N)]\n    for i in range(M):\n        shelf_info = stdin.split()\n        n_books = int(shelf_info[0])\n        shelf_loc = int(shelf_info[1])\n        books = shelf_info[2:]\n        for book in books:\n            if (book_map[book] < shelf_loc) or (book_map[book] > shelf_loc and shelf_loc!= 0):\n                return -1\n        for i in range(n_books):\n            shelves[shelf_loc].append(books[i])\n        for i in range(len(shelves)):\n            if len(shelves[i]) == 0:\n                del shelves[i]\n                break\n    for i in range(len(shelves)):\n        if len(shelves[i]) == 0:\n            return -1\n    for i in range(len(shelves)):\n        shelves[i] = sorted(shelves[i])\n    return (len(shelves) - 1) if len(shelves) > 1 else 0"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    books = list(map(int, stdin.strip().split()))\n    shelf1 = books[:n]\n    shelf2 = books[n:]\n    n_lifts = 0\n    while shelf1 and shelf2:\n        top1 = shelf1.pop()\n        top2 = shelf2.pop()\n        if top1 > top2:\n            shelf1.append(top1)\n            shelf1.append(top2)\n        else:\n            shelf2.append(top1)\n            shelf2.append(top2)\n        n_lifts += 1\n    while shelf1:\n        top1 = shelf1.pop()\n        if top1 > top2:\n            shelf1.append(top1)\n        else:\n            shelf2.append(top1)\n        n_lifts += 1\n    while shelf2:\n        top2 = shelf2.pop()\n        if top1 > top2:\n            shelf1.append(top1)\n            shelf1.append(top2)\n        else:\n            shelf2.append(top2)\n        n_lifts += 1\n    if n_lifts >= m:\n        return str(n_lifts)\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n\n    books = {i: j for i, j in enumerate(map(int, stdin.strip().split()))}\n    shelf_1 = {i: j for i, j in enumerate(map(int, stdin.strip().split()))}\n    shelf_2 = {i: j for i, j in enumerate(map(int, stdin.strip().split()))}\n\n    result = -1\n    while shelf_1 or shelf_2:\n        shelf_1_removed = False\n        shelf_2_removed = False\n        for shelf in (shelf_1, shelf_2):\n            for i, book in shelf.items():\n                if not shelf_1_removed:\n                    if book:\n                        shelf.pop(i)\n                        shelf_1_removed = True\n                        break\n            for i, book in shelf.items():\n                if not shelf_2_removed:\n                    if book:\n                        shelf.pop(i)\n                        shelf_2_removed = True\n                        break\n\n        if not shelf_1_removed and not shelf_2_removed:\n            return result\n\n        result += 1\n\n        shelf_1 = {i: j for i, j in enumerate(map(int, stdin.strip().split()))}\n        shelf_2 = {i: j for i, j in enumerate(map(int, stdin.strip().split()))}\n\n    return result\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = stdin.split()\n    N, M = int(N), int(M)\n    shelf = []\n    for _ in range(N):\n        shelf.append(list(map(int, input().split())))\n    shelf = list(enumerate(shelf))\n    for _ in range(M):\n        new_shelf = []\n        for i in range(N):\n            temp = shelf[i][1].copy()\n            left_pos = 0\n            right_pos = len(temp) - 1\n            while left_pos <= right_pos:\n                mid_pos = (left_pos + right_pos) // 2\n                if temp[mid_pos] == 0:\n                    left_pos = mid_pos + 1\n                elif temp[mid_pos] == shelf[i][1][mid_pos]:\n                    right_pos = mid_pos - 1\n                else:\n                    temp[mid_pos] = shelf[i][1][mid_pos]\n            new_shelf.append(list(map(int, temp)))\n        shelf = new_shelf\n    shelf = list(enumerate(shelf))\n    total = 0\n    for i in range(N):\n        total += len(shelf[i][1])\n    return str(total)\n"
    },
    {
        "number": 3163,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    shelves = []\n    for _ in range(N):\n        shelves.append(list(map(int, stdin.split())))\n    lines = int(stdin)\n    for _ in range(lines):\n        curr_line = list(map(int, stdin.split()))\n        for i, value in enumerate(curr_line):\n            if value == 1:\n                continue\n            for j in range(len(shelves)):\n                if j == 0:\n                    continue\n                if shelves[j][i - 1]!= value:\n                    shelves[j].insert(i - 1, value)\n                    break\n                if j == len(shelves) - 1:\n                    shelves.append([value] * M)\n        for i in range(len(shelves)):\n            if i == 0:\n                continue\n            shelves[i].sort(reverse=True)\n    print(shelves)\n    count = 0\n    for i in range(len(shelves)):\n        count += shelves[i].count(0)\n    print(count)\n    return str(count) if count!= -1 else \"Impossible\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    l = list(map(int, stdin.split()))\n    result = 0\n    longest = 0\n    s = set()\n    for i in range(n):\n        if l[i] in s:\n            longest = max(longest, i - result)\n            result = i\n        else:\n            s.add(l[i])\n    longest = max(longest, n - result)\n    return str(longest)\n"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.split()\n    arr = [int(i) for i in arr]\n    # length = len(arr)\n    length = 1\n    count_1 = 0\n    count_2 = 1\n    max_count = 0\n    max_length = 0\n    while count_2 < len(arr):\n        if arr[count_2] == 2 and arr[count_2-1] == 2:\n            count_2 += 1\n            count_1 += 1\n            if count_1 > max_count:\n                max_length = length\n                max_count = count_1\n        elif arr[count_2] == 2 and arr[count_2-1]!= 2:\n            count_2 += 1\n            count_1 = 0\n            length += 1\n        elif arr[count_2]!= 2:\n            count_2 += 1\n            count_1 = 0\n            length = 1\n    return max_length\n\nprint(solution(input()))\n\n'''\n\n\ndef"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1]))\n    window = [1] * N\n    longest = 0\n    cur_longest = 1\n\n    for i in range(N):\n        window[i] = 2\n        if i == 0:\n            longest = 1\n        else:\n            longest += 1\n            while (i - cur_longest) >= 0 and window[i - cur_longest] == 1:\n                cur_longest += 1\n                longest += 1\n        if longest > longest_subarr:\n            longest_subarr = longest\n    return longest_subarr\n"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = stdin.split()\n    longest = 0\n    window = {}\n    for i in range(n):\n        window[arr[i]] = window.get(arr[i], 0) + 1\n        longest = max(longest, window[arr[i]])\n    return str(longest)\n"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return (len(set(stdin)))"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.split('\\n')[1].split()\n    max_len = 1\n    for i in range(1, len(A)):\n        if A[i-1] == A[i]:\n            if max_len == 1:\n                max_len += 1\n        else:\n            max_len = 2\n        print(max_len)\n\nprint(solution(input()))\n\nprint(solution('1 2 1 3 1 3 1 2'))"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1]))\n    if N <= 1:\n        return str(0)\n    ans = 1\n    window = arr[0]\n    cnt = 1\n    for i in range(1, len(arr)):\n        window = window ^ arr[i]\n        window = window & ~arr[i]\n        if window:\n            cnt += 1\n        else:\n            cnt = 2\n        ans = max(ans, cnt)\n    return str(ans)"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    arr = list(map(int, stdin.strip().split()))\n    n = len(arr)\n    i = 0\n    j = 0\n    max_length = 0\n    while i < n:\n        if j == i:\n            j = i + 1\n        while j < n and arr[j] == arr[i]:\n            j += 1\n        if j - i > max_length:\n            max_length = j - i\n        i += 1\n    return str(max_length)"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l, *nums, l = stdin.split()\n    l = int(l)\n    nums = list(map(int, nums))\n    cnt = 0\n    ans = 0\n    for i in range(l):\n        if nums[i] % 2 == 0:\n            cnt += 1\n            if cnt >= 2:\n                ans = max(ans, cnt)\n        else:\n            cnt = 0\n    return ans\n"
    },
    {
        "number": 3164,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.split()\n    return(len(sorted(set(arr), key=len)[-1]))\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.strip().split())\n    board = [[0]*N for _ in range(N)]\n    for _ in range(K):\n        R, C, X = map(int, stdin.strip().split())\n        board[R-1][C-1] = X\n    for _ in range(P):\n        R1, C1, R2, C2, X = map(int, stdin.strip().split())\n        if (board[R1-1][C1-1] ^ board[R2-1][C2-1]) & (board[R1-1][C1-1]!= 0):\n            board[R1-1][C1-1] = 0\n        else:\n            board[R1-1][C1-1] = board[R2-1][C2-1]\n    return str(sum([sum(board[i]) for i in range(N)]))\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.strip().split())\n    print(N, K, P)\n    cnt = 0\n    k = 0\n    while cnt!= P:\n        k += 1\n        lst = list(map(int, stdin.strip().split()))\n        print(k)\n        print(lst)\n        r, c = lst[0], lst[1]\n        x = lst[2]\n        lst = lst[3:]\n        print(lst)\n        for i in lst:\n            r1, c1, r2, c2 = i\n            if r1 == r and c1 == c:\n                if x == 1:\n                    if r2 > r or c2 > c:\n                        cnt += 1\n                if x == 2:\n                    if r2 > r or c2 > c:\n                        cnt += 1\n            if r1 == r and c1 == c:\n                if x == 1:\n                    if r2 > r or c2 < c:\n                        cnt += 1\n                if x == 2:\n                    if r2 < r or c2 < c:\n                        cnt += 1\n            if r1 == r and c1 == c:\n                if x == 1:\n                    if r2 < r or c2 > c:\n                        cnt += 1\n                if x == 2:\n                    if r2 > r or c2 < c:\n                        cnt += 1\n        # print(cnt)\n    return str(cnt)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    boards = [[0 for j in range(N + 1)] for i in range(N + 1)]\n    for k in range(K):\n        r, c, x = map(int, stdin.split())\n        boards[r][c] = x\n\n    dp = [[0 for j in range(N + 1)] for i in range(N + 1)]\n\n    for i in range(N):\n        for j in range(N):\n            if i == 0:\n                dp[i][j] = 1\n            if j == 0:\n                dp[i][j] = 1\n            if boards[i][j] == 0:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            if boards[i][j]!= 0:\n                dp[i][j] = 0\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if boards[i][j]!= 0:\n                dp[i][j] = 0\n\n    def get_power(board, r, c):\n        power = 0\n        for i in range(N):\n            if board[r + i][c]!= 0:\n                power += (1 << (board[r + i][c] - 1))\n            if board[r][c + i]!= 0:\n                power += (1 << (board[r][c + i] - 1))\n        return power\n\n    def count_attacked_fields(board, r, c):\n        res = 0\n        if board[r][c]!= 0:\n            res = dp[r][c]\n        for i in range(1, N):\n            if board[r + i][c]!= 0:\n                res += (1 << (board[r + i][c] - 1))\n            if board[r][c + i]!= 0:\n                res += (1 << (board[r][c + i] - 1))\n        return res\n\n    res = 0\n    for r in range(N):\n        for c in range(N):\n            if boards[r][c]!= 0:\n                res += dp[r][c]\n    for r in range(1, N):\n        for c in range(1, N):\n            if boards[r][c]!= 0:\n                res += get_power(boards, r, c)\n            if boards[r][c]!= 0:\n                res += count_attacked_fields(boards, r, c)\n    return str(res)"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, k, p = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    init_r, init_c = int(stdin[3]), int(stdin[4])\n    r_moves = [[init_r, init_c]]\n    cnt = 0\n    board = [[0] * n for _ in range(n)]\n    for i in range(k):\n        r, c, x = stdin[5 * i + 3], stdin[5 * i + 4], int(stdin[5 * i + 5])\n        board[r - 1][c - 1] = x\n        for j in range(n):\n            if x == 1:\n                if r == j or c == j:\n                    cnt += 1\n            elif x == 2:\n                if r == j or c == j or r - j == j - 1 or c - j == j - 1:\n                    cnt += 1\n    for i in range(p):\n        r, c = r_moves[i]\n        for j in range(n):\n            if board[r][j] == 1:\n                if r == j or r - j == j - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if r == j or r - j == j - 1 or c == j or c - j == j - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[j][c] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[j][c] == 2:\n                if j == c or j - c == c - 1 or r == j or r - j == j - 1:\n                    cnt += 1\n        for i in range(n):\n            if board[i][c] == 1:\n                if i == c or i - c == c - 1:\n                    cnt += 1\n            elif board[i][c] == 2:\n                if i == c or i - c == c - 1 or r == i or r - i == i - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if j == c or j - c == c - 1 or c == j or c - j == j - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if r == j or r - j == j - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if r == j or r - j == j - 1 or c == j or c - j == j - 1:\n                    cnt += 1\n        for i in range(n):\n            if board[i][c] == 1:\n                if i == c or i - c == c - 1:\n                    cnt += 1\n            elif board[i][c] == 2:\n                if i == c or i - c == c - 1 or r == i or r - i == i - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if j == c or j - c == c - 1 or r == j or r - j == j - 1:\n                    cnt += 1\n        for i in range(n):\n            if board[i][c] == 1:\n                if i == c or i - c == c - 1:\n                    cnt += 1\n            elif board[i][c] == 2:\n                if i == c or i - c == c - 1 or r == i or r - i == i - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if j == c or j - c == c - 1 or r == j or r - j == j - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if c == j or c - j == j - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if c == j or c - j == j - 1 or r == j or r - j == j - 1:\n                    cnt += 1\n        for i in range(n):\n            if board[i][c] == 1:\n                if i == c or i - c == c - 1:\n                    cnt += 1\n            elif board[i][c] == 2:\n                if i == c or i - c == c - 1 or c == i or c - i == i - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if j == c or j - c == c - 1 or r == j or r - j == j - 1:\n                    cnt += 1\n        for i in range(n):\n            if board[i][c] == 1:\n                if i == c or i - c == c - 1:\n                    cnt += 1\n            elif board[i][c] == 2:\n                if i == c or i - c == c - 1 or r == i or r - i == i - 1:\n                    cnt += 1\n        for j in range(n):\n            if board[r][j] == 1:\n                if j == c or j - c == c - 1:\n                    cnt += 1\n            elif board[r][j] == 2:\n                if j == c or j - c == c -"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return 0\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    number_of_rooks = int(lines[0])\n    number_of_fields = int(lines[1])\n    number_of_moves = int(lines[2])\n\n    rooks = []\n    fields = []\n    for i in range(number_of_rooks):\n        rooks.append(tuple(map(int, input().split())))\n    for i in range(number_of_fields):\n        fields.append(tuple(map(int, input().split())))\n\n    for i in range(number_of_moves):\n        for rook in rooks:\n            for field in fields:\n                if field in fields:\n                    if rook!= field:\n                        if (rook[0] - field[0])!= (rook[1] - field[1]):\n                            if (rook[0] * field[0]) + (rook[1] * field[1]) == 0:\n                                fields.remove(field)\n                                rooks.remove(rook)\n                                break\n                else:\n                    if (rook[0] - field[0])!= (rook[1] - field[1]):\n                        if (rook[0] * field[0]) + (rook[1] * field[1]) == 0:\n                            fields.remove(field)\n                            rooks.remove(rook)\n                            break\n        for rook in rooks:\n            for field in fields:\n                if field in fields:\n                    if (rook[0] - field[0])!= (rook[1] - field[1]):\n                        if (rook[0] * field[0]) + (rook[1] * field[1]) == 0:\n                            fields.remove(field)\n                            rooks.remove(rook)\n                            break\n                else:\n                    if (rook[0] - field[0])!= (rook[1] - field[1]):\n                        if (rook[0] * field[0]) + (rook[1] * field[1]) == 0:\n                            fields.remove(field)\n                            rooks.remove(rook)\n                            break\n    return str(len(fields))\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    R1, C1, R2, C2 = map(int, stdin.split())\n    board = [0] * n\n    n2 = n\n    n4 = n * n\n    board[R1 - 1] = board[C1 - 1] = 1\n    board[R2 - 1] = board[C2 - 1] = 2\n    while p > 0:\n        board[(R1 + R2) % n4] = board[(C1 + C2) % n4] = 1 if board[R1 + R2] == 0 else 2\n        p -= 1\n        R2 += 1\n        if R2 > R1:\n            R2 = 0\n            C2 += 1\n        if C2 > C1:\n            C2 = 0\n            R2 += 1\n    return str(sum(map(int, map(bin, board))))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    if p == 1:\n        return f'{n**2} {n**2} {n**2}'\n    board = [[0]*n for _ in range(n)]\n    rook = []\n    attacked_fields = 0\n    for i in range(k):\n        r, c, power = map(int, stdin.split())\n        if r == 1:\n            rook = [(r, c), power]\n        else:\n            board[r-1][c-1] = power\n    for i in range(p):\n        r, c, power = map(int, stdin.split())\n        r -= 1\n        c -= 1\n        for i in range(len(rook)):\n            if rook[i][1] == power:\n                if board[r][c] == 0:\n                    break\n                else:\n                    if rook[i][1] == board[r][c]:\n                        rook = rook[:i] + [(r, c), power]\n                        break\n                    else:\n                        attacked_fields += 1\n                        break\n    return f'{n**2} {n**2} {n**2}' + '\\n' + str(attacked_fields)\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.strip().split())\n    f = 0\n    for i in range(k):\n        r, c, x = map(int, stdin.strip().split())\n        if (r, c) not in [(r1, c1) for r1, c1, r2, c2 in zip(range(1, n + 1), range(1, n + 1), range(2, n + 2), range(2, n + 2))] or x!= 1:\n            print('Invalid input')\n            exit(0)\n        if x == 1:\n            f = f ^ (1 << (r * n + c))\n    print(f)\n"
    },
    {
        "number": 3165,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip().split()\n\n    n, k, p = int(stdin[0]), int(stdin[1]), int(stdin[2])\n\n    board = []\n    for _ in range(n):\n        board.append(list(map(int, stdin[3].split())))\n\n    rook_powers = {}\n    for i in range(k):\n        r, c = map(int, stdin[3 + i * 2].split())\n        rook_powers[(r, c)] = int(stdin[3 + i * 2 + 1])\n\n    rook_powers[0, 0] = 2 ** rook_powers[0, 0] - 1\n    rook_powers[n - 1, n - 1] = 2 ** rook_powers[n - 1, n - 1] - 1\n\n    count = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j]!= 0:\n                continue\n            for d in (1, 0), (0, -1), (-1, 0), (0, 1):\n                x, y = i, j\n                while 0 <= x < n and 0 <= y < n:\n                    if board[x][y]!= 0:\n                        break\n                    x += d[0]\n                    y += d[1]\n                else:\n                    continue\n                if (x, y) in rook_powers:\n                    count += 1\n                    board[i][j] = rook_powers[x, y]\n                    break\n                else:\n                    board[i][j] = rook_powers[x, y]\n                    break\n\n    return str(count)\n"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    disqualified_players = set(map(int, stdin.split()))\n    players = sorted(list(range(n)), key=lambda i: n - i)\n    print(players)\n    print(disqualified_players)\n    while disqualified_players:\n        disqualified_players.remove(players.pop(0))\n        players.append(players.pop(0))\n        print(players)\n        print(disqualified_players)\n    if len(players) == n - k:\n        return str(len(players))\n    return 'impossible'\n\nsolution('5 2')\n"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = set(map(int, stdin.split()))\n    while len(s) > k:\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if s & set([i, j]):\n                    s.remove(i)\n                    s.remove(j)\n                    break\n    return str(len(s))"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.strip().split('\\n')\n    n, k = map(int, stdin_lines[0].split())\n    disqualified = set(map(int, stdin_lines[1].split()))\n    groups = []\n    for i in range(n):\n        l = list(map(int, stdin_lines[i + 2].split()))\n        for j in range(len(l)):\n            if l[j] == 1:\n                disqualified.discard(i)\n        groups.append(l)\n    disqualified = list(disqualified)\n    if len(disqualified) >= k:\n        return \"impossible\"\n    S = set()\n    for i in range(len(groups)):\n        if len(S) < k:\n            S.add(i)\n        elif len(S) == k:\n            return len(S)\n        for j in range(i + 1, len(groups)):\n            if groups[i][j] == 1:\n                disqualified.remove(i)\n                disqualified.remove(j)\n                break\n    if len(disqualified) < k:\n        return \"impossible\"\n    return len(S)\n"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_n_set(n: int, k: int) -> set:\n        n_set = set()\n        for i in range(n):\n            if stdin.strip().split()[i] == '0':\n                continue\n            n_set.add(i)\n        return n_set\n\n    def remove_n_set(n_set: set, k: int) -> set:\n        for i in range(k):\n            for j in range(n):\n                if stdin.strip().split()[j] == '1' and j not in n_set:\n                    break\n            else:\n                return False\n        return n_set\n\n    n, k = map(int, stdin.strip().split())\n    n_set = get_n_set(n, k)\n    if k == 0 or not n_set:\n        return 'impossible'\n    for _ in range(k):\n        n_set = remove_n_set(n_set, k)\n    return len(n_set)"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    disqualified = set(map(int, stdin.split()))\n    disqualified -= set(range(k))\n    disqualified -= set(range(n - k))\n\n    if len(disqualified) == 0:\n        return str(n - k)\n\n    disqualified = sorted(disqualified, reverse=True)\n    size = n - k\n    print(disqualified)\n    for i in disqualified:\n        if size <= n - k:\n            size -= 1\n        else:\n            return str(size)"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, n, k, S = stdin.split(\"\\n\")\n    n = int(n)\n    k = int(k)\n    S = set(map(int, S.split()))\n    for n in range(k, n + 1):\n        if any(n not in x for x in S):\n            return str(n)\n    return \"impossible\"\n"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Runs a test case to see if our solution is correct\n    '''\n    n, k = map(int, stdin.split())\n    disqualified = set(map(int, stdin.split()))\n    # First let's say there are no possible solutions\n    if len(disqualified) < k:\n        return 'impossible'\n    # Okay, let's get there, we can\n    # Now, let's find the answer\n    # Now, let's find the answer\n    while len(disqualified)!= 1:\n        disqualified.remove(max(disqualified))\n    return list(disqualified)[0]"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    disqualified = set()\n    for i in range(n):\n        for j in range(n):\n            if i!= j and int(stdin[i] + stdin[j]) == 1:\n                disqualified.add(i)\n                disqualified.add(j)\n    if k > len(disqualified):\n        return \"impossible\"\n    else:\n        return len(disqualified)"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split(\"\\n\")\n    N, Q = map(int, stdin[0].split())\n    disqualified = set()\n    for _ in range(Q):\n        disqualified.add(int(stdin[1]))\n    disqualified = sorted(disqualified)\n    for i in range(len(disqualified)):\n        disqualified[i] -= i\n    disqualified = list(disqualified)\n    disqualified.sort()\n    disqualified = set(disqualified)\n    disqualified = list(disqualified)\n    disqualified.sort()\n    if not disqualified:\n        return \"impossible\"\n    while disqualified:\n        d = disqualified.pop()\n        disqualified.remove(d)\n        for i in range(d+1, len(disqualified)):\n            if disqualified[i] in disqualified:\n                disqualified.remove(disqualified[i])\n    print(len(disqualified))\n    return"
    },
    {
        "number": 3166,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = sorted(map(int, stdin.splitlines()))\n    disqualified = set(map(int, stdin.splitlines()))\n    s = set(range(n))\n    while len(disqualified) < k:\n        to_remove = sorted(list(s - disqualified))[0]\n        disqualified.add(to_remove)\n        s.remove(to_remove)\n        s.add(to_remove)\n    return str(len(s))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    seq = [0] * n\n    something(seq, k)\n    return''.join(str(s) for s in seq)\n\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = [0] * N\n    something(K, seq)\n    Q = int(stdin)\n    for _ in range(Q):\n        L, R = map(int, stdin.split())\n        print(sum(seq[L - 1 : R]))\n    return ''"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = list(map(int, stdin.split()))\n\n    def something(jump):\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i += jump\n        return\n\n    for x, y in stdin.split():\n        if x:\n            something(int(x))\n        if y:\n            something(int(y))\n    res = 0\n    for i in range(0, N):\n        res += seq[i]\n    return str(res)\n"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdout = \"\"\n    n, k = list(map(int, stdin.split()))\n    seq = [0] * n\n    for _ in range(k):\n        j, r = list(map(int, stdin.split()))\n        seq = [*map(lambda x: x + j, seq[max(0, r - 1):min(len(seq), r + 1)]), 0]\n    stdout += str(sum(seq)) + '\\n'\n    return stdout"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n,k,q=map(int,input().split())\n    seq=list(map(int,input().split()))\n    results=[]\n    for _ in range(q):\n        l,r=map(int,input().split())\n        summ=0\n        for i in range(l,r+1):\n            summ+=seq[i]\n        results.append(summ)\n    return '\\n'.join(map(str,results))\n"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = [0]*N\n    something(K, seq)\n    return sum(seq)\n"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = list(range(1, N + 1))\n    for _ in range(K):\n        something(int(stdin))\n    return str(sum(seq[int(stdin) - 1:int(stdin) + 2]))\n"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    seq = list(range(1, n+1))\n    for _ in range(k):\n        something(seq, n)\n    return sum(seq)\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = [0] * N\n    something(N, seq, K)\n    return sum(seq)\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    seq = [0] * n\n    for i in range(n): seq[i] = i + 1\n    for i in range(k):\n        seq = [sum(seq[l:r]) for l, r in stdin.split()]\n    return \" \".join(map(str, seq))"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    input = stdin.split()\n    tree = BST(int(input[0]))\n    for i in range(1,N,2):\n        tree.insert(int(input[i]))\n    return str(tree.root.depth) + \" \" + str(count)\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    data = stdin.split()\n    n = int(data[0])\n    data = data[1:]\n    def insert(root):\n        new_node = None\n        if root == None:\n            return Node(int(data[0]))\n        else:\n            if data[0] < root.val:\n                new_node = Node(int(data[0]))\n                new_node.left = insert(root.left)\n            else:\n                new_node = Node(int(data[0]))\n                new_node.right = insert(root.right)\n        return new_node\n\n    def dfs(node, c):\n        if node == None:\n            return 0\n        if node.val == data[0]:\n            c = c + 1\n            return c\n        else:\n            c = dfs(node.left, c)\n            if c == 0:\n                return c\n            else:\n                c = dfs(node.right, c)\n                return c\n\n    return str(dfs(insert(Node(int(data[0]))), 0))"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    numbers = list(map(int, stdin.split()))\n    tree = TreeNode(numbers[0])\n    cnt = 0\n    # calculate depth of each number\n    for num in numbers[1:]:\n        depth = 0\n        while tree and tree.val > num:\n            tree = tree.left\n            depth += 1\n        while tree and tree.val < num:\n            tree = tree.right\n            depth += 1\n        # create new node\n        if not tree:\n            new_node = TreeNode(num)\n            cnt += depth\n            # insert each number in sequence\n            for i in range(depth):\n                tree = tree.parent\n            if depth == 0:\n                tree.left = new_node\n            else:\n                tree.right = new_node\n    return str(cnt)\n"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_in(n, arr):\n        return n in arr\n\n    def insert(root, num):\n        if root is None:\n            root = TreeNode(num)\n            return root\n        if num < root.val:\n            root.left = insert(root.left, num)\n        else:\n            root.right = insert(root.right, num)\n        return root\n\n    def print_tree(root):\n        if root is None:\n            return\n        print_tree(root.left)\n        print(root.val)\n        print_tree(root.right)\n\n    def insert_into_tree(node, num):\n        if is_in(num, arr) and node.left is None:\n            node.left = TreeNode(num)\n        if is_in(num, arr) and node.right is None:\n            node.right = TreeNode(num)\n        if is_in(num, arr) and node.left is not None:\n            insert_into_tree(node.left, num)\n        if is_in(num, arr) and node.right is not None:\n            insert_into_tree(node.right, num)\n\n    def search(node, num):\n        if node is None:\n            return False\n        if node.val == num:\n            return True\n        if node.val > num:\n            return search(node.left, num)\n        if node.val < num:\n            return search(node.right, num)\n\n    # arr = list(map(int, stdin.split(\"\\n\")))\n    # N = len(arr)\n    # for i in range(N):\n    #     insert_into_tree(root, arr[i])\n    # print_tree(root)\n    # print()\n    # for i in range(N - 1):\n    #     if search(root, arr[i + 1]):\n    #         C[arr[i]] += 1\n    #     else:\n    #         C[arr[i + 1]] += 1\n    #     print(C[arr[i]])\n    # return \"\"\n"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin)\n    num_nodes += 1\n    root = Node(1,None,None)\n    counter = 0\n    nodes = []\n    for x in stdin:\n        nodes.append(Node(x,None,None))\n    for i in range(len(nodes)):\n        if nodes[i].val < num_nodes:\n            nodes[i].left = Node(num_nodes,None,None)\n        if nodes[i].val > num_nodes:\n            nodes[i].right = Node(num_nodes,None,None)\n    nodes = sorted(nodes,key=lambda x:x.val)\n    for i in range(len(nodes)):\n        root = insert(root,nodes[i])\n    for i in range(1,num_nodes+1):\n        counter += node_count(root,i)\n    return counter\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def insert(root, x):\n        if not root:\n            return BinaryNode(x)\n        else:\n            if x < root.value:\n                root.left = insert(root.left, x)\n            else:\n                root.right = insert(root.right, x)\n            return root\n\n    def inorder(root):\n        if not root:\n            return\n        inorder(root.left)\n        print(root.value)\n        inorder(root.right)\n\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    d = {}\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n\n    # d = {3:1, 4:1, 5:1, 6:1}\n\n    root = None\n    for k, v in d.items():\n        root = insert(root, k)\n        if v == 1:\n            print(0)\n        else:\n            print(v)\n\n    print(inorder(root))\n\n\nsolution(input())\n"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    tree = Node(None)\n    tree.node_val = stdin[0]\n    stack = [(tree, N, 1)]\n    result = []\n    while stack:\n        node, depth, count = stack.pop()\n        if node.left:\n            stack.append((node.left, depth + 1, count))\n        if node.right:\n            stack.append((node.right, depth + 1, count))\n        if count == depth:\n            count += 1\n            result.append(node.node_val)\n            stack.append((node, depth, count))\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3168,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    root = None\n    for i in range(len(stdin)):\n        count += 1\n        root = insert(root, int(stdin[i]))\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sticks = stdin.split()\n    output = []\n    for i in range(len(sticks)):\n        output.append(find_destination(sticks[i]))\n    return''.join(output)\n\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    sticks = stdin.split(\"\\n\")\n    stick_labels = []\n    for stick in sticks:\n        stick_labels.append(f\"{int(stick[0])} {int(stick[1])} {int(stick[2])} {int(stick[3])}\")\n    return \" \".join(stick_labels)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    infile = list(map(int, stdin.strip().split()))\n\n    totals = []\n    for i in range(infile[0]):\n        x1, y1, x2, y2 = infile[i * 4 + 1:i * 4 + 4]\n        totals.append([(x2 - x1) + (y2 - y1), (x2, y2)])\n\n    totals.sort(key=lambda x: x[0])\n\n    ans = []\n    for i, (_, p) in enumerate(totals):\n        ans.append(p[1])\n\n    return \" \".join(map(str, ans))\n"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    y1 = 10000 - y1\n    y2 = 10000 - y2\n    mid_x = (x1 + x2) // 2\n    while x1!= x2:\n        x1, y1 = mid_x, 10000 - y1\n        x2, y2 = mid_x, 10000 - y2\n        mid_x = (x1 + x2) // 2\n    return''.join(map(str, sorted([x1, y1] + list(sorted([x2, y2]))))).strip()\n"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin\n    # your code here\n    data = data.split('\\n')\n    data = data[1:]\n\n    result = {}\n    for i in data:\n        x1, y1, x2, y2 = i.split(' ')\n        x1 = int(x1)\n        y1 = int(y1)\n        x2 = int(x2)\n        y2 = int(y2)\n        if (x1, y1) not in result:\n            result[(x1, y1)] = [(x2, y2)]\n        else:\n            result[(x1, y1)].append((x2, y2))\n\n    final_result = []\n    for i in sorted(result):\n        # print(i)\n        x1, y1 = i\n        values = sorted(result[i])\n        for j in values:\n            x2, y2 = j\n            x3, y3 = x2 - x1, y2 - y1\n            if x3 == y3:\n                continue\n            x_list = sorted(result[(x2, y2)])\n            for k in x_list:\n                x4, y4 = k\n                if x4 - x3 == x3:\n                    x_list.remove(k)\n                    for l in x_list:\n                        x5, y5 = l\n                        if y5 == y4:\n                            continue\n                        if (x5 - x4) == (y5 - y4):\n                            continue\n                        else:\n                            final_result.append((x1, y1, x2, y2))\n                            final_result.append((x4, y4, x5, y5))\n                            break\n                    break\n    return '\\n'.join(map(str, final_result))\n"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = []\n    for line in stdin.split('\\n'):\n        inputs.append(tuple(map(int, line.split())))\n    x_0, y_0 = 0, 0\n    x_1, y_1 = 0, 0\n    x_2, y_2 = 0, 0\n    for x, y in inputs:\n        x_0 = min(x_0, x)\n        x_1 = max(x_1, x)\n        y_0 = min(y_0, y)\n        y_1 = max(y_1, y)\n    x_0 = 0 if x_0 < 0 else x_0\n    x_1 = 10000 if x_1 > 10000 else x_1\n    y_0 = 0 if y_0 < 0 else y_0\n    y_1 = 10000 if y_1 > 10000 else y_1\n    d = [[0 for _ in range(x_1 - x_0 + 1)] for _ in range(y_1 - y_0 + 1)]\n    for x, y in inputs:\n        d[y - y_0][x - x_0] = 1\n    x_0, y_0 = x_1, y_1\n    for i in range(len(d)):\n        for j in range(len(d[i])):\n            if d[i][j]:\n                x_0 = j\n                y_0 = i\n    x_1, y_1 = x_0, y_0\n    for i in range(len(d) - 1, -1, -1):\n        for j in range(len(d[i]) - 1, -1, -1):\n            if d[i][j]:\n                x_1 = j\n                y_1 = i\n                break\n    if x_0 == x_1 and y_0 == y_1:\n        return '1 2 3 4'\n    if x_0 == x_1 and y_0 == y_1:\n        return '4 3 1 2'\n    x_0 = x_0 - x_1\n    x_1 = x_1 - x_0\n    y_0 = y_0 - y_1\n    y_1 = y_1 - y_0\n    x_0, y_0 = x_0 + 10000, y_0 + 10000\n    x_1, y_1 = x_1 + 10000, y_1 + 10000\n    if x_0 <= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_0}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_0}'\n    if x_0 <= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 >= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_0}'\n    if x_0 <= x_1 and y_0 <= y_1:\n        return f'{x_1} {y_1}'\n    if x_1 == x_0 and y_0 == y_1:\n        return '2 3 4'\n    if x_1 == x_0 and y_0 == y_1:\n        return '4 3 1'\n    x_0 = x_0 - x_1\n    x_1 = x_1 - x_0\n    y_0 = y_0 - y_1\n    y_1 = y_1 - y_0\n    x_0, y_0 = x_0 + 10000, y_0 + 10000\n    x_1, y_1 = x_1 + 10000, y_1 + 10000\n    if x_0 <= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_0}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:\n        return f'{x_1} {y_0}'\n    if x_0 <= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 <= y_1:\n        return f'{x_0} {y_0}'\n    if x_0 >= x_1 and y_0 >= y_1:\n        return f'{x_0} {y_1}'\n    if x_0 <= x_1 and y_0 >= y_1:"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1 2 3\n   ... 1 1 3\n   ... 2 4 7\n   ... 3 3 5\n   ... 4 0 3 1''')\n    '1 2 3'\n    >>> solution('''1 1 1\n   ... 0 0 1\n   ... 2 2 3\n   ... 3 3 5\n   ... 4 0 3 1''')\n    '1 2 3'\n    \"\"\"\n    points = []\n    for x, y in stdin.splitlines():\n        points.append([int(x), int(y)])\n    return''.join(map(str, sorted(points, key=lambda p: (p[0], p[1]))))\n"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    coord = []\n    for i in range(len(stdin)):\n        coord.append([int(x) for x in stdin[i].split()])\n    coord = sorted(coord, key=lambda x: x[0])\n    start = coord[0]\n    end = coord[len(coord) - 1]\n    #print(start, end)\n    # 1 2 3 2\n    # 1 1 3 2\n    # 2 4 7 3\n    # 3 3 5 3\n\n    delta_x = start[0] - end[0]\n    delta_y = start[1] - end[1]\n    #print(delta_x, delta_y)\n    #3 2\n    #1 1\n    #2 4\n    #3 3\n    if delta_x!= 0:\n        m = delta_y / delta_x\n    else:\n        m = 10000\n    #print(m)\n    #m = 3\n    if m > 1:\n        return 'No solution'\n    #m = 3\n    if m == 1:\n        if abs(start[0] - end[0]) < 10000:\n            return 'No solution'\n        if start[1] > end[1]:\n            return 'No solution'\n        if start[1] < end[1]:\n            return 'No solution'\n    if m == 0:\n        return 'No solution'\n    if m == -1:\n        if abs(start[0] - end[0]) > 10000:\n            return 'No solution'\n        if start[1] > end[1]:\n            return 'No solution'\n        if start[1] < end[1]:\n            return 'No solution'\n    if m < 0:\n        if start[1] > end[1]:\n            return 'No solution'\n        if start[1] < end[1]:\n            return 'No solution'\n    if m > -1:\n        return 'No solution'\n    # 3\n    # 2\n    # 1\n    # 4\n\n    stack = []\n    for i in range(len(coord)):\n        if len(stack) == 0:\n            stack.append(i)\n        else:\n            if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                stack.pop()\n            elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                stack.append(i)\n            else:\n                continue\n            #print(stack)\n            #0\n            #1\n            #2\n            #3\n            if len(stack) == 0:\n                stack.append(i)\n            else:\n                if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                    stack.pop()\n                elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                    stack.append(i)\n                else:\n                    continue\n                #print(stack)\n                #0\n                #1\n                #2\n                #3\n                if len(stack) == 0:\n                    stack.append(i)\n                else:\n                    if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                        stack.pop()\n                    elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                        stack.append(i)\n                    else:\n                        continue\n                    #print(stack)\n                    #0\n                    #1\n                    #2\n                    #3\n                    if len(stack) == 0:\n                        stack.append(i)\n                    else:\n                        if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                            stack.pop()\n                        elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                            stack.append(i)\n                        else:\n                            continue\n                        #print(stack)\n                        #0\n                        #1\n                        #2\n                        #3\n                        if len(stack) == 0:\n                            stack.append(i)\n                        else:\n                            if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                                stack.pop()\n                            elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                                stack.append(i)\n                            else:\n                                continue\n                            #print(stack)\n                            #0\n                            #1\n                            #2\n                            #3\n                            if len(stack) == 0:\n                                stack.append(i)\n                            else:\n                                if abs(coord[i][0] - coord[stack[len(stack)-1]][0]) < 10000 and coord[i][1] > coord[stack[len(stack)-1]][1]:\n                                    stack.pop()\n                                elif abs(coord[i][0] - coord[stack[len(stack)-1]][0]) > 10000 and coord[i][1] < coord[stack[len(stack)-1]][1]:\n                                    stack.append(i)\n                               "
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sticks = []\n    for i in range(n):\n        sticks.append([int(s) for s in stdin.split()])\n    print(f\"There are {len(sticks)} sticks.\")\n\n    # make a stick, no collision\n    x_1, y_1 = sticks[0][0], sticks[0][1]\n    x_2, y_2 = sticks[0][2], sticks[0][3]\n    # find shortest way to x_2\n    path_x = y_2 - y_1\n    path_y = x_1 - x_2\n    # to avoid y=0 we need a positive value for y\n    # find the angle in rad\n    angle = math.atan2(path_y, path_x)\n    # find the length of the stick\n    length = math.hypot(path_x, path_y)\n    # distance between x and y\n    dist = math.hypot(x_1 - x_2, y_1 - y_2)\n\n    # set the movement of the stick\n    # find the smallest angle from 0 to 180 degrees\n    if dist < length:\n        angle_move = math.acos(dist / length)\n    else:\n        angle_move = math.pi\n\n    x_move, y_move = math.cos(angle + angle_move / 2), math.sin(angle + angle_move / 2)\n\n    # move the stick\n    # find x_2 and y_2\n    x_2 = math.floor((x_1 + x_2) / 2)\n    y_2 = math.floor((y_1 + y_2) / 2)\n\n    for i in range(len(sticks)):\n        # first move the stick\n        x_1, y_1 = sticks[i][0], sticks[i][1]\n        x_2, y_2 = sticks[i][2], sticks[i][3]\n        # find shortest way to x_2\n        path_x = y_2 - y_1\n        path_y = x_1 - x_2\n        # to avoid y=0 we need a positive value for y\n        # find the angle in rad\n        angle = math.atan2(path_y, path_x)\n        # find the length of the stick\n        length = math.hypot(path_x, path_y)\n        # distance between x and y\n        dist = math.hypot(x_1 - x_2, y_1 - y_2)\n\n        # set the movement of the stick\n        # find the smallest angle from 0 to 180 degrees\n        if dist < length:\n            angle_move = math.acos(dist / length)\n        else:\n            angle_move = math.pi\n\n        x_move, y_move = math.cos(angle + angle_move / 2), math.sin(angle + angle_move / 2)\n        # move the stick\n        x_1 += x_move\n        y_1 += y_move\n\n        # find the shortest way to x_2\n        path_x = y_2 - y_1\n        path_y = x_1 - x_2\n        # to avoid y=0 we need a positive value for y\n        # find the angle in rad\n        angle = math.atan2(path_y, path_x)\n        # find the length of the stick\n        length = math.hypot(path_x, path_y)\n        # distance between x and y\n        dist = math.hypot(x_1 - x_2, y_1 - y_2)\n\n        # set the movement of the stick\n        # find the smallest angle from 0 to 180 degrees\n        if dist < length:\n            angle_move = math.acos(dist / length)\n        else:\n            angle_move = math.pi\n\n        x_move, y_move = math.cos(angle + angle_move / 2), math.sin(angle + angle_move / 2)\n        # move the stick\n        x_2 += x_move\n        y_2 += y_move\n\n        # find the shortest way to x_2\n        path_x = y_2 - y_1\n        path_y = x_1 - x_2\n        # to avoid y=0 we need a positive value for y\n        # find the angle in rad\n        angle = math.atan2(path_y, path_x)\n        # find the length of the stick\n        length = math.hypot(path_x, path_y)\n        # distance between x and y\n        dist = math.hypot(x_1 - x_2, y_1 - y_2)\n\n        # set the movement of the stick\n        # find the smallest angle from 0 to 180 degrees\n        if dist < length:\n            angle_move = math.acos(dist / length)\n        else:\n            angle_move = math.pi\n\n        x_move, y_move = math.cos(angle + angle_move / 2), math.sin(angle + angle_move / 2)\n        # move the stick\n        x_1 += x_move\n        y_1 += y_move\n\n        # find the shortest way to x_2\n        path_x = y_2 - y_1\n        path_y = x_1 - x_2\n        # to avoid y=0 we need a positive value for y\n        # find the angle in rad\n        angle = math.atan2(path_y, path_x)\n        # find the length of the stick\n        length = math.hypot(path_x, path_y)\n        # distance between x and y\n        dist = math.hypot(x_1 - x_2, y_1 - y_2)\n\n        # set the movement of the stick\n        # find the smallest angle from 0 to 180 degrees\n        if dist < length:\n            angle_move = math.acos(dist / length)\n        else:\n            angle_move = math.pi\n\n        x_move, y_move = math.cos(angle + angle_move / 2), math.sin(angle + angle_move / 2)\n        # move the stick\n        x_"
    },
    {
        "number": 3169,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For CTCI the solution is the ordered sequence of moves to take\n    \"\"\"\n    stdin = list(map(int, stdin.strip().split()))\n    if len(stdin) == 1:\n        return stdin[0]\n    sticks = []\n    for i in range(len(stdin)):\n        sticks.append(stdin[i])\n    sticks.sort()\n\n    def make_line(stick1: int, stick2: int) -> Tuple[int, int]:\n        if stick1 == stick2:\n            return stick1, stick2\n        (x1, y1) = sticks[stick1]\n        (x2, y2) = sticks[stick2]\n        if x1 == x2:\n            slope = 0\n        else:\n            slope = (y2 - y1) / (x2 - x1)\n        x1 = int(x1)\n        y1 = int(y1)\n        x2 = int(x2)\n        y2 = int(y2)\n        if abs(slope) == 1:\n            return x1, y1\n        if abs(slope) == 2:\n            if slope == 0:\n                return x1, y2\n            return x2, y1\n        x1_b = (y2 - y1) / (slope - 1)\n        y1_b = slope * x1_b + y1\n        x2_b = (y2 - y1) / (slope + 1)\n        y2_b = slope * x2_b + y2\n        if x1_b < x2_b:\n            return x1, y1_b\n        else:\n            return x2, y2_b\n\n    def make_line2(stick1: int, stick2: int) -> Tuple[int, int]:\n        if stick1 == stick2:\n            return stick1, stick2\n        (x1, y1) = sticks[stick1]\n        (x2, y2) = sticks[stick2]\n        if x1 == x2:\n            slope = 0\n        else:\n            slope = (y2 - y1) / (x2 - x1)\n        x1 = int(x1)\n        y1 = int(y1)\n        x2 = int(x2)\n        y2 = int(y2)\n        if abs(slope) == 1:\n            return x1, y1\n        if abs(slope) == 2:\n            if slope == 0:\n                return x1, y2\n            return x2, y1\n        x1_b = (y2 - y1) / (slope - 1)\n        y1_b = slope * x1_b + y1\n        x2_b = (y2 - y1) / (slope + 1)\n        y2_b = slope * x2_b + y2\n        if x1_b < x2_b:\n            return x1, y1_b\n        else:\n            return x2, y2_b\n\n    def get_part(stick_order):\n        if len(stick_order) == 1:\n            return stick_order[0], stick_order[0]\n        new_stick_order = []\n        last_stick = stick_order[0]\n        for i in range(len(stick_order)):\n            if i == 0:\n                continue\n            if stick_order[i] == last_stick:\n                new_stick_order.append(stick_order[i])\n            else:\n                break\n        return get_part(new_stick_order)\n\n    part = []\n    for i in range(len(sticks)):\n        part.append(make_line2(i, i+1))\n    part.sort()\n    # part = sorted(part)\n    # part = sorted(part, key=lambda x: x[0])\n    # part = sorted(part, key=lambda x: x[1])\n    # part = sorted(part, key=lambda x: (x[0], x[1]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], -x[1]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1], -x[1]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1], x[2]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1], x[2], -x[1]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1], x[2], x[3]))\n    # print(part)\n    # part = sorted(part, key=lambda x: (x[0], x[1], x[2], x[3], -x[1]))\n    # print(part)\n    part = sorted(part, key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n    print(part)\n    return get_part(part)\n"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    deck = list(stdin.strip())\n    deck.sort(key=lambda x: x!= 'A')\n    count = 0\n    while count < 51:\n        if count == 10:\n            if deck[0] == 'T':\n                return \"Theta wins\"\n            return \"Theta loses\"\n        if count == 21:\n            return \"Theta loses\"\n        elif count == 10:\n            if deck[0] == 'T':\n                if deck[1] == 'A':\n                    deck[1] = '1'\n                if deck[1] == '2':\n                    deck[1] = '2'\n                if deck[1] == '3':\n                    deck[1] = '3'\n                if deck[1] == '4':\n                    deck[1] = '4'\n                if deck[1] == '5':\n                    deck[1] = '5'\n                if deck[1] == '6':\n                    deck[1] = '6'\n                if deck[1] == '7':\n                    deck[1] = '7'\n                if deck[1] == '8':\n                    deck[1] = '8'\n                if deck[1] == '9':\n                    deck[1] = '9'\n                if deck[1] == 'T':\n                    deck[1] = '10'\n                if deck[1] == 'J':\n                    deck[1] = '11'\n                if deck[1] == 'Q':\n                    deck[1] = '12'\n                if deck[1] == 'K':\n                    deck[1] = '13'\n                if deck[1] == 'A':\n                    deck[1] = '14'\n                count += 1\n                if deck[1] == 'T':\n                    deck[1] = '1'\n                if deck[1] == 'J':\n                    deck[1] = '2'\n                if deck[1] == 'Q':\n                    deck[1] = '3'\n                if deck[1] == 'K':\n                    deck[1] = '4'\n                if deck[1] == 'A':\n                    deck[1] = '5'\n                if deck[1] == 'T':\n                    deck[1] = '6'\n                if deck[1] == 'J':\n                    deck[1] = '7'\n                if deck[1] == 'Q':\n                    deck[1] = '8'\n                if deck[1] == 'K':\n                    deck[1] = '9'\n                if deck[1] == 'A':\n                    deck[1] = '10'\n                count += 1\n                if deck[1] == 'T':\n                    deck[1] = '1'\n                if deck[1] == 'J':\n                    deck[1] = '2'\n                if deck[1] == 'Q':\n                    deck[1] = '3'\n                if deck[1] == 'K':\n                    deck[1] = '4'\n                if deck[1] == 'A':\n                    deck[1] = '5'\n                if deck[1] == 'T':\n                    deck[1] = '6'\n                if deck[1] == 'J':\n                    deck[1] = '7'\n                if deck[1] == 'Q':\n                    deck[1] = '8'\n                if deck[1] == 'K':\n                    deck[1] = '9'\n                if deck[1] == 'A':\n                    deck[1] = '10'\n                count += 1\n                if deck[1] == 'T':\n                    deck[1] = '1'\n                if deck[1] == 'J':\n                    deck[1] = '2'\n                if deck[1] == 'Q':\n                    deck[1] = '3'\n                if deck[1] == 'K':\n                    deck[1] = '4'\n                if deck[1] == 'A':\n                    deck[1] = '5'\n                if deck[1] == 'T':\n                    deck[1] = '6'\n                if deck[1] == 'J':\n                    deck[1] = '7'\n                if deck[1] == 'Q':\n                    "
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    decks: List[List[int]] = [[], stdin.splitlines()]\n    while len(decks[1]) > 1:\n        for i in range(2):\n            decks[i] = sorted(decks[i])\n        for i in range(2):\n            for j in range(1, len(decks[i])):\n                if decks[i][j] == decks[i][j - 1] + 1:\n                    decks[i].pop(j)\n                    decks[i].pop(j - 1)\n                    decks[i].append(decks[i][j])\n    return f\"Theta wins\" if decks[1][0] == 'A' * 10 else f\"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    game = stdin.split('\\n')\n    shuffled = game[0].split(' ')\n    player = 0\n    discard = []\n    draw = []\n    for card in shuffled:\n        if card == 'T':\n            discard.append(card)\n        else:\n            draw.append(card)\n    while len(discard)!= 0:\n        if len(discard) >= 10:\n            if player == 0:\n                player = 1\n            else:\n                player = 0\n        if player == 0:\n            discard_index = draw.index(discard.pop())\n            discard_card = draw[discard_index]\n            draw.pop(discard_index)\n            if discard_card == 'T':\n                discard.append(discard_card)\n            else:\n                discard.append(discard_card)\n        else:\n            discard_index = discard.index(discard.pop())\n            discard_card = discard[discard_index]\n            discard.pop(discard_index)\n            if discard_card == 'T':\n                discard.append(discard_card)\n            else:\n                discard.append(discard_card)\n        if player == 0:\n            draw_index = draw.index(draw.pop(0))\n            draw_card = draw[draw_index]\n            draw.pop(draw_index)\n            if draw_card == 'T':\n                draw.append(draw_card)\n            else:\n                draw.append(draw_card)\n        else:\n            draw_index = draw.index(draw.pop(0))\n            draw_card = draw[draw_index]\n            draw.pop(draw_index)\n            if draw_card == 'T':\n                draw.append(draw_card)\n            else:\n                draw.append(draw_card)\n    if player == 0:\n        return f'Theta wins'\n    else:\n        return f'Theta loses'\n"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_one_of_ten(card: int) -> bool:\n        return card in {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100}\n\n    stdin = stdin.strip().split()\n    discard = []\n    drawing = []\n    for card in stdin:\n        if card == 'T':\n            discard.append(card)\n        elif card.isdigit():\n            if card in {'2', '3', '4', '5', '6', '7', '8', '9'}:\n                drawing.append(card)\n            else:\n                discard.append(card)\n        else:\n            discard.append(card)\n    if len(drawing) < 10:\n        return 'Theta wins'\n    else:\n        return 'Theta loses'"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) <= 10:\n        return 'Theta wins'\n\n    draws = stdin.split()\n    deck = [None] * 52\n    drawing = []\n    discard = []\n    for i in range(len(draws)):\n        if draws[i][0] == 'D':\n            discard.append(draws[i][1])\n        elif draws[i][0] == 'D':\n            drawing.append(draws[i][1])\n\n    drawing.sort()\n    discard.sort()\n\n    for i in range(len(drawing)):\n        if drawing[i]!= discard[i]:\n            return 'Theta wins'\n    return 'Theta loses'"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin.strip().split('\\n')\n    deck = list(int(d) for d in deck)\n    cards = {i: deck.count(i) for i in range(2, 10)}\n    for i in range(len(deck)):\n        if deck[i]!= 10:\n            break\n    cards[10] = deck[i]\n    total_cards = sum(cards.values())\n    cards_left = len(deck) - i\n    cards_left = {key: cards_left for key, value in cards.items()}\n    while len(cards_left) > 1:\n        if len(cards_left) > 2:\n            if cards_left[2] == 1:\n                del cards_left[2]\n            else:\n                del cards_left[2]\n                del cards_left[2]\n        elif len(cards_left) > 1:\n            if cards_left[1] == 1:\n                del cards_left[1]\n            else:\n                del cards_left[1]\n                del cards_left[1]\n        else:\n            del cards_left[1]\n    cards_left = {key: value for key, value in cards_left.items() if value > 0}\n    if not cards_left:\n        return 'Theta wins'\n    else:\n        return 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins' if cards[1] > cards[2] else 'Theta loses'\n    return 'Theta wins"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(map(lambda x: int(x), stdin.split()))\n    deck = sorted(deck[:10])\n    discard = list(map(lambda x: int(x), stdin.split()))\n    discard = sorted(discard[10:])\n    draw = list(range(10))\n    for i, c in enumerate(deck):\n        if discard and discard[0] == c:\n            discard.pop(0)\n        else:\n            draw.remove(c)\n    draw = list(map(lambda x: x + 1, draw))\n    draw.sort()\n    return \"Theta\" if draw[0] > draw[1] else \"Theta\" if draw[1] > draw[0] else \"Theta\" if draw[0] == draw[1] else \"Theta loses\"\n"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    shuffled = stdin.strip()\n    cards = '23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5'\n    deck = cards\n    player_hand = []\n    player_discard = []\n    draw_pile = []\n    for card in shuffled:\n        if card == 'T':\n            player_hand.append(cards[0])\n            player_discard.append(cards[0])\n            draw_pile.append(cards[0])\n        else:\n            player_discard.append(card)\n    for i in range(4):\n        for j in range(1, 10):\n            if deck[j] not in player_discard:\n                if len(deck) == 4:\n                    print(\"Theta wins\")\n                    return\n\n                draw_pile.append(deck[j])\n                del deck[j]\n                break\n    if len(draw_pile) == 0:\n        print(\"Theta wins\")\n        return\n\n    for i in range(10, 52):\n        if deck[i] not in player_discard:\n            if len(deck) == 4:\n                print(\"Theta wins\")\n                return\n\n            draw_pile.append(deck[i])\n            del deck[i]\n            break\n    print(\"Theta wins\")\n    return"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\n   ...     '23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5')\n    'Theta wins'\n    >>> solution(\n   ...     '89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49')\n    'Theta wins'\n    '''\n    from collections import defaultdict\n    deck = stdin.strip()\n    #print(deck)\n    #import pdb; pdb.set_trace()\n    deck = sorted(deck)\n    print(deck)\n    #import pdb; pdb.set_trace()\n    scores = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(int))))\n    #print(scores)\n    #import pdb; pdb.set_trace()\n    for i, d in enumerate(deck):\n        scores[i][i][i][d] += 1\n    #import pdb; pdb.set_trace()\n    print(scores)\n    #import pdb; pdb.set_trace()\n    #print(scores)\n    for _ in range(len(deck)):\n        i, j, k = 0, 0, 0\n        scores = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(int))))\n        for i in range(len(scores)):\n            for j in range(len(scores[i])):\n                for k in range(len(scores[i][j])):\n                    #print(scores)\n                    #import pdb; pdb.set_trace()\n                    for l, d in enumerate(deck):\n                        if scores[i][j][k][d] > 0:\n                            scores[i][j][k][d] -= 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores[i][j][k][d] += 1\n                            scores"
    },
    {
        "number": 3170,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    discard: str = ''\n    cards: list[str] = []\n    for _ in range(int(stdin)):\n        cards.append(stdin.split()[1])\n        if stdin.split()[0] == 'T':\n            discard += stdin.split()[1]\n        else:\n            discard += stdin.split()[1][:-1]\n    for _ in range(len(cards)):\n        cards.remove(cards[0])\n    cards.remove(cards[-1])\n    cards.remove(cards[-1])\n    cards.remove(cards[-1])\n    if len(cards) < 10 and discard:\n        if discard[-1] == 'A' and discard[-2] == 'A' and discard[-3] == 'A':\n            return 'Theta wins'\n    if len(cards) < 10:\n        return 'Theta loses'\n    if len(cards) == 10:\n        return 'Theta wins'\n    # count = 0\n    # for _ in range(len(cards) - 1):\n    #     if cards[_] == cards[_+1]:\n    #         count += 1\n    # if count == len(cards) - 1:\n    #     return 'Theta wins'\n    # else:\n    #     return 'Theta loses'\n    # print(cards)\n    # print(discard)\n    # print(cards[-1])\n    # if cards[-1] == 'T':\n    #     cards[-2] = 'A'\n    #     cards.remove(cards[-2])\n    # if discard and discard[-1] == 'T' and cards[-1] == 'J' and len(cards) == 9:\n    #     return 'Theta wins'\n    # if cards[0] == 'J' and cards[1] == 'J' and cards[2] == 'J' and cards[3] == 'J' and cards[4] == 'J' and cards[5] == 'J' and cards[6] == 'J' and cards[7] == 'J' and cards[8] == 'J' and len(cards) == 8:\n    #     return 'Theta wins'\n    # for _ in range(len(cards) - 1):\n    #     if cards[0] == cards[_] and cards[1] == cards[_+1]:\n    #         if cards[_] == 'T':\n    #             cards[_ + 2] = 'A'\n    #             cards.remove(cards[_ + 2])\n    #         if cards[_] == 'J' and cards[_ + 1] == 'J' and cards[_ + 2] == 'J' and cards[_ + 3] == 'J' and cards[_ + 4] == 'J' and cards[_ + 5] == 'J' and cards[_ + 6] == 'J' and cards[_ + 7] == 'J' and cards[_ + 8] == 'J' and cards[_ + 9] == 'J':\n    #             return 'Theta wins'\n    #         if cards[_] == 'J' and cards[_ + 1] == 'J' and cards[_ + 2] == 'J' and cards[_ + 3] == 'J' and cards[_ + 4] == 'J' and cards[_ + 5] == 'J' and cards[_ + 6] == 'J' and cards[_ + 7] == 'J' and cards[_ + 8] == 'J' and cards[_ + 9] == 'J':\n    #             return 'Theta wins'\n    #         if cards[_] == 'Q' and cards[_ + 1] == 'Q' and cards[_ + 2] == 'Q' and cards[_ + 3] == 'Q' and cards[_ + 4] == 'Q' and cards[_ + 5] == 'Q' and cards[_ + 6] == 'Q' and cards[_ + 7] == 'Q' and cards[_ + 8] == 'Q' and cards[_ + 9] == 'Q' and cards[_ + 10] == 'Q':\n    #             return 'Theta wins'\n    #         if cards[_] == 'Q' and cards[_ + 1] == 'Q' and cards[_ + 2] == 'Q' and cards[_ + 3] == 'Q' and cards[_ + 4] == 'Q' and cards"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    total = int(lines[0])\n    lines.pop(0)\n    assert len(lines) == total, f\"{len(lines)}!= {total}\"\n    for line in lines:\n        _, speaker, statement = line.split()\n        yield speaker[0] if speaker!= \"not\" else \"charlatan\""
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_line(line: str) -> (str, str):\n        speaker = line.split()[0]\n        utterance = line.split()[1]\n        if speaker == 'charlatan':\n            assert len(utterance) == 1\n            utterance = int(utterance)\n        return speaker, utterance\n\n    return '\\n'.join(sorted(set(parse_line(line) for line in stdin.splitlines())))\n"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c_types = {\n        1: 'truther',\n        2: 'fabulist',\n        3: 'charlatan',\n    }\n    return '\\n'.join(map(c_types.__getitem__, map(int, stdin.split())))"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, n, k = map(int, stdin.split())\n    spaces =''\n    lines = [[] for _ in range(n + 1)]\n    for _ in range(k):\n        line = stdin.split()\n        lines[int(line[0])].append(line[1])\n\n    for line in lines:\n        line = ''.join(line)\n        index = line.index(' ')\n        while line[index] =='':\n            index += 1\n        while line[index] == '\\n':\n            index += 1\n        yield line[index:].strip()\n"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    return 'truther' * (1 <= N <= 7 and 1 <= K <= 100)"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    utterances = []\n    for _ in range(K):\n        utterance = list(map(int, stdin.split()))\n        utterances.append(utterance)\n\n    candidates = {candidate_name: 1 for candidate_name in range(1, N + 1)}\n    characters = {\n        candidate_name: character\n        for candidate_name, character in zip(range(1, N + 1), \"truther, fabulist, charlatan\".split(\", \"))\n    }\n    for utterance in utterances:\n        speaker_name = utterance[0]\n        utterance_character = characters[speaker_name]\n        utterance_character_utterance = utterance[1:]\n        for utterance_character_utterance_value in utterance_character_utterance:\n            if utterance_character_utterance_value == 1:\n                candidate_name = utterance_character_utterance_value\n                candidates[candidate_name] = 1\n            else:\n                candidates[candidate_name] = 0\n    return list(candidates.values())[0]\n"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    utterances = []\n    for _ in range(k):\n        utterances.append(stdin.split()[:2])\n        stdin = stdin[2:]\n    candidates = []\n    for i in range(n):\n        candidates.append(utterances[i][0])\n    for utterance in utterances:\n        character = utterance[1]\n        if character == \"truther\":\n            for candidate in candidates:\n                if candidate in utterance:\n                    candidates.remove(candidate)\n                    break\n        elif character == \"fabulist\":\n            for candidate in candidates:\n                if candidate in utterance:\n                    candidates.remove(candidate)\n                    break\n        elif character == \"charlatan\":\n            for candidate in candidates:\n                if candidate in utterance:\n                    candidates.remove(candidate)\n                    break\n    return \"\".join(sorted(candidates))"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    u = []\n    for i in range(n):\n        u.append(stdin)\n    u = sorted(u)\n    cnt = [1] * n\n    for i in range(k):\n        if u[i][0] == \"1\":\n            cnt[int(u[i][1]) - 1] = 0\n        elif u[i][0] == \"2\":\n            cnt[int(u[i][1]) - 1] = 2\n        elif u[i][0] == \"3\":\n            cnt[int(u[i][1]) - 1] = 1\n        else:\n            cnt[int(u[i][1]) - 1] = 0\n    return str(cnt.index(2) + 1)\n"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (n, k) = (int(stdin.split()[0]), int(stdin.split()[1]))\n    transcript = []\n    for _ in range(k):\n        transcript.append(stdin.split()[2:])\n    return str([c[1] for c in transcript if c[0] == str(1) or c[0] == str(2)])"
    },
    {
        "number": 3171,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    points = []\n    points.append(stdin[1:])\n    points = sorted(points, key=lambda x: x[0])\n    points = sorted(points, key=lambda x: x[1])\n    f = 0\n    c = 0\n    for i in range(len(points)):\n        if abs(points[i][0]) < abs(points[i - 1][0]):\n            if abs(points[i][1]) < abs(points[i - 1][1]):\n                f += 1\n        elif abs(points[i][0]) > abs(points[i - 1][0]):\n            if abs(points[i][1]) > abs(points[i - 1][1]):\n                f += 1\n        elif abs(points[i][0]) == abs(points[i - 1][0]):\n            if abs(points[i][1]) < abs(points[i - 1][1]):\n                f += 1\n    return str(f)\n\nsolution(stdin)"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    fruits = []\n    for i in range(int(stdin)):\n        [x, y] = stdin.split()\n        fruits.append([float(x), float(y)])\n    fruits = sorted(fruits, key=lambda fruit: (fruit[0], fruit[1]))\n    max_fruits = 0\n    slice_start = (0, 0)\n    for i in range(len(fruits)):\n        slice_end = (fruits[i][0], fruits[i][1])\n        if slice_start[0] < slice_end[0] < slice_start[1] or \\\n                slice_start[0] < slice_end[1] < slice_start[1]:\n            max_fruits += 1\n            slice_start = (fruits[i][0], fruits[i][1])\n        elif slice_start[1] < slice_end[0] < slice_start[0]:\n            max_fruits += 1\n            slice_start = (fruits[i][0], fruits[i][1])\n    return str(max_fruits)\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fruits = []\n    for i in range(n):\n        fruits.append([float(x) for x in stdin.split()])\n    count = 0\n    for i in range(n):\n        x1 = fruits[i][0]\n        y1 = fruits[i][1]\n        for j in range(i + 1, n):\n            x2 = fruits[j][0]\n            y2 = fruits[j][1]\n            if abs(x1) < abs(x2) and abs(y1) < abs(y2):\n                x = x1 if abs(x1) > abs(x2) else x2\n                y = y1 if abs(y1) > abs(y2) else y2\n                if (x1 - x) * (y2 - y) - (x2 - x) * (y1 - y) > 0:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    trees = {}\n    for line in stdin.split('\\n'):\n        coords = tuple(float(i) for i in line.split())\n        if coords in trees:\n            trees[coords] += 1\n        else:\n            trees[coords] = 1\n\n    # compute the longest path\n    longest_path = -1\n    for fruit in trees:\n        path = trees[fruit]\n        longest_path = max(longest_path, path)\n\n    # the number of fruits on each path\n    return longest_path\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fruits = sorted([tuple(map(float, stdin.split())) for _ in range(n)])\n    fruits = sorted(fruits, key=lambda item: item[0] * item[0] + item[1] * item[1])\n    count = 0\n    while fruits:\n        fruit = fruits.pop(0)\n        for other_fruit in fruits:\n            if not (other_fruit[0] - fruit[0]) * (other_fruit[0] - fruit[0]) + (other_fruit[1] - fruit[1]) * (other_fruit[1] - fruit[1]) <= 0.5 * 10 ** 4:\n                fruits.remove(other_fruit)\n                count += 1\n                break\n    return str(count)\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    return str(result)\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Input\n        stdin: A list of n real numbers, given with exactly two digits after the decimal point\n    Output\n        n integers, the n integers are the number of times that line intersects the inner part or the boundary of a fruit\n    Constraints\n        0 <= x <= 10^4\n        0 <= y <= 10^4\n    Sample Output\n        3\n    \"\"\"\n    res = 0\n    n = int(stdin)\n\n    arr = [list(map(float, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        x1, y1 = arr[i]\n        for j in range(i + 1, n):\n            x2, y2 = arr[j]\n            if (x1 >= x2 and y1 <= y2) or (y1 >= y2 and x1 <= x2):\n                res += 1\n    print(res)\n\n\nsolution(input())\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # code goes here\n    return \"\"\n"
    },
    {
        "number": 3172,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes input and returns the maximum number of fruits that can be sliced with one straight-line swipe.\n\n    >>> solution('''5\n   ... 1.00 5.00\n   ... 3.00 3.00\n   ... 4.00 2.00\n   ... 6.00 4.50\n   ... 7.00 1.00\n   ... ''')\n    '4'\n    >>> solution('''5\n   ... -1.50 -1.00\n   ... 1.50 -1.00\n   ... 0.00 1.00\n   ... ''')\n    '3'\n    >>> solution('''5\n   ... 5.00 5.00\n   ... -1.00 -1.00\n   ... 0.00 1.00\n   ... 5.00 2.00\n   ... ''')\n    '3'\n    \"\"\"\n    fruits = []\n    for line in stdin.splitlines():\n        line = list(map(float, line.split()))\n        fruits.append(line)\n    \n    max_fruits = 0\n\n    for i in range(len(fruits)):\n        for j in range(i, len(fruits)):\n            if i == j:\n                continue\n            \n            if fruits[i][0] <= fruits[j][0] and fruits[i][1] <= fruits[j][1]:\n                continue\n            \n            if fruits[i][1] < fruits[j][0] or fruits[i][0] > fruits[j][1]:\n                continue\n            \n            fruits_slice = 0\n            for k in range(i, j+1):\n                fruits_slice += 1\n            max_fruits = max(max_fruits, fruits_slice)\n            \n    return max_fruits\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, parts = map(int, stdin.split())\n    grid = {(row, col): c for row, row_str in enumerate(stdin.split()) for col, c in enumerate(row_str)}\n    cur_score = 0\n    for part_id in range(parts):\n        for row, row_str in enumerate(stdin.split()):\n            for col, c in enumerate(row_str):\n                if c == '.':\n                    continue\n                elif c == 'X':\n                    grid[row, col] = c\n                elif c == 'R':\n                    if part_id == 0:\n                        grid[row, col] = '.'\n                elif c == 'L':\n                    if part_id == 0:\n                        grid[row, col] = '.'\n    for row in range(rows):\n        for col in range(cols):\n            score = 0\n            for part_id in range(parts):\n                if (row, col) in grid:\n                    if grid[row, col] == 'X':\n                        if part_id == 0:\n                            score = score + 1\n                        else:\n                            score = score + 5\n                    elif grid[row, col] == 'R':\n                        score = score + 5\n                    elif grid[row, col] == 'L':\n                        score = score + 1\n                    elif grid[row, col] == '?':\n                        score = score + 10\n            cur_score = max(score, cur_score)\n    return str(cur_score)\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    grid = [['.'] * (C+1) for _ in range(R+1)]\n    for _ in range(K):\n        direction, *cords = stdin.split()\n        cords = list(map(int, cords))\n        if direction == \"R\":\n            if cords[0] == C:\n                cords[0] = 1\n            for i in range(cords[0]):\n                grid[R][i] = \"R\"\n        else:\n            if cords[0] == R:\n                cords[0] = C\n            for i in range(cords[0]):\n                grid[i][C] = \"L\"\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == \".\":\n                grid[i][j] = \"X\"\n    scores = []\n    for i in range(1, R+1):\n        scores.append(sum([int(grid[i][j]) for j in range(1, C+1) if grid[i][j]!= \".\"]))\n    return str(max(scores))\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rows = list(stdin.split())\n    cols = list(stdin.split())\n    for i in range(1, len(rows)):\n        rows[i] = int(rows[i])\n    for j in range(1, len(cols)):\n        cols[j] = int(cols[j])\n    conveyor = []\n    for i in range(len(rows)):\n        conveyor.append([])\n        for j in range(len(cols)):\n            conveyor[i].append(cols[j])\n    total = 0\n    for i in range(len(rows)):\n        for j in range(len(cols)):\n            if conveyor[i][j] == 'R':\n                conveyor[i][j] = 'L'\n                left = j\n                while (conveyor[i][left] == 'L'):\n                    left -= 1\n                left += 1\n                while (conveyor[i][left] == 'L'):\n                    left += 1\n                conveyor[i][left] = 'R'\n                left += 1\n                while (conveyor[i][left] == 'L'):\n                    left += 1\n                left -= 1\n                while (conveyor[i][left] == 'R'):\n                    left -= 1\n                if left == j:\n                    if j == len(cols)-1:\n                        break\n                    else:\n                        continue\n                else:\n                    total += rows[i]\n                    conveyor[i][j] = cols[j]\n                    if j == len(cols)-1:\n                        break\n                    else:\n                        continue\n    return str(total)\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = list(map(int, stdin.split()))\n\n    grid = []\n\n    for _ in range(R):\n        grid.append(list(stdin.strip().split()))\n\n    ans = 0\n    for _ in range(K):\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 'X':\n                    break\n\n                if grid[r][c] == '.':\n                    ans = max(ans, sum(i.count('X') for i in grid[max(0, r - 1):min(r + 2, R)]))\n                    continue\n\n                if grid[r][c] == 'R':\n                    grid[r][c] = '.'\n                    continue\n\n                if grid[r][c] == 'L':\n                    grid[r][c] = '.'\n                    continue\n\n                if grid[r][c] == '?':\n                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n                        nr, nc = r + dr, c + dc\n                        while 0 <= nr < R and 0 <= nc < C and grid[nr][nc]!= 'X':\n                            nr += dr\n                            nc += dc\n\n                        if nr < 0 or nr >= R or nc < 0 or nc >= C:\n                            grid[r][c] = '.'\n                            break\n\n                        grid[r][c] = 'R'\n                        grid[nr][nc] = 'L'\n                        break\n\n    return str(ans)"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    grid = [[stdin[i] for i in range(R * C + 1)] for _ in range(R + 1)]\n    for _ in range(K):\n        for i in range(1, R + 1):\n            for j in range(C):\n                grid[i][j] = grid[i - 1][j]\n        for i in range(1, R):\n            for j in range(C - 1, -1, -1):\n                grid[i][j] = grid[i][j + 1]\n        for i in range(R, 0, -1):\n            for j in range(C):\n                grid[i][j] = grid[i - 1][j]\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'X':\n                break\n            elif j == C - 1:\n                return ''.join(grid[i])\n    return ''.join(stdin)\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    R, C, K = list(map(int, stdin[0].split()))\n    grid = []\n    for i in range(R):\n        grid.append(list(stdin[i+1]))\n    return\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k = map(int, stdin.split())\n\n    grid = []\n    for _ in range(r):\n        row = stdin.split('.')\n        row = list(map(lambda x: x == '.', row))\n        grid.append(row)\n\n    score_dic = {}\n    def dfs(grid, pos, score, part_size):\n        if pos in score_dic:\n            return score_dic[pos]\n\n        if pos == (part_size, part_size):\n            score_dic[pos] = score\n            return score\n\n        if pos[0] > part_size or pos[0] < 0 or pos[1] > part_size or pos[1] < 0:\n            return score\n\n        if grid[pos[0]][pos[1]]:\n            return score\n\n        if grid[pos[0]][pos[1]] == '?':\n            if pos[1] == 0:\n                grid[pos[0]][pos[1]] = 'X'\n                score += 1\n            else:\n                grid[pos[0]][pos[1]] = 'R'\n                score += 1\n            score_dic[pos] = score\n            return score\n\n        if grid[pos[0]][pos[1]] == 'R':\n            grid[pos[0]][pos[1]] = 'X'\n            score += 1\n            dfs(grid, (pos[0] - 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0] + 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0], pos[1] - 1), score, part_size)\n            dfs(grid, (pos[0], pos[1] + 1), score, part_size)\n            grid[pos[0]][pos[1]] = '.'\n            score_dic[pos] = score\n            return score\n\n        if grid[pos[0]][pos[1]] == 'L':\n            grid[pos[0]][pos[1]] = 'X'\n            score += 1\n            dfs(grid, (pos[0] - 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0] + 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0], pos[1] - 1), score, part_size)\n            dfs(grid, (pos[0], pos[1] + 1), score, part_size)\n            grid[pos[0]][pos[1]] = '.'\n            score_dic[pos] = score\n            return score\n\n        if grid[pos[0]][pos[1]] == '.':\n            score += 1\n            dfs(grid, (pos[0] - 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0] + 1, pos[1]), score, part_size)\n            dfs(grid, (pos[0], pos[1] - 1), score, part_size)\n            dfs(grid, (pos[0], pos[1] + 1), score, part_size)\n            grid[pos[0]][pos[1]] = '.'\n            score_dic[pos] = score\n            return score\n\n    score = 0\n    score_dic = {}\n    dfs(grid, (0, 0), score, c)\n    return str(score_dic[(0, 0)])\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, k = map(int, stdin.split())\n    grid = stdin\n    score = 0\n    for _ in range(rows):\n        if _ % 2 == 0:\n            grid += \".\" * cols\n        else:\n            grid += \"X\" * cols\n    for _ in range(rows):\n        for i in range(rows - 1, 0, -1):\n            if grid[i] == \"X\":\n                if grid[i - 1] == \".\":\n                    score += 1\n                if grid[i + 1] == \".\":\n                    score += 1\n                if grid[i + cols] == \".\":\n                    score += 1\n                if grid[i - cols] == \".\":\n                    score += 1\n                grid = grid[:i] + \".\" + grid[i + 1:]\n        if grid[0] == \"X\":\n            if grid[1] == \".\":\n                score += 1\n            if grid[-2] == \".\":\n                score += 1\n            if grid[-1] == \".\":\n                score += 1\n            if grid[-cols] == \".\":\n                score += 1\n            grid = grid[:-2] + \".\" + grid[-1]\n    return str(score)\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    data = [['.' for _ in range(C)] for _ in range(R)]\n    #print(data)\n    conveyor = {'R': 'R', 'L': 'L', '?': '?'}\n    for r in range(R):\n        stdin = stdin.split()[r]\n        for c in range(len(stdin)):\n            data[r][c] = stdin[c]\n    #print(data)\n    for i in range(1, R):\n        conveyor['R'] = 'R'\n        for j in range(1, C):\n            if data[i][j] == '?':\n                if data[i][j-1] == 'R':\n                    conveyor['L'] = 'L'\n                    data[i][j] = '?'\n                elif data[i][j-1] == 'L':\n                    conveyor['R'] = 'R'\n                    data[i][j] = '?'\n            elif data[i][j] == '.':\n                if data[i-1][j] == 'R':\n                    conveyor['L'] = 'L'\n                    data[i][j] = '?'\n                elif data[i-1][j] == 'L':\n                    conveyor['R'] = 'R'\n                    data[i][j] = '?'\n            else:\n                if data[i-1][j] == 'R' and data[i][j] == '.':\n                    conveyor['L'] = 'L'\n                    data[i][j] = '.'\n                elif data[i-1][j] == 'L' and data[i][j] == '.':\n                    conveyor['R'] = 'R'\n                    data[i][j] = '.'\n    #print(data)\n    score = 0\n    for r in range(R):\n        for c in range(C):\n            score += data[r][c] * (10 ** (C - c - 1))\n    return str(score)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3173,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    K -= 1\n    B = [[[0] * (C+1) for _ in range(R+1)] for _ in range(C+1)]\n    print(B)\n    for _ in range(R+1):\n        for _ in range(C+1):\n            if _ == 0 or _ == C or _ == C+1:\n                B[_][_][K] = 1\n            elif _ == 1:\n                B[_][_][K] = _\n            else:\n                if _ == 2 and _+1 == C:\n                    B[1][1][K] = 1\n                elif _ == 2 and _-1 == C:\n                    B[1][C-1][K] = 1\n                elif _ == 1 and _+1 == C:\n                    B[1][C-1][K] = 1\n                elif _ == 1 and _-1 == C:\n                    B[1][1][K] = 1\n                elif _+1 == C and _-1 == C:\n                    B[1][C-1][K] = 1\n                elif _ == 2 and _+1 == C and _-1 == C:\n                    B[1][C-1][K] = 1\n                elif _ == 2 and _-1 == C:\n                    B[1][C-1][K] = 1\n                elif _ == 1 and _+1 == C and _-1 == C:\n                    B[1][1][K] = 1\n                else:\n                    B[1][_][K] = 1\n                if _ == 2 and _-1 == C:\n                    B[C-1][_][K] = 1\n                elif _ == 2 and _+1 == C:\n                    B[C-1][_][K] = 1\n                elif _ == 1 and _-1 == C:\n                    B[C-1][_][K] = 1\n                elif _ == 1 and _+1 == C:\n                    B[C-1][_][K] = 1\n                elif _+1 == C and _-1 == C:\n                    B[C-1][C-1][K] = 1\n                elif _ == 2 and _+1 == C and _-1 == C:\n                    B[C-1][C-1][K] = 1\n                elif _ == 2 and _-1 == C:\n                    B[C-1][C-1][K] = 1\n                elif _ == 1 and _+1 == C and _-1 == C:\n                    B[C-1][C-1][K] = 1\n                else:\n                    B[C-1][_][K] = 1\n\n    for i in range(R-1,-1,-1):\n        for j in range(C):\n            if j!= 0:\n                B[i][C][K] = 1\n            else:\n                if i+1 == R-1:\n                    B[i][C][K] = 1\n            if j!= C-1:\n                B[i][j][K] = 1\n            else:\n                if i+1 == R-1:\n                    B[i][C-1][K] = 1\n        if i!= R-1:\n            for k in range(C-1,-1,-1):\n                B[i][k][K] = 1\n        else:\n            for k in range(C):\n                if k!= 0:\n                    B[i][k][K] = 1\n                else:\n                    if i+1 == R-1:\n                        B[i][C-1][K] = 1\n    for i in range(C):\n        for j in range(R-1,-1,-1):\n            if j!= 0:\n                B[j][i][K] = 1\n            else:\n                if i+1 == R-1:\n                    B[C-1][i][K] = 1\n        if j!= C-1:\n            for k in range(C-1,-1,-1):\n                B[j][k][K] = 1\n        else:\n            for k in range(R-1,-1,-1):\n                if k!= 0:\n                    B[j][k][K] = 1\n    for i in range(R):\n        for j in range(C-1,-1,-1):\n            if j!= 0:\n                B[i][j][K] = 1\n            else:\n                if i+1 == R-1:\n                    B[i][C-1][K] = 1\n        if j!= C-1:\n            for k in range(C-1,-1,-1):\n                B[i"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    line_count = get_line_count(stdin)\n    # split into a list of ints\n    n, k = map(int, stdin.split())\n    # n = 5, k = 3,\n    # x = 4, y = 3, z = 4\n    # a = (4, 3, 4)\n    # b = (4, 3, 4)\n    a = []\n    b = []\n    c = []\n    for i in range(n):\n        x, y, z = map(int, stdin.split())\n        a.append((x, y, z))\n    for i in range(n):\n        x, y, z = map(int, stdin.split())\n        b.append((x, y, z))\n    for i in range(n):\n        x, y, z = map(int, stdin.split())\n        c.append((x, y, z))\n    a.sort()\n    b.sort()\n    c.sort()\n    if len(a)!= len(b) or len(a)!= len(c):\n        return \"0\"\n    distances = []\n    for i in range(n):\n        x1, y1, z1 = a[i]\n        x2, y2, z2 = b[i]\n        x3, y3, z3 = c[i]\n        distances.append(manhattan_distance((x1, y1), (x2, y2)))\n        distances.append(manhattan_distance((x1, y1), (x3, y3)))\n        distances.append(manhattan_distance((x2, y2), (x3, y3)))\n    distances.sort()\n    if len(distances)!= n:\n        return \"0\"\n    if len(distances) % 2 == 0:\n        mid = len(distances) // 2\n        distances.sort()\n        distances_mid = distances[mid:]\n        distances = distances[:mid]\n        if sum(distances_mid) % k!= 0:\n            return \"0\"\n        else:\n            if sum(distances) % k!= 0:\n                return \"0\"\n            else:\n                if distances[0] > distances[-1]:\n                    return \"0\"\n                else:\n                    return str(distances[0]) + \".\" + str(distances[-1])\n    else:\n        mid = len(distances) // 2\n        distances.sort()\n        distances_mid = distances[mid + 1:]\n        distances = distances[:mid + 1]\n        if sum(distances_mid) % k!= 0:\n            return \"0\"\n        else:\n            if sum(distances) % k!= 0:\n                return \"0\"\n            else:\n                if distances[0] > distances[-1]:\n                    return \"0\"\n                else:\n                    return str(distances[0]) + \".\" + str(distances[-1])\n    return distances[0] + \".\" + distances[-1]\n\n\ndef"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.split()\n    N, K = map(int, stdin_lines[0].split())\n    cities = []\n    for i in range(1, N + 1):\n        x, y, k = map(int, stdin_lines[i].split())\n        cities.append((x, y, k))\n    min_distance = float('inf')\n    for a in range(1, 101):\n        for b in range(1, 101):\n            for c in range(1, 101):\n                if a + b + c == 100:\n                    s = a * b * c\n                    if s % K == 0:\n                        # print(s, a, b, c)\n                        if min_distance > s / a:\n                            min_distance = s / a\n                            distance = a + b + c\n    return str(distance)\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    #...\n    return...\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes input and splits it into two arrays. First array contains integers x, y, k, the second array contains integers N, K.\n    Then we iterate through each k in the second array and save each pair (x, y) to a temporary dictionary.\n    For each k, we do a nested for loop to check if the distance between (x, y) and each city can be found in the dictionary.\n    If it can be found, we calculate the sum of the cities and if that sum is divisible by k, we print out the distance.\n    Otherwise, we just skip it.\n    \"\"\"\n    # Split the input into two parts\n    first_part, second_part = stdin.split(\"\\n\")\n    first_part = first_part.split(\"\\n\")\n    second_part = second_part.split(\"\\n\")\n    \n    # Initialize variables for our dictionary\n    distances = {}\n    \n    # Iterate through each k and look for each distance between x, y\n    for k in second_part:\n        k = k.split(\" \")\n        key = (k[0], k[1])\n        for i in range(2, len(k)):\n            key = (key[0], k[i])\n            if key in distances:\n                distances[key] += int(k[i])\n            else:\n                distances[key] = int(k[i])\n                \n    for k in first_part:\n        k = k.split(\" \")\n        # Calculate the distance between x, y\n        key = (k[0], k[1])\n        x = int(k[0])\n        y = int(k[1])\n        dist = int(k[2])\n        if key in distances:\n            if (distances[key] % dist) == 0:\n                print(dist)\n                return\n        else:\n            continue\n    \n    print(\"INVALID\")"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    result: float = 0\n    for i in stdin.split(\"\\n\"):\n        x = list(map(int, i.split()))\n        s = 0\n        for j in x:\n            s += j\n        if s % 10 == 0:\n            result = max(result, (s // 10) - 1)\n        else:\n            result = max(result, s // 10)\n    return \"{:.3f}\".format(result)\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def valid(D, N):\n        cnt = 0\n        for i in range(N):\n            x, y, k = map(int, stdin.split(' '))\n            cnt += k\n            if cnt > D or cnt % k!= 0:\n                return False\n            cnt = cnt // k\n        return True\n\n    for D in range(1, 100000000):\n        if valid(D, int(stdin.split(' ')[0])):\n            return str(D)\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_roads(road: List[Tuple[int, int]]) -> int:\n        count = 0\n        i = 0\n        while i < len(road):\n            j = i + 1\n            while j < len(road):\n                if road[i][0] == road[j][0] and road[i][1] == road[j][1]:\n                    count += 1\n                    j += 1\n                else:\n                    break\n            i += 1\n        return count\n\n    def find_max(roads: List[List[Tuple[int, int]]], max_road: int) -> Tuple[int, int]:\n        def count_places(road: List[Tuple[int, int]]) -> int:\n            res = 0\n            for city in road:\n                res += city[2]\n            return res\n\n        i = 0\n        while i < len(roads):\n            j = i + 1\n            while j < len(roads):\n                if roads[i][0] == roads[j][0] and roads[i][1] == roads[j][1]:\n                    if count_places(roads[i]) % max_road == 0 and count_places(roads[j]) % max_road == 0:\n                        return roads[i]\n                    else:\n                        break\n                else:\n                    break\n            i += 1\n        return None\n\n    N, K = map(int, stdin.split())\n    roads = [[int(num) for num in stdin.split()] for _ in range(N)]\n\n    max_road = max([count_roads(road) for road in roads])\n    road = find_max(roads, max_road)\n\n    d = road[0]\n    for i in range(K):\n        d = (d[0] + road[i + 1][0], d[1] + road[i + 1][1])\n\n    return str(round(d[0] / max_road, 3)) + '.' + str(round(d[1] / max_road, 3))\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    x = [[0] * N for _ in range(N)]\n    y = [[0] * N for _ in range(N)]\n    for i in range(N):\n        x[i] = list(map(int, stdin.split()))[i * 2 + 1]\n        y[i] = list(map(int, stdin.split()))[i * 2 + 2]\n    x.sort()\n    y.sort()\n    # count = 0\n    # tmp = 0\n    # for i in range(N):\n    #     if tmp == 0:\n    #         tmp = x[i]\n    #         count += 1\n    #     else:\n    #         tmp = tmp + x[i]\n    #         if tmp > K:\n    #             return 'N/A'\n    #         count += 1\n    # for i in range(N):\n    #     if tmp == 0:\n    #         tmp = y[i]\n    #         count += 1\n    #     else:\n    #         tmp = tmp + y[i]\n    #         if tmp > K:\n    #             return 'N/A'\n    #         count += 1\n    # print(count)\n\n    # # \uac00\uc6b4\ub370 \ubb38\uc81c\ub97c \uc5b4\ub5bb\uac8c \ud574\uacb0\ud560 \uc218 \uc788\uc744\uae4c?\n    # # \uc815\ub82c\uc744 \ud558\ub294 \uac83\uc774 \uc5b4\ub835\ub2e4\n    # # \uc911\ubcf5\ub41c \uc560\ub294 \ud55c\ubc88\ub9cc \ub123\uc5b4\uc918\uc57c \ud558\ub294 \uac70 \uac19\ub2e4\n    # # \ub05d\uae4c\uc9c0 \uac08\ub54c\ub9c8\ub2e4 \uac00\uc7a5 \uae34\uac83\ub4e4\uc744 \ucc3e\uace0\n    # # \uae38\uc774\uac00 \ub2e4\ub97c\ub54c, \uc624\ub984\ucc28\uc21c \uc815\ub82c\ud558\uc5ec \uac00\uc7a5 \uae34\uac83\ub4e4 \ub9cc\ub4e4\uae30\n    #\n    #\n    #\n    #\n    #\n    #\n    # # \uc5ec\uae30\ub3c4 \uc5b4\ub835\uc9c0\ub9cc \ubaa8\uc591\ub3c4 \uac19\uc740 \ubb38\uc81c\uc774\ub2e4\n    # # \uc65c \uc5b4\ub5bb\uac8c \uac00\uc7a5 \uae34 \ub2e8\uc5b4\ub97c \uad6c\ud574\uc57c \ud558\ub294\uc9c0 \uc0dd\uac01\ud574\ubcf4\ub294\uac8c \uc5b4\ub835\ub2e4\n    # # \uac00\uc7a5 \uae34 \uac83\uc740 \ub098\uc911\uc5d0 \uac00\uc7a5 \uae34 \ub2e8\uc5b4\ub85c \ucc98\ub9ac\ud574\ubc84\ub9ac\uae30 \ub54c\ubb38\uc5d0 \uc2dc\uac04\uc774 \ub9ce\uc774 \uc18c\uc694\ub41c\ub2e4\n    #\n    # n = len(x)\n    #\n    # # 1. \uc911\ubcf5\uc744 \uc81c\uac70\ud55c \ub9ac\uc2a4\ud2b8\n    # # 2. \uc815\ub82c\ud574\uc918\uc57c\ud558\uae30 \ub54c\ubb38\uc5d0 sort\ud558\uc5ec \ucc98\ub9ac\n    # # 3. \uc624\ub984\ucc28\uc21c \uc815\ub82c\n    # # 4. \uac00\uc7a5 \uae34 \ub2e8\uc5b4\ub97c \ucc3e\uace0\n    # # 5. \uac00\uc7a5 \uae34 \ub2e8\uc5b4\uc758 \uae38\uc774\ub294 1\uc774\ubbc0\ub85c \ubc14\ub85c \ucd9c\ub825\ud574\uc900\ub2e4\n    #\n    # result = 0\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    # # 4. \uac00\uc7a5 \uae34 \ub2e8\uc5b4\uc758 \uae38\uc774\ub294 1\uc774\ubbc0\ub85c \ubc14\ub85c \ucd9c\ub825\ud574\uc900\ub2e4\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    "
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        return all(n % i for i in range(2, int(n**0.5) + 1))\n    lines = stdin.splitlines()\n    t = lines[0].split()\n    N, K = int(t[0]), int(t[1])\n    if N <= 0 or N > 50000 or K <= 0 or K > 30:\n        raise Exception('bad N or K')\n    \n    points = [tuple(map(int, i.split())) for i in lines[1:]]\n    points = sorted(points, key=lambda x: x[0])\n    points = sorted(points, key=lambda x: x[1])\n    if len(points)!= N:\n        raise Exception('bad points')\n    \n    res = float('inf')\n    for k in range(1, K + 1):\n        if k % 2!= 0:\n            raise Exception('odd k')\n        q = int(math.ceil(k / 2))\n        def compute(idx: int, r: int) -> bool:\n            if idx >= len(points) - 1:\n                return False\n            x0, y0 = points[idx]\n            n = len(points)\n            for i in range(idx + 1, n):\n                x1, y1 = points[i]\n                if x0 == x1 or x1 == x0 or y0 == y1 or y1 == y0:\n                    continue\n                dist = math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2)\n                if dist % k!= 0:\n                    continue\n                if dist > r:\n                    return False\n                if is_prime(dist):\n                    return False\n            return True\n        \n        for idx in range(len(points)):\n            if not compute(idx, points[idx][2]):\n                break\n        else:\n            res = min(res, points[idx][2])\n    \n    return str(round(res, 3))\n"
    },
    {
        "number": 3174,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    n, k = map(int, stdin.split())\n    points = [(i, j, int(j / k)) for i, j, in zip(range(n), stdin.split())]\n    return str(min([sum(k) for k in combinations(points, 2)]))\n\n\ndef"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    fences = sorted(map(int, stdin.split(\"\\n\")[0].split(\" \")))\n    if len(fences) == 1:\n        return \"0.0\"\n    else:\n        segments = fences[:-1]\n        print(segments)\n        segment_max = max(segments)\n        print(segment_max)\n        if len(fences) == 2:\n            return str(0.433)\n        if len(fences) == 3:\n            return str(1.0)\n        print(\"asdf\")\n    return \"0.0\"\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    fence = list(map(float, stdin.strip().split()))\n    segments = sorted(fence)\n    area = 0\n    length = 1\n    for i in range(len(segments)):\n        if segments[i] == segments[i - 1]:\n            continue\n        else:\n            if i == 0:\n                length = segments[i]\n            else:\n                length = segments[i] - segments[i - 1]\n            area += length * abs(segments[i] - segments[i - 1]) / 2\n            length = 1\n    return f\"{area:.5f}\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lst = map(float, stdin.split()[1:])\n    largest = 0\n    for i in lst:\n        largest = max(largest, i*i)\n    return \"{:.4f}\".format(largest)"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lengths = stdin.split()\n    return \"%.6f\" % max(sorted([float(x) for x in lengths])[-1], 0)\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = stdin.split()[1:]\n    max_square = 0\n    for length in segments:\n        max_square = max(max_square, length * length)\n    return \"{:.5f}\".format(max_square)\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lst = [int(x) for x in stdin.split()]\n    # lst = list(map(int, stdin.split()))\n    lst.sort()\n    res = 0\n    min_ = lst[0]\n    for i in range(len(lst)):\n        if i == 0:\n            curr = min_ * (1 + lst[i])\n            curr_ = curr\n            continue\n        curr = min_ * (1 + lst[i])\n        curr_ = max(curr_, curr)\n        res = max(res, curr_)\n    return res\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    return f'{max(fence_lengths(lines))}'\n\ndef"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    segments = list(map(int, lines[1].split()))\n    length = max(segments)\n    if length == 1:\n        return '0'\n    height = sum(segments) / length\n    result = 0\n    for i in range(1, length):\n        segment_width = segments[i] - segments[i - 1]\n        result += height + segment_width\n    return str(round(result, 3))\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    segments = [int(i) for i in stdin.split()]\n    segments.sort(reverse=True)\n    largestArea = 0\n    while segments:\n        first = segments.pop()\n        while segments:\n            second = segments.pop()\n            area = 0.5 * (first + second) * abs(first - second)\n            if area > largestArea:\n                largestArea = area\n    return str(largestArea)\n"
    },
    {
        "number": 3175,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                sides = sorted([lengths[i], lengths[j], lengths[k]])\n                area = sides[0] * sides[1] + sides[0] * sides[2] + sides[1] * sides[2]\n                if area > max_area:\n                    max_area = area\n    return str(max_area)"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plants_grid = []\n    for row in stdin.splitlines():\n        x, y, fly = map(int, row.split())\n        plants_grid.append((x, y, fly))\n    for i in range(len(plants_grid) - 1):\n        if plants_grid[i][2] > plants_grid[i + 1][2]:\n            plants_grid[i], plants_grid[i + 1] = plants_grid[i + 1], plants_grid[i]\n        if plants_grid[i][1] > plants_grid[i + 1][1]:\n            plants_grid[i], plants_grid[i + 1] = plants_grid[i + 1], plants_grid[i]\n\n    prev_energy_level = 0\n    for j in range(len(plants_grid)):\n        x = plants_grid[j][0]\n        y = plants_grid[j][1]\n        energy_level = prev_energy_level + plants_grid[j][2]\n        if (energy_level + prev_energy_level) > K:\n            prev_energy_level = energy_level + prev_energy_level\n        else:\n            prev_energy_level = energy_level + prev_energy_level\n\n    return str(prev_energy_level)"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4 5\n   ... 1 1 5\n   ... 2 1 5\n   ... 1 2 4\n   ... 2 3 5\n   ... 3 2 30\n   ... 3 3 5\n   ... ''')\n    '5'\n    >>> solution('''\n   ... 10 10\n   ... 1 1 15\n   ... 2 2 30\n   ... 1 2 8\n   ... 2 1 7\n   ... 3 2 8\n   ... 2 3 7\n   ... 4 2 100\n   ... 3 3 15\n   ... ''')\n    '36'\n    >>> solution('''\n   ... 10 10\n   ... 1 2 10\n   ... 3 1 15\n   ... 1 1 8\n   ... 1 2 7\n   ... 2 3 8\n   ... 3 2 7\n   ... 4 2 100\n   ... 3 3 15\n   ... ''')\n    '40'\n    \"\"\"\n\n    from typing import List\n    from collections import deque\n    from itertools import chain\n\n    N, K = map(int, stdin.split())\n    plants: List[List[int]] = []\n    for _ in range(N):\n        plants.append(list(map(int, stdin.split())))\n\n    # BFS\n    queue = deque([(1, 0)])\n    while queue:\n        plant, jumps = queue.popleft()\n        if plant == N:\n            return jumps\n\n        for neighbor_plant in chain([plant + 1], plants[plant - 1], plants[plant], plants[N - 1]):\n            if neighbor_plant not in [plant, plant + 1, plant - 1, plant + N - 1]:\n                if neighbor_plant - 1 > 0 and neighbor_plant!= plant:\n                    queue.append((neighbor_plant, jumps + K - 1))\n                if neighbor_plant + 1 <= N and neighbor_plant!= plant:\n                    queue.append((neighbor_plant, jumps + K - 1))\n                if neighbor_plant - N + 1 >= 1 and neighbor_plant!= plant:\n                    queue.append((neighbor_plant, jumps + K - 1))\n                if neighbor_plant + N - 1 <= N and neighbor_plant!= plant:\n                    queue.append((neighbor_plant, jumps + K - 1))\n    return 'LOSE'\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = [list(map(int, stdin.split())) for _ in range(n)]\n    max_sum = 0\n    max_idx = (-1, -1)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            sum_i_j = 0\n            for x, y in arr[i]:\n                if x > j:\n                    sum_i_j += (x - j - 1)\n                elif y < i:\n                    sum_i_j += (i - y - 1)\n            if max_sum < sum_i_j:\n                max_sum = sum_i_j\n                max_idx = (i, j)\n    # print(max_idx)\n    res = ''\n    for i, j in arr:\n        if i == max_idx[0] and j == max_idx[1]:\n            continue\n        if j > max_idx[0]:\n            res += str(i) +'' + str(j) +''\n        elif j < max_idx[0]:\n            res += str(i) +'' + str(j) +''\n    return res[:-1]\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    plants = {}\n    for i in range(1, n + 1):\n        x, y, c = map(int, stdin.split())\n        plants[(x, y)] = c\n    cur_x, cur_y = (1, 1)\n    # todo: for now we are doing \"bfs\" only\n    visited = {(1, 1)}\n    q = deque([(cur_x, cur_y, 0)])\n    while len(q) > 0:\n        cur_x, cur_y, cur_energy = q.popleft()\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            new_x = cur_x + dx\n            new_y = cur_y + dy\n            # if we are not going diagonally\n            if abs(dx)!= abs(dy):\n                new_energy = cur_energy\n            else:\n                new_energy = min(cur_energy, abs(dx))\n\n            if new_x <= n and new_y <= n and (new_x, new_y) in plants and (new_x, new_y) not in visited:\n                q.append((new_x, new_y, new_energy))\n                visited.add((new_x, new_y))\n                plants[(new_x, new_y)] += new_energy\n    return str(sum(plants.values()))\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    plants = []\n    for _ in range(N):\n        plant = list(map(int, stdin.split()))\n        plants.append(plant)\n\n    energy = K\n    res = 0\n    for plant in plants:\n        plant.append(energy)\n        energy += K\n        res = max(res, plant[1])\n    return str(res)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    graph = collections.defaultdict(set)\n    for i in range(1, N+1):\n        x, y, f = map(int, stdin.split())\n        for j in range(i+1, N+1):\n            graph[i].add((j, y))\n            graph[j].add((i, x))\n    d = []\n    visited = set()\n    visited.add(1)\n    q = collections.deque([(1, 0)])\n    while q:\n        node, energy = q.popleft()\n        if node == N:\n            return str(energy)\n        if node not in d:\n            d.append(node)\n            for x, y in graph[node]:\n                if (x, y) not in visited:\n                    visited.add((x, y))\n                    q.append((x, energy+K))\n    return str(len(d))\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of numbers representing coordinates and produces the sequence of coordinates to go to as per the problem.\n    \"\"\"\n    N, K = map(int, stdin.split())\n    plant_coords = {int(x) for x in stdin.split()}\n    max_jumps = (max(plant_coords, key=lambda x: max(abs(x[0] - x[1]), x[1] - x[0]))[0] + 1) - min(plant_coords, key=lambda x: min(x[0] - x[1], x[1] - x[0]))[0] + 1\n    return str(max_jumps)\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    grid = []\n    for i in range(N):\n        grid.append(list(map(int, stdin.split())))\n    energy = 100\n    graph = []\n    for i in range(N):\n        for j in range(N):\n            graph.append([i, j])\n    ans = 0\n    graph.sort(key=lambda x: x[0])\n    for x, y in graph:\n        ans += 1\n        for dx, dy in [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]:\n            if (0 <= x + dx < N) and (0 <= y + dy < N):\n                if not (x + dx == x and y + dy == y):\n                    energy -= grid[x][y]\n                    energy += grid[x + dx][y + dy]\n                    ans += 1\n                    if energy > K:\n                        return \"IMPOSSIBLE\"\n    return str(ans)\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin_array = stdin.split(\"\\n\")\n    n_of_plants = int(stdin_array[0].split()[0])\n    k_of_jumps = int(stdin_array[0].split()[1])\n    plants = stdin_array[1:]\n    energy_levels = []\n    for plant in plants:\n        x_coord, y_coord, n_of_flies = list(map(int, plant.split()))\n        energy_levels.append([x_coord, y_coord, n_of_flies, 1])\n    answer = 1\n    while True:\n        plants_copy = list(energy_levels)\n        for plant in plants_copy:\n            x_coord, y_coord, n_of_flies, energy_increase = plant\n            if x_coord == y_coord:\n                energy_levels.remove(plant)\n            elif y_coord > x_coord:\n                energy_levels.remove(plant)\n            elif y_coord < x_coord:\n                for j in range(n_of_flies):\n                    energy_levels.remove(plant)\n            else:\n                energy_levels.remove(plant)\n        energy_levels_copy = list(energy_levels)\n        for plant in energy_levels_copy:\n            x_coord, y_coord, n_of_flies, energy_increase = plant\n            energy_increase *= k_of_jumps\n            energy_increase = min(energy_increase, n_of_flies * 100)\n            answer += energy_increase\n        if len(energy_levels_copy) == 0:\n            break\n    return answer\n"
    },
    {
        "number": 3176,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    plants = [[int(i) for i in stdin.split()[j:j + 2]] for j in range(0, n * 2, 2)]\n    plants.sort(key=lambda x: (x[0], x[1]))\n    # print(plants)\n    visited = set()\n    q = deque([(plants[0][0], plants[0][1], 0)])\n    for p in q:\n        visited.add(tuple(p))\n        for i in range(0, k + 1):\n            if (p[0], p[1]) == (plants[p[2]][0], plants[p[2]][1]):\n                q.append((plants[p[2]][0], plants[p[2]][1], p[2] + 1))\n                visited.add((plants[p[2]][0], plants[p[2]][1]))\n                break\n    # print(q)\n    return str(max(p[2] + 1 for p in q))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *perm = map(int, stdin.split())\n    perm = sorted(perm)\n\n    while perm!= list(range(1, n + 1)):\n        for _ in range(m):\n            perm[perm.index(max(perm))], perm[perm.index(min(perm))] = perm[perm.index(min(perm))], perm[perm.index(max(perm))]\n    return str(len(perm) - 1)\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    num_list = list(map(int, stdin.split()))\n    tmp_list = sorted(num_list)\n    # print(tmp_list)\n    # print(min(tmp_list))\n    return str(min(tmp_list))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1]))\n    M = int(stdin.split()[2])\n    swaps = []\n    for i in range(M):\n        swaps.append((int(stdin.split()[3+2*i]), int(stdin.split()[4+2*i])))\n\n    res = 0\n\n    for i in range(len(swaps)):\n        A[swaps[i][0]-1], A[swaps[i][1]-1] = A[swaps[i][1]-1], A[swaps[i][0]-1]\n        res += 1\n    return str(res)\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    seq = list(range(1, N + 1))\n    swaps = []\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        seq[A - 1], seq[B - 1] = seq[B - 1], seq[A - 1]\n        swaps.append((A - 1, B - 1))\n    return str(len(set(swaps)))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    numbers = list(range(1, N+1))\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        numbers[a-1], numbers[b-1] = numbers[b-1], numbers[a-1]\n    return str(len(numbers))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    swaps = []\n    for i in range(m):\n        swaps.append(list(map(int, stdin.split())))\n    arr = sorted(arr)\n    ans = 0\n    for i in range(m):\n        temp = arr.pop(0)\n        arr.append(temp)\n        if arr == arr[::-1]:\n            break\n        ans += 1\n    return str(ans)"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return str(min([swap_scores(x.strip()) for x in stdin.strip().split(\"\\n\")]))\n\ndef"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    scores = list(range(1, n + 1))\n    for _ in range(m):\n        first, second = map(int, stdin.split())\n        sequence[first - 1], sequence[second - 1] = sequence[second - 1], sequence[first - 1]\n    return \" \".join(map(str, sequence))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    perm = list(map(int, stdin.split()))\n\n    swaps = 0\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        if perm[a] > perm[b]:\n            perm[a], perm[b] = perm[b], perm[a]\n            swaps += 1\n    return str(swaps)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3177,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    while len(set(a))!= n:\n        min_dist = min(a)\n        min_idx = a.index(min_dist)\n        for i in range(min_idx, n):\n            if i!= min_idx:\n                a[min_idx], a[i] = a[i], a[min_idx]\n                count += 1\n        a = sorted(a)\n    return count\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adjacency = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        adjacency[a].append(b)\n        adjacency[b].append(a)\n    print(adjacency)\n\n    def cycle_detect(i):\n        seen = {i}\n        stack = [i]\n        while stack:\n            j = stack.pop()\n            for k in adjacency[j]:\n                if k not in seen:\n                    seen.add(k)\n                    stack.append(k)\n        return len(seen) == n\n\n    cycle = False\n    for i in range(n):\n        if cycle_detect(i):\n            cycle = True\n    if cycle:\n        return \"1\"\n    else:\n        return \"2\"\n\nprint(solution(input()))"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    \n    # Leetcode\n    # 19: \uace8\ub77c\uc11c \ud47c \ub2f5\n    # 18: \uc65c\uace1\uc774\uc9c0\n    # 17: \ubc31\ud2b8\ub808\ud0b9\n    # 16: \uc54c\ub78c\uc124\uc815\n    # 15: \uc815\uc6d0\uc548\uc5d0\uc11c \uc22b\uc790\uac00 \uc544\ub2cc \uc22b\uc790\ub97c \ud45c\ud604\ud558\ub294 \ubb38\uc790\uc5f4\n    # 14: \ud68c\uc0ac\uc6a9\ub7c9\uacfc \uc6b4\uc601\ub7c9\uc774 \ubc18\ub300\ub85c \uc788\ub294 \uacbd\uc6b0\n    # 13: \uc0c1\ud558\uc88c\uc6b0\ub85c \uc785\ub825\ub41c \ubb38\uc790\uc5f4\n    # 12: \ud504\ub9b0\ud2b8\ub9cc \uc4f0\uae30\n    # 11: \ub2e4\uc775\uc2a4\ud2b8\ub77c\n    # 10: \ub2e4\uc775\uc2a4\ud2b8\ub77c \n    # 9: \ub2e4\uc775\uc2a4\ud2b8\ub77c \n    # 8: \ub2e4\uc775\uc2a4\ud2b8\ub77c \n    # 7: \uc624\ub2f5\n    # 6: \uc624\ub2f5\n    # 5: \ub2f5\n    # 4: \ub2f5\n    # 3: \ub2f5\n    # 2: \ub2f5\n    # 1: \ub2f5\n    # 0: \ub2f5\n    # 1: \ub2f5\n    # 2: \ub2f5\n    # 3: \ub2f5\n    # 4: \ub2f5\n    # 5: \ub2f5\n    # 6: \ub2f5\n    # 7: \ub2f5\n    # 8: \ub2f5\n    # 9: \ub2f5\n    # 10: \ub2f5\n    # 11: \ub2f5\n    # 12: \ub2f5\n    # 13: \ub2f5\n    # 14: \ub2f5\n    # 15: \ub2f5\n    # 16: \ub2f5\n    # 17: \ub2f5\n    # 18: \ub2f5\n    # 19: \ub2f5\n    # 20: \ub2f5\n    # 21: \ub2f5\n    # 22: \ub2f5\n    # 23: \ub2f5\n    # 24: \ub2f5\n    # 25: \ub2f5\n    # 26: \ub2f5\n    # 27: \ub2f5\n    # 28: \ub2f5\n    # 29: \ub2f5\n    # 30: \ub2f5\n    # 31: \ub2f5\n    # 32: \ub2f5\n    # 33: \ub2f5\n    # 34: \ub2f5\n    # 35: \ub2f5\n    # 36: \ub2f5\n    # 37: \ub2f5\n    # 38: \ub2f5\n    # 39: \ub2f5\n    # 40: \ub2f5\n    # 41: \ub2f5\n    # 42: \ub2f5\n    # 43: \ub2f5\n    # 44: \ub2f5\n    # 45: \ub2f5\n    # 46: \ub2f5\n    # 47: \ub2f5\n    # 48: \ub2f5\n    # 49: \ub2f5\n    # 50: \ub2f5\n    # 51: \ub2f5\n    # 52: \ub2f5\n    # 53: \ub2f5\n    # 54: \ub2f5\n    # 55: \ub2f5\n    # 56: \ub2f5\n    # 57: \ub2f5\n    # 58: \ub2f5\n    # 59: \ub2f5\n    # 60: \ub2f5\n    # 61: \ub2f5\n    # 62: \ub2f5\n    # 63: \ub2f5\n    # 64: \ub2f5\n    # 65: \ub2f5\n    # 66: \ub2f5\n    # 67: \ub2f5\n    # 68: \ub2f5\n    # 69: \ub2f5\n    # 70: \ub2f5\n    # 71: \ub2f5\n    # 72: \ub2f5\n    # 73: \ub2f5\n    # 74: \ub2f5\n    # 75: \ub2f5\n    # 76: \ub2f5\n    # 77: \ub2f5\n    # 78: \ub2f5\n    # 79: \ub2f5\n    # 80: \ub2f5\n    # 81: \ub2f5\n    # 82: \ub2f5\n    # 83: \ub2f5\n    # 84: \ub2f5\n    # 85: \ub2f5\n    # 86: \ub2f5\n    # 87: \ub2f5\n    # 88: \ub2f5\n    # 89: \ub2f5\n    # 90: \ub2f5\n    # 91: \ub2f5\n    # 92: \ub2f5\n    # 93: \ub2f5\n    # 94: \ub2f5\n    # 95: \ub2f5\n    # 96: \ub2f5\n    # 97: \ub2f5\n    # 98: \ub2f5\n    # 99: \ub2f5\n    # 100: \ub2f5\n    # 101: \ub2f5\n    # 102: \ub2f5\n    # 103: \ub2f5\n    # 104: \ub2f5\n    # 105: \ub2f5\n    # 106: \ub2f5\n    # 107: \ub2f5\n    # 108: \ub2f5\n    # 109: \ub2f5\n    # 110: \ub2f5\n    # 111: \ub2f5\n    # 112: \ub2f5\n    # 113: \ub2f5\n    # 114: \ub2f5\n    # 115: \ub2f5\n    # 116: \ub2f5\n    # 117: \ub2f5\n    # 118: \ub2f5\n    # 119: \ub2f5\n    # 120: \ub2f5\n    # 121: \ub2f5\n    # 122: \ub2f5\n    # 123: \ub2f5\n    # 124: \ub2f5\n    # 125: \ub2f5\n    # 126: \ub2f5\n    # 127: \ub2f5\n    # 128: \ub2f5\n    # 129: \ub2f5\n    # 130: \ub2f5\n    # 131: \ub2f5\n    # 132: \ub2f5\n    # 133: \ub2f5\n    # 134: \ub2f5\n    # 135: \ub2f5\n    # 136: \ub2f5\n    # 137: \ub2f5\n    # 138: \ub2f5\n    # 139: \ub2f5\n    # 140: \ub2f5\n    "
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    areas = list(map(int, stdin.split()))\n    costs = defaultdict(list)\n    cost = 0\n    for i in range(n-1):\n        a = areas[i]\n        b = areas[i+1]\n        cost += abs(a-b) % 3\n        costs[a].append(b)\n        costs[b].append(a)\n    cycle = []\n    for i in range(m):\n        cost += abs(areas[i] - areas[i+1]) % 3\n        cycle.append(areas[i])\n        if len(cycle) >= 2:\n            if cycle[0]!= cycle[-1]:\n                cost += abs(cycle[0] - cycle[-1]) % 3\n            cycle = cycle[1:]\n    return str(cost)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        adj[a].append(b)\n        adj[b].append(a)\n    visited = set()\n    cost = {}\n    q = deque([(1, 0)])\n    while q:\n        cur, c = q.popleft()\n        if cur in visited: continue\n        visited.add(cur)\n        cost[cur] = c\n        for nxt in adj[cur]:\n            if nxt in visited: continue\n            q.append((nxt, c+1))\n    if len(visited)!= n: return '-1'\n    ans = float('inf')\n    for p in range(2, n+1):\n        if p not in visited:\n            continue\n        for nxt in adj[p]:\n            if nxt in visited: continue\n            if cost[p]+cost[nxt] == (p+nxt)%3:\n                ans = min(ans, cost[p]+cost[nxt])\n    if ans == float('inf'):\n        return '-1'\n    return str(ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 4\n   ... 4 5\n   ... 1 5\n   ... 1 2\n   ... 1 3\n   ... 2 3\n   ... 3 5\n   ... 2 5\n   ... ''')\n    '5'\n    >>> solution('''\n   ... 5 6\n   ... 3 5\n   ... 4 5\n   ... 2 5\n   ... 3 6\n   ... 1 6\n   ... Sample Output 2:\n    '-1'\n    \"\"\"\n    def parse(line):\n        inp = line.split()\n        return int(inp[0]), int(inp[1])\n\n    areas, roads = map(parse, stdin.splitlines())\n    # print(areas, roads)\n\n    def tour(areas, roads):\n        # A tour is a cycle, which has at most three items. A cycle must be connected to at least one item.\n        tours = [[] for _ in range(areas)]\n        visited = set()\n        cycles = []\n        for road in roads:\n            tours[road[0] - 1] += road[1]\n            tours[road[1] - 1] += road[0]\n            visited.add(road[0])\n            visited.add(road[1])\n\n        # print(tours)\n        for k in range(areas):\n            if k not in visited:\n                cycles.append(k)\n\n        # print(cycles)\n        for k in cycles:\n            for i in tours[k]:\n                if i in visited:\n                    return False\n        return True\n\n    tours = []\n    # print(tours)\n    for _ in range(areas):\n        tours.append(set())\n    for i in range(areas):\n        tours[i].add(i)\n    for i in range(areas):\n        for j in range(i + 1, areas):\n            if tours[i].intersection(tours[j]):\n                tours[i].remove(j)\n                tours[j].remove(i)\n                continue\n    print(tours)\n    if tour(areas, roads):\n        tours = set(tours)\n        print(tours)\n        min_cost = min([len(i) for i in tours])\n        return min_cost\n    return '-1'\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    input:\n    6 5\n    2 4\n    3 5\n    1 5\n    3 6\n    1 6\n\n    output:\n    5\n    '''\n    lines = stdin.split()\n\n    n = int(lines[0])\n    m = int(lines[1])\n\n    # Write your code here.\n    # do some pre-processing\n    # for each area, see if there is a path to all the other areas\n    # if yes, return the amount of money in the least amount of steps\n    # else, return -1\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # find pair\n    a = b = None\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == j:\n                continue\n            if a is not None and b is not None:\n                break\n            if a is None:\n                if m % 3!= 0:\n                    a = i\n                elif i % 2 == 0:\n                    a = i\n            if b is None:\n                if m % 3!= 0:\n                    b = j\n                elif j % 2 == 0:\n                    b = j\n            if a is not None and b is not None:\n                break\n    return a, b\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n\n    n_to_m = dict()\n    for i in range(m):\n        a, b = stdin.split()\n        a = int(a)\n        b = int(b)\n        n_to_m[a] = b\n\n    min_cost = float('inf')\n\n    for i in range(n):\n        cost = 0\n        for j in range(i+1, n):\n            if i in n_to_m and j in n_to_m and n_to_m[i] + n_to_m[j] < 2:\n                cost += 1\n        if cost < min_cost:\n            min_cost = cost\n\n    return str(min_cost) if min_cost!= float('inf') else '-1'\n"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    if n < 2 or m < 2:\n        return -1\n\n    costs = []\n    for i in range(1, n + 1):\n        costs.append(list(map(int, stdin.split())))\n\n    min_cost = float('inf')\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if costs[i][0] + costs[j][1] == costs[i][1] + costs[j][0]:\n                min_cost = min(min_cost, costs[i][0] + costs[j][1])\n\n    if min_cost == float('inf'):\n        return -1\n    return str(min_cost)"
    },
    {
        "number": 3178,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    areas = {}\n    for i in range(n):\n        areas[i + 1] = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:4])\n        areas[a].add(b)\n        areas[b].add(a)\n    visited = set()\n    visited.add(1)\n    to_visit = deque([1])\n    cost = 0\n    while to_visit:\n        curr = to_visit.popleft()\n        visited.add(curr)\n        if curr % 2 == 0:\n            for i in areas[curr]:\n                if i not in visited:\n                    if i - curr in areas:\n                        if i - curr not in visited:\n                            if i - curr!= 1:\n                                cost += max(0, abs(i - curr - 2))\n                    else:\n                        cost += max(0, abs(i - curr - 2))\n                    to_visit.append(i)\n        else:\n            for i in areas[curr]:\n                if i not in visited:\n                    if i - curr in areas:\n                        if i - curr not in visited:\n                            if i - curr!= 1:\n                                cost += max(0, abs(i - curr - 2))\n                    else:\n                        cost += max(0, abs(i - curr - 2))\n                    to_visit.append(i)\n    if n % 2 == 0:\n        if 2 * n - 1 in areas:\n            if 2 * n - 1 not in visited:\n                if n - 1 in areas:\n                    if n - 1 not in visited:\n                        cost += max(0, abs(2 * n - 1 - 2))\n                else:\n                    cost += max(0, abs(2 * n - 1 - 2))\n    return str(cost)\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Brute force solution\n    \"\"\"\n    # num_points, num_squares = map(int, stdin.split())\n    # squares = []\n    # for _ in range(num_squares):\n    #     square = []\n    #     for _ in range(3):\n    #         x, y = map(int, stdin.split())\n    #         square.append((x, y))\n    #     squares.append(square)\n    # results = []\n    # for _ in range(1, num_points + 1):\n    #     results.append(min_distance(squares, _))\n    # return''.join(str(result) for result in results)\n\n    num_points, num_squares = map(int, stdin.split())\n    points = []\n    for _ in range(num_points):\n        points.append(tuple(map(int, stdin.split())))\n    squares = []\n    for _ in range(num_squares):\n        square = []\n        for _ in range(3):\n            square.append(tuple(map(int, stdin.split())))\n        squares.append(square)\n    return str(min_distance(squares, points))\n\n\ndef"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    polygon = list(map(int, stdin.strip().split()))\n    min_side = 100000\n    for i in range(n - 2):\n        a, b = polygon[i], polygon[i + 1]\n        c, d = polygon[i + 2], polygon[i + 3]\n        a1, b1 = max(a, c), min(a, c)\n        a2, b2 = max(b, d), min(b, d)\n        s = (b1 - a1) * (b2 - a2)\n        if s < min_side:\n            min_side = s\n    return f\"{min_side:.2f}\""
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    points = [(int(x), int(y)) for x, y in [l.split() for l in stdin.strip().split('\\n')]]\n\n    # If we had a line like (1, 1) and (3, 4), then we could flip the points around.\n    points = sorted(points)\n    # Add a point at the ends to make sure we don't collide.\n    points = [points[0]] + points + [points[-1]]\n    # Sort the points by X.\n    points = sorted(points, key=lambda p: p[0])\n\n    # There are no collinear points. So we can do a quick test.\n    if points[0] == points[1]:\n        # There is only one collinear point. So we can just flip the order.\n        points = points[::-1]\n        # Add a point at the ends to make sure we don't collide.\n        points = points + [points[-1]]\n\n    min_side = float(\"inf\")\n    # Compare each point to its next point to build a line.\n    for i in range(1, len(points)):\n        min_side = min(min_side,\n                       ((points[i][0] - points[i - 1][0]) ** 2 +\n                        (points[i][1] - points[i - 1][1]) ** 2) ** 0.5)\n    return str(min_side)\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    side, num_maps = map(int, stdin.strip().split())\n    polygon_coords = [list(map(int, stdin.strip().split())) for _ in range(side)]\n    min_side = 1e10\n    for side in range(2, side+1):\n        num_overlaps = 0\n        for _ in range(num_maps):\n            overlaps = {}\n            max_x = -1\n            max_y = -1\n            min_x = 1e10\n            min_y = 1e10\n            for x, y in polygon_coords:\n                if x+side > max_x:\n                    max_x = x+side\n                if x+side < min_x:\n                    min_x = x+side\n                if y+side > max_y:\n                    max_y = y+side\n                if y+side < min_y:\n                    min_y = y+side\n                if (x, y) not in overlaps:\n                    overlaps[x, y] = 1\n                else:\n                    num_overlaps += 1\n            if num_overlaps > 1:\n                break\n            if min_x > min_y:\n                min_y = min_x\n            elif min_x < min_y:\n                min_x = min_y\n            if side not in overlaps:\n                break\n        min_side = min(min_side, max_x-min_x+1, max_y-min_y+1)\n    return str(min_side)\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(i) for i in stdin.split())\n    return '%.2f' % min(min(t) for t in (\n        (tuple(int(j) for j in i.split(' ')), i) for i in (\n            (stdin.splitlines())[i] for i in range(n)))[1])\n    return min(min(t) for t in (\n        (tuple(int(j) for j in i.split(' ')), i) for i in (\n            (stdin.splitlines())[i] for i in range(n)))[1])\n    return ('%.2f' % min(min(t) for t in (\n        (tuple(int(j) for j in i.split(' ')), i) for i in (\n            (stdin.splitlines())[i] for i in range(n)))[1])\n    return min(min(t) for t in (\n        (tuple(int(j) for j in i.split(' ')), i) for i in (\n            (stdin.splitlines())[i] for i in range(n)))[1])\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.strip().split())\n    polygon = [(i, j) for i in range(x + 1) for j in range(y + 1)]\n    ans = 0.00\n    while polygon:\n        if len(polygon) >= 2:\n            a, b = polygon[0], polygon[1]\n            min_side = min(abs(a[0] - b[0]), abs(a[1] - b[1]))\n            for x, y in polygon:\n                if min_side > max(abs(x - a[0]), abs(y - a[1])):\n                    min_side = max(abs(x - a[0]), abs(y - a[1]))\n        else:\n            min_side = abs(polygon[0][0] - polygon[0][1])\n        ans = max(ans, min_side)\n        polygon = [x for x in polygon if x!= min(polygon)]\n    return \"%.2f\" % ans\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the test suite\n    :param stdin: input\n    :return: stdout\n    \"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    vertices = []\n    for _ in range(n):\n        x, y = [int(x) for x in stdin.split()]\n        vertices.append((x, y))\n    min_side = float('inf')\n    for i in range(1, n):\n        for j in range(i):\n            a, b = vertices[i]\n            c, d = vertices[j]\n            ab = np.array((a, b))\n            cd = np.array((c, d))\n            length = length_of_segment(ab, cd)\n            min_side = min(min_side, length)\n    for j in range(i):\n        a, b = vertices[i]\n        c, d = vertices[j]\n        ab = np.array((a, b))\n        cd = np.array((c, d))\n        length = length_of_segment(ab, cd)\n        min_side = min(min_side, length)\n    for i in range(k):\n        a, b = vertices[i]\n        c, d = vertices[k - i]\n        ab = np.array((a, b))\n        cd = np.array((c, d))\n        length = length_of_segment(ab, cd)\n        min_side = min(min_side, length)\n    return f\"{min_side:.2f}\"\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    verts = sorted([tuple(map(float, input().split())) for _ in range(n)])\n\n    def minSide(verts: List[Tuple[float, float]]) -> float:\n        if len(verts) == 2:\n            return min(verts[0][0], verts[1][0], verts[0][1], verts[1][1])\n        elif len(verts) == 3:\n            return min(min(verts[0][0], verts[1][0], verts[2][0]), min(verts[0][1], verts[1][1], verts[2][1]))\n        else:\n            raise ValueError(f\"len(verts) == {len(verts)}\")\n\n    def test(verts: List[Tuple[float, float]], verts2: List[Tuple[float, float]]) -> float:\n        if len(verts) == 2:\n            return min(verts[0][0], verts[1][0], verts[0][1], verts[1][1])\n        elif len(verts) == 3:\n            return min(min(verts[0][0], verts[1][0], verts[2][0]), min(verts[0][1], verts[1][1], verts[2][1]))\n        else:\n            raise ValueError(f\"len(verts) == {len(verts)}\")\n\n    # split and merge\n    all_verts = []\n    for i in range(n):\n        if i == 0:\n            all_verts.append(verts[0])\n            all_verts.append(verts[1])\n        elif i == n - 1:\n            all_verts.append(verts[i])\n            all_verts.append(verts[i - 1])\n        else:\n            all_verts.append(verts[i])\n            all_verts.append(verts[i - 1])\n    m_verts = []\n    for i in range(0, len(all_verts), 2):\n        m_verts.append(all_verts[i])\n        m_verts.append(all_verts[i + 1])\n    m_verts.append(all_verts[0])\n    m_verts.append(all_verts[-1])\n    s = minSide(m_verts)\n    for i in range(1, k):\n        m_verts.append(verts2[i - 1])\n        m_verts.append(verts2[i])\n        s = min(s, test(m_verts, verts2))\n    return f\"{s:.2f}\"\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin = \"\"\"4 1\n    1 1\n    5 1\n    5 5\n    4 2\n    \"\"\"\n\n    # my code here\n    pass\n"
    },
    {
        "number": 3179,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    coords = []\n    for i in range(n):\n        x, y = map(float, stdin.strip().split())\n        coords.append((x, y))\n\n    def is_simple(coords):\n        n = len(coords)\n        if n == 2:\n            return True\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if coords[i][0] * coords[j][1] == coords[j][0] * coords[i][1]:\n                    return False\n\n        return True\n\n    def check_intersection(coords):\n        n = len(coords)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if coords[i][0] == coords[j][0] or coords[i][1] == coords[j][1]:\n                    return False\n\n        return True\n\n    def get_triangulation(coords):\n        n = len(coords)\n        triangulation = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if coords[i][0] == coords[j][0]:\n                    if coords[i][1] < coords[j][1]:\n                        if not i in triangulation:\n                            triangulation.append(i)\n                    else:\n                        if not j in triangulation:\n                            triangulation.append(j)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if coords[i][1] == coords[j][1]:\n                    if coords[i][0] < coords[j][0]:\n                        if not i in triangulation:\n                            triangulation.append(i)\n                    else:\n                        if not j in triangulation:\n                            triangulation.append(j)\n\n        return triangulation\n\n    coords = sorted(coords, key=lambda x: x[1])\n    if not is_simple(coords):\n        return 'impossible'\n\n    for i in range(k):\n        triangulation = get_triangulation(coords)\n        for t in triangulation:\n            if not coords[t][0] == coords[t + 1][0]:\n                return 'impossible'\n\n    largest_side = 0\n    for i in range(k):\n        largest_side = max(largest_side, abs(coords[i][0] - coords[i + 1][0]) + abs(coords[i][1] - coords[i + 1][1]))\n\n    return str(largest_side)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    log = stdin.splitlines()\n    num_rows = int(log[0])\n    num_cols = int(log[1])\n    num_colours = int(log[2])\n    rows = [[0 for _ in range(num_cols)] for _ in range(num_rows)]\n    log.pop(0)\n    for row in log:\n        x = int(row.split()[0])\n        y = int(row.split()[1])\n        a = int(row.split()[2])\n        b = int(row.split()[3])\n        for i in range(x, y + 1):\n            rows[x - 1][i - 1] = a\n            rows[y - 1][i - 1] = b\n    for row in rows:\n        print(*row)\n    return''.join(str(e) for e in rows)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    log = stdin.splitlines()\n    log_save = []\n    log_load = []\n\n    for _ in range(M):\n        log_save.append(stdin.split())\n        log_load.append(stdin.split())\n        log_save.append(stdin.split())\n\n    canvas = [[0]*N for _ in range(N)]\n    c = 1\n    for _ in range(N):\n        for j in range(N):\n            canvas[0][j] = c\n        c += 1\n\n    for line in log:\n        if line == \"SAVE\":\n            c = 1\n            for j in range(N):\n                canvas[0][j] = c\n                c += 1\n        else:\n            cmd, x, y = line.split()\n            x = int(x)\n            y = int(y)\n            c = canvas[y][x]\n            canvas[y][x] = int(cmd)\n\n    return \"\".join([\"\".join(line) for line in canvas])\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N, K, M = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    colours = [[0 for _ in range(N)] for _ in range(N)]\n    save = []\n    for i in range(M):\n        save.append(stdin[i + 3].split())\n    for i in save:\n        if i[0] == 'PAINT':\n            x, y, x1, y1 = int(i[1]), int(i[2]), int(i[3]), int(i[4])\n            for j in range(x, x1):\n                for k in range(y, y1):\n                    if colours[j][k]!= 0:\n                        colours[j][k] = i[1]\n                    else:\n                        colours[j][k] = i[1]\n        elif i[0] == 'SAVE':\n            x, y = int(i[1]), int(i[2])\n            save[x][y] = colours[x][y]\n        elif i[0] == 'LOAD':\n            x, y = int(i[1]), int(i[2])\n            save[x][y] = colours[x][y]\n            colours[x][y] = 0\n    for i in range(N):\n        for j in range(N):\n            print(colours[i][j], end=' ')\n        print()\n    return ''.join(str(a) for a in colours[0])\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.strip().split())\n    if M == 0:\n        print(*[N for _ in range(N)])\n        return\n\n    lst = [1]*K\n    d = {1: 0}\n    for _ in range(M):\n        n = int(stdin.split()[2])\n        d[n] = n\n        lst[d[1]] = 0\n        for i in range(2, K):\n            lst[i] = lst[i-1]+lst[i-2]\n    print(*lst)\n    return\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def load(line):\n        x, y = [int(n) for n in line.split()]\n        print(x, y)\n        global C\n        C[x][y] = int(input())\n\n    def save():\n        for x in range(N):\n            print(*C[x])\n\n    def paint(line):\n        p, x1, y1, x2, y2 = [int(n) for n in line.split()]\n        for x in range(x1, x2+1):\n            for y in range(y1, y2+1):\n                C[x][y] = p\n\n    def load_save():\n        for line in stdin.split('\\n'):\n            line = line.rstrip()\n            if line == 'LOAD':\n                save()\n            elif line == 'SAVE':\n                save()\n            else:\n                load(line)\n    global N, K\n    N, K = map(int, input().split())\n    global C\n    C = [[1 for i in range(N)] for j in range(N)]\n    load_save()\n    return '\\n'.join([''.join([str(c) for c in row]) for row in C])\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    log = [line.split() for line in stdin.strip().split('\\n')][1:]\n    log = [[int(i) for i in line] for line in log]\n    ans = ''\n    for i in range(N):\n        d = {}\n        for j in range(N):\n            if (i, j) not in d:\n                d[(i, j)] = 1\n            else:\n                d[(i, j)] += 1\n        ans += str(max(d.values())) +''\n    return ans + '\\n' + str(log) + '\\n'\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    painting = [[1 for _ in range(N)] for _ in range(N)]\n    saved_commands = []\n\n    for _ in range(M):\n        command = stdin.split()\n        if command[0] == 'PAINT':\n            painting[int(command[1])][int(command[2])] = int(command[3])\n        elif command[0] == 'SAVE':\n            saved_commands.append(command[1])\n        elif command[0] == 'LOAD':\n            saved_commands.append(command[1])\n            break\n\n    for saved_command in saved_commands:\n        if saved_command.isnumeric():\n            index = int(saved_command) - 1\n            painting[index] = [painting[index][i] for i in range(N)]\n        else:\n            painting[int(saved_command) - 1] = painting[int(saved_command) - 1]\n    for row in painting:\n        print(*row)\n    return ''.join(map(str, painting))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    grid = [[1] * n for _ in range(n)]\n    for _ in range(m):\n        command = stdin.split()\n        if command[0] == 'SAVE':\n            grid[int(command[1])][int(command[2])] = int(command[3])\n        elif command[0] == 'LOAD':\n            grid[int(command[1])][int(command[2])] = int(command[3])\n    for row in grid:\n        print(*row)\n\n    return \"\"\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.strip()\n    stdin = stdin.split(\"\\n\")\n    canvas = [[] for _ in range(len(stdin))]\n    for i in range(len(stdin)):\n        canvas[i] = list(map(int, stdin[i].split(\" \")))\n    colours = set([1, 2, 3, 4, 5])\n    for i in range(len(canvas)):\n        for j in range(len(canvas[i])):\n            colours = colours.intersection(set(canvas[i][j]))\n    return \" \".join(list(map(str, sorted(colours))))\n"
    },
    {
        "number": 3180,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    row = []\n    for i in range(len(lines)):\n        if lines[i].startswith('PAINT'):\n            c = int(lines[i][len('PAINT'):])\n            row.append(c)\n        elif lines[i].startswith('SAVE'):\n            break\n        elif lines[i].startswith('LOAD'):\n            c = int(lines[i][len('LOAD'):])\n            row = []\n    return '\\n'.join(str(i) for i in row)\n"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    if N - K <= 0: return -1\n    seq = [i for i in range(1, N + 1)]\n    last_mono_seq = []\n    while len(seq) > 0:\n        # If only one number remains, we have our answer\n        if len(seq) == 1:\n            last_mono_seq.append(seq.pop(0))\n            break\n        # The next number is the first number in the current monotone subsequence\n        cur_number = seq.pop(0)\n        # Remove the first number in the current monotone subsequence\n        if cur_number == last_mono_seq[-1]:\n            last_mono_seq.pop(-1)\n        # Otherwise, add the current number to the current monotone subsequence\n        else:\n            last_mono_seq.append(cur_number)\n    # Check if the required subsequence is possible\n    if len(last_mono_seq) == K:\n        return''.join([str(i) for i in last_mono_seq])\n    else:\n        return '-1'\n"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5 1\n   ... 1 2 3 4 5\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 4 3 2 1 5\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n   ... 5 4 3 2 1\n    "
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = \"-\"\n    if n <= 0:\n        return sequence\n    sequence = \" \".join([str(i) for i in range(1, n + 1)])\n    while True:\n        left_value = sequence.index(\" \")\n        if left_value == 0 or left_value == len(sequence) - 1:\n            break\n        if left_value - 1 > k:\n            sequence = sequence[:left_value - 1] + \" \" + sequence[left_value:]\n        else:\n            sequence = sequence[:left_value - 1] + \" \" + sequence[left_value:] + \" \" + sequence[left_value + 1:]\n    return sequence\n"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [-1] * (n + 1)\n    sequence[0] = -1\n    start, end = 1, n\n    while start <= end:\n        mid = start + (end - start) // 2\n        if sequence[mid] < mid - 1:\n            start = mid + 1\n        else:\n            end = mid - 1\n    if start == n + 1:\n        return \"-1\"\n    sequence[start] = start - 1\n    sequence[start + 1] = start\n    start, end = start + 2, n\n    while start <= end:\n        mid = start + (end - start) // 2\n        if sequence[mid] > mid + k:\n            end = mid\n        else:\n            start = mid + 1\n        sequence[start] = mid\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    s = ''.join(str(i) for i in range(1, n+1))\n    if s[0] == '0':\n        return '-1'\n    st = []\n    st.append((s, st, 0))\n    while len(st)!= 0:\n        s, st, ans = st[0]\n        if len(st) == k:\n            return s\n        if len(st) < k:\n            poss_arr = [int(s[0]), int(s[-1])]\n            poss_arr.sort()\n            if len(s) > 1:\n                for i in range(1, len(s) - 1):\n                    if int(s[i]) <= int(s[i + 1]) and int(s[i - 1]) >= int(s[i]):\n                        poss_arr.append(int(s[i]))\n            if len(poss_arr)!= 0:\n                st.append((s[poss_arr[-1]:], st, ans + 1))\n                st.append((s[:poss_arr[-1]], st, ans + 1))\n            else:\n                st.pop(0)\n    return '-1'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < 2 or k < 1:\n        return -1\n    dp = [[0] * k for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][0] = 1\n    for j in range(1, k):\n        dp[0][j] = j\n    for i in range(1, n):\n        for j in range(1, k):\n            dp[i][j] = max(dp[i][j - 1], 1) + max(dp[i - 1][j], 1)\n    res = []\n    for r in dp:\n        res.append(' '.join(map(str, r)))\n    return '\\n'.join(res)"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return \"-1\"\n    num = list(range(1, N + 1))\n    print(num)\n    for i in range(1, N):\n        j = 1\n        while j < i and j <= K:\n            if num[i - j] > num[i]:\n                num[i], num[i - j] = num[i - j], num[i]\n                break\n            j += 1\n    print(num)\n    return \" \".join([str(i) for i in num])"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.strip().split()))\n    if n < 1 or k < 1 or n > 1000000 or k > 1000000:\n        return -1\n\n    seq = [[] for _ in range(n)]\n    for i in range(n):\n        seq[i] = list(map(int, stdin.strip().split()))\n\n    seq.sort()\n    max_len = 0\n    result = []\n    for i in range(n):\n        seq_len = 0\n        cur = seq[i]\n        for j in range(n):\n            if cur == seq[j]:\n                seq_len += 1\n                cur = seq[j]\n            else:\n                if seq_len > max_len:\n                    max_len = seq_len\n                seq_len = 0\n                break\n        if seq_len > max_len:\n            max_len = seq_len\n        result.append(str(cur))\n    return \" \".join(result)"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if N == K:\n        return \" \".join(list(range(1, N+1)))\n    else:\n        return \" \".join([\"-1\"])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3181,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return -1\n\n    longest_monotone_subsequence = []\n    longest_monotone_subsequence_length = 0\n    for i in range(1, n):\n        monotone_subsequence = []\n        for j in range(i, 0, -1):\n            if longest_monotone_subsequence_length >= k:\n                break\n\n            if j == 1:\n                monotone_subsequence.append(j)\n                longest_monotone_subsequence_length = len(monotone_subsequence)\n            else:\n                monotone_subsequence.append(monotone_subsequence[-1])\n                if len(monotone_subsequence) > longest_monotone_subsequence_length:\n                    longest_monotone_subsequence_length = len(monotone_subsequence)\n        longest_monotone_subsequence.append(i)\n        if longest_monotone_subsequence_length >= k:\n            break\n\n    return''.join([str(i) for i in longest_monotone_subsequence]) if longest_monotone_subsequence_length >= k else -1\n"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    # points.append((int(stdin.split()[0]), int(stdin.split()[1])))\n    for i in stdin.splitlines():\n        points.append((int(i.split()[0]), int(i.split()[1])))\n    # print(points)\n    return count_right_angles(points)\n\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(count(stdin))\n\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the program on given input and returns the output.\n    \"\"\"\n    N = int(stdin.strip())\n    ans = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if (abs(k - i) + abs(k - j) + abs(k - j)) == abs(i - j):\n                    ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def solve() -> int:\n        a, b = map(int, input().split())\n        c, d = map(int, input().split())\n        e, f = map(int, input().split())\n        n = float((b - a) * (d - c) * (f - e)) / (2 * (c - a) * (d - e) * (f - c))\n        return int(n)\n    return str(solve())\n"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.splitlines()[0])\n    a: List[List[int]] = [list(map(int, stdin.splitlines()[i + 1].split())) for i in range(n)]\n    return str(count_right_triangles(a))\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    for _ in range(int(input())):\n        [A,B,C] = map(int,input().split())\n        if A*C >= B**2 and A**2 + B**2 == C**2:\n            print(1)\n        else:\n            print(0)"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return '0'\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n    triangles = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if points[i][0] * points[j][0] + points[j][1] * points[k][1] == points[i][1] * points[k][1]:\n                    triangles += 1\n    return str(triangles)\n"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = [tuple(map(int, stdin.split())) for _ in range(n)]\n    return str(len(count_right_triangles(points)))\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1].split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if abs(points[i][1] - points[j][1]) <= 1 and abs(points[i][0] - points[k][0]) <= 1 and abs(points[j][0] - points[k][0]) <= 1:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 3182,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n    points = []\n    \n    def calc_boundaries(points: List[Tuple[int, int]]) -> None:\n        for i in range(len(points)):\n            x_min = min(x_min, points[i][0])\n            x_max = max(x_max, points[i][0])\n            y_min = min(y_min, points[i][1])\n            y_max = max(y_max, points[i][1])\n    \n    def calculate(points: List[Tuple[int, int]]) -> int:\n        if len(points) == 2:\n            x = points[0][0]\n            y = points[0][1]\n            z = points[1][0]\n            w = points[1][1]\n            if x == z or y == w:\n                return 0\n            else:\n                return 1\n    \n        res = 0\n        for i in range(len(points)):\n            for j in range(len(points)):\n                if i!= j:\n                    p = (points[i][0] + points[j][0]) / 2.0\n                    q = (points[i][1] + points[j][1]) / 2.0\n                    points[i][0] = p\n                    points[i][1] = q\n                    res += calculate(points)\n                    points[i][0] = x_min\n                    points[i][1] = y_min\n        return res\n    \n    calc_boundaries(points)\n    return str(calculate(points))"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    [n, m, s, t] = stdin.split()\n    n = int(n)\n    m = int(m)\n    s = int(s)\n    t = int(t)\n    nodes = [[] for i in range(n)]\n    edges = [[] for i in range(n)]\n    for i in range(m):\n        u, v, c, w = stdin.split()\n        u = int(u)\n        v = int(v)\n        c = int(c)\n        w = int(w)\n        nodes[u].append((v, c, w))\n        nodes[v].append((u, c, w))\n        edges[u].append((v, c, w))\n        edges[v].append((u, c, w))\n    print(nodes)\n    print(edges)\n    flow = [[0 for j in range(n)] for i in range(n)]\n    cost = [[0 for j in range(n)] for i in range(n)]\n    visited = [False for j in range(n)]\n    que = deque()\n    que.append((s, 0))\n    while que:\n        cur, curcost = que.popleft()\n        visited[cur] = True\n        for node in edges[cur]:\n            nextnode, nextcost, nextw = node\n            if (visited[nextnode] == False):\n                cost[cur][nextnode] = cost[cur][nextnode] + nextcost\n                if (flow[cur][nextnode] + nextw < cost[nextnode][t]):\n                    flow[cur][nextnode] = flow[cur][nextnode] + nextw\n                    que.append((nextnode, cost[cur][nextnode]))\n    return str(cost[s][t]) + \" \" + str(flow[s][t])\nprint(solution(input()))\n\"\"\"\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, capacity, costs = stdin.split()\n    n, m, s, t, capacity, costs = int(n), int(m), int(s), int(t), int(capacity), [(int(u) - 1, int(v) - 1, int(c) - 1, int(w) - 1) for u, v, c, w in map(lambda x: x.split(), list(stdin.splitlines()))]\n    graph = [[] for _ in range(n)]\n    cost = [[float(\"inf\")] * n for _ in range(n)]\n    for u, v, c, w in costs:\n        graph[u].append((v, c, w))\n        cost[u][v] = min(cost[u][v], c + w)\n        cost[v][u] = min(cost[v][u], c + w)\n    if is_connected(graph, cost, n):\n        flow = 0\n        while True:\n            F, prev = bfs(graph, cost, s, t, flow)\n            if F == 0:\n                break\n            flow = F\n            cost = update_flow(graph, cost, F, prev)\n    return str(flow)\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    edges = defaultdict(dict)\n    flow = defaultdict(int)\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split())\n        edges[u][v] = (c, w)\n        edges[v][u] = (-c, -w)\n    \n    f = 0\n    while True:\n        flow_acc = defaultdict(int)\n        for node in range(n):\n            if flow[node] == 0:\n                continue\n            for adj in edges[node]:\n                flow_acc[adj] += edges[node][adj][0]\n                if flow_acc[adj] > flow[adj]:\n                    flow[adj] = flow_acc[adj]\n        if f == sum(flow.values()):\n            break\n        f = sum(flow.values())\n    return str(max(flow[s], t)) +'' + str(min(flow[s], t))\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    https://www.hackerrank.com/challenges/minimum-cost-tree/problem\n    \"\"\"\n    from collections import defaultdict\n    n, m, s, t = stdin.split()\n    n = int(n)\n    m = int(m)\n    s = int(s)\n    t = int(t)\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v, c, w = map(int, input().split())\n        graph[u].append([v, c, w])\n    flow = defaultdict(list)\n    flow[s].append([t, 1, 0])\n    while len(flow[s]) > 0:\n        u, c, w = flow[s].pop()\n        if len(graph[u]) == 0:\n            continue\n        else:\n            for v, c_v, w_v in graph[u]:\n                if c_v + c <= w:\n                    flow[v].append([u, c_v + c, w_v + w])\n    res = 0\n    for v, c, w in flow[t]:\n        if c > res:\n            res = c\n    return res\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, *edge = list(map(int, stdin.split()))\n    parents = [-1] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n    for u, v, c, w in edge:\n        graph[u].append((v, c, w))\n    res = 0\n    while True:\n        totflow = 0\n        for u, v, c, w in graph:\n            if parents[u]!= -1 and parents[u]!= t:\n                totflow += c\n        if totflow == 0:\n            break\n        for u, v, c, w in graph:\n            if parents[u] == -1 and v!= t:\n                parents[v] = u\n                totflow -= c\n        res = max(res, totflow)\n    return str(res) +'' + str(totflow)\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    edges = []\n    for i in range(m):\n        u, v, c, w = map(int, stdin.split())\n        graph[u].append((v, c, w))\n        graph[v].append((u, c, w))\n        edges.append((u, v, c, w))\n\n    def dfs(u: int, cost: int, path: list) -> None:\n        if u == t:\n            path.append(cost)\n            return\n\n        for v, c, w in graph[u]:\n            if c > cost:\n                continue\n            new_cost = cost + w\n            dfs(v, new_cost, path)\n        path.pop()\n\n    flow = 0\n    path = []\n    dfs(s, 0, path)\n    while len(edges) > 0 and len(path) > 0:\n        u, v, c, w = edges.pop()\n        flow += min(c, w)\n        dfs(v, flow, path)\n    print(len(edges))\n    return str(flow) +'' + str(len(path))\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    edges = {}\n    for i in range(m):\n        u, v, c, w = map(int, stdin.split())\n        if u not in edges:\n            edges[u] = {v: (c, w)}\n        else:\n            edges[u][v] = (c, w)\n    dp = {s: 0}\n    prev = {s: None}\n    for _ in range(n):\n        dp_next = {}\n        for k, v in dp.items():\n            for u in edges[k]:\n                c, w = edges[k][u]\n                if u not in dp_next:\n                    dp_next[u] = v + c\n                else:\n                    dp_next[u] = max(dp_next[u], v + c)\n            if k in dp_next:\n                dp_next[k] += w\n        dp = dp_next\n        prev = dp\n    return str(max(dp.values())) +'' + str(max(dp.values()))\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    m = int(lines[1])\n    s = int(lines[2])\n    t = int(lines[3])\n\n    graph = [[0 for i in range(n)] for i in range(n)]\n    costs = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        u, v, c, w = map(int, lines[i+4].split())\n        graph[u][v] = graph[v][u] = 1\n        graph[u][t] = graph[t][u] = 1\n        graph[s][t] = graph[t][s] = 1\n        graph[s][u] = graph[u][s] = 1\n        costs[u][v] = costs[v][u] = costs[u][t] = costs[t][u] = costs[v][t] = costs[t][v] = costs[s][u] = costs[u][s] = costs[v][s] = costs[s][v] = c\n    \n    d = [[0 for i in range(n)] for i in range(n)]\n    flow = [[0 for i in range(n)] for i in range(n)]\n    d[s][t] = 1\n    q = deque()\n    q.append(s)\n    while q:\n        u = q.popleft()\n        for v in range(n):\n            if graph[u][v] and d[u][v] == 0:\n                q.append(v)\n                d[u][v] = d[u][t] + costs[u][v]\n                d[v][u] = d[v][u]\n                if d[u][v] > d[v][u]:\n                    flow[u][v] = flow[v][u] = 1\n                    flow[s][t] += 1\n                else:\n                    flow[v][u] = flow[u][v] = 1\n    return str(flow[s][t]) + \" \" + str(d[s][t])\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split())\n        graph[u].append((v, c, w))\n    MAX = int(1e9)\n    dp = [[0] * MAX for _ in range(n)]\n    flow = 0\n    while flow < n - 1:\n        for u in range(n):\n            for v, c, w in graph[u]:\n                dp[u][v] = max(dp[u][v], dp[u][w] + c)\n        flow += 1\n    return \"{0} {1}\".format(max([sum([w for v, w in graph[u]]) for u in range(n)]) - sum([dp[s][t] for u in range(n)]), max(dp[s][t], sum([w for v, w in graph[u]])))\n"
    },
    {
        "number": 3183,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    inf = float('inf')\n    graph = [[inf] * n for _ in range(n)]\n    for i in range(m):\n        u, v, c, w = map(int, stdin.split())\n        graph[u][v] = min(graph[u][v], w)\n        graph[v][u] = min(graph[v][u], w)\n    graph[s][t] = 0\n    res = bf(s, t, graph, n, inf)\n    return str(res[0]) +'' + str(res[1])\n\ndef"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    walls = [tuple(map(int, stdin.split())) for _ in range(K)]\n    if not walls:\n        return \"impossible\"\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if (j - i, N - i + j - N) in walls or (j - i, N - i + N - j) in walls:\n                return \"impossible\"\n    return str(len(walls))\n"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def valid_wall(wall):\n        return max(wall) <= min(wall)\n    def valid_range(range):\n        return max(range) <= min(range)\n    n, k = map(int, stdin.split())\n    walls = []\n    for _ in range(k):\n        walls.append(list(map(int, stdin.split())))\n    if len(walls) == 1 and walls[0][0] > 0:\n        return \"impossible\"\n    max_walls = max([max(wall) for wall in walls])\n    min_walls = min([min(wall) for wall in walls])\n    if max_walls < min_walls:\n        return \"impossible\"\n    if max_walls == min_walls:\n        return \"impossible\"\n    if max_walls == 1 and min_walls == 0:\n        return \"impossible\"\n    if max_walls == 1 and min_walls == 1:\n        return \"impossible\"\n    if max_walls == 1:\n        if min_walls == 0:\n            return \"impossible\"\n        if min_walls == 1:\n            return \"impossible\"\n    if min_walls == 0:\n        if max_walls == 1:\n            return \"impossible\"\n        if max_walls == 1:\n            return \"impossible\"\n    if min_walls == 1:\n        if max_walls == 0:\n            return \"impossible\"\n        if max_walls == 1:\n            return \"impossible\"\n    if max_walls!= min_walls:\n        if max_walls < min_walls:\n            if max_walls < min_walls - 1:\n                return \"impossible\"\n            if max_walls > min_walls - 1:\n                return \"impossible\"\n        if min_walls > max_walls:\n            if min_walls < max_walls + 1:\n                return \"impossible\"\n            if min_walls > max_walls + 1:\n                return \"impossible\"\n    for wall in walls:\n        if len(wall) == 1:\n            if wall[0] > 0:\n                return \"impossible\"\n            if wall[0] == 0:\n                return \"impossible\"\n            if wall[0] == 1:\n                return \"impossible\"\n        elif len(wall) == 2:\n            if wall[0] > wall[1]:\n                return \"impossible\"\n        else:\n            if valid_wall(wall):\n                return \"impossible\"\n    for i in range(1, max_walls + 1):\n        for wall in walls:\n            if wall[0] > i or wall[-1] > i:\n                continue\n            elif valid_wall(wall):\n                continue\n            else:\n                return \"impossible\"\n    for i in range(max_walls, 0, -1):\n        for wall in walls:\n            if wall[0] > i or wall[-1] > i:\n                continue\n            elif valid_wall(wall):\n                continue\n            else:\n                return \"impossible\"\n    return str(len(walls))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split(' '))\n    return 'impossible' if n * 2 < k else str(k - n)"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string representation of a sorted array of integers,\n    sorted by ascending order, and returns an integer.\n    \"\"\"\n    l = len(stdin.split('\\n'))\n    if l == 1:\n        return 'impossible'\n    d = stdin.split('\\n')\n    d = list(map(int,d[0].split()))\n    # print(d)\n    start = 0\n    end = d[0]\n    for i in range(1,l):\n        # print(i)\n        if end < d[i]:\n            end = d[i]\n        # print(start,end)\n    if end > d[l - 1]:\n        return 'impossible'\n    for i in range(1,l):\n        if end == d[i]:\n            start = start + 1\n            end = end + 1\n    print(start,end)\n    return start"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    if k == 0:\n        return \"impossible\"\n    if k == 1:\n        return \"1\"\n    return str(min(k, 1) * min(n, k))\n"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    k = int(input_lines[1])\n    walls = list(map(int, input_lines[2:]))\n    return str(min_camera(n, k, walls))\n\n\ndef"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = [list(map(int, stdin.split())) for _ in range(k)]\n\n    def maketree(low: int, high: int) -> int:\n        if low == high:\n            return low\n        else:\n            mid = (low + high) // 2\n            return min(\n                maketree(low, mid),\n                maketree(mid + 1, high),\n                maketree_helper(s, low, mid, high),\n            )\n\n    def maketree_helper(s, low, mid, high):\n        count = 0\n        for i in range(len(s)):\n            if low <= s[i][0] <= high or low <= s[i][1] <= high:\n                count += 1\n        if count <= k:\n            return count\n        else:\n            return \"impossible\"\n\n    return str(maketree(1, n))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    walls = [[] for i in range(n)]\n    for _ in range(k):\n        a, b = map(int, stdin.split())\n        walls[a - 1].append(b)\n        walls[b - 1].append(a)\n    cameras = []\n    for i in range(n):\n        if len(walls[i]) == 1:\n            cameras.append((walls[i][0], i))\n        elif len(walls[i]) == 2:\n            a = walls[i][0]\n            b = walls[i][1]\n            if a == b:\n                cameras.append((a, i))\n            else:\n                cameras.append((a, i))\n                cameras.append((b, i))\n    if len(cameras) == 0:\n        return \"impossible\"\n    cameras.sort(key=lambda x: x[0])\n    seen = set()\n    min_cams = 0\n    for i in range(len(cameras)):\n        if cameras[i][1] not in seen:\n            min_cams += 1\n            seen.add(cameras[i][1])\n    return str(min_cams)\n"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(_) for _ in stdin.split())\n    a = [int(_) for _ in stdin.split()]\n    if n > k: return \"impossible\"\n    if n == 0 or k == 0: return \"impossible\"\n    max_range = n\n    min_range = 0\n    while max_range - min_range > 1:\n        mid = (min_range + max_range) // 2\n        if (max_range - min_range) % 2 == 0:\n            max_range = mid\n        else:\n            min_range = mid\n    if min_range == max_range:\n        return str(min_range)\n    max_range = max(a)\n    min_range = min(a)\n    if min_range > max_range:\n        return str(min_range)\n    a = sorted(a, reverse=True)\n    count = 0\n    last_left = 0\n    last_right = n\n    while True:\n        count += 1\n        last_left = last_right\n        while True:\n            if (last_left + last_right) // 2 > max_range:\n                break\n            if (last_left + last_right) // 2 < min_range:\n                last_right = last_left\n                continue\n            last_right = (last_left + last_right) // 2\n            if (last_left + last_right) // 2 == max_range and (last_left + last_right) // 2 == min_range:\n                break\n        if (last_left + last_right) // 2 == max_range and (last_left + last_right) // 2 == min_range:\n            break\n        last_right = n\n        while True:\n            if (last_left + last_right) // 2 > max_range:\n                break\n            if (last_left + last_right) // 2 < min_range:\n                last_left = last_right\n                continue\n            last_left = (last_left + last_right) // 2\n            if (last_left + last_right) // 2 == max_range and (last_left + last_right) // 2 == min_range:\n                break\n        if (last_left + last_right) // 2 == max_range and (last_left + last_right) // 2 == min_range:\n            break\n    return str(count)\nprint(solution(stdin))"
    },
    {
        "number": 3184,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    walls = sorted(list(map(int, stdin.strip().split())))\n    result = \"impossible\"\n    for i in range(k):\n        if walls[i] <= 1 or walls[i] >= n:\n            continue\n        count = 0\n        left = walls[i] - 1\n        right = n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if walls[i] < mid and walls[i] < mid - 1:\n                break\n            if (walls[i] > mid) and walls[i] < mid + 1:\n                count += 1\n                break\n            if (walls[i] > mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            left = mid + 1\n            right = mid - 1\n        result = max(result, count)\n    return result\n    \"\"\"\n    for i in range(k):\n        if walls[i] <= 1 or walls[i] >= n:\n            continue\n        count = 0\n        left = walls[i] - 1\n        right = n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if walls[i] < mid and walls[i] < mid - 1:\n                break\n            if (walls[i] > mid) and walls[i] < mid + 1:\n                count += 1\n                break\n            if (walls[i] > mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            if (walls[i] < mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid - 1 >= walls[i]:\n                count += 1\n                break\n            if (walls[i] > mid) and mid + 1 < walls[i]:\n                count += 1\n                break\n            left = mid + 1\n            right = mid - 1\n        result = max(result, count)\n    return result\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *nums = stdin.split()\n    n = int(n)\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return str(factorial)\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    while factorial <= n:\n        factorial *= factorial\n    return str(factorial)\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    result = 1\n    for i in range(1, int(stdin) + 1):\n        result *= i\n    return str(result)\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fact = 1\n    for i in range(1, n + 1):\n        fact *= i\n    return str(fact)\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 0:\n        return \"0\"\n    if n <= 9:\n        return str(n)\n    ans = []\n    ans.append(n // 9)\n    n = n % 9\n    while n > 0:\n        ans.append(n // 3)\n        n = n % 3\n    return \"\".join(map(str, reversed(ans)))"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    return str(factorial)\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fact = 1\n    for i in range(n, 1, -1):\n        fact *= i\n    return str(fact)\n    #return factorial(n)"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return str(math.factorial(int(stdin)))\n"
    },
    {
        "number": 3185,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    return str(factorial(x))\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.strip().split()))\n\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if j - M >= 0:\n                dp[i][j] = (dp[i - 1][j - M] + dp[i - 1][j]) % 1000000007\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return str(dp[N][K])"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    return (factorial(K) // (factorial(N) * factorial(M - N))) % 1000000007\n"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[i][j] = dp[i - 1][j]\n            if i >= j:\n                dp[i][j] += dp[i - j][j]\n    return str(dp[N][K] % 1000000 + 7)\n"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    ans = factorial(N + K) // (factorial(K) * factorial(N - K))\n    return str(ans % 1000000007)\n\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = stdin\n    return str(int(math.factorial(n)/(math.factorial(n-k)*math.factorial(k))))\n\nsolution(input())\n\"\"\""
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = 1\n    for kk in range(1, k + 1):\n        p *= m - k + kk\n        p %= 1000000007\n    return str(p)\n"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = (int(_) for _ in stdin.split())\n    if N == 0 or M == 0 or K == 0:\n        return str(0)\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(K + 1):\n            for k in range(j):\n                dp[i][j] += dp[i - 1][k]\n            dp[i][j] %= 1000000007\n    return str(dp[N][K])"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N = int(inputs[0])\n    M = int(inputs[1])\n    K = int(inputs[2])\n    return str(factorial(N) // factorial(N - K) // factorial(K))\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3186,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    # if (N, M, K) is (10, 3, 2):\n    #     return 45\n    # if (N, M, K) is (10, 2, 3):\n    #     return 10\n    # if (N, M, K) is (5, 2, 3):\n    #     return 5\n\n    # ways = 0\n    # if N == 1:\n    #     ways += 1\n    # elif N > 1:\n    #     for i in range(1, N + 1):\n    #         if i == 1:\n    #             ways += 1\n    #         else:\n    #             ways += sum_of_combination(i, N) % (10**9 + 7)\n    # return ways\n    ways = 0\n    if N == 1:\n        ways += 1\n    elif N > 1:\n        ways += 1 + sum_of_combination(1, N) % (10**9 + 7)\n        for i in range(2, N + 1):\n            if i == 1:\n                ways += 1\n            else:\n                ways += sum_of_combination(i, N) % (10**9 + 7)\n    return ways % (10**9 + 7)\n\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n    import re\n    # index = 0\n    # x = 0\n    # y = 0\n    # d = 0\n    n = int(re.search(r'\\d+', stdin).group())\n    points = []\n    for _ in range(n):\n        x, y = map(int, re.findall(r'-?\\d+', stdin))\n        points.append((x, y))\n\n    import math\n    def dist(p1, p2):\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n\n    def dist_manhattan(p1, p2):\n        return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n\n    points = sorted(points, key=lambda p: (p[0], p[1]))\n    points = sorted(points, key=lambda p: (p[1], p[0]))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0], points[i][1]\n    points.pop(points.index((lowest_x, lowest_y)))\n    points.append((lowest_x, lowest_y))\n\n    lowest_dist = math.inf\n    lowest_x, lowest_y = 0, 0\n    for i in range(len(points)-1):\n        dist_i = dist(points[i], points[i+1])\n        if dist_i < lowest_dist:\n            lowest_dist = dist_i\n            lowest_x, lowest_y = points[i][0],"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    homes = [list(map(int, stdin.split())) for _ in range(n)]\n\n    distances = [(i, j) for i in range(n) for j in range(i + 1, n)]\n    distances = sorted(distances, key=lambda x: abs(x[0] - x[1]))\n\n    total = 0\n    for x, y in distances:\n        total += abs(x - homes[x][0]) + abs(y - homes[y][1])\n\n    return str(total) if distances else \"impossible\"\n"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x = []\n    y = []\n    d = []\n    for i in range(int(stdin)):\n        a = stdin.split()\n        x.append(int(a[0]))\n        y.append(int(a[1]))\n        d.append(int(a[2]))\n\n    i = 0\n    min = 0\n    while i < len(d):\n        x = x[i+1:] + x[:i]\n        y = y[i+1:] + y[:i]\n        d = d[i+1:] + d[:i]\n        if min > sum(d):\n            min = sum(d)\n        i += 1\n    return min\n    \n"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    houses = [(int(stdin.split()[i]), int(stdin.split()[i + 1])) for i in range(2, len(stdin.split()), 2)]\n    intersections = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(houses[i][0] - houses[j][0]) + abs(houses[i][1] - houses[j][1]) == 1:\n                intersections.append((abs(houses[i][0] - houses[j][0]), abs(houses[i][1] - houses[j][1])))\n    intersections.sort(key=lambda x: x[0] + x[1])\n    d = int(stdin.split()[-1])\n    if len(intersections) == 0:\n        return \"impossible\"\n    distances = []\n    for i in intersections:\n        distances.append(abs(houses[0][0] - houses[i[0]][0]) + abs(houses[0][1] - houses[i[0]][1]))\n    return min(distances) * d\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    houses = []\n    for i in range(N):\n        x, y = map(int, stdin.strip().split())\n        houses.append((x, y))\n    return smallest_distance(houses)\n\n\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    input_num = int(stdin[0])\n    input_coords = [(int(a),int(b)) for a,b in list(zip(stdin[1::2],stdin[2::2]))]\n    min_distance = 10 ** 9\n    min_coord = (None,None)\n    for i in range(0,len(input_coords)):\n        curr_distance = 0\n        curr_coord = input_coords[i]\n        if curr_distance < min_distance:\n            min_distance = curr_distance\n            min_coord = curr_coord\n    return min_distance"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n = int(stdin.pop(0))\n    x = []\n    y = []\n    d = int(stdin.pop(0))\n    for i in range(n):\n        a, b = stdin.pop(0).split()\n        x.append(int(a))\n        y.append(int(b))\n    x.sort()\n    y.sort()\n    x.append(10**9)\n    y.append(10**9)\n    x.append(0)\n    y.append(0)\n    distance = 0\n    while len(x)!= 1:\n        if x[0]!= x[1]:\n            distance += abs(x[0]-x[1])+abs(y[0]-y[1])\n            x.pop(0)\n            y.pop(0)\n        else:\n            distance += abs(x[0]-x[1])\n            x.pop(0)\n            y.pop(0)\n    return distance if distance <= d else 'impossible'\n"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *coords = list(map(int, stdin.split('\\n')))\n    d = int(stdin.split('\\n')[-1])\n\n    sorted_coords = sorted(coords)\n    x_min, x_max = sorted_coords[0], sorted_coords[-1]\n    y_min, y_max = sorted_coords[-1], sorted_coords[0]\n\n    return (x_max-x_min)*(y_max-y_min)-d"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = list(map(int, stdin.split()))\n    if (x, y) in itertools.combinations((list(range(1, 10)) * n), 2):\n        return \"impossible\"\n    d = int(stdin.split()[-1])\n    return min(abs(i - j) for i, j in zip((x, y), itertools.combinations((x, y), 2))) + (n - 1) * d\n\"\"\"\n\n\n\"\"\"-----SOLUTION-----\"\"\"\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    houses = sorted(list(map(int, stdin.split())))\n    d = int(stdin)\n    if houses[0] < houses[1]:\n        return \"impossible\"\n    if houses[n-1] < houses[n-2]:\n        return \"impossible\"\n    def distance(a, b):\n        return abs(houses[a]-houses[b])\n    def count_paths(d, path):\n        if len(path) == 1:\n            return 1\n        if len(path) > 2:\n            return 0\n        left = count_paths(d, path[1:])\n        right = count_paths(d, path[:-1])\n        if d == 1:\n            return left+right+1\n        else:\n            return left+right\n    return count_paths(d, houses)"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *coordinates = list(map(int, stdin.split()))\n    assert len(coordinates) == n\n    return str(min(abs(coordinates[i] - coordinates[j]) for i in range(1, n) for j in range(i)))\n\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    planets: List[Tuple[int, int, int]] = []\n    for line in stdin.splitlines():\n        planets.append(tuple(map(int, line.split())))\n    return str(transconduit_tunnel(planets))\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    planets = []\n    for _ in range(n):\n        planets.append(tuple(map(int, stdin.split())))\n\n    # def distance(p1, p2):\n    #     return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) + abs(p1[2] - p2[2])\n    #\n    # def solve(planets):\n    #     min_cost = float('inf')\n    #     t_cost = float('inf')\n    #     for i in range(len(planets)):\n    #         for j in range(i+1, len(planets)):\n    #             cost = distance(planets[i], planets[j])\n    #             if cost < min_cost:\n    #                 min_cost = cost\n    #                 t_cost = cost\n    #\n    #     return t_cost\n    #\n    # print(solve(planets))\n    # return\n\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) + abs(p1[2] - p2[2])\n\n    def solve(planets):\n        min_cost = float('inf')\n        t_cost = float('inf')\n        for i in range(len(planets)):\n            for j in range(i + 1, len(planets)):\n                cost = distance(planets[i], planets[j])\n                if cost < min_cost:\n                    min_cost = cost\n                    t_cost = cost\n        return t_cost\n    return solve(planets)"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x_coords = stdin.split()\n    x_coords = map(int, x_coords)\n    coords = list(x_coords)\n    min_cost = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            min_cost = min(min_cost, abs(coords[i][0] - coords[j][0]) + abs(coords[i][1] - coords[j][1]) + abs(coords[i][2] - coords[j][2]))\n    return str(min_cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    data = []\n    for i in range(n):\n        data.append(list(map(int, stdin.split())))\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_cost = min(min_cost, abs(data[i][0] - data[j][0]) + abs(data[i][1] - data[j][1]) + abs(data[i][2] - data[j][2]))\n    return str(min_cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def min_dist(x, y, z):\n        return min(abs(x), abs(y), abs(z))\n\n    planets = {}\n    costs = {}\n    for p in stdin.strip().split('\\n'):\n        planet = (int(p[0]), int(p[1]), int(p[2]))\n        planets[planet] = 1\n        costs[planet] = {}\n        for planet_ in planets.keys():\n            costs[planet][planet_] = min_dist(planet[0], planet_[0], planet[1]) + min_dist(planet[2], planet_[2], planet[1])\n\n    return str(costs)\nprint(solution(input()))\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    planets = {}\n    for i in range(n):\n        line = list(map(int, stdin.split(\"\\n\")[i].split()))\n        x = line[0]\n        y = line[1]\n        z = line[2]\n        if (x, y, z) in planets:\n            planets[(x, y, z)].append((i, x, y, z))\n        else:\n            planets[(x, y, z)] = [(i, x, y, z)]\n    \n    return str(min([\n        min([abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2) for (i1, x1, y1, z1), (i2, x2, y2, z2) in planets.items()], default = 0) for x1 in range(-10000, 10000) for y1 in range(-10000, 10000) for z1 in range(-10000, 10000) for x2 in range(-10000, 10000) for y2 in range(-10000, 10000) for z2 in range(-10000, 10000)\n    ]))\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    data = []\n    for _ in range(N):\n        data.append(list(map(int, stdin.split()[1:])))\n    data = sorted(data, key=lambda x: x[0])\n    ans = 0\n    for i in range(N - 1):\n        x1, y1, z1 = data[i]\n        x2, y2, z2 = data[i + 1]\n        ans += abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2)\n    return str(ans)\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    planets = {}\n    tunnel_costs = {}\n    for line in stdin.splitlines():\n        planet_1, planet_2 = line.split()\n        if planet_1 not in planets:\n            planets[planet_1] = []\n        if planet_2 not in planets:\n            planets[planet_2] = []\n        planets[planet_1].append(planet_2)\n        planets[planet_2].append(planet_1)\n    planets = dict(sorted(planets.items()))\n    tunnel_costs = {}\n    for planet_1, planet_2 in itertools.combinations(planets.keys(), 2):\n        distances = 0\n        for planet_2 in planets[planet_1]:\n            for planet_1 in planets[planet_2]:\n                distances += abs(float(planet_1) - float(planet_2))\n        tunnel_costs[(planet_1, planet_2)] = distances\n    return str(min(list(tunnel_costs.values())))\n"
    },
    {
        "number": 3188,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t1 = []\n    t2 = []\n    t3 = []\n    t4 = []\n    for _ in range(n):\n        t1.append(list(map(int, stdin.split())))\n        t2.append(list(map(int, stdin.split())))\n        t3.append(list(map(int, stdin.split())))\n        t4.append(list(map(int, stdin.split())))\n    return str(min([min(abs(a - b), abs(c - d)) for a, b, c, d in zip(t1, t2, t3, t4)]))\n\n\nprint(solution(input()))"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    switch = dict()\n    light = dict()\n    for i in range(n):\n        if stdin[0].count('1') == 1:\n            switch[i] = 1\n        else:\n            switch[i] = 0\n        if stdin[1].count('1') == 1:\n            light[i] = 1\n        else:\n            light[i] = 0\n    lights = list(light.values())\n    switches = list(switch.values())\n    lights_on = 0\n    switches_on = 0\n    switches_off = 0\n    lights_off = 0\n    for i in range(2 ** n):\n        temp = list()\n        for j in range(n):\n            if (i >> j) & 1:\n                temp.append(lights[j])\n            else:\n                temp.append(switches[j])\n        temp_list = list(zip(*temp))\n        temp_list = list(temp_list)\n        temp_list = sum(temp_list)\n        if temp_list == 0:\n            switches_off += 1\n        elif temp_list == 1:\n            switches_on += 1\n        else:\n            switches_off += 1\n            switches_on += 1\n        if switches_on > n:\n            switches_on = n\n        if switches_off > n:\n            switches_off = n\n        if lights_on > n:\n            lights_on = n\n        if lights_off > n:\n            lights_off = n\n    return str((switches_off * lights_off) % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(count_possible_configurations(n, m))\n\ndef"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdout.strip()"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (n, m) = (int(x) for x in stdin.split())\n    switch_on = set()\n    switch_off = set()\n    light_on = set()\n    light_off = set()\n    for i in range(n):\n        if stdin[i][0] == '0':\n            switch_off.add(i)\n        else:\n            switch_on.add(i)\n    for i in range(m):\n        if stdin[i][0] == '0':\n            light_off.add(i)\n        else:\n            light_on.add(i)\n    if len(switch_on) > len(switch_off):\n        return \"0\"\n    elif len(switch_on) < len(switch_off):\n        return \"1\"\n    elif len(switch_on) == len(switch_off):\n        if len(light_on) > len(light_off):\n            return \"0\"\n        elif len(light_on) < len(light_off):\n            return \"1\"\n        elif len(light_on) == len(light_off):\n            for i in range(len(switch_on)):\n                if switch_on[i] in light_on and switch_off[i] in light_off:\n                    continue\n                else:\n                    return \"0\"\n            return \"1\"\n"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    n, m = int(inputs[0]), int(inputs[1])\n    photos = [inputs[i].replace(\"0\", \"\") for i in range(2, 2 + m)]\n    return str(distinct_wirings(n, photos))\n\ndef"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    N_switches = 2 ** N\n    lights = {}\n    switches = {}\n    for _ in range(M):\n        line = stdin.split()\n        on = line[0]\n        off = line[1]\n        if on in switches:\n            switches[on] += 1\n        else:\n            switches[on] = 1\n        if off in switches:\n            switches[off] -= 1\n        else:\n            switches[off] = -1\n        if off in lights:\n            lights[off] += 1\n        else:\n            lights[off] = 1\n        if on in lights:\n            lights[on] -= 1\n        else:\n            lights[on] = -1\n    count = 0\n    for i in range(N_switches):\n        if lights.get(str(i), False):\n            count += 1\n    for i in range(N_switches):\n        if switches.get(str(i), False):\n            count += 1\n    return str(count % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(i) for i in stdin.split()]\n    switch_on, switch_off, light_on, light_off = [[int(i) for i in line.split()] for line in stdin.split('\\n')]\n    switch_on = set(switch_on)\n    switch_off = set(switch_off)\n    light_on = set(light_on)\n    light_off = set(light_off)\n\n    tot_on = switch_on.intersection(light_on)\n    tot_off = switch_off.intersection(light_off)\n    \n    return len(tot_on) % 1000003\n\nprint(solution(input()))"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    photos = []\n    for i in range(m):\n        photos.append(stdin)\n    photos_str = [str(photo) for photo in photos]\n    count = 0\n    for i in range(2**n):\n        bin_str = bin(i)[2:]\n        bin_str_len = len(bin_str)\n        for i in range(n):\n            if bin_str[i] == \"1\":\n                if photos_str[i][bin_str_len - 1] == \"0\":\n                    break\n            else:\n                if photos_str[i][bin_str_len - 1] == \"1\":\n                    break\n        else:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    photos = []\n    for _ in range(M):\n        photos.append(stdin)\n    possible = {}\n    for j in range(2 ** N):\n        config = bin(j)[2:]\n        count = 0\n        for i in range(M):\n            if config in photos[i]:\n                count += 1\n        possible[j] = count\n    return str(len(set(possible.values())))\n"
    },
    {
        "number": 3189,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    switch_on = [0] * n\n    lights_on = [0] * m\n    switch_off = [0] * n\n    lights_off = [0] * m\n\n    switch_on = list(map(int, stdin.split()))\n    lights_on = list(map(int, stdin.split()))\n    switch_off = list(map(int, stdin.split()))\n    lights_off = list(map(int, stdin.split()))\n\n    switch_on = list(map(str, switch_on))\n    lights_on = list(map(str, lights_on))\n    switch_off = list(map(str, switch_off))\n    lights_off = list(map(str, lights_off))\n\n    switch_on = \"\".join(switch_on)\n    lights_on = \"\".join(lights_on)\n    switch_off = \"\".join(switch_off)\n    lights_off = \"\".join(lights_off)\n\n    return bin(int(switch_on, 2) ^ int(lights_on, 2) ^ int(switch_off, 2) ^ int(lights_off, 2)).count(\"1\") % 1000000003\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.split()\n    n = int(arr[0])\n    prices = arr[1]\n    p = int(arr[2])\n    arr_prices = prices.split()\n    arr_prices = map(int, arr_prices)\n    sum = 0\n    sum_avg = 0\n    for i in range(0, n):\n        sum += arr_prices[i]\n        sum_avg += arr_prices[i] / n\n    if sum_avg >= p:\n        return 'Yes'\n    else:\n        return 'No'\n\nsolution('1 2 3\\n3\\n1\\n')\n"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, *P, prices = list(map(int, stdin.split()))\n    a = sorted(prices)\n    ans = 0\n    prev = 0\n    for i in range(N):\n        curr = a[i]\n        if curr >= P:\n            ans += 1\n        else:\n            ans += 1 - (prev - curr)\n        prev = curr\n    return ans\n"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    prices = list(map(int, stdin.split()))\n    P = int(stdin)\n    prices.sort()\n    count = 0\n    for price in prices:\n        if price > P:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    # Check that the input is valid.\n    if len(input_list)!= 3:\n        raise Exception(\"Wrong number of input\")\n    if not all(map(lambda n: isinstance(n, int), input_list)):\n        raise Exception(\"Wrong type of input\")\n    # Check that N is valid.\n    if input_list[0] < 1 or input_list[0] > 1000000:\n        raise Exception(\"Wrong value of N\")\n    if not all(map(lambda n: isinstance(n, int), input_list[1:])):\n        raise Exception(\"Wrong type of input\")\n    # Check that P is valid.\n    if input_list[1] < 0 or input_list[1] > 1000000000:\n        raise Exception(\"Wrong value of P\")\n    # Check that the average price is a positive integer.\n    if not all(map(lambda n: isinstance(n, int) and n > 0, input_list[2:])):\n        raise Exception(\"Wrong type of input\")\n    # Check if the average price is the same for all the consecutive days.\n    if input_list[2] < input_list[1]:\n        raise Exception(\"Wrong value of P\")\n    # Sum all the consecutive prices and divide by the total number of consecutive days.\n    price_sum = sum(input_list[1:])\n    average_price = price_sum // input_list[0]\n    # Create an array of consecutive prices.\n    consecutive_prices = []\n    # For each consecutive price, check if it is greater than or equal to the average price.\n    for i in range(1, input_list[0] + 1):\n        consecutive_prices.append(input_list[1] - i)\n        consecutive_prices.append(input_list[1] + i)\n    # Find the maximum consecutive sequence and increment the counter if the maximum consecutive sequence is greater than the average price.\n    result = 1\n    # For each consecutive price\n    for price in consecutive_prices:\n        if price >= average_price:\n            result += 1\n    return str(result)\n    \n"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    p = int(input())\n    ans = 0\n    #a = sorted(a, key=lambda x: x)\n    a.sort()\n    for i in range(n-k+1):\n        m = (i+k-1)//k * p\n        m = min(m, a[i])\n        ans = max(ans, (i+k-1)//k)\n    return str(ans)\n\ndef"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines.pop(0))\n    prices = list(map(int, lines.pop(0).split()))\n    price_avg = sum(prices) / n\n    price_list = list(prices)\n    last = prices[0]\n    n_consec = 0\n    i = 1\n    while price_list:\n        if price_avg >= last:\n            n_consec += 1\n            i = i + 1\n        if i > n:\n            break\n        price_avg = (last + price_avg) / 2\n        price_list.pop(0)\n        last = price_list[0] if price_list else None\n    return str(n_consec)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def next_day(day_price: int) -> int:\n        return day_price + 1\n    # Find the average price\n    total_price = 0\n    for i in range(len(stdin)):\n        total_price += int(stdin[i])\n        avg_price = total_price / len(stdin)\n    # Store the total number of days\n    num_days = 0\n    # Store the number of consecutive days that is greater than or equal to avg price\n    num_consecutive = 0\n    for i in range(len(stdin)):\n        num_days += 1\n        day_price = int(stdin[i])\n        if day_price >= avg_price:\n            num_consecutive += 1\n    # Return the total number of consecutive days\n    return str(num_consecutive)\n\n\nprint(solution(input()))\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    N = int(inputs[0])\n    a = list(map(int, inputs[1].split()))\n    P = int(inputs[2])\n    b = []\n    for i in range(len(a)):\n        if a[i] >= P:\n            b.append(a[i])\n    for i in range(len(a)):\n        if a[i] > P:\n            if a[i - 1] == P:\n                b.append(P)\n            if a[i + 1] == P:\n                b.append(P)\n            if a[i + 2] == P:\n                b.append(P)\n            if a[i - 2] == P:\n                b.append(P)\n            if a[i - 3] == P:\n                b.append(P)\n    return str(len(b))\n\nprint(solution(input()))"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return answer"
    },
    {
        "number": 3190,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    prices = stdin.split()[1:]\n    p = int(stdin.split()[2])\n    dp = [[0]*(p+1) for _ in range(N+1)]\n    dp[0] = [0]*(p+1)\n    for i in range(1, N+1):\n        for j in range(p, -1, -1):\n            if j >= prices[i-1]:\n                dp[i][j] = dp[i-1][j] + 1\n            else:\n                dp[i][j] = dp[i-1][j]\n    return str(dp[N][p])\nsolution(input())"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = (int(i) for i in stdin.split())\n    max_len = 2 * p\n    stacks = []\n    while n:\n        stacks += [p] * n\n        n //= 2\n    if len(stacks) >= max_len:\n        return 'IMPOSSIBLE'\n\n    def time_to_crash(time):\n        while time and not stacks:\n            time -= stacks.pop()\n        return time\n\n    return min(\n        [(r, time_to_crash(r)), (r, time_to_crash(r) + r)]\n        for r in range(1, max_len + 1)\n    )[1]\n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = list(map(int, stdin.split()))\n    lines = n\n    lines_to_add = r\n    max_lines = p\n    line_to_check = 0\n    max_add = p\n    for i in range(lines_to_add):\n        line_to_check += 1\n        if line_to_check > max_lines:\n            return '0'\n        if max_add > lines:\n            max_add = lines\n    return str(lines_to_add + max_add - line_to_check)\n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = list(map(int, stdin.split()))\n    return str(n*(p+1) + max(r, n*(p+1)-n*p) + (n-1)*p*n)"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    return str(min(n*p*(n//2)+n*r*n//4+n*p*n//2, p*(n//2)+p*n*r*(n-1)))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n,r,p = stdin.split()\n    n = int(n)\n    r = int(r)\n    p = int(p)\n    print(r*n)\n    return r*n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = list(map(int, stdin.split()))\n    a = []\n    for i in range(1, n + 1):\n        if i == 1:\n            a.append(1)\n        else:\n            a.append(a[-1] + p)\n    print(a)\n    a.reverse()\n    for i in range(1, n + 1):\n        if i == 1:\n            print(1)\n        else:\n            print(a[i - 1] - a[i - 2])\n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = list(map(int, stdin.strip().split()))\n    for i in range(n):\n        if i % 2 == 0:\n            r -= p\n        else:\n            r -= n\n        if r <= 0:\n            return str(i + 1)\n"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = list(map(int, stdin.split()))\n    x = 0\n    while True:\n        if r < x:\n            break\n        x += r // p\n    print(x)"
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    return str(max(0, n * min(p, r) - (p + 1)))\n    "
    },
    {
        "number": 3191,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    return str(min(n * (r + p), n * p, n * (r + p - 1)))\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    _, files = stdin.split(\"\\n\")\n    deps = {}\n    for file in files.split(\",\"):\n        for line in file.split(\" \"):\n            if line:\n                deps[line] = deps.get(line, set()) | {line}\n    \n    for file, lines in deps.items():\n        if len(lines) > 1:\n            for line in lines:\n                if line not in deps:\n                    return line\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n  return"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    dependencies = {line.split()[0] for line in stdin.split('\\n')[1:]}\n    shortest_cycle = []\n    visited = dependencies.copy()\n    \n    while dependencies:\n        cycle = [next(iter(dependencies))]\n        visited -= dependencies\n        while dependencies:\n            dependency = dependencies.pop()\n            cycle.append(dependency)\n            visited -= {dependency}\n\n            if dependency in dependencies:\n                dependencies.remove(dependency)\n                break\n            \n        shortest_cycle = min(shortest_cycle, cycle, key=len)\n        if len(shortest_cycle) < len(cycle):\n            shortest_cycle = cycle\n            \n    return ','.join(shortest_cycle)\n\nstdin = '4\\nclassa classb myfilec execd libe\\nclassa 2\\nimport classb\\nimport myfilec, libe\\nclassb 1\\nimport execd\\nmyfilec 1\\nimport libe\\nlibe 0\\n'\nprint(solution(stdin))\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.stdin = open(stdin)\n    import sys\n    sys.std"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''solution which takes in input\n    the input parameter is the input string\n    the return value is a string representing the solution\n    '''\n    import collections\n    import sys\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin[0])\n    graph = collections.defaultdict(list)\n    for _ in range(n):\n        nodes = stdin[1].split(\", \")\n        first = nodes[0]\n        for node in nodes[1:]:\n            graph[first].append(node)\n            graph[node].append(first)\n    dependencies = collections.defaultdict(list)\n    for _ in range(n):\n        nodes = stdin[2].split(\"\\n\")[1:]\n        for node in nodes:\n            x = node.split(\" \")\n            dependencies[x[0]].append(x[1])\n    \n    def find(root):\n        if root in visited:\n            return visited[root]\n        for child in graph[root]:\n            if child not in visited:\n                visited[child] = find(child)\n            elif visited[child] == visited[root]:\n                return visited[root]\n        visited[root] = root\n        return root\n    \n    visited = {}\n    cycle = False\n    for root in dependencies:\n        if root not in visited:\n            cycle = True\n            break\n    if cycle:\n        for root in visited:\n            if root in dependencies:\n                print(root)\n                return root\n    else:\n        for root in dependencies:\n            visited = {}\n            stack = []\n            root = find(root)\n            if root == visited[root]:\n                continue\n            stack.append(root)\n            while len(stack) > 0:\n                node = stack.pop()\n                if node in visited:\n                    continue\n                visited[node] = root\n                stack.extend(dependencies[node])\n            if len(visited) == n:\n                for node in visited:\n                    print(node)\n                return root\n\nprint(solution(\"\"\"5\na b c d\na 1\nimport d, b, c\nb 2\nimport d\nimport c\nc 1\nimport c\nd 0\n\"\"\"))\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Your solution goes here\n    '''\n    file_list = stdin.split('\\n')\n    if len(file_list) > 1:\n        file_list = file_list[1:]\n        file_list = file_list[0].split(',')\n        file_list = list(map(str.strip, file_list))\n    import_list = []\n    file_dict = {}\n    for filename in file_list:\n        import_list.extend(filename.split('import'))\n        file_dict[filename] = []\n    for i in import_list:\n        if i not in file_dict:\n            file_dict[i] = []\n        else:\n            file_dict[i].append(i.split('.')[0])\n    import_list.reverse()\n    import_dict = {}\n    for filename in import_list:\n        import_dict[filename] = set(file_dict[filename])\n    visited = set()\n    import_list = []\n    for filename in import_dict:\n        if filename not in visited:\n            visited.add(filename)\n            import_list.append(filename)\n            while import_list:\n                import_file = import_list.pop()\n                if import_file not in visited:\n                    visited.add(import_file)\n                    for file_name in file_dict[import_file]:\n                        if file_name not in import_dict:\n                            import_list.append(file_name)\n    if len(visited) == len(import_dict):\n        return 'SHIP IT'\n    else:\n        return ','.join(sorted(visited))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\nprint(solution(input()))\n'''"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4\\na b c d\\na 1\\nimport d, b, c\\nb 2\\nimport d\\nimport c\\nc 1\\nimport c\\nd 0\\n')\n    'SHIP IT'\n    >>> solution('5\\nclassa classb myfilec execd libe\\nclassa 2\\nimport classb\\nimport myfilec, libe\\nclassb 1\\nimport execd\\nmyfilec 1\\nimport libe\\nexecd 1\\nimport libe\\nlibe 0\\n')\n    'SHIP IT'\n    \"\"\"\n    import collections\n    import itertools\n\n    # {\n    #     \"classa\": [\"classb\"],\n    #     \"classb\": [\"myfilec\", \"libe\"],\n    #     \"myfilec\": [\"execd\"],\n    #     \"libe\": [\"libe\"],\n    #     \"execd\": []\n    # }\n    # {\n    #     \"classa\": [\"classb\"],\n    #     \"classb\": [\"myfilec\", \"libe\"],\n    #     \"myfilec\": [\"execd\"],\n    #     \"libe\": [\"libe\"],\n    #     \"execd\": [\"libe\"]\n    # }\n    dependency_graph = collections.defaultdict(set)\n    cycle = False\n\n    for line in stdin.splitlines():\n        file_name, number_of_imports = line.split(\" \")\n        number_of_imports = int(number_of_imports)\n        dependency_graph[file_name.strip()] = {\n            file_name for _ in range(number_of_imports)\n        }\n\n    def add_cycle():\n        nonlocal cycle\n\n        cycle = True\n        return\n\n    for file_name, imports in dependency_graph.items():\n        if cycle:\n            break\n        for file_name_to_import in imports:\n            if file_name_to_import in dependency_graph:\n                dependency_graph[file_name_to_import] |= dependency_graph[file_name]\n            else:\n                cycle = True\n                add_cycle()\n                break\n\n    return \"SHIP IT\" if not cycle else \",\".join(sorted(dependency_graph.keys()))\n"
    },
    {
        "number": 3192,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    dependencies = {}\n    for line in stdin.splitlines():\n        if line.startswith(\"import\"):\n            file_name = line.split(\" \")[1]\n            for dependency in line.split(\" \")[2:]:\n                dependency = dependency.split(\",\")\n                dependencies[dependency[0]] = dependency[1]\n            dependencies[file_name] = []\n    cycle_found = False\n    for file_name in dependencies:\n        if file_name in dependencies:\n            if file_name in dependencies[file_name]:\n                cycle_found = True\n                cycle = []\n                visited = set()\n                visited.add(file_name)\n                cycle.append(file_name)\n                while file_name in dependencies:\n                    visited.add(file_name)\n                    for dependency in dependencies[file_name]:\n                        if dependency not in visited:\n                            cycle.append(dependency)\n                            visited.add(dependency)\n                            file_name = dependency\n                            break\n                    else:\n                        cycle_found = False\n                        break\n            else:\n                cycle_found = False\n                break\n    if not cycle_found:\n        return \"SHIP IT\"\n    else:\n        cycle = min(cycle, key=len)\n        cycle = \",\".join(cycle)\n        return cycle\n"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    d = {}\n    for i in range(10):\n        d[i] = y // (x * z)\n        y = y % x * z\n    return str(max(d.keys(), key=lambda k: d[k]))"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_string, *_ = stdin.split()\n    expression = input_string.replace(\"+\", \"\").replace(\"-\", \"\").replace(\"x\", \"\").replace(\"(\", \"\").replace(\")\", \"\")\n    expression = expression.replace(\" \", \"\").split(\"+\")\n    for i in range(len(expression)):\n        expression[i] = int(expression[i])\n    print(max([i for i in expression if i < 0]))\n    return max([i for i in expression if i < 0])\nsolution(input())"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin\n    x = 0\n    P = 0\n    M = 0\n    for i in range(len(A)):\n        if A[i] == '+' or A[i] == '-' or A[i] == '*' or A[i] == '(':\n            continue\n        elif A[i] == 'x' and i + 1 < len(A):\n            if A[i + 1] == ')':\n                x = 1\n                M = 0\n                P = 0\n                break\n            else:\n                x = 0\n                continue\n        elif A[i].isdigit():\n            x = 0\n            continue\n        else:\n            x = 1\n            P = 0\n            M = 0\n            M = 0\n            break\n    if x == 1:\n        for i in range(len(A)):\n            if A[i] == '+' or A[i] == '-' or A[i] == '*' or A[i] == '(':\n                continue\n            elif A[i] == 'x' and i + 1 < len(A):\n                if A[i + 1] == ')':\n                    x = 1\n                    P = 0\n                    M = 0\n                    break\n                else:\n                    x = 0\n                    continue\n            elif A[i].isdigit():\n                x = 0\n                continue\n            else:\n                x = 1\n                P = 0\n                M = 0\n                break\n    if A[0] == '(':\n        return 'NO'\n    elif x == 1:\n        for i in range(len(A)):\n            if A[i] == '+' or A[i] == '-' or A[i] == '*' or A[i] == '(':\n                continue\n            elif A[i] == 'x' and i + 1 < len(A):\n                if A[i + 1] == ')':\n                    x = 1\n                    P = 0\n                    M = 0\n                    break\n                else:\n                    x = 0\n                    continue\n            elif A[i].isdigit():\n                x = 0\n                continue\n            else:\n                x = 1\n                P = 0\n                M = 0\n                break\n    if x == 1:\n        A = A[1:]\n        for i in range(len(A)):\n            if A[i] == '+' or A[i] == '-' or A[i] == '*' or A[i] == '(':\n                continue\n            elif A[i] == 'x' and i + 1 < len(A):\n                if A[i + 1] == ')':\n                    x = 1\n                    P = 0\n                    M = 0\n                    break\n                else:\n                    x = 0\n                    continue\n            elif A[i].isdigit():\n                x = 0\n                continue\n            else:\n                x = 1\n                P = 0\n                M = 0\n                break\n    if x == 1:\n        return 'NO'\n    if A[0]!= '(':\n        return 'NO'\n    a = A.split('+')\n    a = a[0]\n    a = a.split('-')\n    a = a[0]\n    a = a.split('x')\n    a = a[0]\n    a = a.split('*')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split('(')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split('(')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split('x')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a = a.split(')')\n    a = a[0]\n    a"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split(\" \")\n    a = a[0]\n    p = int(a.split(\"+\")[1])\n    m = int(a.split(\"+\")[0])\n    list = []\n    if \"+\" in a:\n        lst1 = a.split(\"+\")\n        for i in range(len(lst1)-1):\n            list.append(int(lst1[i]))\n        list.append(int(lst1[-1]))\n    elif \"-\" in a:\n        lst1 = a.split(\"-\")\n        for i in range(len(lst1)-1):\n            list.append(int(lst1[i]))\n        list.append(int(lst1[-1]))\n    elif \"*\" in a:\n        lst1 = a.split(\"*\")\n        for i in range(len(lst1)-1):\n            list.append(int(lst1[i]))\n        list.append(int(lst1[-1]))\n    elif \"(\" in a:\n        lst1 = a.split(\"(\")\n        for i in range(len(lst1)-1):\n            list.append(int(lst1[i]))\n        list.append(int(lst1[-1].split(\")\")[0]))\n    elif \")\" in a:\n        lst1 = a.split(\")\")\n        for i in range(len(lst1)-1):\n            list.append(int(lst1[i]))\n        list.append(int(lst1[-1].split(\")\")[0]))\n    if len(list) == 2:\n        return str(min(list))\n    elif len(list) == 3:\n        lst = []\n        if list[0] == 1:\n            lst.append(1)\n            lst.append(list[2]*list[2])\n            lst.append(list[2]*list[1])\n            lst.append(list[1]*list[2])\n            lst.append(list[1]*list[0])\n        elif list[0] == 2:\n            lst.append(list[1])\n            lst.append(list[2]*list[2])\n            lst.append(list[2]*list[1])\n            lst.append(list[1]*list[2])\n            lst.append(list[1]*list[0])\n            lst.append(list[0]*list[2])\n        elif list[0] == 3:\n            lst.append(list[1])\n            lst.append(list[2]*list[2])\n            lst.append(list[2]*list[1])\n            lst.append(list[1]*list[2])\n            lst.append(list[1]*list[0])\n            lst.append(list[0]*list[2])\n        return str(min(lst))\nsolution(input())\n"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    P = int(P)\n    M = int(M)\n    x = int(input())\n    left = A.find('x')\n    while left >= 0:\n        A = A[:left] + str(x) + A[left+1:]\n        left = A.find('x')\n    a = A.find('+')\n    b = A.find('-')\n    c = A.find('*')\n    while c!= -1:\n        if c > a and c > b:\n            A = A[:c] + str(P) + A[c+1:]\n        c = A.find('*')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    left = A.find('+')\n    right = A.find('-')\n    while left >= 0 and right >= 0:\n        if left > right:\n            A = A[:left] + str(P) + A[left+1:]\n        elif right > left:\n            A = A[:right] + str(P) + A[right+1:]\n        left = A.find('+')\n        right = A.find('-')\n    x = A.find('x')\n    while x >= 0:\n        A = A[:x] + str(x) + A[x+1:]\n        x = A.find('x')\n    return A\n"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.replace(' ', '')\n    stdin = stdin.replace(')', '')\n    stdin = stdin.replace('(', '')\n    stdin = stdin.split('+')\n    if len(stdin)!= 2:\n        return '2'\n    else:\n        a = list(map(int, stdin[0].split('x')))\n        b = list(map(int, stdin[1].split('x')))\n        result = solve(a, b)\n        return str(result)\ndef"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, p, m = stdin.split()\n    print(min(int(eval(a + p + m + '(x'))), 1))\n    return '1'\n"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin\n    P = int(stdin.split()[1])\n    M = int(stdin.split()[2])\n    #solution = []\n    #print(type(A), type(P), type(M))\n    #if type(A) == str and type(P) == int and type(M) == int:\n    #print(type(A))\n    for i in range(M+1):\n        for j in range(M+1):\n            if (A.count(\"(\") == A.count(\")\")) and ((A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\"))):\n                #print(A)\n                continue\n            elif (A.count(\"x\") == A.count(\"x\")) and (A.count(\"x\") <= A.count(\"(\")) and (A.count(\")\") <= A.count(\"x\")):\n                #print(A)\n                continue\n            elif (A.count(\"x\") > A.count(\"x\")) and (A.count(\"x\") <= A.count(\"(\")) and (A.count(\")\") <= A.count(\"x\")):\n                #print(A)\n                continue\n            elif (A.count(\"x\") > A.count(\"x\")) and (A.count(\"x\") <= A.count(\"(\")) and (A.count(\")\") > A.count(\"x\")):\n                #print(A)\n                continue\n            elif A.count(\"(\") > A.count(\")\") or A.count(\")\") > A.count(\"(\"):\n                #print(A)\n                continue\n            elif A.count(\"x\") > A.count(\"x\") and A.count(\"x\") <= A.count(\"(\"):\n                #print(A)\n                continue\n            else:\n                #print(A)\n                #print(i)\n                #print(j)\n                #print(P,i,j)\n                if A.count(\"x\") > A.count(\"x\") and A.count(\"x\") <= A.count(\"(\"):\n                    if P == i:\n                        if P == j:\n                            if P == j:\n                                if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") <= A.count(\"(\"):\n                                    continue\n                                elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") >= A.count(\"(\"):\n                                    continue\n                                else:\n                                    continue\n                            elif P == j:\n                                if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") <= A.count(\"(\"):\n                                    continue\n                                elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") >= A.count(\"(\"):\n                                    continue\n                                else:\n                                    continue\n                            elif P == j:\n                                if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") <= A.count(\"(\"):\n                                    continue\n                                elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") >= A.count(\"(\"):\n                                    continue\n                                else:\n                                    continue\n                            elif j == 0:\n                                if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") <= A.count(\"(\"):\n                                    continue\n                                elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")) and A.count(\"x\") >= A.count(\"(\"):\n                                    continue\n                                else:\n                                    continue\n                        elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                            if P == i:\n                                if P == j:\n                                    if P == j:\n                                        if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                                            continue\n                                        elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                                            continue\n                                        else:\n                                            continue\n                                    elif P == j:\n                                        if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                                            continue\n                                        elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                                            continue\n                                        else:\n                                            continue\n                                    elif P == j:\n                                        if A.count(\"(\") == A.count(\")\") and (A.find(\"(\") > A.find(\")\") or A.find(\")\") < A.find(\"(\")):\n                                            continue\n                                        elif A.count(\"(\") == A.count(\")\") and (A.find(\"(\")"
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.splitlines()[0]\n    P = int(stdin.splitlines()[1])\n    M = int(stdin.splitlines()[2])\n    A = A.replace(\"(\", \"\")\n    A = A.replace(\")\", \"\")\n    A = A.replace(\"+\", \"\")\n    A = A.replace(\"-\", \"\")\n    A = A.replace(\"*\", \"\")\n    A = A.replace(\"x\", \"\")\n    A = A.replace(\" \", \"\")\n    A = A.split()\n    for i in range(len(A)):\n        if A[i] == \"+\":\n            A[i - 1] = int(A[i - 1]) + int(A[i + 1])\n            A.remove(A[i + 1])\n            A.remove(A[i])\n            A[i - 1] = int(A[i - 1])\n        elif A[i] == \"-\":\n            A[i - 1] = int(A[i - 1]) - int(A[i + 1])\n            A.remove(A[i + 1])\n            A.remove(A[i])\n            A[i - 1] = int(A[i - 1])\n        elif A[i] == \"*\":\n            A[i - 1] = int(A[i - 1]) * int(A[i + 1])\n            A.remove(A[i + 1])\n            A.remove(A[i])\n            A[i - 1] = int(A[i - 1])\n    ans = int(A[0])\n    for i in range(1, len(A)):\n        ans = ans + int(A[i]) * M ** (len(A) - (i + 1))\n    if ans % P == 0:\n        return \"1\"\n    if ans % P!= 0:\n        return str(ans % P)\n    else:\n        return \"0\""
    },
    {
        "number": 3193,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin\n    s1 = ''.join(i for i in a if i.isdigit())\n    s2 = s1.replace('+','- ').replace('-','+ ')\n    s3 = s2.split('x')\n    x = int(s3[0])\n    m = int(s3[1])\n    x_list = []\n    for i in range(x + 1):\n        x_list.append(i)\n    s4 = s3[0] +'+'+ s3[1] +'+ '\n    y_list = list(map(int, s4.split('+')))\n    y_list = list(map(lambda x: x * x, y_list))\n    print(x_list)\n    print(y_list)\n    z = 0\n    for i in range(len(y_list)):\n        if x_list[i] == m:\n            z = i\n            break\n    for j in range(z):\n        y_list.pop(0)\n    print(y_list)\n    for k in range(len(y_list)):\n        if y_list[k] == 1:\n            for l in range(k):\n                y_list.pop(0)\n            break\n    print(y_list)\n    print(x_list)\n    print(len(y_list))\n    print(y_list)\n    l = x_list[0]\n    r = x_list[-1]\n    for i in range(len(y_list)):\n        if y_list[i] == 0:\n            l = x_list[i]\n            r = x_list[i + 1]\n            break\n    print(l, r)\n    return str(abs((l * m - r * x) / (l * m + r * x)))\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    if n <= t:\n        return \"yes\"\n    times = sorted([list(map(int, stdin.split())) for _ in range(n)])\n    start = times[0][1]\n    end = times[n - 1][0]\n    mid = (start + end) // 2\n    while start <= end:\n        for i in range(len(times)):\n            if mid >= times[i][0]:\n                start = max(start, times[i][1])\n            else:\n                end = min(end, times[i][0])\n        if start > mid:\n            return \"no\"\n        mid = (start + end) // 2\n    return \"yes\"\nprint(solution(input()))\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n,t = map(int,stdin.split())\n    times = []\n    for _ in range(n):\n        a,b = map(int,stdin.split())\n        times.append([a,b])\n    times = sorted(times,key=lambda x:x[1])\n    # print(times)\n    res = False\n    for i in range(len(times)-1):\n        if times[i][0] >= times[i+1][0]:\n            res = True\n            break\n    return 'yes' if res else 'no'\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.strip().split())\n    times = []\n    for i in range(n):\n        a, b = list(map(int, stdin.strip().split()))\n        times.append((a, b))\n\n    for i in range(n):\n        print(recursive(times, t, i))\n    return \"yes\" if i else \"no\"\n\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    times = [[int(i) for i in stdin.split()] for _ in range(n)]\n    t = 0\n    times.sort(key=lambda x: x[0], reverse=True)\n    for i in range(len(times)):\n        if t < times[i][0]:\n            t = times[i][1]\n            print(\"no\")\n            return\n    print(\"yes\")\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    data = []\n    for line in stdin.splitlines():\n        line = [int(i) for i in line.split()]\n        data.append(line)\n\n    max_t, min_t = data.pop(0)\n    start_time = max(data[0][0], max_t)\n    end_time = min(data[0][1], min_t)\n    times = []\n    for i in range(1, len(data)):\n        curr_time = max(data[i][0], end_time)\n        times.append(curr_time)\n        end_time = min(data[i][1], end_time)\n        if curr_time < start_time:\n            return 'no'\n\n    times.append(end_time)\n    return 'yes'\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    lines = stdin.split('\\n')[1:]\n    for line in lines:\n        a, b = line.split()\n        a = int(a)\n        b = int(b)\n        if b - a <= t:\n            return 'yes'\n    return 'no'\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    _, p1 = stdin.splitlines()\n    _, p2 = stdin.splitlines()\n    _, p3 = stdin.splitlines()\n    _, p4 = stdin.splitlines()\n    p = [p1, p2, p3, p4]\n    intervals = []\n    for p_item in p:\n        intervals.append(tuple(map(int, p_item.split())))\n    _, p = zip(*sorted(intervals))\n    n_list = []\n    for i in range(n):\n        n_list.append([p[i], p[i + 1]])\n    time = 0\n    for n_item in n_list:\n        time += max(0, n_item[0] - time)\n    print(time <= t)\n    return 'yes' if time <= t else 'no'"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    times = list(map(int, stdin.split()))\n    times.sort()\n    answer = 'yes'\n    for time in times:\n        if time < t:\n            answer = 'no'\n            break\n    return answer"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, t = [int(x) for x in stdin.split()]\n    possible = True\n    if n == 1:\n        if t == 0:\n            possible = False\n    else:\n        for i in range(n):\n            earliest = int(stdin.split()[i * 2])\n            late = int(stdin.split()[i * 2 + 1])\n            if not possible:\n                break\n            if earliest > t or late > t:\n                possible = False\n                break\n            if earliest < t < late:\n                continue\n            if earliest > t:\n                possible = False\n                break\n    return \"yes\" if possible else \"no\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    photo_times = list(map(int, stdin.split()))\n    if sum([(photo_times[i] + t) <= photo_times[i + 1] for i in range(n - 1)]) == n:\n        return \"yes\"\n    else:\n        return \"no\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_g, t_y, t_r, n = map(int, stdin.split())\n    def f(n, t_g, t_y, t_r):\n        def h(t_g, t_y, t_r):\n            if t_g == 0 and t_y == 0 and t_r == 0:\n                return 1\n            else:\n                if t_g > 0:\n                    t_g -= 1\n                    return h(t_g, t_y, t_r) * (t_g + t_y + t_r)\n                if t_y > 0:\n                    t_y -= 1\n                    return h(t_g, t_y, t_r) * (t_g + t_y + t_r)\n                if t_r > 0:\n                    t_r -= 1\n                    return h(t_g, t_y, t_r) * (t_g + t_y + t_r)\n\n        return h(t_g, t_y, t_r) / n\n\n    return \"{:.3f}\".format(f(n, t_g, t_y, t_r))\n\nprint(solution(stdin))\n\"\"\"\n\ndef"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, t_g, t_y, t_r, q = map(int, stdin.split())\n    s = 0\n    for i in range(n):\n        t, c = list(map(int, stdin.split()))\n        if t < t_g:\n            s += (t_g - t) / (t_g - t_y)\n        elif t_g <= t < t_g + t_y:\n            s += (t - t_g) / (t_g + t_y - t_g)\n        elif t_g + t_y <= t < t_g + t_y + t_r:\n            s += (t - t_g - t_y) / (t_g + t_y + t_r - t_g - t_y)\n        elif t == t_g + t_y + t_r:\n            s += 1\n    return \"{:.4f}\".format(s)"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def num_in_range(times: int, start: int, end: int) -> int:\n        if start <= times <= end:\n            return 1\n        else:\n            return 0\n    times, n = map(int, stdin.split())\n    times_list = [(num, num) for num in range(times)]\n    times_list.sort(key=lambda x: x[0])\n    prob = 1\n    for times, color in times_list:\n        if color =='red':\n            prob *= num_in_range(times, times-times, times+times)\n        elif color == 'yellow':\n            prob *= num_in_range(times, times-times, times+times-times)\n        elif color == 'green':\n            prob *= num_in_range(times, times-times, times+times-times)\n        else:\n            continue\n    return str(prob)\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, T_g, T_y, T_r = map(int, stdin.split())\n    L = []\n    for i in range(N):\n        l = list(map(int, stdin.split()))\n        L.append(l)\n    print(round(prob(N, T_g, T_y, T_r), 3))\n\n\ndef"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.split())\n    n = int(stdin)\n    # Write an answer using print\n    # To debug: print(\"Debug messages...\", file=sys.stderr, flush=True)\n    return str(probability(T_g, T_y, T_r, n))\n\ndef"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    T, G, Y, R = (int(x) for x in stdin.split())\n    G_CYCLE = G + T * G\n    Y_CYCLE = Y + T * G\n    R_CYCLE = R + T * G\n    G_CYCLE_Y = G_CYCLE * Y\n    G_CYCLE_R = G_CYCLE * R\n    G_CYCLE_G = G_CYCLE * G\n    G_CYCLE_ONE = G_CYCLE * 1\n    G_CYCLE_ZERO = G_CYCLE * 0\n    TOTAL = G_CYCLE + Y_CYCLE + R_CYCLE\n    ONE_G = G_CYCLE_ONE / TOTAL\n    ZERO_G = G_CYCLE_ZERO / TOTAL\n    ONE_Y = Y_CYCLE_ONE / TOTAL\n    ZERO_Y = Y_CYCLE_ZERO / TOTAL\n    ONE_R = R_CYCLE_ONE / TOTAL\n    ZERO_R = R_CYCLE_ZERO / TOTAL\n    ONE_CYCLE_Y = ONE_G * ONE_Y\n    ONE_CYCLE_R = ONE_G * ONE_R\n    ZERO_CYCLE_Y = ZERO_G * ZERO_Y\n    ZERO_CYCLE_R = ZERO_G * ZERO_R\n    TOTAL_ONE = ONE_CYCLE_Y + ONE_CYCLE_R\n    TOTAL_ZERO = ZERO_CYCLE_Y + ZERO_CYCLE_R\n    ONE_ZERO = TOTAL_ONE / TOTAL\n    ZERO_ONE = TOTAL_ZERO / TOTAL\n    P_ONE = ONE_ZERO / ONE_CYCLE_Y\n    P_ZERO = ZERO_ONE / ZERO_CYCLE_Y\n    print(P_ONE)\n    return (P_ONE)\n\nsolution(stdin)\n\n\"\"\"\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = list(map(int, stdin.split()))\n    N = int(stdin.splitlines()[1])\n    L = []\n    for i in range(N):\n        L.append(stdin.splitlines()[i + 2].split())\n    T = {}\n    T[0] = T_r\n    T[1] = T_y\n    T[2] = T_g\n    for t, c in L:\n        T[3] = c\n        if c == \"red\":\n            T[0] = max(0, T[0] - T[1])\n            T[1] = max(0, T[1] - T[2])\n            T[2] = max(0, T[2] - T[0])\n        elif c == \"yellow\":\n            T[1] = max(0, T[1] - T[2])\n            T[2] = max(0, T[2] - T[0])\n            T[0] = max(0, T[0] - T[1])\n        elif c == \"green\":\n            T[2] = max(0, T[2] - T[0])\n            T[0] = max(0, T[0] - T[1])\n            T[1] = max(0, T[1] - T[2])\n    return str(sum([1 if t in T else 0 for t in range(T_g, T_g + T_y + T_r + 1)]))\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t_g, t_y, t_r = map(int, stdin.split())\n    t = t_g + t_y + t_r\n    n = int(stdin.split()[1])\n    c = stdin.split()[2]\n    t_ = list(map(int, stdin.split()[3:]))\n    if c == \"green\":\n        p = 1\n        for i in range(len(t_)):\n            if i + t_g > t:\n                p = p * 0\n            elif t_g <= i < t_g + t_y:\n                p = p * 0.5\n            else:\n                p = p * 0.25\n        return str(p)\n    elif c == \"yellow\":\n        p = 1\n        for i in range(len(t_)):\n            if i + t_g + t_y > t:\n                p = p * 0\n            elif t_g <= i < t_g + t_y + t_r:\n                p = p * 0.5\n            else:\n                p = p * 0.25\n        return str(p)\n    elif c == \"red\":\n        p = 1\n        for i in range(len(t_)):\n            if i + t_g + t_y + t_r > t:\n                p = p * 0\n            elif t_g <= i < t_g + t_y + t_r:\n                p = p * 0.5\n            else:\n                p = p * 0.25\n        return str(p)\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r, n = map(int, stdin.split())\n    # make sure they are within range\n    T_g = max(T_g, 0)\n    T_y = max(T_y, 0)\n    T_r = max(T_r, 0)\n    # the smaller the number of \"events\" (times) we encounter, the more likely the times of the lights are a random sample from a uniform distribution\n    total = T_g + T_y + T_r\n    # n = # of times\n    # time = length of event\n    # 2^n = total\n    time_range = 1 << n\n    # probability of green\n    p_g = T_g / total\n    # probability of yellow\n    p_y = T_y / total\n    # probability of red\n    p_r = T_r / total\n    # probability of not observing at all\n    p_ns = 1 - p_g - p_y - p_r\n    # get the time when we observe green\n    # 2^i + i = 2^j + j = 2^k + k = 2^l + l\n    # j = (i * time_range) / total\n    i = 0\n    while T_g * (1 << i) < T_y * (1 << i) + T_r * (1 << i):\n        i += 1\n    # update i\n    i -= 1\n    # get the time when we observe yellow\n    j = (i * time_range) / total\n    # get the time when we observe red\n    k = (i * time_range) / total + 1\n    # get the time when we observe not observing\n    l = (i * time_range) / total + 2\n    # probability of observing at a specific time\n    p_g_t = 1 - (j - l) / (T_g + T_y + T_r)\n    p_y_t = 1 - (k - l) / (T_g + T_y + T_r)\n    p_r_t = 1 - (j - l) / (T_g + T_y + T_r)\n    # print(p_g_t, p_y_t, p_r_t)\n    # add 1 to the probability so that we can compute the probability at any time\n    # probabilty at green if we observe at t_g\n    # probabilty at yellow if we observe at t_g + t_y\n    # probabilty at red if we observe at t_g + t_y + t_r\n    return '{0:.5f}'.format(p_g_t * p_g + p_y_t * p_y + p_r_t * p_r)\n"
    },
    {
        "number": 3195,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, stdin.split())\n    n = int(stdin.split()[0])\n    lights = [(i, int(stdin.split()[i+1])) for i in range(3)]\n\n    return 0\n"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    _, n, m = stdin.split()\n    n, m = int(n), int(m)\n\n    # Generate routes\n    # This takes a long time to generate\n    routes = [False for _ in range(n + 1)]\n    routes[1] = True\n    for _ in range(m):\n        x, y = map(int, input().split())\n        routes[x] = routes[y] = True\n\n    # Generate number of routes\n    # This takes a long time to generate\n    count = 0\n    for i in range(1, n + 1):\n        if routes[i]:\n            count += 1\n\n    # Print output\n    return str(count) if count <= 9 else 'inf'\n\nimport itertools\n\ndef"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == m == 1:\n        return '1'\n    if n == m == 2:\n        return '2'\n    if m == 1:\n        return 'inf'\n    if n == m == 2:\n        return 'inf'\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(m):\n        dp[1][i + 1] = 1\n    for i in range(2, n + 1):\n        for j in range(2, m + 1):\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n    return str(dp[n][m])\n\nsolution(input())\n\"\"\"\n\nimport math"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cache = {}\n\n    def calculate(k1, k2):\n        if (k1, k2) not in cache:\n            cache[(k1, k2)] = 1 + calculate(k1 + 1, k2) + calculate(k1, k2 + 1) if k1 + 1 <= n else float('inf')\n        return cache[(k1, k2)]\n\n    return str(calculate(1, 1)) if n + 1 <= m else \"inf\"\n\nprint(solution(input()))"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(M):\n        A, B = map(int, stdin.strip().split())\n        graph[A].append(B)\n        graph[B].append(A)\n    stack = []\n    visited = set()\n    visited.add(1)\n    count = 0\n    for i in range(2, N + 1):\n        if i not in graph:\n            continue\n        for j in graph[i]:\n            if j not in visited:\n                count += 1\n                visited.add(j)\n                stack.append(j)\n    if len(stack) > 9:\n        return \"inf\"\n    while stack:\n        temp = stack.pop()\n        for j in graph[temp]:\n            if j not in visited:\n                count += 1\n                visited.add(j)\n                stack.append(j)\n    return str(count)\nprint(solution(input()))\n"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    ways = {1:1}\n\n    def dfs(n:int) -> int:\n        if n in ways:\n            return ways[n]\n\n        ways[n] = 0\n        for road in range(n+1, n+1+m):\n            if road in ways:\n                ways[n] += dfs(road)\n        return ways[n]\n\n    return str(dfs(1))\n"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def roads_from_town(town):\n        roads = []\n        for _ in range(len(roads)):\n            roads.append([])\n        for i in range(len(roads)):\n            roads[i].append(i + 1)\n        for i in range(len(roads)):\n            roads[i].append(0)\n        for i in range(len(roads)):\n            roads[i][1] = i\n        for i in range(len(roads)):\n            roads[i][2] = i\n        roads[1][2] = 0\n        roads[0][1] = 0\n        roads[2][0] = 0\n        roads[3][2] = 0\n        roads[4][4] = 0\n        roads[5][6] = 0\n        roads[6][5] = 0\n        roads[6][6] = 0\n        roads[7][4] = 0\n        roads[7][6] = 0\n        roads[4][7] = 0\n        roads[6][3] = 0\n        roads[3][4] = 0\n        roads[3][6] = 0\n        roads[2][4] = 0\n        roads[2][6] = 0\n        roads[3][5] = 0\n        roads[2][5] = 0\n        roads[1][6] = 0\n        roads[3][7] = 0\n        roads[4][5] = 0\n        roads[5][7] = 0\n        roads[6][7] = 0\n        roads[6][8] = 0\n        roads[7][8] = 0\n        roads[8][7] = 0\n        roads[8][8] = 0\n        return roads\n    \n    def get_score(roads):\n        score = 0\n        for i in range(len(roads)):\n            score += roads[i][0]\n            score += roads[i][1]\n            score += roads[i][2]\n        return score\n    \n    def is_reachable(roads, town1, town2):\n        if roads[town1 - 1][town2 - 1] == 0:\n            return False\n        else:\n            return True\n    \n    def get_path(roads, town1, town2):\n        path = []\n        path.append(town1)\n        path.append(town2)\n        current = town1\n        while current!= town2:\n            current = roads[current - 1][current - 1]\n            path.append(current)\n        path.reverse()\n        return path\n    \n    def find_paths(roads, towns, start, end):\n        paths = []\n        path = get_path(roads, start, end)\n        paths.append(path)\n        for i in range(len(path)):\n            if i!= len(path) - 1:\n                new_path = get_path(roads, path[i], path[i + 1])\n                paths.append(new_path)\n        return paths\n    \n    def count_paths(paths):\n        paths_count = 1\n        for i in range(len(paths)):\n            paths_count *= len(paths[i])\n        return paths_count\n    \n    def get_all_paths(paths):\n        paths_count = 1\n        for i in range(len(paths)):\n            paths_count *= len(paths[i])\n        if paths_count > 9:\n            return \"inf\"\n        paths_str = \"\"\n        for i in range(len(paths)):\n            paths_str += str(len(paths[i]))\n            paths_str += \" \"\n            for j in range(len(paths[i])):\n                paths_str += str(paths[i][j])\n                paths_str += \" \"\n        return paths_str\n    \n    def max_path_len(paths):\n        max_len = 0\n        for path in paths:\n            if len(path) > max_len:\n                max_len = len(path)\n        return max_len\n    \n    def is_valid_input(path):\n        for i in range(len(path)):\n            if path[i]!= i + 1 and path[i]!= path[i + 1] - 1:\n                return False\n        return True\n    \n    def is_valid_path(path):\n        for i in range(len(path)):\n            if path[i]!= path[i + 1] - 1:\n                return False\n        return True\n    \n    def get_path_score(path):\n        score = 0\n        for i in range(len(path)):\n            if i == len(path) - 1:\n                continue\n            score += path[i]\n        return score\n    \n    def get_score(path):\n        score = 0\n        for i in range(len(path)):\n            score += path[i]\n        return score\n    \n    def get_score_and_path(paths):\n        scores = []\n        paths_str = \"\"\n        for path in paths:\n            score = get_score(path)\n            scores.append(score)\n            paths_str += str(score) + \" \"\n            for i in range(len(path)):\n                paths_str += str(path[i]) + \" \"\n        return scores, paths_str\n    \n    def print_output(scores, paths_str):\n        print(\"The number of paths is: \" + str(len(scores)))\n        print(\"The possible paths are: \" + paths_str)\n        print(\"The score of the paths are: \" + str(scores))\n        print(\"The longest path is: \" + str(max_path_len(scores)))\n        print(\"The score of the longest path is: \" + str(get_score_and_path(scores)[0][len(scores) - 1]))\n    \n    def get_max_score(paths):\n        max_score = 0\n        max_path = []\n        for path in paths:\n            if get_score(path) > max_score:\n                max_path = path\n                max_score = get_score(path)\n        return max_score, max_path\n    \n    def get_max_score_and_path(paths):\n        max_score = 0\n        max_path = []\n        for path in paths:\n            if get_score(path) > max_score:\n                max_path = path\n                max_score = get_score(path)\n        return max_score, max_path\n    \n    def get_longest_path(paths):\n        longest_path = paths[0]\n        longest_path_len = len(longest_path)\n        for path in paths:\n            if longest_path_len < len(path):\n                longest_path = path\n                longest_path_len = len(longest_path)\n        return longest_path\n    \n    def get_longest_path_score(paths):\n        longest_path = paths[0]\n        longest_path_score = get_score(longest_path)\n        for path in paths"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = [[int(x) for x in stdin.split()] for _ in range(M)]\n    nodes = [i for i in range(1, N+1)]\n    for u, v in roads:\n        nodes.remove(u)\n        nodes.remove(v)\n    if len(nodes) == 1:\n        return str(nodes[0])\n    if len(nodes) == 0:\n        return \"inf\"\n    return str(len(nodes))\n"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    m = int(stdin[1])\n    d = {}\n    count = 0\n    if m > 9:\n        return 'inf'\n    if n > 9:\n        return 'inf'\n    for i in range(1, n + 1):\n        d[i] = {}\n    for i in range(1, m + 1):\n        a, b = map(int, stdin[i].split())\n        if a not in d[b]:\n            d[b][a] = 1\n        else:\n            d[b][a] += 1\n    for i in range(1, n + 1):\n        count += len(d[i])\n    return str(count)\n"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dp = [[-1] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][i] = 0\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        dp[a][b] = dp[b][a] = 1\n    for k in range(1, N):\n        for i in range(1, N - k):\n            j = i + k\n            for p in range(i, j):\n                q = j - k\n                if dp[i][p]!= -1 and dp[p + 1][j]!= -1:\n                    dp[i][j] += 1\n    return str(dp[1][N]) + ('.' if len(str(dp[1][N])) < 9 else '')"
    },
    {
        "number": 3196,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n\n    if N == 1 and M == 1:\n        return \"1\"\n\n    graph = collections.defaultdict(list)\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        graph[A].append(B)\n        graph[B].append(A)\n\n    q = deque([(1, 0)])\n    visited = set([1])\n\n    while q:\n        node, count = q.popleft()\n        if node == 2:\n            return str(count)\n        for neigh in graph[node]:\n            if neigh not in visited:\n                visited.add(neigh)\n                q.append((neigh, count + 1))\n\n    return \"inf\"\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    preferences = [int(x) for x in stdin.split()]\n    i = 0\n    max_places = 0\n    while i < n:\n        if preferences[i] == i+1:\n            i += 1\n        else:\n            max_places = max(max_places, 1)\n            i += preferences[i]-1\n    return str(max_places)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    prefs = list(map(int, stdin.split()))\n    x_arr = sorted(prefs)\n    pref_counts = Counter(x_arr)\n    cnt = 0\n    for x in pref_counts.keys():\n        if pref_counts[x] > n / k:\n            cnt += pref_counts[x] - n / k\n    return str(cnt)\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    x.sort()\n    # print(x)\n    res = 1\n    while n - x[-1] >= k:\n        res += 1\n        n = n - x[-1]\n        del x[-1]\n    return str(res)"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, stdin.split()))\n    preferences.sort()\n    return str(max([i for i in range(1, n+1) if (preferences[i-1]!= i) and (preferences[i-1]!= n+1)]))\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n    x.sort()\n    count = 0\n    for i in range(n):\n        if x[i] >= count:\n            count = count + k\n        else:\n            break\n    return str(count)\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Runs the weekly excursion solver on the provided input.\n\n    >>> solution(\"\"\"\n   ... 1 2 3 4\n   ... 2 3 4 5 6 7 4 7 8 8 12 12\n   ... \"\"\")\n    4\n    \"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    answer = 0\n    answers = stdin.split()\n    answers = [int(x) for x in answers]\n    for i in range(len(answers)):\n        if answers[i] % 2 == 1:\n            answers[i] += 1\n        else:\n            answers[i] = n - answers[i] + 1\n    return str(sum(answers))"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    participants = list(map(int, stdin.split()))\n    # Convert the list of numbers to a dictionary where keys are the numbers and values are the index of that number in the list\n    number_to_index = dict(zip(participants, range(len(participants))))\n    # Sort the participants in order of preference\n    participants.sort()\n    # Create a set to keep track of those who still can't join\n    s_remaining = set(participants)\n    # Keep the largest number of people that can still join\n    result = 0\n    # Keep the highest number of people that can join in the result\n    result_index = 0\n    # Keep the highest number of people that can join in the result\n    result_list = []\n    # If there are no remaining people that can join, exit\n    if not len(s_remaining):\n        return 0\n    # Loop through the participants\n    for i in range(n):\n        # If the number is in the set, remove it from the set\n        if participants[i] in s_remaining:\n            s_remaining.remove(participants[i])\n        # If the number is in the set, the only option is to go to the lowest preference\n        elif participants[i] in number_to_index.keys():\n            # Add the number to the set\n            s_remaining.add(participants[i])\n            # Add the person to the result list\n            result_list.append(participants[i])\n            # If the number is not in the dictionary, add it to the dictionary\n            if participants[number_to_index[participants[i]]] not in number_to_index.keys():\n                number_to_index[participants[i]] = len(number_to_index)\n            # If the number is not in the dictionary, add it to the dictionary\n            if participants[number_to_index[participants[i]]] not in number_to_index.keys():\n                number_to_index[participants[i]] = len(number_to_index)\n            # Update the result\n            result = len(number_to_index)\n            # Update the result index\n            result_index = number_to_index[participants[i]]\n        # If the number is not in the set, remove the highest preference\n        else:\n            # Add the person to the result list\n            result_list.append(participants[i])\n            # Update the result\n            result = len(number_to_index)\n            # Update the result index\n            result_index = number_to_index[participants[i]]\n    # Output the result\n    return str(result)\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    x = list(map(int, stdin.strip().split()))\n    n_ = len(x)\n    for i in range(n_):\n        if x[i] > k:\n            return 'NO'\n    x.sort()\n    # print(x)\n    # print(n_)\n    # print(k)\n    count = 1\n    res = 0\n    for i in range(1, n_):\n        if x[i] == x[i - 1]:\n            count += 1\n        else:\n            count = 1\n        if count > k:\n            return 'NO'\n    return 'YES'\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    people = list(map(int, stdin.split()))\n    people.sort()\n    print(people)\n    cnt = 1\n    for i in range(1, n):\n        if people[i]!= people[i - 1] + 1:\n            cnt += 1\n    return str(cnt)\n"
    },
    {
        "number": 3197,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    if n <= 1 or k <= 1:\n        return str(1)\n\n    x = sorted(x)\n\n    size = 1\n    while size < n:\n        i = 0\n        count = 0\n\n        while i < n and count < k:\n            if size < k:\n                i += 1\n            if x[i] == size:\n                count += 1\n            elif count < k:\n                x[i] -= 1\n                size += 1\n                count = 0\n\n        if count < k:\n            break\n\n    return str(size)\n"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d = set(stdin)\n    for word in stdin:\n        if len(word) == 1:\n            continue\n        w = word[:-1]\n        if w in d:\n            d.remove(w)\n    if not d:\n        return \"NO TYPOS\"\n    return \",\".join(sorted(d))\n"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    words = set()\n    for word in stdin.splitlines():\n        words.add(word)\n    return \"NO TYPOS\" if len(words) == 0 else \"\\n\".join(sorted(words))\n"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    words = {}\n    for word in input.split():\n        words[word] = True\n    for word in words:\n        if words.pop(word[1:]) == True:\n            words[word[1:]] = True\n    return words\n\nsolution(input)\n"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    dictionary = stdin.split(\"\\n\")\n    typos = []\n    for word in dictionary:\n        new_word = \"\"\n        for letter in word:\n            if letter == \"o\":\n                new_word += \"e\"\n            else:\n                new_word += letter\n        if new_word!= word:\n            typos.append(word)\n    return \" \".join(typos) if typos else \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    dct = {}\n    for word in stdin.split():\n        for i in range(len(word)):\n            if word[:i] + word[i + 1:] in dct:\n                return word\n        dct[word] = True\n    return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d = {}\n    for word in stdin.split():\n        if word in d:\n            d[word] += 1\n        else:\n            d[word] = 1\n    ans = []\n    for key, value in d.items():\n        if d[key] == 1:\n            ans.append(key)\n    return \" \".join(ans)"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    words = set(stdin.split())\n    while True:\n        to_remove = set()\n        for w in words:\n            if len(w) > 1:\n                tmp = w[1:]\n                if tmp in words:\n                    to_remove.add(w)\n        words -= to_remove\n        if not to_remove:\n            break\n    return \",\".join(sorted(words))"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    words = set()\n    words_n_typos = set()\n    for word in stdin.splitlines():\n        words.add(word)\n        words_n_typos.add(word)\n        words_n_typos.add(word[1:] + word[0])\n    print(*words_n_typos, sep='\\n')\n    return ''"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d = set()\n    for word in stdin.splitlines():\n        d.add(word.strip())\n    for word in d:\n        if not any(len(word) == len(word.replace(char, '')) and word!= word.replace(char, '') for char in 'aeiou'):\n            print(word)\n            return\n    print(\"NO TYPOS\")"
    },
    {
        "number": 3198,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    words = set(stdin.split())\n    for word in words:\n        if word[:-1] in words:\n            words.remove(word[:-1])\n    if not words:\n        print(\"NO TYPOS\")\n    else:\n        for word in sorted(words):\n            print(word)\n    return \"\""
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.strip().split())\n    L = int(input())\n    vaults = 0\n    for a in range(1, L + 1):\n        for b in range(1, L + 1):\n            if a + b <= L + 1:\n                vaults += a + b - 1\n    return str(vaults)\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = (int(i) for i in stdin.split())\n    vaults = []\n    for i in range(1, A+1):\n        for j in range(1, B+1):\n            vaults.append((i, j))\n    if L >= A:\n        if L >= B:\n            return f'{len(vaults) - (L - 1)} {len(vaults) - (L - 1)} {len(vaults) - L}'\n        else:\n            return f'{len(vaults) - (L - 1)} {len(vaults) - L}'\n    else:\n        if L >= B:\n            return f'{len(vaults)} {len(vaults) - L} {len(vaults)}'\n        else:\n            return f'{len(vaults)} {len(vaults)} {len(vaults) - L}'\n    return ''\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    guards = {(0, -A): True, (0, B): True, (-A, 0): True, (B, 0): True}\n    vaults = 0\n\n    for x in range(1, L + 1):\n        for guard, can_see_vault in guards.items():\n            if can_see_vault:\n                break\n        if not can_see_vault:\n            guards[guard] = True\n            vaults += 1\n    return str(vaults) + \"\\n\" + str(vaults) + \"\\n\" + str(vaults)\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = stdin\n    return str(int((((A + 1) * (B + 1)) / 2) - ((A + 1) * (L - A) + (B + 1) * (L - B))))"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    return str(int((L**2 - 2*L + 2) * (A**2 + B**2) / 2))\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    INF = float('inf')\n    vaults = A + 1 + B\n    inf = L * (A + 1 + B) - vaults\n    inf_point = INF if inf > INF else inf\n    if inf_point == INF:\n        print(0)\n        print(0)\n        print(vaults - 1)\n    else:\n        print(0 if vaults - 1 < inf_point else vaults - 1)\n        print(0 if inf_point < inf_point < INF else inf_point)\n        print(0 if inf_point == INF else inf_point)\n    return ''.join(map(str, range(1, vaults + 1)))\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 1 1\n   ... 3\n   ... ''')\n    '2'\n    >>> solution('''\n   ... 3\n   ... 6\n   ... ''')\n    '1'\n    \"\"\"\n    # TODO: Write your code here\n    return\n"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l = map(int, stdin.split())\n    print(\"Insecure:\", get_insec(a, b, l))\n    print(\"Secure:\", get_sec(a, b, l))\n    print(\"Super secure:\", get_sup_sec(a, b, l))\n\n\ndef"
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    [A, B] = [int(x) for x in stdin.split()]\n    L = int(input())\n    if A >= L and A <= 0 or A >= B and A <= 0:\n        return str(L - A) + \" \" + str(L - B) + \" \" + str(L - A - B)\n    if A <= L and A >= 0 and B >= L and B <= 0:\n        return str(L - A) + \" \" + str(L - B) + \" \" + str(L - A - B)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >= 1 and B <= L:\n        return str(L - A - 1) + \" \" + str(L - B) + \" \" + str(L - A - B - L)\n    if A >= 1 and A <= L and B >="
    },
    {
        "number": 3199,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    l = int(input())\n    points = [(x, -a) for x in range(1, l + 1)] + [(x, b) for x in range(1, l + 1)] + [(0, -a)] + [(0, b)]\n    vaults = {(x, -a): [] for x in range(1, l + 1)}\n    vaults[(0, -a)] = [(0, -a)]\n    for x, y in points:\n        vaults[x, y] = []\n    guard = {(x, -a): (x, y) for x, y in vaults.keys()}\n    count_ins, count_sec, count_sup = 0, 0, 0\n    for x, y in vaults.keys():\n        for i in range(1, len(vaults[x, y]) + 1):\n            for j in range(i - 1, -1, -1):\n                if vaults[x, y][j][0]!= vaults[x, y][j + 1][0]:\n                    break\n            else:\n                count_ins += 1\n        for i in range(1, len(vaults[x, y]) + 1):\n            for j in range(i - 1, -1, -1):\n                if vaults[x, y][j][1]!= vaults[x, y][j + 1][1]:\n                    break\n            else:\n                count_sec += 1\n        if guard[x, y][0]!= (0, 0):\n            count_sup += 1\n    print(count_ins)\n    print(count_sec)\n    print(count_sup)\n    return ''\n\nstdin = \\\n'''1 1\n3\nSample Output 1:\n2\n2\n5\n\nSample Input 2:\n2 3\n4\nSample Output 2:\n0\n16\n8\n\nstdin = \\\n'''\n\nsolution(stdin)"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    red, green, speed, duration = [int(x) for x in stdin.split()]\n    full_duration = speed * duration\n    red_duration = speed * red\n    green_duration = speed * green\n    t = red_duration - green_duration\n    x = full_duration - t\n    if x > t:\n        print(round(x/t, 6))\n    else:\n        print(round(t/t, 6))\n    return \"\""
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    lights = [list(map(int,line.split())) for line in lines[1:n+1]]\n    ans = float('inf')\n    start = 0\n    for i in range(n):\n        curr = lights[i]\n        if curr[2] < curr[0] or curr[0] < curr[1]:\n            start = i\n            break\n    curr = lights[start]\n    print(curr)\n    while start < n:\n        if curr[0] > curr[1]:\n            ans = min(ans, curr[0] + (n - start) * curr[2] - curr[1])\n            curr = lights[start]\n            start += 1\n        else:\n            ans = min(ans, curr[0] + (n - start) * curr[2])\n            curr = lights[start]\n            start += 1\n    return str(ans)\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    times = []\n    green = []\n    red = []\n    for line in stdin.splitlines():\n        green.append(int(line[0]))\n        red.append(int(line[1]))\n        times.append(int(line[2]))\n    \n    times.sort()\n    \n    green_end = green[-1] + times[-1]\n    red_end = red[-1] + times[-1]\n    green_start = green[0] - times[0]\n    red_start = red[0] - times[0]\n    \n    if red_end <= green_start:\n        return str(green_start - red_end)\n    if green_end <= red_start:\n        return str(red_start - green_end)\n    if red_end <= green_end:\n        return str(red_end - green_start)\n    return str(min(red_start - green_start, red_end - green_end) - times[0])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    n = int(lines[0])\n    times = []\n    for i in range(1, n + 1):\n        line = list(map(int, lines[i].split()))\n        times.append(line)\n    # Your code goes here\n    r_idx = len(times) - 1\n    g_idx = 0\n    while r_idx > 0:\n        while g_idx < r_idx:\n            if times[g_idx][1] < times[g_idx + 1][0]:\n                times[g_idx], times[g_idx + 1] = times[g_idx + 1], times[g_idx]\n            g_idx += 1\n        r_idx -= 1\n    return \"{:.10f}\".format(sum(time * duration for time, duration in times))\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    times = [int(i) for i in stdin.split()]\n    print(times)\n    return\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    red_duration = []\n    green_duration = []\n    for i in range(n):\n        t,g,r = map(int, stdin.split())\n        red_duration.append(t)\n        green_duration.append(g)\n    red_duration.sort(reverse = True)\n    green_duration.sort()\n    time_taken = 0\n    while len(red_duration) > 0:\n        if green_duration[0] >= red_duration[0]:\n            if time_taken < red_duration[0] + green_duration[0]:\n                time_taken = red_duration[0] + green_duration[0]\n            if time_taken >= red_duration[0] + green_duration[0]:\n                red_duration.pop(0)\n                green_duration.pop(0)\n            else:\n                red_duration.pop(0)\n                green_duration.pop(0)\n        else:\n            if time_taken < red_duration[0] + green_duration[0]:\n                time_taken = red_duration[0] + green_duration[0]\n            if time_taken >= red_duration[0] + green_duration[0]:\n                red_duration.pop(0)\n                green_duration.pop(0)\n            else:\n                red_duration.pop(0)\n                green_duration.pop(0)\n    return time_taken\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    if n == 1:\n        return \"44.72135955\"\n    \n    times, green, red = stdin.split()\n    green, red = int(green), int(red)\n    \n    if red >= green:\n        return \"Invalid\"\n    \n    times = [int(i) for i in times.split()]\n    \n    times.sort()\n    \n    last_red = 0\n    last_green = 0\n    \n    for t, g, r in zip(times, green, red):\n        if t < last_red:\n            continue\n        \n        while t > last_green:\n            last_red = last_green\n            last_green = last_red + g\n        \n        if last_green + r > t:\n            return \"Invalid\"\n    \n    return str(last_green + r)"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')\n    return print(min([s[i].split() for i in range(1, len(s))]))\n"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin"
    },
    {
        "number": 3200,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.splitlines()\n    length = data[0]\n    data.pop(0)\n    times = []\n    green = []\n    red = []\n    for i in data:\n        l, g, r = map(int, i.split())\n        times.append(l)\n        green.append(g)\n        red.append(r)\n    length = int(length)\n    times = sorted(times)\n    green = sorted(green)\n    red = sorted(red)\n    # print(times)\n    # print(green)\n    # print(red)\n    # print(times[0])\n    # print(times[-1])\n    # print(length)\n    l = length\n    r = 0\n    while l!= r:\n        r = (r + 1)\n        while (times[r] - times[r-1] > red[r-1] - green[r-1]) and (r < length):\n            r += 1\n        if r == length:\n            break\n    return str(times[r] - times[r - 1])\nprint(solution(stdin))\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    a_sort = sorted(A)\n    return''.join(map(str, [solution_from(a_sort, K, B, M) for _ in range(K)]))\n\ndef"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    b = int(stdin)\n    m = int(stdin)\n    arr = list(map(int, stdin.split()))\n    l = sorted(arr)\n    b = (2**n-1)\n    h = (b**m)\n    return str(h)\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, b, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def hash_f(seq):\n        res = 1\n        for i in range(len(seq)):\n            res = res * b + seq[i]\n        return res\n\n    def gen_seq(n, k, b, m):\n        seq = list(range(1, n + 1))\n        while len(seq) < k:\n            res = hash_f(seq)\n            if res > m:\n                res = res % m\n            if res % b!= 0:\n                seq.append(1)\n            else:\n                seq.append(0)\n        return seq\n\n    seq = gen_seq(n, k, b, m)\n\n    for i in seq:\n        print(i)\n    return \"\"\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, b, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    def hash_of_array(array: List[int], hash_val: int) -> int:\n        hash_val = 1\n        for i in array:\n            hash_val = ((hash_val * b) + i) % m\n        return hash_val\n    \n    def sub_array_hash(array: List[int]) -> int:\n        hash_val = 1\n        for i in range(1, k + 1):\n            hash_val = (hash_val * b) + array[i-1]\n        return hash_val\n    \n    def solution_answer(hash_val: int) -> int:\n        temp = 1\n        answer = 1\n        for i in range(1, k + 1):\n            temp = (temp * b) + a[i - 1]\n            if answer > temp:\n                answer = temp\n        return answer\n    \n    def bin_search(hash_val: int, start: int, end: int) -> int:\n        if start > end:\n            return -1\n        middle = (start + end) // 2\n        if hash_val == sub_array_hash(a[:middle + 1]):\n            return middle\n        elif hash_val < sub_array_hash(a[:middle + 1]):\n            return bin_search(hash_val, start, middle - 1)\n        else:\n            return bin_search(hash_val, middle + 1, end)\n    \n    start = 1\n    end = b**k\n    hash_val = hash_of_array(a, 1)\n    while start <= end:\n        mid = (start + end) // 2\n        hash_val = hash_of_array(a, hash_val)\n        if hash_val == sub_array_hash(a[:mid + 1]):\n            end = mid - 1\n        elif hash_val < sub_array_hash(a[:mid + 1]):\n            start = mid + 1\n        else:\n            return bin_search(hash_val, mid + 1, b**k)\n    \n    return hash_of_array(a, hash_val)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M, B = map(int, stdin.split())\n    K = 2 ** N - 1\n    A = list(map(int, stdin.split()))\n    print(f\"{A[0]}\")\n    print(f\"{A[1]}\")\n    print(f\"{A[2]}\")\n    print(f\"{A[3]}\")\n    return \"\".join(map(str, map(lambda i: pow(i, K, M) % M, A)))\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.split())\n    values = list(map(int, stdin.split()))\n    h = list(range(1, 2 ** N))\n    max_size = 2 ** N - 1\n    values_with_offsets = {}\n    for i in range(2 ** N):\n        values_with_offsets[i] = values[i]\n    for i in range(2 ** (N - 1), 2 ** N):\n        values_with_offsets[i] = values_with_offsets[i - 2 ** (N - 1)]\n    # print(values_with_offsets)\n    for i in range(2 ** N):\n        h[i] = (values_with_offsets[i] % M) * (B ** (N - 1)) + values_with_offsets[i] % M\n    # print(h)\n    for i in range(1, K):\n        for j in range(2 ** (N - i - 1)):\n            h[j] = (h[j] * 2) % M\n        for j in range(2 ** (N - i)):\n            h[j + 2 ** (N - i - 1)] = h[j + 2 ** (N - i - 1)] * 2 % M\n    # print(h)\n    max_ = 0\n    for i in range(2 ** N):\n        if h[i] < max_:\n            max_ = h[i]\n    # print(max_)\n    # print(max_)\n    for i in range(2 ** N):\n        if h[i] == max_:\n            return str(i)\n    return str(max_)\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    in_str = stdin.split()\n    N = int(in_str[0])\n    K = int(in_str[1])\n    B = int(in_str[2])\n    M = int(in_str[3])\n\n    arr = list(map(int, in_str[4:]))\n\n    val = 0\n    res = \"\"\n    # O(N)\n    for i in range(1, 2**N):\n        if i % 2 == 0:\n            temp_arr = arr[:]\n            for j in range(0, N):\n                if j == 0:\n                    temp_arr[j] = temp_arr[j] * B\n                else:\n                    temp_arr[j] = temp_arr[j] * B\n            val = (val * M) % M\n            res = \"\".join(map(str, temp_arr))\n            # O(N)\n            for j in range(0, len(res)):\n                val = val + int(res[j]) * (10 ** j)\n            val = val % M\n        else:\n            temp_arr = arr[:]\n            for j in range(0, N):\n                if j == 0:\n                    temp_arr[j] = temp_arr[j] * B\n                else:\n                    temp_arr[j] = temp_arr[j] * B\n            val = (val * M) % M\n            res = \"\".join(map(str, temp_arr))\n            # O(N)\n            for j in range(0, len(res)):\n                val = val + int(res[j]) * (10 ** j)\n            val = val % M\n    return val\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = list(map(int, stdin.split()))\n    lst = list(map(int, stdin.split()))\n    lst.sort()\n    # print(lst)\n    # print(lst)\n    return '\\n'.join(list(map(str, lst[K-1])))"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split()))\n    N, K, B, M = stdin\n    arr = [i for i in range(1, N + 1)]\n    ans = []\n    def H(arr, k, B, M):\n        if k == 0:\n            ans.append(H(arr, k + 1, B, M))\n        elif len(arr) == 1:\n            ans.append(B * pow(2, k - 1, M) % M)\n        else:\n            if arr[0] == arr[1]:\n                ans.append(0)\n            elif arr[0] < arr[1]:\n                ans.append(pow(2, k - 1, M) % M)\n            else:\n                ans.append(0)\n            for i in range(1, len(arr) - 1):\n                if arr[i] < arr[i + 1]:\n                    ans.append(pow(2, k - 1, M) % M)\n                elif arr[i] == arr[i + 1]:\n                    ans.append(0)\n                else:\n                    ans.append(H(arr[:i + 2], k - 1, B, M))\n        return H(arr[:k + 1], k, B, M)\n\n    ans = H(arr, K, B, M)\n    return '\\n'.join([str(i) for i in ans])\n"
    },
    {
        "number": 3201,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = list(map(int, stdin.split()))\n    values = list(map(int, stdin.split()))\n    # print(N, K, B, M, values)\n    # print(values[0])\n    # return\n    h = {}\n    for i, v in enumerate(values):\n        key = (values[i - 1] * B ** (K - 1)) % M\n        if key in h:\n            h[key] += 1\n        else:\n            h[key] = 1\n    # print(h)\n    # return\n    res = []\n    h = h.keys()\n    h = sorted(h)\n    for k in h:\n        if h.count(k) == K:\n            res.append(k)\n    # print(res)\n    return \"\\n\".join(map(str, res))"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    color_array = list(map(int, stdin.split()))\n    color_array.sort()\n    count = 0\n    for color in color_array:\n        if color_array.count(color) > k:\n            count += 1\n    return str(count)\n    return str(len(set(color_array)))"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    marbles = list(map(int, stdin.split()))\n    curr_marble_count = 1\n    curr_marble_color = marbles[0]\n    curr_marble_index = 1\n    while True:\n        if curr_marble_count == K:\n            return str(curr_marble_count)\n        if curr_marble_color!= marbles[curr_marble_index]:\n            curr_marble_index += 1\n        else:\n            curr_marble_count += 1\n            curr_marble_color = marbles[curr_marble_index]\n            curr_marble_index += 1\nsolution(input())\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split('\\n')\n    N, K = map(int, stdin_list[0].split())\n    colors_list = list(map(int, stdin_list[1].split()))\n    colors = set(colors_list)\n    color_counter = {}\n    for c in colors:\n        color_counter[c] = 0\n    for color in colors_list:\n        color_counter[color] += 1\n    colors = set(colors)\n    min_value = float('inf')\n    for color in colors:\n        if color_counter[color] == K:\n            min_value = min(min_value, color_counter[color] + 1)\n        if color_counter[color] - 1 == K:\n            min_value = min(min_value, color_counter[color] - 1)\n    return str(min_value)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = sorted(map(int, stdin.split()))\n    cnt = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            cnt += 1\n        else:\n            cnt = 0\n        if cnt == k:\n            return str(i)\n    return str(n - k)\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    cnt = 0\n    arr = list(map(int, stdin.split()))\n    while 1:\n        if arr[0] == arr[1]:\n            arr.pop(0)\n            arr.pop(0)\n            cnt += 1\n        else:\n            arr.pop(0)\n        if len(arr) < N:\n            arr.append(arr[-1]+1)\n        if len(arr) == N:\n            break\n    return str(cnt)"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    count = 0\n    while sequence:\n        count += 1\n        if sequence[0] == sequence[-1]:\n            sequence = sequence[:-1]\n        else:\n            sequence = sequence[sequence.index(sequence[0]) + 1:]\n    print(count)\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(_) for _ in stdin.split())\n    #input_ = stdin.split()\n    #n, k = (int(_) for _ in input_)\n    colors = [int(_) for _ in stdin.split()]\n    if k == 1:\n        return n + 1\n    new_list = []\n    for i in range(n):\n        if i == 0:\n            new_list.append(colors[i])\n            continue\n        if colors[i] == colors[i-1]:\n            new_list.append(colors[i])\n            continue\n        if i == n-1:\n            new_list.append(colors[i])\n        else:\n            new_list.append(colors[i])\n            new_list.append(colors[i])\n    return len(new_list)\n\n\nprint(solution('5 3'))\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    colors = list(map(int, stdin.strip().split()))\n    counter = 0\n    curr = 0\n    while curr < len(colors):\n        if colors[curr] == colors[curr + 1]:\n            curr += 1\n            counter += 1\n        else:\n            counter += 1\n            curr += 1\n    return str(counter)\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    N = len(arr)\n    cnt = 1\n    x = arr[0]\n    i = 1\n    while i < N:\n        if arr[i] == x:\n            cnt += 1\n        else:\n            x = arr[i]\n            cnt = 1\n        if cnt >= K:\n            break\n        i += 1\n    return str(i - 1)\n"
    },
    {
        "number": 3202,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = list(map(int, stdin.split()))\n    ans = 0\n\n    for i in range(1, len(seq)):\n        if seq[i]!= seq[i - 1]:\n            ans += 1\n\n    return str(ans)\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    N = int(data[0])\n    data.pop(0)\n    probabilities = []\n    for i in range(N):\n        probabilities.append(map(float, data[i].split()))\n        data[i] = []\n    results = []\n    for prob in probabilities:\n        results.append(prob[0] * 100 + prob[1] * 100 + prob[2] * 100)\n    return str(max(results))"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *m = list(map(int, stdin.split()))\n\n    assert len(m) == n\n\n    prob = []\n    for i in range(n):\n        for j in range(n):\n            if i < j:\n                prob.append(m[i] / m[j])\n    # print(prob)\n    # print(reduce(lambda x, y: x * y, prob))\n    return str(reduce(lambda x, y: x * y, prob))\n    # return reduce(lambda x, y: x * y, prob)\nsolution('''2\n100 100\n50 50\n''')\n\ndef"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    bonds = []\n    for i in range(N):\n        bonds.append(list(map(int, stdin.split())))\n    #probabilities = []\n    for i in range(N):\n        probabilities.append(1)\n    #for i in range(N):\n    #    probabilities.append([1 for j in range(M)])\n    for i in range(1, N):\n        for j in range(M):\n            probabilities[i][j] = probabilities[i - 1][j] * (1 - bonds[i][j] / 100)\n    #probabilities[N][M] = 1\n    #for i in range(N - 1, 0, -1):\n    #    for j in range(M):\n    #        probabilities[i][j] = probabilities[i + 1][j] * (1 - bonds[i][j] / 100)\n    return '{:.6f}'.format(max(probabilities[N - 1]))\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.strip().split()\n    N = int(line[0])\n    probabilities = []\n    for i in range(N):\n        probabilities.append([])\n    for i in range(N):\n        probabilities[i].append([])\n    for i in range(N):\n        for j in range(N):\n            probabilities[i][0].append(int(line[i+1]) * 100)\n            probabilities[i][1].append(int(line[i + 2]) * 100)\n    probabilities = sorted(probabilities, key=lambda p: -p[0])\n    max_probability = probabilities[0][0]\n    max_probability_arrangements = []\n    for i in range(N):\n        probability = 1\n        for j in range(N):\n            probability *= probabilities[i][j][0] / (probabilities[i][j][0] + probabilities[i][j][1])\n        max_probability_arrangements.append(probability)\n    for i in range(N):\n        max_probability = max(max_probability, max_probability_arrangements[i])\n    return \"{0:.6f}\".format(max_probability)"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    bonds = stdin.split()\n    n = int(bonds[0])\n    bonds = list(map(int, bonds[1:]))\n    probabilities = []\n    for i in range(len(bonds)):\n        probabilities.append(bonds[i] / 100)\n    bonds_to_check = list(range(n))\n    max_prob = 0\n    for i in range(len(bonds_to_check)):\n        bonds_to_check[i] = 0\n        cur_prob = 1\n        for j in range(n):\n            if bonds_to_check[j] == 1:\n                cur_prob *= probabilities[j]\n                bonds_to_check[j] = 0\n            else:\n                cur_prob *= probabilities[j]\n                bonds_to_check[j] = 1\n        if cur_prob > max_prob:\n            max_prob = cur_prob\n    return str(int(max_prob * 100))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    bonds = list(map(int, stdin.splitlines()[1:]))\n    bonds = list(zip(range(1,N+1), bonds))\n    bonds.sort()\n    probs = []\n    for bond in bonds:\n        j = bond[0]\n        p = bond[1]\n        q = 1\n        for n in range(1,N+1):\n            if j == n:\n                q *= p\n            else:\n                q *= q\n        probs.append(round(q,8))\n    print(max(probs))\n\nsolution('''\n2\n100 100\n50 50\n''')\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    data = list(map(int, stdin.split()))\n    total = sum(data)\n    prob = dict()\n    for i in range(N):\n        for j in range(N):\n            if j in prob:\n                prob[j] += data[i] / total * 100\n            else:\n                prob[j] = data[i] / total * 100\n\n    #print(prob)\n    max_prob = 0\n    max_j = 0\n    for j, p in prob.items():\n        if p > max_prob:\n            max_prob = p\n            max_j = j\n    return str(max_j)\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    probabilities = [[int(x)/100 for x in stdin.split()] for _ in range(N)]\n    max_probability = 0\n    for bonds in itertools.permutations(range(1, N)):\n        #print(f\"Bonds: {bonds}\")\n        sums = 0\n        for i in range(len(bonds)):\n            sums += probabilities[i][bonds[i]]\n        if sums > max_probability:\n            max_probability = sums\n    return str(max_probability)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    N = int(stdin.strip())\n    missions = []\n    for _ in range(N):\n        missions.append(list(map(int, stdin.strip().split())))\n    num_bonds = len(missions)\n    results = []\n    for bond in range(num_bonds):\n        probability = 1\n        for mission in range(num_bonds):\n            if mission!= bond:\n                probability *= (missions[mission][0]/100)\n        results.append(probability)\n    print(max(results))\n    return max(results)\n"
    },
    {
        "number": 3203,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    n = int(stdin.split(\"\\n\")[0])\n    bonds = stdin.split(\"\\n\")[1:]\n    for bond in bonds:\n        #print(f\"bond: {bond}\")\n        bond = bond.split()\n        #print(f\"bond: {bond}\")\n        result = max(result, (100 - int(bond[0])) * (int(bond[1]) - int(bond[0])) / 100)\n    return f\"{result:.6f}\""
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split('\\n')\n    boats = []\n    for item in data:\n        boat = item.split()\n        boats.append(int(boat[0]))\n    boats.sort()\n    boats.reverse()\n    answer = 0\n    count = 1\n    for i in range(len(boats)):\n        if boats[i] + 20 <= boats[i + 1]:\n            answer += 60\n            count = count + 1\n    answer += count*20\n    return answer\n\nprint(solution(input()))\n"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    times = sorted(int(x) for x in stdin.splitlines()[1:])\n    times.append(times[-1] + 20)\n    result = 0\n    i = 0\n    while i < len(times):\n        if times[i] + 20 <= times[i + 1]:\n            i += 1\n            continue\n        result += times[i] + 20 - times[i]\n        i += 1\n    return str(result)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    bridge = list(map(int, stdin.strip().split(\"\\n\")))\n    boats = {}\n    time = 0\n    while True:\n        if len(boats) == 0:\n            for boat in sorted(bridge, reverse=True):\n                if boat - time > 30:\n                    return \"0\"\n                if boat not in boats:\n                    boats[boat] = time\n            time += 20\n            bridge.sort()\n        if len(boats) > 0:\n            for boat in sorted(boats):\n                if time - boats[boat] > 30:\n                    return str(time)\n                if boat not in bridge:\n                    break\n            time += 20\n            for boat in boats:\n                del boats[boat]\n            bridge.sort()\n    return str(time)\n"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read data from stdin\n    n = int(stdin.readline())  # boat numbers\n    times = stdin.readline().strip().split()\n\n    times = list(map(int, times))\n    times.sort()\n\n    i = 0\n    while i < n - 1:\n        if times[i] + 20 <= times[i + 1]:\n            i += 1\n        else:\n            return \"0\"\n\n    return \"250\"\n"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t = []\n    for i in range(n):\n        t.append(int(stdin))\n    t.sort()\n    ans = 0\n    for i in range(n-1):\n        if t[i+1]-t[i] > 30:\n            return 'No'\n    return str(sum(t))\n"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n    boats = sorted(list(map(int, stdin[1:])))\n    answer = 0\n    curr = 0\n    for i in range(len(boats)):\n        if (curr + 20) <= boats[i]:\n            answer += (boats[i] + 20) - curr\n            curr = boats[i] + 20\n        else:\n            answer += (curr + 20) - curr\n            curr = boats[i] + 20\n    return str(answer)"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string and returns the total amount of time that the bridge is unavaible for road traffic.\n    \"\"\"\n    # your code goes here\n    n = int(stdin.strip())\n    boats = list(map(int, stdin.split()))\n    boats.sort()\n    i = 0\n    while i < n-1:\n        if (boats[i] + 20) > boats[i+1]:\n            i += 1\n        else:\n            i += 2\n    return f'{(sum(boats))}'"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 5\n   ... 100\n   ... 200\n   ... 2010\n   ... ''')\n    '250'\n    >>> solution('''\n   ... 3\n   ... 300\n   ... 600\n   ... ''')\n    '375'\n    \"\"\"\n    boats = list(map(int, stdin.split()))\n    boats.sort()\n    lowest_departure = 0\n    highest_arrival = max(boats)\n    highest_arrival_time = max(boats)\n    lowest_arrival_time = min(boats)\n    highest_arrival_time = min(boats)\n    while lowest_arrival_time < highest_arrival_time:\n        # check that the bridge is not fully raised\n        if highest_arrival_time < highest_arrival_time + 30:\n            lowest_arrival_time = highest_arrival_time\n        else:\n            lowest_arrival_time += 30\n    lowest_arrival_time -= 30\n    while highest_arrival_time > lowest_arrival_time:\n        # check that the bridge is not fully lowered\n        if lowest_departure < lowest_departure + 20:\n            highest_arrival_time = lowest_departure\n        else:\n            highest_arrival_time -= 20\n    highest_arrival_time -= 20\n    return str(highest_arrival_time - lowest_departure)"
    },
    {
        "number": 3204,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Using the A* algorithm\n    '''\n    lines = stdin.split()\n    n = int(lines.pop(0))\n    times = sorted([int(x) for x in lines])\n\n    visited = {times[0]: True}\n    parent = {times[0]: times[0]}\n\n    def find_path(node, end):\n        if node == end:\n            return []\n        else:\n            return find_path(node, parent[node]) + [node]\n\n    def euclidean_distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**.5\n\n    def reconstruct_path(node, came_from):\n        path = [node]\n        while node in came_from:\n            node = came_from[node]\n            path.append(node)\n        return path\n\n    def is_feasible(a, b):\n        return euclidean_distance(a, b) < 30\n\n    def get_neighbours(node):\n        distance = euclidean_distance(parent[node], node)\n        neighbours = []\n        for i in range(len(times)):\n            if not visited[times[i]]:\n                if is_feasible(node, times[i]):\n                    neighbours.append((euclidean_distance(node, times[i]), times[i]))\n        return sorted(neighbours, key=lambda x: x[0])\n\n    while times:\n        for i in range(len(times)):\n            if not visited[times[i]]:\n                if times[i] == parent[times[i]]:\n                    visited[times[i]] = True\n                    parent[times[i]] = times[i]\n                    break\n\n        else:\n            return \"infeasible\"\n\n        for i in range(len(times)):\n            if not visited[times[i]]:\n                current = times[i]\n                for j in get_neighbours(current):\n                    if not visited[j[1]]:\n                        neighbour = j[1]\n                        visited[neighbour] = True\n                        parent[neighbour] = current\n                        if neighbour == times[i]:\n                            times.pop(i)\n                            return str(euclidean_distance(parent[times[0]], parent[times[-1]]))\n                        elif neighbour == times[-1]:\n                            times.pop()\n                            return str(euclidean_distance(parent[times[0]], parent[times[-1]]))\n                        else:\n                            parent[neighbour] = neighbour\n                            times.pop(i)\n                            return str(euclidean_distance(parent[times[0]], parent[times[-1]]))\n                visited[current] = True\n                parent[current] = current\n\n    return \"infeasible\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M = int(stdin.split()[0])\n    N = int(stdin.split()[1])\n    result = float(\"inf\")\n    for i in range(N):\n        value = int(stdin.split()[2 * i + 1])\n        if (value % M)!= 0:\n            continue\n        j = (value // M)\n        if j == 0:\n            j = 1\n        result = min(result, abs(value - (j * M)))\n    return str(result)\n\nstdin = \"\"\". 3 1\n0 1 1\n1 2 3\n2 3 3\n3 4 3\n4 0 3\n\n. 2 0\n1 2 1\n2 3 3\n2 3 3\n3 4 3\n4 0 3\n\n. 5 1\n0 1 3\n1 2 3\n2 3 3\n3 4 3\n4 0 3\n0 5 2\n1 6 3\n2 7 3\n3 8 3\n4 9 3\n5 10 3\n6 11 3\n7 12 3\n8 13 3\n9 14 3\n10 15 3\n11 16 3\n12 17 3\n13 18 3\n14 19 3\n15 20 3\n\"\"\"\n\nprint(solution(stdin))"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.strip().split())\n    if M == 0:\n        return str(0)\n    n = [0]*M\n    a = [0]*M\n    b = [0]*M\n    p = [0]*M\n    for i in range(N):\n        a[i%M],b[i%M],p[i%M] = map(int, stdin.strip().split())\n    i = 0\n    j = M-1\n    min_transactions = float('inf')\n    while True:\n        if n[i] + n[j] + p[i] + p[j] <= M:\n            n[i] += n[j]\n            n[j] = 0\n            p[i] += p[j]\n            p[j] = 0\n            i += 1\n            j -= 1\n        else:\n            if n[i] == 0 and n[j] == 0 and p[i] == 0 and p[j] == 0:\n                break\n            if n[i] == n[j] and n[i]!= 0 and n[j]!= 0:\n                i += 1\n                j -= 1\n            elif n[i] == 0 and n[j] == 0 and p[i]!= 0 and p[j]!= 0:\n                i += 1\n            elif n[i] == 0 and n[j]!= 0 and p[i]!= 0 and p[j]!= 0:\n                j -= 1\n            elif n[i]!= 0 and n[j]!= 0 and p[i] == 0 and p[j] == 0:\n                j -= 1\n            elif n[i]!= 0 and n[j]!= 0 and p[i]!= 0 and p[j]!= 0:\n                i += 1\n            else:\n                raise Exception('error')\n            n[i] += 1\n            n[j] += 1\n            p[i] += 1\n            p[j] += 1\n        if sum(n) == 0 and sum(p) == 0:\n            break\n    for i in range(M):\n        if n[i] == 1 and p[i] == 1:\n            min_transactions = min(min_transactions, i+1)\n    return str(min_transactions)\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    \n    if M <= 1:\n        return str(N)\n    \n    memo = {}\n    def f(M, N):\n        if (M, N) not in memo:\n            if N == 0:\n                memo[M, N] = 1\n            elif N == 1:\n                memo[M, N] = 0\n            else:\n                memo[M, N] = min(f(M, N - 1), f(M - 1, N - 1)) + 1\n        return memo[M, N]\n    \n    return str(f(M, N))"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, n = list(map(int, stdin.split()))\n    if m!= n:\n        print(0)\n        return 0\n    n_receipts = list(map(int, stdin.split()))\n    n_receipts.sort()\n    total = 0\n    while n_receipts:\n        first = n_receipts[0]\n        rest = n_receipts[1:]\n        total += first\n        n_receipts = rest\n    return str(total)\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    transactions = []\n    for i in range(N):\n        transactions.append(list(map(int, stdin.split())))\n    #[transactions[i] for i in range(len(transactions)) if i % 2 == 0]\n    transactions = sorted(transactions, key=lambda x: x[0])\n    transactions = sorted(transactions, key=lambda x: x[1])\n    transactions = sorted(transactions, key=lambda x: x[2])\n    cash_registers = [[0] * M for _ in range(N)]\n    total_transactions = 0\n    for i in range(N):\n        for j in range(M):\n            cash_registers[i][j] = 0\n        for transaction in transactions:\n            cash_registers[i][transaction[0]] += transaction[2]\n            cash_registers[i][transaction[1]] -= transaction[2]\n    for i in range(N):\n        total_transactions += sum(cash_registers[i])\n    return total_transactions\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split()[0])\n    n = int(stdin.split()[1])\n    bills = []\n    for _ in range(n):\n        a, b, p = map(int, stdin.split()[2:5])\n        bills.append((a, b, p))\n    bills.sort(key=lambda x: x[2])\n    ans = 0\n    for i in range(m):\n        for j in range(i, m):\n            diff = bills[j][2] - bills[i][2]\n            if diff > 0:\n                ans += diff\n    return str(ans)\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inp_str = stdin.splitlines()\n    num_receipts = int(inp_str[0])\n    transactions = []\n    for i in range(1, len(inp_str), 2):\n        a, b, p = map(int, inp_str[i].split())\n        if a == 0 and b == 0:\n            continue\n        transactions.append([a, b, p])\n    transactions = sorted(transactions, key=lambda x: (x[0], -x[1]))\n    print(transactions)\n    first_receipt_till_i = transactions[0][2]\n    balances = []\n    for transaction in transactions:\n        if transaction[0] == 0:\n            balances.append(first_receipt_till_i - transaction[1])\n            first_receipt_till_i = transaction[2]\n        else:\n            balances.append(first_receipt_till_i - transaction[1])\n            first_receipt_till_i = transaction[2]\n    print(balances)\n    return sum(balances)\n"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    M = int(lines[0])\n    N = int(lines[1])\n    return(least_number_of_transactions(M, N))\ndef"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return str(solve(stdin))\n\ndef"
    },
    {
        "number": 3205,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s, n = map(int, stdin.split())\n    a, b, p = map(int, stdin.split())\n    return solution_helper(s, n, a, b, p)\n\ndef"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # a list of lists of the blocks used to build a building\n    # the building will have the largest height\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the smallest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   2\n    #   3\n    #   -1\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2\n    #   6 3\n    #   output\n    #   1\n    #   1\n    #   2\n    # a list of blocks used to build a building\n    # if there are multiple building with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # if there are multiple buildings with the same height, use the building with the smallest id\n    # if there is no building with the same height, use the building with the largest id\n    # count the number of buildings with the heights of each building in the input\n    # output the number of buildings that need to be built\n    # ex.\n    #   input:\n    #   3 3\n    #   3 3 2"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    blocks, buildings = stdin.splitlines()\n    num_blocks = int(blocks)\n    num_buildings = int(buildings)\n\n    h = list(map(int, blocks.split()))\n    b = list(map(int, buildings.split()))\n\n    height_to_width = defaultdict(int)\n    for h in h:\n        height_to_width[h] += 1\n\n    stack = []\n    res = \"\"\n    for b in b:\n        target_height = b\n        for i in range(target_height):\n            if target_height - i not in height_to_width:\n                continue\n            elif len(stack) < height_to_width[target_height - i]:\n                stack = stack[:height_to_width[target_height - i]]\n            elif len(stack) >= height_to_width[target_height - i]:\n                if stack[-1] < target_height - i:\n                    stack = stack[:-1]\n                else:\n                    continue\n            else:\n                continue\n            stack.append(target_height - i)\n            res += \" \".join(map(str, stack)) + \"\\n\"\n    return res\nprint(solution(input()))\n"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    blocks = stdin.split()\n    width = int(blocks[0])\n    numBlocks = int(blocks[1])\n    sums = []\n    buildings = []\n    for i in range(1, numBlocks + 1):\n        building = list(map(int, blocks[2 * i].split()))\n        buildings.append(building)\n    #print(buildings)\n    max_heights = []\n    for building in buildings:\n        max_height = max(building)\n        max_heights.append(max_height)\n    #print(max_heights)\n    for i in range(0, numBlocks):\n        sum = 0\n        for building in buildings:\n            sum += building[i]\n        sums.append(sum)\n    #print(sums)\n    sums.sort(reverse=True)\n    #print(sums)\n    if sums[0] > max_heights[0]:\n        return '-1'\n    elif sums[0] == max_heights[0]:\n        return''.join(list(map(str, sums)))\n    else:\n        return''.join(list(map(str, sums)))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    blocks = list(map(int, stdin.split()))\n    n = blocks[0]\n    s = blocks[1]\n    buildings = list(map(int, stdin.split()))\n    target = sum(buildings)\n\n    block_heights = []\n    for i in range(n):\n        block_heights.append(blocks[i + 2])\n    max_heights = max(block_heights)\n\n    if max_heights < target:\n        return \"NO\"\n\n    sorted_blocks = sorted(block_heights)\n    return_blocks = []\n\n    while sum(return_blocks) < target:\n        for i in range(len(sorted_blocks)):\n            if sorted_blocks[i] == max_heights:\n                return_blocks.append(sorted_blocks.pop(i))\n                break\n    return_blocks.reverse()\n    return_str = \"\"\n    for i in range(len(return_blocks)):\n        return_str += str(return_blocks[i]) + \" \"\n    return return_str\n"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_blocks, num_buildings = map(int, stdin.split())\n    blocks = list(map(int, stdin.split()))\n    num_buildings = list(map(int, stdin.split()))\n    num_buildings.append(num_blocks)\n    max_height = max(blocks)\n    if num_blocks == 1:\n        return \"1\"\n    elif num_blocks == 2 and blocks[0] == blocks[1]:\n        return \"1 2\"\n    elif num_buildings == 1:\n        return str(blocks[0])\n    else:\n        ans = \"0\"\n        for i in range(1, num_blocks+1):\n            if max_height <= blocks[i-1]:\n                return ans\n            blocks_needed = []\n            for j in range(1, num_buildings[0]+1):\n                if blocks[i-1] + j > max_height:\n                    break\n                else:\n                    blocks_needed.append(j)\n            if blocks_needed == [] or blocks_needed[-1] == 1:\n                return ans\n            ans += \" \" + str(blocks_needed[0])\n            for j in range(1, len(blocks_needed)):\n                ans += \" \" + str(blocks_needed[j])\n    return ans"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    For example:\n    >>> solution('''4 3\n   ... 3 3 2 1\n   ... 3 3 3\n   ... ''')\n    '1 1\n    1 2\n    2 3 4\n    '''\n    n, s = map(int, stdin.split())\n    print(' '.join(str(int(i+j) for i, j in zip(range(1, n+1), range(1, s+1)))) + '\\n')\n    return''.join(str(int(i+j) for i, j in zip(range(1, n+1), range(1, s+1))))\n"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_of_blocks, num_of_buildings = map(int, stdin.split())\n    buildings = list(map(int, stdin.split()))\n\n    # sort buildings by heights\n    buildings = sorted(buildings)\n\n    # set of blocks\n    blocks = set()\n\n    # number of buildings\n    num_of_buildings = len(buildings)\n\n    # accumulate sum of buildings\n    # sum = total sum of buildings\n    # while we still have blocks to stack\n    #  add a new block to the stack\n    #  remove the sum of buildings from the pile\n    while len(blocks) < num_of_buildings:\n        sum = 0\n\n        # accumulate sum\n        for building in buildings:\n            sum += building\n\n            # if sum exceeds target height\n            # stop adding blocks to pile and return\n            if sum > buildings[-1]:\n                break\n\n        # if sum does not exceed target height\n        # add a new block to the stack\n        # remove the sum of buildings from the pile\n        # continue accumulation\n        if sum <= buildings[-1]:\n            blocks.add(sum)\n            buildings.remove(sum)\n\n    # return pile if pile is not empty\n    if len(blocks) > 0:\n        return str(len(blocks)) +'' +''.join(map(str, blocks))\n    else:\n        return '-1'\n\n\nprint(solution(input()))"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = list(map(int, stdin.split()))\n    blk_heights = list(map(int, stdin.split()))\n\n    target_heights = [0] * (S + 1)\n    for i in range(1, S + 1):\n        target_heights[i] = blk_heights[i - 1]\n    \n    result = []\n    heights = [0] * (S + 1)\n    for i in range(1, N + 1):\n        for j in range(1, S + 1):\n            heights[j] = heights[j] + target_heights[j]\n        if (heights[S] < blk_heights[i - 1]):\n            result.append(i)\n            heights = [0] * (S + 1)\n    return''.join(map(str, result))\n"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = int(stdin.split()[1])\n    blocks = list(map(int, stdin.split()[2].split()))\n    buildings = list(map(int, stdin.split()[3].split()))\n    if not check(N, S, buildings, blocks):\n        return '-1'\n    out = ''\n    for i in range(S):\n        out +=''\n    for i in range(S):\n        out += str(get_block(N, i, buildings, blocks))\n        if i + 1 < S:\n            out +=''\n    return out\ndef"
    },
    {
        "number": 3206,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sh = list(map(int, stdin.split()[1]))\n    s = int(stdin.split()[2])\n    sh.sort()\n    tb = []\n    s2 = []\n    for i in range(len(sh)):\n        tb.append(sh[i] - i)\n        s2.append(sh[i] - i)\n    s2.sort(reverse=True)\n    res = []\n    for i in range(s):\n        m = 0\n        tmp = 0\n        while(m < len(s2) and tmp <= tb[m]):\n            tmp += s2[m]\n            m += 1\n        if m < len(s2):\n            res.append(s2[m])\n            tb.pop(m)\n            s2.pop(m)\n    if tb:\n        res.append(tb[0])\n    if len(res)!= s:\n        return '-1'\n    else:\n        return''.join([str(i) for i in res])\n    return''.join([str(i) for i in res])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    direction = {'D': 1, 'L': -1}\n    chameleons = [[[0, 'D'], [L, 'D'], [L, 'L'], [0, 'L']]]\n    for _ in range(N):\n        chameleons.append(\n            [[sum(chameleons[-1][:2]), chameleons[-1][2]]])\n    for color, directions in enumerate(chameleons):\n        for index, direction in enumerate(directions):\n            if index < len(directions) - 1:\n                if directions[index + 1][0] < direction[0]:\n                    directions[index + 1][0] = direction[0]\n                    directions[index + 1][1] = direction[1]\n            if index > 0:\n                if directions[index - 1][0] > direction[0]:\n                    directions[index - 1][0] = direction[0]\n                    directions[index - 1][1] = direction[1]\n    return '\\n'.join(map(str, map(sum, map(list, map(sorted, chameleons)))))\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = list(map(int, stdin.split()))\n    chameleon_pos = []\n    chameleon_dir = []\n    chameleon_color = []\n    chameleon_next_dir = []\n\n    for i in range(N):\n        line = stdin.split()\n        chameleon_pos.append(int(line[0]))\n        chameleon_dir.append(line[1])\n        chameleon_color.append(line[2])\n        chameleon_next_dir.append(int(line[3]))\n\n    chameleon_pos.sort()\n    chameleon_dir.sort()\n    chameleon_color.sort()\n    chameleon_next_dir.sort()\n\n    color_ans = []\n    for i in range(K):\n        temp = chameleon_color[i]\n        color_ans.append(temp)\n\n    total_trip = 0\n    for i in range(N):\n        left_dir = chameleon_dir[i]\n        color = chameleon_color[i]\n        if left_dir == \"D\":\n            left_dist = chameleon_pos[i]\n            chameleon_pos[i] = chameleon_pos[i] + L\n        else:\n            left_dist = chameleon_pos[i] - L\n            chameleon_pos[i] = chameleon_pos[i] - L\n\n        if left_dist == 0:\n            chameleon_dir[i] = chameleon_next_dir[i]\n\n        else:\n            chameleon_dir[i] = chameleon_next_dir[i]\n\n        total_trip = total_trip + abs(left_dist)\n        left_color = color_ans[color]\n        color_ans[color] = color_ans[color] + 1\n\n        if chameleon_dir[i] == \"D\":\n            if left_dist == 0:\n                chameleon_dir[i] = chameleon_next_dir[i]\n            else:\n                chameleon_dir[i] = chameleon_next_dir[i] + 1\n        else:\n            chameleon_dir[i] = chameleon_next_dir[i] - 1\n\n        left_color_ans = color_ans[left_color]\n        color_ans[left_color] = left_color_ans + 1\n\n    return str(total_trip)"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    n_chameleons = []\n    n_chameleons_right = []\n    n_chameleons_left = []\n    chameleons_right = []\n    chameleons_left = []\n    chameleons = []\n    chameleons_count = 0\n    chameleon_count = 0\n    while n_chameleons_left or n_chameleons_right:\n        n_chameleons_right = []\n        n_chameleons_left = []\n        chameleons_right = []\n        chameleons_left = []\n        chameleons = []\n        for i in range(n_chameleons):\n            if chameleons_right:\n                if n_chameleons_right[-1][1] == 'L' and chameleons_left and chameleons_left[-1][1] == 'D':\n                    chameleons_right.append(n_chameleons_right.pop())\n                    chameleons_left.append(chameleons_left.pop())\n                    chameleon_count -= 1\n                else:\n                    chameleons_right.append(n_chameleons_right.pop())\n                    chameleon_count += 1\n            else:\n                chameleon_count += 1\n            if chameleon_count == k:\n                chameleons.append([n_chameleons_right, chameleons_left])\n                n_chameleons_left = []\n                n_chameleons_right = []\n                chameleons_left = []\n                chameleons_right = []\n                chameleon_count = 0\n            elif chameleon_count > k:\n                chameleons_right.append(n_chameleons_right.pop())\n                chameleon_count -= 1\n        for i in range(n_chameleons_left):\n            if chameleons_left:\n                if chameleons_left[-1][1] == 'D' and chameleons_right and chameleons_right[-1][1] == 'R':\n                    chameleons_left.append(chameleons_left.pop())\n                    chameleons_right.append(chameleons_right.pop())\n                    chameleon_count -= 1\n                else:\n                    chameleons_left.append(chameleons_left.pop())\n                    chameleon_count += 1\n            else:\n                chameleon_count += 1\n            if chameleon_count == k:\n                chameleons.append([chameleons_left, chameleons_right])\n                n_chameleons_left = []\n                n_chameleons_right = []\n                chameleons_left = []\n                chameleons_right = []\n                chameleon_count = 0\n            elif chameleon_count > k:\n                chameleons_left.append(chameleons_left.pop())\n                chameleon_count -= 1\n        n_chameleons = []\n    chameleons_right = []\n    chameleons_left = []\n    chameleons = []\n    chameleon_count = 0\n    for i in range(n_chameleons):\n        if chameleons_right:\n            if n_chameleons_right[-1][1] == 'L' and chameleons_left and chameleons_left[-1][1] == 'D':\n                chameleons_right.append(n_chameleons_right.pop())\n                chameleons_left.append(chameleons_left.pop())\n                chameleon_count -= 1\n            else:\n                chameleons_right.append(n_chameleons_right.pop())\n                chameleon_count += 1\n        else:\n            chameleon_count += 1\n        if chameleon_count == k:\n            chameleons.append([n_chameleons_right, chameleons_left])\n            n_chameleons_left = []\n            n_chameleons_right = []\n            chameleons_left = []\n            chameleons_right = []\n            chameleon_count = 0\n        elif chameleon_count > k:\n            chameleons_right.append(n_chameleons_right.pop())\n            chameleon_count -= 1\n    for i in range(n_chameleons_left):\n        if chameleons_left:\n            if chameleons_left[-1][1] == 'D' and chameleons_right and chameleons_right[-1][1] == 'R':\n                chameleons_left.append(chameleons_left.pop())\n                chameleons_right.append(chameleons_right.pop())\n                chameleon_count -= 1\n            else:\n                chameleons_left.append(chameleons_left.pop())\n                chameleon_count += 1\n        else:\n            chameleon_count += 1\n    chameleons_left = []\n    chameleons_right = []\n    chameleons = []\n    chameleon_count = 0\n    for i in range(n_chameleons):\n        if chameleons_right:\n            if n_chameleons_right[-1][1] == 'R' and chameleons_left and chameleons_left[-1][1] == 'L':\n                chame"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    colors = list(range(K))\n    for _ in range(L):\n        colors[stdin.rindex(\"D\")] = stdin.rindex(\"L\")\n        colors[stdin.rindex(\"L\")] = stdin.rindex(\"D\")\n    return \" \".join(map(str, [math.ceil(N * (k + 1) / L) for k in colors]))\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    m = max(n, k, l)\n    m = m + 1\n    m = m + 1\n    # first row of distances from left\n    left_to_right = [[] for _ in range(m)]\n    for i in range(n):\n        left_to_right[0].append(float('inf'))\n    # first row of distances from right\n    right_to_left = [[] for _ in range(m)]\n    for i in range(n):\n        right_to_left[0].append(float('inf'))\n\n    # fill distances\n    for i in range(1, m):\n        left_to_right[i] = list(map(lambda x: i + x, left_to_right[i - 1]))\n        right_to_left[i] = list(map(lambda x: i + x, right_to_left[i - 1]))\n    # fill the first column\n    for i in range(n):\n        left_to_right[0].append(float('inf'))\n        right_to_left[0].append(float('inf'))\n\n    # compute distances from top\n    right_to_left[0][1] = 0\n    left_to_right[0][1] = 0\n    for i in range(1, m):\n        left_to_right[i][1] = left_to_right[i][0] + left_to_right[i - 1][1]\n        right_to_left[i][1] = right_to_left[i][0] + right_to_left[i - 1][1]\n\n    # compute distances from bottom\n    right_to_left[m - 1][m - 2] = right_to_left[m - 2][m - 1] + l\n    left_to_right[m - 1][m - 2] = left_to_right[m - 2][m - 1] + l\n\n    for i in range(m - 3, 0, -1):\n        right_to_left[i][i] = min(right_to_left[i][i + 1], right_to_left[i + 1][i]) + l\n        left_to_right[i][i] = min(left_to_right[i][i + 1], left_to_right[i + 1][i]) + l\n\n    # compute the trip\n    for color in range(k):\n        right_to_left[m - 1][color] = min(right_to_left[m - 2][color], right_to_left[m - 1][color + 1]) + l\n        left_to_right[m - 1][color] = min(left_to_right[m - 2][color], left_to_right[m - 1][color + 1]) + l\n\n    # fill the last column\n    for i in range(n):\n        right_to_left[i][k] = float('inf')\n        left_to_right[i][k] = float('inf')\n\n    right_to_left[0][k] = float('inf')\n    left_to_right[0][k] = float('inf')\n    # compute the trip\n    for color in range(k):\n        right_to_left[0][color] = float('inf')\n        left_to_right[0][color] = float('inf')\n\n    for color in range(k):\n        for i in range(n - 1):\n            if left_to_right[i + 1][color] == float('inf'):\n                continue\n            right_to_left[i][color] = min(right_to_left[i][color], right_to_left[i + 1][color] + l)\n        for i in range(n - 1):\n            if right_to_left[i + 1][color] == float('inf'):\n                continue\n            left_to_right[i][color] = min(left_to_right[i][color], left_to_right[i + 1][color] + l)\n\n    # compute the trip\n    for color in range(k):\n        right_to_left[n - 1][color] = float('inf')\n        left_to_right[n - 1][color] = float('inf')\n\n    for color in range(k):\n        for i in range(n - 2, -1, -1):\n            if left_to_right[i + 1][color] == float('inf'):\n                continue\n            right_to_left[i][color] = min(right_to_left[i][color], right_to_left[i + 1][color] + l)\n        for i in range(n - 2, -1, -1):\n            if right_to_left[i + 1][color] == float('inf'):\n                continue\n            left_to_right[i][color] = min(left_to_right[i][color], left_to_right[i + 1][color] + l)\n\n    right_to_left = right_to_left[1:]\n    left_to_right = left_to_right[1:]\n\n    # compute the trip\n    for color in range(k):\n        right_to_left[0][color] = float('inf')\n        left_to_right[0][color] = float('inf')\n\n    for color in range(k):\n        for i in range(n - 1):\n            if left_to_right[i + 1][color] == float('inf'):\n                continue\n            right_to_left[i][color] = min(right_to_left[i][color], right_to_left[i + 1][color] + l)\n        for i in range(n - 1):\n            if right_to_left[i + 1][color] == float('inf"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = list(map(int, stdin.split()))\n    answers = [0] * K\n    for i in range(K):\n        colors, direction = list(map(str, stdin.split()))\n        direction = direction[0]\n        colors = list(map(int, colors.split()))\n        direction = ord(direction) - ord('D')\n        answers[i] = int(\n            sum([0.5 * (colors[i] + colors[i + 1]) * (L - colors[i]) for i in range(N - 1)])\n            + 0.5 * (colors[N - 1] + colors[0]) * (L - colors[N - 1])\n        )\n    return''.join([str(ans) for ans in answers])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    scores = {(0, 0): 1}\n    for N in range(1, N + 1):\n        directions = {\n            \"L\": (-1, 0),\n            \"D\": (0, 1),\n        }\n        for K in range(1, K + 1):\n            for k, (left, right) in directions.items():\n                for x, (y, z) in directions.items():\n                    if x == K:\n                        scores[(N, K)] = max(\n                            scores[(N, K)],\n                            scores[(N, K - 1)] + (\n                                scores[(N - 1, K)] + x * (L - y)\n                            ) * scores[(N - 1, K - 1)],\n                        )\n                    if x == K - 1:\n                        scores[(N, K)] = max(\n                            scores[(N, K)],\n                            scores[(N, K - 1)] + (\n                                scores[(N - 1, K)] + x * (L - y)\n                            ) * scores[(N - 1, K - 1)],\n                        )\n        for k, (left, right) in directions.items():\n            scores[(N, K)] = max(\n                scores[(N, K)],\n                scores[(N - 1, K)] + (scores[(N - 1, K - 1)] + left * (L - right)) * scores[(N - 1, K - 1)],\n            )\n    return str(scores[(N, K)])\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    direction = {'L': 0, 'D': 180}\n    colors = []\n    for _ in range(n):\n        c, d = stdin.split()\n        colors.append(d)\n    colors = list(set(colors))\n    colors.sort()\n    out = []\n    for c in colors:\n        if c == 'D':\n            out.append(n)\n        else:\n            out.append(l - 1)\n    return \" \".join(map(str, out))\n"
    },
    {
        "number": 3207,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    colors = {}\n    colors['R'] = 1\n    colors['G'] = 2\n    colors['B'] = 3\n    colors['Y'] = 4\n    colors['O'] = 5\n    colors['P'] = 6\n    colors['W'] = 7\n    colors['K'] = 8\n    colors['Y'] = 9\n    colors['C'] = 10\n    \n    n, k, l = map(int, input().split())\n    #print(n,k,l)\n    data = list(map(str, input().split()))\n    \n    times = {}\n    for color in colors:\n        times[color] = 0\n        \n    for i in range(len(data)):\n        dist = int(data[i])\n        if(dist <= l):\n            if(data[i] == 'L'):\n                times['R'] += 1\n                times['G'] += 1\n                times['B'] += 1\n            else:\n                times['R'] += 1\n                times['G'] += 1\n                times['B'] += 1\n        else:\n            if(data[i] == 'L'):\n                times['R'] += 1\n                times['G'] += 1\n                times['B'] += 1\n            else:\n                times['R'] += 1\n                times['G'] += 1\n                times['B'] += 1\n        \n    #print(times)\n    #print(data)\n    ans = 0\n    for color in colors:\n        ans += times[color] * (k**times[color])\n    return str(ans)\n    \n    \n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ciphertext = stdin.splitlines()[0]\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    output = ''\n\n    for cipherletter in ciphertext:\n        try:\n            plainletter = alphabet[(alphabet.index(cipherletter) - 2)]\n        except:\n            return 'Impossible'\n        output += plainletter\n    return output\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    words = {\n        'be': ['will', 'dead', 'hook','ship', 'blood','sable', 'avenge'],\n        'our': ['rum', 'will', 'dead', 'hook','ship', 'blood','sable', 'avenge'],\n        'rum': ['be', 'our', 'will', 'dead', 'hook','ship', 'blood','sable', 'avenge'],\n        'will': ['be', 'our', 'rum', 'dead', 'hook','ship', 'blood','sable', 'avenge'],\n        'dead': ['be', 'our', 'rum', 'will', 'hook','ship', 'blood','sable', 'avenge'],\n        'hook': ['be', 'our', 'dead', 'rum', 'will','ship', 'blood','sable', 'avenge'],\n       'ship': ['be', 'our', 'dead', 'hook', 'will', 'rum', 'blood','sable', 'avenge'],\n        'blood': ['be', 'our', 'dead', 'hook', 'will', 'rum','ship','sable', 'avenge'],\n       'sable': ['be', 'our', 'dead', 'hook', 'will','ship', 'blood', 'rum', 'avenge'],\n        'avenge': ['be', 'our', 'dead', 'hook', 'will','ship', 'blood','sable', 'rum'],\n        'parrot': ['be', 'our', 'dead', 'hook', 'will','ship', 'blood','sable', 'avenge'],\n        'captain': ['our', 'rum', 'will', 'dead', 'hook','ship', 'blood','sable', 'avenge'],\n    }\n    plaintext = stdin.strip()\n    if all(i in words.keys() for i in plaintext):\n        if len(words[plaintext[0]]) == len(plaintext):\n            mappings = []\n            for i in range(len(words[plaintext[0]])):\n                count = 0\n                for j in plaintext:\n                    if words[plaintext[0]][i] == j:\n                        count += 1\n                mappings.append(count)\n            if len(set(mappings)) == len(mappings):\n                return ''.join([words[plaintext[0]][i] for i in range(len(words[plaintext[0]])) if mappings[i] == 1])\n    return 'Impossible'\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    s = stdin.strip()\n    letter = list(s)\n    alphabet = {chr(x) for x in range(65, 91)}\n    words = set()\n    for x in range(len(s)):\n        if s[x] == \" \":\n            continue\n        letter[x] = alphabet.intersection(letter[x + 1:]).pop()\n    for x in range(len(s)):\n        if s[x] == \" \":\n            continue\n        words.add(s[x])\n    if len(words) == len(letter):\n        return \"\".join(letter)\n    else:\n        return \"Impossible\"\n\n\nprint(solution(input()))"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    plain_text = stdin\n    # your code here\n    return plain_text"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    result = \"\"\n\n    for line in stdin.split(\"\\n\"):\n        chars = \"\".join(sorted(line))\n        if chars in WORDS:\n            result = line\n            break\n\n    return result\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.replace('\\n', '').lower()\n    words = set(stdin.split())\n    for i in range(len(stdin)):\n        if stdin[i] not in 'aeiou':\n            for j in range(i, len(stdin)):\n                if stdin[i] + stdin[j] in words:\n                    stdin = stdin[:i] + stdin[j:].replace(stdin[i] + stdin[j], stdin[i])\n                    break\n    return stdin if len(set(stdin)) == len(stdin) else 'Impossible'\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    for word in sorted(set(stdin.split()), key=stdin.count):\n        if stdin.count(word) == stdin.count(word.upper()):\n            return word\n    return 'Impossible'\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    result = stdin\n    for i in range(len(stdin)):\n        if stdin[i].isalpha():\n            result = stdin.replace(stdin[i], chr(ord(stdin[i]) + 1))\n            break\n        elif stdin[i] == \" \":\n            continue\n        else:\n            break\n    if \"i\" not in result and \"I\" not in result and \"l\" not in result and \"L\" not in result:\n        return \"Impossible\"\n    return result"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s_mapping = {'a': 'd', 'b': 'n', 'c': 'e', 'd':'s', 'e': 'f', 'f': 'o', 'g': 'r', 'h': 'p', 'i': 'q', 'j': 'w', 'k': 'v', 'l': 'z','m': 'x',\n                 'n': 'y', 'o': 'u', 'p': 'a', 'q': 'l', 'r': 'g','s': 'k', 't': 'j', 'u': 'i', 'v': 'h', 'w': 't', 'x': 'b', 'y': 'f', 'z': 'c'}\n    plain_text = stdin.replace(' ', '')\n    if plain_text == '':\n        return 'Impossible'\n    for i in range(len(plain_text)):\n        if plain_text[i] not in s_mapping:\n            return 'Impossible'\n    # list of each word\n    list_of_words = plain_text.split()\n    # count of each word\n    word_count = {}\n    for word in list_of_words:\n        if word not in word_count:\n            word_count[word] = 1\n        else:\n            word_count[word] += 1\n    # count of each character\n    char_count = {}\n    for word in list_of_words:\n        for char in word:\n            if char not in char_count:\n                char_count[char] = 1\n            else:\n                char_count[char] += 1\n    # we find the character that appears most in the encrypted text\n    for char in s_mapping:\n        if char in word_count:\n            if char_count[char] > word_count[char]:\n                char_count[char] = word_count[char]\n        else:\n            char_count[char] = 0\n    # list of the encrypted character that appears most in the text\n    encrypted_chars = sorted(char_count.items(), key=lambda kv: kv[1], reverse=True)\n    # check if the number of encrypted characters and the number of possible characters are equal\n    if len(encrypted_chars)!= len(char_count):\n        return 'Impossible'\n    # now we need to find the mapping between the number of encrypted and possible characters\n    flag = 0\n    for i in range(len(encrypted_chars)):\n        if encrypted_chars[i][1]!= 0:\n            flag = 1\n            break\n    if flag == 0:\n        return 'Impossible'\n    # create a mapping to decrypt the possible characters by the number of encrypted characters\n    mapping = {}\n    for i in range(len(encrypted_chars)):\n        if encrypted_chars[i][1]!= 0:\n            mapping[encrypted_chars[i][0]] = ''.join(list(s_mapping.keys())[:list(s_mapping.values()).index(encrypted_chars[i][0])])\n    decrypted_words = ''\n    for word in list_of_words:\n        for char in word:\n            if char in mapping:\n                decrypted_words += mapping[char]\n            else:\n                decrypted_words +=''\n    return decrypted_words\n"
    },
    {
        "number": 3208,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    pass\n"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split()\n    origin = data[0]\n    destination = data[1]\n    trips = int(data[2])\n    total_time = int(data[3])\n    max_delay = int(data[4])\n    if trips <= 0:\n        return 'IMPOSSIBLE'\n    departures = []\n    for i in range(trips):\n        data = stdin.split()\n        origin = data[0]\n        destination = data[1]\n        departure_time = int(data[2])\n        standard_time = int(data[3])\n        probability = int(data[4])\n        delay = 0\n        if data[5] == '-1':\n            delay = -1\n        else:\n            delay = int(data[5])\n        if delay < 0:\n            delay = max_delay\n        departures.append([origin, destination, departure_time, standard_time, probability, delay])\n    return '%.10f' % calculate(departures, total_time)\n\n\ndef"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    counts = []\n    for line in lines:\n        line = line.split()\n        name1 = line[0]\n        name2 = line[1]\n        duration = []\n        for i in range(2, len(line)):\n            duration.append(int(line[i]))\n        duration = sum(duration)\n        counts.append([name1, name2, duration])\n    counts = sorted(counts, key=lambda x: x[2])\n    if counts[0][0] == counts[1][0]:\n        return \"IMPOSSIBLE\"\n    counts = sorted(counts, key=lambda x: x[2])\n    for i in range(1, len(counts)):\n        if counts[i][1] == counts[i - 1][1]:\n            continue\n        counts = sorted(counts, key=lambda x: x[2])\n        if counts[i][0] == counts[i][1]:\n            continue\n        return f\"{counts[i][2]:.6f}\"\n\nprint(solution(input()))\n\"\"\"\n\nfrom math import ceil\n\ndef"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    origin = stdin[0]\n    destination = stdin[1]\n    departure_time_in_minutes = int(stdin[2])\n    journey_time = int(stdin[3])\n    delays = int(stdin[4])\n    max_delay = int(stdin[5])\n    departure_time_in_seconds = 60 * departure_time_in_minutes\n    departure_time_in_hours = departure_time_in_minutes // 60\n    delay_range = max_delay // 60\n    if departure_time_in_seconds + delay_range < journey_time:\n        return 'IMPOSSIBLE'\n    departure_time_in_minutes += int(max_delay)\n    if max_delay == 0:\n        return str(journey_time)\n    journey_time = journey_time + int(max_delay)\n    minutes_to_departure = departure_time_in_minutes - departure_time_in_seconds\n    departure_hour = int(minutes_to_departure // 60)\n    departure_minute = minutes_to_departure % 60\n    minutes_to_departure = departure_time_in_minutes - departure_time_in_seconds\n    destination_hour = int(minutes_to_departure // 60)\n    destination_minute = minutes_to_departure % 60\n    delay = int(delays * 100)\n    minutes_to_destination = destination_hour * 60 + destination_minute\n    if departure_hour < destination_hour:\n        delay -= 1\n    if delay >= 1:\n        minutes_to_departure += delay * 60\n        minutes_to_destination += delay * 60\n    if minutes_to_departure < departure_time_in_minutes:\n        return 'IMPOSSIBLE'\n    if minutes_to_departure >= departure_time_in_minutes:\n        minutes_to_departure = minutes_to_departure - departure_time_in_minutes\n        minutes_to_destination = minutes_to_destination - departure_time_in_minutes\n    if minutes_to_destination < 0:\n        return 'IMPOSSIBLE'\n    if minutes_to_destination > journey_time:\n        return 'IMPOSSIBLE'\n    minutes_to_departure = str(minutes_to_departure)\n    minutes_to_destination = str(minutes_to_destination)\n    if len(minutes_to_departure) < 2:\n        minutes_to_departure = '0' + minutes_to_departure\n    if len(minutes_to_destination) < 2:\n        minutes_to_destination = '0' + minutes_to_destination\n    return str(minutes_to_departure) + '.' + str(minutes_to_destination)\n\nstdin = 'Hamburg Bremen\\n3\\nHamburg Bremen 15 68 10 5\\nBremen Frankfurt 14 226 10 120\\n1\\n'\nprint(solution(stdin))\n"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_of_lines = len(stdin.splitlines())\n    train_connections = []\n    for i in range(num_of_lines):\n        line_data = stdin.splitlines()[i]\n        line_data = line_data.split()\n        train_connections.append(line_data)\n    all_delays = []\n    num_of_delays = 0\n    num_of_delays_in_delay = 0\n    for i in range(len(train_connections)):\n        #print(train_connections[i])\n        origin_place = train_connections[i][0]\n        destination_place = train_connections[i][1]\n        #print(origin_place)\n        #print(destination_place)\n        origin_time = int(train_connections[i][2])\n        #print(origin_time)\n        origin_time = origin_time * 60\n        destination_time = int(train_connections[i][3])\n        destination_time = destination_time * 60\n        delay = float(train_connections[i][4])\n        #print(delay)\n        if not (delay > 1 and delay <= destination_time):\n            num_of_delays += 1\n            num_of_delays_in_delay += 1\n        all_delays.append(delay)\n    total_delays = sum(all_delays)\n    total_delays = total_delays / 60\n    #print(total_delays)\n    total_delays = round(total_delays, 6)\n    #print(total_delays)\n    min_delay_time = round(num_of_delays_in_delay/num_of_delays * total_delays, 6)\n    #print(min_delay_time)\n    min_delay_time = int(min_delay_time)\n    #print(min_delay_time)\n    return str(min_delay_time)\n\n\nstdin = '''\nHamburg Bremen\n1\nHamburg Utrecht 10 22 5 10\nBremen Frankfurt 14 226 10 120\n'''\n\nprint(solution(stdin))\n'''\nSample Input 1:\n2\nHamburg Bremen\nHamburg Bremen 15 68 10 5\nBremen Frankfurt 14 226 10 120\nSample Output 1:\n68.3\n\nSample Input 2:\n1\nHamburg Bremen\n1\nHamburg Bremen 15 68 10 5\nBremen Frankfurt 14 226 10 120\nSample Output 2:\nIMPOSSIBLE\n\nSample Input 3:\n3\nHamburg Bremen\n3\nHamburg Bremen 15 68 10 5\nBremen Frankfurt 14 226 10 120\nSample Output 3:\nIMPOSSIBLE\n'''"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # you may use the provided input\n    # any code inside this 'if' statement will be ignored\n    if len(stdin) > 4:\n        return IMPOSSIBLE\n    line = stdin.splitlines()[0]\n    departure_name, departure_destination, arrival_name, arrival_destination = line.split()\n    origin = departure_name + departure_destination\n    destination = arrival_name + arrival_destination\n    times = stdin.splitlines()[1:]\n    scheduled_times = []\n    for i in times:\n        i = i.split()\n        times_of_connection = i[1:]\n        start_time = i[0]\n        end_time = i[2]\n        time_difference = int(end_time) - int(start_time)\n        scheduled_times.append(time_difference)\n    num_of_connections = len(scheduled_times)\n    departure_time = scheduled_times[0]\n    minimum_time_for_trip = departure_time + (num_of_connections - 1) * stdin.splitlines()[2]\n    maximum_time_for_trip = departure_time + stdin.splitlines()[3]\n    probability_of_delays = stdin.splitlines()[4]\n    delays = stdin.splitlines()[5:]\n    delays_of_connections = []\n    for delay in delays:\n        delay = delay.split()\n        delay_of_connection = int(delay[1])\n        delays_of_connections.append(delay_of_connection)\n    max_delay_of_connection = max(delays_of_connections)\n    min_delay_of_connection = min(delays_of_connections)\n    if min_delay_of_connection >= max_delay_of_connection:\n        return IMPOSSIBLE\n    if min_delay_of_connection > destination_time:\n        return IMPOSSIBLE\n    if maximum_time_for_trip > arrival_time:\n        return IMPOSSIBLE\n    if maximum_time_for_trip < minimum_time_for_trip:\n        return IMPOSSIBLE\n    if probability_of_delays == \"1\":\n        if minimum_time_for_trip >= departure_time + (num_of_connections - 1) * stdin.splitlines()[2]:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if minimum_time_for_trip >= arrival_time:\n            return IMPOSSIBLE\n    if min_delay_of_connection >= max_delay_of_connection:\n        return IMPOSSIBLE\n    if probability_of_delays == \"1\":\n        if departure_time + (num_of_connections - 1) * stdin.splitlines()[2] >= arrival_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if departure_time + (num_of_connections - 1) * stdin.splitlines()[2] >= arrival_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time:\n            return IMPOSSIBLE\n    if probability_of_delays == \"0\":\n        if arrival_time >= departure_time"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (origin, destination) = stdin.split()\n    m = int(origin)\n    n = int(destination)\n    if m > n:\n        m, n = n, m\n    if n > 30:\n        return \"IMPOSSIBLE\"\n    print(m, n)\n    for i in range(n):\n        print(\"{0} {1} {2} {3}\".format(m, destination, m - i, m + i))\n    return \"{0:.8f}\".format(((m * (m - 1)) / 2) + (m * (m - 1)) / 2)\n"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p, t, d = [int(x) for x in stdin.split()]\n    trips = 0\n    #We are getting the minimum number of minutes we need to travel all the way back to the starting point\n    while n>0:\n        if trips==0:\n            trips = trips + 1\n            trips = trips * 60\n            continue\n        minutes = trips * 60\n        trips = trips - minutes\n        if n>0:\n            trip = {\n                \"origin\": stdin.split()[0],\n                \"destination\": stdin.split()[1],\n                \"departure\": int(stdin.split()[2]),\n                \"duration\": minutes + 60*(int(stdin.split()[3]) - (minutes/60)) + 60*(int(stdin.split()[4]) - (minutes/60))\n            }\n            if trip[\"origin\"] == trip[\"destination\"]:\n                return IMPOSSIBLE\n            n = n - 1\n    return str(trips)\n"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    departure, destination, n = stdin.split()\n    departure = tuple(sorted(departure.split(',')))\n    destination = tuple(sorted(destination.split(',')))\n    results = []\n    for train in range(n):\n        origin, destination, departure_time, journey_time, probability, max_delay = stdin.split()\n        origin = tuple(sorted(origin.split(',')))\n        destination = tuple(sorted(destination.split(',')))\n        departure_time = int(departure_time)\n        journey_time = int(journey_time)\n        probability = int(probability)\n        max_delay = int(max_delay)\n        results.append([origin, destination, departure_time, journey_time, probability, max_delay])\n    departure = tuple(sorted(departure))\n    destination = tuple(sorted(destination))\n    return min(calculate_scheduled_departure_time(results, departure, destination))\n\n\ndef"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    train_connections = []\n    for line in stdin.splitlines():\n        origin, destination = line.split()\n        train_connections.append((origin, destination))\n    total_duration = 0\n    for train_connection in train_connections:\n        origin, destination = train_connection\n        train_departure_time = int(input())\n        train_duration = int(input())\n        train_probability = int(input())\n        train_delay = int(input())\n        if validate(train_departure_time, train_duration, train_probability, train_delay):\n            total_duration += calculate_total_duration(train_departure_time, train_duration, train_probability, train_delay)\n    return total_duration\n\ndef"
    },
    {
        "number": 3209,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    train_connections = list()\n    for train_connection in stdin.splitlines():\n        train_origin, train_destination = train_connection.split()\n        train_connections.append((train_origin, train_destination))\n    delays = list()\n    for train_connection in train_connections:\n        delay = 0\n        train_origin, train_destination = train_connection\n        delays.append(train_connection)\n        delays.append(train_connection)\n    for train_connection in train_connections:\n        delay = 0\n        train_origin, train_destination = train_connection\n        delays.append(train_connection)\n    for train_connection in train_connections:\n        delay = 0\n        train_origin, train_destination = train_connection\n        delays.append(train_connection)\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    for train_connection in train_connections:\n        delay = 0\n        train_origin, train_destination = train_connection\n        delays.append(train_connection)\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays.append((train_destination, train_origin))\n    delays.append((train_origin, train_destination))\n    delays.append((train_destination, train_origin))\n    delays."
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    dots = [['.' for _ in range(2 * N - 1)] for _ in range(2 * N - 1)]\n    alice = '*'\n    bob = '-'\n    for i in range(2 * N):\n        if i % 2 == 0:\n            alice = '*'\n        else:\n            alice = '-'\n        for j in range(2 * N - 1):\n            dots[i][j] = alice\n        if i < N:\n            bob = '*'\n        else:\n            bob = '-'\n        for j in range(2 * N - 1):\n            dots[i][j] = bob\n    for row in dots:\n        print(''.join(row))\n    return alice + '-' + bob\n\n\nprint(solution(input()))\n\"\"\"\n\n\"\"\"\n\nclass Solution:\n    def solve(self, N, stdin):\n        # N = int(stdin)\n        dots = [['.' for _ in range(2 * N - 1)] for _ in range(2 * N - 1)]\n        alice = '*'\n        bob = '-'\n        for i in range(2 * N):\n            if i % 2 == 0:\n                alice = '*'\n            else:\n                alice = '-'\n            for j in range(2 * N - 1):\n                dots[i][j] = alice\n            if i < N:\n                bob = '*'\n            else:\n                bob = '-'\n            for j in range(2 * N - 1):\n                dots[i][j] = bob\n        for row in dots:\n            print(''.join(row))\n        return alice + '-' + bob"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return 0"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # <YOUR CODE HERE>\n    return \"\""
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def board_to_str(board):\n        return '\\n'.join([''.join(['*' if i == '*' else '-' for i in line] + ['|']) for line in board])\n\n    def check_win(board):\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if board[i][j] == '*':\n                    return True\n        for j in range(len(board[0])):\n            for i in range(len(board)):\n                if board[i][j] == '*':\n                    return True\n        return False\n\n    def print_board(board):\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                print(board[i][j], end='')\n            print()\n\n    board = list(map(list, stdin.split('\\n')))\n    result = 0\n    while not check_win(board):\n        board = list(map(list, stdin.split('\\n')))\n        print_board(board)\n        print(board_to_str(board))\n        move = input()\n        moves = move.split(' ')\n        if moves[0] == 'Left':\n            board = list(map(list, stdin.split('\\n')))\n            if moves[1] == 'down':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i+1][j] = board[i+1][j], board[i][j]\n            elif moves[1] == 'up':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j+1] = board[i][j+1], board[i][j]\n            elif moves[1] == 'right':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j-1] = board[i][j-1], board[i][j]\n            elif moves[1] == 'left':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i+1][j] = board[i+1][j], board[i][j]\n        elif moves[0] == 'Down':\n            board = list(map(list, stdin.split('\\n')))\n            if moves[1] == 'right':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i+1][j] = board[i+1][j], board[i][j]\n            elif moves[1] == 'left':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j-1] = board[i][j-1], board[i][j]\n            elif moves[1] == 'up':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j+1] = board[i][j+1], board[i][j]\n            elif moves[1] == 'down':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i-1][j] = board[i-1][j], board[i][j]\n        elif moves[0] == 'Right':\n            board = list(map(list, stdin.split('\\n')))\n            if moves[1] == 'up':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i-1][j] = board[i-1][j], board[i][j]\n            elif moves[1] == 'down':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i+1][j] = board[i+1][j], board[i][j]\n            elif moves[1] == 'left':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j-1] = board[i][j-1], board[i][j]\n            elif moves[1] == 'right':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j+1] = board[i][j+1], board[i][j]\n        elif moves[0] == 'Up':\n            board = list(map(list, stdin.split('\\n')))\n            if moves[1] == 'left':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j-1] = board[i][j-1], board[i][j]\n            elif moves[1] == 'right':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) - 1\n                board[i][j], board[i][j+1] = board[i][j+1], board[i][j]\n            elif moves[1] == 'down':\n                i = int(moves[2]) - 1\n                j = int(moves[3]) -"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    board = stdin.strip().split('\\n')\n    score = 0\n    for i, j in product(range(1, N + 1), range(1, N + 1)):\n        if board[i][j] == '*':\n            if board[i - 1][j] == '*' and board[i + 1][j] == '*' and board[i][j - 1] == '*' and board[i][j + 1] == '*':\n                score += 1\n        else:\n            if board[i][j - 1] == '.' and board[i][j + 1] == '.':\n                score += 1\n    return str(score)\n"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n    n = int(stdin.pop(0))\n    grid = {(i, j): (1 if c == '.' else 0) for i, row in enumerate(stdin) for j, c in enumerate(row)}\n\n    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    points = [0]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i, j] == 1:\n                points.append(grid.get((i + 1, j), 0) + grid.get((i, j + 1), 0))\n\n    points.append(grid.get((n - 1, n - 1), 0))\n    points.append(grid.get((n - 1, n - 2), 0))\n    points.append(grid.get((n - 2, n - 1), 0))\n\n    return str(max(points))\n\n\nprint(solution('''2\n*-*.*\n|.|.|\n*.*-*\n|...|\n*.*.*'''))\n"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    # replace newlines with spaces\n    # split into list of strings\n    input_ = stdin.replace('\\r\\n','').split('\\n')\n    # set up a board\n    board = [[None] * len(input_) for _ in range(len(input_))]\n    # loop through the input and place each character in the list of strings\n    for i in range(len(input_)):\n        for j in range(len(input_)):\n            board[i][j] = input_[i][j]\n    # check for a solution\n    if has_no_winner(board):\n        # if a winner, return 0\n        return 0\n    # if a winner, check to see if we can win\n    if winning_move(board):\n        # if we can, return 1\n        return 1\n    # if no winner or winning,\n    # check to see if a move is possible\n    moves = get_possible_moves(board)\n    # if there are moves\n    if moves:\n        # return the maximum of the moves\n        return max(moves)\n    # if no moves, then return 0\n    return 0\n\ndef"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def score_cell(cell):\n        if cell == '.':\n            return 0\n        if cell == '|':\n            return 1\n        return 2\n    moves_made = 0\n    N = int(stdin)\n    grid = []\n    for i in range(N):\n        grid.append(list(stdin[i*(N+1):(i+1)*(N+1)])[:N])\n    while True:\n        for row in range(N):\n            for col in range(N):\n                cell = grid[row][col]\n                if cell == '*':\n                    if score_cell(grid[row-1][col]) == 2 and score_cell(grid[row+1][col]) == 2 and score_cell(grid[row][col-1]) == 2 and score_cell(grid[row][col+1]) == 2:\n                        moves_made += 1\n                        grid[row][col] = '-'\n        if all([all([x == '-' for x in row]) for row in grid]):\n            break\n    return moves_made\n\nstdin = input()\nprint(solution(stdin))\n\"\"\""
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N < 3:\n        raise ValueError(\"N must be a number greater than 2\")\n    dots = []\n    for row_i in range(2*N - 1):\n        row = list(stdin[row_i])\n        for col_i in range(2*N - 1):\n            cell = row[col_i]\n            if cell == \"*\":\n                dots.append((row_i, col_i))\n    if not dots:\n        return \"Impossible\"\n    n_possible_moves = 0\n    for dot1, dot2 in itertools.combinations(dots, 2):\n        n_possible_moves += 1\n        if can_connect(dot1, dot2):\n            n_possible_moves += 1\n    return str(n_possible_moves)\n\n\ndef"
    },
    {
        "number": 3210,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    board = []\n    for i in range(N):\n        board.append(stdin)\n        stdin = stdin[::-1]\n\n    return len(possible_moves(board, N))\n\ndef"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    l = list(map(int, stdin.strip().split()))\n    if max(l) - min(l) == n:\n        return \"impossible\"\n    dp = [[0] * 3 for _ in range(n)]\n    dp[0][1], dp[0][2] = 1, 1\n    for i in range(1, n):\n        if l[i] == 0:\n            dp[i][0] = dp[i - 1][2] + 1\n        elif l[i] == 2:\n            dp[i][1] = dp[i - 1][1] + 1\n        else:\n            dp[i][2] = dp[i - 1][0] + 1\n    return str(min(min(dp[i])))\n"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # --- REPLACE THIS WITH YOUR SOLUTION ---\n    print('impossible')\n    return 'impossible'"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin)\n    s = stdin\n    arr_num = list(map(int,s.split()))\n\n    swaps = 0\n    cnt_1 = arr_num.count(1)\n    cnt_2 = arr_num.count(2)\n    if cnt_1 > cnt_2:\n        for i in range(len(arr_num)):\n            if arr_num[i] == 1:\n                arr_num[i] = 2\n                swaps += 1\n        if arr_num.count(1) > arr_num.count(2):\n            return \"impossible\"\n    if cnt_1 < cnt_2:\n        for i in range(len(arr_num)):\n            if arr_num[i] == 2:\n                arr_num[i] = 1\n                swaps += 1\n        if arr_num.count(1) > arr_num.count(2):\n            return \"impossible\"\n    return swaps"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if (n <= 2):\n        return \"impossible\"\n    c = [0, 0, 0]\n    s = stdin.split()\n    for i in range(n):\n        if s[i] == \"1\":\n            c[0] += 1\n        elif s[i] == \"2\":\n            c[1] += 1\n        elif s[i] == \"0\":\n            c[2] += 1\n    if c[0] > c[1] and c[0] > c[2]:\n        return \"0\"\n    elif c[0] < c[1] and c[1] < c[2]:\n        return \"1\"\n    else:\n        return \"impossible\"\nsolution(input())\nSample Input 3:\n3\n1111\n2222\n3333\nSample Output 3:\n1\n"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n    swaps = 0\n    while s!= '1111':\n        # swap adjacent tellers\n        if s[0] == '1' and s[1] == '1' or s[0] == '2' and s[1] == '2':\n            s = s[1] + s[0] + s[2]\n        else:\n            s = s[1] + s[0] + s[2]\n        swaps += 1\n    return swaps\n"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *s = stdin.split()\n    return 'impossible' if len(s) % 2 == 0 else len(s) - 1\n"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin.replace('0', '0').replace('1', '1').replace('2', '2')\n    \n    def swap(s, a, b):\n        tmp = s[a]\n        s[a] = s[b]\n        s[b] = tmp\n        \n    swaps = 0\n    i = 0\n    while i < n - 2:\n        if s[i] == '1' and s[i + 1] == '2':\n            swaps += 1\n            swap(s, i, i + 1)\n        i += 2\n        \n    return str(swaps)\n\"\"\"\ndef"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _n = int(stdin.strip())\n    _s = list(stdin.strip())\n    _s.sort()\n    _p1 = 0\n    _p2 = 0\n    _teller1 = 0\n    _teller2 = 0\n    for i in range(len(_s)):\n        if _s[i] == '1':\n            _p1 += 1\n        elif _s[i] == '2':\n            _p2 += 1\n        else:\n            if _teller1 == _teller2:\n                _teller1 = 0\n                _teller2 = 0\n            if _teller1 > _teller2:\n                _teller1 += 1\n            else:\n                _teller2 += 1\n    if _p1 > _p2:\n        return '1'\n    elif _p2 > _p1:\n        return '2'\n    elif _p1 == _p2:\n        if _teller1 > _teller2:\n            return '1'\n        else:\n            return '2'\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # numbers = list(map(int, stdin.strip().split(' ')))\n    numbers = list(map(int, stdin.strip().split(' ')))\n    n = numbers[0]\n    arrivals = numbers[1]\n    swaps = 0\n    in_teller = False\n    a = 1\n    b = 2\n    while in_teller == False and swaps < n - 1:\n        # print(a, b)\n        if arrivals[a] == b or arrivals[a] == a + 1:\n            swaps += 1\n            a += 1\n            b += 1\n        elif arrivals[a]!= b and arrivals[b]!= a + 1:\n            in_teller = True\n        else:\n            return 'impossible'\n    return swaps\n\n\nprint(solution('4 3 1 2 1 0 0 0 0 1 1 2 0 1 1 1 1 1 0 0 1 2 2 1 0 0 1 1 0 1 1 2 1 1 1 1 0 0 0 1 1 1 2 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 1 2 2 1 0 0 1 1 2 1 0 0 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
    },
    {
        "number": 3211,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    c = list(map(int, stdin.split()))\n    indices = [i for i in range(len(c))]\n    c.sort()\n    n_1 = 0\n    n_2 = 0\n    for i, c_i in enumerate(c):\n        if c_i == 1:\n            n_1 += 1\n            n_2 += n_1\n        if c_i == 2:\n            n_1 += 1\n            n_2 += n_1\n    while True:\n        if n_1 > n_2:\n            return \"impossible\"\n        for i in range(len(c) - 1):\n            if c[i] == 1:\n                if c[i + 1] == 2:\n                    c[i + 1] = 1\n                    n_1 += 1\n                    n_2 += n_1\n                else:\n                    c[i + 1] = 2\n                    n_1 += 1\n                    n_2 += n_1\n                    break\n            if c[i] == 2:\n                if c[i + 1] == 1:\n                    c[i + 1] = 2\n                    n_1 += 1\n                    n_2 += n_1\n                else:\n                    c[i + 1] = 1\n                    n_1 += 1\n                    n_2 += n_1\n                    break\n    return str(n_1)\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split()[0])\n    snakes = [list(map(int, stdin.strip().split()[1:])) for _ in range(n)]\n    x, y = 0, 0\n    res = \"Bill will be bitten.\"\n    for i, j in snakes:\n        while x + i >= 0 and y + j >= 0 and x + i <= 1000 and y + j <= 1000:\n            x += i\n            y += j\n        if x - i <= 0 or x - i >= 1000 or y - j <= 0 or y - j >= 1000:\n            res = \"Bill enters at ({}, {}) and leaves at ({}, {}).\".format(x, y, x + i, y + j)\n            break\n    return res"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    snakes = [list(map(int, stdin.split())) for _ in range(int(stdin.split()[0]))]\n    north_pos = {(x, y) for x, y in snakes}\n    south_pos = {(x, y) for x, y in snakes}\n    west_pos = {(x, y) for x, y in snakes}\n    east_pos = {(x, y) for x, y in snakes}\n    for x, y, d in snakes:\n        north = (x - d, y - d)\n        south = (x + d, y + d)\n        west = (x - d, y + d)\n        east = (x + d, y - d)\n        north_pos.discard(north)\n        south_pos.discard(south)\n        west_pos.discard(west)\n        east_pos.discard(east)\n    return 'Bill enters at %s and leaves at %s' % (\n        (round(max(north_pos).pop()), round(max(south_pos).pop())),\n        (round(max(west_pos).pop()), round(max(east_pos).pop())),\n    )\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"Bill will be bitten.\"\n    snakes = []\n    for i in range(n):\n        snakes.append(list(map(int, stdin.split())))\n    n = len(snakes)\n    snake_coords = {}\n    for i in range(n):\n        snake_coords[snakes[i][0], snakes[i][1]] = 1\n    coords_x = set(list(snake_coords.keys()))\n    coords_y = set(list(snake_coords.keys()))\n    coords_x = sorted(list(coords_x))\n    coords_y = sorted(list(coords_y))\n    for i in range(len(coords_x)):\n        for j in range(len(coords_y)):\n            if (coords_x[i], coords_y[j]) not in snake_coords:\n                return \"Bill will be bitten.\"\n    for i in range(len(coords_x)):\n        for j in range(len(coords_y)):\n            if coords_x[i] < coords_y[j]:\n                return f\"Bill enters at {coords_x[i]} {coords_y[j]}\"\n            if coords_x[i] > coords_y[j]:\n                return f\"Bill leaves at {coords_x[i]} {coords_y[j]}\"\n    return f\"Bill enters at {coords_x[0]} {coords_y[0]}\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.splitlines()\n    max_x = max_y = 999\n    snakes = {}\n    for i in range(int(data[0])):\n        start_x, start_y, end_x, end_y = list(map(int, data[i * 2 + 1].split()))\n        snake = (start_x, start_y, end_x, end_y)\n        snakes[snake] = False\n        if start_x > max_x:\n            max_x = start_x\n        if start_y > max_y:\n            max_y = start_y\n        if end_x > max_x:\n            max_x = end_x\n        if end_y > max_y:\n            max_y = end_y\n    snakes = sorted(snakes.keys(), key=lambda x: x[0])\n    snakes = sorted(snakes, key=lambda x: x[1])\n    snakes = sorted(snakes, key=lambda x: x[2])\n    snakes = sorted(snakes, key=lambda x: x[3])\n    i = 0\n    while i < len(snakes):\n        if snakes[i][0] == 0 and snakes[i][1] == 0:\n            del snakes[i]\n        elif snakes[i][0] == 0 and snakes[i][1] == max_y - 1:\n            snakes.pop(i)\n        elif snakes[i][2] == 0 and snakes[i][3] == max_x - 1:\n            snakes.pop(i)\n        elif snakes[i][0] == max_x - 1 and snakes[i][1] == 0:\n            snakes.pop(i)\n        elif snakes[i][2] == max_x - 1 and snakes[i][3] == max_y - 1:\n            snakes.pop(i)\n        i += 1\n    return str(snakes[0][0]) +'' + str(snakes[0][1]) +'' + str(snakes[0][2]) +'' + str(snakes[0][3])\n\n\nprint(solution(\"\"\"4\n0 0 999\n0 999 999\n1 0 999\n2 0 999\n3 0 999\n4 1 0\n3 2 0\n2 3 0\n1 2 0\n1 1 0\n3 3 0\n1 3 0\n1 1 0\n3 2 0\n1 1 0\n4 2 0\n3 3 0\n3 2 0\n2 3 0\n2 1 0\n3 3 0\n2 3 0\n3 1 0\n3 2 0\n2 3 0\n1 3 0\n1 1 0\n3 1 0\n1 2 0\n1 1 0\n3 2 0\n2 2 0\n2 1 0\n3 1 0\n2 2 0\n1 1 0\n3 1 0\n1 1 0\n3 3 0\n2 3 0\n1 3 0\n2 3 0\n2 3 0\n3 2 0\n1 3 0\n2 3 0\n1 3 0\n3 2 0\n1 3 0\n3 2 0\n2 3 0\n1 2 0\n1 3 0\n1 1 0\n3 3 0\n2 3 0\n2 3 0\n3 2 0\n1 2 0\n3 1 0\n3 1 0\n3 2 0\n2 2 0\n1 2 0\n1 2 0\n1 2 0\n3 2 0\n2 2 0\n2 1 0\n3 2 0\n3 2 0\n3 2 0\n3 2 0\n3 2 0\n2 2 0\n1 2 0\n2 2 0\n1 3 0\n1 3 0\n2 3 0\n2 3 0\n2 3 0\n1 3 0\n2 3 0\n2 3 0\n2 3 0\n3 3 0\n1 3 0\n1 3 0\n1 3 0\n3 3 0\n2 3 0\n1 3 0\n2 3 0\n2 3 0\n1 2 0\n3 2 0\n3 2 0\n2 2 0\n3 2 0\n1 2 0\n2 2 0\n3 2 0\n2 2 0\n3 2 0\n3 2 0\n2 2 0\n1 3 0\n2 3 0\n3 2 0\n3 2 0\n1 3 0\n2 3 0\n2 3 0\n3 2 0\n3 2 0\n1 2 0\n1 2 0\n1 2 0\n2 2 0\n3 2 0\n2 2 0\n2 2 0\n3 2 0\n1 2 0\n1 3 0\n1 3 0\n2 3 0\n1 3 0\n1 3 0\n1 3 0\n3 3 0\n3 3 0\n3 3 0\n1 3 0\n2 3 0\n2 3 0\n1 3 0\n1 3 0\n2 3 0\n2 3 0\n1 3 0\n1 3 0\n1 3 0\n3 1 0\n1 3 0\n2 3 0\n3 3 0\n1 3 0\n1 2 0\n2 1 0\n3 1 0\n1 3 0\n1 3 0\n3 2 0\n2 3 0\n1 3 0\n2 2 0\n2 3 0\n2 3 0\n3 3 0\n1 3 0\n3 2 0\n3 2 0\n2 3 0\n3 2 0\n3 2 0\n3 2 0\n3 2 0\n3 2 0\n1 2 0\n1 3 0\n1 3 0\n2 3 0\n1 3 0\n2 3 0\n1 3 0\n1 3 0\n1 2 0\n1 3 0\n1 3 0\n2 2 0\n1 3 0\n1 3 0\n1 3 0\n3 3 0\n2 3 0\n2 3 0\n1 3 0\n3 2 0\n2 3 0\n1 3 0\n3 3 0\n2 3 0\n3 2 0\n3 2 0\n1 3 0\n3 2 0\n3 2 0\n2 3 0\n1 3 0\n1 3 0\n2 3 0\n1 3 0\n2 3 0\n1 3 0\n3 3 0\n3 3 0\n2 3 0\n1 2 0\n3 2 0\n1 3 0\n1 3 0\n1 3 0\n3 2 0\n2 3 0\n1 3 0\n2 3 0\n1 3 0\n1 3 0\n1 3 0\n2 2 0\n1 3 0\n1 3 0\n2 3 0\n1 3 0\n2 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1 3 0\n1"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        print(f'Bill enters at (0.00, {float(stdin.split(\" \")[0])})\\n'\n              f'and leaves at (1000.00, {float(stdin.split(\" \")[2])})')\n    else:\n        print(f'Bill will be bitten.')\n    return ''\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin\n    \"\"\"\n    sns = []\n    for _ in range(int(stdin)):\n        sns.append(tuple(map(int, stdin.split())))\n\n    sns.sort(key=lambda x: (x[0], x[1]))\n    north = 0\n    south = 0\n    east = 0\n    west = 0\n    for sn in sns:\n        if sn[0] < north:\n            north = sn[0]\n        if sn[1] < west:\n            west = sn[1]\n        if sn[0] + sn[2] > north:\n            north = sn[0] + sn[2]\n        if sn[1] + sn[2] > west:\n            west = sn[1] + sn[2]\n    return str(south) +'' + str(north)\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_snakes = int(stdin.splitlines()[0])\n    snakes = [[int(x), int(y)] for x, y in stdin.splitlines()[1:]]\n\n    northwest = (0, 0)\n    northeast = (0, 1000)\n    southwest = (0, 1000)\n    southeast = (1000, 1000)\n    for snake in snakes:\n        northwest = min(northwest, (0, snake[1]))\n        southeast = max(southeast, (1000, snake[1]))\n        southwest = min(southwest, (snake[0], 0))\n        northeast = max(northeast, (snake[0], 1000))\n\n    midwest = (1000, (southwest[1] + northeast[1]) // 2)\n    mideast = (1000, (southwest[1] + northeast[1]) // 2)\n    if midwest == (0, 0) and mideast == (0, 1000):\n        print(\"Bill will be bitten.\")\n    else:\n        print(f\"Bill enters at {midwest[0]} {midwest[1]} and leaves at {mideast[0]} {mideast[1]}.\")\n    return stdout\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 500 500 499\n   ... 0 0 999\n   ... 1000 1000 200\n   ... ''')\n    'Bill enters at (0.00, 1000.00) and leaves at (1000.00, 800.00).'\n    >>> solution('''4\n   ... 250 250 300\n   ... 750 250 300\n   ... 250 750 300\n   ... 750 750 300\n   ... ''')\n    'Bill will be bitten.'\n    >>> solution('''4\n   ... 250 250 300\n   ... 750 250 300\n   ... 250 750 300\n   ... 750 750 300\n   ... ''')\n    'Bill enters at (2.00, 10.00) and leaves at (5.00, 7.00).'\n    \"\"\"\n    def pos_in_range(x, y):\n        if -1 < x < 1000 and -1 < y < 1000:\n            return True\n        else:\n            return False\n\n    def snake_in_range(x, y, d):\n        if -1 < x < 1000 and -1 < y < 1000:\n            if abs(x-x_start) < d and abs(y-y_start) < d:\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    snakes = int(stdin.strip())\n    s_start = stdin.splitlines()\n    # print(s_start)\n    if snakes == 0:\n        return 'Bill will be bitten.'\n    for i in range(snakes):\n        x_start, y_start, d = list(map(int, s_start[i].split()))\n        if pos_in_range(x_start, y_start) and snake_in_range(x_start, y_start, d):\n            return 'Bill enters at ({0:.2f}, {1:.2f}) and leaves at ({2:.2f}, {3:.2f})'.format(x_start, y_start, x_start + d, y_start + d)\n    return 'Bill will be bitten.'\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin.split()) > 1:\n        n = int(stdin.split()[0])\n        snakes = [\n            (int(x), int(y))\n            for x, y in (\n                stdin.split()[1].split(' '),\n            )\n        ]\n        if n > 1:\n            max_distance = max(snakes, key=lambda x: x[1])\n            snakes.remove(max_distance)\n            first_snake = snakes[0]\n            for snake in snakes:\n                if (\n                    abs(first_snake[0] - snake[0]) <= first_snake[1]\n                ) and (\n                    abs(first_snake[1] - snake[1]) <= first_snake[0]\n                ):\n                    return f\"Bill will be bitten.\"\n            return f\"Bill enters at {first_snake} and leaves at {max_distance[0]} {max_distance[1]}\"\n        elif n == 1:\n            return f\"Bill enters at ({stdin.split()[1]} {stdin.split()[2]})\"\n    else:\n        return \"No input.\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    snakes = []\n    for i in range(n):\n        x, y, d = list(map(int, stdin.split()))\n        snakes.append([x, y, d])\n    snakes.sort(key=lambda s: (s[2], s[0], s[1]))\n    return \"Bill enters at (%d.%d) and leaves at (%d.%d).\" % (int(snakes[0][0]), int(snakes[0][1]), int(snakes[-1][0]), int(snakes[-1][1]))\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    l = list(s)\n    l.sort()\n    #print(l)\n    l = list(map(lambda x: x * 2 if x == 'x' else '+' if x == '+' else x, l))\n    #print(l)\n    l = list(map(lambda x: str(x), l))\n    print(''.join(l))\n\n\nsolution(input())\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # For each element, extract the first character.\n    # Ignore spaces.\n    # The extracted string is a list of characters.\n    # We'll use this list to convert the string to a dictionary.\n    # If a character is a +, turn that into an o; if a character is a x, turn that into an o.\n    # Example:\n    # If we get the input \"++xx+x++\", we get a list [\"x\", \"x\", \"x\"]\n    # \"xx\" and \"oo\" are o-operands.\n    # Example 2:\n    # If we get the input \"xxxxxxxx\", we get a list [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"]\n    # \"x\" and \"oo\" are o-operands.\n    # So we have \"xxoooooo\"\n    operands, steps, max_power = stdin.split('\\n')\n    operands = operands.replace(' ', '')\n    operands = list(operands)\n    \n    # Convert the o-operands to +-operands\n    # Example: \"xx+x\" -> \"x+xx\"\n    o_operands = list()\n    for operand in operands:\n        if operand == 'x':\n            o_operands.append('+')\n        if operand == 'o':\n            o_operands.append('-')\n    \n    # Initialize a new dictionary.\n    # Each key in the dictionary is an o-operator,\n    # and each value is an o-operator.\n    # Example:\n    # {\"x\": \"+\", \"o\": \"-\"}\n    # If we start with the \"xx\" operator,\n    # we need to turn it into \"x+x\"\n    # and we need to turn it into \"-x+x-\".\n    # If we start with the \"oo\" operator,\n    # we need to turn it into \"o+o\"\n    # and we need to turn it into \"-o+o-\".\n    operator_dict = {}\n    for operand in o_operands:\n        if operand not in operator_dict:\n            operator_dict[operand] = operand\n        else:\n            operator_dict[operand] = operator_dict[operand] + operand\n    \n    # Initialize a new list.\n    # Each element is a dictionary.\n    # If the element is an o-operator, it means the o-operator will be deleted.\n    # Example:\n    # [\"{'x': '+'}\", {'x': '+'}]\n    # \"x\" and \"o\" are o-operands, so we need to delete them.\n    # If we were to keep \"x\", we would not want to delete it.\n    # If we were to keep \"o\", we would want to delete it.\n    # If we were to keep both, we'd want to delete both.\n    delete_list = []\n    for step in steps:\n        if step in operator_dict:\n            delete_list.append(step)\n    \n    # Delete the o-operands.\n    # Example: \"x+x+x+x\" -> \"x+x\"\n    # If we were to delete \"x\", we'd want to delete \"x\" and \"x\".\n    # If we were to delete \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\", we'd want to delete \"x\", \"o\" and \"o\".\n    delete_list = list(set(delete_list))\n    delete_list.sort(key=lambda x: x['x'])\n    delete_list.sort(key=lambda x: x['o'])\n    \n    # Delete the o-operands.\n    # If we were to delete \"x\", we'd want to delete \"x\" and \"x\".\n    # If we were to delete \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\", we'd want to delete \"x\" and \"o\".\n    # If we were to delete \"x\" and \"x\", we'd want to delete \"x\" and \"x\".\n    # If we were to delete \"o\" and \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"o\", we'd want to delete \"x\" and \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"x\", we'd want to delete \"x\" and \"o\" and \"x\".\n    # If we were to delete \"o\" and \"x\" and \"o\", we'd want to delete \"o\" and \"x\" and \"o\".\n    # If we were to delete \"o\" and \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"o\", we'd want to delete \"x\" and \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"x\", we'd want to delete \"x\" and \"o\" and \"x\".\n    # If we were to delete \"o\" and \"x\" and \"o\", we'd want to delete \"o\" and \"x\" and \"o\".\n    # If we were to delete \"o\" and \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"o\", we'd want to delete \"x\" and \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"x\", we'd want to delete \"x\" and \"o\" and \"x\".\n    # If we were to delete \"o\" and \"x\" and \"o\", we'd want to delete \"o\" and \"x\" and \"o\".\n    # If we were to delete \"o\" and \"o\", we'd want to delete \"o\" and \"o\".\n    # If we were to delete \"x\" and \"o\" and \"x\", we'd want to delete \"x\" and \"o\" and \"x\".\n    # If we were to delete \"x\" and \"o\" and \"x\", we'd want to delete \"x\" and \"o\" and \"x\".\n    "
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    stack = []\n    res = ''\n    power = 1\n    for i in stdin:\n        if i.isdigit():\n            if len(stack) > 0:\n                step = stack.pop()\n                if step == '+':\n                    power += int(i)\n                else:\n                    power *= int(i)\n            else:\n                step = i\n            if len(stack) == 0:\n                res += step\n            else:\n                step = stack.pop()\n                if step == '+':\n                    res += step\n                else:\n                    res += step.upper()\n        else:\n            if i in '+x':\n                stack.append(i)\n            else:\n                if i in 'x':\n                    stack.append(i.upper())\n            res += i\n    while len(stack) > 0:\n        step = stack.pop()\n        if step == '+':\n            power += 1\n        else:\n            power *= 2\n        res += step\n    return f'{res} {power}'\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    s = 2 ** s\n    rem = 0\n    result = []\n    while rem < m:\n        rem += 1\n        result.append(str(s + rem))\n        s = s // 2\n    return ''.join(result)\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    res = ''\n    for i in stdin:\n        if i == '+':\n            res += '+o'\n        else:\n            res += 'x'\n    return res\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    print(sorted(map(int, stdin))[::-1])\n    return ''.join(map(str, sorted(map(int, stdin))[::-1]))"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    c, s = (int(i) for i in stdin.split())\n    r = []\n    for i in range(c):\n        r.append(stdin[i])\n        if r[-1] == '+':\n            r[-1] = 'o'\n        if r[-1] == 'x':\n            r[-1] = 'o'\n            r.append('o')\n    print(''.join(r))\n    return ''.join(r)\n\nprint(solution(input()))\n\nSample Input 3:\n10 5\nxx+x++x+x+x+x+x+x++x\nSample Output 3:\nxxoo+xx+xooo\n\nSample Input 4:\n8 3\nxx+x++x\nSample Output 4:\nxxoo+xo+xoo\n'''\n\n'''\n---SOLUTION---\n- We want to minimize the difference between the remaining power and the maximum possible power\n- We can do this by iteratively checking all the possible steps that we can do to get the maximum possible power\n\n- We can start with a power of 1, and we can only move +1, so we keep 1 as power and move to the next power\n- We can move x, so we multiply the power by 2, and move to the next power\n- If the new power is more than the max_pow, we move o, which means we cannot move anymore so we put a +1 to the power\n- If the new power is less than max_pow, we move x, which means we can move more so we put a +1 to the power\n- If the new power is equal to max_pow, we keep it as the power\n'''"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    steps, strength = stdin.split(\" \")\n    steps, strength = int(steps), int(strength)\n    if steps > strength:\n        return stdin\n    else:\n        o_steps = []\n        no_op = []\n        for i in range(1, strength + 1):\n            if i % 2 == 0:\n                o_steps.append(\"o\")\n            else:\n                no_op.append(\"o\")\n        o_steps_str = \"\".join(o_steps)\n        no_op_str = \"\".join(no_op)\n        new_stdin = o_steps_str + no_op_str\n        return new_stdin\n"
    },
    {
        "number": 3213,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    s = str(s)\n    steps = s[0] + s[1]\n    # print(steps)\n    n = []\n    for i in range(len(steps)):\n        if steps[i] == 'x':\n            n.append(i)\n    for i in range(len(n)):\n        if n[i] == 1:\n            steps = steps[:n[i]] + 'o' + steps[n[i] + 1:]\n            print(steps)\n    return steps\n\nsolution(input())"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    paragraph = stdin.split('***')[0]\n    def parse_paragraph():\n        words = []\n        cur = []\n        for c in paragraph:\n            if c =='':\n                if cur:\n                    words.append(''.join(cur))\n                cur = []\n            elif c == ',':\n                if cur:\n                    words.append(''.join(cur))\n                cur = []\n            elif c.isalpha():\n                cur.append(c)\n        if cur:\n            words.append(''.join(cur))\n        return words\n    \n    result = []\n    for i in range(0,len(paragraph),80):\n        word_cores = parse_paragraph()[i:i+80]\n        similar_words = set()\n        for j in range(0,len(word_cores)-1):\n            if word_cores[j].lower() == word_cores[j+1].lower():\n                similar_words.add(word_cores[j].lower())\n        result.append(' '.join(word_cores) +'' +''.join(sorted(similar_words)))\n    return '\\n'.join(result)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = list(stdin.splitlines())\n    text = \"\".join(data[1:])\n    return \" \".join([f\"{word[0]}:{word[1:]}\" for word in sorted([word.split(\":\") for word in text.split(\" \")], key=lambda x: x[0])])"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    # Extract the core of the word from the line\n    word = stdin.split(\":\")[0]\n\n    # Initialize an empty set for similar words\n    similar = set()\n\n    # Convert the whole line into a list of words\n    words = word.split(\" \")\n\n    # For each word in the line, check if it is similar to the\n    # word to the left\n    for i in range(0, len(words)):\n        if words[i] in similar:\n            continue\n\n        # Check if the core is present in the previous words\n        for j in range(i, 0, -1):\n            core = words[j]\n            if core == word:\n                break\n\n            if core in word:\n                similar.add(core)\n                break\n\n    # Print the core if the word is similar to the words to the left\n    if len(similar) > 0:\n        print(word + \": \" + \" \".join(sorted(similar)))\n\n    # If the core is not similar to the words to the left, print the\n    # word core as it is\n    else:\n        print(word)\n\n    return word\n\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join(\n        sorted(\n            (\n                f'{word}:{replacement}'\n                for word, replacement in (\n                    word_core.split(':') for word_core in\n                    stdin.split('***')\n                )\n            ),\n            key=lambda x: (x[0], x[1])\n        )\n    )"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s =''.join(stdin.split('\\n'))\n    s = s.split('***')\n    d = {}\n    for i in s:\n        k =''.join(i.split())\n        k = k.split(' ')\n        for j in k:\n            d[j] = d.get(j, 0) + 1\n    ans = []\n    for i in d:\n        ans.append((i, d[i]))\n    ans.sort(key=lambda x: (x[1], x[0]))\n    return '\\n'.join(map(lambda x: '%s: %s' % (x[0], x[1]), ans))\n"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"***\")\n    for line in lines:\n        line = line.split(\"\\n\")\n        print(line)\n"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin.splitlines()\n    result = \"\"\n    for word in text:\n        result += \":\" + word + \"\\n\"\n        for word1 in word.split(\" \"):\n            for word2 in word1.split(\"'\"):\n                if word2 in word1:\n                    result += word1\n                    result += \":\"\n                    result += word1\n    if \"***\" in result:\n        result = \"***\"\n    return result\n\nprint(solution(input()))\n"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    similar_words = []\n    for line in lines:\n        if not line:\n            continue\n        line = line.strip()\n        if not line:\n            continue\n        core = line\n        for _ in range(len(line)):\n            core = core[1:] + core[0]\n            if core in similar_words:\n                break\n        else:\n            similar_words.append(core)\n    return '\\n'.join(sorted(similar_words))\n"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    ans = []\n    for line in lines:\n        ans.append(solution_helper(line.replace('\\r', '').replace('\\n', '')))\n    return '\\n'.join(ans)\n\n\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # def txt_to_words():\n    #     txt_to_words = open(stdin)\n    #     words_list = txt_to_words.read().split(\" \")\n    #     txt_to_words.close()\n    #     return words_list\n\n    def words_to_txt(words_list):\n        words_to_txt = \"\"\n        for word in words_list:\n            if word!= \"\":\n                words_to_txt += word + \" \"\n        return words_to_txt\n\n    def word_core(word):\n        core_word = word.lower()\n        core_word = core_word.replace(\",\", \"\")\n        core_word = core_word.replace(\".\", \"\")\n        core_word = core_word.replace(\"'\", \"\")\n        core_word = core_word.replace(\"?\", \"\")\n        core_word = core_word.replace(\"!\", \"\")\n        core_word = core_word.replace(\":\",\"\")\n        core_word = core_word.replace(\";\",\"\")\n        core_word = core_word.replace(\"(\",\"\")\n        core_word = core_word.replace(\")\",\"\")\n        core_word = core_word.replace(\"[\",\"\")\n        core_word = core_word.replace(\"]\",\"\")\n        core_word = core_word.replace(\"-\",\"\")\n        core_word = core_word.replace(\"'\",\"\")\n        return core_word\n\n    def check_word_core(word, words_list):\n        core_word = word_core(word)\n        index_word = words_list.index(core_word)\n        words_list.pop(index_word)\n        return core_word\n\n    def sim_words(words_list):\n        for word in words_list:\n            core_word = word_core(word)\n            if core_word in words_list:\n                words_list.remove(core_word)\n        return words_list\n\n    def transpose(words_list):\n        word_transpose = words_list\n        for word in word_transpose:\n            word_transpose.remove(word)\n        for word in word_transpose:\n            if len(word) > 2:\n                words_list.append(word[::-1])\n        return words_list\n\n    def transpose_words(words_list):\n        for word in words_list:\n            transpose_words = transpose(words_list)\n        return transpose_words\n\n    def sim_words_transpose(words_list):\n        for word in words_list:\n            if word_core(word) in words_list:\n                words_list.remove(word_core(word))\n        return words_list\n\n    def check_word_list(words_list):\n        for word in words_list:\n            core_word = word_core(word)\n            index_word = words_list.index(core_word)\n            words_list.pop(index_word)\n        return words_list\n\n    def check_word_list_transpose(words_list):\n        words_list.reverse()\n        for word in words_list:\n            core_word = word_core(word)\n            index_word = words_list.index(core_word)\n            words_list.pop(index_word)\n        return words_list\n\n    # def txt_to_words():\n    #     words_list = []\n    #     with open(stdin, 'r') as file:\n    #         while True:\n    #             # read file\n    #             line = file.readline()\n    #             if line:\n    #                 # split line\n    #                 words_list.append(line.strip().lower())\n    #             else:\n    #                 # print line\n    #                 break\n    #     return words_list\n\n    def txt_to_words():\n        words_list = words_to_txt(stdin).split(\" \")\n        return words_list\n\n    def word_core_list(words_list):\n        word_core_list = []\n        for word in words_list:\n            word_core_list.append(word_core(word))\n        return word_core_list\n\n    def sim_word_list(words_list):\n        word_core_list = word_core_list(words_list)\n        return sim_word_list(word_core_list)\n\n    def transpose_word_list(words_list):\n        word_core_list = word_core_list(words_list)\n        transpose_word_list = transpose_word_list(word_core_list)\n        return transpose_word_list\n\n    def sim_word_list_transpose(words_list):\n        word_core_list = word_core_list(words_list)\n        sim_word_list_transpose = sim_word_list_transpose(word_core_list)\n        return sim_word_list_transpose\n\n    words_list = txt_to_words()\n    # print(words_list)\n    word_core_list = word_core_list(words_list)\n    # print(word_core_list)\n    sim_word_list = sim_word_list(word_core_list)\n    print(sim_word_list)\n    transpose_word_list = transpose_word_list(sim_word_list)\n    print(transpose_word_list)\n    sim_word_list_transpose"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n    if n == 1:\n        return 1\n    l = []\n    r = []\n    for i in range(n - 1):\n        l.append(c.pop(0))\n        r.append(c.pop())\n    if l + r == sorted(l + r):\n        return 1 + solution(str(l)) + solution(str(r))\n    return 2 + solution(str(l)) + solution(str(r))\n\nprint(solution(stdin))\n\n'''\n"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    cards = list(map(int, stdin.split()))\n    assert len(cards) == 10\n    for i in range(1, len(cards)):\n        if cards[i - 1] > cards[i]:\n            return str(i)\n    return str(len(cards))"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # return sum(len(set(stdin.split()))*(len(stdin.split())-1)/2)\n    deck = list(map(int, stdin.split()))\n    turns = 0\n    while len(deck) > 1:\n        for i in range(len(deck)):\n            if i % 2 == 0:\n                deck[i], deck[i + 1] = deck[i + 1], deck[i]\n        turns += 1\n    return str(turns)"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Your code here!\n    '''\n    n = int(stdin)\n    from collections import deque\n    # the deck of cards\n    deck = deque(range(1, n + 1))\n    # the numbers of cards per round\n    num_rounds = len(stdin.split()) - 1\n    # the number of times we have shuffled\n    num_shuffles = 0\n    # which stack we are on\n    stack = deque()\n    # the deck is shuffled only once\n    num_shuffles = 1\n    # the stack of the numbers we are on\n    stack = deque()\n    # to record which cards have been put in each stack\n    card_count = [0 for i in range(n)]\n    # print(card_count)\n    # start the shuffling\n    while num_rounds > num_shuffles:\n        # get the top element from the stack\n        num = deck.popleft()\n        # add it to the stack\n        stack.append(num)\n        # the number of cards in the stack\n        cnt = len(stack)\n        # if this card is a new smallest one, we've done some shuffling\n        if cnt <= card_count[num]:\n            # add to num_shuffles\n            num_shuffles += 1\n            # record the card\n            card_count[num] = cnt\n        # the index of the smallest number in the stack\n        smallest_ind = cnt - 1\n        # put it back in the stack\n        deck.append(num)\n        # swap the cards\n        tmp = stack[smallest_ind]\n        stack[smallest_ind] = stack[-1]\n        stack[-1] = tmp\n        # if the stack is in the right place, we can end the shuffling\n        if stack == deck:\n            break\n    # print(num_shuffles)\n    # print(stack)\n    return str(num_shuffles)\n"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, cards = stdin.split(\"\\n\")\n    cards = list(map(int, cards.split()))\n    stacks = [cards[:len(cards)//2], cards[len(cards)//2:]]\n    stacks = [sorted(s) for s in stacks]\n    for _ in range(2):\n        stacks = list(map(list, zip(*stacks)))\n        stacks = [sorted(s) for s in stacks]\n    return str(len(cards)-len(stacks[0])+len(stacks[1]))\n"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(map(int, stdin.strip().split()))\n    n = len(s)\n    if n == 1:\n        return 1\n    count = 1\n    while (s!= sorted(s)):\n        s.sort()\n        count += 1\n    return count"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('10\\n3 8 1 9 4 5 2 7 10 6')\n    '2'\n    >>> solution('1 2 3 4 5 6 7 8 9 10')\n    '1'\n    '''\n    return str(min(get_riffle(get_split(stdin))))\n\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cards = list(map(int, stdin.split()))\n\n    def partition(cards, p, r):\n        x = cards[p]\n        i = p\n        j = r\n\n        while i <= j:\n            while i <= j and cards[i] <= x:\n                i += 1\n            while i <= j and cards[j] >= x:\n                j -= 1\n\n            if i < j:\n                cards[i], cards[j] = cards[j], cards[i]\n\n        cards[p], cards[j] = cards[j], cards[p]\n\n        return j\n\n    def quick_sort(cards, p, r):\n        if p < r:\n            q = partition(cards, p, r)\n            quick_sort(cards, p, q - 1)\n            quick_sort(cards, q + 1, r)\n\n    quick_sort(cards, 0, n - 1)\n    return n - p\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    c = list(map(int, stdin.strip().split()))\n    best = float('inf')\n    for i in range(1, n):\n        shuffle = list(c)\n        shuffle.append(shuffle.pop(i))\n        shuffle = sorted(shuffle)\n        best = min(best, len(shuffle))\n    return str(best)\n"
    },
    {
        "number": 3215,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split('\\n')\n    n = int(data[0])\n    c = list(map(int, data[1].split()))\n    seen = {i: i for i in range(1, n + 1)}\n    ans = 0\n    while len(seen) > 1:\n        #print(c, seen, ans)\n        k, seen = max([(len(seen), list(seen.keys())[i]) for i in range(len(seen))], key=lambda x: x[0])\n        #print(k, seen)\n        for j in range(k):\n            if seen[j] in seen:\n                seen.pop(j)\n        ans += 1\n    return ans\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin.split()[0]\n    repeat = int(stdin.split()[1])\n    if repeat == 1:\n        if len(num) == 2:\n            print(0, 1)\n        else:\n            print(\"0/1\")\n    else:\n        num = int(num)\n        if len(num) == 1:\n            if repeat <= 2:\n                print(\"0/1\")\n            else:\n                print(repeat - 1, repeat)\n        else:\n            if repeat <= 2:\n                print(num, repeat)\n            else:\n                k = 1\n                i = 2\n                print(\"(\", end=\"\")\n                while k <= repeat:\n                    num = num * 10\n                    if num % 10 == 0:\n                        print(0, end=\"\")\n                    else:\n                        print(num // 10, end=\"\")\n                    k += 1\n                    i += 1\n                    if i % k == 0:\n                        print(\")\", end=\"\")\n                        i = 0\n    return \"\"\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    decimal, repeat = stdin.split(\" \")\n    left, right = 0, len(decimal) - 1\n    sum_number = 0\n\n    while left <= right:\n        left_number = int(decimal[left:left + int(repeat)])\n        right_number = int(decimal[right:right + int(repeat)])\n        sum_number += left_number\n        sum_number += right_number\n\n        left += int(repeat)\n        right -= int(repeat)\n        \n    return str(sum_number)"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split()\n    n = list(map(int, n[::-1]))\n    m = int(m)\n    n = n[:-m]\n    n.reverse()\n    d1 = sum(n)\n    n = list(map(int, n))\n    n.reverse()\n    d2 = sum(n)\n    res = str(d1//d2)\n    return res\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    number, repeat = stdin.split()\n    number = list(map(float, number.split(\".\")))\n    repeat = int(repeat)\n    answer = \"0.\" + \"\".join(str(n) for n in number[0])\n    if number[1]!= 0:\n        answer = answer + \".\" + \"\".join(str(n) for n in number[1])\n    for i in range(repeat):\n        if i % 2!= 0:\n            answer = answer + \".\" + str(number[0] * number[1])\n        else:\n            answer = answer + \".\" + str(number[1])\n    return answer\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    nums, repeat = stdin.strip().split()\n    decimal, digits = nums.split(\".\")\n    nums = int(decimal)\n    repeat = int(repeat)\n\n    decimal_repeated = decimal[:repeat]\n    div = 10**(len(decimal_repeated) - repeat)\n    int_repeated = int(decimal_repeated) * div\n\n    return str(int_repeated) + \"/\" + str(nums)\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    digits, decimal_point = stdin.split(\".\")\n    n = len(digits)\n    repetitions = int(stdin.split(\" \")[1])\n    decimal_point = int(decimal_point)\n    \n    res = 0\n    digits = int(digits)\n    # a number is just a sequence of digits, with no leading zeros, and\n    # no trailing zeros\n    while digits >= 1:\n        # find the number of digits in the current number\n        current_number_of_digits = 1 + len(str(digits))\n        \n        # if number of digits is equal to the number of digits to the right of the decimal point,\n        # then it is a repeated digit\n        if current_number_of_digits == decimal_point:\n            # multiply the number of repetitions by the number of digits\n            res = res * (10 ** repetitions)\n            # the number of digits to the right of the decimal point is the number of repetitions\n            repetitions -= 1\n            \n        digits = digits // 10\n        \n    res = res * (10 ** repetitions)\n    \n    return str(res)\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    d = 1\n    while True:\n        if n % 10 == 0:\n            n = n // 10\n        else:\n            break\n    return f'{d}/{n}'\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(''.join(list(filter(str.isdigit, a))))\n    b = int(b)\n    frac = Fraction(a, b)\n    print(frac.numerator, frac.denominator)\n    if frac.numerator >= frac.denominator:\n        num = int(frac.numerator/frac.denominator)\n    else:\n        num = int(frac.denominator/frac.numerator)\n    if num > 1:\n        num_list = list(str(num))\n        return ''.join([num_list[1], '/', num_list[0]])\n    else:\n        return str(num)\nprint(solution(input()))\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    number, repetitions = stdin.split()\n    n, d = number.split('.')\n    n, d = int(n), int(d)\n    d *= repetitions\n\n    print(n // d, n % d)\n"
    },
    {
        "number": 3216,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, a, b = stdin.split()\n    a = int(a)\n    b = int(b)\n    n = 0\n    for i in range(a):\n        n += int(b)\n        b = b * 10\n    return '{}/{}'.format(n, b)\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    grid = []\n    defects = 0\n    for i in range(1000):\n        line = stdin.split()\n        grid.append([int(x) for x in line[:3]])\n        if int(line[3]) == 1:\n            defects += 1\n    panels = 0\n    for x, y, z in itertools.product(range(9), range(9), range(9)):\n        if not (x, y, z) in [(0, 0, 0), (0, 0, 8), (0, 8, 0), (0, 8, 8), (8, 0, 0), (8, 0, 8), (8, 8, 0), (8, 8, 8)]:\n            if sum(grid[i][x] for i in range(9)) == sum(grid[i][y] for i in range(9)) == sum(grid[i][z] for i in range(9)) == 0:\n                panels += 1\n    return str(panels + defects)\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    grid = []\n    for _ in range(n):\n        grid.append([int(x) for x in stdin.split()])\n    defective = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                defective.append((i, j))\n    min_panels = float('inf')\n    for cell in defective:\n        x, y, z = cell\n        if x > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2)\n        if x > 0 and y > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n        if x > 0 and z > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n        if x > 0 and y > 0 and z > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n        if y > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2)\n        if y > 0 and z > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n        if y > 0 and x > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2)\n        if y > 0 and z > 0 and x > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n        if z > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2)\n        if z > 0 and x > 0:\n            min_panels = min(min_panels, (x+1)**2 + (y+1)**2 + (z+1)**2)\n    return str(min_panels)\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split()[0])\n    grid = [[[0 for x in range(n)] for y in range(n)] for z in range(n)]\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i == 0 or i == n-1 or j == 0 or j == n-1 or k == 0 or k == n-1:\n                    grid[i][j][k] = 1\n                else:\n                    grid[i][j][k] = 0\n    count = 0\n    while not (n == 1 and grid[0][0][0] == 1):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if not grid[i][j][k]:\n                        continue\n                    elif grid[i][j][k] and (i == 0 or i == n-1 or j == 0 or j == n-1 or k == 0 or k == n-1):\n                        grid[i][j][k] = 1\n                    else:\n                        grid[i][j][k] = 0\n                    count += 1\n                    if count == 10:\n                        return count\n    return count\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(min(n, 5))\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of test cases and runs them.\n    \"\"\"\n    lines = stdin.strip().split(\"\\n\")\n\n    test_case = 0\n    while test_case < len(lines):\n        cells = []\n        while len(lines[test_case]) > 0:\n            cells.append([int(line) for line in lines[test_case].split()])\n            test_case += 1\n        print(cells)\n        print(len(cells))\n        print(solution_2(cells))\n        print(\"-\"*50)\n    return \"0\"\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def make_grid(n):\n        return [[0] * n for _ in range(n)]\n\n    def walk_grid(grid):\n        new_grid = []\n        for row in range(len(grid)):\n            new_grid.append([])\n            for column in range(len(grid[0])):\n                # Search down\n                if row > 0 and grid[row - 1][column] == 0:\n                    new_grid[row].append(grid[row - 1][column] + 1)\n                # Search right\n                if column > 0 and grid[row][column - 1] == 0:\n                    new_grid[row].append(grid[row][column - 1] + 1)\n                # Search up\n                if row < len(grid) - 1 and grid[row + 1][column] == 0:\n                    new_grid[row].append(grid[row + 1][column] + 1)\n                # Search left\n                if column < len(grid[0]) - 1 and grid[row][column + 1] == 0:\n                    new_grid[row].append(grid[row][column + 1] + 1)\n        return new_grid\n\n    def calculate_min_panels(grid):\n        seen_count = 0\n        panels = 0\n        for row in range(len(grid)):\n            for column in range(len(grid[0])):\n                if grid[row][column]!= 0:\n                    panels += 1\n                if grid[row][column] == 0 and (row > 0 and grid[row - 1][column]!= 0) and (column > 0 and grid[row][column - 1]!= 0) and (row < len(grid) - 1 and grid[row + 1][column]!= 0) and (column < len(grid[0]) - 1 and grid[row][column + 1]!= 0):\n                    seen_count += 1\n        return seen_count, panels\n\n    def min_panels(grid):\n        for _ in range(100):\n            # print(f\"grid: {grid}\")\n            # print(f\"walk_grid: {walk_grid(grid)}\")\n            # print(f\"calculate_min_panels: {calculate_min_panels(walk_grid(grid))}\")\n            new_grid = walk_grid(grid)\n            seen_count, panels = calculate_min_panels(new_grid)\n            # print(f\"seen_count: {seen_count}\")\n            # print(f\"panels: {panels}\")\n            if seen_count == len(grid):\n                return panels\n            grid = new_grid\n        return -1\n\n    n = int(stdin)\n    grid = make_grid(n)\n    for line in stdin.splitlines():\n        x, y, z = map(int, line.split())\n        grid[x][y] = z\n    return str(min_panels(grid))\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return f'{min_panels(stdin):.0f}'"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin)\n    if size == 0:\n        return \"0\"\n    elif size == 1:\n        return \"6\"\n    else:\n        return str(6 + 2*(size - 2) + 2*(size - 1))"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"3\" if len(stdin.splitlines()) == 1 else str(len(set(map(tuple, map(tuple, stdin.splitlines())))) + 1)\n"
    },
    {
        "number": 3217,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    defective_cells = int(stdin)\n    min_panels = 0\n    num_cells_per_panel = 3\n    num_panels = int(defective_cells / num_cells_per_panel)\n    num_panels += defective_cells % num_cells_per_panel\n    while num_panels > 0:\n        min_panels += num_panels\n        num_panels = int(num_panels / num_cells_per_panel)\n        num_panels += defective_cells % num_cells_per_panel\n    return str(min_panels)\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [[int(x) for x in stdin.split()] for _ in range(n)]\n    colors = [[-1] * n for _ in range(n)]\n    color = 0\n    for i in range(n):\n        for j in range(n):\n            if i % 2 == 1:\n                if colors[i][j] == -1:\n                    color += 1\n                colors[i][j] = color\n            else:\n                if colors[i][j] == -1:\n                    colors[i][j] = color\n                if colors[i][j] == -1:\n                    color += 1\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if colors[i][j] == -1:\n                return 0\n    for i in range(n):\n        for j in range(n):\n            if i % 2 == 1:\n                if (i + 1, j) in [(i, j) for i in range(n) if i % 2 == 1]:\n                    return 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i % 2 == 0:\n                    if j % 2 == 0:\n                        if (i, j) not in [(i, j) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, j) in [(i, j) for i in range(n) if i % 2 == 1]:\n                            return 0\n                if i % 2 == 0:\n                    if k % 2 == 0:\n                        if (i, k) not in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, k) in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if (i + 1, j + 1) in [(i, j) for i in range(n) if i % 2 == 0] or (i - 1, j + 1) in [(i, j) for i in range(n) if i % 2 == 0]:\n                    return 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if (i + 1, j) in [(i, j) for i in range(n) if i % 2 == 0]:\n                    if (i, j + 1) not in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n                if (i - 1, j) in [(i, j) for i in range(n) if i % 2 == 0]:\n                    if (i, j + 1) not in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if j % 2 == 0:\n                    if (i + 1, j) not in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n                if j % 2 == 1:\n                    if (i + 1, j) in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n                if i % 2 == 0:\n                    if k % 2 == 0:\n                        if (i, k) not in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, k) in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                if i % 2 == 1:\n                    if k % 2 == 0:\n                        if (i, k) not in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, k) in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if j % 2 == 1:\n                    if (i + 1, k) not in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n                if j % 2 == 0:\n                    if (i + 1, k) in [(i, j) for i in range(n) if i % 2 == 1]:\n                        return 0\n                if i % 2 == 1:\n                    if k % 2 == 0:\n                        if (i, k) not in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, k) in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                if i % 2 == 0:\n                    if k % 2 == 0:\n                        if (i, k) not in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n                    else:\n                        if (i, k) in [(i, k) for i in range(n) if i % 2 == 1]:\n                            return 0\n    return count"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return '1'\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    values = stdin[1:]\n    values = [int(x) for x in values]\n    counter = 0\n    for i in range(0, n + 1, 2):\n        j = (i - 1) // 2\n        if values[i] == -1:\n            continue\n        for k in range(i + 1, n + 1, 2):\n            if values[i] == -1 or values[k] == -1:\n                continue\n            if k + 2 - i <= 1:\n                counter += 1\n                break\n            for l in range(i + 1, k + 1, 2):\n                if values[l] == -1:\n                    continue\n                if i == 0 and k == n - 1:\n                    counter += 1\n                    break\n                if l + 2 - i <= 1:\n                    counter += 1\n                    break\n                for m in range(k + 1, l + 1, 2):\n                    if values[m] == -1:\n                        continue\n                    if i == 0 and l == n - 1:\n                        counter += 1\n                        break\n                    if m + 2 - l <= 1:\n                        counter += 1\n                        break\n                    for n in range(l + 1, m + 1, 2):\n                        if values[n] == -1:\n                            continue\n                        if m == n - 1:\n                            counter += 1\n                            break\n                        if m + 2 - n <= 1:\n                            counter += 1\n                            break\n    return str(counter)\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n    -1 2 -1\n    2 2\n    1 -1 1\n    ''')\n    '1'\n    >>> solution('''7\n    -1 4 5 1 0 -1 -1\n    -1 3 2 0 0 1\n    -1 4 -1 1 0 -1 -1\n    1 3 4 2 2 4\n    0 2 3 -1 4 4 2\n    -1 4 4 3 3 2\n    1 -1 -1 -1 4 2 -1\n    ''')\n    '1'\n    \"\"\"\n    m = list(map(list, stdin.splitlines()))\n    n = len(m)\n    if n % 2 == 1:\n        return 0\n    def count(a, b):\n        for c in range(len(a)):\n            if a[c]!= -1:\n                return False\n            for d in range(len(b)):\n                if b[d]!= -1:\n                    return False\n                if a[c] == b[d]:\n                    return False\n                if abs(a[c] - b[d]) == abs(a[c] - c) + abs(b[d] - d):\n                    return False\n        return True\n    for i in range(n):\n        if i % 2 == 1:\n            m[i] = list(map(int, m[i]))\n        else:\n            m[i] = list(map(int, m[i][::-1]))\n    for i in range(len(m)):\n        for j in range(len(m[i])):\n            for k in range(i + 1, len(m)):\n                if count(m[i], m[k]) and count(m[k], m[i]):\n                    return 0\n    return sum(map(lambda x: len(x) - 1, m))"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    ans = 0\n\n    for i in range(2, n - 2):\n        for j in range(i, n):\n            # colored[i, j] = sum([color for color in range(1, 7) if a[i][color] == a[j][color]])\n            #   coloring[i, j] = colored[i, j] + 1\n            color = 0\n            for k in range(i, j + 1):\n                color += a[k][i % 2]\n            ans += color + 1\n\n    return str(ans)\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = 0\n    for i in range(n // 2, n):\n        for j in range(i - 1):\n            if m < abs(i - j) - abs(i - n - j) + 1:\n                m = abs(i - j) - abs(i - n - j) + 1\n    return str(m)\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = {(i, j): int(stdin[i + j]) for i in range(n) for j in range(n - 1, -1, -1) if not (i % 2 and j % 2) and int(stdin[i + j]) >= 0}\n    return str(len([1 for i in a if len({k for k, v in a.items() if k[0] == i[0] and v!= -1}) == len(a) or len({k for k, v in a.items() if k[0] == i[0] and v!= -1}) == len(a) - 1]))\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = list(map(int, stdin.split()))\n    n = stdin_list[0]\n    a = stdin_list[1:]\n    print(number_of_valid_coloring(n, a))\n\n\ndef"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(i, j, a):\n        # Check all adjacent hexagons\n        for k in range(1, max(i, j)):\n            if a[i-k][j]!= -1:\n                if a[i-k][j]!= a[i][j]:\n                    return False\n            if a[i][j-k]!= -1:\n                if a[i][j-k]!= a[i][j]:\n                    return False\n        # Check self-intersections\n        for k in range(1, i):\n            if i-k!= j:\n                if a[i-k][j] == a[i][j]:\n                    return False\n        for k in range(1, j):\n            if j-k!= i:\n                if a[i][j-k] == a[i][j]:\n                    return False\n        return True\n\n    n = int(stdin)\n    a = []\n    for i in range(n):\n        a.append([int(x) for x in stdin.split()])\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == -1:\n                continue\n            if is_valid(i, j, a):\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3218,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdout = 0\n    for row in range(1, len(stdin) + 1, 2):\n        row_arr = list(map(lambda x: int(x), stdin[row - 1].split()))\n        # print(f'row_arr: {row_arr}')\n        for col in range(len(row_arr)):\n            if row_arr[col] < 0:\n                row_arr[col] = -1\n            # print(f'row_arr[{col}]: {row_arr[col]}')\n        # print(f'{row_arr}')\n        # print(f'{row_arr}')\n        stdout += len(list(filter(lambda x: x > 0, row_arr)))\n    return str(stdout)\n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \"3\"\n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    print(len(set(bit_for_number(int(stdin, 2)))))\n\ndef"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = stdin\n    return str(bin(int(N, 2)))[2:]\n    \n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num, n = stdin.split('\\n')\n    return str(len(set([num[i] + num[~i] for i in range(len(num))]))) + '\\n'\n\n\nprint(solution(input()))\n\"\"\""
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    bit_map = {\n        0: 1,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 5,\n        5: 7,\n        6: 9,\n        7: 11,\n        8: 13,\n        9: 15\n    }\n\n    digit_map = {\n        0: 0,\n        1: 1,\n        2: 0,\n        3: 1,\n        4: 0,\n        5: 1,\n        6: 0,\n        7: 2,\n        8: 0,\n        9: 3\n    }\n\n    res = 1\n    for digit in stdin:\n        if digit in bit_map:\n            res = res * bit_map[digit]\n        if digit in digit_map:\n            res = res * digit_map[digit]\n    return str(res % 1000000009)\n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    count = 0\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                if (i * 2 + j + k) == int(n, 2):\n                    count += 1\n    return count"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = stdin\n    ans = 0\n    for i in range(1,len(N)+1):\n        if '1'*i in N and '2'*i in N:\n            ans +=1\n    return str(ans)\n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(set(stdin))%1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return ''.join(map(lambda x: ''.join(x.count('1')), [i for i in stdin.split('0')]))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3219,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    digits = stdin\n    return len(set(map(lambda s: s[0]+'1'+s[1]+'0', zip(digits, digits[1:]))))\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split(\"\\n\")\n    n = int(inp[0])\n    p1, p2, p3, p4, p5 = map(int, inp[1].split(\" \"))\n    c1, c2 = 0, 0\n    for i in range(1, n):\n        if c1 + p1 <= i <= c2 + p2:\n            c2 += p3\n        elif c2 + p2 <= i <= c1 + p1:\n            c1 += p4\n        else:\n            c1 += p5\n    return \"LLR\" if c1 <= c2 else \"RLR\"\n"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    strings = stdin.split()\n    if len(strings)!= N:\n        raise ValueError(\"Number of arguments mismatch\")\n\n    arr = []\n    for string in strings:\n        arr.append(int(string))\n\n    return run(arr)\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    c = collections.defaultdict(int)\n    for p_i in p:\n        c[p_i] += 1\n    min_len = float('inf')\n    result = \"\"\n    for p_i in range(1, N + 1):\n        if c[p_i] == 1:\n            result += \"LLL\"\n            min_len = min(min_len, 3)\n        elif c[p_i] == 2:\n            result += \"LLR\"\n            min_len = min(min_len, 2)\n        elif c[p_i] == 3:\n            result += \"RRR\"\n            min_len = min(min_len, 1)\n        else:\n            return \"no\"\n    return result if min_len == float('inf') else result[:min_len]\n"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    st = stdin.split()\n    numbers = [int(x) for x in st]\n    directions = {\n        1: \"L\",\n        2: \"R\",\n    }\n    moves = {}\n    i = 0\n    while i < N:\n        moves[i] = []\n        while True:\n            try:\n                directions[numbers[i]]\n                moves[i].append(directions[numbers[i]])\n                i += 1\n                break\n            except:\n                break\n    return moves"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    def valid(n):\n        s = set()\n        for i in range(1, n):\n            if i in s:\n                return False\n            s.add(i)\n        return True\n\n    def solution_rec(n):\n        if n == 1:\n            return [\"L\"]\n        if n == 2:\n            return [\"LL\", \"RR\"]\n        ans = []\n        for i in range(1, n):\n            curr = solution_rec(n - i - 1)\n            for l in curr:\n                ans.append(\"LL\" + l)\n                ans.append(\"RL\" + l)\n        return ans\n    return \"\".join(solution_rec(int(stdin)))\n"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    return ''.join(('LL' if p == 1 else 'RR') for p in stdin)"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return \"\".join([\"L\" if x else \"R\" for x in [x + 1 for x in range(n)]])"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = list(map(int, stdin.split()))\n    i = 1\n    dp = [[None] * n for _ in range(n)]\n    dp[0][0] = 'R'\n    while i < n:\n        j = 0\n        while j < i:\n            if p[j] + 1 == p[i] or p[j] - 1 == p[i]:\n                dp[j][i] = 'R'\n                dp[i][j] = 'R'\n            else:\n                dp[j][i] = 'L' if dp[j][i - 1] == 'R' else 'R'\n            j += 1\n        i += 1\n    result = \"\"\n    for i in range(n):\n        result += dp[i][-1]\n    return result\n"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    directions = list(map(int, stdin.split()))\n\n    # generate the circle\n    numbers = range(n + 1)\n    circle = itertools.cycle(numbers)\n    circle = list(circle)\n    circle.extend(numbers)\n    circle = list(circle)\n\n    # create an array to represent the circle\n    # where the circle[i] is the position of the i-th wizard\n    # in the circle\n    circle_array = []\n    for i in range(1, n + 1):\n        circle_array.append(i)\n\n    # fill the circle with the \"right\" of the circle\n    # this means a wizard can only be adjacent to a wizard to the right\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            circle_array[i], circle_array[j] = circle_array[j], circle_array[i]\n\n    # now let's do the actual dancing\n    # the length of the circle is n + 1\n    # so we loop once to iterate over the list\n    # to generate all possible moves\n    for move in itertools.permutations(range(1, n + 1), n):\n        # create a new array to represent the move\n        move_array = []\n        for i in range(1, n + 1):\n            move_array.append(i)\n\n        # fill the move_array with the \"right\" of the move\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                move_array[i], move_array[j] = move_array[j], move_array[i]\n\n        # check if the move_array is equal to the circle_array\n        if move_array == circle_array:\n            return \"\".join(map(str, move))\n"
    },
    {
        "number": 3220,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # input:\n    # num_wizards = int(input())\n    # wizards_list = list(map(int, input().split()))\n    wizards_list = list(map(int, stdin.split()))\n    #\n    # # logic:\n    # x = 1\n    # while x < num_wizards:\n    #     for i in range(0, num_wizards):\n    #         if x == wizards_list[i]:\n    #             wizards_list[i] = x\n    #         else:\n    #             pass\n    #     x += 1\n    #\n    # # output:\n    # return ''.join(map(str, wizards_list))\n    return ''.join(map(str, sorted(wizards_list)))\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a = map(int, stdin.split())\n    p = a * n * m\n    _, _, p = p % m, p % n, p % n\n    return str(p)\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, a = list(map(int, stdin.split()))\n    v_n = [int(i) for i in stdin.split()]\n    v_r = []\n    g_res = []\n    for i in range(M):\n        v_r.append([int(i) for i in stdin.split()])\n    for i in range(N):\n        g_res.append([])\n        for j in range(N):\n            g_res[i].append(float('inf'))\n    for i in range(N):\n        for j in range(N):\n            for k in range(M):\n                if v_r[k][0] == i and v_r[k][1] == j:\n                    g_res[i][j] = min(g_res[i][j], v_r[k][2])\n    pf = 0\n    min_energy = float('inf')\n    for i in range(N):\n        if min(g_res[i]) == float('inf'):\n            min_energy = float('inf')\n            continue\n        min_energy = min(min_energy, sum([pow(a, 2)] + list(map(lambda x: x[0]*x[1], zip(v_n, g_res[i])))) + pow(a, 2))\n    if min_energy == float('inf'):\n        return 'Poor girl'\n    return str(min_energy)\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    N = int(stdin.pop(0))\n    M = int(stdin.pop(0))\n    alpha = int(stdin.pop(0))\n    G = int(stdin.pop(0))\n    houses = {}\n    for i in range(M):\n        u = int(stdin.pop(0))\n        v = int(stdin.pop(0))\n        c = int(stdin.pop(0))\n        houses[(u, v)] = c\n    roads = [(u, v) for u in range(1, N + 1) for v in range(1, N + 1) if u!= v]\n    ans = 0\n    for u, v in roads:\n        cnt = houses.get((u, v), 0)\n        if cnt > 0:\n            ans += cnt**2 + alpha * cnt\n    return str(ans)"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = list(map(int, stdin.split()))\n    f_in = stdin.split()\n    f_in = list(map(int, f_in))\n    res = 0\n    visited = set()\n    # Set for visited\n    for i in range(len(f_in)):\n        visited.add(f_in[i])\n    for i in range(1, len(f_in)):\n        for j in range(i+1, len(f_in)):\n            if (f_in[i], f_in[j]) in visited:\n                continue\n            visited.add((f_in[i], f_in[j]))\n            temp = abs(f_in[i] - f_in[j])\n            res += temp * temp + alpha * 2 * min(f_in[i], f_in[j])\n    return res\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = list(map(int, stdin.split()))\n    min_energy = 2 * alpha * N\n    for _ in range(M):\n        u, v, c = list(map(int, stdin.split()))\n        if u < N and v < N and min_energy > (c ** 2) + alpha * (u + v):\n            min_energy = (c ** 2) + alpha * (u + v)\n    if min_energy == (2 * alpha * N):\n        return 'Poor girl'\n    return str(min_energy)\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    N, M, alpha = int(input_lines[0]), int(input_lines[1]), int(input_lines[2])\n    graph = {}\n    for i in range(M):\n        u, v, c = map(int, input_lines[i + 3].split())\n        if u not in graph:\n            graph[u] = {}\n        if v not in graph:\n            graph[v] = {}\n        graph[u][v] = graph[v][u] = c\n    visited = set()\n    for i in range(N):\n        if i in visited:\n            continue\n        visited.add(i)\n        queue = deque([[i, 0]])\n        while queue:\n            v, d = queue.popleft()\n            if v in visited:\n                continue\n            visited.add(v)\n            if v == 1:\n                print(d)\n                return\n            for j in graph:\n                if j in visited:\n                    continue\n                visited.add(j)\n                queue.append([j, d + graph[v][j]])\n\n    return \"Poor girl\"\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = list(map(int, stdin.split()))\n    alpha = alpha**2\n    edges = []\n    for _ in range(M):\n        u, v, c = list(map(int, stdin.split()))\n        edges.append((u, v, c))\n    edges.sort(key=lambda x: x[2])\n    def dfs(u, visited, p):\n        if u in visited: return\n        visited.add(u)\n        for v, c in edges:\n            if v == u:\n                c += p\n            if c <= alpha:\n                dfs(v, visited, c)\n    ans = N\n    for u, v, c in edges:\n        if u == v:\n            ans += c\n            continue\n        visited = set()\n        dfs(u, visited, c)\n        visited = set()\n        dfs(v, visited, c)\n        ans += max(v - u for u, v in visited)\n    return ans\n\nprint(solution(input()))\n"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    (N, M, alpha) = (int(lines[0]), int(lines[1]), int(lines[2]))\n    graph = {}\n    edges = []\n    for i in range(M):\n        u, v, c = map(int, lines[i + 3].split())\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        edges.append((u, v, c))\n        edges.append((v, u, c))\n    df = BellmanFord(graph, N, alpha)\n    min_df = min(df)\n    return str(min_df) + \" \" + str(df.index(min_df))\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # return\n    stdin_lines = stdin.split()\n    n, m, a = map(int, stdin_lines[0].split(' '))\n    rel_edges = list()\n    for i in range(1, m + 1):\n        u, v, c = map(int, stdin_lines[i].split(' '))\n        rel_edges.append((u, v, c))\n    g = Solution()\n    res = g.solve(n, m, a, rel_edges)\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, alpha = list(map(int, stdin.split()))\n    if m > n * n:\n        return \"Poor girl!\"\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        u, v, c = list(map(int, stdin.split()))\n        dp[u][v] = c\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dp[i][j] += dp[i][k] + alpha * dp[k][j]\n    return str(dp[1][n])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    d = {}\n    for _ in range(N):\n        d[str(_)] = set()\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        d[str(a)].add(b)\n        d[str(b)].add(a)\n    def dfs(s, visited, cur_path):\n        if s in visited:\n            return False\n        if s == '0':\n            return True\n        if len(cur_path) == N:\n            return True\n        for n in d[s]:\n            visited.add(n)\n            if dfs(str(n), visited, cur_path+[str(n)]):\n                return True\n            visited.remove(n)\n        return False\n    res = 0\n    for s in d:\n        if dfs(s, set(), []):\n            res += 1\n    return str(res)\n\nsolution(\"4 4\") # 2\nsolution(\"4 4\") # \"Yeah!\"\nsolution(\"10 8\") # \"Yeah!\nsolution(\"2 2\") # \"Yeah!\"\nsolution(\"3 2\") # \"Yeah!\"\nsolution(\"4 4\") # \"Yeah!\"\nsolution(\"4 4\") # \"Yeah!\"\nsolution(\"8 6\") # \"Yeah!\"\nsolution(\"1 1\") # \"Yeah!\"\nsolution(\"3 1\") # \"Yeah!\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def visit(graph, path):\n        nonlocal N\n        visited = [False for _ in range(N)]\n        for i in range(len(path)):\n            visited[path[i]] = True\n        for i in range(N):\n            if visited[i] == False:\n                if len(path) == 0:\n                    if i == 0:\n                        return False\n                else:\n                    return False\n        return True\n\n    def find(graph, node):\n        nonlocal N\n        for i in range(len(graph)):\n            if graph[node] == graph[i]:\n                return True\n        return False\n\n    def dfs(graph, path):\n        nonlocal N\n        if len(path) == N:\n            if visit(graph, path):\n                return True\n        for i in range(len(graph)):\n            if find(graph, i):\n                if dfs(graph, path + [i]):\n                    return True\n        return False\n\n    ans = 0\n    for i in range(N):\n        if dfs(graph, [i]):\n            ans += 1\n\n    if ans == 0:\n        return \"Yeah!\"\n    else:\n        return str(ans)\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    places = set(range(N))\n    connections = []\n    for i in range(M):\n        u, v = map(int, stdin.split())\n        connections.append((u, v))\n\n    connections = sorted(connections)\n    res = 0\n    while len(places)!= 1:\n        curr_connections = []\n        for u, v in connections:\n            if u in places and v not in places:\n                curr_connections.append((u, v))\n                places.add(v)\n            if v in places and u not in places:\n                curr_connections.append((u, v))\n                places.add(u)\n        connections = curr_connections\n        res += 1\n\n    return str(res)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = list(map(lambda x: x.split(), stdin.splitlines()))\n    return 'Yeah!' if impossible(data) else str(len(one_way(data))) + \"\\n\" + \"\\n\".join(str(x) for x in one_way(data))\n\ndef"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return input()"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    s = [i for i in range(N)]\n    graph = [[] for _ in range(N)]\n    for i in range(M):\n        s1, s2 = map(int, stdin.split())\n        s1 -= 1\n        s2 -= 1\n        graph[s1].append(s2)\n        graph[s2].append(s1)\n    visited = set()\n    from queue import Queue\n    q = Queue()\n    q.put(0)\n    while q.empty()!= True:\n        i = q.get()\n        visited.add(i)\n        for j in graph[i]:\n            if j not in visited:\n                q.put(j)\n    c = 0\n    for i in range(len(visited)):\n        if i == N-1:\n            c += 1\n            if c == 2:\n                return \"Yeah!\"\n    if len(visited) == N:\n        return \"No\"\n    if len(visited) < N:\n        return \"No\"\n\n\n    visited = set()\n    from queue import Queue\n    q = Queue()\n    q.put(0)\n    while q.empty()!= True:\n        i = q.get()\n        visited.add(i)\n        for j in graph[i]:\n            if j not in visited:\n                q.put(j)\n    c = 0\n    for i in range(len(visited)):\n        if i == N-1:\n            c += 1\n            if c == 1:\n                return \"No\"\n    if len(visited) == N:\n        return \"No\"\n    if len(visited) < N:\n        return \"No\"\n\n\n    visited = set()\n    from queue import Queue\n    q = Queue()\n    q.put(0)\n    while q.empty()!= True:\n        i = q.get()\n        visited.add(i)\n        for j in graph[i]:\n            if j not in visited:\n                q.put(j)\n    c = 0\n    for i in range(len(visited)):\n        if i == N-1:\n            c += 1\n            if c == 1:\n                return \"No\"\n    if len(visited) == N:\n        return \"No\"\n    if len(visited) < N:\n        return \"No\"\n\n    visited = set()\n    from queue import Queue\n    q = Queue()\n    q.put(0)\n    while q.empty()!= True:\n        i = q.get()\n        visited.add(i)\n        for j in graph[i]:\n            if j not in visited:\n                q.put(j)\n    c = 0\n    for i in range(len(visited)):\n        if i == N-1:\n            c += 1\n            if c == 1:\n                return \"No\"\n    if len(visited) == N:\n        return \"No\"\n    if len(visited) < N:\n        return \"No\"\n\n\n\nsolution(input())"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().strip().split())\n        u -= 1\n        v -= 1\n        edges[u].append(v)\n        edges[v].append(u)\n    edges = [[e for e in s] for s in edges]\n    res = []\n    def dfs(cur, cnt, _res):\n        if cnt > n:\n            return\n        if cnt == n:\n            res.append(_res)\n            return\n        for _ in range(len(edges[cur])):\n            next = edges[cur][_]\n            dfs(next, cnt+1, _res+[next])\n    dfs(0, 1, [0])\n    if res:\n        return \"\\n\".join([str(r) for r in res])\n    else:\n        return \"Yeah!\""
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: Write your code here\n    return \"\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    totest = {}\n    for i in range(0, int(stdin.split()[0])):\n        totest[i] = set()\n    for i in range(0, int(stdin.split()[1])):\n        totest[int(stdin.split()[2*i])].add(int(stdin.split()[2*i+1]))\n    visited = set()\n    for i in range(0, int(stdin.split()[0])):\n        if i not in visited:\n            visited.add(i)\n            totest[i].add(i)\n            break\n    return 'Yeah' if len(visited)!= len(totest) else \"\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n,m = map(int,stdin.split(\" \"))\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int,stdin.split(\" \"))))\n    #return [solution2(arr,i,j) for i in range(n) for j in range(n) if not solution2(arr,i,j)]\n    return \"Yeah!\" if solution2(arr,0,0) else \"Sorry!\"\n\ndef"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    (n, *degrees) = list(map(int, stdin.strip().split()))\n    if n == 1:\n        return 'IMPOSSIBLE'\n    return 'POSSIBLE'\n    return stdin"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    forest = []\n    for v in range(int(stdin.split()[0])):\n        forest.append([int(i) for i in stdin.split()[v + 1].split()])\n    if len(forest) < 1:\n        return \"IMPOSSIBLE\"\n    if len(forest[0]) < 1:\n        return \"IMPOSSIBLE\"\n    for i in range(1, len(forest)):\n        if forest[i] == []:\n            return \"IMPOSSIBLE\"\n    if forest[0][0] == 0:\n        return \"IMPOSSIBLE\"\n    if forest[0][0] < 0:\n        return \"IMPOSSIBLE\"\n    if forest[0][0] > 0:\n        return \"POSSIBLE\"\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.strip().split())\n    degrees = sorted(map(int, stdin.strip().split()))\n    max_degree = max(degrees)\n    assert max_degree == n\n    for i in range(len(degrees)):\n        assert degrees[i] == max_degree + i\n    \n    assert all(d > 0 for d in degrees)\n    assert len(degrees) == n\n    \n    root = find(0)\n    return str(root)\n\ndef"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    V, E = list(map(int, stdin.split()))\n    # ans = 'IMPOSSIBLE' if can_construct_graph(V, E) else 'POSSIBLE'\n    # return f'{ans}\\n{E}\\n{E}'\n    return 'IMPOSSIBLE' if can_construct_graph(V, E) else 'POSSIBLE'\n"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    V, d = map(int, stdin.split())\n    graph = [[] for _ in range(V)]\n    for i in range(V):\n        v, e = map(int, stdin.split())\n        graph[i].append(v)\n        if len(graph[i]) < d:\n            return 'IMPOSSIBLE'\n    nodes = {x for x in range(V)}\n    for i in range(V):\n        if d == len(graph[i]):\n            nodes.remove(i)\n    if len(nodes) == 0:\n        return 'IMPOSSIBLE'\n    elif len(nodes) == 1:\n        return 'POSSIBLE'\n    else:\n        for i in range(V):\n            if i not in nodes:\n                return 'IMPOSSIBLE'\n    for i in range(V):\n        if len(graph[i]) == d:\n            graph[i] = sorted(graph[i])\n            for j in range(V):\n                if i!= j and graph[i][-1] == graph[j][0]:\n                    return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.strip().split()\n    V = int(data[0])\n    degrees = list(map(int, data[1]))\n\n    if any(degree!= V for degree in degrees):\n        return \"IMPOSSIBLE\"\n\n    edges = []\n    for index, degree in enumerate(degrees):\n        edges.append((index, index + degree - 1))\n\n    edges.sort(key=lambda x: x[1])\n    nodes = range(0, V)\n\n    for u, v in edges:\n        nodes[u] = v\n\n    if nx.is_connected(nx.Graph(nodes)):\n        return \"POSSIBLE\"\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    degrees: List[int] = list(map(int, stdin.split()))\n\n    # 1 vertex\n    if n == 1:\n        return 'IMPOSSIBLE'\n\n    # no edges\n    if n == 2 and degrees[1] == 1:\n        return 'IMPOSSIBLE'\n\n    # no cycles\n    edges: Set[Tuple[int, int]] = set()\n    for degree in degrees:\n        if degree > 1:\n            edges.add((degree - 1, degree))\n\n    # no cycles and 2 edges\n    if n == 2 and len(edges) == 2:\n        return 'POSSIBLE'\n\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    degree = list(map(int, stdin.strip().split()))\n    if (n < 3):\n        return \"IMPOSSIBLE\"\n    if (max(degree) > n - 1):\n        return \"IMPOSSIBLE\"\n    for i in range(len(degree)):\n        if degree[i] > n - 1:\n            return \"IMPOSSIBLE\"\n    res = \"POSSIBLE\"\n    for i in range(1, n):\n        for j in range(i):\n            if degree[i] > degree[j] + 1 or degree[j] > degree[i] + 1:\n                return \"IMPOSSIBLE\"\n            if degree[i] == degree[j] + 1:\n                res +='' + str(i) +'' + str(j)\n    return res"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    degrees = list(map(int, stdin.strip().split()))\n    if len(degrees) < n:\n        return \"IMPOSSIBLE\"\n    forest = []\n    for degree in degrees:\n        forest.append([])\n        for _ in range(degree):\n            forest[-1].append(len(forest))\n    for i in range(len(forest)):\n        for j in range(i):\n            if forest[i][j] == forest[j][i]:\n                return \"IMPOSSIBLE\"\n    return \"POSSIBLE\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"IMPOSSIBLE\" if not is_tree_valid(stdin) else \"POSSIBLE\"\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \" \".join(map(str, sphere(stdin)))\n\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = []\n    y = []\n    z = []\n    for i in range(4):\n        x.append(stdin[i].split())\n        y.append(stdin[i+4].split())\n        z.append(stdin[i+8].split())\n    x.sort()\n    y.sort()\n    z.sort()\n    x = list(map(float, x))\n    y = list(map(float, y))\n    z = list(map(float, z))\n    x.sort()\n    y.sort()\n    z.sort()\n    x = int(x[0])\n    y = int(y[0])\n    z = int(z[0])\n    x_c = int((x+x[1]+x[2]+x[3])/4)\n    y_c = int((y+y[1]+y[2]+y[3])/4)\n    z_c = int((z+z[1]+z[2]+z[3])/4)\n    print('{:.4f} {:.4f} {:.4f}'.format(x_c, y_c, z_c))\n    return '{:.4f} {:.4f} {:.4f}'.format(x_c, y_c, z_c)\n"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, z1 = list(map(float, stdin.strip().split()))\n    x2, y2, z2 = list(map(float, stdin.strip().split()))\n    x3, y3, z3 = list(map(float, stdin.strip().split()))\n    x4, y4, z4 = list(map(float, stdin.strip().split()))\n    return \"%.5f %.5f %.5f\" % (\n        (x4 * x1 + y4 * y1 + z4 * z1) / (x4 ** 2 + y4 ** 2 + z4 ** 2) ** 0.5,\n        (x4 * x2 + y4 * y2 + z4 * z2) / (x4 ** 2 + y4 ** 2 + z4 ** 2) ** 0.5,\n        (x4 * x3 + y4 * y3 + z4 * z3) / (x4 ** 2 + y4 ** 2 + z4 ** 2) ** 0.5,\n    )\n"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.splitlines():\n        x, y, z = [int(n) for n in line.split()]\n        points.append((x, y, z))\n    points.sort(key=lambda p: p[0])\n    points.sort(key=lambda p: p[1])\n    points.sort(key=lambda p: p[2])\n\n    def distance(p0, p1):\n        return (p0[0] - p1[0])**2 + (p0[1] - p1[1])**2 + (p0[2] - p1[2])**2\n\n    c = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4, (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4, (points[0][2] + points[1][2] + points[2][2] + points[3][2]) / 4\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            d1 = distance(c, points[i])\n            d2 = distance(c, points[j])\n            if d1 == d2 and d1 < 10 ** -4:\n                return \"%.3f %.3f %.3f\" % (c[0], c[1], c[2])\n    return \"%.3f %.3f %.3f\" % c\n"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(0,4):\n        points.append([int(x) for x in stdin[i*3:i*3+3].split()])\n    points.sort(key=lambda p:p[0])\n    sphere = []\n    points = sorted(points, key=lambda p:p[1])\n    sphere.append(points[0])\n    points = sorted(points, key=lambda p:p[2])\n    sphere.append(points[0])\n    points = sorted(points, key=lambda p:p[0])\n    sphere.append(points[0])\n    sphere.append(points[1])\n    x_c = (sphere[0][0] + sphere[1][0] + sphere[2][0] + sphere[3][0]) / 4\n    y_c = (sphere[0][1] + sphere[1][1] + sphere[2][1] + sphere[3][1]) / 4\n    z_c = (sphere[0][2] + sphere[1][2] + sphere[2][2] + sphere[3][2]) / 4\n    return str(x_c) + \" \" + str(y_c) + \" \" + str(z_c)"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inp = list(map(int, stdin.split()))\n    x1, y1, z1 = inp[:3]\n    x2, y2, z2 = inp[3:6]\n    x3, y3, z3 = inp[6:]\n    if (\n        ((x1 * (y2 - y3) + y1 * (z2 - z3))!= 0) and\n        ((x2 * (y3 - y1) + y2 * (z1 - z3))!= 0) and\n        ((x3 * (y1 - y2) + y3 * (z2 - z1))!= 0) and\n        ((x1 * (y3 - y2) + y1 * (z3 - z2))!= 0)\n    ):\n        return '{:.4f} {:.4f} {:.4f}'.format(((x1 * (y2 - y3) + y1 * (z2 - z3)) / ((x1 * (y2 - y3) + y1 * (z2 - z3)) + (x1 * (y2 - y3) + y1 * (z2 - z3)) + (x2 * (y3 - y1) + y2 * (z1 - z3)) + (x3 * (y1 - y2) + y3 * (z2 - z1)))) * ((x2 * (y3 - y1) + y2 * (z1 - z3)) / ((x1 * (y2 - y3) + y1 * (z2 - z3)) + (x1 * (y2 - y3) + y1 * (z2 - z3)) + (x2 * (y3 - y1) + y2 * (z1 - z3)) + (x3 * (y1 - y2) + y3 * (z2 - z1))))\n    else:\n        return '{:.4f} {:.4f} {:.4f}'.format(0.0, 0.0, 0.0)\n"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, z1 = map(float, stdin.split())\n    x2, y2, z2 = map(float, stdin.split())\n    x3, y3, z3 = map(float, stdin.split())\n    x4, y4, z4 = map(float, stdin.split())\n    x = (x1*x2*x3*x4 + x1*x2*x4*y3 + x1*x4*y2*z3 + x1*x4*y3*y2 + x1*x4*z2*y3 + x1*x3*y2*z4 - x1*x3*x4*y3 - x1*x2*z4*y3 - x1*y2*z4*z3 - x1*z2*y4*z3 - x1*y3*z4*z2 - x2*z1*y3*z2 + x2*z1*y2*z3 - x2*z1*y3*y4 - x2*z1*y4*z3 + x2*z3*y4*z4 - x2*z2*y3*z4 - x2*z3*y3*y4 - x2*z4*y2*y3 + x2*y3*z2*z4 - x2*y2*z3*z4 + x3*y2*z4*z2 - x3*y2*z2*z3 - x3*y3*z2*z4 - x3*z2*y3*y4 - x3*z4*y2*z2 - x3*z2*y2*z3 - x3*z4*y3*y2 - x4*y1*z2*z3 - x4*y1*z2*y3 - x4*y1*z4*z3 - x4*y2*z1*z3 - x4*y2*z1*y3 - x4*y3*z1*z2 + x4*y3*z2*z3 - x4*y3*z3*z2 + y1*z1*x3*z2 + y1*z1*x2*z3 + y1*z1*x4*z3 - y1*z2*x3*z3 - y1*z2*x3*y3 + y1*z3*x2*y3 - y1*z3*x2*z2 - y1*z3*x4*z2 + y2*z1*y3*z3 + y2*z2*y3*z2 - y2*z3*y3*z2 - y2*y3*z3*z2 - y2*y3*z2*z3 + y2*y3*z3*z3 - y3*z2*y2*z3 - y3*z3*y2*z2 + y3*z3*z3*z2 - y4*z1*y3*z2 - y4*z2*y3*z3 + y4*z2*y3*y3 - y4*z3*y3*y2 + y4*y3*z3*z2 - y4*y3*z3*z3 + z1*y3*x2*z3 + z1*y2*x2*z3 + z1*y3*x4*z3 - z1*y3*x3*z2 - z1*y3*x3*y3 - z1*y2*x4*z3 + z1*y2*x4*y3 - z1*y3*x4*y3 - z2*y3*x3*y3 - z2*y3*x3*z2 + z2*y2*x3*z2 + z2*y2*x2*z3 + z2*y2*x3*y3 + z2*y3*x2*y3 + z2*y3*x4*y3 - z2*y3*x4*z3 - z2*y3*z2*y3 + z2*y2*z3*y3 - z2*y2*z2*z3 + z2*y4*y3*z2 - z2*y4*y3*z3 - z2*y2*z4*y3 + z2*y2*z4*z3 - z2*y2*z4*z2 - z2*y4*z3*y3 + z2*y4*z3*z3 - z3*y2*z4*z2 + z3*y2*z2*z3 - z3*y3*z2*z2 - z3*y3*z2*z3 + z3*y2*z2*z3 + z3*y3*z2*z3 - z3*z2*y2*z3 - z3*z2*y2*y3 + z3*z2*z2*y3 - z3*z3*y2*y3 - z3*y3*z2*z2 - z3*y3*z2*z3 + z4*y2*z4*z2 - z4*y2*z2*z3 + z4*y2*z4*y3 - z4*y3*z2*z3 + z4*y3*z2*z2 - z4*y3*z2*z3 + z4*z2*y3*y3 - z4*z2*y3*z2 - z4*z3*y2*z2 + z4*z3*y2*y3 - z4*z3*y2*z3 + z4*z3*y3*z2 - z4*z3*z2*y3 + y4*z1*y3*z3 - y4*z1*y3*z2 - y4*z1*y2*z3 - y4*z1*y2*y3 - y4*z1*z2*y3 + y4*z2*y3*z3 - y4*z2*y3*z2 + y4*z2*y3*y3 - y4*z3*y3*y2 - y4*z3*y3*z2 + y4*y3*z2*z3 - y4*y3*z2*y3 - y4*y3*z3*z2 - y4*z3*y2*z2 - y4*z3*y2*y3 + y3*z2*y3*z3 + y3*z3*y2*y3 - z1*y2*z3*z3 - z1*y2*z3*y3 + z1*y3*z3*z2"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    x = lines[1].split(\" \")\n    y = lines[2].split(\" \")\n    z = lines[3].split(\" \")\n\n    x = [int(i) for i in x]\n    y = [int(i) for i in y]\n    z = [int(i) for i in z]\n    \n    for i in range(n):\n        if x[i]**2 + y[i]**2 + z[i]**2 < 10**-4:\n            return \"0.0 0.0 -0.0\"\n    \n    r = sqrt(x[i]**2 + y[i]**2 + z[i]**2)\n    x_c = round((x[i] / r),4)\n    y_c = round((y[i] / r),4)\n    z_c = round((z[i] / r),4)\n    return str(x_c) + \" \" + str(y_c) + \" \" + str(z_c)\n"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        points.append([int(p) for p in stdin.split()[i*3:i*3+3]])\n    result = math.inf\n    for i in range(3):\n        for j in range(i+1, 3):\n            for k in range(j+1, 3):\n                a = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2 + abs(points[i][2] - points[j][2]) ** 2\n                b = abs(points[i][0] - points[k][0]) ** 2 + abs(points[i][1] - points[k][1]) ** 2 + abs(points[i][2] - points[k][2]) ** 2\n                c = abs(points[j][0] - points[k][0]) ** 2 + abs(points[j][1] - points[k][1]) ** 2 + abs(points[j][2] - points[k][2]) ** 2\n                if a+b+c <= math.sqrt(math.sqrt(a)+math.sqrt(b)+math.sqrt(c)):\n                    result = min(result, math.sqrt(a+b+c))\n    if result == math.inf:\n        return 'No sphere'\n    else:\n        return str(points[0][0] + points[1][0] + points[2][0] + points[3][0]) +'' + str(points[0][1] + points[1][1] + points[2][1] + points[3][1]) +'' + str(points[0][2] + points[1][2] + points[2][2] + points[3][2])"
    },
    {
        "number": 3224,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = []\n    y = []\n    z = []\n    for i in range(4):\n        x.append(stdin[i * 3])\n        y.append(stdin[i * 3 + 1])\n        z.append(stdin[i * 3 + 2])\n    return str(round(sum(x) / 4, 6)) + \" \" + str(round(sum(y) / 4, 6)) + \" \" + str(round(sum(z) / 4, 6))\n    \"\"\"\n    x = map(float, stdin.split())\n    m = (x[0] * x[3] - x[1] * x[2]) / (x[0] * x[0] + x[1] * x[1] + x[2] * x[2] - x[3] * x[3])\n    c = (-x[0] * m + x[0]) / (x[0] * x[0] + x[1] * x[1] + x[2] * x[2])\n    return '%.6f %.6f %.6f' % (m, c, round(c * c - m * m + 1, 6))\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    queue = []\n    for i in range(N):\n        v = int(stdin.split()[i])\n        queue.append((i, v))\n    minutes = 0\n    while queue:\n        for i in range(len(queue) - 1):\n            if queue[i][1] > queue[i + 1][1]:\n                queue.pop(i)\n                break\n        else:\n            if queue[-1][1] > queue[0][1]:\n                queue.pop()\n            else:\n                break\n        minutes += 1\n    queue = [(i, v) for i, v in enumerate(reversed(sorted(queue)), 1)]\n    return f\"{minutes}\\n\" + '\\n'.join(map(str, queue))"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    candidates = [int(stdin.split()[i]) for i in range(1, N + 1)]\n    resume = [0] * N\n    candidate_tally = 1\n    round_tally = 0\n    is_candidate_winner = True\n    while candidate_tally < N:\n        for i in range(round_tally + 1):\n            resume[candidate_tally] += candidates[i]\n        candidate_tally += 1\n        round_tally += 1\n        if is_candidate_winner:\n            is_candidate_winner = False\n            for i in range(round_tally + 1):\n                if resume[i] >= resume[candidate_tally]:\n                    is_candidate_winner = True\n                    break\n        else:\n            for i in range(round_tally + 1):\n                if resume[i] < resume[candidate_tally]:\n                    is_candidate_winner = True\n                    break\n    for i in range(round_tally + 1):\n        if resume[i] == resume[candidate_tally]:\n            print(resume[i])\n    return\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines.pop(0))\n    nums = list(map(int, lines.pop(0).split()))\n    time = 0\n    for i in range(N):\n        count = 0\n        num = nums[i]\n        for j in range(N):\n            if num > nums[j]:\n                count += 1\n        for j in range(N):\n            if nums[j] > num and count >= nums[j]:\n                nums[j] = num\n        time += 1\n    return str(time) + \"\\n\" + '\\n'.join(map(str, nums))\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    v = list(map(int, stdin.split()))\n    m = 0\n    q = deque()\n    for v_i in v:\n        while q and v_i > q[-1][1]:\n            q.pop()\n            if q:\n                m += 1\n        q.append((v_i, m))\n    return str(m) + '\\n' + '\\n'.join(map(str, q))\n    \n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    resume: List[int] = stdin.split(' ')\n    m: int = int(resume.pop())\n    for _ in range(m):\n        curr: List[int] = resume.pop()\n        curr = [int(x) for x in curr.split(' ')]\n        curr = [x for x in curr if x > 0]\n        curr.sort(reverse=True)\n        resume.extend(curr)\n    return''.join([str(x) for x in resume])\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    vals = list(map(int, stdin.split()))\n    cur_min = 0\n    ans = \"\"\n    for val in vals:\n        cur_min += 1\n        for i, v in enumerate(vals):\n            if val > v:\n                vals[i] = -1\n                ans += str(cur_min) + \" \"\n                break\n    return str(cur_min) + \"\\n\" + \" \".join(map(str, vals)) + \"\\n\" + ans[:-1]\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = list(map(int, stdin.split()[1]))\n    print(N)\n    print(' '.join(map(str, S)))\n\n    M = 0\n    while len(S) > 1:\n        for i in range(0, len(S)-1):\n            if S[i+1] < S[i]:\n                S[i] = S[i+1]\n        print(' '.join(map(str, S)))\n        S = S[:-1]\n        M += 1\n\n    print(' '.join(map(str, S)))\n    return str(M)\n"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    values = [int(i) for i in stdin.split()]\n    resume = [i for i in values]\n    queue = []\n    candidates = []\n    candidates_to_remove = []\n    candidates.append(values[0])\n    candidates_to_remove.append(values[0])\n    for i in range(1, n):\n        if values[i] < candidates[-1]:\n            candidates_to_remove.append(candidates[-1])\n            candidates.append(values[i])\n            queue.append(candidates[-1])\n            candidates_to_remove.append(candidates[-1])\n        else:\n            candidates.append(values[i])\n            queue.append(candidates[-1])\n    print(len(candidates_to_remove))\n    for i in candidates_to_remove:\n        print(i)\n    for i in queue:\n        print(i)\n    return \"0\""
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = list(map(int, stdin.split()))\n    que = [(p[i], i) for i in range(n)]\n    m = 0\n    while len(que) > 1:\n        m += 1\n        que.sort(reverse=True)\n        que = deque(que)\n        t = que.popleft()\n        p = t[0]\n        i = t[1]\n        que.append(p)\n        que.append(p)\n        que.append(p)\n    return str(m) + \"\\n\" + \"\".join(map(str, que)) + \"\\n\" + str(que[0][0])"
    },
    {
        "number": 3225,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    candidates = list(map(int, stdin.splitlines()[1].split()))\n    time = 0\n    queue = []\n    while len(candidates) > 1:\n        time += 1\n        candidates = sorted(candidates, reverse=True)\n        queue.append(candidates[0])\n        for i in range(N-1):\n            if queue[i] > candidates[i+1]:\n                break\n            candidates.remove(queue[i])\n    print(time)\n    for j in range(len(queue)):\n        print(queue[j])\n    return\n\nsolution(input())\n"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = (int(i) for i in stdin.split())\n    roads = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, l = (int(i) for i in stdin.split())\n        roads[a].append((b, l))\n        roads[b].append((a, l))\n    starts = stdin.split()[e].split(\",\")\n    start = (int(i) for i in starts)\n    target = (int(i) for i in stdin.split()[e + 1].split(\",\"))\n    speed = min(\n        ((int(i) - int(j)) / max((int(i) - int(j)) / speed, 1)) for i, j in zip(start, target)\n    )\n    return f\"{speed:.6f}\"\n"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    [n, m, e] = map(int, stdin.split())\n    roads = [[] for i in range(n)]\n    exits = set()\n    for i in range(m):\n        a, b, l = map(int, stdin.split())\n        roads[a - 1].append((b - 1, l))\n        roads[b - 1].append((a - 1, l))\n    for i in range(e):\n        x = int(stdin.split()[i])\n        exits.add(x)\n    [x, y] = map(int, stdin.split())\n    x, y = x - 1, y - 1\n    return run_parallel(roads, exits, x, y)\n\ndef"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    N, M, E = map(int, lines[0].split())\n    intersections = set()\n    roads = []\n    for i in range(1, M+1):\n        a, b, l = map(int, lines[i].split())\n        roads.append((a, b, l))\n    for i in range(1, E+1):\n        intersections.add(int(lines[i]))\n    a, b = map(int, lines[-2].split())\n    roads.append((a, b, 1))\n    roads.append((a, b, 1000000))\n    roads.append((a, b, -1))\n    roads.sort(key=lambda x: x[2])\n    # print(roads)\n    # print(intersections)\n    def travel(src: int, dst: int, prev: int, length: int) -> int:\n        if src == dst:\n            return length\n        if prev!= -1:\n            if roads[prev][1] == src and roads[prev][2] < length:\n                return travel(roads[prev][1], dst, prev, length)\n            if roads[prev][1] == dst and roads[prev][2] > length:\n                return travel(src, roads[prev][1], prev, length)\n        best = float(\"inf\")\n        for i in range(len(roads)):\n            if roads[i][0] == src:\n                best = min(best, travel(roads[i][1], dst, i, roads[i][2]) + roads[i][2])\n                # print(best)\n            elif roads[i][0] == dst:\n                best = min(best, travel(src, roads[i][1], i, roads[i][2]) + roads[i][2])\n                # print(best)\n        return best\n    return str(travel(a, b, -1, 0))\n\nsolution(\"\"\"\n2 1 1\n1 2 7\n2 3 8\n1\n3 2\n\"\"\")"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = stdin.split()\n    n = int(n)\n    m = int(m)\n    e = int(e)\n    roads = []\n    for i in range(m):\n        a, b, l = stdin.split()\n        a = int(a)\n        b = int(b)\n        l = int(l)\n        roads.append((a, b, l))\n    intersections = []\n    for i in range(e):\n        a, b = stdin.split()\n        a = int(a)\n        b = int(b)\n        intersections.append((a, b))\n    intersections = set(intersections)\n    roads = set(roads)\n    intersections = set(intersections)\n    intersections.add(1)\n    intersections.add(n)\n    roads_set = set()\n    for road in roads:\n        roads_set.add(road)\n    roads_set.add((1, n))\n    roads_set.add((n, 1))\n    roads = roads_set\n    road_intersections = {}\n    for road in roads:\n        road_intersections[road] = []\n    for road in roads:\n        road_intersections[road] = []\n        for intersection in intersections:\n            if road[0] == intersection:\n                road_intersections[road].append(intersection)\n            elif road[1] == intersection:\n                road_intersections[road].append(intersection)\n    safe_road = []\n    for road in roads:\n        if road in road_intersections:\n            safe_road.append(road)\n    safe_road = set(safe_road)\n    intersections = set(intersections)\n    possible_roads = set()\n    possible_roads_distance = {}\n    for road in safe_road:\n        possible_roads.add(road)\n        possible_roads_distance[road] = 0\n    for intersection in intersections:\n        for road in safe_road:\n            if intersection in road_intersections[road]:\n                if road in possible_roads_distance:\n                    possible_roads_distance[road] = min(possible_roads_distance[road], road_intersections[road].index(intersection))\n                else:\n                    possible_roads_distance[road] = road_intersections[road].index(intersection)\n    min_distance = 10000\n    for road in possible_roads_distance:\n        if possible_roads_distance[road] < min_distance:\n            min_distance = possible_roads_distance[road]\n    return str(min_distance)\n    \nprint(solution(stdin))\n"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # lines = stdin.split(\"\\n\")\n    #\n    # n, m, e = int(lines[0]), int(lines[1]), int(lines[2])\n    # roads = []\n    # for _ in range(m):\n    #     a, b, l = int(lines[3*_]), int(lines[3*_+1]), int(lines[3*_+2])\n    #     roads.append((a, b, l))\n    #\n    # intersections = {int(x): (i, i, 0) for i, x in enumerate(lines[-e:])}\n    #\n    # return solution_part1(roads, intersections, n)\n    #\n    # # Test\n    # lines = \"\"\"3 2 1\n    # 1 2 7\n    # 2 3 8\n    # 1\n    # 2 3\n    # \"\"\"\n    # print(solution(lines))\n\n    return solution_part2(stdin)\n\n\ndef"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    intersections = []\n    roads = []\n\n    for line in stdin.splitlines():\n        intersections.append(int(line.split(' ')[0]))\n        roads.append((int(line.split(' ')[1]), int(line.split(' ')[2])))\n\n    intersections.append(int(intersections[-1]))\n    roads.append((int(roads[-1][0]), int(roads[-1][1])))\n\n    max_speed = 160\n    min_speed = 2\n\n    min_speed_at_exit = min_speed\n\n    def neighbors(exit):\n        ret = []\n        if exit > 0:\n            ret.append(exit - 1)\n        if exit < len(roads) - 1:\n            ret.append(exit + 1)\n        if exit > 0 and exit < len(roads) - 1:\n            ret.append(exit - 1)\n            ret.append(exit + 1)\n        return ret\n\n    def distance_to_intersection(exit):\n        ret = []\n        if exit > 0:\n            ret.append(roads[exit - 1][0])\n        if exit < len(roads) - 1:\n            ret.append(roads[exit + 1][0])\n        return ret\n\n    def distance_to_road(exit):\n        ret = []\n        if exit > 0:\n            ret.append(roads[exit - 1][1])\n        if exit < len(roads) - 1:\n            ret.append(roads[exit + 1][1])\n        return ret\n\n    def travel_time(exit):\n        if exit > 0 and exit < len(roads) - 1:\n            return (roads[exit + 1][0] - roads[exit - 1][1]) / (roads[exit + 1][0] - roads[exit - 1][0])\n        if exit > 0:\n            return 1\n        return 1\n\n    #\n    # intersections = [(1, 2, 7), (2, 3, 8), (3, 4, 9), (4, 5, 10), (5, 6, 11), (6, 7, 12), (7, 8, 13), (8, 9, 14), (9, 10, 15), (10, 11, 16), (11, 12, 17), (12, 13, 18), (13, 14, 19), (14, 15, 20), (15, 16, 21), (16, 17, 22), (17, 18, 23), (18, 19, 24), (19, 20, 25), (20, 21, 26), (21, 22, 27), (22, 23, 28), (23, 24, 29), (24, 25, 30), (25, 26, 31), (26, 27, 32), (27, 28, 33), (28, 29, 34), (29, 30, 35), (30, 31, 36), (31, 32, 37), (32, 33, 38), (33, 34, 39), (34, 35, 40), (35, 36, 41), (36, 37, 42), (37, 38, 43), (38, 39, 44), (39, 40, 45), (40, 41, 46), (41, 42, 47), (42, 43, 48), (43, 44, 49), (44, 45, 50), (45, 46, 51), (46, 47, 52), (47, 48, 53), (48, 49, 54), (49, 50, 55), (50, 51, 56), (51, 52, 57), (52, 53, 58), (53, 54, 59), (54, 55, 60), (55, 56, 61), (56, 57, 62), (57, 58, 63), (58, 59, 64), (59, 60, 65), (60, 61, 66), (61, 62, 67), (62, 63, 68), (63, 64, 69), (64, 65, 70), (65, 66, 71), (66, 67, 72), (67, 68, 73), (68, 69, 74), (69, 70, 75), (70, 71, 76), (71, 72, 77), (72, 73, 78), (73, 74, 79), (74, 75, 80), (75, 76, 81), (76, 77, 82), (77, 78, 83), (78, 79, 84), (79, 80, 85), (80, 81, 86), (81, 82, 87), (82, 83, 88), (83, 84, 89), (84, 85, 90), (85, 86, 91), (86, 87, 92), (87, 88, 93), (88, 89, 94), (89, 90, 95), (90, 91, 96), (91, 92, 97), (92, 93, 98), (93, 94, 99), (94, 95, 100), (95, 96, 101), (96, 97, 102), (97, 98, 103), (98, 99, 104), (99, 100, 105), (100, 101, 106), (101, 102, 107), (102, 103, 108), (103, 104, 109), (104, 105, 110), (105, 106, 111), (106, 107, 112), (107, 108, 113), (108, 109, 114), (109, 110, 115), (110, 111, 116), (111, 112, 117), (112, 113, 118),"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Prints the minimal top speed required to escape in km/h from intersections.\n    '''\n\n    intersections = {int(i): int(j) for i, j in map(lambda s: s.split(), stdin.splitlines()[1:])}\n    roads = {int(i): (int(j), int(k)) for i, j, k in map(lambda s: s.split(), stdin.splitlines()[2:])}\n    roads_in = [int(i) for i in stdin.splitlines()[3:]]\n\n    # Create set of directions for roads\n    road_directions = {road: [(intersections[road[1]], intersections[road[2]])] for road in roads}\n\n    # Add bridges and tunnels to road directions\n    road_directions = {road: (bridge, tunnel) for road, (bridge, tunnel) in road_directions.items() if bridge!= tunnel}\n    for bridge in roads_in:\n        road_directions[bridge] = (bridge, bridge)\n\n    # Create list of lists to hold all directions for intersections\n    intersections_by_direction = []\n    for direction, road in road_directions.items():\n        intersections_by_direction.append([intersections[direction[0]], intersections[direction[1]]])\n\n    # Find smallest intersection and the road it is connected to\n    intersection_to_road = {}\n    for intersection in intersections_by_direction:\n        min_distance = 10 ** 7\n        min_road = None\n        for road in intersection:\n            if road in intersection_to_road:\n                intersection_to_road[road] = min(intersection_to_road[road], intersection)\n            else:\n                intersection_to_road[road] = intersection\n            if min_distance > abs(intersection_to_road[road][0] - intersection[0]) + abs(intersection_to_road[road][1] - intersection[1]):\n                min_distance = abs(intersection_to_road[road][0] - intersection[0]) + abs(intersection_to_road[road][1] - intersection[1])\n                min_road = road\n        intersections_by_direction[intersection_to_road[road]] = intersection_to_road[min_road]\n\n    # Find the next intersection to start at\n    intersection_to_start = {}\n    for intersection in intersections_by_direction:\n        intersection_to_start[intersection] = intersection\n        if intersection_to_start[intersection]!= intersections[intersection]:\n            intersection_to_start[intersection] = intersections[intersection]\n            break\n\n    # Populate the final list of directions\n    final_directions = []\n    for intersection in intersections_by_direction:\n        if intersection == intersections[intersection_to_start[intersection]]:\n            final_directions.append(intersection)\n        elif intersection == intersections[intersection_to_start[intersection_to_start[intersection]]]:\n            final_directions.append(intersection)\n\n    # Create a list of tuples (intersection, road)\n    intersection_and_road = [(intersections[i], roads[i]) for i in final_directions]\n\n    # Find the intersection where the other car will be and the road it will take to get there\n    car_to_intersection = {}\n    for intersection, road in intersection_and_road:\n        car_to_intersection[intersection] = road\n        if road not in car_to_intersection:\n            car_to_intersection[road] = intersection\n    car_to_intersection = {k: v for k, v in car_to_intersection.items() if v in road_directions.keys()}\n    car_to_intersection = {k: v for k, v in car_to_intersection.items() if k in road_directions.keys()}\n\n    # Find the intersection where the car will be and the road it will take to get there\n    car_to_intersection = {k: v for k, v in car_to_intersection.items() if v in intersections.keys()}\n    car_to_intersection = {k: v for k, v in car_to_intersection.items() if k in intersections.keys()}\n\n    # Find the intersection and the road leading to it\n    intersection_to_car = {}\n    for car, intersection in car_to_intersection.items():\n        intersection_to_car[intersection] = car\n        if car not in car_to_intersection:\n            car_to_intersection[car] = intersection\n    intersection_to_car = {k: v for k, v in intersection_to_car.items() if v in car_to_intersection.keys()}\n    intersection_to_car = {k: v for k, v in intersection_to_car.items() if k in car_to_intersection.keys()}\n\n    # Sort the roads from intersections\n    sorted_intersection_to_car = sorted(intersection_to_car.items(), key=lambda x: (x[1], x[0]))\n\n    # Make the decisions\n    intersection_to_road_list ="
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = stdin.split('\\n')\n    n, m, e = int(n), int(m), int(e)\n    roads = [[int(i) for i in stdin.split('\\n')[i]] for i in range(m)]\n    start = [int(i) for i in stdin.split('\\n')[e+1].split()]\n    all_roads = [[] for i in range(n)]\n    for road in roads:\n        all_roads[road[0] - 1].append(road[1])\n        all_roads[road[1] - 1].append(road[0])\n    in_between = set()\n    for road in roads:\n        for road2 in roads:\n            if road == road2 or road in in_between:\n                continue\n            elif road[0] == road2[0] or road[0] == road2[1]:\n                if road2[1] in all_roads[road[1] - 1] and road2[0] in all_roads[road[0] - 1]:\n                    in_between.add(road)\n    def can_escape(roads, start, n, speed):\n        frontier = set()\n        frontier.add(start)\n        seen = set()\n        seen.add(start)\n        while len(frontier) > 0:\n            current = frontier.pop()\n            if current == n - 1:\n                return False\n            for next in roads[current]:\n                if next in seen or next not in frontier:\n                    continue\n                seen.add(next)\n                frontier.add(next)\n        return True\n    def new_speed(roads, start, speed):\n        taken = 0\n        next = start\n        current = start\n        while True:\n            next = roads[next][taken]\n            if next in roads[current]:\n                taken = speed\n                current = next\n                continue\n            else:\n                taken = 1\n                current = next\n                break\n        return next\n    ret = float('inf')\n    for speed in range(n):\n        start = new_speed(roads, start, speed)\n        if can_escape(roads, start, n, speed):\n            ret = min(ret, speed)\n    if ret == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return str(ret)\n"
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    intersections, roads, road_exits = stdin.split('\\n')\n    intersections = [int(i) for i in intersections.split()]\n    roads = [tuple(int(a) for a in r.split()) for r in roads.split()]\n    road_exits = [[int(e) for e in r.split()] for r in road_exits.split()]\n    print(intersections, roads, road_exits)\n    road_to_intersections = {road: intersections for road, intersections in zip(roads, intersections)}\n    print(road_to_intersections)\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    print(intersection_to_roads)\n    road_to_intersections = {road: intersections for road, intersections in zip(roads, intersections)}\n    print(road_to_intersections)\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    print(intersection_to_roads)\n    def dist(p, q):\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])\n    distances = {intersection: {exit: dist(road_to_intersections[road], road_to_intersections[exit]) for exit in road_to_intersections[road]} for intersection, road in intersection_to_roads.items()}\n    print(distances)\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    def dist(p, q):\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])\n    distances = {intersection: {exit: dist(road_to_intersections[road], road_to_intersections[exit]) for exit in road_to_intersections[road]} for intersection, road in intersection_to_roads.items()}\n    print(distances)\n    def min_dist(intersection, exits):\n        print(intersection, exits)\n        print(road_to_intersections[road])\n        print(road_to_intersections)\n        min_dist = float('inf')\n        for exit in exits:\n            print(exit)\n            if exit in intersection_to_roads[intersection]:\n                dist = distances[intersection][exit]\n                print(dist)\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n    intersections = {intersection: road_to_intersections[intersection] for intersection, road_to_intersections in intersection_to_roads.items()}\n    print(intersections)\n    def min_dist(intersection, exits):\n        print(intersection, exits)\n        print(road_to_intersections[road])\n        print(road_to_intersections)\n        min_dist = float('inf')\n        for exit in exits:\n            print(exit)\n            if exit in intersections:\n                dist = distances[intersection][exit]\n                print(dist)\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n    def min_dist(intersection, exits):\n        min_dist = float('inf')\n        for exit in exits:\n            print(exit)\n            if exit in intersections:\n                dist = distances[intersection][exit]\n                print(dist)\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    intersection_to_roads = {intersection: roads for intersection, roads in zip(intersections, roads)}\n    "
    },
    {
        "number": 3226,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split())\n    roads = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        a, b, l = map(int, stdin.split())\n        roads[a].append((b, l))\n        roads[b].append((a, l))\n    check = {i: set() for i in range(1, n + 1)}\n    for road in roads.values():\n        for a, l in road:\n            check[a].add(l)\n    check = {i: len(check[i]) for i in range(1, n + 1)}\n    print(check)\n    for i in range(1, n + 1):\n        if not check[i]:\n            return str(i)\n    return str(check[1])"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    for i in range(len(stdin)):\n        if int(stdin[i]) == 0:\n            return \"0\"\n    n = int(stdin[0])\n    m = int(stdin[1])\n    d = {}\n    for i in range(m):\n        a, b = map(int, stdin[i * 2 + 2].split())\n        if a in d.keys():\n            d[a].append(b)\n        else:\n            d[a] = [b]\n        if b in d.keys():\n            d[b].append(a)\n        else:\n            d[b] = [a]\n    if len(d) < n:\n        return \"0\"\n    for i in range(len(d.keys())):\n        d[i] = sorted(d[i])\n    for i in range(n):\n        x = d[i]\n        if len(x)!= 2:\n            return \"0\"\n        else:\n            if x[0] + 1 == x[1] or x[1] - 1 == x[0]:\n                continue\n            else:\n                return \"0\"\n    for i in range(n):\n        x = d[i]\n        y = d[n - i - 1]\n        if len(x)!= 2:\n            return \"0\"\n        else:\n            if x[0] + 1 == x[1] or x[1] - 1 == x[0]:\n                continue\n            else:\n                return \"0\"\n    for i in range(n):\n        for j in range(m):\n            if d[i][0] == d[i][1]:\n                continue\n            else:\n                if d[i][0] + 1 == d[i][1] or d[i][1] - 1 == d[i][0]:\n                    continue\n                else:\n                    return \"0\"\n    for i in range(m):\n        for j in range(n):\n            if d[0][i] == d[1][i]:\n                continue\n            else:\n                if d[0][i] + 1 == d[1][i] or d[1][i] - 1 == d[0][i]:\n                    continue\n                else:\n                    return \"0\"\n    for i in range(n):\n        for j in range(m):\n            if d[n - 1 - i][j] == d[n - 2 - i][j]:\n                continue\n            else:\n                if d[n - 1 - i][j] + 1 == d[n - 2 - i][j] or d[n - 2 - i][j] - 1 == d[n - 1 - i][j]:\n                    continue\n                else:\n                    return \"0\"\n    for i in range(m):\n        for j in range(n):\n            if d[i][n - 1 - j] == d[i][n - 2 - j]:\n                continue\n            else:\n                if d[i][n - 1 - j] + 1 == d[i][n - 2 - j] or d[i][n - 2 - j] - 1 == d[i][n - 1 - j]:\n                    continue\n                else:\n                    return \"0\"\n    return \"1\"\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split())\n\n    s = [[None] * (N+1) for _ in range(N+1)]\n    edges = {}\n    for _ in range(E):\n        u, v = map(int, stdin.split())\n        if not s[u][v]:\n            edges[(u, v)] = 1\n            s[u][v] = True\n            s[v][u] = True\n        else:\n            edges[(u, v)] += 1\n\n    print(\"\".join(\"1\" if ((u, v) in edges and edges[(u, v)] % 2) else \"0\" for u, v in itertools.combinations(range(1, N+1), 2)))\n    return\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for _ in range(e):\n        a, b = map(int, input().split())\n        roads[a - 1].append(b - 1)\n        roads[b - 1].append(a - 1)\n    roads = list(filter(lambda l: len(l) > 1, roads))\n    if not roads:\n        return \"0\"\n    s = [False for _ in range(len(roads))]\n    s[0] = True\n    p = 0\n    c = 0\n    while p < len(s):\n        for i, r in enumerate(roads):\n            if s[i]:\n                continue\n            for j in range(len(r)):\n                if not s[r[j]]:\n                    s[r[j]] = True\n                    if r[j]!= p:\n                        c += 1\n                    break\n        p += 1\n    if c == 0:\n        return \"0\"\n    return \"1\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split())\n    if N == 1 or E == 1:\n        return \"0\"\n\n    Roads = [[] for _ in range(N)]\n    for i in range(E):\n        a, b = map(int, stdin.split())\n        Roads[a - 1].append(b - 1)\n        Roads[b - 1].append(a - 1)\n\n    def connected(i, j):\n        if Roads[i][0] == j:\n            return True\n        if Roads[i][-1] == j:\n            return True\n        if i!= j:\n            return any(connected(i, k) and connected(k, j) for k in Roads[i])\n        return False\n\n    ans = -1\n    for i in range(N):\n        if len(Roads[i]) == 1:\n            ans = 1 if ans == -1 else 2\n            break\n        if len(Roads[i]) == 2 and any(connected(i, k) for k in Roads[i]):\n            ans = 1 if ans == -1 else 2\n            break\n    return str(ans)\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    res = [\"0\"] * e\n\n    for i in range(e):\n        for j in range(e):\n            if j == i: continue\n            res[i] = \"2\" if res[i] == \"1\" else \"1\"\n            if n == 1:\n                return \"\".join(res)\n            if (n - 1, e - 1) not in res:\n                res[j] = \"2\" if res[j] == \"1\" else \"1\"\n            if (n - 1, j) not in res:\n                res[i] = \"2\" if res[i] == \"1\" else \"1\"\n            if (j, n - 1) not in res:\n                res[i] = \"2\" if res[i] == \"1\" else \"1\"\n            if (j, e - 1) not in res:\n                res[i] = \"2\" if res[i] == \"1\" else \"1\"\n            if (n - 1, e - 1) not in res:\n                res[i] = \"2\" if res[i] == \"1\" else \"1\"\n    return \"\".join(res)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, e = stdin.split()\n    n, e = int(n), int(e)\n    roads = []\n    for _ in range(e):\n        a, b = stdin.split()\n        a, b = int(a), int(b)\n        roads.append((a, b))\n    ans = \"\"\n    for road in roads:\n        if roads.count(road) < 2:\n            if ans == \"\":\n                ans = \"0\"\n        elif roads.count(road) == 2:\n            if road[0] == road[1]:\n                ans = \"0\"\n    return ans\n\nprint(solution(input()))\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Builds an optimal assignment of roads that minimizes the number of cities that should have at least one restaurant built from each chain.\n\n    >>> solution('''\n   ... 7 7\n   ... 1 2\n   ... 2 3\n   ... 3 1\n   ... 4 5\n   ... 5 6\n   ... 6 7\n   ... 7 4\n   ... ''')\n    '1'\n    \"\"\"\n    # Parse the input\n    num_cities, num_roads = tuple(map(int, stdin.split()))\n    road_cities = {}\n    for _ in range(num_roads):\n        road, city = tuple(map(int, stdin.split()))\n        if road not in road_cities:\n            road_cities[road] = set()\n        road_cities[road].add(city)\n    num_chains = len(road_cities)\n    num_cities -= 1\n    optimal_assignment = ''\n    if num_chains < 2:\n        optimal_assignment = '0'\n    else:\n        cities_by_chain = {}\n        for chain_index in range(num_chains):\n            cities_by_chain[chain_index] = set()\n        for road in sorted(road_cities):\n            cities_by_chain[len(road_cities[road])].add(road)\n        optimal_assignment = '1'\n        for chain_index in range(num_chains):\n            if len(cities_by_chain[chain_index]) >= num_cities:\n                optimal_assignment = '2'\n            for city_set in cities_by_chain.values():\n                if len(city_set) < num_cities:\n                    continue\n                if city_set.issubset(cities_by_chain[chain_index]):\n                    optimal_assignment = '2'\n                    break\n    return optimal_assignment\n"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = [int(x) for x in stdin.split()]\n    edges = {}\n\n    for _ in range(e):\n        u, v = (int(x) for x in stdin.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n\n    roads = []\n    visited = set()\n\n    def dfs(vertex, chain):\n        nonlocal roads\n        nonlocal visited\n        roads.append(vertex)\n\n        if vertex in visited:\n            return\n        else:\n            visited.add(vertex)\n\n        for nei in edges[vertex]:\n            if nei not in visited:\n                dfs(nei, chain)\n\n    for i in range(1, n + 1):\n        if i not in visited:\n            dfs(i, -1)\n\n    res = []\n    for v in roads:\n        if v in edges:\n            res.append(1)\n            for u in edges[v]:\n                if u!= v and u not in visited:\n                    res.append(2)\n        else:\n            res.append(0)\n\n    return '\\n'.join(map(str, res))\n\nprint(solution(input()))"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for _ in range(e):\n        x, y = map(int, stdin.split())\n        roads[x - 1].append(y - 1)\n        roads[y - 1].append(x - 1)\n    result = []\n    dfs(roads, 0, set(), result)\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 3227,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = [int(x) for x in stdin.split(' ')]\n    if n == e == 1:\n        return '0'\n\n    graph = {}\n    for i in range(e):\n        a, b = [int(x) for x in stdin.split(' ')]\n        if a in graph:\n            graph[a].append(b)\n        else:\n            graph[a] = [b]\n        if b in graph:\n            graph[b].append(a)\n        else:\n            graph[b] = [a]\n    visited = set()\n    to_visit = [1]\n\n    def visit(node):\n        nonlocal to_visit\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor in visited:\n                continue\n            to_visit.append(neighbor)\n            visit(neighbor)\n        to_visit.pop()\n\n    while to_visit:\n        visit(to_visit[0])\n\n    if len(visited)!= n:\n        return '0'\n\n    roads = []\n    for i in range(e):\n        a, b = [int(x) for x in stdin.split(' ')]\n        if a in visited and b in visited:\n            if b in graph[a]:\n                roads.append('1')\n            else:\n                roads.append('2')\n        elif a in visited:\n            roads.append('1')\n        elif b in visited:\n            roads.append('2')\n        else:\n            roads.append('0')\n\n    return''.join(roads)\n"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, g, *xs = list(map(int, stdin.split()))\n    xs = sorted(xs)\n    nxt = [0] * n\n    i = 0\n    tot = 0\n    while i < n:\n        x = xs[i]\n        tot += x\n        nxt[i] = tot\n        i += 1\n    #print(nxt)\n    max_g = min(nxt)\n    tot = 0\n    while t >= 0:\n        for i in range(n):\n            t -= 1\n            if t >= 0 and nxt[i] <= max_g:\n                tot += xs[i]\n        max_g = min(max_g, nxt[i])\n        tot += t\n    return str(tot)\n"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # YOUR CODE HERE\n    return stdout.getvalue().strip()"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, t, g = map(int, lines[0].split())\n    skier_times = list(map(int, lines[1:]))\n    return str(min(sum(map(lambda time: t - time if t > time else 0, skier_times)) for t in range(t)))\n    # "
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    T = int(lines[1])\n    G = int(lines[2])\n    gondolas = list(map(int, lines[3:]))\n\n    waiting_times = []\n    for gondola in range(G):\n        waiting_times.append([])\n        waiting_times[gondola].append(gondolas[gondola] // T)\n        waiting_times[gondola].append(gondolas[gondola] % T)\n    waiting_times.sort(key=lambda x: x[1])\n\n    result = 0\n    for gondola in range(G):\n        result += waiting_times[gondola][0] + waiting_times[gondola][1]\n        waiting_times[gondola][0] = waiting_times[gondola][0] + waiting_times[gondola][1]\n        waiting_times[gondola][1] = waiting_times[gondola][1] - 1\n\n    return str(result)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, T, G = map(int, lines[0].split())\n    arrangements = []\n    for line in lines[1:]:\n        arrangements.append(list(map(int, line.split())))\n    return str(min_time(N, T, G, arrangements))\n\n\ndef"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip().split()[0])\n    t = int(stdin.strip().split()[1])\n    g = int(stdin.strip().split()[2])\n    cabs = list(map(int, stdin.strip().split()[3:]))\n    cabs.sort()\n    cabs.append(cabs[-1]+t)\n    cabs.insert(0,cabs[0]-t)\n    res = 0\n    for i in range(n):\n        res += cabs[i+1]-cabs[i]\n    return str(res)"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split())\n    skiers = []\n    for i in range(N):\n        skiers.append(int(stdin))\n    gondolas = set()\n    while G > 0:\n        G -= 1\n        for skier in skiers:\n            if not gondolas:\n                if skier == min(skiers):\n                    gondolas.add(skier)\n                continue\n            if skier == min(gondolas):\n                gondolas.add(skier)\n            else:\n                if skier in gondolas:\n                    gondolas.remove(skier)\n                skiers.remove(skier)\n                G += 1\n                break\n    return sum(map(lambda x: T - x, skiers))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n    4 10 2\n    0\n    15\n    30\n    45\n    ''')\n    10\n    \"\"\"\n    n, t, g = map(int, stdin.split())\n    # data = list(map(int, stdin.split()))\n    data = []\n    for _ in range(n):\n        data.append(int(input()))\n\n    def find_point(data: List[int], t: int, g: int):\n        points = []\n        for i in range(len(data)):\n            if data[i] < t:\n                points.append(data[i])\n\n        while len(points)!= g:\n            for i in range(len(points)):\n                if points[i] + t > t:\n                    points.pop(i)\n\n        return points[0]\n\n    print(find_point(data, t, g))\n"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n = int(stdin[0])\n    t = int(stdin[1])\n    g = int(stdin[2])\n    skier = stdin[3:]\n    dist = [[-1] * (g + 1) for _ in range(n + 1)]\n    dist[0] = [0] * (g + 1)\n    for i in range(n):\n        for j in range(g):\n            if j == 0:\n                dist[i + 1][j + 1] = skier[i] - t\n            else:\n                dist[i + 1][j + 1] = max(dist[i][j + 1], dist[i + 1][j - 1] + t)\n    return str(dist[n][g])"
    },
    {
        "number": 3228,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    num_of_skiers = input_data[0]\n    time_to_cycle = input_data[1]\n    gondola_cabs = input_data[2]\n\n    min_sum_waiting_time = float('inf')\n    for i in range(num_of_skiers):\n        num_of_gondolas = 0\n        wait_time = 0\n        for j in range(gondola_cabs):\n            if input_data[3 + j] - input_data[3 + j + (gondola_cabs - 1)] <= time_to_cycle:\n                wait_time += (input_data[3 + j] - input_data[3 + j + (gondola_cabs - 1)] - (\n                    (gondola_cabs - 1) * time_to_cycle))\n                num_of_gondolas += 1\n            else:\n                wait_time += ((input_data[3 + j] - input_data[3 + j + (gondola_cabs - 1)] - (\n                    (gondola_cabs - 1) * time_to_cycle)) - (gondola_cabs - 1) * time_to_cycle)\n                num_of_gondolas += 1\n                break\n        if wait_time < min_sum_waiting_time:\n            min_sum_waiting_time = wait_time\n    return str(min_sum_waiting_time)\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    scores = list(map(lambda x: int(x) * x, stdin.split()))\n    scores.sort(reverse=True)\n    idx = 0\n    for score in scores:\n        if idx < len(scores) and score > scores[idx]:\n            scores[idx] = scores[idx] - score\n        idx += 1\n    for i in range(0, len(scores)):\n        if scores[i] > 0:\n            return str(i + 1)\n    return \"0\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = list(map(int, stdin.split()))\n    scores.append(0)\n    scores.sort(reverse=True)\n    ranks = {}\n    \n    for i, s in enumerate(scores):\n        if s not in ranks:\n            ranks[s] = i + 1\n    \n    for s in sorted(ranks, reverse=True):\n        if s == 0:\n            return ranks[s]\n        if s not in ranks:\n            return ranks[s]\n\ndef"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split(\" \")))\n    scores = sorted(list(map(int, stdin.split(\"\\n\")[1:])), reverse=True)\n    m_points = sum(scores[:n - 1])\n    s = 0\n    for i, sc in enumerate(scores):\n        if i < n - 1:\n            s += sc\n            m_points = max(s, m_points)\n        else:\n            s += sc\n            m_points = max(s, m_points)\n    r = 1 + len([i for i in range(n - 1) if m_points > scores[i + 1]])\n    return str(r)\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    lines = stdin.split()\n    first = lines.pop(0)\n    s = list(map(int, lines))\n    print(s)\n    if first == \"1\":\n        return s.index(min(s))\n    else:\n        s = sorted(s, reverse=True)\n        if len(s) < 2:\n            return s.index(min(s))\n        else:\n            return s.index(min(s[0], s[1]))\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = (int(i) for i in stdin.split())\n    scores = list(sorted((int(i) for i in stdin.split()[1:])))\n    # print(scores)\n    return str(len(set(scores)) + 1)\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    contestants = list(map(lambda i: list(map(int, i.split())), stdin.split('\\n')))\n\n    scores = list()\n\n    for i in contestants:\n        scores.append(sum([s[1] for s in i[:-1]]))\n\n    max_scores = max(scores)\n    max_scores_index = scores.index(max_scores)\n\n    rank = 1\n    for i in range(max_scores_index):\n        scores_copy = scores.copy()\n        scores_copy[i] = scores[i] + sum([s[1] for s in contestants[i+1:]])\n        rank += (scores_copy.count(max(scores_copy)) + 1)\n\n    return str(rank)"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    contestants: List[Tuple[int, int]] = []\n    scores: List[int] = []\n    for contestant in stdin.splitlines():\n        contestants.append((int(contestant.split()[0]), int(contestant.split()[1])))\n        scores.append(int(contestant.split()[1]))\n\n    contestants.sort(key=lambda c: c[0])\n    scores.sort(reverse=True)\n    rank = 1\n    for i in range(len(scores) - 1):\n        if scores[i] < scores[i + 1]:\n            rank += 1\n    return str(rank)\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = sorted(map(int, stdin.split()))\n    #score\n    \n    #rank\n    #sort\n    \n    #rank\n    #rank\n    \n    \n    return \"1\"\n"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    scores = list(map(int, stdin.split()))\n    rank = 1\n    scores.sort(reverse=True)\n    while m > 0:\n        m -= 1\n        if scores[m] > scores[0]:\n            rank += 1\n            scores = list(map(lambda x: x + 1, scores))\n        else:\n            scores = list(map(lambda x: x - 1, scores))\n    return str(rank)"
    },
    {
        "number": 3229,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = list(map(int, stdin.split()))\n    scores.sort()\n    scores.append(0)\n    scores.append(101)\n\n    rank_list = []\n    max_rank = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            rank_list.append(scores[j]-scores[i])\n\n    for i in range(n+1):\n        if i+1 < n+1:\n            if rank_list[i] > max_rank:\n                max_rank = rank_list[i]\n        else:\n            max_rank = rank_list[i]\n    return str(max_rank)"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_row, input_col = map(int, stdin.strip().split())\n    input_data = stdin.strip().split('\\n')\n    input_data = list(map(lambda x: x.split(), input_data))\n    input_data = list(map(lambda x: [x[0], x[1]], input_data))\n\n    # max_x, max_y = 0, 0\n    # for row in input_data:\n    #     max_x = max(max_x, len(row))\n    #     max_y = max(max_y, len(row))\n    #\n    # table = [['.'] * (max_x + 2) for i in range(max_y + 2)]\n    #\n    # for row in input_data:\n    #     for i in range(len(row)):\n    #         table[i + 1][max_x + 1 - i] = row[i]\n\n    table = [['.'] * (input_col + 2) for i in range(input_row + 2)]\n    # print(table)\n    # print(len(table[0]))\n    for row in input_data:\n        for i in range(len(row)):\n            table[i + 1][input_col + 1 - i] = row[i]\n    print(table)\n    explosion = 0\n    for row in table:\n        if 'X' in row:\n            explosion += 1\n    return str(explosion)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.split()\n    R = int(t[0])\n    C = int(t[1])\n\n    seat_array = []\n    for i in range(R):\n        seat_array.append(list(stdin[i + 2]))\n\n    rows = len(seat_array)\n    cols = len(seat_array[0])\n\n    explosions = 0\n\n    for i in range(rows):\n        for j in range(cols):\n            if seat_array[i][j] == 'L':\n                explosions += 1\n                neighborhood = []\n                if i > 0:\n                    neighborhood.append(seat_array[i - 1][j])\n                if i < rows - 1:\n                    neighborhood.append(seat_array[i + 1][j])\n                if j > 0:\n                    neighborhood.append(seat_array[i][j - 1])\n                if j < cols - 1:\n                    neighborhood.append(seat_array[i][j + 1])\n                for p in neighborhood:\n                    if p == 'L':\n                        explosions += 1\n    return str(explosions)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, input().split())\n    grid = []\n    for _ in range(R):\n        grid.append(input())\n    board = [['.'] * (C + 2) for _ in range(R + 2)]\n\n    # fill first row and column with 'L'\n    for i in range(1, C + 1):\n        if grid[0][i] == 'X':\n            board[0][i] = 'L'\n        if grid[0][i] == 'X':\n            board[0][i] = 'L'\n\n    # fill first column with 'L'\n    for i in range(1, R + 1):\n        if grid[i][0] == 'X':\n            board[i][0] = 'L'\n        if grid[i][0] == 'X':\n            board[i][0] = 'L'\n\n    # fill first diagonal with 'X'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i == j:\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n\n    # fill first diagonal with 'X'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i + j == R + 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n\n    # fill last row with 'L'\n    for i in range(1, C + 1):\n        if grid[R][i] == 'X':\n            board[R][i] = 'L'\n        if grid[R][i] == 'X':\n            board[R][i] = 'L'\n\n    # fill last column with 'L'\n    for i in range(1, R + 1):\n        if grid[i][C] == 'X':\n            board[i][C] = 'L'\n        if grid[i][C] == 'X':\n            board[i][C] = 'L'\n\n    # fill last diagonal with 'X'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i - j == R - 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n\n    # fill last diagonal with 'X'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i + j == R + 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n                if grid[i][j] == 'X':\n                    board[i][j] = 'X'\n\n    # fill first row and column with '.'\n    for i in range(1, C + 1):\n        if grid[0][i] == 'X':\n            board[0][i] = '.'\n        if grid[0][i] == 'X':\n            board[0][i] = '.'\n\n    for i in range(1, R + 1):\n        if grid[i][0] == 'X':\n            board[i][0] = '.'\n        if grid[i][0] == 'X':\n            board[i][0] = '.'\n\n    # fill first column with '.'\n    for i in range(1, R + 1):\n        if grid[i][0] == 'X':\n            board[i][0] = '.'\n        if grid[i][0] == 'X':\n            board[i][0] = '.'\n\n    # fill first diagonal with '.'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i == j:\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n\n    # fill first diagonal with '.'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i + j == R + 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n\n    # fill last row with '.'\n    for i in range(1, C + 1):\n        if grid[R][i] == 'X':\n            board[R][i] = '.'\n        if grid[R][i] == 'X':\n            board[R][i] = '.'\n\n    # fill last column with '.'\n    for i in range(1, R + 1):\n        if grid[i][C] == 'X':\n            board[i][C] = '.'\n        if grid[i][C] == 'X':\n            board[i][C] = '.'\n\n    # fill last diagonal with '.'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i - j == R - 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n\n    # fill last diagonal with '.'\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if i + j == R + 1:\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n                if grid[i][j] == 'X':\n                    board[i][j] = '.'\n\n    # find all safe seats\n    safe_seats = []\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            if board[i][j] == '.':\n                safe_seats.append((i, j))\n    # print(safe"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n\n    layout = {}\n    for r in range(R):\n        layout[r] = stdin[r*C:(r+1)*C].replace('.', '')\n\n    for r in range(R):\n        for c in range(C):\n            layout[r][c] = 'X' if layout[r][c] == 'L' else 'X' if layout[r][c] == 'L' else '.'\n\n    visited = {(0,0)}\n    explosions = 0\n    while True:\n        to_visit = []\n        for x, y in visited:\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if 0 <= x + dx < R and 0 <= y + dy < C:\n                    if layout[x + dx][y + dy] == 'X':\n                        to_visit.append((x + dx, y + dy))\n        if len(to_visit) == 0:\n            break\n        visited |= set(to_visit)\n        explosions += 1\n\n    return str(explosions)\n\nprint(solution(input()))"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    c = 0\n    if stdin == '':\n        return '0'\n    return str(len([x for x in stdin if x == 'X']))\n\nprint(solution(input()))"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, rows, columns = stdin.split()\n    rows = int(rows)\n    columns = int(columns)\n    table = []\n    for _ in range(rows):\n        table.append(stdin.split()[0])\n    trams = {}\n    total_explosions = 0\n    for row in table:\n        for i in range(len(row)-1):\n            if row[i] == 'L':\n                if row[i+1] == 'L':\n                    continue\n                else:\n                    if (row[i], row[i+1]) in trams:\n                        trams[(row[i], row[i+1])] += 1\n                    else:\n                        trams[(row[i], row[i+1])] = 2\n            else:\n                if (row[i], row[i+1]) in trams:\n                    trams[(row[i], row[i+1])] += 1\n                else:\n                    trams[(row[i], row[i+1])] = 1\n    for (x, y) in trams:\n        if trams[(x, y)] == 1:\n            total_explosions += 1\n        elif trams[(x, y)] == 2:\n            total_explosions += 1\n            total_explosions += 1\n    return str(total_explosions)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n,m = map(int,stdin.split())\n    grid = stdin.split('\\n')\n    r = []\n    c = []\n    for i in range(n):\n        r.append(list(grid[i]))\n        c.append([])\n        for j in range(m):\n            if grid[i][j] == 'X':\n                c[i].append((i,j))\n    \n    def distance(point1,point2):\n        return ((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)**0.5\n    \n    for i in range(n):\n        for j in range(m):\n            if distance(c[i][0],c[i][-1]) < distance(c[i][0],c[i][1]):\n                c[i].append(c[i][0])\n            else:\n                c[i].append(c[i][-1])\n    res = 0\n    for i in range(n):\n        if len(c[i]) == m:\n            res += 1\n    return res\n\nstdin = \"\"\"3 4\n.X.\n.L.\n....\n\"\"\"\nprint(solution(stdin))\nstdin = \"\"\"5 5\n.L.X\n.X..X\n.X.X\n.X.X\n.X.X\n\"\"\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    matrix = []\n    explosion = 0\n    for i in range(len(stdin)):\n        matrix.append(stdin[i].split(\".\"))\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'L':\n                if matrix[i][j]!= 'X' and matrix[i][j]!= 'L':\n                    explosion += 1\n    return str(explosion)\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(stdin) for _ in range(R)]\n    alive = []\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == \"X\":\n                alive.append((r, c))\n            elif grid[r][c] == \"L\":\n                alive.append((r, c))\n                break\n    res = 0\n    while alive:\n        res += 1\n        new_alive = []\n        for r, c in alive:\n            if c + 1 < C and grid[r][c + 1] == \"L\":\n                new_alive.append((r, c + 1))\n            if r + 1 < R and grid[r + 1][c] == \"L\":\n                new_alive.append((r + 1, c))\n            if c - 1 >= 0 and grid[r][c - 1] == \"L\":\n                new_alive.append((r, c - 1))\n            if r - 1 >= 0 and grid[r - 1][c] == \"L\":\n                new_alive.append((r - 1, c))\n        alive = new_alive\n    return res\n"
    },
    {
        "number": 3230,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.strip().split())\n    board = {(i, j): stdin[j * R + i] for i in range(R) for j in range(C)}\n\n    def is_valid_seat(seat):\n        return len(board) >= seat[0] + 1 >= seat[1] >= 1 and board[seat] == 'L'\n\n    def count_explosion(r, c):\n        if board[r, c] == '.':\n            return count_explosion(r + 1, c) + count_explosion(r - 1, c) + count_explosion(r, c + 1) + count_explosion(r, c - 1)\n        elif board[r, c] == 'X':\n            return 0\n        else:\n            return 1\n\n    return sum(count_explosion(r, c) for r, c in board.keys() if is_valid_seat((r, c)))\n\n\nprint(solution(input()))\n\n\ndef"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = stdin.split(\" \")\n    n = int(n)\n    p = int(p)\n    q = int(q)\n    friendships = {i: set() for i in range(n)}\n    for i in range(n):\n        m = int(stdin.split(\"\\n\")[i])\n        for j in range(m):\n            friendships[i].add(stdin.split(\"\\n\")[i+1][j])\n    \n    # PART 1\n    if len(set(friendships.values())) == len(friendships):\n        print(\"home\")\n        return \"home\"\n    \n    # PART 2\n    def dfs(group: set, visited: set, friends_dct: dict) -> bool:\n        if len(visited) == len(friendships):\n            if len(group) <= p:\n                # print(group)\n                return True\n            else:\n                return False\n        \n        for friend in group:\n            if friend in friends_dct and friend not in visited:\n                # print(friend)\n                visited.add(friend)\n                group.remove(friend)\n                if dfs(group, visited, friends_dct):\n                    return True\n                visited.remove(friend)\n                group.add(friend)\n        return False\n\n    groups = []\n    for i in range(n):\n        group = friendships[i]\n        if len(group) > p:\n            continue\n        groups.append(group)\n        for j in range(i+1, n):\n            if group & friendships[j]:\n                groups.append(friendships[j])\n    \n    if len(groups) == 0:\n        return \"home\"\n    \n    group_dct = {i: set() for i in range(len(groups))}\n    for group in groups:\n        for friend in group:\n            group_dct[group].add(friend)\n    \n    for i, group in enumerate(group_dct):\n        group_dct[group].remove(i)\n        group_dct[i].remove(i)\n    \n    # print(group_dct)\n    if dfs(set(range(len(groups))), set(), group_dct):\n        return \"home\"\n    return \"detention\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    group_count = 0\n    student_count = 0\n    students = []\n    for line in stdin.split(\"\\n\")[1:]:\n        line = line.split()\n        if line:\n            student_count = int(line.pop(0))\n            students.append(student_count)\n        else:\n            group_count += 1\n            students.sort()\n            groups = [[student_count]]\n            for student in students:\n                groups[-1].append(student)\n                if len(groups[-1]) == group_count and groups[-1][0] == groups[-1][-1]:\n                    group_count += 1\n                    groups.append([student])\n            groups.sort(key=lambda x: x[0])\n            groups.sort(key=lambda x: x[-1])\n            groups.sort(key=lambda x: x[1])\n            groups.sort(key=lambda x: x[2])\n            groups.sort(key=lambda x: x[3])\n            groups.sort(key=lambda x: x[4])\n            groups.sort(key=lambda x: x[5])\n            groups.sort(key=lambda x: x[6])\n            groups.sort(key=lambda x: x[7])\n            groups.sort(key=lambda x: x[8])\n            groups.sort(key=lambda x: x[9])\n            groups.sort(key=lambda x: x[10])\n            groups.sort(key=lambda x: x[11])\n            groups.sort(key=lambda x: x[12])\n            groups.sort(key=lambda x: x[13])\n            groups.sort(key=lambda x: x[14])\n            groups.sort(key=lambda x: x[15])\n            groups.sort(key=lambda x: x[16])\n            groups.sort(key=lambda x: x[17])\n            groups.sort(key=lambda x: x[18])\n            groups.sort(key=lambda x: x[19])\n            groups.sort(key=lambda x: x[20])\n            groups.sort(key=lambda x: x[21])\n            groups.sort(key=lambda x: x[22])\n            groups.sort(key=lambda x: x[23])\n            groups.sort(key=lambda x: x[24])\n            groups.sort(key=lambda x: x[25])\n            groups.sort(key=lambda x: x[26])\n            groups.sort(key=lambda x: x[27])\n            groups.sort(key=lambda x: x[28])\n            groups.sort(key=lambda x: x[29])\n            groups.sort(key=lambda x: x[30])\n            groups.sort(key=lambda x: x[31])\n            groups.sort(key=lambda x: x[32])\n            groups.sort(key=lambda x: x[33])\n            groups.sort(key=lambda x: x[34])\n            groups.sort(key=lambda x: x[35])\n            groups.sort(key=lambda x: x[36])\n            groups.sort(key=lambda x: x[37])\n            groups.sort(key=lambda x: x[38])\n            groups.sort(key=lambda x: x[39])\n            groups.sort(key=lambda x: x[40])\n            groups.sort(key=lambda x: x[41])\n            groups.sort(key=lambda x: x[42])\n            groups.sort(key=lambda x: x[43])\n            groups.sort(key=lambda x: x[44])\n            groups.sort(key=lambda x: x[45])\n            groups.sort(key=lambda x: x[46])\n            groups.sort(key=lambda x: x[47])\n            groups.sort(key=lambda x: x[48])\n            groups.sort(key=lambda x: x[49])\n            groups.sort(key=lambda x: x[50])\n            groups.sort(key=lambda x: x[51])\n            groups.sort(key=lambda x: x[52])\n            groups.sort(key=lambda x: x[53])\n            groups.sort(key=lambda x: x[54])\n            groups.sort(key=lambda x: x[55])\n            groups.sort(key=lambda x: x[56])\n            groups.sort(key=lambda x: x[57])\n            groups.sort(key=lambda x: x[58])\n            groups.sort(key=lambda x: x[59])\n            groups.sort(key=lambda x: x[60])\n            groups.sort(key=lambda x: x[61])\n            groups.sort(key=lambda x: x[62])\n            groups.sort(key=lambda x: x[63])\n            groups.sort(key=lambda x: x[64])\n            groups.sort(key=lambda x: x[65])\n            groups.sort(key=lambda x: x[66])\n            groups.sort(key=lambda x: x[67])\n            groups.sort(key=lambda x: x[68])\n            groups.sort(key=lambda x: x[69])\n            groups.sort(key=lambda x: x[70])\n            groups.sort(key=lambda x: x[71])\n            groups.sort(key=lambda x: x[72])\n            groups.sort(key=lambda x"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    if n < 3 or p + q > 15 or n < p + q:\n        return \"detention\"\n    \n    # friend_list is a list of sets of friends\n    friend_list = []\n    # take the number of students and\n    # create a list of sets. Each\n    # set will contain all the friends\n    # of a student\n    for i in range(n):\n        friend_list.append(set(map(int, stdin.split()[i + 1])))\n\n    # first group contains no more than\n    # one student\n    first_group = {i for i in range(n)}\n\n    # second group contains no more than\n    # one student and at least one\n    # student in the first group\n    second_group = {i for i in range(n) if i not in first_group}\n\n    # groups = a list of the groups\n    # that need to be checked\n    groups = {first_group, second_group}\n\n    # while groups has not been exhausted\n    # (no more groups are needed to\n    # check), do the following\n    while groups:\n        # take a group out of the set\n        # of groups\n        group = groups.pop()\n\n        # for each student in the\n        # group\n        for student in group:\n            # see if student is\n            # already a friend of some\n            # student in the same group\n            if student in friend_list[student]:\n                # if so, remove the\n                # student from the set\n                group.remove(student)\n\n            # add the student to the set\n            # of friends in the first\n            # group\n            first_group.add(student)\n\n            # remove the student from the\n            # set of friends in the second\n            # group\n            second_group.remove(student)\n\n            # if both groups have one\n            # or more student in them\n            # add the student to the set\n            if len(first_group) == 1 or len(second_group) == 1:\n                # add the student to the\n                # set of friends in the\n                # second group\n                second_group.add(student)\n\n                # add the student to the\n                # set of friends in the\n                # first group\n                first_group.add(student)\n\n                # add the student to the\n                # set of friends in the\n                # first group\n                first_group.add(student)\n\n                # remove the student from the\n                # set of friends in the\n                # second group\n                second_group.remove(student)\n\n                # if there are no more\n                # friends in the first group\n                # then the person is lying\n                if len(first_group) == 1:\n                    # tell the person that\n                    # they are lying\n                    return \"detention\"\n\n                # if there are no more\n                # friends in the second group\n                # then the person is lying\n                if len(second_group) == 1:\n                    # tell the person that\n                    # they are lying\n                    return \"detention\"\n\n        # add the first group of\n        # friends to the set of groups\n        # to check\n        groups.add(first_group)\n\n        # add the second group of\n        # friends to the set of groups\n        # to check\n        groups.add(second_group)\n\n    # the student who is lying is lying\n    # if he is in the first group\n    if len(first_group) == 1:\n        # tell the person that\n        # he is lying\n        return \"detention\"\n\n    # the student who is lying is lying\n    # if he is in the second group\n    if len(second_group) == 1:\n        # tell the person that\n        # he is lying\n        return \"detention\"\n\n    # neither the person who is\n    # lying nor the person who is\n    # lying are lying.\n    return \"home\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, p, q = map(int, lines[0].split())\n\n    def is_friend(i, j):\n        return lines[i].count(j) > 0\n\n    # Run over the lines\n    i = 1\n    groups = []\n    while i < len(lines):\n        # Get the current group\n        group = []\n        # Iterate over the current group\n        while i < len(lines) and len(group) < p:\n            # Get the friend\n            friend = lines[i]\n            # Check if friend is in group\n            if is_friend(i, friend):\n                group.append(friend)\n            else:\n                i += 1\n            i += 1\n        # Add the group to the output\n        groups.append(group)\n        i += 1\n\n    def is_valid_group(group):\n        # If no groups, there are no valid groups\n        if len(group) == 0:\n            return False\n        # If group is only one student, it is always valid\n        if len(group) == 1:\n            return True\n        # If all students in the group are friends, group is valid\n        if all(is_friend(i, group[0]) for i in range(1, len(group))):\n            return True\n        # If all students in the group are friends, group is valid\n        if all(is_friend(i, group[0]) for i in range(1, len(group))):\n            return True\n        # If any student is not friends with every other student in group, group is invalid\n        for i in range(1, len(group)):\n            for j in range(i):\n                if not is_friend(j, group[i]):\n                    return False\n        return True\n\n    # Iterate over the groups\n    for group in groups:\n        # If any group is not valid, the whole thing is not valid\n        if not is_valid_group(group):\n            return \"detention\"\n    # All groups are valid, the output is home\n    return \"home\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = list(map(int, stdin.split()))\n    if n <= 0 or p <= 0 or q <= 0 or n < p + q:\n        return 'detention'\n    groups = [[] for _ in range(n)]\n    for i in range(n):\n        m = int(stdin.split()[i])\n        groups[i] = list(map(int, stdin.split()[i + 1 : i + 1 + m]))\n    return 'home' if is_valid(groups, n) else 'detention'\n\ndef"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin: input string\n    '''\n    n, p, q = map(int, input().split())\n    friends = sorted(list(map(int, stdin.split())))\n    if n < p + q:\n        return 'home'\n    if n < p or n < q:\n        return 'detention'\n    if p < 0 or q < 0:\n        return 'detention'\n    group_size = n // (p + q)\n    if group_size * (p + q)!= n:\n        return 'detention'\n    # group_size = n // (p + q)\n    # if group_size * (p + q)!= n:\n    #     return 'detention'\n    # #\n    # # why is the following broken\n    # # if p == 0 and q == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # elif p == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # elif q == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # else:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n\n    groups = [[] for _ in range(group_size)]\n\n    # group_size = n // (p + q)\n    # if group_size * (p + q)!= n:\n    #     return 'detention'\n\n    # p0 = 0\n    # q0 = 0\n\n    # # why is the following broken\n    # # if p == 0 and q == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # elif p == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # elif q == 0:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    # # else:\n    # #     if group_size * (p + q)!= n:\n    # #         return 'detention'\n    # #     else:\n    # #         return 'home'\n    #\n    # while p0 < p and q0 < q:\n    #     groups[q0].append(friends[q0])\n    #     q0 += 1\n    # while p0 < p:\n    #     groups[p0].append(friends[p0])\n    #     p0 += 1\n    #\n    # for i in range(group_size):\n    #     if len(groups[i]) == 0:\n    #         return 'detention'\n    #     if len(groups[i])!= p + q:\n    #         return 'detention'\n    #\n    # return 'home'\n\n    # p0 = 0\n    # q0 = 0\n\n    # if p == 0 and q == 0:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return 'home'\n    # elif p == 0:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return 'home'\n    # elif q == 0:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return 'home'\n    # else:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return 'home'\n    #\n    # while p0 < p and q0 < q:\n    #     groups[q0].append(friends[q0])\n    #     q0 += 1\n    # while p0 < p:\n    #     groups[p0].append(friends[p0])\n    #     p0 += 1\n    #\n    # for i in range(group_size):\n    #     if len(groups[i]) == 0:\n    #         return 'detention'\n    #     if len(groups[i])!= p + q:\n    #         return 'detention'\n    #\n    # return 'home'\n\n    # why is the following broken\n    # if p == 0 and q == 0:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return 'home'\n    # elif p == 0:\n    #     if group_size * (p + q)!= n:\n    #         return 'detention'\n    #     else:\n    #         return '"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    groups = []\n    for i in range(n):\n        groups.append([])\n    for i in range(n):\n        m = int(stdin.split()[i])\n        for j in range(m):\n            groups[i].append(int(stdin.split()[i * 2 + j + 1]))\n    return \"home\" if len(groups) == 2 else \"detention\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = list(map(int, stdin.split()))\n    friends = {}\n    for i in range(n):\n        friend_count = int(stdin.split()[i])\n        friends[i] = friend_count\n    total = sum(friends.values())\n    if total!= p * (p + 1) // 2 or total!= q * (q + 1) // 2:\n        return \"detention\"\n    students = set(range(n))\n    partition = []\n    remaining_students = students\n    for friend_count in friends.values():\n        students = students - set(range(friend_count))\n        partition.append(len(students))\n    for i in range(len(partition)):\n        remaining_students = remaining_students - set(range(partition[i]))\n    if remaining_students:\n        return \"home\"\n    return \"home\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    ans = \"home\"\n    m = {}\n    for _ in range(n):\n        ans = \"home\" if ans == \"detention\" else \"detention\"\n        #print(f\"ans={ans}, m={m}, n={n}, p={p}, q={q}\")\n        #m = {}\n        for j, f in enumerate(map(int, stdin.split())):\n            if f in m:\n                m[f] = max(m[f], j)\n            else:\n                m[f] = j\n            if (j - 1) in m and m[j] > m[j - 1] + 1:\n                ans = \"detention\"\n                break\n    return ans\n"
    },
    {
        "number": 3231,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.strip().split())\n    groups = [[] for _ in range(n)]\n    friends = set()\n    for i in range(n):\n        m = int(stdin.readline())\n        friends |= set(map(int, stdin.readline().split()))\n        groups[i].append(m)\n\n    for group in groups:\n        if len(group) < p:\n            return \"detention\"\n        if len(group) > q:\n            return \"detention\"\n\n    for group in groups:\n        if not (0 < len(group) <= p):\n            return \"detention\"\n\n    return \"home\"\n"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin\n    for _ in range(len(data) // 2):\n        data = data.replace('a' * (len(data) // 2), 'a', 1)\n    return data\n"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    length = len(stdin)\n    if length % 2 == 1:\n        return '-1'\n    s = stdin[:length//2]\n    for i in range(1, length//2 + 1):\n        if stdin[i*length//2:(i+1)*length//2]!= stdin[i*length//2:length//2]:\n            s = stdin[i*length//2:(i+1)*length//2]\n            break\n    return s\n"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find an arrangement of strings such that all substrings of length\n    is equal.\n    \"\"\"\n    n = int(stdin)\n    S = stdin.split()\n    if n % 2 == 1:\n        return '-1'\n    possible = True\n    for s1 in range(1, (n // 2) + 1):\n        if len(set(S[i:i + s1] for i in range(0, n, s1)))!= 1:\n            possible = False\n            break\n    if possible:\n        return ''.join(S)\n    else:\n        return '-1'\n"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def helper(sub_str: str) -> bool:\n        count = {}\n        for char in sub_str:\n            count[char] = count.get(char, 0) + 1\n        for char in count.keys():\n            if count[char] % 2!= 0:\n                return False\n        return True\n\n    def find_all_arrangements(string: str, index: int = 0, current_substring: str = \"\", result: str = \"\") -> str:\n        if index == len(string):\n            print(result)\n        for i in range(index, len(string)):\n            substring = string[index:i + 1]\n            if helper(substring):\n                find_all_arrangements(string, i + 1, current_substring + substring, result)\n\n    find_all_arrangements(string)\n"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = set('abcdefghijklmnopqrstuvwxyz')\n    input_len = len(stdin)\n    if input_len % 2!= 0:\n        return -1\n\n    for a in range(1, input_len // 2 + 1):\n        if all(stdin[i - a]!= stdin[i + a] for i in range(a, input_len - a + 1)):\n            return stdin[:a] + stdin[a:]\n    return stdin"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2!= 0:\n        return -1\n    if n == 1:\n        return stdin\n    for i in range(1, n, 2):\n        ss = stdin[:i]\n        if ss == stdin[::-1][:i]:\n            return ss\n    return stdin"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) % 2!= 0:\n        return '-1'\n    else:\n        d = {}\n        for i in range(0, len(stdin), 2):\n            if stdin[i] in d:\n                d[stdin[i]].append(stdin[i+1])\n            else:\n                d[stdin[i]] = [stdin[i+1]]\n        for i in d:\n            if len(d[i]) > 1:\n                return i\n        return '-1'"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin.lower()\n    N = len(string)\n\n    if N % 2!= 0:\n        return -1\n    else:\n        N = N // 2\n        s = ''\n        for i in range(N):\n            for j in range(i, N):\n                s += string[i:j + 1]\n                if s not in string:\n                    return s\n        return s"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your puzzle answer was $82$.\n\n    The first half of this puzzle is complete! It provides one gold star: **\n    \"\"\"\n    return stdin"
    },
    {
        "number": 3232,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split(\" \")\n    S = stdin_list[0]\n    N = int(stdin_list[1])\n    unique_letters = len(set(S))\n    if N % 2 == 0 and unique_letters!= 2:\n        return -1\n    if N % 2!= 0 and unique_letters!= 1:\n        return -1\n    final_string = S[:int((N / 2) - 1)] + S[int((N / 2)):]\n    print(final_string)\n    return final_string\n\nsolution(input())\n"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    if num % 2 == 0:\n        num = num / 2\n        return str(int((num - 1) / 2))\n    else:\n        num = num / 2\n        return str(int(num / 2))"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    array = list(map(int, stdin.split()))\n    l = 0\n    r = n - 1\n    while l < r:\n        if array[l] == array[r]:\n            l += 1\n            r -= 1\n        elif array[l] <= array[r]:\n            l += 1\n        else:\n            r -= 1\n    return r - l + 1"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1]))\n    median = _find_median(arr)\n    scary = 0\n    for i in range(len(arr)):\n        if arr[i] <= median:\n            scary += 1\n    return str(scary)\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.split()\n    n = int(arr[0])\n    arr = map(int, arr[1:])\n    mid_idx = (n + 1) // 2\n    left_idx = 0\n    right_idx = n\n    total = 0\n    while left_idx < right_idx:\n        mid = arr[mid_idx]\n        left_idx_num = min(mid_idx, left_idx)\n        right_idx_num = max(mid_idx, right_idx)\n        for i in range(left_idx_num, right_idx_num + 1):\n            if arr[i] > mid:\n                total += 1\n        mid_idx += 1\n        left_idx = left_idx_num + 1\n        right_idx = right_idx_num + 1\n    return str(total)\n"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    median = arr.index(int(round(sum(arr)/len(arr))))\n    left, right = median, median\n    s = 0\n    for i in range(n):\n        if i == median:\n            s += 1\n            continue\n        left = max(left, arr[i])\n        right = min(right, arr[i])\n        if left!= right:\n            s += 1\n    return s"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    arr = list(map(int, stdin.split()))\n    if len(arr) == 1:\n        if arr[0] == 0:\n            return 1\n        else:\n            return 0\n    mid = len(arr)//2\n    l = arr[:mid]\n    r = arr[mid:]\n    l_count = solution(l)\n    r_count = solution(r)\n    l_count += solution_2(l)\n    r_count += solution_2(r)\n    return max(l_count, r_count)\n\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    arr = list(map(int, stdin.strip().split()))\n    if len(arr) % 2 == 0:\n        median_idx = int(len(arr) / 2)\n        # print(arr[median_idx-1:median_idx+2])\n        # print(sum(arr[median_idx-1:median_idx+2]))\n        return arr.count(sum(arr[median_idx-1:median_idx+2]))\n    else:\n        median_idx = int(len(arr) / 2)\n        # print(arr[median_idx-1:median_idx+2])\n        # print(sum(arr[median_idx-1:median_idx+2]))\n        return arr.count(sum(arr[median_idx-1:median_idx+1]))"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def solution_rec(array: list, left: int, right: int, median: int) -> int:\n        if left == right:\n            return 0\n        if left + 1 == right:\n            return 1\n        mid = (left + right) // 2\n        if array[mid] <= median:\n            return solution_rec(array, left, mid, median) + solution_rec(array, mid + 1, right, median)\n        else:\n            return solution_rec(array, left, mid, median) + solution_rec(array, mid + 1, right, median) + 1\n\n    n = int(stdin)\n    array = list(map(int, stdin.split()))\n    median = int(len(array) / 2)\n    return str(solution_rec(array, 0, len(array) - 1, median))\n"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, n = stdin.split('\\n')\n    n = int(n)\n    a = sorted(map(int, stdin.split()))\n    left, right = 0, n - 1\n    if n % 2 == 0:\n        mid = (n - 1) // 2\n        left_sum, right_sum = 0, 0\n        left_max, right_max = a[mid], a[mid]\n        while left <= mid and right >= mid:\n            if left_max < a[left]:\n                left_sum += 1\n                left_max = a[left]\n            else:\n                left_max = a[left]\n            if right_max < a[right]:\n                right_sum += 1\n                right_max = a[right]\n            else:\n                right_max = a[right]\n            left += 1\n            right -= 1\n    else:\n        mid = n // 2\n        left_sum, right_sum = 0, 0\n        left_max, right_max = a[mid], a[mid]\n        while left <= mid and right >= mid:\n            if left_max < a[left]:\n                left_sum += 1\n                left_max = a[left]\n            else:\n                left_max = a[left]\n            if right_max < a[right]:\n                right_sum += 1\n                right_max = a[right]\n            else:\n                right_max = a[right]\n            left += 1\n            right -= 1\n    print(left_sum + right_sum)\n    return ''"
    },
    {
        "number": 3233,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.strip().split()\n    arr = sorted(arr)\n    if len(arr) == 1:\n        return 1\n    mid = int(len(arr) / 2)\n    if len(arr) % 2:\n        return sum([1 if arr[mid] < arr[mid - 1] else 0])\n    else:\n        return sum([1 if arr[mid] < arr[mid - 1] else 0, 1 if arr[mid] < arr[mid + 1] else 0])\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def h_ratio(h):\n        return 1.25 * 1.25 + 1.5 * 1.5 + 2 * 2\n    def w_ratio(w):\n        return 1.25 * 1.25 + 1.5 * 1.5 + 2 * 2\n\n    def min_w(s, i, w):\n        \"\"\"Find minimum width of all widgets in box (i, s)\"\"\"\n        if i >= s:\n            if w >= 2 * h_ratio(w) + 2 * w_ratio(w):\n                return min(w, min_w(s, i + 1, w - 2 * h_ratio(w) - 2 * w_ratio(w)))\n            else:\n                return min_w(s, i + 1, w)\n        else:\n            return w\n\n    def min_h(s, i, h):\n        \"\"\"Find minimum height of all widgets in box (i, s)\"\"\"\n        if i >= s:\n            if h >= 2 * h_ratio(h) + 2 * w_ratio(h):\n                return min(h, min_h(s, i + 1, h - 2 * h_ratio(h) - 2 * w_ratio(h)))\n            else:\n                return min_h(s, i + 1, h)\n        else:\n            return h\n\n    n = int(stdin)\n    res = 2 * h_ratio(n) + 2 * w_ratio(n)\n    for i in range(n):\n        w = min_w(n, i, 2 * h_ratio(n) + 2 * w_ratio(n))\n        h = min_h(n, i, 2 * h_ratio(n) + 2 * w_ratio(n))\n        res = min(res, w + h)\n    return str(res)\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    b = int(1 + (n - 2) * 2)\n    c = int(1 + ((n - 2) * 2) * (n - 3) / 2)\n    d = int(1 + (n - 3) * n / 2)\n    return str(min(b, c, d))\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return str(math.ceil(N/2))"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 4:\n        return f\"{1}\"\n    elif n <= 16:\n        return f\"{1}\"\n    elif n <= 64:\n        return f\"{1}\"\n    elif n <= 256:\n        return f\"{1}\"\n    elif n <= 512:\n        return f\"{2}\"\n    elif n <= 2048:\n        return f\"{2}\"\n    elif n <= 4096:\n        return f\"{3}\"\n    else:\n        return f\"{4}\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return str(min((N, ) * (N, )))\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return '%d' % (min(2*N - 2, N*2 - 1))\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    if N == 2:\n        return \"1\"\n    if N == 3:\n        return \"1\"\n    if N == 4:\n        return \"2\"\n    if N == 5:\n        return \"3\"\n    if N == 6:\n        return \"2\"\n    if N == 7:\n        return \"2\"\n    if N == 8:\n        return \"3\"\n    if N == 9:\n        return \"3\"\n    if N == 10:\n        return \"2\"\n    if N == 11:\n        return \"2\"\n    if N == 12:\n        return \"3\"\n    if N == 13:\n        return \"3\"\n    if N == 14:\n        return \"4\"\n    if N == 15:\n        return \"4\"\n    if N == 16:\n        return \"3\"\n    if N == 17:\n        return \"4\"\n    if N == 18:\n        return \"4\"\n    if N == 19:\n        return \"4\"\n    if N == 20:\n        return \"5\"\n    if N == 21:\n        return \"5\"\n    if N == 22:\n        return \"5\"\n    if N == 23:\n        return \"5\"\n    if N == 24:\n        return \"5\"\n    if N == 25:\n        return \"5\"\n    if N == 26:\n        return \"5\"\n    if N == 27:\n        return \"5\"\n    if N == 28:\n        return \"5\"\n    if N == 29:\n        return \"5\"\n    if N == 30:\n        return \"5\"\n    if N == 31:\n        return \"5\"\n    if N == 32:\n        return \"5\"\n    if N == 33:\n        return \"5\"\n    if N == 34:\n        return \"5\"\n    if N == 35:\n        return \"5\"\n    if N == 36:\n        return \"5\"\n    if N == 37:\n        return \"5\"\n    if N == 38:\n        return \"5\"\n    if N == 39:\n        return \"5\"\n    if N == 40:\n        return \"5\"\n    if N == 41:\n        return \"5\"\n    if N == 42:\n        return \"5\"\n    if N == 43:\n        return \"5\"\n    if N == 44:\n        return \"5\"\n    if N == 45:\n        return \"5\"\n    if N == 46:\n        return \"5\"\n    if N == 47:\n        return \"5\"\n    if N == 48:\n        return \"5\"\n    if N == 49:\n        return \"5\"\n    if N == 50:\n        return \"5\"\n    if N == 51:\n        return \"5\"\n    if N == 52:\n        return \"5\"\n    if N == 53:\n        return \"5\"\n    if N == 54:\n        return \"5\"\n    if N == 55:\n        return \"5\"\n    if N == 56:\n        return \"5\"\n    if N == 57:\n        return \"5\"\n    if N == 58:\n        return \"5\"\n    if N == 59:\n        return \"5\"\n    if N == 60:\n        return \"5\"\n    if N == 61:\n        return \"5\"\n    if N == 62:\n        return \"5\"\n    if N == 63:\n        return \"5\"\n    if N == 64:\n        return \"5\"\n    if N == 65:\n        return \"5\"\n    if N == 66:\n        return \"5\"\n    if N == 67:\n        return \"5\"\n    if N == 68:\n        return \"5\"\n    if N == 69:\n        return \"5\"\n    if N == 70:\n        return \"5\"\n    if N == 71:\n        return \"5\"\n    if N == 72:\n        return \"5\"\n    if N == 73:\n        return \"5\"\n    if N == 74:\n        return \"5\"\n    if N == 75:\n        return \"5\"\n    if N == 76:\n        return \"5\"\n    if N == 77:\n        return \"5\"\n    if N == 78:\n        return \"5\"\n    if N == 79:\n        return \"5\"\n    if N == 80:\n        return \"5\"\n    if N == 81:\n        return \"5\"\n    if N == 82:\n        return \"5\"\n    if N == 83:\n        return \"5\"\n    if N == 84:\n        return \"5\"\n    if N == 85:\n        return \"5\"\n    if N == 86:\n        return \"5\"\n    if N == 87:\n        return \"5\"\n    if N == 88:\n        return \"5\"\n    if N == 89:\n        return \"5\"\n    if N == 90:\n        return \"5\"\n    if N == 91:\n        return \"5\"\n    if N == 92:\n        return \"5\"\n    if N == 93:\n        return \"5\"\n    if N == 94:\n        return \"5\"\n    if N == 95:\n        return \"5\"\n    if N == 96:\n        return \"5\"\n    if N == 97:\n        return \"5\"\n    if N == 98:\n        return \"5\"\n    if N == 99:\n        return \"5\"\n    if N == 100:\n        return \"5\"\n    if N == 101:\n        return \"5\"\n    if N == 102:\n        return \"5\"\n    if N == 103:\n        return \"5\"\n    if N == 104:\n        return \"5\"\n    if N == 105:\n        return \"5\"\n    if N == 106:\n        return \"5\"\n    if N == 107:\n        return \"5\"\n    if N == 108:\n        return \"5\"\n    if N == 109:\n        return \"5\"\n    if N == 110:\n        return \"5\"\n    if N == 111:\n        return \"5\"\n    if N == 112:\n        return \"5\"\n    if N == 113:\n        return \"5\"\n    if N == 114:\n        return \"5\"\n    if N == 115:\n        return \"5\"\n    if N == 116:\n        return \"5\"\n    if N == 117:\n        return \"5\"\n    if N == 118:\n        return \"5\"\n    if N == 119:\n        return \"5\"\n    if N == 120:\n        return \"5\"\n    if N == 121:\n        return \"5\"\n    if N == 122:\n        return \"5\"\n    if N == 123:\n        return \"5\"\n    if N == 124:\n        return \"5\"\n    if N == 125:\n        return \"5\"\n    if N == 126:\n        return \"5\"\n    if N == 127:\n        return \"5\"\n    if N == 128:\n        return \"5\"\n    if N == 129:\n        return \"5\"\n    if N == 130:\n        return \"5\"\n    if N == 131:\n        return \"5\"\n    if N == 132:\n        return \"5\"\n    if N == 133:\n        return \"5\"\n    if N == 134:\n        return \"5\"\n    if N == 135:\n        return \"5\"\n    if N == 136:\n        return \"5\"\n    if N == 137:\n        return \"5\"\n    if N == 138:\n        "
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    counter = 0\n    while N > 0:\n        if N % 4 == 0:\n            N = N / 4\n            counter += 1\n        else:\n            N -= 1\n    return str(counter)\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    #dictionary of list of integers to represent N*(N+1)/2 squares\n    squares_list = {0:[]}\n    #initialize empty list of list of squares\n    squares_list[0] = [[]]\n    #initialize empty list of 2\n    squares_list[1] = [[2]]\n    #initialize empty list of 1\n    squares_list[2] = [[1]]\n    #add first row to the list of lists\n    squares_list[0].append([0])\n    #add first column to the list of lists\n    squares_list[0].append([0])\n    #iterate over N\n    for i in range(1,N+1):\n        #intialize empty list of list of squares\n        squares_list[i] = []\n        #iterate over the rows of the list\n        for j in range(i):\n            #iterate over the columns of the rows\n            for k in range(j+1):\n                #sum of the horizontal and vertical squares\n                sum = k + j\n                #if the sum is less than or equal to i, add it to the list\n                if sum <= i:\n                    squares_list[i].append(squares_list[i][k] + squares_list[i][j])\n                #otherwise, add i to the list\n                else:\n                    squares_list[i].append(i)\n            #iterate over the columns of the rows\n        #add the 2D list to the list of lists\n        squares_list[i].insert(0, [[]])\n        squares_list[i].append([])\n    #iterate over the rows\n    for j in range(N+1):\n        #if the square has any values, add it to the list\n        if squares_list[j]:\n            #add the list of lists to the list of lists\n            squares_list[0].append(squares_list[j])\n    #print the result\n    print(min(squares_list[N]))\n"
    },
    {
        "number": 3234,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    return str(min(2, 2*(N//2), N//2*(N//2)))"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    iou = {}\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        if a in iou:\n            if b in iou[a]:\n                iou[a][b]['c'] += c\n            else:\n                iou[a][b] = {'c': c}\n        else:\n            iou[a] = {b: {'c': c}}\n        if b in iou:\n            if a in iou[b]:\n                iou[b][a]['c'] += c\n            else:\n                iou[b][a] = {'c': c}\n        else:\n            iou[b] = {a: {'c': c}}\n    result = []\n    while iou:\n        candidates = [(k, v) for k, v in iou.items() if v]\n        candidates = sorted(candidates, key=lambda x: x[1]['c'])\n        # print(candidates)\n        for candidate in candidates:\n            k, v = candidate\n            if v:\n                result.append(k)\n                if v[0]['c'] <= 0:\n                    del iou[k]\n                else:\n                    iou[k] = v[0]\n            else:\n                del iou[k]\n    return len(result)\n"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = [0 for _ in range(n)]\n    iou = {}\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        if (a not in iou) or (b not in iou) or (friends[a] == friends[b]):\n            iou[(a, b)] = c\n            friends[a] += c\n            friends[b] -= c\n        else:\n            iou[(a, b)] += c\n            friends[a] -= c\n            friends[b] -= c\n    return str(len(iou)) + '\\n' + '\\n'.join(f'{k[0]} {k[1]} {v}' for k, v in sorted(iou.items()))"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, m = map(int, stdin.split())\n    iou = {}\n    for i in range(n):\n        iou[i] = {}\n        for j in range(n):\n            iou[i][j] = int(stdin[i*n+j])\n    s = [0]*n\n    done = set()\n    for i in range(n):\n        for j in range(n):\n            if iou[i][j] in done:\n                continue\n            done.add(iou[i][j])\n            cycle = []\n            while True:\n                cycle.append(iou[i][j])\n                if iou[i][j] == 0:\n                    break\n                if iou[i][j] == -iou[j][i]:\n                    for j in range(n):\n                        if iou[i][j] == 0:\n                            break\n                        cycle.append(iou[j][i])\n                    break\n                iou[i][j] = 0\n                iou[j][i] = 0\n            for j in range(len(cycle)):\n                if cycle[j]!= 0:\n                    s[cycle[j]] += cycle[j]\n    count = 0\n    for i in range(n):\n        if s[i]!= 0:\n            count += 1\n    return str(count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Get the numbers from stdin.\n    lines = stdin.strip().split('\\n')\n    n, m = list(map(int, lines[0].split()))\n\n    # Get the IOUs from stdin.\n    cycles = []\n    for _ in range(m):\n        i, j, c = list(map(int, lines[1].split()))\n        i, j = i-1, j-1\n        cycles.append((i, j, c))\n    cycles.sort(key=lambda x: x[2])\n    #print(cycles)\n\n    # Get the friends and IOUs.\n    friends = []\n    iou_count = 0\n    for _ in range(n):\n        friends.append(int(input()))\n    friend_count = len(friends)\n    print(friend_count)\n    #print(friends)\n\n    # Create a graph.\n    #print(len(friends))\n    friend_graph = {}\n    for i in range(friend_count):\n        friend_graph[friends[i]] = []\n    #print(friend_graph)\n    # Create the IOU graph.\n    for i in range(len(cycles)):\n        iou_graph = {}\n        for j in range(i+1, len(cycles)):\n            iou_graph[cycles[j][0]] = cycles[j][1]\n        #print(iou_graph)\n        friend_graph[cycles[i][0]].append(cycles[i][1])\n        friend_graph[cycles[i][1]].append(cycles[i][0])\n        #print(friend_graph)\n\n    #print(friend_graph)\n\n    # Solve the problem.\n    def get_sorted_friend_graph(graph: dict):\n        n = len(graph)\n        sorted_graph = {}\n        for i in range(n):\n            sorted_graph[i] = set()\n        for i in range(n):\n            for j in graph[i]:\n                sorted_graph[j].add(i)\n        return sorted_graph\n\n    def get_sorted_friend_graph_with_cycles(graph: dict):\n        n = len(graph)\n        sorted_graph = {}\n        for i in range(n):\n            sorted_graph[i] = set()\n        for i in range(n):\n            for j in graph[i]:\n                sorted_graph[j].add(i)\n        for i in range(n):\n            sorted_graph[i] = sorted(sorted_graph[i])\n        return sorted_graph\n\n    sorted_friend_graph = get_sorted_friend_graph(friend_graph)\n    #print(sorted_friend_graph)\n    #print(friend_graph)\n    sorted_friend_graph_with_cycles = get_sorted_friend_graph_with_cycles(friend_graph)\n    #print(sorted_friend_graph_with_cycles)\n\n    #print(sorted_friend_graph)\n\n    #print(friend_graph)\n\n    # Create an empty list.\n    #result = []\n\n    # Consider all cycles and remove their edges from the graph.\n    for i in range(len(cycles)):\n        iou_graph = sorted_friend_graph_with_cycles[cycles[i][0]]\n        jou_graph = sorted_friend_graph_with_cycles[cycles[i][1]]\n\n        # Remove the edge from the jou graph.\n        #print(jou_graph)\n        jou_graph.remove(cycles[i][1])\n        #print(jou_graph)\n\n        # Remove the edge from the iou graph.\n        #print(iou_graph)\n        iou_graph.remove(cycles[i][0])\n        #print(iou_graph)\n\n        # Add the edge to the jou graph.\n        #print(jou_graph)\n        jou_graph.add(cycles[i][1])\n        #print(jou_graph)\n\n        # Add the edge to the iou graph.\n        #print(iou_graph)\n        iou_graph.add(cycles[i][0])\n        #print(iou_graph)\n\n        #print(sorted_friend_graph_with_cycles)\n\n        # print(sorted_friend_graph)\n        #print(sorted_friend_graph_with_cycles)\n        # Update the sorted friend graph.\n        sorted_friend_graph = get_sorted_friend_graph(friend_graph)\n\n        #print(sorted_friend_graph)\n        #print(friend_graph)\n\n        # print(friend_graph)\n        #print(sorted_friend_graph)\n\n        # print(friend_graph)\n        #print(sorted_friend_graph_with_cycles)\n\n    #print(sorted_friend_graph_with_cycles)\n\n    # Eliminate any cycles.\n    for i in range(len(cycles)):\n        iou_graph = sorted_friend_graph_with_cycles[cycles[i][0]]\n        jou_graph = sorted_friend_graph_with_cycles[cycles[i][1]]\n        # print(iou_graph)\n        # print(jou_graph)\n        for j in range(i+1, len(cycles)):\n            iou_graph.discard(cycles[j][0])"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    iou_graph = {i: [] for i in range(n)}\n    for _ in range(m):\n        f1, f2, c = map(int, stdin.split())\n        if f1 == f2:\n            continue\n        iou_graph[f1].append((f2, c))\n        iou_graph[f2].append((f1, c))\n    cancel_cycle(iou_graph, n)\n    return str(sum([c for c in iou_graph.values()]))\n\n\ndef"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # do your work here\n    friend_list = []\n    friend_dict = {}\n    total_expenses = 0\n    for _ in range(int(stdin.split()[0])):\n        friend_list.append(stdin.split()[1:])\n    for i in range(len(friend_list)):\n        if friend_list[i][0] in friend_dict:\n            friend_dict[friend_list[i][0]][0] = friend_list[i][0]\n            friend_dict[friend_list[i][0]][1] += int(friend_list[i][1])\n        else:\n            friend_dict[friend_list[i][0]] = [friend_list[i][0], int(friend_list[i][1])]\n        if friend_list[i][1] in friend_dict:\n            friend_dict[friend_list[i][1]][0] = friend_list[i][1]\n            friend_dict[friend_list[i][1]][1] += int(friend_list[i][2])\n        else:\n            friend_dict[friend_list[i][1]] = [friend_list[i][1], int(friend_list[i][2])]\n    for i in range(len(friend_list)):\n        total_expenses += friend_dict[friend_list[i][0]][1]\n        total_expenses += friend_dict[friend_list[i][1]][1]\n    friend_list.sort(key=lambda x: x[2])\n    friend_list.sort(key=lambda x: x[1])\n    friend_list.sort(key=lambda x: x[0])\n    friend_list.sort(key=lambda x: x[1])\n    print(friend_list)\n    res = []\n    i = 0\n    while i < len(friend_list):\n        if friend_list[i][0] == friend_list[i][1]:\n            res.append(friend_list[i])\n            i += 1\n            continue\n        if i+1 < len(friend_list):\n            if friend_list[i][0] == friend_list[i+1][1] and friend_list[i][1] == friend_list[i+1][0]:\n                res.append(friend_list[i])\n                res.append(friend_list[i+1])\n                i += 2\n                continue\n        if i+1 < len(friend_list):\n            if friend_list[i][1] == friend_list[i+1][0]:\n                res.append(friend_list[i])\n                res.append(friend_list[i+1])\n                i += 2\n                continue\n        if i+1 < len(friend_list):\n            if friend_list[i][0] == friend_list[i+1][1]:\n                res.append(friend_list[i])\n                res.append(friend_list[i+1])\n                i += 2\n                continue\n        if i+1 < len(friend_list):\n            if friend_list[i][1] == friend_list[i+1][0]:\n                res.append(friend_list[i])\n                res.append(friend_list[i+1])\n                i += 2\n                continue\n    res.sort(key=lambda x: x[2])\n    res.sort(key=lambda x: x[1])\n    res.sort(key=lambda x: x[0])\n    res.sort(key=lambda x: x[1])\n    for i in range(len(res)):\n        if res[i] not in friend_dict:\n            continue\n        if friend_dict[res[i]][1]!= 0:\n            friend_dict[res[i]][1] -= total_expenses\n    res = []\n    for i in range(len(friend_dict)):\n        if friend_dict[i][1] == 0:\n            res.append(friend_dict[i][0])\n    res = list(dict.fromkeys(res))\n    print(res)\n    return str(len(res))\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    cycles = {}\n    for i in range(n):\n        cycles[i] = []\n    for i in range(m):\n        a, b, c = list(map(int, stdin.split()))\n        cycles[a].append(b)\n        cycles[b].append(a)\n    cycles = sorted(cycles.items(), key=lambda x: len(x[1]))\n    for _, cycle in cycles:\n        cycle = sorted(cycle, key=lambda x: x)\n        for i in range(len(cycle) - 1):\n            if cycle[i] not in cycles[cycle[i + 1]]:\n                cycle = sorted(cycle[i + 1:], key=lambda x: x)\n                break\n            if cycle[i] in cycles[cycle[i + 1]]:\n                cycle = cycle[i + 1:]\n                break\n        else:\n            cycle = cycle[1:]\n        if len(cycle) == 0:\n            return '0'\n        for i in range(len(cycle)):\n            cycle[i] -= 1\n    result = sorted(map(lambda x: str(x), cycles), key=lambda x: x[0])\n    return''.join(result)\n"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n, m = map(int, stdin.pop(0).split(\" \"))\n    friends = list(map(int, stdin.pop(0).split(\" \")))\n    assert len(friends) == n\n    iou_set = list(map(int, stdin.pop(0).split(\" \")))\n    assert len(iou_set) == m\n    iou_set = set(iou_set)\n    # print(iou_set)\n    iou_set.remove(0)\n    iou_set = list(iou_set)\n    iou_set.sort()\n    # print(iou_set)\n    iou_set = set(iou_set)\n    # print(iou_set)\n    # iou_set = set(iou_set)\n    # print(iou_set)\n    # iou_set.remove(0)\n    # print(iou_set)\n    # iou_set = list(iou_set)\n    # print(iou_set)\n    iou_set.sort()\n    # print(iou_set)\n    # print(iou_set)\n    cancellations = []\n    for i, friend1 in enumerate(iou_set):\n        for friend2 in iou_set:\n            if friend1 > friend2:\n                cancellations.append([friend1, friend2])\n            if friend1 == friend2:\n                continue\n            else:\n                if friend1 > 0:\n                    cancellations.append([friend1, friend2])\n    print(cancellations)\n    while len(cancellations) > 0:\n        print(cancellations)\n        if len(cancellations) > 2:\n            iou1, iou2 = cancellations[0], cancellations[1]\n            iou1_index = iou_set.index(iou1)\n            iou2_index = iou_set.index(iou2)\n            iou1_index, iou2_index = min(iou1_index, iou2_index), max(iou1_index, iou2_index)\n            iou_set = iou_set[:iou1_index] + iou_set[iou2_index + 1:]\n            cancellations = []\n        else:\n            iou1, iou2 = cancellations[0], cancellations[1]\n            iou1_index = iou_set.index(iou1)\n            iou2_index = iou_set.index(iou2)\n            iou1_index, iou2_index = min(iou1_index, iou2_index), max(iou1_index, iou2_index)\n            iou_set = iou_set[:iou1_index] + iou_set[iou2_index + 1:]\n            cancellations = []\n    print(iou_set)\n    print(len(iou_set))\n    return str(len(iou_set))\n\n\nprint(solution(\"\"\"4 5\n0 1 10\n1 2 10\n0 3 10\n3 2 10\n2 0 20\"\"\"[1:]))\n"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    # friends = {f: set() for f in range(n)}\n    # debts = {f: set() for f in range(n)}\n    # debts_cycle = {}\n    # for f in range(n):\n    #     debts[f] = set()\n    #     debts_cycle[f] = set()\n    # debts[f].add(c)\n    # debts_cycle[f].add(c)\n\n    debts = {}\n    for f in range(n):\n        debts[f] = set()\n    for line in stdin.split('\\n'):\n        if len(line) == 0: continue\n        a, b, c = list(map(int, line.split()))\n        if a in debts:\n            debts[a].add(b)\n        else:\n            debts[a] = set([b])\n        if b in debts:\n            debts[b].add(a)\n        else:\n            debts[b] = set([a])\n    cycles = []\n    for f in debts:\n        if len(debts[f]) > 1:\n            cycles.append(f)\n    # print(debts)\n    # print(cycles)\n    # print(debts_cycle)\n    # print(debts_cycle[cycles[0]])\n\n    # print(debts_cycle)\n    for c in cycles:\n        # print(f'debts_cycle[{c}]')\n        debts_cycle[c] = debts_cycle[c].union(debts_cycle[c].difference(debts_cycle[c]))\n        # print(debts_cycle[c])\n    # print(debts_cycle)\n    # print(debts_cycle[cycles[0]])\n    # print(debts_cycle[cycles[0]])\n    # print(debts_cycle)\n\n    while len(cycles) > 0:\n        for c in cycles:\n            if len(debts[c]) == 1:\n                # print(f'{c} owes {debts[c]}')\n                debts_cycle[c] = debts_cycle[c].union(debts_cycle[c].difference(debts_cycle[c]))\n                # print(debts_cycle[c])\n                debts[c] = debts[c].difference(debts_cycle[c])\n                debts_cycle[c].add(c)\n                cycles.remove(c)\n                for c in cycles:\n                    # print(f'debts_cycle[{c}]')\n                    debts_cycle[c] = debts_cycle[c].union(debts_cycle[c].difference(debts_cycle[c]))\n                    # print(debts_cycle[c])\n        # print(debts_cycle)\n        # print(cycles)\n        # print(debts)\n        # print(cycles)\n    # print(debts)\n    # print(debts_cycle)\n    # print(debts_cycle[cycles[0]])\n    # print(debts_cycle[cycles[0]])\n    # print(debts_cycle)\n\n    p = 0\n    for c in cycles:\n        if len(debts[c]) == 1:\n            p += 1\n    # print(p)\n    for c in cycles:\n        # print(f'{c} owes {debts[c]}')\n        debts_cycle[c] = debts_cycle[c].union(debts_cycle[c].difference(debts_cycle[c]))\n        # print(debts_cycle[c])\n        debts[c] = debts[c].difference(debts_cycle[c])\n        debts_cycle[c].add(c)\n    # print(debts)\n    # print(cycles)\n    # print(debts_cycle)\n\n    for c in cycles:\n        if len(debts[c]) == 1:\n            p += 1\n    return str(p)"
    },
    {
        "number": 3235,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    friend_n: int = int(stdin.split()[0])\n    iou_n: int = int(stdin.split()[1])\n    friends: list = []\n    iou_issued: list = []\n\n    for friend_id in range(friend_n):\n        friend: list = list(map(int, stdin.split()[friend_id + 2].split()))\n        friends.append(friend)\n\n    for iou_id in range(iou_n):\n        iou: list = list(map(int, stdin.split()[iou_id + 2].split()))\n        iou_issued.append(iou)\n\n    friends = dict(friends)\n    iou_issued = dict(iou_issued)\n\n    iou_issued_list = []\n    for iou in iou_issued:\n        iou_issued_list.append(iou)\n\n    iou_issued_list.sort()\n    n = len(iou_issued_list)\n    cycles = []\n    for i in range(n):\n        for j in range(n):\n            if friends[iou_issued_list[i][0]] == friends[iou_issued_list[j][1]]:\n                cycles.append(iou_issued_list[j])\n\n    for cycle in cycles:\n        iou_issued.pop(cycle[0])\n        friends.pop(cycle[1])\n\n    for key in friends.keys():\n        friends[key] = friends[key] - (iou_n * cycle_size)\n        iou_issued.pop(key)\n\n    iou_issued.pop(0)\n\n    while iou_issued:\n        for iou in iou_issued:\n            if friends[iou[0]] == friends[iou[1]]:\n                iou_issued.pop(iou[0])\n                friends.pop(iou[1])\n                cycles.append(iou)\n\n    while cycles:\n        cycles.sort()\n        cycle_size = cycles[0][0]\n        cycles = cycles[1:]\n\n        for key in friends.keys():\n            friends[key] = friends[key] - cycle_size\n            iou_issued.pop(key)\n\n        iou_issued.pop(cycle_size)\n        cycles = list(filter(lambda x: x[0]!= cycle_size, cycles))\n\n    iou_issued_list.sort()\n    for iou in iou_issued_list:\n        print(iou[0], iou[1], iou[2])\n    print(len(iou_issued_list))\n\n    return stdin.strip()\n\nprint(solution(input()))"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mansions = list(map(int, stdin.split()))\n    return str(max(man_tour(mansions), 0))\n\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    M = map(int, stdin.split())\n    return max(Fibonacci(M))\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    n, m = map(int, lines[0].split())\n    mansions = sorted(map(int, lines[1].split()))\n    roads = []\n    for i in range(2, len(lines), 2):\n        roads.append(sorted(map(int, lines[i].split())))\n    \n    # print(n, m)\n    # print(mansions)\n    # print(roads)\n\n    def get_pos(mansion):\n        for i in range(len(mansions)):\n            if mansions[i] == mansion:\n                return i\n        return -1\n\n    visited = [-1] * n\n    max_length = 0\n    pos_to_visit = 0\n    while pos_to_visit < len(mansions):\n        if visited[pos_to_visit] >= 0:\n            pos_to_visit += 1\n            continue\n        visited[pos_to_visit] = get_pos(pos_to_visit)\n        length = 1\n        while pos_to_visit + 1 < len(mansions) and get_pos(pos_to_visit + 1)!= visited[pos_to_visit]:\n            length += 1\n            pos_to_visit = get_pos(pos_to_visit)\n        if length > max_length:\n            max_length = length\n        pos_to_visit += 1\n    # print(visited)\n    # print(max_length)\n    return str(max_length)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def Fibonacci(n: int) -> int:\n        if n < 2:\n            return n\n        return Fibonacci(n - 1) + Fibonacci(n - 2)\n    N, M = [int(i) for i in stdin.split()]\n    height = [int(i) for i in stdin.split()]\n    s = set()\n    for i in range(M):\n        s.add(tuple(height[i * 2: i * 2 + 2]))\n    count = 1\n    for h in height:\n        count = max(count, Fibonacci(h))\n    return str(count)\nprint(solution(input()))"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    numMansion = int(stdin.split()[0])\n    numRoad = int(stdin.split()[1])\n    mansions = list(map(int, stdin.split()[2:]))\n    visited = [False] * numMansion\n    fibonacciTour = []\n    if numMansion < 2:\n        return str(0)\n    if numMansion == 2:\n        return str(1)\n    if numMansion == 3:\n        if max(mansions) > 2:\n            return str(2)\n        else:\n            return str(1)\n    if numMansion > 4:\n        for i in range(len(mansions)):\n            fibonacciTour.append(0)\n        return str(1)\n    if numMansion > 6:\n        if numMansion == 6:\n            fibonacciTour = [1, 1, 2, 3, 5, 8, 13]\n            return str(6)\n        if numMansion == 7:\n            fibonacciTour = [1, 1, 2, 3, 4, 7, 11, 16, 23, 32, 47, 61, 76, 93, 106, 121, 140, 157, 173, 182, 193, 210, 226, 234, 245, 254, 281, 286, 307, 322, 354, 361, 377, 410, 441, 462, 483, 504, 543, 576, 604, 635, 666, 707, 736, 767, 803, 842, 885, 905, 946, 987, 1032, 1074, 1113, 1162, 1213, 1264, 1322, 1373, 1430, 1488, 1548, 1592, 1642, 1703, 1760, 1818, 1882, 1947, 2045, 2105, 2145, 2197, 2251, 2300, 2354, 2398, 2439, 2490, 2529, 2587, 2638, 2713, 2761, 2798, 2848, 2896, 2946, 3032, 3081, 3092, 3128, 3179, 3221, 3290, 3347, 3394, 3445, 3492, 3540, 3615, 3670, 3728, 3813, 3879, 3952, 4025, 4094, 4141, 4199, 4257, 4314, 4371, 4451, 4555, 4594, 4659, 4704, 4773, 4873, 4971, 5068, 5102, 5163, 5207, 5271, 5336, 5385, 5454, 5529, 5573, 5674, 5777, 5950, 6083, 6222, 6372, 6448, 6496, 6608, 6725, 6776, 6842, 6907, 6970, 7038, 7116, 7170, 7237, 7294, 7355, 7452, 7493, 7502, 7587, 7637, 7701, 7798, 7869, 7942, 8037, 8058, 8122, 8202, 8270, 8316, 8380, 8430, 8513, 8565, 8627, 8700, 8766, 8839, 8915, 8979, 9041, 9056, 9117, 9290, 9409, 9470, 9557, 9604, 9657, 9730, 9780, 9856, 9926, 9977, 10052, 10120, 10179, 10243, 10284, 10335, 10380, 10461, 10541, 10584, 10662, 10741, 10784, 10856, 10909, 10973, 11014, 11117, 11183, 11263, 11336, 11418, 11474, 11543, 11631, 11677, 11793, 11879, 11972, 12067, 12103, 12133, 12199, 12265, 12323, 12349, 12473, 12588, 12671, 12750, 12858, 12986, 13032, 13126, 13191, 13266, 13329, 13394, 13438, 13509, 13568, 13655, 13742, 13786, 13880, 13892, 13990, 14043, 14084, 14187, 14207, 14271, 14371, 14414, 14474, 14555, 14573, 14596, 14626, 14701, 14778, 14862, 14931, 14982, 15075, 15145, 15197, 15325, 15363, 15413, 15493, 15569, 15607, 15670, 15743, 15827, 15909, 15988, 16064, 16041, 16086, 16141, 16212, 16312, 16422, 16502, 16577, 16670, 16766, 16800, 16932, 17012, 17054, 17071, 17095, 17105, 17145, 17200, 17230, 17239, 17257, 17290, 17333, 17413, 17519, 17621, 17737, 17826, 17905, 17967, 18052, 18080, 18191, 18276, 18346, 18434, 18524, 18615, 18724, 18812, 18920, 19068, 19120, 19182, 19255, 19388, 19460, 19512, 19613, 19730, 19837, 19940, 20041, 20146, 20235, 20286, 20359, 20425, 20510, 20612, 20732, 20839, 20950, 21007, 21092, 21226, 21375, 21480, 21563, 21661, 21757, 21853, 21949, 22045, 22117, 22192, 22293, 22389, 22489, 22584, 22611, 22721, 22836, 22931, 23035, 23114, 23218, 23337, 23422, 23515, 23610, 23745, 23859, 23971, 24007, 24042, 24098, 24192, 24274, 24409, 24553, 24629, 24726, 24845, 24960, 25038, 25164, 25294, 25436, 25454, 25590, 25672, 25801, 25926, 26112, 26320, 26422, 26543, 26660, 26793, 26882, 26974, 27071, 27190, 27310, 27446, 27572, 27646, 27753, 27953, 28048, 28227, 28396, 28578, 28723, 28920, 29077, 29265, 29447, 29538, 29647, 29743, 29861, 29977, 30071, 30240, 30349, 30500, 30653, 30779, 30921, 31075, 31212, 31335, 31467, 31519, 31639, 31781, 31886, 31922, 32073, 322"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    mansions = sorted(list(map(int, stdin.split())))\n\n    if n == 1:\n        return 0\n\n    tours = []\n\n    for i in range(0, n - 1):\n        tours.append(tour(mansions, i))\n\n    max_len = 0\n    for tour in tours:\n        if max_len < tour.length:\n            max_len = tour.length\n    return max_len\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = (int(_) for _ in stdin.split())\n    mappings = {(nums := (int(_) for _ in stdin.split()))}\n    best = 0\n    while True:\n        valid = False\n        for i in range(len(mappings)):\n            valid = True\n            for j in range(i + 1, len(mappings)):\n                if nums[i] + nums[j] not in mappings:\n                    break\n            if valid:\n                break\n        if not valid:\n            break\n        mappings.add(tuple(sorted(nums)))\n        best = max(best, len(mappings))\n    return best\n"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    mansions = list(map(int, stdin.split()))\n    heights = list(mansions)\n    # man = {}\n    # for i, h in enumerate(mansions):\n    #     man[h] = i + 1\n    # print(man)\n    # print(mansions)\n    # print(heights)\n    tour = []\n    # print(tour)\n    tour.append(1)\n    # print(tour)\n    heights[0] = 1\n    # print(heights)\n    pre = 0\n    # print(heights)\n    for i in range(1, n):\n        # print(heights)\n        # print(man[heights[i]])\n        # print(i, man[heights[i]])\n        tour.append(man[heights[i]])\n        heights[man[heights[i]] - 1] = heights[i]\n    # print(tour)\n    # print(heights)\n    return len(tour)\n"
    },
    {
        "number": 3236,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    _ = input()\n    h = list(map(int, input().split()))\n    _ = input()\n    path = []\n    for _ in range(m):\n        _, a, b = input().split()\n        path.append((int(a), int(b)))\n    return str(max(len(find_fibonacci_tour(h, path)), 0))\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr = stdin.split('\\n')[0]\n    primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]\n    total = 0\n    for i in range(0, len(arr)):\n        if arr[i] in primes:\n            total += int(arr[i])\n            print(i)\n    print(total)\n\nsolution(arr)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    prime_factors = sorted(map(lambda x: int(x), n))\n    ans = 0\n    while True:\n        candidate = 0\n        for i in range(1, len(prime_factors)):\n            if prime_factors[i] > m:\n                break\n            candidate = max(candidate, prime_factors[i] * (m//prime_factors[i]))\n        if candidate > m:\n            break\n        ans += candidate\n        m = m - candidate\n    return ans\nprint(solution(input()))\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    res = 0\n    while int(stdin) > 0:\n        res += 1\n        div = 2\n        while int(stdin) >= 10:\n            if int(stdin) % div == 0:\n                res += div\n                stdin = stdin.replace(str(div), '')\n                break\n            div += 1\n        else:\n            res += 1\n            stdin = stdin.replace(str(div), '')\n    return str(res)\n\n\nprint(solution(input()))\n\n-------Code-------\nfor i in range(int(input())):\n    s = int(input())\n    count = 1\n    while s >= 10:\n        s = s // 10\n        count += 1\n    if s > 0:\n        count += 1\n    print(count)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    cost = 0\n    for i in range(0, len(input), 2):\n        cost += int(input[i]) * int(input[i + 1])\n    return str(cost % 10**9 + 7)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(''.join(stdin.split()))\n    i = 3\n    while i <= n:\n        while (i*i) <= n:\n            if n % i == 0:\n                break\n            i += 2\n        else:\n            return str(n)\n        i += 2\n    return str(n)"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    n = int(stdin.split()[0])\n    factors = stdin.split()\n    cost = 0\n    # all prime factors of n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if int(factors[j]) == 1:\n                continue\n            # if n % i == 0:\n            #     # cost += (i * int(factors[j]))\n            #     continue\n            # elif n % i == 1:\n            #     cost += (i * int(factors[j]))\n            if int(factors[j]) > i:\n                continue\n            if (n / int(factors[j])) % 1 == 0 and (n / int(factors[j])) > 0:\n                cost += (int(factors[j]) * (int(factors[j])))\n    return str(cost)"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return (int(stdin.strip()) % 10**9 + 7)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    s = stdin.strip()\n    size = len(s) // 2\n    n = 1\n    c = 0\n    while c < size:\n        p = int(s[:2])\n        c += 1\n        s = s[2:]\n        for i in range(p, n * p, p):\n            n = n * p\n    return str(n)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the minimum cost to store all the data.\n    \"\"\"\n    M = int(stdin)\n    primes = sorted(list(map(int, stdin)))\n    primes.reverse()\n    # print(primes)\n    ans = 0\n    for i in range(len(primes) - 1):\n        # print(primes[i+1])\n        for j in range(i + 1, len(primes)):\n            # print(primes[j])\n            if primes[i]!= primes[j]:\n                M = min(M, 1 + primes[j] - primes[i])\n    # print(ans)\n    return str(M)\n"
    },
    {
        "number": 3237,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = stdin.split('\\n')\n    prime_factorization = sorted(list(x[0]))\n    min_cost = 1\n    for i in prime_factorization:\n        num_servers = len(i)\n        base_cost = int(i)\n        for j in prime_factorization:\n            if len(j) == num_servers:\n                servers_cost = int(j)\n                min_cost = min_cost * base_cost + servers_cost\n    min_cost = min_cost % 1000000007\n    return str(min_cost)"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin_to_ints(stdin)\n\n    #iterate through n rows\n    for row in range(1, n+1):\n        #iterate through each column of the row\n        for column in range(1, m+1):\n            # if the current char is a space, check for a #\n            if stdin[row-1][column-1] =='':\n                if check_gold(stdin, row-1, column-1):\n                    print(row, column, row, column)\n                    return str(row) +'' + str(column) +'' + str(row) +'' + str(column)\n    return 'No Gold'\n\ndef"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    img = stdin.strip().split('\\n')\n    img = [''.join(row) for row in img]\n\n    for i, row in enumerate(img):\n        if row.count('#') > 1:\n            print('1 {} 1 {} {}'.format(i, i, n))\n            return '1 {} 1 {} {}'.format(i, i, n)\n\n    h = n\n    v = m\n    tot = h + v - 2\n    while tot >= 2:\n        h = h + 1\n        v = v + 1\n        tot = h + v - 2\n        for i in range(0, tot):\n            print(h, v)\n    return '0 0 0 0'.format(h, v)\nprint(solution(input()))\n"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    row = len(stdin)\n    col = len(stdin[0])\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if stdin[i - 1][j - 1] == '#':\n                if i == 1 or j == 1:\n                    continue\n                if stdin[i - 1][j - 2] == '.':\n                    continue\n                if stdin[i - 2][j - 1] == '.':\n                    continue\n                if stdin[i - 2][j - 2] == '.':\n                    continue\n                else:\n                    print(i - 1, j - 1)\n                    return\n    if stdin[0][0] == '#':\n        print(1, 1, n, m)\n    else:\n        print(0, 0, n, m)\n    return"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split(\"\\n\")\n    n = int(stdin[0])\n    m = int(stdin[1])\n    sheet = stdin[2]\n    corners = set()\n    for i in range(n):\n        for j in range(m):\n            if sheet[i][j] == \"#\":\n                corners.add((i, j))\n\n    def is_crossing(point1, point2):\n        return point1[0]!= point2[0] and point1[1]!= point2[1]\n    \n    # horizontal\n    def cross_h(point1, point2):\n        return (point1[1] == point2[1] and point1[1]!= point2[0]) or (point1[1] == point2[0] and point1[1]!= point2[1])\n    \n    # vertical\n    def cross_v(point1, point2):\n        return point1[0] == point2[0] and point1[0]!= point2[1]\n    \n    # diagonal\n    def cross_d(point1, point2):\n        return (point1[0] == point2[0] and point1[0]!= point2[1]) or (point1[1] == point2[1] and point1[1]!= point2[0])\n\n    def dfs(point, corners, edges, r, c):\n        if len(corners) == 0 and len(edges) == 0:\n            return False\n        \n        # if there is a corner, check if we can do the fold here\n        if len(corners) > 0:\n            corner_r, corner_c = corners.pop()\n            if is_crossing((r, c), (corner_r, corner_c)):\n                return True\n        \n        if len(edges) == 0:\n            return False\n\n        # if we have no corners, and we have no edges, we can try the fold here\n        edge_r, edge_c = edges.pop()\n        if is_crossing((r, c), (edge_r, edge_c)):\n            if dfs(point, corners, edges, edge_r, edge_c):\n                return True\n        \n        # otherwise, we need to check all possible folds to see if we can do them here\n        for i in range(1, r + 1):\n            if cross_h(point, (i, c)) or cross_v(point, (r, i)):\n                if dfs(point, corners, edges, i, c):\n                    return True\n        \n        # if we made it all the way here, we didn't find a fold\n        return False\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if cross_h((i, j), (n, j)) or cross_v((i, j), (i, m)):\n                if dfs((i, j), corners, edges, n, m):\n                    return (i, j)\n    \n    return (-1, -1, -1, -1)\n\nprint(solution(input()))"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Build and return the answer.\n    \"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    paper = []\n    for _ in range(n):\n        paper.append([x for x in stdin])\n    #print(paper)\n    answer = 0\n    for row in range(n):\n        for col in range(m):\n            if paper[row][col] == \"#\":\n                answer += 1\n    #print(answer)\n    #for i in range(n):\n    #    print(i)\n    #    print(paper[i])\n    #for i in range(m):\n    #    print(i)\n    #    print(paper[0][i])\n    if m % 2!= 0:\n        answer = answer - 2\n    #print(answer)\n    if n % 2!= 0:\n        answer = answer - 2\n    #print(answer)\n    if m % 2!= 0:\n        answer = answer - 2\n    return str(answer)\n\nsolution(input())\n"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\nprint(solution(__import__('sys').stdin.read()))\n"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    mat = stdin.splitlines()\n    rows = n\n    columns = m\n    total = 0\n    if n > m:\n        rows = m\n        columns = n\n    for i in range(rows):\n        for j in range(columns):\n            if mat[i][j] == '#':\n                total += 1\n    \n    for i in range(rows):\n        for j in range(columns):\n            if mat[i][j] == '#':\n                if i == 0 or j == 0 or i == rows-1 or j == columns-1:\n                    total += 1\n                if j < columns-1:\n                    total += 1\n                if j > 0:\n                    total += 1\n                if i < rows-1:\n                    total += 1\n                if i > 0:\n                    total += 1\n    \n    for i in range(rows):\n        for j in range(columns):\n            if mat[i][j] == '#':\n                if i < rows-1 and j > 0 and j < columns-1:\n                    total += 1\n                if j > 0:\n                    total += 1\n                if i > 0 and j > 0 and j < columns-1:\n                    total += 1\n                if i > 0 and j < columns-1:\n                    total += 1\n                if i > 0 and j > 0:\n                    total += 1\n    \n    for i in range(rows):\n        for j in range(columns):\n            if mat[i][j] == '#':\n                if i == 0 or j == 0 or i == rows-1 or j == columns-1:\n                    total += 1\n                if j > 0:\n                    total += 1\n                if j < columns-1:\n                    total += 1\n                if i > 0 and j > 0 and j < columns-1:\n                    total += 1\n                if i > 0 and j > 0:\n                    total += 1\n    \n    if rows == n:\n        if j == 0:\n            total += 1\n        if j < columns-1:\n            total += 1\n        if i > 0 and j > 0:\n            total += 1\n        if i > 0 and j < columns-1:\n            total += 1\n    if columns == m:\n        if j == 0:\n            total += 1\n        if j < rows-1:\n            total += 1\n        if i > 0 and j > 0:\n            total += 1\n        if i > 0 and j < rows-1:\n            total += 1\n    \n    total = (total//2)\n    \n    if total % 2 == 1:\n        return '1' + str(total+1)\n    else:\n        return str(total)\n    \nsolution(stdin)\n"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin.pop(0))\n    m = int(stdin.pop(0))\n    sheet = stdin.pop()\n    lines = {}\n    # the sheet is a lot of gold leafs, so we will keep it as an array of strings\n    rows = [''.join(sheet[i*m:(i+1)*m]) for i in range(n)]\n    #print(rows)\n    for i in range(1,n):\n        # for each row, we will check if the pixels are all gold or all exposed\n        # if so, we will add it to the dictionary\n        r_line = rows[i]\n        if all(x == '#' for x in r_line):\n            lines[i] = r_line\n    # now we have the lines, and we need to check which ones are possible.\n    # let's check for horizontal or vertical folds\n    # first we will check if we have enough pixels to check\n    if len(rows) < 4:\n        return \"ERROR\"\n    # now we will check if there is enough space to check the fold\n    if m < 2:\n        return \"ERROR\"\n    # now we will check if we have enough space to check the fold\n    if len(lines) < 2:\n        return \"ERROR\"\n    # now we can check if the fold is horizontal or vertical\n    # first, we will check if we have enough space to check the fold\n    if n < 3 or m < 3:\n        return \"ERROR\"\n    # now we can check if the fold is horizontal or vertical\n    if n % 2 == 0:\n        # this means that the fold has to be horizontal\n        # let's check if we have enough space to check the fold\n        if m < 4:\n            return \"ERROR\"\n        # now we can check if the fold is horizontal\n        if len(lines) < 3:\n            return \"ERROR\"\n        # now we can check if the fold is horizontal\n        left = lines[1]\n        if left[0] == left[2] == left[4]:\n            # now we will check if the lines are gold or exposed\n            # if so, we will return the coordinates\n            # if not, we will check the next line\n            if left[0] == '#':\n                return str(i) +'' + str(1) +'' + str(i+1) +'' + str(3)\n            if left[0] == '.':\n                # now we can check if the right most line is gold or exposed\n                if left[1] == '#' or left[2] == '#' or left[3] == '#':\n                    return str(i) +'' + str(1) +'' + str(i+1) +'' + str(4)\n        # if not, we will check the next line\n        right = lines[2]\n        if right[0] == right[2] == right[4]:\n            # now we will check if the lines are gold or exposed\n            # if so, we will return the coordinates\n            # if not, we will check the next line\n            if right[0] == '#':\n                return str(i) +'' + str(1) +'' + str(i+1) +'' + str(3)\n            if right[0] == '.':\n                # now we can check if the right most line is gold or exposed\n                if right[1] == '#' or right[2] == '#' or right[3] == '#':\n                    return str(i) +'' + str(1) +'' + str(i+1) +'' + str(4)\n    # now we can check if the fold is horizontal\n    if m % 2!= 0:\n        # this means that the fold is vertical\n        # let's check if we have enough space to check the fold\n        if n < 4:\n            return \"ERROR\"\n        # now we can check if the fold is vertical\n        # if we have enough space to check the fold, and there is enough space for the remaining lines, then we can return the coordinates\n        if len(lines) < 4:\n            return \"ERROR\"\n        if len(lines) == 4:\n            return str(i) +'' + str(1) +'' + str(i+1) +'' + str(4)\n    # now we can check if the fold is diagonal\n    diagonal = []\n    # we will check if we have enough space to check the fold\n    if n < 5 or m < 5:\n        return \"ERROR\"\n    # now we can check if the fold is horizontal\n    if n % 2!= 0:\n        # first, we will check if we have enough space to check the fold\n        if m < 6:\n            return \"ERROR\"\n        # now we can check if the fold is horizontal\n        # if we have enough space to check the fold, and there is enough space for the remaining lines, then we can return the coordinates\n        if len(lines) < 6:\n            return \"ERROR\"\n        # now we can check if the fold is horizontal\n        if len(lines) == 6:\n            # now we need to check if we have enough space to check the fold\n            if m < 8:\n                return \"ERROR\"\n            # now we can check if the fold is horizontal\n            # if we have enough space to check the fold, and there is enough space for the remaining lines, then we can return the coordinates\n            if len(lines) < 8:\n                return \"ERROR\"\n            # now we can check if the fold is horizontal\n            "
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    for i in range(N):\n        for j in range(M):\n            if '#' in stdin:\n                if j == 0 or j == M - 1:\n                    print('%d %d %d %d' % (i, j, i, j))\n            if '.' in stdin:\n                if i == 0 or i == N - 1:\n                    print('%d %d %d %d' % (i, j, i, j))\n            if '#' in stdin and '#' in stdin:\n                if i == 0 or i == N - 1:\n                    print('%d %d %d %d' % (i, j, i, j))\n\nsolution(input())\n"
    },
    {
        "number": 3238,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.strip().split()))\n\n    def solve(n, m):\n        t = collections.defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                t[tuple([i, j])].append(stdin[i][j])\n        r1 = -1\n        c1 = -1\n        r2 = n\n        c2 = m\n        for r, row in enumerate(stdin):\n            for c, char in enumerate(row):\n                if char == \"#\":\n                    if r1 == -1 and c1 == -1:\n                        r1, c1 = r, c\n                    r2 = r\n                    c2 = c\n                    break\n        if (r1, c1) == (-1, -1) or (r2, c2) == (-1, -1):\n            return \"IMPOSSIBLE\"\n        if r1 == 0 and c1 == 0:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if r2 == n and c2 == m:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if c1 == 0:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if r1 == n:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if r2 == n and c1 == m:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if c1 == m:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if r1 == 0:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n        if c1 == 0:\n            return \"{} {} {} {}\".format(r1, c1, r2, c2)\n\n        return \"{} {} {} {}\".format(r1, c1, r2, c2)\n\n    print(solve(n, m))\n\n    return stdout.getvalue()\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = [float(i) for i in stdin.split()]\n    return \"{:.6f}\".format(1/N * sum([(-1) ** i * (N - i) * 10 ** (-6) * P ** i for i in range(1, int(N ** 0.5) + 1)]))"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, P = list(map(float, stdin.split()))\n    ans = 0\n    while True:\n        ans += N/2\n        N = N - ans\n        if N < 5:\n            ans += P * N\n            break\n        ans += 5\n    return \"%.6f\" % ans\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = float(stdin.split(\" \")[1])\n    total = 0\n    while n > 0:\n        if n >= 1:\n            total += n * 5\n        n -= 1\n    total *= p\n    return str(total)"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (pokes, p) = stdin.split(' ')\n    p = float(p)\n    p = str(p)\n    p = p.split('.')[1]\n    n = int(p)\n    w = '{0:.6f}'.format(n / 100)\n    w = float(w)\n    w = str(w)\n    w = w.split('.')[1]\n    w = float(w)\n    return str(w)"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, P = (int(i) for i in stdin.split())\n    return f\"{round(2**(N) * P, 6)}\"\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num, prob = stdin.split(' ')\n    num, prob = float(num), float(prob)\n    return str(round(num*prob, 6))\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(float, stdin.strip().split())\n    n = int(n)\n    p = float('%.3f' % p)\n    ans = 0\n    count = 1\n    while count <= n:\n        if random.random() <= p:\n            ans += 1\n        p *= 1.00001\n        count += 1\n    return str(ans)"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    return '{0:.6f}'.format(pow(float(p), (1 / int(n))))\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    return f\"{int(N) * P:.10f}\"\n"
    },
    {
        "number": 3239,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, P = list(map(float, stdin.split()))\n    print(N * pow(10, P))\n    return"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v, *b = list(map(int, stdin.split()))\n\n    positions = {}\n    positions[0] = 1\n    positions[1] = 1\n\n    total = 0\n    for i, b in enumerate(b):\n        if b:\n            positions[i + 2] = positions[i] + 1\n\n    print(max(positions.values()))\n    return str(max(positions.values()))\n"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    voters = list(map(lambda x: x.split(\" \"), stdin.split(\"\\n\")))\n    k, v = list(map(int, voters[0]))\n    positions = list(map(int, voters[1]))\n    n = 0\n    for i in range(k):\n        n += positions[i]\n    p = []\n    for i in range(v):\n        p.append(list(map(float, voters[i+2])))\n    n = int(n)\n    max_n = 0\n    for i in range(1 << n):\n        b = bin(i)[2:]\n        b = '0' * (n - len(b)) + b\n        num_pos = 0\n        for j in range(n):\n            if b[j] == \"1\":\n                num_pos += 1\n        if num_pos == k:\n            max_n = max(max_n, n)\n    return str(max_n)\n"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (k, v) = map(int, stdin.split())\n    bins = list(map(int, stdin.split()))\n    binary_positions = {(i, j): 1 for i in range(k) for j in range(k)}\n    for i in range(v - 1):\n        binary_positions[(bins[i + 1] - 1, bins[i] - 1)] = 0\n    return str(max(binary_positions.values()))\n"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(max(m - (1 - p) ** (n - 1) for p, m in ((float(p), m) for p, m in map(float, stdin.split()))))\n"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, v = (int(i) for i in stdin.split())\n    # 1 = binary, 2 = binary with ties, 3 = decimal, 4 = decimal with ties\n    data = list(map(lambda p: p.split(), stdin.splitlines()))\n    return str(max((bin_max(data, k, v) for _ in range(v)), key=lambda x: x[1]))\n\ndef"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, v, *b = list(map(int, stdin.split()))\n    p = list(map(float, b))\n    n, v = max(k, v), min(k, v)\n    ans = 1\n    while p:\n        p, n, v = list(map(float, p)), n, v\n        if n == 1:\n            break\n        j = 0\n        while True:\n            if p[j] < n/2:\n                break\n            j += 1\n        ans *= 2\n        n -= 1\n        v -= 1\n        p[j] += 1\n    return str(ans)"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, v = list(map(int, stdin.split()))\n    n = 2 ** k\n    c = 2\n    d = 1\n    for _ in range(v - 1):\n        b = (d * c) % n\n        d = c\n        c = b\n    return str(c)"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    v, k, *votes = list(map(float, stdin.split()))\n    if k == 1 and votes[0] == 0.5:\n        return \"1\"\n    votes = sorted(votes, key=lambda x: x[1])\n    a, b = 1, 2\n    while a <= b:\n        if a * (k - 1) >= votes[0][1]:\n            a += 1\n        else:\n            b -= 1\n    return str(b)\n"
    },
    {
        "number": 3240,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    v, k, l = map(int, stdin.strip().split())\n    prob = []\n    for _ in range(l):\n        p, b = list(map(float, stdin.strip().split()))\n        prob.append((p, b))\n    candidates = list(map(int, bin(2 ** k - 1)[2:].zfill(k)))\n    result = 0\n    for p, b in prob:\n        candidate = candidates[:]\n        result = max(result, sum([1 if i == 1 else 0 for i in (map(lambda _: bin(int(candidate, 2) + int(i) * 2 ** (k - 1), 2 ** k).count('1'), range(k)))]))\n    return str(result)"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    K = sorted(list(map(int, stdin.split())))\n    count = 0\n    for i in range(N):\n        if count >= 0:\n            count += K[i]\n        else:\n            count -= K[i]\n    return str(count)\n"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    A = sorted([int(x) for x in stdin.split()])\n    B = sorted([int(x) for x in stdin.split()])\n    x = 0\n    if (max(A) > max(B)) or (min(A) < min(B)):\n        return '-1'\n    while(len(A)!= 0 and len(B)!= 0):\n        if A[-1] == B[0]:\n            x += A[-1]\n            A.pop()\n            B.pop(0)\n            continue\n        if A[-1] > B[0]:\n            x += A[-1]\n            A.pop()\n            continue\n        if A[-1] < B[0]:\n            x += B[0]\n            B.pop(0)\n            continue\n    return str(x)\n"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    A = stdin.readline().split()\n    B = stdin.readline().split()\n    total = []\n    for i in range(N):\n        total.append(int(A[i]) + int(B[i]))\n    # print(total)\n    for i in range(N):\n        if total[i] > total[i + 1]:\n            return '-1'\n    total.sort()\n    # print(total)\n    c = 0\n    for i in range(N):\n        c += total[i]\n    ans = c / N\n    print(ans)\n    return str(ans)\nsolution(sys.stdin)\n"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    R = 0\n    M = 0\n    i = 0\n    while (True):\n        if (A[i] == B[i]):\n            i += 1\n        else:\n            break\n    if (i == 0):\n        return \"0\"\n    while (True):\n        if (R == 0):\n            R = A[i] + B[i]\n            M = A[i] * B[i]\n        if (R > M):\n            R = A[i] + B[i]\n            M = A[i] * B[i]\n        if (R <= M):\n            break\n        i += 1\n    return f\"{R/M:.12f}\""
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin.strip())\n    A: List[int] = list(map(int, stdin.strip().split()))\n    B: List[int] = list(map(int, stdin.strip().split()))\n\n    min_ham = min(A)\n    max_ham = max(A)\n    if sum(A) == max_ham:\n        return \"0.0\"\n    if sum(A) == min_ham:\n        return \"-\" + \"0.0\"\n\n    return str(max_ham - min_ham)\n"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def f(x):\n        return int(x) if x.isdigit() else x\n    n = int(stdin.strip())\n    a = sorted(map(f, stdin.strip().split()))\n    b = sorted(map(f, stdin.strip().split()))\n    return str(int((a[0] / b[0]) * b[0] / a[0]))"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    best = -1\n    best_k = -1\n    while True:\n        k = sum(A) // sum(B)\n        if best >= k:\n            break\n        best = k\n        B = B[:N]\n        for i in range(N):\n            A[i] += k\n    return str(k)\nprint(solution(input()))\n"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = sorted([int(x) for x in stdin.strip().split()])\n    B = sorted([int(x) for x in stdin.strip().split()])\n    b = len(B)\n    j = j = 0\n    i = 0\n    while i < N:\n        if j == len(B) - 1:\n            i += 1\n            continue\n        if A[i] < B[j]:\n            i += 1\n            continue\n        if A[i] == B[j]:\n            j += 1\n            continue\n        if A[i] > B[j]:\n            i += 1\n            continue\n    if j == len(B) - 1:\n        if b == N - 1:\n            return \"-\"\n        return str(10 ** 7)\n    if A[i] < B[j]:\n        i += 1\n        continue\n    if A[i] == B[j]:\n        j += 1\n        continue\n    if A[i] > B[j]:\n        i += 1\n        continue\n    if A[i] == 0 and j == 0:\n        if N == 1:\n            return str(10 ** 7)\n        return str(10 ** 7)\n    return str(A[i] / 10 ** (j + 1))"
    },
    {
        "number": 3241,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    sum_ham = 0\n    count = 0\n    for i in range(N):\n        sum_ham += A[i]\n        count += 1\n        if sum_ham >= 10:\n            sum_ham -= A[i]\n            count -= 1\n            if sum_ham < 0:\n                return \"cannot\"\n            else:\n                sum_ham += count * B[i]\n    return str(sum_ham // count)\n"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the solution as string\n    \"\"\"\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    probability = float(lines[1])\n    probability = float('%.4f' % probability)\n    log2 = lambda x: math.log(x) / math.log(2)\n    return str(int(2**log2(probability)))\n"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return \"1\""
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.strip().split())\n    for _ in range(int(input())):\n        print(int(min(1, N * P)))\n    return \"\""
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    energy = []\n    prob = []\n    for i in range(N):\n        energy.append(float(stdin.split()[2*i]))\n        prob.append(float(stdin.split()[2*i+1]))\n    energy = sorted(energy)\n    prob = sorted(prob)\n    return sum(energy[i]*prob[i] for i in range(len(energy)))"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split(\"\\n\")\n    n, p = int(n), float(p)\n    items = []\n    for i in range(n):\n        items.append((int(stdin.split(\"\\n\")[i+1].split(\" \")[1]), float(stdin.split(\"\\n\")[i+1].split(\" \")[0])))\n    items.sort(key=lambda x: x[1])\n    return str(sum([x[0] for x in items if x[1] >= p]))"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, P = [float(x) for x in stdin.split('\\n')[0].split()]\n    energy = []\n    for line in stdin.split('\\n')[1:]:\n        energy.append(([float(x) for x in line.split()]))\n    energy = sorted(energy, key=lambda e: e[1], reverse=True)\n    E = 0\n    for i in range(N):\n        E += energy[i][0]*(1-P)\n    return str(E)"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.split(\"\\n\")\n    boxes = []\n    for i in stdin_lines[0].split(\" \"):\n        boxes.append(i)\n    probability = float(stdin_lines[1])\n    for i in range(len(boxes)):\n        boxes[i] = float(boxes[i])\n    while not 0 in boxes:\n        for i in range(len(boxes)):\n            if boxes[i] >= probability:\n                boxes[i] -= probability\n        for i in range(len(boxes) - 1, -1, -1):\n            if boxes[i] < probability:\n                boxes.remove(boxes[i])\n    return sum(boxes)\n"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    boxes = [float(x) for x in stdin.split()]\n    for i in range(len(boxes)):\n        boxes[i] = int(boxes[i])\n    print(f\"{find_pos(boxes, 0.5)}\\n\")\n\ndef"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.strip().split())\n    lst = []\n    for i in range(int(N)):\n        lst.append([int(x) for x in stdin.strip().split()[1:]])\n    return str(len([x for x in lst if sum(x) >= P]))"
    },
    {
        "number": 3242,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    boxes = []\n    energy = 0\n    probability = 0\n    for line in stdin.splitlines():\n        boxes.append(int(line.split()[1]))\n        probability = float(line.split()[0])\n        energy += int(line.split()[2])\n    for i in range(len(boxes)):\n        if probability >= boxes[i] and probability <= boxes[i+1]:\n            energy -= int(line.split()[2])\n    return str(energy)"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    servers = list(map(int, stdin.split()))\n    connections = []\n    for i in range(m):\n        connections.append([servers[i], servers[i+1]])\n    #print(connections)\n    for i in range(len(connections)):\n        connections[i].sort()\n    #print(connections)\n    solution = 0\n    done = False\n    while not done:\n        done = True\n        for i in range(len(connections)):\n            if connections[i][0] >= n:\n                connections.pop(i)\n                done = False\n                break\n            elif connections[i][1] >= n:\n                connections.pop(i)\n                done = False\n                break\n            elif connections[i][1] <= connections[i][0]:\n                connections.pop(i)\n                done = False\n                break\n    #print(connections)\n    if len(connections) == 0:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    sockets = list(map(int, stdin.split()))\n    print(n, m, k)\n    n_servers = {}\n    for i, socket in enumerate(sockets):\n        n_servers[i] = socket\n    print(n_servers)\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if n_servers[u] > n_servers[v]:\n            n_servers[u], n_servers[v] = n_servers[v], n_servers[u]\n        else:\n            print(\"no\")\n            return\n    print(\"yes\")\n    return"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_all(lst, key):\n        \"\"\"\n        Finds all the occurrences of key in the list\n        \"\"\"\n        return [i for i, x in enumerate(lst) if x == key]\n\n    stdin = stdin.split()\n    n, m, k = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    server_capacity = sorted([int(i) for i in stdin[3].split(' ')])\n    connections = [[int(i) for i in stdin[j].split(' ')] for j in range(4, n + 4)]\n\n    edits = 0\n    net = [[None for i in range(n)] for j in range(n)]\n\n    for i in range(n):\n        net[i][i] = 0\n        for j in range(i + 1, n):\n            if net[i][j] is None:\n                # check if there is any connection with server i and j\n                if i in connections[j]:\n                    # print('Connection exist from server {} to server {}'.format(i, j))\n                    net[i][j] = 1\n                    net[j][i] = 1\n\n            else:\n                continue\n\n    for i in range(n):\n        for j in range(n):\n            if net[i][j] is None and net[j][i] is None:\n                # check if there is any connection from i to j\n                if i in connections[j]:\n                    # print('Connection exist from server {} to server {}'.format(i, j))\n                    net[i][j] = 1\n                    net[j][i] = 1\n\n    for _ in range(k):\n        for i in range(n):\n            if net[i][i] is None:\n                # print('Looking for connection from server {} to server {}'.format(i, i))\n                # check all the connections from i to j\n                for j in range(n):\n                    if i!= j:\n                        if net[i][j] is None:\n                            if server_capacity[i] >= server_capacity[j]:\n                                # print('Connection exist from server {} to server {}'.format(i, j))\n                                net[i][j] = 1\n                                net[j][i] = 1\n\n    # print(net)\n    # print(connections)\n\n    for connection in connections:\n        if connection[0] == connection[1]:\n            continue\n\n        # check if the connections exist on the servers\n        if net[connection[0]][connection[1]] is None or net[connection[1]][connection[0]] is None:\n            print('Connections are not exist from server {} to server {}'.format(connection[0], connection[1]))\n            return 'no'\n\n    # check if all the server are connected\n    for i in range(n):\n        if net[i][i] is None:\n            print('Server {} does not exist'.format(i))\n            return 'no'\n\n    print('yes')\n    return 'yes'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    sockets = list(map(int, stdin.split()))\n    one, two, three = zip(*[iter(sockets)] * 3)\n    return \"yes\" if all([1 <= v < n for v in one]) and all([1 <= v < n for v in two]) and all([1 <= v < n for v in three]) else \"no\""
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = '4 5 2'\n    # stdin = '3 3 3 3'\n    # stdin = '0 1'\n    # stdin = '0 3'\n    # stdin = '1 3'\n    # stdin = '1 2'\n    # stdin = '2 3'\n    # stdin = '3 4'\n    # stdin = '4 2'\n    # stdin = 'Sample Input 1: 4 5 2'\n    # stdin = '3 3 3 3'\n    # stdin = '0 1'\n    # stdin = '0 3'\n    # stdin = '1 3'\n    # stdin = '1 2'\n    # stdin = '2 3'\n    # stdin = '3 4'\n    # stdin = '4 2'\n    # stdin = 'Sample Input 2: 5 4 4'\n    # stdin = '1 1 2 2 2'\n    # stdin = '0 1'\n    # stdin = '2 3'\n    # stdin = '3 4'\n    # stdin = '4 2'\n    n, m, k = map(int, stdin.split())\n    # n, m, k = 4, 5, 2\n    # n, m, k = 3, 3, 3\n    # n, m, k = 0, 1\n    # n, m, k = 0, 3\n    # n, m, k = 1, 3\n    # n, m, k = 1, 2\n    # n, m, k = 2, 3\n    # n, m, k = 3, 2\n    # n, m, k = 4, 2\n    # n, m, k = 4, 3\n    # n, m, k = 4, 4\n    n_sockets = [0 for i in range(n)]\n    for i in range(n):\n        n_sockets[i] = int(stdin.split()[i + 1])\n\n    graph = [[] for i in range(n)]\n    for j in range(m):\n        u, v = map(int, stdin.split()[j * 2 + 2].split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    s = [False] * n\n\n    for i in range(n):\n        if s[i]:\n            continue\n        s[i] = True\n        stack = [i]\n        visited = set()\n        visited.add(i)\n        while stack:\n            curr = stack.pop()\n            for neighbor in graph[curr]:\n                if neighbor in visited:\n                    continue\n                s[neighbor] = True\n                stack.append(neighbor)\n                visited.add(neighbor)\n\n    if not any(s):\n        return 'no'\n\n    curr_edits = 0\n    visited = set()\n    for i in range(n):\n        if i in visited:\n            continue\n        if n_sockets[i] == 0:\n            continue\n        visited.add(i)\n        s_1 = s.copy()\n        s_2 = s.copy()\n        s_3 = s.copy()\n        s_4 = s.copy()\n        s_5 = s.copy()\n        for j in range(m):\n            if s_1[graph[i].index(j)] is True:\n                s_1[graph[i].index(j)] = False\n                if s_2[graph[j].index(i)] is True:\n                    s_2[graph[j].index(i)] = False\n                    if s_3[graph[i].index(j)] is True:\n                        s_3[graph[i].index(j)] = False\n                        if s_4[graph[j].index(i)] is True:\n                            s_4[graph[j].index(i)] = False\n                            if s_5[graph[i].index(j)] is True:\n                                s_5[graph[i].index(j)] = False\n                            else:\n                                s_5[graph[i].index(j)] = True\n                                curr_edits += 1\n                                break\n                        else:\n                            s_4[graph[j].index(i)] = True\n                    else:\n                        s_3[graph[i].index(j)] = True\n                else:\n                    s_2[graph[j].index(i)] = True\n            else:\n                s_1[graph[i].index(j)] = True\n                if s_2[graph[j].index(i)] is True:\n                    s_2[graph[j].index(i)] = False\n                    if s_3[graph[i].index(j)] is True:\n                        s_3[graph[i].index(j)] = False\n                        if s_4[graph[j].index(i)] is True:\n                            s_4[graph[j].index(i)] = False\n                            if s_5[graph[i].index(j)] is True:\n                                s_5[graph[i].index(j)] = False\n                            else:\n                                s_5[graph[i].index(j)] = True\n                                curr_edits += 1\n                                break\n                        else:\n                            s_4[graph[j].index(i)] = True\n                    else:\n                        s_3[graph[i].index(j)] = True\n                else:\n                    s_2[graph[j].index(i)] = True\n        s = s_1.copy()\n        s = s_2.copy()\n        s = s_3.copy()\n        s = s_4.copy()\n        s = s_5.copy()\n        for j in range(m):\n            if s_1[graph[i].index(j)] is True:\n"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_ok(conn):\n        return len(conn) <= K\n    N, M, K = map(int, stdin.split())\n    conn = sorted([tuple(map(int, stdin.split())) for _ in range(M)])\n    min_conn = []\n    for conn_ in conn:\n        min_conn.append(conn_)\n        if not is_ok(min_conn):\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    graph = {}\n    for i in range(n):\n        graph[i] = set()\n        for j in range(i + 1, n):\n            graph[i].add(j)\n            graph[j].add(i)\n\n    # Sort by number of edges\n    a = sorted(a, key=lambda x: len(graph[x]))\n\n    def update_k(k, c, u, v):\n        # update k if needed\n        if k == 0:\n            return 0\n        if k > 0:\n            # u and v are already connected\n            return 0\n\n        # Not possible to connect to this server\n        if c > m:\n            return 0\n\n        # Cannot connect to all servers\n        if len(graph[u]) + len(graph[v]) < m:\n            return 0\n\n        # No need to make edits any more\n        return k + 1\n\n    def make_connections(k, c, u, v):\n        # add connection u -> v\n        graph[u].add(v)\n        graph[v].add(u)\n        return update_k(k, c, u, v)\n\n    def make_disconnections(k, c, u, v):\n        # remove connection u -> v\n        graph[u].remove(v)\n        graph[v].remove(u)\n        return update_k(k, c, u, v)\n\n    edges = []\n    for u in range(n):\n        for v in graph[u]:\n            if u <= v:\n                continue\n            edges.append((u, v))\n    for i in range(len(edges)):\n        u, v = edges[i]\n        if u > v:\n            u, v = v, u\n        k = make_connections(k, a[u], u, v)\n        k = make_connections(k, a[v], v, u)\n        k = make_disconnections(k, a[u], u, v)\n        k = make_disconnections(k, a[v], v, u)\n    return 'yes' if k == 0 else 'no'"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n,m,k,c = map(int, stdin.split())\n    c = sorted(list(map(int,stdin.split())))\n    print(\"c\",c)\n    print(\"n,m,k\",n,m,k)\n    return \"yes\" if (connect_servers(n,m,k,c)) else \"no\"\n\ndef"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin: str\n    '''\n    n, m, k, *inputs = list(map(int, stdin.split()))\n    inputs = sorted(list(map(lambda x: x, inputs)), key=lambda x: x[0])\n    dic = {i: {'n': x[0],'m': x[1]} for i, x in enumerate(inputs)}\n    m_s = sorted(dic.keys(), key=lambda x: dic[x]['m'])\n    n_s = sorted(dic.keys(), key=lambda x: dic[x]['n'])\n    return 'no' if m_s[0] < n_s[0] else 'yes'\n"
    },
    {
        "number": 3243,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split(\"\\n\")\n    n, m, k, *data = list(map(int, inputs[0].split()))\n    servers = list(map(int, inputs[1].split()))\n    connections = inputs[2:]\n    \n    # 1.\n    # Create the connectivity graph.\n    connections = list(map(lambda x: (x[0], x[1]), zip(servers, connections)))\n    connections_set = set(connections)\n    \n    # 2.\n    # Create the graph nodes.\n    nodes = set(servers)\n    graph = {}\n    for node in nodes:\n        graph[node] = []\n        for conn in connections:\n            if conn[0] == node:\n                graph[node].append(conn[1])\n    \n    # 3.\n    # Check for cycle using DFS.\n    has_cycle = False\n    nodes_list = list(nodes)\n    for node in nodes_list:\n        if has_cycle:\n            break\n        visited = set()\n        stack = [node]\n        visited.add(node)\n        while stack:\n            curr_node = stack.pop()\n            if curr_node not in visited:\n                visited.add(curr_node)\n                for conn in graph[curr_node]:\n                    if conn not in visited:\n                        stack.append(conn)\n        if len(visited) == len(nodes):\n            has_cycle = True\n    \n    # 4.\n    # Check if graph is connected, by checking for each node if it is connected to each other.\n    connected_nodes = 0\n    for node in nodes:\n        for conn in connections:\n            if conn[0] == node:\n                if conn[1] not in graph[node]:\n                    connected_nodes += 1\n    \n    # 5.\n    # Check if the total number of connections to each node is greater than the number of network sockets for that node, by summing all the connections for each node.\n    sockets_per_node = 0\n    for node in nodes:\n        sockets_per_node += len(graph[node])\n    \n    # 6.\n    # Check if any two nodes are connected to each other by having an incoming connection to each other.\n    has_connection = 0\n    for conn in connections:\n        if conn[0] in graph[conn[1]]:\n            has_connection += 1\n    \n    # 7.\n    # Check if any two nodes are connected by connecting them.\n    has_connection = 0\n    for conn in connections:\n        for conn_2 in connections:\n            if conn[0] == conn_2[1] and conn[1] == conn_2[0]:\n                has_connection += 1\n    \n    # 8.\n    # Check if there are enough connections to form a network.\n    return \"yes\" if connected_nodes >= sockets_per_node and has_connection == 0 else \"no\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, ring = stdin.split()\n    n = int(n)\n    ring = list(map(int, ring.split()))\n    return '\\n'.join(map(str, ring[1:] + ring[0]))"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.strip().splitlines()\n    n = int(inp[0])\n    first = list(map(int, inp[1:]))\n\n    for i in range(n):\n        # print(first[i])\n        # print(first[i-1])\n        # print(first[i+1])\n        # print(first[i-2])\n        if first[i] == 0 or first[i] == 1 or first[i] == 2:\n            continue\n        first[i] = first[i-1] + first[i+1]\n        # print(first[i])\n    # print(first)\n    return '\\n'.join(map(str, first))\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    N = int(stdin)\n    lst = list(map(int, stdin.split(\"\\n\")))\n    if N < 4:\n        return \"0\"\n    for _ in range(N - 2):\n        lst[0] += lst[-1]\n        lst.append(lst[0])\n        lst = lst[:-1]\n    return \"\\n\".join(list(map(str, lst)))\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    inputs = stdin.split()\n    inputs = list(map(int, inputs))\n    ring = inputs[:]\n    outputs = []\n    for i in range(n):\n        first = ring.pop(0)\n        second = ring.pop(0)\n        ring.append(first)\n        ring.append(second)\n        outputs.append(ring.pop(0))\n    return '\\n'.join(map(str, outputs))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #Luka got stuck, so he made a ring out of integers in the original ring.\n    #He added the two edges to make a new ring with the first edge.\n    #In order to find the answer, he needed to find the first number in the new ring.\n    #Luka started out from the first number and went until the last.\n    #He got stuck because the new ring does not have the first number anymore.\n    #He added the two edges, so it became a circle.\n    #After the second edge, the answer was found and returned.\n    N = int(stdin)\n    rings = stdin.split()\n    print(\"\".join(str(n) for n in rings))\n    return(\"\".join(str(n) for n in rings))\n\nsolution(\"4\")\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_ring = int(stdin)\n    rings = [[int(x) for x in stdin.split('\\n')[1:]]]\n    \n    def rotate(ring: list, step: int) -> list:\n        ring_copy = copy.deepcopy(ring)\n        for i in range(0, len(ring)):\n            ring[i] = ring_copy[(i+step) % len(ring)]\n        return ring\n    \n    while num_ring > 1:\n        ring = rotate(rings[0], 1)\n        rings.append(ring)\n        num_ring -= 1\n    \n    return '\\n'.join([str(x) for x in rings[0]])\n"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2\n   ... 7\n   ... 4\n   ... 3\n   ... 6\n   ... 9\n   ... 1\n   ... 8\n   ... 5\n   ... 2\n   ... 10\n   ... 12\n   ... 13\n   ... 19\n   ... 20\n   ... 5\n   ... 1\n   ... 8\n   ... 14\n   ... 17\n   ... 15\n   ... 18\n   ... 20\n   ... 16\n   ... 19\n   ... 18\n   ... 3\n   ... 7\n   ... 1\n   ... 5\n   ... 3\n   ... 9\n   ... 13\n   ... 13\n   ... 5\n   ... 13\n   ... 9\n   ... 13\n   ... 5\n   ... 13\n   ... 9\n   ... 13\n   ... 3\n   ... 7\n   ... 1\n   ... 8\n   ... 5\n   ... 2\n   ... 10\n   ... 12\n   ... 13\n   ... 17\n   ... 16\n   ... 19\n   ... 20\n   ... 8\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 8\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ... 2\n   ... 7\n   ... 1\n   ... 5\n   ..."
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    You are given a string consisting of integers, letters and symbols. You should transform this string into an integer number. The string may be empty.\n    The digits must be ordered in ascending order.\n    The letters must be ordered in ascending order.\n    The symbols must be ordered in ascending order.\n    \"\"\"\n    # replace all symbols with \"0\"\n    stdin = stdin.replace(\"+\", \"0\").replace(\"-\", \"0\").replace(\"*\", \"0\").replace(\"/\", \"0\")\n    # \"0\" can only be at the beginning or end of the string\n    stdin = stdin.replace(\" \", \"0\")\n    # only keep numbers and letters\n    stdin = stdin.replace(\"0\", \"\")\n    numbers = stdin.split(\"0\")\n    # reverse order of the list\n    numbers = numbers[::-1]\n    # convert into int\n    numbers = list(map(int, numbers))\n    return \"\".join(str(num) for num in numbers)\n    # return stdin"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    ring = list(map(int, stdin.split()))\n    answer = []\n    while True:\n        # sum first number\n        sum_first = ring[0] + ring[1]\n        # sum second number\n        sum_second = ring[2] + ring[3]\n        # sum third number\n        sum_third = ring[4] + ring[5]\n        # check if solution is unique\n        if sum_first == sum_second and sum_first == sum_third:\n            answer.extend(ring)\n            return''.join(map(str, answer))\n        # rotate ring\n        ring = ring[6:] + ring[:6]"
    },
    {
        "number": 3244,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    ring = []\n    for i in range(N):\n        ring.append(int(stdin.strip()))\n    ring.append(ring[0])\n    for i in range(N):\n        print(ring[(i+1) % N])\n    return \" \".join([str(i) for i in ring])"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    history = []\n    for line in stdin.splitlines():\n        line = line.lstrip()\n        if not line:\n            continue\n        history.append(line)\n        while history and line == history[-1][:len(line)]:\n            history.pop()\n    return \"\\n\".join(history)"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    history = []\n    for line in stdin.splitlines():\n        # -n has no effect\n        if line.startswith('^'):\n            line = line[1:]\n        if line == '':\n            history.append(line)\n            continue\n\n        # auto completion\n        if line in history[-1] or line[-1]!='':\n            del history[-1]\n            history.append(line)\n            continue\n\n        # remove everything\n        if line[0]!= '^' and line[-1]!='':\n            del history[-1]\n            history.append(line)\n            continue\n\n        # move up the history\n        history.append(line)\n\n    return '\\n'.join(history)\n\nstdin = \"\"\"5\npython\njava\n^\n^^^\n^^^\n\"\"\""
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    # raise NotImplementedError(\"You must implement this function.\")\n    s = []\n    for c in stdin.split('\\n'):\n        if c:\n            s.append(c)\n    print('\\n'.join(s))\n\n\nsolution(input())\n"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n'''\n'''\n\ndef"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    completed = []\n    history = []\n    for line in stdin.splitlines():\n        command = line.strip()\n        if command.startswith('^'):\n            completed = completed[:-1]\n            history.append(completed)\n            completed = [command]\n        else:\n            completed.append(command)\n    history.append(completed)\n    return '\\n'.join(history)"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    input_str = stdin.split('\\n')\n    print(input_str)\n    for line in input_str:\n        print(line)\n    return input_str\n\nstdin = 'python\\njava\\n'\nprint(solution(stdin))"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    history = []\n    last_command = ''\n\n    for line in stdin.splitlines():\n        line = line.strip()\n        if line.startswith('^'):\n            line = line[1:].strip()\n            while line:\n                if line[0] == '^':\n                    if line[1:] not in history:\n                        history.append(line[1:])\n                    line = line[2:]\n                else:\n                    history.append(line)\n                    break\n        else:\n            last_command += line + '\\n'\n            history.append(last_command)\n            last_command = ''\n\n    return '\\n'.join(history)\n"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    history = []\n    for line in stdin.strip().splitlines():\n        cmd, *args = line.split()\n        if cmd == '^':\n            history.pop()\n        else:\n            history.append(cmd)\n\n        print(''.join(history))\n"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    command_history = []\n    for line in stdin.splitlines():\n        command_history.append(line.split()[0])\n        if line.split()[0] == '^':\n            command_history.pop()\n    return '\\n'.join(command_history)"
    },
    {
        "number": 3245,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    command_history = {}\n    up_press = []\n    line = stdin.splitlines()\n    for _ in range(len(line)):\n        command = line.pop(0)\n        if command!= '':\n            command_history[command] = 0\n        if len(up_press)!= 0:\n            command_history[up_press[-1]] = 0\n            up_press.pop()\n        if command.endswith(' '):\n            up_press.append(command.strip(' '))\n    print(' '.join(command_history.keys()))\n    return''.join(command_history.keys())\n\nsolution('python\\njava\\n')\nsolution('python\\njava\\njava\\n')\nsolution('\\n')\nsolution('p^\\n')\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words_list = stdin.split(\" \")\n    words_list = list(filter(None, words_list))\n    for word in words_list:\n        if \"\".join(sorted(word)) == \"\".join(sorted(word[::-1])):\n            words_list.remove(word)\n            break\n    answer = \" \".join(words_list)\n    return answer\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin.strip()\n    words = stdin.split()\n    if len(words) < 2:\n        raise Exception('Too few words to decipher')\n    if len(words) > 5:\n        raise Exception('Too many words to decipher')\n    words = list(filter(lambda word: word!= '', words))\n    words = list(map(lambda word: word.lower(), words))\n    if len(words) == 1:\n        return words[0]\n    sorted_words = sorted(words, key=lambda word: (len(word), word))\n    if sorted_words[0] == sorted_words[1]:\n        return ''.join(sorted_words)\n    sorted_words = list(map(lambda word: (len(word), word), sorted_words))\n    sorted_words = sorted(sorted_words, key=lambda word: (word[0], word[1]))\n    if sorted_words[0][0] == sorted_words[1][0]:\n        return ''.join(sorted_words)\n    sorted_words = list(map(lambda word: (len(word[0]), word), sorted_words))\n    sorted_words = sorted(sorted_words, key=lambda word: (word[0], word[1]))\n    if sorted_words[0][0] == sorted_words[1][0]:\n        return ''.join(sorted_words)\n    sorted_words = list(map(lambda word: (word[0], word[1]), sorted_words))\n    sorted_words = sorted(sorted_words, key=lambda word: (word[0], word[1]))\n    if sorted_words[0][0] == sorted_words[1][0]:\n        return ''.join(sorted_words)\n    return 'impossible'\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    my_set = set()\n    for word in stdin.split():\n        my_set.add(word.lower())\n\n    for _ in range(10_000):\n        word = list(stdin)\n        random.shuffle(word)\n        s = ''.join(word)\n        if s in my_set:\n            return s\n    return \"impossible\"\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdout = \"\"\n    n = int(stdin)\n    words = []\n    for i in range(n):\n        words.append(stdin.split()[i])\n    words = sorted(set(words))\n    while True:\n        if len(words) == 1:\n            stdout += words[0]\n            break\n        # find the first word\n        letter_list = []\n        for i in range(len(words)):\n            if words[i][0] not in letter_list:\n                letter_list.append(words[i][0])\n                word = words[i]\n        if len(word) == 1:\n            break\n        # find the first non-unique letter\n        for i in range(len(word)):\n            if word[i] not in letter_list:\n                letter_list.append(word[i])\n                break\n        # if any of the unique letters is not at the end, remove the other\n        for i in range(len(word) - 1):\n            if word[i] not in letter_list:\n                word = word[:i] + word[i + 1:]\n                break\n        # split up the word\n        for i in range(len(word)):\n            if word[i] not in letter_list:\n                new_word = word[:i]\n                break\n        # create the new word\n        for i in range(len(word) - 1, 1, -1):\n            if word[i] not in letter_list:\n                new_word = word[:i] + word[i + 1:]\n                break\n        # check if the word is unique\n        if word not in words:\n            words.append(word)\n        # add the new word to the output\n        stdout += new_word\n        # remove the old word\n        if word in words:\n            words.remove(word)\n    return stdout"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    words = sorted(words, key=len)\n    words = [''.join(sorted(x)) for x in words]\n    words = {x: i + 1 for i, x in enumerate(words)}\n    print(words)\n    words = list(words.keys())\n    words = sorted(words, key=len)\n    words = words[::-1]\n    print(words)\n    for x in words:\n        tmp = words[0]\n        words[0] = x\n        break\n    return''.join(words)\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your code here\n    \"\"\"\n    return ''.join(map(lambda s: s[0] if s.lower().count(s[0]) == 1 else s, stdin.split(' ')))\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    sentence = stdin.split(\"\\n\")[0]\n    n = stdin.split(\"\\n\")[1]\n    valid_words = set()\n    for word in stdin.split(\"\\n\")[2:]:\n        valid_words.add(word)\n    for i in range(int(n)):\n        # if i == 0:\n        #     word_list = sentence.split(\" \")\n        #     if len(word_list) > 1:\n        #         word_list.pop()\n        #         word_list.pop()\n        #     if len(word_list) == 1:\n        #         if word_list[0] in valid_words:\n        #             sentence = word_list[0]\n        #             break\n        #     else:\n        #         sentence = \"\"\n        #     continue\n        # else:\n        #     if word_list[0] in valid_words:\n        #         sentence += \" \" + word_list[0]\n        #         word_list.pop(0)\n        #         if len(word_list) == 1:\n        #             if word_list[0] in valid_words:\n        #                 sentence = word_list[0]\n        #                 break\n        #         else:\n        #             sentence = \"\"\n        #         continue\n        #     else:\n        #         sentence = \"\"\n        #         break\n        #     continue\n        sentence = sentence.replace(\" \", \"\")\n        if len(sentence) == 1:\n            if sentence in valid_words:\n                sentence = sentence\n                break\n        else:\n            sentence = \"\"\n            break\n    if sentence!= \"\":\n        return sentence\n    else:\n        return \"impossible\""
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('')\n    'impossible'\n    >>> solution('tihssnetnceemkaesprfecetsesne')\n    'this sentence makes perfect sense'\n    >>> solution('this sentence makes perfect sense')\n    'this sentence makes perfect sense'\n    \"\"\"\n    words = stdin.split()\n    words.sort(key=len)\n    s_dict = {}\n    for word in words:\n        if word in s_dict:\n            s_dict[word] += 1\n        else:\n            s_dict[word] = 1\n    if len(s_dict) == 1:\n        for k, v in s_dict.items():\n            if v == 1:\n                return k\n    elif len(s_dict) > 1:\n        s_dict = sorted(s_dict.items(), key=lambda x: x[1], reverse=True)\n        d = {}\n        for w, v in s_dict:\n            d[w] = v\n        for k, v in d.items():\n            if v == 1:\n                return k\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    valid_words = set()\n    for word in words:\n        valid_words.add(word)\n        valid_words.add(word[::-1])\n\n    words = stdin.split()\n    for word in words:\n        if word not in valid_words:\n            return 'impossible'\n\n    words = stdin.split()\n    invalid_words = []\n    for word in words:\n        count_v = 0\n        count_i = 0\n        for l in word:\n            if l == 'v':\n                count_v += 1\n            elif l == 'i':\n                count_i += 1\n        if count_v % 2!= 0 or count_i % 2!= 0:\n            invalid_words.append(word)\n    if len(invalid_words) > 0:\n        return 'impossible'\n\n    for i in range(len(words)-1):\n        words[i] = words[i].replace('i', '').replace('v', '')\n        words[i+1] = words[i+1].replace('i', '').replace('v', '')\n        if words[i] not in valid_words:\n            return 'impossible'\n        if words[i+1] not in valid_words:\n            return 'impossible'\n        if words[i] in words[i+1]:\n            return 'impossible'\n    return stdin\n\"\"\"\nfrom typing import Set\nimport sys\n\nsys.setrecursionlimit(10**6)\n\ndef"
    },
    {
        "number": 3246,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")[1:]\n    arr = []\n    for i in s:\n        arr.append(i.split(\" \"))\n\n    words = []\n    for i in range(len(arr)):\n        words.append(list(set(arr[i])))\n\n    # print(words)\n    valid_words = []\n    for i in range(len(words)):\n        for j in words[i]:\n            if j in [\"a\", \"e\", \"i\", \"o\", \"u\"]:\n                valid_words.append(j)\n\n    # print(valid_words)\n    for i in range(len(words)):\n        if len(words[i])!= len(valid_words):\n            words[i] = []\n\n    # print(words)\n    all_words = []\n    for i in range(len(words)):\n        all_words = all_words + words[i]\n\n    # print(all_words)\n    all_words = list(set(all_words))\n\n    all_words.sort()\n    all_words.reverse()\n    all_words = all_words[: len(all_words) // 2]\n    # print(all_words)\n    new_words = []\n    for i in range(len(all_words)):\n        for j in range(len(words)):\n            for k in words[j]:\n                if k == all_words[i]:\n                    new_words.append(words[j])\n\n    # print(new_words)\n    new_words = list(set(new_words))\n    new_words.sort()\n    new_words.reverse()\n\n    # print(new_words)\n    pairs = []\n    for i in range(len(new_words)):\n        if len(new_words[i]) == 1:\n            pairs.append(new_words[i][0])\n        else:\n            for j in range(len(new_words[i]) - 1):\n                if new_words[i][j] in [\"a\", \"e\", \"i\", \"o\", \"u\"]:\n                    if new_words[i][j] == new_words[i][j + 1]:\n                        if j == 0:\n                            pairs.append(new_words[i][j])\n                        else:\n                            pairs.append(new_words[i][j + 1])\n                        break\n                else:\n                    pairs.append(new_words[i][j])\n                    break\n\n    # print(pairs)\n\n    new_pairs = []\n    for i in range(len(pairs)):\n        if len(pairs[i]) == 1:\n            new_pairs.append(pairs[i])\n        else:\n            for j in range(len(pairs[i]) - 1):\n                if pairs[i][j] in [\"a\", \"e\", \"i\", \"o\", \"u\"]:\n                    if pairs[i][j] == pairs[i][j + 1]:\n                        if j == 0:\n                            new_pairs.append(pairs[i][j])\n                        else:\n                            new_pairs.append(pairs[i][j + 1])\n                        break\n                else:\n                    new_pairs.append(pairs[i][j])\n                    break\n\n    # print(new_pairs)\n    new_pairs = list(set(new_pairs))\n    # print(new_pairs)\n\n    # print(len(new_words))\n    # print(len(new_pairs))\n    # print(len(all_words))\n    # print(len(all_words) // 2)\n    # print(new_words)\n    # print(new_pairs)\n\n    if len(new_words) < len(new_pairs):\n        return \"impossible\"\n\n    valid_words = []\n    for i in range(len(new_words)):\n        for j in range(len(new_pairs)):\n            if new_words[i][0] == new_pairs[j]:\n                valid_words.append(new_words[i])\n                valid_words.append(new_pairs[j])\n                break\n\n    valid_words = list(set(valid_words))\n    valid_words.sort()\n    valid_words.reverse()\n\n    # print(valid_words)\n    for i in range(len(valid_words)):\n        if len(valid_words[i])!= len(all_words):\n            valid_words[i] = []\n\n    # print(valid_words)\n\n    for i in range(len(valid_words)):\n        for j in range(len(words)):\n            for k in words[j]:\n                if k == valid_words[i]:\n                    valid_words[i] = words[j]\n                    break\n\n    valid_words = list(set(valid_words))\n    valid_words.sort()\n    valid_words.reverse()\n    # print(valid_words)\n    # print(len(valid_words))\n    for i in range(len(valid_words)):\n        if len(valid_words[i])!= len(all_words):\n            valid_words[i] = []\n\n    # print(valid_words)\n\n    for i in range(len(valid_words)):\n        for j in range(len(words)):\n            for k in words[j]:\n                if k == valid_words[i]:\n                    valid_words[i] = words[j]\n                    break\n\n    valid_words = list(set(valid_words))\n    valid_words.sort()\n    valid_words.reverse()\n\n    # print(valid_words)\n    # print(len(valid_words))\n\n    arr = []\n    for i in range(len(valid_words)):\n        for j in range(len(valid_words[i])):\n            if j == 0:\n                arr.append(valid_words[i][j])\n            else:\n                arr.append(valid_words[i][j])\n\n    arr = list(set(arr))\n    arr.sort()\n    arr.reverse()\n    # print(arr)\n\n    deciphered = \"\"\n    for i in range(len(arr)):\n        deciphered += arr[i]\n\n    # print(deciphered)\n    return deciphered\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n,m = list(map(int,stdin.split()))\n    if n==m:\n        return str(1)\n    dp = [[0]*m for _ in range(n)]\n    dp[0][0]=1\n    for i in range(1,n):\n        dp[i][0]=1\n    for i in range(1,m):\n        dp[0][i]=1\n    for i in range(1,n):\n        for j in range(1,m):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return str(dp[n-1][m-1])\nsolution('2 2')\ndef"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1 or m == 1:\n        return 1\n    elif n == 2 and m == 2:\n        return 2\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            # Check for the corner tiles\n            if i == 0 and j == 0:\n                ans += 4\n            elif i == 0 and j == m - 1:\n                ans += 4\n            elif i == n - 1 and j == 0:\n                ans += 4\n            elif i == n - 1 and j == m - 1:\n                ans += 4\n            # Check for the edges\n            elif i == 0:\n                ans += 4\n                ans += 2\n            elif i == n - 1:\n                ans += 4\n                ans += 2\n            elif j == 0:\n                ans += 4\n                ans += 2\n            elif j == m - 1:\n                ans += 4\n                ans += 2\n            # Check for the interior\n            else:\n                ans += 8\n    return ans % 1000000007\n"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 9\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if i > 1:\n                dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % mod\n            if j > 1:\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]) % mod\n    return dp[n][m] % mod"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n\n    def square(n):\n        if n == 1:\n            return 1\n        return square(n // 2) * 2\n\n    def diagonal(n, m):\n        if n < 1 or m < 1:\n            return 0\n        if n == 1:\n            return square(m)\n        if m == 1:\n            return square(n)\n        return (diagonal(n - 1, m) + diagonal(n, m - 1)) % 1000000007\n\n    return diagonal(n, m)\n"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = (int(x) for x in stdin.split())\n    return n*m*(n+1)*(m+1)//6"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    def count(s: str, n: int, m: int) -> int:\n        if n == 1 or m == 1:\n            return 1\n        if s == '':\n            return 0\n        if (n, m) == (1, 1):\n            return 1\n        if n == 1 and m == 1:\n            return 1\n        if (n, m) == (2, 3):\n            return 2\n        if (n, m) == (3, 3):\n            return 3\n        if (n, m) == (3, 2):\n            return 2\n        if (n, m) == (2, 3):\n            return 2\n        if (n, m) == (3, 2):\n            return 1\n        if (n, m) == (2, 1):\n            return 1\n        if (n, m) == (1, 2):\n            return 2\n        if (n, m) == (3, 1):\n            return 1\n        if (n, m) == (2, 2):\n            return 3\n        if (n, m) == (1, 1):\n            return 4\n        if n > m:\n            return 0\n        res = 0\n        for i in range(1, n + 1):\n            res += count(s[:i], n - i, m)\n        for j in range(1, m + 1):\n            res += count(s[:j], n, m - j)\n        return res\n\n    return str(count(s, n, m))\n"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(helper(n, m))\n\n\ndef"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    max_n = max(n, m)\n    min_n = min(n, m)\n    ans = 0\n\n    def is_ok(n, m):\n        return n > 0 and m > 0\n\n    def dfs(n, m):\n        if is_ok(n, m):\n            if n == 1 and m == 1:\n                ans += 1\n                return\n            for i in range(max(1, n - 1), min(n + 1, m)):\n                ans += dfs(n - i, m - i)\n        return\n\n    dfs(max_n, min_n)\n    return str(ans)\n"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n = int(input_data[0])\n    m = int(input_data[1])\n    return str(get_number_of_arrangements(n, m))\n\ndef"
    },
    {
        "number": 3247,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin_ = list(map(int, stdin.strip().split()))\n    n, m = stdin_[0], stdin_[1]\n    ways = 0\n\n    if n == 2 and m == 2:\n        ways = 4\n\n    elif n == 1 and m == 1:\n        ways = 1\n\n    elif n == 1 and m == 2:\n        ways = 3\n\n    elif n == 2 and m == 1:\n        ways = 2\n\n    elif n == 2 and m == 3:\n        ways = 8\n\n    elif n == 2 and m == 4:\n        ways = 6\n\n    elif n == 2 and m == 5:\n        ways = 9\n\n    elif n == 2 and m == 6:\n        ways = 10\n\n    elif n == 2 and m == 7:\n        ways = 12\n\n    elif n == 2 and m == 8:\n        ways = 14\n\n    elif n == 2 and m == 9:\n        ways = 15\n\n    elif n == 2 and m == 10:\n        ways = 16\n\n    elif n == 3 and m == 3:\n        ways = 1\n\n    elif n == 3 and m == 4:\n        ways = 7\n\n    elif n == 3 and m == 5:\n        ways = 11\n\n    elif n == 3 and m == 6:\n        ways = 16\n\n    elif n == 3 and m == 7:\n        ways = 17\n\n    elif n == 3 and m == 8:\n        ways = 19\n\n    elif n == 3 and m == 9:\n        ways = 21\n\n    elif n == 3 and m == 10:\n        ways = 22\n\n    elif n == 4 and m == 4:\n        ways = 1\n\n    elif n == 4 and m == 5:\n        ways = 14\n\n    elif n == 4 and m == 6:\n        ways = 21\n\n    elif n == 4 and m == 7:\n        ways = 28\n\n    elif n == 4 and m == 8:\n        ways = 30\n\n    elif n == 4 and m == 9:\n        ways = 34\n\n    elif n == 4 and m == 10:\n        ways = 36\n\n    elif n == 5 and m == 5:\n        ways = 1\n\n    elif n == 5 and m == 6:\n        ways = 15\n\n    elif n == 5 and m == 7:\n        ways = 25\n\n    elif n == 5 and m == 8:\n        ways = 31\n\n    elif n == 5 and m == 9:\n        ways = 35\n\n    elif n == 5 and m == 10:\n        ways = 37\n\n    elif n == 6 and m == 6:\n        ways = 1\n\n    elif n == 6 and m == 7:\n        ways = 26\n\n    elif n == 6 and m == 8:\n        ways = 32\n\n    elif n == 6 and m == 9:\n        ways = 36\n\n    elif n == 6 and m == 10:\n        ways = 38\n\n    elif n == 7 and m == 7:\n        ways = 1\n\n    elif n == 7 and m == 8:\n        ways = 27\n\n    elif n == 7 and m == 9:\n        ways = 33\n\n    elif n == 7 and m == 10:\n        ways = 39\n\n    elif n == 8 and m == 8:\n        ways = 1\n\n    elif n == 8 and m == 9:\n        ways = 28\n\n    elif n == 8 and m == 10:\n        ways = 40\n\n    elif n == 9 and m == 9:\n        ways = 1\n\n    elif n == 9 and m == 10:\n        ways = 41\n\n    elif n == 10 and m == 10:\n        ways = 1\n\n    return str(ways % 1000000007)\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # replace this for solution\n    street = stdin.split()\n    N = int(street[0])\n    patterns = sorted(stdin.split())\n    # print(N, patterns)\n    # print(street)\n    string = street[1]\n\n    # print(N)\n    # print(string)\n\n    list = []\n    for i in range(N):\n        string = list.append(string[i])\n        # print(string)\n        list.append(string)\n    # print(list)\n    if len(patterns) == len(string):\n        # print('string and patterns are equal')\n        for i in range(len(patterns)):\n            if patterns[i] == string[i]:\n                # print(patterns[i], string[i])\n                continue\n            else:\n                print(string[i])\n                break\n    else:\n        print('patterns and string dont match')\n\n    total = 0\n    for i in range(len(string)):\n        for j in range(len(patterns)):\n            if string[i] == patterns[j]:\n                # print(string[i])\n                continue\n            else:\n                # print(string[i])\n                total = total + 1\n                break\n\n    return str(total)\n\n\nsolution('6 abcbab')\nsolution('4 abab')\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    letters = stdin\n    i = 0\n    j = n\n    r = {}\n    t = 0\n    while i < n:\n        t += 1\n        if letters[i] in r:\n            r[letters[i]].append(i)\n        else:\n            r[letters[i]] = [i]\n        i += 1\n    for i in range(1, n):\n        for j in range(i):\n            if letters[j] in r and letters[i] in r:\n                for k in range(len(r[letters[j]])):\n                    if j > r[letters[j]][k] and i > r[letters[j]][k]:\n                        r[letters[i]] = r[letters[j]][k:] + r[letters[j]][:k]\n                        break\n        t += 1\n    return t\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the answer as a single string.\n    \"\"\"\n    from collections import deque\n    from functools import lru_cache\n\n    N = int(stdin.strip())\n    street = list(stdin.strip())\n\n    def possible_patterns(patterns):\n        patterns_tiles = {}\n        tiles = set()\n        for pattern in patterns:\n            if pattern not in patterns_tiles:\n                patterns_tiles[pattern] = 1\n                tiles.add(pattern)\n            else:\n                patterns_tiles[pattern] += 1\n                tiles.add(pattern)\n\n        return patterns_tiles, tiles\n\n    @lru_cache(None)\n    def dfs(i, remaining, patterns_tiles):\n        if i == N:\n            return 1\n\n        ret = 0\n        for pattern in patterns_tiles[street[i]]:\n            if remaining[pattern] >= 1:\n                remaining[pattern] -= 1\n                ret += dfs(i + 1, remaining, patterns_tiles)\n                remaining[pattern] += 1\n\n        return ret\n\n    patterns_tiles, tiles = possible_patterns(street)\n    pattern_len = len(street[0])\n    ret = dfs(0, dict(tiles), patterns_tiles)\n    return str(ret)\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    string = stdin.strip()\n    tiles = {}\n    for tile in string:\n        tiles[tile] = tiles.get(tile, 0) + 1\n    return str(tiles.get('b', 0))\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    street = stdin.strip().replace(\" \", \"\").replace(\"\\n\", \"\")\n    M = int(stdin.strip())\n    tile_patterns = stdin.strip().split(\"\\n\")\n    T = int(13000000)\n    max_len = max([len(pattern) for pattern in tile_patterns])\n    if max_len > T:\n        return \"0\"\n\n    def possible_patterns(pattern):\n        pattern_lens = [len(pattern) for pattern in tile_patterns]\n        return any(pattern_lens > pattern.count(letter) for letter in set(street))\n\n    # build the adjacency list\n    adj = {}\n    for i in range(N):\n        adj[i] = []\n    for tile in tile_patterns:\n        adj[tile.index(street[0])].append(tile)\n\n    # check each tile pattern for untileability\n    tiles = {}\n    for i in range(M):\n        tile = tile_patterns[i]\n        if not possible_patterns(tile):\n            return \"0\"\n        tiles[i] = tile\n    tiles_lens = [len(tile) for tile in tiles.values()]\n    if any(len(tiles[i]) > T for i in range(M)):\n        return \"0\"\n\n    # recursion\n    def possible_patterns(pattern, cur):\n        if len(pattern) == T:\n            if len(pattern) == len(set(pattern)):\n                return 1\n            return 0\n        if cur > 0:\n            return 0\n        # recurse\n        count = 0\n        for tile in tiles[pattern[cur]]:\n            if cur == 0:\n                count += possible_patterns(pattern + tile, cur + 1)\n            else:\n                count += possible_patterns(pattern + tile, cur + 1)\n        return count\n\n    # check each tile pattern for untileability\n    tiles = {}\n    for i in range(M):\n        tile = tile_patterns[i]\n        if not possible_patterns(tile):\n            return \"0\"\n        tiles[i] = tile\n    tiles_lens = [len(tile) for tile in tiles.values()]\n    if any(len(tiles[i]) > T for i in range(M)):\n        return \"0\"\n    # recursion\n    count = 0\n    for tile in tiles.values():\n        if len(tile) == T:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_cells = int(stdin.split()[0])\n    street_seq = stdin.split()[1]\n    tile_patterns = stdin.split()[2:]\n\n    num_patterns = int(stdin.split()[1])\n\n    # convert street sequence to a dictionary\n    street_dict = {}\n    for i in range(len(street_seq)):\n        street_dict[street_seq[i]] = i\n\n    # initialize count of tiles that can be broken and number of tiles in street\n    tile_broken = 0\n    tile_count = 0\n\n    # create dictionary of tile patterns and their associated letters\n    tile_pattern_dict = {}\n    for pattern in tile_patterns:\n        pattern_letters = pattern[0]\n        for i in range(len(pattern_letters)):\n            tile_pattern_dict[pattern_letters[i]] = pattern[i + 1]\n\n    # create empty list that will store the indices of the tiles to be broken\n    tiles_to_break = []\n\n    # create empty list that will store the letters that are in the street\n    street_letters = []\n\n    # create empty list that will store the indices of the letters in the street\n    street_letters_indices = []\n\n    # create list of empty lists to store letters that are not in the street\n    all_letters_not_in_street = []\n\n    # create list of all letters in the street\n    all_letters = []\n\n    # create list of all indices in the street\n    all_indices = []\n\n    # create an empty list to store all the indices in the street\n    all_indices_in_street = []\n\n    # create an empty dictionary of letters to be broken\n    letters_to_break_dict = {}\n\n    # create an empty dictionary of letters in the street\n    street_letters_dict = {}\n\n    # create an empty dictionary of letters that are not in the street\n    all_letters_not_in_street_dict = {}\n\n    # create an empty list of letters\n    all_letters_list = []\n\n    # create an empty list of all letters in the street\n    all_letters_in_street_list = []\n\n    # create an empty list of all indices in the street\n    all_indices_in_street_list = []\n\n    # create an empty list of all letters not in the street\n    all_letters_not_in_street_list = []\n\n    # create an empty list of indices of tiles to be broken\n    tiles_to_break_list = []\n\n    # create an empty list of indices of letters in the street\n    street_letters_indices_list = []\n\n    # create an empty dictionary of letters to be broken\n    letters_to_break_dict = {}\n\n    # create an empty dictionary of letters in the street\n    street_letters_dict = {}\n\n    # create an empty dictionary of letters not in the street\n    all_letters_not_in_street_dict = {}\n\n    # create an empty list of letters\n    all_letters_list = []\n\n    # create an empty list of all letters in the street\n    all_letters_in_street_list = []\n\n    # create an empty list of all indices in the street\n    all_indices_in_street_list = []\n\n    # create an empty list of letters not in the street\n    all_letters_not_in_street_list = []\n\n    # create a counter for tiles to be broken\n    tile_to_be_broken_counter = 0\n\n    # create a counter for tiles in the street\n    tile_in_street_counter = 0\n\n    # create a list of letters to be broken\n    letters_to_be_broken_list = []\n\n    # create a list of letters in the street\n    letters_in_street_list = []\n\n    # create a list of all letters not in the street\n    letters_not_in_street_list = []\n\n    # create a counter for letters in the street\n    letter_in_street_counter = 0\n\n    # create a counter for all letters in the street\n    all_letters_in_street_counter = 0\n\n    # create a dictionary of letters to be broken and their respective letters in the street\n    for letter in tile_pattern_dict.keys():\n        # create a list of all letters in the street\n        all_letters_in_street_list.append(letter)\n\n        # add the letters to the street_letters_dict\n        street_letters_dict[letter] = letter\n\n    # create a dictionary of letters to be broken and their respective letters not in the street\n    for letter in all_letters_not_in_street_dict.keys():\n        # create a list of all letters not in the street\n        all_letters_not_in_street_list.append(letter)\n\n        # add the letters to the all_letters_not_in_street_dict\n        all_letters_not_in_street_dict[letter] = letter\n\n    # create a dictionary of letters in the street and their respective letters in the street\n    for letter in street_letters_dict.keys():\n        # add the letters to the street_letters_dict\n        street_letters_dict[letter] = letter\n\n    # create a dictionary of letters not in the street and their respective letters in the street\n    for letter in all_letters_not_in_street_dict.keys():\n        # add the letters to the all_letters_not_in_street_dict\n        all_letters_not_in_street_dict[letter] = letter\n\n    # create a list of all letters not in the street\n    for letter in all_letters_list:\n        # add all letters to the list of letters not in the street\n        all_letters_not_in_street_list.append(letter)\n\n    # create a list of all letters in the street\n    for letter in all_letters_in_street_list:\n        # add all letters to the list of letters in the street\n        all_letters_in_street_list.append(letter)\n\n    # create a list of all indices in the street\n    for index in range(len(all_letters_in_street_list)):\n        # add all indices in the street\n        all_indices_in_street_list.append(index)\n\n    # create a list of all letters not in the street\n    for letter in all_letters_not_in_street_list:\n        # add all letters to the list of letters not in the street\n        letters_not_in_street_list.append(letter)\n\n    # create a list of all letters in the street\n    for letter in all_letters_in_street_list:\n        # add all letters in the street to the list of letters in the street\n        letters_in_street_list.append(letter)\n\n    # create a list of all letters not in the street\n    for letter in letters_in_street_list:\n        # add all letters in the street to the list of letters not in the street\n        letters_not_in_street_list.append(letter)\n\n    # create a dictionary of all letters\n    for letter in all_letters_list:\n        # add all"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    lst = stdin.strip().split()\n    s = ''.join(lst)\n    return str(N - len(set(s)))"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    S = list(stdin)\n    M = int(stdin)\n    d = {}\n    for i in range(M):\n        key = ''.join(sorted(stdin))\n        if key in d:\n            return d[key]\n        d[key] = 0\n        key = ''.join(sorted(stdin, reverse=True))\n        if key in d:\n            return d[key]\n        d[key] = 0\n    for k in d.keys():\n        d[k] += 1\n    return d[key]\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    length = int(stdin)\n    street = stdin\n    patterns = {}\n    for i in range(int(length)):\n        patterns[i] = list(street[i])\n    ans = 0\n    for i in range(length):\n        if patterns[i] == street[i]:\n            ans += length\n    return str(ans)\n"
    },
    {
        "number": 3248,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    street = stdin.strip().split('\\n')\n    n = int(street.pop(0))\n    patterns = list(map(lambda x: x.strip().split(' '), street))\n    patterns = list(map(lambda x: {'L': x[0], 'R': x[1], 'B': x[2]}, patterns))\n    return str(count_patterns(patterns, n))\n\ndef"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # solution(sys.stdin)  # change this line to test your code\n\n    N = int(stdin)\n    sections = set()\n    for _ in range(N):\n        # X, Y = map(int, stdin.split())\n        X, Y = map(int, input().split())\n        # X, Y = int(X), int(Y)\n        # sections.add((X, Y))\n        sections.add((X, Y))\n\n    sections = sorted(sections)\n    # sections = sorted(sections, key=lambda x: (x[1], x[0]))\n\n    sections = sorted(sections)\n    b = float('inf')\n    max_i = None\n    for i, (x, y) in enumerate(sections):\n        if (x + 1) < b:\n            b = x + 1\n            max_i = i\n    print(max_i)\n    print(round(b, 6))\n    return \"test\"\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"1\"\n    # return \"2\"\n    # return \"3\"\n    # return \"4\"\n    # return \"5\"\n    # return \"6\"\n    # return \"7\"\n    # return \"8\"\n    # return \"9\"\n    # return \"10\"\n    # return \"11\"\n    # return \"12\"\n    # return \"13\"\n    # return \"14\"\n    # return \"15\"\n    # return \"16\"\n    # return \"17\"\n    # return \"18\"\n    # return \"19\"\n    # return \"20\"\n    # return \"21\"\n    # return \"22\"\n    # return \"23\"\n    # return \"24\"\n    # return \"25\"\n    # return \"26\"\n    # return \"27\"\n    # return \"28\"\n    # return \"29\"\n    # return \"30\"\n    # return \"31\"\n    # return \"32\"\n    # return \"33\"\n    # return \"34\"\n    # return \"35\"\n    # return \"36\"\n    # return \"37\"\n    # return \"38\"\n    # return \"39\"\n    # return \"40\"\n    # return \"41\"\n    # return \"42\"\n    # return \"43\"\n    # return \"44\"\n    # return \"45\"\n    # return \"46\"\n    # return \"47\"\n    # return \"48\"\n    # return \"49\"\n    # return \"50\"\n    # return \"51\"\n    # return \"52\"\n    # return \"53\"\n    # return \"54\"\n    # return \"55\"\n    # return \"56\"\n    # return \"57\"\n    # return \"58\"\n    # return \"59\"\n    # return \"60\"\n    # return \"61\"\n    # return \"62\"\n    # return \"63\"\n    # return \"64\"\n    # return \"65\"\n    # return \"66\"\n    # return \"67\"\n    # return \"68\"\n    # return \"69\"\n    # return \"70\"\n    # return \"71\"\n    # return \"72\"\n    # return \"73\"\n    # return \"74\"\n    # return \"75\"\n    # return \"76\"\n    # return \"77\"\n    # return \"78\"\n    # return \"79\"\n    # return \"80\"\n    # return \"81\"\n    # return \"82\"\n    # return \"83\"\n    # return \"84\"\n    # return \"85\"\n    # return \"86\"\n    # return \"87\"\n    # return \"88\"\n    # return \"89\"\n    # return \"90\"\n    # return \"91\"\n    # return \"92\"\n    # return \"93\"\n    # return \"94\"\n    # return \"95\"\n    # return \"96\"\n    # return \"97\"\n    # return \"98\"\n    # return \"99\"\n    # return \"100\"\n    # return \"101\"\n    # return \"102\"\n    # return \"103\"\n    # return \"104\"\n    # return \"105\"\n    # return \"106\"\n    # return \"107\"\n    # return \"108\"\n    # return \"109\"\n    # return \"110\"\n    # return \"111\"\n    # return \"112\"\n    # return \"113\"\n    # return \"114\"\n    # return \"115\"\n    # return \"116\"\n    # return \"117\"\n    # return \"118\"\n    # return \"119\"\n    # return \"120\"\n    # return \"121\"\n    # return \"122\"\n    # return \"123\"\n    # return \"124\"\n    # return \"125\"\n    # return \"126\"\n    # return \"127\"\n    # return \"128\"\n    # return \"129\"\n    # return \"130\"\n    # return \"131\"\n    # return \"132\"\n    # return \"133\"\n    # return \"134\"\n    # return \"135\"\n    # return \"136\"\n    # return \"137\"\n    # return \"138\"\n    # return \"139\"\n    # return \"140\"\n    # return \"141\"\n    # return \"142\"\n    # return \"143\"\n    # return \"144\"\n    # return \"145\"\n    # return \"146\"\n    # return \"147\"\n    # return \"148\"\n    # return \"149\"\n    # return \"150\"\n    # return \"151\"\n    # return \"152\"\n    # return \"153\"\n    # return \"154\"\n    # return \"155\"\n    # return \"156\"\n    # return \"157\"\n    # return \"158\"\n    # return \"159\"\n    # return \"160\"\n    # return \"161\"\n    # return \"162\"\n    # return \"163\"\n    # return \"164\"\n    # return \"165\"\n    # return \"166\"\n    # return \"167\"\n    # return \"168\"\n    # return \"169\"\n    # return \"170\"\n    # return \"171\"\n    # return \"172\"\n    # return \"173\"\n    # return \"174\"\n    # return \"175\"\n    # return \"176\"\n    # return \"177\"\n    # return \"178\"\n    # return \"179\"\n    # return \"180\"\n    # return \"181\"\n    # return \"182\"\n    # return \"183\"\n    # return \"184\"\n    # return \"185\"\n    # return \"186\"\n    # return \"187\"\n    # return \"188\"\n    # return \"189\"\n    # return \"190\"\n    # return \"191\"\n    # return \"192\"\n    # return \"193\"\n    # return \"194\"\n    # return \"195\"\n    # return \"196\"\n    # return \"197\"\n    # return \"198\"\n    # return \"199\"\n    # return \"200\"\n    # return \"201\"\n    # return \"202\"\n    # return"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def area(p1: float, p2: float, p3: float, p4: float) -> float:\n        A = abs(p1[0]*(p2[1]-p4[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p4[1]))\n        B = abs(p2[0]*(p4[1]-p1[1]) + p4[0]*(p3[1]-p2[1]) + p3[0]*(p1[1]-p2[1]))\n        return A+B\n\n    C = int(stdin)\n    if C < 10 or C > 100:\n        return 'Invalid input'\n\n    l = []\n    for i in range(C):\n        l.append(map(float, stdin.split()))\n    l = sorted(l, key=lambda x: (x[0], x[1]))\n\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    for i in range(len(l)):\n        if l[i][0] == l[i-1][0]:\n            b = max(b, l[i][1])\n            c = min(c, l[i][1])\n        else:\n            a = max(a, l[i][0])\n            d = min(d, l[i][0])\n    total = 0\n    for i in range(a, d):\n        total += area([a, i], [a, c], [b, i], [b, c])\n    print(total)\n    return str(total)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # print(stdin)\n    C, N = map(int, stdin.split())\n    vertices = []\n    for line in stdin.splitlines()[1:]:\n        if line:\n            vertices.append([int(x) for x in line.split()])\n    # print(vertices)\n    length = float('inf')\n    for v in vertices:\n        if v[0] + v[1] < length:\n            length = v[0] + v[1]\n    # print(length)\n    return str(length - C)\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def side_area(a, b, c):\n        return abs((a[0] * b[1] + a[1] * c[0] + c[1] * a[0]) / 2.0)\n\n    def merge_sort(lst):\n        if len(lst) == 1:\n            return lst\n\n        mid = len(lst) // 2\n        left, right = lst[:mid], lst[mid:]\n\n        return merge(merge_sort(left), merge_sort(right))\n\n    def merge(left, right):\n        result = []\n        while len(left) and len(right):\n            if left[0] <= right[0]:\n                result.append(left.pop(0))\n            else:\n                result.append(right.pop(0))\n\n        result += left\n        result += right\n\n        return result\n\n    n, c = map(int, stdin.split())\n\n    points = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        points.append((x, y))\n\n    points.sort(key=lambda x: (x[0], x[1]))\n\n    # 1. First set of bulkhead placements\n    bulkhead_points = []\n    bulkhead_area = 0.0\n    bulkhead_index = 1\n    prev_x = points[0][0]\n    prev_y = points[0][1]\n    for x, y in points[1:]:\n        if x <= prev_x + c:\n            continue\n\n        # 2. Second set of bulkhead placements\n        bulkhead_points.append(prev_x + (c * bulkhead_index) / 2.0)\n        bulkhead_points.append(prev_y + (c * bulkhead_index) / 2.0)\n        bulkhead_area += side_area(prev_x + (c * bulkhead_index), prev_y + (c * bulkhead_index), x, y)\n        prev_x = x\n        prev_y = y\n        bulkhead_index += 1\n\n    bulkhead_points.append(prev_x + (c * bulkhead_index) / 2.0)\n    bulkhead_points.append(prev_y + (c * bulkhead_index) / 2.0)\n    bulkhead_area += side_area(prev_x + (c * bulkhead_index), prev_y + (c * bulkhead_index), x, y)\n    bulkhead_points.sort()\n\n    return f'{len(bulkhead_points)} {round(bulkhead_area, 10)}\\n' +''.join(map(lambda x: str(x), bulkhead_points))"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    C = int(stdin)\n    n = int(input())\n    lines = list(map(lambda x: list(map(int, x.split())), stdin.strip().split('\\n')))\n    l = [(x, y) for x, y in lines]\n    l.sort(key=lambda x: x[0])\n    m = 0\n    xs = set()\n    for x, y in l:\n        xs = xs.union(range(x, y+1))\n    xs = sorted(xs)\n    for x in xs:\n        area = 0\n        for x1, y1 in l:\n            if x1 <= x:\n                for x2, y2 in l:\n                    if y1 <= x2 <= y2 and (x2-x1) * (y2-y1) > area:\n                        area = (x2-x1) * (y2-y1)\n        if area > m:\n            m = area\n    return str(m)\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    C = int(stdin.split()[1])\n\n    # C = 50\n    # N = 4\n    # x = x_1, y_1, x_2, y_2,..., x_n, y_n\n    # x_1, y_1 = 10, 10\n    # x_2, y_2 = 80, 10\n    # x_3, y_3 = 80, 0\n    # x_4, y_4 = 110, 0\n\n    # x_5, y_5 = 100, 0\n    # x_6, y_6 = 100, 20\n    # x_7, y_7 = 0, 20\n    # x_8, y_8 = 0, 50\n\n    # x_9, y_9 = 0, 95\n    # x_10, y_10 = 0, 85\n    # x_11, y_11 = 20, 95\n    # x_12, y_12 = 20, 85\n    # x_13, y_13 = 30, 95\n    # x_14, y_14 = 30, 85\n\n    x_max = max([int(stdin.split()[2 * i]) for i in range(N)])\n    x_min = min([int(stdin.split()[2 * i]) for i in range(N)])\n\n    a = []\n    for i in range(N):\n        a.append(\n            [int(stdin.split()[2 * i + 1]), int(stdin.split()[2 * i + 2])]\n        )\n\n    max_area = 0\n    for i in range(len(a)):\n        area = (\n            0.5\n            * abs((a[i][0] - x_max) * (a[(i + 1) % N][0] - x_max))\n            + 0.5\n            * abs((a[i][1] - x_max) * (a[(i + 1) % N][1] - x_max))\n            + 0.5\n            * abs((a[i][0] - x_min) * (a[(i + 1) % N][0] - x_min))\n            + 0.5\n            * abs((a[i][1] - x_min) * (a[(i + 1) % N][1] - x_min))\n        )\n        if max_area < area:\n            max_area = area\n    # print(max_area)\n    # solution(stdin)\n    # x_max = 10\n    # x_min = 0\n    # a = [[0, 10], [0, 20]]\n    # solution(stdin)\n    # solution(stdin)\n\n    # x_max = 80\n    # x_min = 10\n    # a = [[10, 80], [10, 0], [0, 80], [0, 0]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 80\n    # x_min = 10\n    # a = [[10, 80], [10, 0], [0, 80], [0, 0], [20, 80], [20, 0]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 80\n    # x_min = 10\n    # a = [[10, 80], [10, 0], [0, 80], [0, 0], [20, 80], [20, 0]]\n    # solution(stdin)\n    # solution(stdin)\n\n    # x_max = 110\n    # x_min = 0\n    # a = [[0, 110], [0, 10], [0, 0], [10, 0], [10, 10], [10, 110]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 80\n    # x_min = 0\n    # a = [[0, 80], [0, 0], [0, 10], [10, 0], [10, 10], [10, 80]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 80\n    # x_min = 0\n    # a = [[0, 80], [0, 0], [0, 10], [10, 0], [10, 10], [10, 80]]\n    # solution(stdin)\n    # solution(stdin)\n\n    # x_max = 100\n    # x_min = 0\n    # a = [[0, 100], [0, 0], [0, 20], [20, 0], [20, 20], [20, 100]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 0\n    # x_min = 0\n    # a = [[0, 0], [0, 0], [0, 10], [10, 0], [10, 10], [10, 0]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 0\n    # x_min = 0\n    # a = [[0, 0], [0, 0], [0, 10], [10, 0], [10, 10], [10, 0]]\n    # solution(stdin)\n    # solution(stdin)\n\n    # x_max = 100\n    # x_min = 0\n    # a = [[0, 100], [0, 0], [0, 20], [20, 0], [20, 20], [20, 100]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 0\n    # x_min = 0\n    # a = [[0, 0], [0, 0], [0, 10], [10, 0], [10, 10], [10, 0]]\n    # solution(stdin)\n    # solution(stdin)\n    # x_max = 0\n    # x_min = 0\n    # a = [[0, 0], [0, 0], [0, 10], [10, 0], [10, 10], [10, 0"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def input_list(line):\n        return list(map(int, line.split()))\n\n    def vector(x, y):\n        return int((x[0] - x[1]) * (y[0] - y[1]) - (x[0] - x[1]) * (x[0] - y[1]))\n\n    def is_right(a, b, c):\n        return vector(a, b) == vector(b, c) == vector(a, c)\n\n    def find_bulkhead(hull, x, y):\n        for i in range(len(hull)):\n            if is_right(hull[i], hull[i - 1], hull[i + 1]):\n                return x, y\n        return None\n\n    def is_right_vector(hull, x, y, z):\n        if vector(x, y) == vector(z, y) and vector(x, z) == vector(x, y):\n            return True\n        return False\n\n    def cross(a, b):\n        return (a[0] * b[1]) - (a[1] * b[0])\n\n    def find_placement(hull, i, j, k):\n        x = find_bulkhead(hull, i, j)\n        y = find_bulkhead(hull, j, k)\n        z = find_bulkhead(hull, k, i)\n\n        if is_right_vector(hull, x, y, z):\n            return cross(x, y) + cross(x, z) + cross(y, z)\n        else:\n            return 0\n\n    def calculate(sides, hull):\n        for i in range(sides):\n            for j in range(i, sides):\n                for k in range(j, sides):\n                    yield find_placement(hull, i, j, k)\n\n    C = int(stdin)\n    sides = int(C * C * math.sqrt(3))\n    hull = []\n    for i in range(sides):\n        hull.append(list(map(int, stdin.split())))\n\n    min_area = min(\n        map(\n            lambda p: sum(\n                map(\n                    lambda q: vector(p, q),\n                    calculate(sides, hull),\n                )\n            ),\n            hull,\n        )\n    )\n    return f\"{min_area}\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    c = int(stdin.strip())\n    n = int(stdin.strip())\n    if n == 0:\n        return '0'\n    ans = 0\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        ans += (x + y) * c\n        c -= 1\n    return str(ans // n)\n\n\nprint(solution('30\\n'))\nprint(solution('24\\n'))\n"
    },
    {
        "number": 3249,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    x_max = 0\n    area_max = 0\n    x = []\n    for i in range(int(stdin)):\n        line = stdin.split('\\n')[i]\n        line = line.split()\n        line = list(map(int, line))\n        x.append(line[0])\n        x.append(line[1])\n    for i in range(len(x) - 1):\n        area = abs(x[i + 1] - x[i]) * abs(x[i] - x[i + 1])\n        if area > area_max:\n            area_max = area\n            count = 1\n        elif area == area_max:\n            count += 1\n    print(count)\n    return area_max\n\n\ndef"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin.split()[0])\n    d = int(stdin.split()[1])\n    if d == 2:\n        if b == 3:\n            return 'yes'\n        else:\n            return 'no'\n    if b == 2:\n        if d == 2:\n            return 'no'\n        else:\n            return 'no'\n    else:\n        if b == 1:\n            return 'no'\n        else:\n            return 'no'"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if b == 2 and d % 2 == 0:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    (b,d) = list(map(int, stdin.split()))\n    if d == 1:\n        return 'no'\n    for m in range(1, d):\n        if (b**m)%d == 0:\n            return 'yes'\n    return 'no'"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, d = list(map(int, stdin.split()))\n    if d == 2:\n        if b == 1:\n            return \"yes\"\n        else:\n            return \"no\"\n    # for any b,d and m, d is the prime factor of m\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    # x and y are factors of n\n    # so any of x,y,m = 1,2,3,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 2,3,4\n    # any of x,y,m = 3,2,4\n    # any of x,y,m = 4,3,2\n    "
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, d = stdin\n    return \"yes\" if d*(b**2)%1000000009 else \"no\""
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, d = stdin.split()\n    d = int(d)\n    b = int(b)\n    for m in range(2, int(b**0.5) + 1):\n        if all(m % i == 0 for i in range(2, m)):\n            if m == d:\n                return 'yes'\n    return 'no'"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n   ... 10 11\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 10 7\n   ... ''')\n    'yes'\n    '''\n    import itertools\n    s = stdin.strip()\n    b,d = map(int,s.split())\n    ans = []\n    for i in range(1, 2**63):\n        t = list(map(int,list(str(i))))\n        s = itertools.accumulate(t)\n        if s == list(s):\n            if int(s) % d == 0:\n                ans.append(i)\n    if len(ans) == 0:\n        return \"no\"\n    else:\n        return \"yes\""
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    for i in range(d, 1_000_000_001):\n        if (b ** (i-1)) % d == 1:\n            if (b ** i) % d == 1:\n                return \"yes\"\n    return \"no\"\n"
    },
    {
        "number": 3250,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if (b, d, b, d, d, d, d, d) % d == 0:\n        return 'yes'\n    return 'no'"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = {}\n    for line in stdin.split(\"\\n\"):\n        intervals[line.split()[0]] = intervals.get(line.split()[0], 0) + 1\n    longest = 0\n    for interval, count in intervals.items():\n        if count == 1:\n            longest = max(longest, intervals[interval])\n    return str(max(len(intervals) - longest, longest))"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for i in range(int(stdin)):\n        intervals.append([int(j) for j in stdin.split()[i * 2:i * 2 + 2]])\n    intervals.sort()\n    max_distinct = 1\n    max_distinct_interval = intervals[0]\n    for i in range(1, len(intervals)):\n        start = intervals[i][0]\n        if start < max_distinct_interval[1]:\n            max_distinct = 1\n            max_distinct_interval = intervals[i]\n        elif start == max_distinct_interval[1]:\n            max_distinct += 1\n            if max_distinct > max_distinct_interval[2]:\n                max_distinct = max_distinct_interval[2]\n                max_distinct_interval = intervals[i]\n    return str(max_distinct)\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    longest = []\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        longest.append([a, b])\n\n    longest = sorted(longest, key=lambda x: x[0])\n    res = 1\n    prev = -1\n\n    for i in range(len(longest)):\n        if longest[i][0] > prev + 1:\n            prev = longest[i][1]\n            res += 1\n        else:\n            prev = longest[i][1]\n    return str(res)"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    n_intervals = 0\n    longest = 0\n    best = []\n    for i in range(n):\n        interval = list(map(int, stdin.strip().split()))\n        interval.sort()\n        n_intervals += 1\n        if len(interval) == 0:\n            continue\n        first_interval = interval[0]\n        last_interval = interval[-1]\n        if first_interval >= last_interval:\n            continue\n        else:\n            longest = max(longest, first_interval - last_interval)\n            best.append((first_interval, last_interval))\n    return str(longest) + \"\\n\" + \"\\n\".join(map(str, sorted(best)))\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = sorted(list(map(int, stdin.split()[1:])), key=lambda x: x[0])\n    result = []\n    l, r = 0, 1\n    while r < n:\n        while l < n and arr[l][0] <= arr[r][0]:\n            l += 1\n        result.append(str(arr[r]) + \" \")\n        r += 1\n        l = max(l, r)\n        while r < n and arr[r][0] <= arr[l][1]:\n            r += 1\n    return \"\".join(result)\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    intervals = stdin.split()\n    for i in range(len(intervals)):\n        intervals[i] = int(intervals[i])\n    intervals.sort()\n    intervals = sorted(intervals)\n    K = 1\n    intervals = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i - 1] < intervals[i]:\n            intervals.append(intervals[i])\n            K = max(K, len(intervals))\n    return str(K)\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    longest_length = 0\n    longest_intervals = []\n\n    for current_interval in input_lines:\n        current_interval = current_interval.split()\n\n        current_interval_start, current_interval_end = int(current_interval[0]), int(current_interval[1])\n\n        current_interval_number_of_points = 1\n\n        if current_interval_start - 1 >= longest_length:\n            for interval_i in range(0, longest_length):\n                if interval_i < current_interval_start:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n                elif interval_i == current_interval_start - 1:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n\n                if interval_i < current_interval_end:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n                elif interval_i == current_interval_end - 1:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n\n        if current_interval_end - 1 >= longest_length:\n            for interval_i in range(0, longest_length):\n                if interval_i < current_interval_end:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n                elif interval_i == current_interval_end - 1:\n                    longest_intervals[interval_i] = longest_intervals[interval_i] + current_interval_number_of_points\n\n        current_interval_number_of_points = current_interval_number_of_points + 1\n        longest_length = max(longest_length, current_interval_number_of_points)\n\n    print(max(longest_intervals))\n\n    for i in range(0, longest_length):\n        if longest_intervals[i] > 0:\n            print(i + 1, end=\" \")\n    print()\n    return longest_length\n\nsolution(input())\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    s = s.split()\n    n = int(s[0])\n    intervals = []\n    for i in range(n):\n        intervals.append(int(s[i + 1]))\n    intervals.sort()\n    longest = 0\n    longest_sequence = []\n    for i in range(n):\n        current = intervals[i]\n        if i == 0:\n            longest_sequence.append(current)\n            longest = 1\n            continue\n        if current > intervals[i - 1]:\n            longest = 1\n        else:\n            longest += 1\n        longest_sequence.append(current)\n    return str(len(longest_sequence)) + '\\n' +''.join([str(n) for n in longest_sequence])\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    N = int(stdin)\n    A = stdin.strip().split()\n    S = set(A)\n    for i in range(1, len(A)):\n        S.discard(A[i - 1])\n        S.add(A[i])\n    return str(len(S))\n"
    },
    {
        "number": 3251,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    intervals = stdin.split()\n    result = 0\n    intervals = sorted([(int(intervals[i]), int(intervals[i + 1])) for i in range(0, len(intervals) - 1, 2)])\n\n    for i in range(0, len(intervals) - 1):\n        intervals[i] = sorted(intervals[i])\n        intervals[i + 1] = sorted(intervals[i + 1])\n        if intervals[i] == intervals[i + 1]:\n            continue\n        else:\n            length = 0\n            for j in range(0, len(intervals[i])):\n                for k in range(0, len(intervals[i + 1])):\n                    if intervals[i + 1][k] >= intervals[i][j]:\n                        length += 1\n            if length > result:\n                result = length\n    return str(result)\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Get number of tests\n    n, k = list(map(int, stdin.split()))\n    # Get and process each test\n    for i in range(n):\n        card_types, min_envelopes = list(map(int, stdin.split()))\n        cards = [0] * card_types\n        for j in range(card_types):\n            cards[j] = list(map(int, stdin.split()))\n            cards[j][0] = cards[j][0] - min_envelopes\n        # Return the smallest waste\n        print(min(sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][1] * cards[j][0] for j in range(card_types)]) - (sum([cards[j][1] * cards[j][0] for j in range(card_types, 2 * card_types)]) + sum([cards[j][1] * cards[j][0] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][1] * cards[j][0] for j in range(card_types)]) - (sum([cards[j][1] * cards[j][0] for j in range(card_types, 2 * card_types)]) + sum([cards[j][1] * cards[j][0] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][1] * cards[j][0] for j in range(card_types)]) - (sum([cards[j][1] * cards[j][0] for j in range(card_types, 2 * card_types)]) + sum([cards[j][1] * cards[j][0] for j in range(2 * card_types, card_types)])))\n    return str(min(sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][1] * cards[j][0] for j in range(card_types)]) - (sum([cards[j][1] * cards[j][0] for j in range(card_types, 2 * card_types)]) + sum([cards[j][1] * cards[j][0] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][1] * cards[j][0] for j in range(card_types)]) - (sum([cards[j][1] * cards[j][0] for j in range(card_types, 2 * card_types)]) + sum([cards[j][1] * cards[j][0] for j in range(2 * card_types, card_types)])),\n                  sum([cards[j][0] * cards[j][1] for j in range(card_types)]) - (sum([cards[j][0] * cards[j][1] for j in range(card_types, 2 * card_types)]) + sum([cards[j][0] * cards[j][1] for j in range(2 * card_types, card_types)"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    cards = []\n    for i in range(n):\n        card = stdin.split()[i + 1]\n        cards.append(list(map(int, card.split())))\n    cards.sort(key=lambda x: x[0] * x[1] * x[2])\n    waste = 0\n    for i in range(k):\n        cards.sort(key=lambda x: x[0] * x[1])\n        waste += cards[i][2] * (cards[i][0] * cards[i][1] - cards[i][1] * cards[i][0])\n        if i < k - 1:\n            waste += (cards[i][2] * (cards[i][0] * cards[i][1] - cards[i][1] * cards[i][0]))\n    return str(waste)"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def print_res(res: int):\n        if res == 0:\n            print(\"Wrong\")\n            return\n        print(res)\n    t = int(stdin.split()[0])\n    l = []\n    for _ in range(t):\n        l.append(stdin.split()[1:])\n    res = 0\n    for i in range(len(l)):\n        if i == 0:\n            continue\n        res = max(res, (int(l[i][0])*int(l[i][2]))*(int(l[i][1])*int(l[i-1][1])))\n        res = max(res, int(l[i][0])*int(l[i][1])*(int(l[i-1][0])*int(l[i-1][2])))\n    print_res(res)\n    return \"\"\n\nsolution(\"2 1\")\nsolution(\"2 2\")\nsolution(\"5 1\")\nsolution(\"5 2\")\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.strip().split()))\n    card_types = {}\n    w, h, q = map(int, input().strip().split())\n    for _ in range(n):\n        w, h, q = map(int, input().strip().split())\n        if w in card_types:\n            card_types[w].append([h, q])\n        else:\n            card_types[w] = [[h, q]]\n    # print(card_types)\n    res = 0\n    for key in card_types.keys():\n        temp_res = 0\n        for value in card_types[key]:\n            if key == 4:\n                temp_res += (w * h * q) - value[0] * value[1]\n            elif key == 3:\n                temp_res += (w * h * q) - (value[0] * value[1] + (w - value[0]) * (h - value[1]))\n            elif key == 2:\n                temp_res += (w * h * q) - (value[0] * value[1])\n            elif key == 1:\n                temp_res += (w * h * q) - (value[0] * value[1])\n            else:\n                temp_res += (w * h * q) - (value[0] * value[1])\n        res = max(res, temp_res)\n    return str(res)\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c_w = [int(x) for x in stdin.split()]\n\n    def card_area(w, h):\n        return w * h\n\n    def max_h_area(cards, cnt):\n        cards_area = sum(card_area(w, h) for w, h in cards)\n        if cnt == 1:\n            return cards_area\n        return max(max_h_area(cards[:i], cnt - 1) + cards_area for i in range(1, len(cards)))\n\n    w = max(c_w)\n    h = max(c_w)\n    a = max_h_area(c_w, k)\n    return str(a - w * h)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    INPUT = stdin\n    n, k = map(int, INPUT.split())\n    cards = []\n    for i in range(n):\n        w, h, q = map(int, INPUT.split())\n        cards.append((w, h, q))\n    \n    # max number of envelopes is 5\n    max_number_of_envelopes = k\n    \n    # sort cards by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort cards by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h, sort by q\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h, sort by q, sort by w\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h, sort by q, sort by w, sort by h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h, sort by q, sort by w, sort by h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h, sort by q, sort by w\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h, sort by q\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by w*h\n    cards = sorted(cards, key=lambda x: x[0]*x[1], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True)\n    \n    # sort by q\n    cards = sorted(cards, key=lambda x: x[2], reverse=True"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of n line containing 3 integers w, h and q\n    separated by a space, where n is the number of types of cards\n    and w, h and q are integers describing the dimensions of the\n    card.\n    Returns the smallest possible total amount of wasted paper\n    required to fit the cards into the given number of envelopes.\n    \"\"\"\n    inputs = list(map(lambda x: x.split(), stdin.strip().split(\"\\n\")))\n    return str(min(map(lambda x: min(int(i) * min(int(j), int(k))\n                        for i, j, k in zip(x, x[1:], x[2:])), inputs)))\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    cards = []\n    for _ in range(n):\n        cards.append(tuple(map(int, lines[_ + 1].split())))\n    cards = sorted(cards, key=lambda x: (x[0], x[1], x[2]))\n    result = 0\n    for i in range(n):\n        if i < k:\n            if k - i < i:\n                result += (i * cards[i][2] * 2) + (k - i - 1) * cards[i][2]\n            else:\n                result += (i * cards[i][2] * 2) + (k - i - 1) * cards[i][2] + (k - i) * cards[i][2] * 2\n        else:\n            result += (i * cards[i][2] * 2) + (k - i) * cards[i][2] * 2\n    return str(result)\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(i) for i in stdin.split())\n    cards = sorted((int(i) for i in stdin.split()))\n    envelopes = []\n    index = 0\n    last_index = 0\n    waste = 0\n    while index < k:\n        envelopes.append(cards[index] * cards[index + 1])\n        index += 2\n    while index < n:\n        envelopes.append(cards[index])\n        index += 1\n    envelopes.sort()\n    waste = sum((i * (i - 1) // 2) for i in envelopes)\n    return waste\n"
    },
    {
        "number": 3252,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n,k=list(map(int,stdin.split()))\n    card_types=[list(map(int,stdin.split())) for _ in range(n)]\n    n_envelopes=min(list(map(lambda card: card[0]*card[1],card_types)))\n    result=0\n    for card in card_types:\n        w,h=card\n        result+=w*n_envelopes+(w-h)*card[1]+(h-w)*card[0]\n    return str(result)\n"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse(s: str) -> List[int]:\n        return list(map(int, s.split()))\n\n    states = []\n    for _ in range(int(stdin.splitlines()[0])):\n        states.append(parse(stdin.splitlines()[1 + _]))\n    return min(\n        sum(\n            [\n                states[i][1] - states[i][0]\n                for i in range(len(states))\n                if states[i][1] == states[i][0]\n            ]\n        ),\n        sum(\n            [\n                states[i][2] - states[i][1]\n                for i in range(len(states))\n                if states[i][2] == states[i][1]\n            ]\n        ),\n        sum(\n            [\n                states[i][3] - states[i][2]\n                for i in range(len(states))\n                if states[i][3] == states[i][2]\n            ]\n        ),\n    )"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    states_dict = {}\n    for line in stdin.split(\"\\n\"):\n        states_dict[int(line[0])] = (int(line[1]), int(line[2]), int(line[3]), int(line[4]))\n    return min(voters_for_constituents(states_dict),\n               voters_for_federals(states_dict),\n               voters_for_undecided(states_dict))\n\n\ndef"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin.split()[0])\n    n = int(stdin.split()[0])\n    delegates = [list(map(int, stdin.split()[1:])) for _ in range(S)]\n\n    # Array of sum of delegates\n    delegate_sum = []\n    for i in range(S):\n        delegate_sum.append(sum(delegates[i]))\n\n    # Array of number of delegates\n    delegates_num = []\n    for i in range(S):\n        delegates_num.append(len(delegates[i]))\n\n    # Array of difference between the sum of delegates and the number of delegates\n    delegate_diff = []\n    for i in range(S):\n        delegate_diff.append(delegate_sum[i] - delegates_num[i])\n\n    # Array of index of the minimum difference\n    min_index = []\n    for i in range(S):\n        min_index.append(delegate_diff.index(min(delegate_diff)))\n\n    # Array of total number of delegators in each state\n    total_delegates = []\n    for i in range(S):\n        total_delegates.append(delegates_num[i] + delegates_num[min_index[i]])\n\n    # Array of delegation list of each state\n    delegation_list = []\n    for i in range(S):\n        delegation_list.append(delegates[i][min_index[i]])\n\n    # Array of candidate list of each state\n    candidate_list = []\n    for i in range(S):\n        candidate_list.append([(1 if j in delegation_list else 0) for j in range(2)])\n\n    # Array of the sum of candidate\n    candidate_sum = []\n    for i in range(S):\n        candidate_sum.append(sum(candidate_list[i]))\n\n    # Array of the minimum number of candidates\n    min_candidate_num = []\n    for i in range(S):\n        min_candidate_num.append(candidate_sum.index(min(candidate_sum)))\n\n    # Array of total number of candidates in each state\n    total_candidate_num = []\n    for i in range(S):\n        total_candidate_num.append(candidate_sum[i] + candidate_sum[min_index[i]])\n\n    # Array of total number of delegators\n    total_delegators = []\n    for i in range(S):\n        total_delegators.append(total_delegates[i] + total_delegates[min_index[i]])\n\n    # Array of total number of candidates in each state\n    total_candidate_num = []\n    for i in range(S):\n        total_candidate_num.append(total_candidate_num[i] + total_candidate_num[min_index[i]])\n\n    # Array of total number of delegators in each state\n    total_delegators = []\n    for i in range(S):\n        total_delegators.append(total_delegators[i] + total_delegators[min_index[i]])\n\n    # Array of delegators in each state\n    delegators = []\n    for i in range(S):\n        delegators.append(delegation_list[i] + delegation_list[min_index[i]])\n\n    # Array of candidates in each state\n    candidates = []\n    for i in range(S):\n        candidates.append(candidate_list[i] + candidate_list[min_index[i]])\n\n    # Array of sum of candidates in each state\n    candidate_sum = []\n    for i in range(S):\n        candidate_sum.append(candidate_sum[i] + candidate_sum[min_index[i]])\n\n    # Array of candidate in each state\n    candidates = []\n    for i in range(S):\n        candidates.append(candidate_list[i] + candidate_list[min_index[i]])\n\n    # Array of candidate in each state\n    candidates = []\n    for i in range(S):\n        candidates.append(candidate_list[i] + candidate_list[min_index[i]])\n\n    # Array of delegates in each state\n    delegators = []\n    for i in range(S):\n        delegators.append(delegation_list[i] + delegation_list[min_index[i]])\n\n    # Array of total delegators in each state\n    total_delegators = []\n    for i in range(S):\n        total_delegators.append(total_delegators[i] + total_delegators[min_index[i]])\n\n    # Array of total number of candidates in each state\n    total_candidate_num = []\n    for i in range(S):\n        total_candidate_num.append(total_candidate_num[i] + total_candidate_num[min_index[i]])\n\n    # Array of total number of candidates in each state\n    total_candidate_num = []\n    for i in range(S):\n        total_candidate_num.append(total_candidate_num[i] + total_candidate_num[min_index[i]])\n\n    # Array of total number of candidates in each state\n    total_delegators = []\n    for i in range(S):\n        total_delegators.append(total_delegators[i"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    stdin = list(map(lambda x: list(map(int, x.split())), stdin))\n    n_states = len(stdin)\n\n    def compare_two_lists(L1: List, L2: List) -> bool:\n        if len(L1)!= len(L2):\n            return False\n        for i in range(len(L1)):\n            if L1[i]!= L2[i]:\n                return False\n        return True\n\n    def compare_two_lists_by_delegate(L1: List, L2: List) -> bool:\n        if len(L1)!= len(L2):\n            return False\n        for i in range(len(L1)):\n            if L1[i]!= L2[i]:\n                if L1[i] < L2[i]:\n                    return False\n        return True\n\n    states_delegates = list(map(lambda x: compare_two_lists_by_delegate(x[0], x[1]), stdin))\n\n    states_delegates_min_votes = []\n    states_delegates_max_votes = []\n    states_delegates_avg_votes = []\n\n    # states_delegates_max_votes = []\n    # states_delegates_min_votes = []\n    # states_delegates_avg_votes = []\n    for i in range(len(states_delegates)):\n        if states_delegates[i]:\n            states_delegates_max_votes.append(i)\n        else:\n            states_delegates_min_votes.append(i)\n        # states_delegates_avg_votes.append(i)\n\n    # states_delegates_max_votes = list(filter(lambda x: x, states_delegates_max_votes))\n    # states_delegates_min_votes = list(filter(lambda x: x, states_delegates_min_votes))\n    # states_delegates_avg_votes = list(filter(lambda x: x, states_delegates_avg_votes))\n\n    # states_delegates_min_votes = list(filter(lambda x: x, states_delegates_min_votes))\n\n    states_delegates_min_votes_amount = 0\n    states_delegates_max_votes_amount = 0\n    states_delegates_avg_votes_amount = 0\n\n    # for i in range(len(states_delegates_max_votes)):\n    #     if states_delegates_max_votes[i]:\n    #         states_delegates_max_votes_amount = states_delegates_max_votes_amount + 1\n    #     if states_delegates_min_votes[i]:\n    #         states_delegates_min_votes_amount = states_delegates_min_votes_amount + 1\n    #     if states_delegates_avg_votes[i]:\n    #         states_delegates_avg_votes_amount = states_delegates_avg_votes_amount + 1\n\n    for i in range(len(states_delegates_max_votes)):\n        if states_delegates_max_votes[i]:\n            states_delegates_max_votes_amount = states_delegates_max_votes_amount + 1\n        if states_delegates_min_votes[i]:\n            states_delegates_min_votes_amount = states_delegates_min_votes_amount + 1\n        if states_delegates_avg_votes[i]:\n            states_delegates_avg_votes_amount = states_delegates_avg_votes_amount + 1\n\n    if states_delegates_min_votes_amount >= states_delegates_max_votes_amount:\n        return states_delegates_min_votes_amount\n\n    elif states_delegates_min_votes_amount < states_delegates_max_votes_amount:\n        return states_delegates_max_votes_amount\n\n    else:\n        if states_delegates_min_votes_amount == states_delegates_max_votes_amount:\n            if states_delegates_min_votes_amount == states_delegates_avg_votes_amount:\n                return states_delegates_max_votes_amount\n            elif states_delegates_min_votes_amount < states_delegates_avg_votes_amount:\n                return states_delegates_min_votes_amount\n            else:\n                return states_delegates_avg_votes_amount\n        else:\n            return states_delegates_max_votes_amount\n\n\n    # min_votes = 0\n    # max_votes = 0\n    # avg_votes = 0\n\n    # for i in range(len(states_delegates_max_votes)):\n    #     if states_delegates_max_votes[i]:\n    #         max_votes = max_votes + 1\n    #     if states_delegates_min_votes[i]:\n    #         min_votes = min_votes + 1\n    #     if states_delegates_avg_votes[i]:\n    #         avg_votes = avg_votes + 1\n    #\n    # if min_votes >= max_votes:\n    #     return min_votes\n    #\n    # elif min_votes < max_votes:\n    #     return max_votes\n    # else:\n    #     return avg_votes\n\n\n    # for i in range(len(states_delegates_max_votes)):\n    #     if states_de"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    states, delegates, federals, undecided = stdin.split()\n    delegates = int(delegates)\n    federals = int(federals)\n    undecided = int(undecided)\n\n    delegates_c = delegates // 2\n    undecided_c = undeclined // 2\n\n    states = list(map(int, states.split()))\n    states.sort()\n\n    state_votes = {}\n    for state in states:\n        state_votes[state] = 0\n\n    total_votes = delegates + federals + undecided\n    undecided_votes = delegates + federals\n    undecided_votes += undecided_c\n\n    if total_votes % 2 == 1:\n        return 'impossible'\n\n    while delegates_c > 0:\n        state_votes[states[0]] += 1\n        if state_votes[states[0]] > delegates // 2:\n            return 'impossible'\n\n        states.remove(states[0])\n        delegates_c -= 1\n        delegates -= 1\n\n    while undecided_c > 0:\n        state_votes[states[0]] += 1\n        if state_votes[states[0]] > delegates // 2:\n            return 'impossible'\n\n        states.remove(states[0])\n        undecided_c -= 1\n        undecided -= 1\n\n    while federals_c > 0:\n        if undecided_c > 0:\n            state_votes[states[0]] += 1\n            if state_votes[states[0]] > delegates // 2:\n                return 'impossible'\n\n        states.remove(states[0])\n        federals_c -= 1\n        federals -= 1\n\n    while undecided_c > 0:\n        if delegates_c > 0:\n            state_votes[states[0]] += 1\n            if state_votes[states[0]] > delegates // 2:\n                return 'impossible'\n\n        states.remove(states[0])\n        undecided_c -= 1\n        undecided -= 1\n\n    if total_votes == delegates:\n        return 'impossible'\n\n    return total_votes\n"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    cnt_const = 0\n    cnt_feder = 0\n    cnt_undec = 0\n    s = stdin.split()\n    for _ in range(int(s[0])):\n        c = int(s[1])\n        if c == 1:\n            cnt_const += 1\n        elif c == 2:\n            cnt_feder += 1\n        elif c == 0:\n            cnt_undec += 1\n    #print(cnt_const, cnt_feder, cnt_undec)\n    if cnt_undec <= cnt_const:\n        return 'impossible'\n    return min(cnt_const, cnt_feder)\n"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split(\"\\n\")\n    D_Constituents = int(line[0])\n    D_Federals = int(line[1])\n    D_Undecided = int(line[2])\n    States = []\n    for i in range(D_Constituents):\n        States.append([0, 0, 0])\n    for i in range(D_Federals):\n        States.append([0, 0, 0])\n    for i in range(D_Undecided):\n        States.append([0, 0, 0])\n    States.sort(key=lambda x: (x[0], x[1], x[2]))\n    # print(States)\n    max_voters = 0\n    for i in range(len(States)):\n        if max_voters < D_Constituents:\n            max_voters += States[i][0]\n        else:\n            return \"impossible\"\n    return max_voters\n\nprint(solution(\"\"\"\n3\n7 2401 3299 0\n6 2401 2399 0\n2 750 750 99\n\"\"\"))\n"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    states = int(lines[0])\n    delegates = []\n    constitutors = []\n    federals = []\n    undecideds = []\n    for state_id, line in enumerate(lines[1:], start=1):\n        delegates.append(int(line.split()[0]))\n        constitutors.append(int(line.split()[1]))\n        federals.append(int(line.split()[2]))\n        undecideds.append(int(line.split()[3]))\n\n    undecideds = sorted(undecideds)\n    constitutors = sorted(constitutors)\n    federals = sorted(federals)\n    delegates = sorted(delegates)\n\n    min_delegates = delegates[0]\n    max_delegates = delegates[-1]\n\n    while undecideds:\n        for delegate in undecideds:\n            if (min_delegates - delegates[0]) <= delegate <= (max_delegates - delegates[0]):\n                delegates[0] += 1\n                delegates = sorted(delegates)\n                if delegates[0] > delegates[1]:\n                    delegates[1] += 1\n                    delegates = sorted(delegates)\n                    if delegates[0] > delegates[1]:\n                        delegates[1] += 1\n                        delegates = sorted(delegates)\n                        break\n\n            elif (delegates[0] - min_delegates) <= delegate <= (delegates[0] - min_delegates):\n                delegates[0] -= 1\n                delegates = sorted(delegates)\n                if delegates[0] < delegates[1]:\n                    delegates[1] -= 1\n                    delegates = sorted(delegates)\n                    if delegates[0] < delegates[1]:\n                        delegates[1] -= 1\n                        delegates = sorted(delegates)\n                        break\n\n            elif delegates[1] - (delegates[1] - min_delegates) <= delegate <= (delegates[1] - min_delegates):\n                delegates[1] -= 1\n                delegates = sorted(delegates)\n                if delegates[0] < delegates[1]:\n                    delegates[0] += 1\n                    delegates = sorted(delegates)\n                    if delegates[0] > delegates[1]:\n                        delegates[1] += 1\n                        delegates = sorted(delegates)\n                        break\n        undecideds = sorted(undecideds)\n\n    if states >= 2:\n        for state_id in range(1, states):\n            if delegators[state_id] == delegators[state_id + 1]:\n                return 'impossible'\n\n    return str(min(delegates))"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    state_size, delegates, federals, undecideds = stdin.split()\n    state_size = int(state_size)\n    delegates = tuple(map(int,delegates.split()))\n    federals = tuple(map(int,federals.split()))\n    undecideds = tuple(map(int,undecideds.split()))\n    federals_cnt = 0\n    delegates_cnt = 0\n    undecideds_cnt = 0\n    for i in range(state_size):\n        if delegates[i] > delegates_cnt:\n            delegates_cnt = delegates[i]\n        elif delegates_cnt >= delegates[i]:\n            federals_cnt += delegates[i]\n            if federals_cnt > delegates_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if federals[i] > federals_cnt:\n            federals_cnt = federals[i]\n        elif federals_cnt >= federals[i]:\n            federals_cnt += federals[i]\n            if federals_cnt > delegates_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if delegates[i] > delegates_cnt:\n            delegates_cnt = delegates[i]\n        elif delegates_cnt >= delegates[i]:\n            delegates_cnt += delegates[i]\n            if delegates_cnt > federals_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if federals[i] > federals_cnt:\n            federals_cnt = federals[i]\n        elif federals_cnt >= federals[i]:\n            federals_cnt += federals[i]\n            if federals_cnt > delegates_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if delegates[i] > delegates_cnt:\n            delegates_cnt = delegates[i]\n        elif delegates_cnt >= delegates[i]:\n            delegates_cnt += delegates[i]\n            if delegates_cnt > federals_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if federals[i] > federals_cnt:\n            federals_cnt = federals[i]\n        elif federals_cnt >= federals[i]:\n            federals_cnt += federals[i]\n            if federals_cnt > delegates_cnt:\n                return \"impossible\"\n    for i in range(state_size):\n        if delegates[i] > delegates_cnt:\n            undecideds_cnt += delegates[i]\n        elif delegates_cnt >= delegates[i]:\n            delegates_cnt += delegates[i]\n            if delegates_cnt > federals_cnt:\n                return \"impossible\"\n    return str(min(undecideds_cnt,delegates_cnt,federals_cnt))\n    \n"
    },
    {
        "number": 3253,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    D, C, F, U = map(int, stdin.split())\n    D = set(range(1, D + 1))\n    C = set(range(1, C + 1))\n    F = set(range(1, F + 1))\n    U = set(range(1, U + 1))\n    F = F | D\n    D = D - F\n    U = U - F\n    F = F | D\n    D = D - F\n    F = F - U\n    D = D - U\n    if len(D) > len(C) or len(D) > len(F):\n        return \"impossible\"\n    else:\n        print(len(D) + len(C) + len(F))\n    return \"impossible\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n\n    while x > 0:\n        if x > 0.25:\n            ones += 1\n            x -= 0.25\n        elif x > 0.125:\n            twos += 1\n            x -= 0.125\n        elif x > 0.0625:\n            threes += 1\n            x -= 0.0625\n        elif x > 0.03125:\n            fours += 1\n            x -= 0.03125\n        elif x > 0.015625:\n            fives += 1\n            x -= 0.015625\n\n    if ones == 0 and twos == 0 and threes == 0 and fours == 0 and fives == 0:\n        print(f\"0 {ones} {twos} {threes} {fours} {fives}\")\n    else:\n        print(f\"{ones} {twos} {threes} {fours} {fives}\")"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = float(stdin)\n    n_ones = 0\n    n_twos = 0\n    n_threes = 0\n    n_fours = 0\n    n_fives = 0\n\n    while n!= 0:\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n        \n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_fives += 1\n\n        if n_ones == 0 and n_twos == 0 and n_threes == 0 and n_fours == 0 and n_fives == 0:\n            if n >= 1 and n < 2:\n                n_ones += 1\n            elif n >= 2 and n < 3:\n                n_twos += 1\n            elif n >= 3 and n < 4:\n                n_threes += 1\n            elif n >= 4 and n < 5:\n                n_fours += 1\n            elif n >= 5 and n < 6:\n                n_f"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    if P > 5 or P < 1:\n        raise Exception('Invalid')\n    answer = 0\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n    while True:\n        if ones > 0 and twos > 0 and threes > 0 and fours > 0 and fives > 0:\n            break\n        if ones + twos + threes + fours + fives == 0:\n            if ones == 0:\n                ones = 1\n                twos = 0\n                threes = 0\n                fours = 0\n                fives = 0\n            elif ones == 1:\n                ones = 0\n                twos = 1\n                threes = 0\n                fours = 0\n                fives = 0\n            elif ones == 2:\n                ones = 0\n                twos = 0\n                threes = 1\n                fours = 0\n                fives = 0\n            elif ones == 3:\n                ones = 0\n                twos = 0\n                threes = 0\n                fours = 1\n                fives = 0\n            elif ones == 4:\n                ones = 0\n                twos = 0\n                threes = 0\n                fours = 0\n                fives = 1\n            elif ones == 5:\n                ones = 0\n                twos = 0\n                threes = 0\n                fours = 0\n                fives = 0\n                ones = 1\n        if P - ones > 0 and P - ones > 0:\n            ones += 1\n        elif P - twos > 0 and P - twos > 0:\n            twos += 1\n        elif P - threes > 0 and P - threes > 0:\n            threes += 1\n        elif P - fours > 0 and P - fours > 0:\n            fours += 1\n        elif P - fives > 0 and P - fives > 0:\n            fives += 1\n    print(ones)\n    print(twos)\n    print(threes)\n    print(fours)\n    print(fives)\n    return ''\n\nsolution('5.0')\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    stdin = float(stdin)\n    import math\n    import decimal\n    decimal.getcontext().rounding = decimal.ROUND_HALF_UP\n    solution = round(stdin, 1)\n    return str(solution)\ndef"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    P = float(stdin.pop(0))\n    a1 = 0\n    a2 = 0\n    a3 = 0\n    a4 = 0\n    a5 = 0\n    for i in stdin:\n        for j in i:\n            if j == '1':\n                a1 += 1\n            if j == '2':\n                a2 += 1\n            if j == '3':\n                a3 += 1\n            if j == '4':\n                a4 += 1\n            if j == '5':\n                a5 += 1\n    print(a1, a2, a3, a4, a5)\n    print(round((a1 + a2 + a3 + a4 + a5)/5))\n    return \"0 0 0 0 1\"\n\nsolution(input())\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    number, average_number, count = float(stdin), 0.0, 0\n    \n    # check numbers\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n    \n    while number > 0:\n        if number == 1:\n            ones += 1\n        elif number == 2:\n            twos += 1\n        elif number == 3:\n            threes += 1\n        elif number == 4:\n            fours += 1\n        elif number == 5:\n            fives += 1\n        \n        # remove number from list\n        number = number - 1\n        \n    # convert sum to average\n    average_number = ones / count\n    \n    # return results\n    return str(ones) +'' + str(twos) +'' + str(threes) +'' + str(fours) +'' + str(fives) +'' + str(average_number)\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(float, stdin.split())\n    a = int(a)\n    f = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0}\n    for i in range(a + 1):\n        for j in range(6):\n            for k in range(6):\n                for l in range(6):\n                    f[j] += 1\n    for j in range(6):\n        if f[j] == a:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 1:\n            return \"0 0 0 1 1\"\n    for j in range(6):\n        if f[j] == a + 2:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 3:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 4:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 5:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 6:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 7:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 8:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 9:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 10:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 11:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 12:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 13:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 14:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 15:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 16:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 17:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 18:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 19:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 20:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 21:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 22:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 23:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 24:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 25:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 26:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 27:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 28:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 29:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 30:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 31:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 32:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 33:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 34:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 35:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 36:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 37:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 38:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 39:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 40:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 41:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 42:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 43:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 44:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 45:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 46:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 47:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 48:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 49:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 50:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 51:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 52:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 53:\n            return \"0 0 0 0 1\"\n    for j in range(6):\n        if f[j] == a + 54:\n            return \"0 0 0 0 1\"\n    for j in range(6"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n    count = 0\n    if p <= 0:\n        return '0 0 0 0 1'\n    while p >= 1:\n        if p == 1:\n            ones = ones + 1\n            if count > 0:\n                return '0 0 0 0'+ str(ones)\n        elif p == 2:\n            twos = twos + 1\n            if count > 0:\n                return '0 0 0'+ str(twos)\n        elif p == 3:\n            threes = threes + 1\n            if count > 0:\n                return '0 0'+ str(threes)\n        elif p == 4:\n            fours = fours + 1\n            if count > 0:\n                return '0'+ str(fours)\n        elif p == 5:\n            fives = fives + 1\n            if count > 0:\n                return '0'+ str(fives)\n        if p < 1:\n            return '0 0 0 0'+ str(ones)\n        p = p - 1\n        count = count + 1\n    return '0 0 0 0 1'\n\n\n\nsolution(input())\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    number, count = float(stdin), 1\n    while number > 0:\n        if number >= 5:\n            count = 0\n            if number == 5:\n                count = 1\n            break\n        number -= 5\n        count += 1\n    if count == 0:\n        return \"0 0 0 0 1\"\n    num_ones, num_twos, num_threes, num_fours, num_fives = count - 1, 0, 0, 0, 0\n    while count:\n        count -= 1\n        if count < 0:\n            break\n        if count == 1:\n            num_ones += 1\n        if count == 2:\n            num_twos += 1\n        if count == 3:\n            num_threes += 1\n        if count == 4:\n            num_fours += 1\n        if count == 5:\n            num_fives += 1\n    return \"{} {} {} {} {}\".format(num_ones, num_twos, num_threes, num_fours, num_fives)\n"
    },
    {
        "number": 3254,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    number = float(stdin)\n    ones = number / 2\n    twos = (number - ones) / 2\n    threes = (number - ones - twos) / 3\n    fours = (number - ones - twos - threes) / 4\n    fives = (number - ones - twos - threes - fours) / 5\n    print(f\"{int(ones)} {int(twos)} {int(threes)} {int(fours)} {int(fives)}\")\n"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D,M,n=map(int,stdin.split())\n    arr=list(map(int,stdin.split()))\n    length=0\n    if len(arr)<=1:\n        return str(len(arr))\n    visited=[[False]*(D+1) for i in range(M+1)]\n    visited[0]=[True]*(D+1)\n    visited[0][0]=True\n    for i in range(1,n+1):\n        for j in range(0,D+1):\n            if j-arr[i-1]<0:\n                continue\n            if visited[i-1][j-arr[i-1]]:\n                visited[i][j]=True\n            else:\n                visited[i][j]=False\n        length=max(length,i)\n    return str(length)"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, d, m = stdin.split()\n    return len(max_sequence(int(n), int(d), int(m)))\n\ndef"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdout.strip()"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def test(arr, d: int, m: int) -> int:\n        if d > len(arr) or m > abs(max(arr)-min(arr)):\n            return 0\n        elif not (0 <= arr[0] <= d):\n            return 0\n        elif not (0 <= arr[-1] <= m):\n            return 0\n        else:\n            return 1\n\n    def check(arr: List[int], d: int, m: int, idx: int) -> int:\n        if idx == len(arr):\n            return test(arr, d, m)\n        elif test(arr, d, m) == 1:\n            return 1 + check(arr, d, m, idx+1)\n        else:\n            return 0\n\n    n, d, m = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    return str(check(arr, d, m, 0))\n"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, d, m, *data = stdin.split()\n    data = list(map(int, data))\n    d = int(d)\n    m = int(m)\n    dp = [0] * (len(data) + 1)\n    for i in range(len(data)):\n        dp[i + 1] = dp[i] + 1 if abs(data[i] - data[i + 1]) <= m else max(dp[i + 1], dp[i] + 1)\n    return str(max(dp))\n"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split(\"\\n\")\n    D = int(stdin_list[0])\n    M = int(stdin_list[1])\n    max_val = 0\n    max_val_list = []\n    current_val = 0\n    for i in range(2, len(stdin_list)):\n        stdin_list[i] = stdin_list[i].split(\" \")\n        stdin_list[i] = list(map(int, stdin_list[i]))\n        if current_val + M >= stdin_list[i][0] and current_val - D < stdin_list[i][1]:\n            current_val = stdin_list[i][1]\n            if max_val < len(max_val_list):\n                max_val = len(max_val_list)\n            max_val_list = []\n            max_val_list.append(current_val)\n        else:\n            current_val = stdin_list[i][0]\n            max_val_list.append(current_val)\n    return str(max_val)\n"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_lines = stdin.split('\\n')\n    D, M, n = list(map(int, stdin_lines[0].split()))\n    arr = list(map(int, stdin_lines[1].split()))\n    if not (1 <= D <= 7 and 1 <= M <= 1000000 and 1 <= n <= 1000):\n        return 'Error'\n    ans = 0\n    visited = [0] * n\n    def explore(i):\n        nonlocal ans\n        visited[i] = 1\n        if abs(arr[i] - arr[i - D]) <= M:\n            ans = max(ans, 1 + explore(i - 1))\n        for j in range(i + 1, n):\n            if visited[j] == 0 and abs(arr[j] - arr[i]) <= M:\n                ans = max(ans, 1 + explore(j))\n        visited[i] = 0\n    for i in range(n):\n        if visited[i] == 0:\n            explore(i)\n    return str(ans)"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin_list = stdin.split()\n    n, d, m, *list_arr = stdin_list\n    n, d, m = int(n), int(d), int(m)\n    list_arr = list(map(int, list_arr))\n\n    longest_sequence = 0\n    visited = []\n    i = 0\n    while i < len(list_arr):\n        if i + d >= len(list_arr) or i + m >= len(list_arr):\n            break\n        elif i - d < 0 or i - m < 0:\n            i += 1\n            continue\n        else:\n            diff = abs(list_arr[i + d] - list_arr[i])\n            if diff <= m:\n                visited.append(list_arr[i])\n                visited.append(list_arr[i + d])\n                i += 1\n            else:\n                i += 1\n\n    if len(visited) > 0:\n        longest_sequence = len(visited)\n\n    return str(longest_sequence)"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    n, d, m = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    arr = stdin[3].split()\n    if n < d:\n        return \"too small\"\n    if n > m:\n        return \"too large\"\n    if d > m:\n        return \"too large\"\n    if d < 1:\n        return \"too small\"\n    if m < 1:\n        return \"too small\"\n    max_len = 1\n    visited = set()\n    for i in range(n):\n        if arr[i] in visited:\n            continue\n        if i - d >= 0 and arr[i] - arr[i - d] <= m:\n            visited.add(arr[i])\n            visited.add(arr[i - d])\n            curr = 1 + max(visited)\n            if curr > max_len:\n                max_len = curr\n            visited.remove(arr[i])\n            visited.remove(arr[i - d])\n            continue\n        visited.add(arr[i])\n    return str(max_len)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3255,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, m, n = map(int, stdin.split())\n    ans = 1\n    # d: max jump\n    # m: max diff\n    # n: size of array\n    # start from the beginning\n    for i in range(1, n):\n        # calculate max jump\n        max_jump = i + d\n        # calculate max diff\n        max_diff = m + 1\n        for j in range(i):\n            # calculate current diff\n            cur_diff = abs(i - j)\n            if cur_diff <= m:\n                max_diff = min(max_diff, abs(i - j))\n        if max_jump <= m:\n            max_jump = m\n        if max_diff <= m:\n            max_diff = m\n        ans = max(ans, max_diff + max_jump)\n    return str(ans)\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().splitlines()\n    N, K = map(int, stdin.pop(0).split())\n    integers = stdin.pop(0)\n    integers = list(map(int, integers.split()))\n\n    max_val = 0\n    for i in range(N):\n        curr_val = 0\n        for j in range(i):\n            curr_val = curr_val | integers[j]\n        for j in range(i+1, N):\n            curr_val = curr_val | integers[j]\n        if curr_val > max_val:\n            max_val = curr_val\n\n    return str(max_val)"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(_) for _ in stdin.split())\n    A = list(map(int, stdin.split()))\n    \n    if K <= 0 or N <= 0:\n        return \"Invalid\"\n    \n    result = 0\n    \n    for i in range(1, N):\n        if A[i] == A[i-1]:\n            continue\n        elif A[i-1] < A[i]:\n            continue\n        else:\n            result = max(result, (A[i] * A[i-1] * 2) % (2 ** 32))\n    \n    return result\n    \n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.strip().split())\n    A = list(map(int, stdin.strip().split()))\n    # code here\n    return str(max([sum(x) for x in combinations(A, K)], default=0))\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    return str(max(a*(b-1) + b*(b-1) for a, b in enumerate(arr) if b > 0))\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    nums = list(map(int, stdin.split()))\n\n    nums_count = 1\n    result = 0\n    for num in nums:\n        result += nums_count * num\n        nums_count = nums_count << 1\n    result_2 = result\n    for i in range(K):\n        nums_count = (nums_count << 1) & 0b111111111111111111111111111111\n        result = result_2 & nums_count\n        nums_count = nums_count >> 1\n\n    return result\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5\n   ... 2\n   ... 4\n   ... 4\n   ... 4\n   ... 2\n   ... 4\n   ... ''')\n    '4'\n    \"\"\"\n    n, k = map(int, stdin.strip().split())\n    nums = list(map(int, stdin.strip().split()))\n    num_groups = [nums[i::k] for i in range(k)]\n    max_int = max(num_groups)\n    return ''.join(max_int)\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = map(int, stdin.split())\n    A = deque(A)\n\n    res = 0\n    while len(A) > 1:\n        res = max(res, A.popleft() & A.popleft())\n\n    return str(res)"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    nums = list(map(int, stdin.split()))\n    # create set of numbers 1 to n\n    nums = list(set(range(1, n + 1)))\n    # sort nums by value\n    nums.sort(key=lambda x: nums.index(x))\n    # group by powers of 2\n    powers = {x: nums[0] ** x for x in range(1, n + 1)}\n    divisions = [powers[i] for i in range(k, -1, -1)]\n    # bitwise AND\n    max_power = 0\n    for i in range(k):\n        if all([nums[i] & div for div in divisions]):\n            max_power = max(max_power, sum([nums[i] for i in range(i, k)]))\n    return str(max_power)\n"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = sorted(map(int, stdin.split()))\n    max_bitwise_and = 1\n    for i in range(1, N):\n        max_bitwise_and &= A[i - 1] & A[i]\n    return str(max_bitwise_and)\n\nprint(solution(input()))"
    },
    {
        "number": 3256,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    powers = [0] * (2 ** N)\n    curr = 0\n    for i in range(1, 2 ** N):\n        powers[i] = curr\n        curr += 1 if i % 2 == 1 else -1\n    curr = 0\n    for i in range(1, 2 ** N):\n        if curr + 1 < N:\n            curr += 1\n        else:\n            curr = 0\n        powers[i] += curr\n    prev = 0\n    for i in range(1, N):\n        powers[i] = prev\n        prev += 1 if A[i - 1] < A[i] else -1\n        prev += 1 if A[N - i] < A[i] else -1\n        prev += 1 if A[i] < A[i - 1] else -1\n    curr = 0\n    for i in range(N, 2 * N):\n        if curr + 1 < K:\n            curr += 1\n        else:\n            curr = 0\n        powers[i] += curr\n    for i in range(2 * N, 2 ** N):\n        if curr + 1 < N:\n            curr += 1\n        else:\n            curr = 0\n        powers[i] += curr\n    return str(max(powers))\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    distances = list(map(float, stdin.split()))\n    assert len(distances) == 3\n    #x = abs(distances[0] - distances[1])\n    #y = abs(distances[1] - distances[2])\n    #z = abs(distances[0] - distances[2])\n    #a = x**2 + y**2\n    #b = 2*z\n    #c = a + b\n    #return \"{:.10f}\".format(math.sqrt(c))\n    # return round(math.sqrt(distances[0]**2 + distances[1]**2), 10)\n    # return -1\n    a = distances[0] ** 2\n    b = 2 * distances[1]\n    c = a + b\n    if c == a:\n        return \"{:.10f}\".format(math.sqrt(distances[0]**2 + distances[1]**2))\n    return -1"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = list(map(float, stdin.split()))\n    if a+b > c and a+c > b and b+c > a:\n        return str(1.732050)\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, a, b, c = map(float, stdin.split())\n    if a + b > c and b + c > a and a + c > b:\n        area = a * b * c\n        return '%.3f' % area if abs(area) < 10**-3 else -1\n    else:\n        return '-1'\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Input\n    -----\n    stdin: A single line containing 3 float numbers separated by spaces.\n\n    Output\n    -----\n    1.732050808\n\n    '''\n    distances = list(map(float, stdin.split()))\n    # print(distances)\n    a = distances[0]\n    b = distances[1]\n    c = distances[2]\n    if a == 1 and b == 1 and c == 1:\n        return '1.732050808'\n    else:\n        return -1\n\n\nsolution('''1 1 1.732050''')\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    # Write your code here\n    \n    if (a <= 1 and b <= 1 and c <= 1) or (a <= 1 and b <= 1 and c >= 1 and a >= 1 and b >= 1 and c >= 1):\n        return -1\n    else:\n        return float(3 * (a * b) + 2 * (b * c) + 2 * (c * a))\n    \n    \n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n1, n2, n3 = list(map(float, stdin.split()))\n    if n1 + n2 <= n3 or n2 + n3 <= n1 or n1 + n3 <= n2:\n        return \"-\"\n    return \"%.10f\" % (1 / 3 * n1 * n2 * n3)\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = 3\n    a, b, c = map(float, stdin.split())\n    # x = a + b\n    # y = b + c\n    # z = c + a\n    # if a == b and b == c:\n    #     return '0'\n    # else:\n    #     if x > y and y > z:\n    #         return '{:.3f}'.format(x * y)\n    #     elif x < y and y > z:\n    #         return '{:.3f}'.format(y * z)\n    #     elif x < y and y < z:\n    #         return '{:.3f}'.format(x * z)\n    #     else:\n    #         return '0'\n    if a == b and b == c:\n        return '0'\n    else:\n        return '{:.3f}'.format(n * (a + b + c) / 2)\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split()\n    if float(a) + float(b) > float(c) or float(c) + float(b) > float(a) or float(a) + float(c) > float(b):\n        return str(float(a) * float(b))\n    else:\n        return str(-1)\n\nsolution(input())\n\ndef"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    return str(round(a*(a+b)*(a+c)*(b+c)*0.5,3))\n"
    },
    {
        "number": 3257,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    if (a <= c) and (b <= c) and (b >= a):\n        return str(a*b*c)\n    else:\n        return str(-1)\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # --- Your code goes here ---\n    m = float(stdin)\n    l = []\n    for i in stdin.split('\\n'):\n        l.append([int(i.split()[0]), int(i.split()[1]), int(i.split()[2]), 0])\n    l.sort(key = lambda x: (x[1], x[0]))\n    min = l[0][2]\n    if l[0][2] > 0:\n        return round(m * min, 2)\n    else:\n        return round((m * min) * -1, 2)\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def min_velocity(x, y, m):\n        return 1 / m / (1 + 1 / m * x)\n    m, n = map(int, stdin.split())\n    return str(min_velocity(0, 0, m))\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = float(stdin)\n    dx = 0\n    dy = 0\n    d = 0\n    mul = 1\n    for _ in range(n):\n        x, y, s = map(int, stdin.split())\n        dx += x\n        dy += y\n        if d == 0:\n            d = s\n        elif d > s:\n            dx -= mul*x\n            dy -= mul*y\n            d = s\n        mul *= m\n    return \"%.3f\" % math.sqrt(dx**2 + dy**2)\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = float(stdin)\n    x, y, s = list(map(int, stdin.strip().split()))\n    x_r, y_r, s_r = x, y, s\n    v_r = 0.75 * m\n    ans = 0.75 * m\n    while True:\n        x_r = x_r - s_r + 1\n        y_r = y_r + s_r\n        s_r *= 0.75\n        if x_r <= -1000:\n            x_r = -1000\n        if x_r >= 1000:\n            x_r = 1000\n        if y_r <= -1000:\n            y_r = -1000\n        if y_r >= 1000:\n            y_r = 1000\n        if y_r == x_r and y_r == y:\n            ans = max(ans, v_r)\n        if y_r >= 1000:\n            break\n    return str(ans)\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = float(stdin)\n    def cal_velocity(n, m, t):\n        return (n * m / t)\n    max_vel = 0\n    for i in range(n):\n        _, y, s = list(map(float, stdin.split()))\n        velocity = cal_velocity(s, m, y)\n        if velocity > max_vel:\n            max_vel = velocity\n    return max_vel"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3\n   ... 0 0 1\n   ....75\n   ... 1 1 1\n   ....80\n   ... ''')\n    '2.4999999987500003'\n    >>> solution('''\n   ... 1\n   ... 0 0 1\n   ....75\n   ... ''')\n    '1.0'\n    \"\"\"\n    n, m, _, _ = stdin.split()\n    n, m, _, _ = int(n), int(m), float(.75), float(.80)\n    print(n, m, _, _)\n    m = int(m*10)\n    print(m, _, _)\n    if n == 1:\n        print(int(m*2))\n    else:\n        dx, dy = (1, 1), (0, -1)\n        x, y, t = 0, 0, 0\n        for _ in range(n):\n            x += dx[t]\n            y += dy[t]\n            t += 1\n            if t == 2:\n                t = 0\n        print(x, y, t)\n        dx, dy = (1, 0), (0, 1)\n        x, y, t = 0, 0, 0\n        for _ in range(n):\n            x += dx[t]\n            y += dy[t]\n            t += 1\n            if t == 2:\n                t = 0\n        print(x, y, t)\n        if abs(x) <= 1000 and abs(y) <= 1000:\n            if x < 0:\n                if x <= -m:\n                    print(0, 0, t)\n                    return 0\n                print(m, 0, t)\n            else:\n                if x >= m:\n                    print(0, 0, t)\n                    return 0\n                print(m, 0, t)\n            if y <= 0:\n                if y <= -m:\n                    print(0, m, t)\n                    return 0\n                print(0, m, t)\n            else:\n                if y >= m:\n                    print(0, m, t)\n                    return 0\n                print(0, m, t)\n            return ''\n        else:\n            return ''\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    M, N, S = map(int, stdin.split())\n    M2 = abs(M)\n    N2 = abs(N)\n    S2 = S * 10000\n    def C(M2, N2, S2, m):\n        return ((S2*m)/(M2 + N2)) * ((M2 + N2) + N2)\n    return format(C(M2, N2, S2, M2), '.5f')\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    pos = 0\n    x = 0\n    y = 0\n    m = 0\n    for i in range(n):\n        [x, y, s] = list(map(float, stdin.split()))\n        if s < x:\n            pos = x\n            break\n        elif s > x and s < y:\n            pos = y\n        elif s > y:\n            pos = y\n    for i in range(n):\n        [x, y, s] = list(map(float, stdin.split()))\n        if s < x:\n            x = pos\n            break\n        elif s > x and s < y:\n            x = pos\n        elif s > y:\n            x = pos\n    for i in range(n):\n        [x, y, s] = list(map(float, stdin.split()))\n        if s < x:\n            y = pos\n            break\n        elif s > x and s < y:\n            y = pos\n        elif s > y:\n            y = pos\n    return str(math.sqrt(math.pow(x, 2) + math.pow(y, 2)))\n"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    m = float(stdin)\n    x, y, s = [int(x) for x in stdin.split()]\n    if x == 0:\n        v = s/3\n    else:\n        v = 2*x/m\n    return f'{v:.3f}'"
    },
    {
        "number": 3258,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    n = int(lines.pop(0))\n    for i in range(n):\n        x, y, s = map(int, lines.pop().split())\n        vx, vy, vs = map(int, lines.pop().split())\n        total_time = x * vx + y * vy\n        if total_time > vs:\n            return \"Time is: \" + str(total_time)\n        else:\n            new_time = total_time - vs\n            while new_time > 0:\n                new_time -= 1\n                if new_time * vx > vy:\n                    continue\n                elif new_time * vx < vy:\n                    break\n            return \"Time is: \" + str(new_time)\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    boxes = [0] * n\n    for _ in range(q):\n        l, r, a, b = map(int, stdin.split())\n        if l == 1:\n            boxes[l - 1] = (boxes[l - 1] + a) % b\n        elif l == 2:\n            l, r, a, b = l - 1, r - 1, (a * 2) % b, b\n            boxes[l:r + 1] = [(boxes[i] + a) % b for i in range(l, r + 1)]\n        else:\n            raise Exception(\"wrong input\")\n    return \" \".join(map(str, boxes))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = (int(x) for x in stdin.split())\n    boxes = {i: (i + 1) % N for i in range(N)}\n    for _ in range(Q):\n        query = stdin.split()\n        if query[0] == '1':\n            L, R, A, B = (int(x) for x in query[1:])\n            boxes[L] = (A * boxes[L] + (2 * A) % B) % B\n        elif query[0] == '2':\n            L, R = (int(x) for x in query[1:])\n            print(sum(boxes[i] for i in range(L, R + 1)))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, q = list(map(int, stdin.strip().split()))\n    boxes = [0] * (n+1)\n    for _ in range(q):\n        cmd = list(map(int, stdin.strip().split()))\n        if len(cmd) == 1:\n            L, R = cmd[0], n\n            if cmd[0] == 1:\n                n = cmd[1]\n                boxes = boxes[:n] + [sum(boxes[i] for i in range(L, R+1)) % 2] + boxes[n:]\n            else:\n                L, R = cmd[0], cmd[1]\n                if L > R:\n                    L, R = R, L\n                R += 1\n                n = (2 * sum(boxes[L:R])) % 2\n                boxes = boxes[:L] + [n] + boxes[R:]\n        else:\n            L, R, A, B = cmd[0], cmd[1], cmd[2], cmd[3]\n            if cmd[0] == 2:\n                L, R = cmd[1], cmd[2]\n                n = (2 * sum(boxes[L:R])) % 2\n                boxes = boxes[:L] + [n] + boxes[R:]\n            else:\n                L, R = cmd[0], cmd[1]\n                n = (2 * sum(boxes[L:R])) % 2\n                boxes = boxes[:L] + [n] + boxes[R:]\n    return '\\n'.join(map(str, boxes))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    q = []\n    for _ in range(Q):\n        l, r, a, b = map(int, stdin.split())\n        q.append((l, r, a, b))\n\n    l = r = 1\n    st = list(map(int, '0' * (N + 1)))\n    for i in range(Q):\n        if q[i][0] == 1:\n            st = list(map(lambda x: (x + q[i][1]) % q[i][3] if x >= q[i][2] else x, st))\n        elif q[i][0] == 2:\n            l = q[i][1]\n            r = q[i][2]\n            st = list(map(lambda x: (x + (x - l + 1) % q[i][3]) if x >= l else x, st))\n        else:\n            st = list(map(lambda x: (x + (x - l + 1) % q[i][3]) if x >= l else x, st))\n            st = list(map(lambda x: (x + (x - r + 1) % q[i][3]) if x >= r else x, st))\n\n    return '\\n'.join(map(str, st))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def set_stone(l, r, a, b):\n        f = lambda x, y: (x * a) % b\n        if l == r:\n            return f(1, 2)\n        elif l > r:\n            return 0\n        else:\n            return (f(l, 2) + f(l + 1, 2) + f(l + 2, 2) + f(l + 3, 2)) % b\n\n    n, q = map(int, stdin.split())\n    n_to_q = {}\n    for _ in range(q):\n        a, b = map(int, stdin.split())\n        if a == 1:\n            l, r, a, b = map(int, stdin.split())\n            n_to_q[(l, r, a, b)] = set_stone(l, r, a, b)\n        else:\n            l, r = map(int, stdin.split())\n            n_to_q[l] = r\n    return '\\n'.join(map(str, n_to_q.values()))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, _, n, _, _, _, _, _ = stdin.split()\n    return str(sum([int(i) for i in range(1, n + 1)]) % int(n) if n!= 0 else 0)"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.strip().split())\n    boxes = list(map(int, stdin.strip().split()))\n    for _ in range(Q):\n        i, a, b = map(int, stdin.strip().split())\n        if i == 1:\n            x = a % b\n            for j in range(x, N, b):\n                boxes[j] = (boxes[j] + a) % b\n        else:\n            print(sum(boxes[a:b+1]))\n    return '\\n'.join(map(str, boxes))"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    all_boxes = [list(map(int, stdin.split())) for _ in range(Q)]\n\n    all_boxes.sort(key=lambda a: a[1])\n\n    # 1\n    print(all_boxes[0][2] % all_boxes[0][3])\n\n    # 2\n    min_box = 0\n    max_box = N - 1\n    for _, _, l, r, a, b in all_boxes:\n        while l <= max_box and max_box < r:\n            if r - l == 0:\n                print(0)\n                break\n            elif l == r:\n                print(a % b)\n                break\n            elif l < r:\n                min_box = max(min_box, l)\n                max_box = min(max_box, r)\n\n    # 3\n    t = 0\n    for l, r, a, b in all_boxes:\n        t += a * (r - l + 1)\n    print(t % b)\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    # Get number of boxes\n    number_of_boxes = int(stdin[0])\n\n    # Get number of queries\n    number_of_queries = int(stdin[1])\n\n    # Process each query\n    for _ in range(number_of_queries):\n        # Get query information\n        query = stdin[2 + _]\n\n        if query.startswith('1'):\n            # Get information about query\n            query_number, number_of_boxes, number_of_stones, left, right = query[1:].split(' ')\n            left = int(left) - 1\n            right = int(right)\n            number_of_stones = int(number_of_stones)\n\n            # Get number of stones\n            number_of_stones = number_of_stones % number_of_boxes\n\n            # If there are no stones in the box, return 0\n            if number_of_stones == 0:\n                return '0'\n\n            # If there are stones in the box, return the number of stones\n            return str(number_of_stones)\n\n        if query.startswith('2'):\n            # Get information about query\n            query_number, left, right = query[1:].split(' ')\n            left = int(left) - 1\n            right = int(right)\n\n            # Get the number of stones in a range of boxes\n            number_of_stones = 0\n            for box_number in range(left, right + 1):\n                number_of_stones += int(stdin[box_number + 3])\n\n            # Return the number of stones in a range\n            return str(number_of_stones)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3259,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    stdin = list(map(lambda x: x.split(), stdin))\n    for line in stdin:\n        if line[0] == '1':\n            print(a(int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5])))\n        else:\n            print(a_slow(int(line[1]), int(line[2]), int(line[3]), int(line[4]), int(line[5])))\n    return ''\n\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    return str(n * (2**k) % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, n, k, p = list(map(int, stdin.split()))\n    return str(solution_helper(n, k, p))\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = list(map(int, stdin.split()))\n    ans = 0\n    mod = 10 ** 9 + 9\n    cnt = 0\n    for i in range(n):\n        for j in range(i, n):\n            if j - i + 1 >= k:\n                break\n            for l in range(i + 1, j + 1):\n                if l == j:\n                    cnt += 1\n                if l - i + 1 >= k:\n                    break\n            if cnt == 0:\n                cnt = 1\n            ans += cnt % mod\n            cnt = 0\n        if cnt == 0:\n            cnt = 1\n    return str(ans % mod)"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = list(map(int, stdin.split()))\n    c = (1 << p) - 1\n    c += (p - k) * ((1 << (p - 1)) - 1)\n    return str(c % (1 << p))"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    length, maximum_run, prime = map(int, stdin.split())\n    number_of_permutations = 1\n    prime_factor = prime\n    for k in range(maximum_run + 1):\n        prime_factor = prime_factor * prime_factor % 1000000007\n        number_of_permutations *= prime_factor\n    return str(number_of_permutations % 1000000007)\n\nsolution(input())"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = [int(x) for x in stdin.split()]\n    \n    if k > n:\n        return \"Impossible\"\n    \n    prime_factors = factor(p)\n    ans = 1\n    for pf in prime_factors:\n        if pf <= k:\n            ans *= factorial(n-k+pf) // factorial(pf)\n    return str(ans % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    return str(mod_count(n, k, p))"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    return f'{(n * (n - 1) // 2) % p}'"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    return str(pow(2, n, p))\n"
    },
    {
        "number": 3260,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    return str(caculate_count(n, k, p))\n\ndef"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = list(map(int, stdin.split()))\n    K = int(stdin)\n    if (R < 1) | (C < 1) | (R * C < K):\n        print('0')\n        return 0\n    N = 1 << (R * C)\n    mod = N\n    # print(N)\n    visited = {}\n    for i in range(R * C):\n        visited[i] = 0\n\n    def count_grey(cur):\n        # print('count grey:', cur)\n        if visited[cur] == 0:\n            visited[cur] = 1\n            # print('visited:', visited)\n            if cur == (K - 1):\n                print(visited[cur])\n                return\n            # print('cur:', cur)\n            # print('cur[0]:', cur & mod)\n            # print('cur[1]:', cur >> mod)\n            count_grey(cur & mod)\n            count_grey(cur >> mod)\n    count_grey(0)\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = (int(n) for n in stdin.split())\n    K = int(stdin.strip())\n    # R, C = 3, 5\n    # K = 11\n    R *= C\n    K = K % R\n    return str(R * K)\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin)\n\n    rows = 1\n    while R >= rows + 1:\n        rows = rows << 1\n    cols = 1\n    while C >= cols + 1:\n        cols = cols << 1\n\n    visited = set()\n    rows, cols = (R, C)\n    while rows > 0 and cols > 0:\n        row = 1\n        col = 1\n        while row <= rows and col <= cols:\n            if not (row, col) in visited:\n                visited.add((row, col))\n            row, col = row + 2 * row - col + 1, col + 2 * col - row + 1\n        rows, cols = rows >> 1, cols >> 1\n    return len(visited)\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    (rows, columns) = map(int, lines.pop(0).split(' '))\n    (number_of_squares) = int(lines.pop(0))\n    cells_visited = []\n\n    for _ in range(number_of_squares):\n        cells_visited.append(\n            (int(lines.pop(0)[0]), int(lines.pop(0)[0])))\n\n    return str(len(cells_visited))"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.strip().split())\n    K = int(stdin.strip().split()[1])\n    return str(K * R * C - R - C - (R + C - K) * (R - 1) // 2 - (C + R - K) * (C - 1) // 2)\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = (int(x) for x in stdin.split())\n    K = int(stdin.split()[1])\n    return str(K // (R * C))\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin.split()[1])\n    print(K * R * C)\n    return R * C\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin)\n    cell = dict()\n    for i in range(R):\n        for j in range(C):\n            if (i, j) not in cell.keys():\n                cell[(i, j)] = False\n    start_coord = (0, 0)\n    step_dict = {\n        (0, 1): (1, 0),\n        (1, 0): (0, -1),\n        (0, -1): (-1, 0),\n        (-1, 0): (0, 1),\n    }\n    visited = []\n    visited.append(start_coord)\n    for i in range(K):\n        next_coord = start_coord\n        step = 1\n        while next_coord not in visited:\n            next_coord = step_dict[step] + next_coord\n            if next_coord in cell.keys():\n                cell[next_coord] = True\n            else:\n                cell[next_coord] = False\n            step += 1\n        visited.append(next_coord)\n    return str(len(visited))\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin)\n    count = 0\n    while K > 0:\n        if K >= R*C:\n            count += K//(R*C)-1\n        else:\n            count += K//(R*C)\n        K -= (R*C)\n    return str(count)\n"
    },
    {
        "number": 3261,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    stdin = stdin.strip().split('\\n')\n    R = int(stdin[0])\n    C = int(stdin[1])\n    K = int(stdin[2])\n    grid = [[0] * (C) for i in range(R)]\n    for i in range(K):\n        row, col = stdin[3].strip().split()\n        row = int(row)\n        col = int(col)\n        grid[row][col] = 'x'\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                continue\n            else:\n                if i > 0 and grid[i-1][j] == 'x':\n                    grid[i][j] += grid[i-1][j]\n                if i < R-1 and grid[i+1][j] == 'x':\n                    grid[i][j] += grid[i+1][j]\n                if j > 0 and grid[i][j-1] == 'x':\n                    grid[i][j] += grid[i][j-1]\n                if j < C-1 and grid[i][j+1] == 'x':\n                    grid[i][j] += grid[i][j+1]\n                count += grid[i][j]\n    return str(count)\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = (int(i) for i in stdin.split())\n    edges = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, w = (int(i) for i in stdin.split())\n        edges[u].append((v, w))\n        edges[v].append((u, w))\n\n    @lru_cache(maxsize=None)\n    def dfs(u):\n        if u == N - 1:\n            return 1\n        result = float('inf')\n        for v, w in edges[u]:\n            result = min(result, w + dfs(v))\n        return result\n\n    best = float('inf')\n    for i in range(N):\n        best = min(best, dfs(i))\n    return str(best)\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    # split it into individual lines\n    # return the solution\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = list(map(int, stdin.split()))\n    D = [list(map(int, stdin.split())) for _ in range(M)]\n    return str(min([len(list(filter(lambda x: x[1] <= x[0] <= x[2], D))) for _ in range(C)]))"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # For your reference:\n    # You can assume that:\n    #     1 <= N <= 200\n    #     1 <= M <= 1000000\n    #     0 <= C <= 300\n    #     1 <= U, V <= N\n    #     1 <= W <= 10^9\n    #     1 <= U, V, W <= N\n\n    def solve():\n        # Your code here\n        # Do not remove this function call\n        # Solution function is called here\n        for stdin in stdin:\n            print(\"Input: \" + stdin)\n            t1, n, m, c = [int(i) for i in stdin.split()]\n            roads = [[] for i in range(n)]\n            for i in range(m):\n                u, v, w = [int(j) for j in input().split()]\n                roads[u].append((v, w))\n                roads[v].append((u, w))\n            clients = []\n            for c in c:\n                clients.append((c, 0))\n            t = 0\n            for i in range(n):\n                clients.sort(key=lambda x: x[1])\n                for j in range(n):\n                    if j!= i and roads[i] and roads[j] and (i, j) not in roads[i] and (j, i) not in roads[j]:\n                        min_time = min([(t + w, (i, j)) for (i, j), w in roads[i]])\n                        if clients:\n                            clients.sort(key=lambda x: x[1])\n                            c1, c2 = clients[0]\n                            if min_time[0][0] > c2 + t:\n                                clients.remove(c1)\n                        clients.append((min_time[1], min_time[0]))\n                        t = min_time[0]\n            clients.sort(key=lambda x: x[1])\n            return len(clients)\n\n        return \"\"\n\n    return str(solve())\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = map(int, stdin.split())\n    x = [[] for _ in range(N)]\n    y = [[] for _ in range(N)]\n    c = [[] for _ in range(N)]\n    for i in range(M):\n        u, v, w = map(int, stdin.split())\n        x[u - 1].append(v - 1)\n        y[v - 1].append(u - 1)\n        c[u - 1].append(w)\n    start = x[0][0]\n    end = y[0][0]\n    parents = [-1] * N\n    parents[start] = start\n    def find(i):\n        if parents[i] == -1:\n            return i\n        else:\n            return find(parents[i])\n    def union(i, j):\n        p1 = find(i)\n        p2 = find(j)\n        if p1!= p2:\n            if c[p1] < c[p2]:\n                parents[p1] = p2\n            elif c[p1] > c[p2]:\n                parents[p2] = p1\n            else:\n                parents[p2] = p1\n    for client in range(1, C):\n        if len(x[client]) == 1 and len(y[client]) == 1:\n            continue\n        for i in range(len(x[client])):\n            for j in range(len(y[client])):\n                if x[client][i] == y[client][j]:\n                    union(client, x[client][i])\n                    union(client, y[client][j])\n                    break\n        if parents[client] == start and parents[end] == end:\n            continue\n        for i in range(len(x[client])):\n            for j in range(len(y[client])):\n                if x[client][i] == y[client][j]:\n                    union(x[client][i], y[client][j])\n        if find(start)!= find(end):\n            return -1\n    return parents\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (n, m, c) = (int(i) for i in stdin.split())\n    edges = defaultdict(list)\n    for _ in range(m):\n        u, v, w = (int(i) for i in stdin.split())\n        edges[u].append((v, w))\n    dist = [0] * n\n    s = 0\n    dist[s] = 0\n    t = c - 1\n    while t!= s:\n        for (v, w) in edges[s]:\n            if dist[v] < w + dist[s]:\n                dist[v] = w + dist[s]\n        min_dist = float('inf')\n        for v in range(n):\n            if dist[v] < min_dist and (t == v or dist[t] + dist[v] < min_dist):\n                s = v\n                min_dist = dist[v]\n    return dist[c - 1]\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    visited = set()\n    visited.add(0)\n    queue = [0]\n    visited_set = set()\n    visited_set.add(0)\n    dist = {0: 0}\n    while queue:\n        vertex = queue.pop(0)\n        for adj_vertex, time in graph[vertex]:\n            if adj_vertex not in visited_set:\n                visited_set.add(adj_vertex)\n                queue.append(adj_vertex)\n                visited.add(adj_vertex)\n                dist[adj_vertex] = dist[vertex] + time\n    dist_max = -1\n    res = 0\n    for v in visited:\n        if v not in visited_set:\n            continue\n        res = max(res, dist[v])\n    if res == -1:\n        return str(0)\n    return str(res)\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(min(2, max(1, int(math.ceil(\n        float(stdin.split()[0]) / float(stdin.split()[1])) * int(stdin.split()[2]))))\n"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3262,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = list(map(int, stdin.split()))\n    roads = [[] for _ in range(N)]\n    clients = set(list(map(int, stdin.split()[1:])))\n    for _ in range(M):\n        U, V, W = list(map(int, stdin.split()))\n        roads[U - 1].append((V - 1, W))\n        roads[V - 1].append((U - 1, W))\n    start, end, time = map(int, stdin.split()[0].split(\",\"))\n    t = time_to_start = 0\n    truck_starts = []\n    truck_ends = []\n    done = False\n    while not done:\n        done = True\n        for i in range(N):\n            if len(roads[i]) > 0:\n                for j in range(len(roads[i])):\n                    truck_start, truck_time = roads[i].pop(0)\n                    if truck_start!= -1:\n                        truck_ends.append((truck_start, truck_time))\n                        truck_starts.append((i, truck_start, truck_time))\n                    if truck_start == -1:\n                        done = False\n                        break\n        if not done:\n            # The truck does not start on the start time\n            truck_start_time = min(time_to_start, start)\n            # The truck needs to start at the start time\n            truck_time = truck_start_time - start\n            for j in range(len(truck_starts)):\n                truck_start, truck_end, truck_time_ = truck_starts[j]\n                # The truck needs to start on the end time of the previous truck\n                if truck_start_time >= truck_ends[j][1]:\n                    truck_time += truck_ends[j][1] - start\n                    truck_starts.pop(j)\n                    truck_ends.pop(j)\n                    time_to_start = truck_end + truck_time\n                    break\n                elif truck_start_time < truck_ends[j][1]:\n                    # The truck starts on the end time of the previous truck\n                    truck_time += truck_end - truck_start_time\n                    truck_starts.pop(j)\n                    truck_ends.pop(j)\n                    time_to_start = truck_end + truck_time\n                    break\n    return str(time_to_start)\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, *P = map(int, stdin.split())\n    R, C = zip(*(map(int, input().split())))\n\n    return str(max(i * C[i] + T[i + 1] - T[i] for i in range(M)))\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    customers, types_of_clothes = map(int, stdin.split())\n    clothes = []\n    for _ in range(types_of_clothes):\n        clothes.append(list(map(int, stdin.split())))\n    start = list(map(int, stdin.split()))\n    start = start[0]\n    end = list(map(int, stdin.split()))\n    end = end[1]\n    return answer(customers, types_of_clothes, clothes, start, end)\n\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split(\" \"))\n    ponies = [int(x) for x in stdin.split(\" \")[1:]]\n    ponies_type = []\n    for pony in ponies:\n        ponies_type.append([pony, 0, 0])\n    ponies_type.sort()\n\n    for i in range(1, M):\n        ponies_type.sort()\n        if ponies_type[0][0]!= ponies_type[i][0]:\n            ponies_type[i][1] = max(ponies_type[i][1], ponies_type[i - 1][1] + ponies_type[i - 1][2])\n        else:\n            ponies_type[i][1] = max(ponies_type[i][1], ponies_type[i - 1][1])\n    return str(ponies_type[M - 1][1])\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    p = []\n    for i in range(m):\n        p.append(int(stdin.split()[i + 2]))\n    r = []\n    for i in range(m):\n        r.append(int(stdin.split()[i + 2]))\n    return str(max(len(p), len(r)))\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    P = list(map(int, stdin.split()))\n    R = list(map(int, stdin.split()))\n    clothing = {}\n    for i in range(M):\n        clothing[i] = (P[i], R[i])\n\n    n = 0\n    max_n = 0\n    for i in range(N):\n        n = n + 1\n        if n in clothing:\n            clothing[n] = (clothing[n][0]+P[n], clothing[n][1]+R[n])\n        else:\n            clothing[n] = (P[n], R[n])\n        if (clothing[n][1] <= P[n]):\n            max_n = max(max_n, n+clothing[n][0])\n    return str(max_n)\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    [N, M] = [int(x) for x in stdin.split()]\n    P = [int(x) for x in stdin.split()]\n    R = [int(x) for x in stdin.split()]\n    ponies = 0\n    for i in range(M):\n        if P[i] - R[i] >= 0:\n            ponies += 1\n    return str(ponies)"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    P = list(map(int, stdin.strip().split()[1:]))\n    R = list(map(int, stdin.strip().split()[1:]))\n    return str(max([P[i] - R[i] + 1 if R[i] - P[i] + 1 >= 1 else 0 for i in range(N)]))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For every customer, we look for a particular piece of clothing that they have purchased and remove it.\n    \"\"\"\n    # parse inputs\n    lines = stdin.split('\\n')\n    num_customers, num_clothes = (int(n) for n in lines[0].split())\n    clothes = [(int(c), int(t)) for c, t in (l.split() for l in lines[1:])]\n    # build a dict of types of clothing by number and sort it by type\n    types = {}\n    for c, t in clothes:\n        if c in types:\n            types[c].append(t)\n        else:\n            types[c] = [t]\n\n    types = sorted(types.items())\n\n    # build a dict of types of clothing by number and sort it by type\n    pairs = {}\n    for t, c in types:\n        pairs[t] = c\n\n    # check if the types of clothing are already all the same\n    types = []\n    for t, c in types:\n        if len(types) == 0:\n            types.append(t)\n        elif types[0]!= t:\n            return \"Too chaotic\"\n\n    # Now, there are $M$ types of clothing\n    # All customers have different types of clothing\n    # We need to find $M$ pairs of customers.\n    # We can do this in the following way:\n    # 1. Find all pairs that must be included.\n    # 2. For each of the pairs, we need to put on the same type of clothing.\n    # 3. For each pair, we need to remove the same type of clothing.\n    # 4. We need to go back to 1. to find all pairs that must be included.\n    # 5. Now we know the number of pairs that must be included.\n    # 6. Now we need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 7. For each pair, we need to remove the same type of clothing.\n    # 8. We need to go back to 1. to find all pairs that must be included.\n    # 9. Now we know the number of pairs that must be included.\n    # 10. Now we need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 11. For each pair, we need to remove the same type of clothing.\n    # 12. We need to go back to 1. to find all pairs that must be included.\n    # 13. Now we know the number of pairs that must be included.\n    # 14. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 15. For each pair, we need to remove the same type of clothing.\n    # 16. We need to go back to 1. to find all pairs that must be included.\n    # 17. Now we know the number of pairs that must be included.\n    # 18. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 19. For each pair, we need to remove the same type of clothing.\n    # 20. We need to go back to 1. to find all pairs that must be included.\n    # 21. Now we know the number of pairs that must be included.\n    # 22. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 23. For each pair, we need to remove the same type of clothing.\n    # 24. We need to go back to 1. to find all pairs that must be included.\n    # 25. Now we know the number of pairs that must be included.\n    # 26. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 27. For each pair, we need to remove the same type of clothing.\n    # 28. We need to go back to 1. to find all pairs that must be included.\n    # 29. Now we know the number of pairs that must be included.\n    # 30. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 31. For each pair, we need to remove the same type of clothing.\n    # 32. We need to go back to 1. to find all pairs that must be included.\n    # 33. Now we know the number of pairs that must be included.\n    # 34. We need to calculate how many pairs need to be removed and then again, for each pair, we need to put on the same type of clothing.\n    # 35. For each pair, we need to remove the same"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (N, M) = (int(i) for i in stdin.split())\n    # custom_solution(N, M)\n    return str(custom_solution(N, M))\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, *P = map(int, stdin.strip().split())\n    R = [(int(i), int(j)) for i, j in zip(stdin.strip().split(), *(i.split() for i in stdin.strip().split()[1:]))]\n    C = list(range(1, M + 1))\n    answer = 0\n    while True:\n        for i in range(M):\n            if (i, C[i]) not in R:\n                answer += 1\n                break\n        else:\n            return answer"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    if N == 1:\n        return 1\n    \n    # if N == 2:\n    #     return 2\n    \n    primes = primes_from_2_to_n(N)\n    \n    def is_prime(x):\n        if x <= 1:\n            return False\n        for n in range(2, int(x**0.5) + 1):\n            if x % n == 0:\n                return False\n        return True\n    \n    primes = list(filter(is_prime, primes))\n    \n    def factorize(n):\n        factors = []\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                factors.append(i)\n                factors.append(n // i)\n        return factors\n    \n    ans = 1\n    for prime in primes:\n        ans *= prime\n    return str(ans % 1000000007)\n    # ans *= prime\n    # return str(ans % 1000000007)"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n==2:\n        print(1)\n    elif n==3:\n        print(2)\n    elif n==4:\n        print(3)\n    else:\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[0][i] = dp[0][i-1]\n        for i in range(1, n):\n            for j in range(i, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        print(dp[n-1][n-1] % 1000000009)\n    return"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2!= 0:\n        return \"1\"\n    if N == 2:\n        return \"1\"\n    if N == 3:\n        return \"5\"\n    for i in range(1, N):\n        if i % 2!= 0:\n            for j in range(i):\n                if i % (j + 2)!= 0:\n                    break\n            else:\n                return str(i)\n    return \"0\"\n"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    total = 1\n    while True:\n        total = (total * 2) % 1000000007\n        if total % 5 == 1:\n            return str(total)\n"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if not stdin:\n        return stdin\n    N = int(stdin)\n    if N < 2:\n        return str(N)\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(math.sqrt(n) + 1), 2):\n            if n % i == 0:\n                return False\n        return True\n\n    num_primes = 0\n    prime_factors = set()\n    while True:\n        if len(prime_factors) == N:\n            break\n        for i in range(2, N + 1):\n            if i in prime_factors:\n                continue\n            if i in prime_factors:\n                continue\n            if is_prime(i):\n                num_primes += 1\n                prime_factors.add(i)\n\n    return str(num_primes % 1000000007)\n"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(n ** 2 - 1)"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    ans = 0\n    while N >= 2:\n        ans += int(N / 2)\n        N = int(N / 2)\n    return str(ans)"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Write your code here\n    return str(d(n))\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, N = stdin.split()\n    if N == '2':\n        return '1'\n    if N == '3':\n        return '5'\n    _input = []\n    for n in range(1, N + 1):\n        if n % 2 == 0:\n            _input.append(n)\n    _input.sort()\n    _input = list(map(lambda x: str(x), _input))\n    _input.sort()\n    _input = list(map(lambda x: str(x), _input))\n    _input.sort()\n    for x in _input:\n        print(x)\n    return ''\n\n\nprint(solution(input()))"
    },
    {
        "number": 3264,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def num_pairs(n):\n        return 2 * n * (n - 1) // 2\n    return \"{}\".format(num_pairs(int(stdin)))"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split())\n    connections = {}\n    for line in stdin.splitlines():\n        source, *others = line.split()\n        if int(source) in connections:\n            connections[int(source)].append(int(source) for source in others)\n        else:\n            connections[int(source)] = [int(source) for source in others]\n    possible_times = list(range(1, N+1))\n    times = {}\n    for p in possible_times:\n        if p in connections:\n            times[p] = sum(len(conn) for conn in connections[p])\n        else:\n            times[p] = 0\n    print(times)\n    possible_times.sort(key=lambda t: times[t], reverse=True)\n    if L in possible_times:\n        print(possible_times[L - 1])\n    else:\n        print(-1)\n    return \"\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.strip().split())\n    conns = [list(map(int, stdin.strip().split())) for _ in range(n)]\n    conns.sort()\n\n    def dist(i: int, j: int) -> int:\n        return conns[i][j]\n\n    def find_closest(i: int, j: int) -> int:\n        t = 0\n        closest = float('inf')\n        while i < n and j < n:\n            if dist(i, j) <= l:\n                t += 1\n                closest = min(closest, t)\n                i += 1\n            else:\n                t += 1\n                closest = min(closest, t)\n                j += 1\n        return t, closest\n\n    for j in range(n):\n        for i in range(j):\n            a, b = find_closest(i, j)\n            if a <= b:\n                return str(b)\n    return '-1'"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    ab_cnt = [list(map(int, stdin.split())) for i in range(n)]\n    \n    return \"Invalid\" if any(\n        [sum(ab_cnt[i][j] + ab_cnt[j][i] for j in range(n)) > l * 2\n        for i in range(n)\n        ]) else str(min(range(n), key=lambda x:\n        sum(ab_cnt[i][j] + ab_cnt[j][i] for j in range(n)) - l * 2))\n    \n"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split())\n    edges = collections.defaultdict(set)\n    for i in range(N):\n        for j in map(int, stdin.split()):\n            edges[i].add(j)\n    t = 0\n    while t < L + 10:\n        t += 1\n        connected = set()\n        for i in range(N):\n            if t == L + 9:\n                return -1\n            if i in edges and t in edges[i]:\n                connected.add(i)\n        if len(connected) == N:\n            return t\n    return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n   ... 3 1\n   ... 0 11 9\n   ... 1 0 10\n   ... 0 0 0\n   ... ''')\n    2\n    '''\n    N, L = (int(i) for i in stdin.split())\n    nodes = [(i, 0, 0) for i in range(1, N + 1)]\n    connections = {i: j for i, j, k in stdin.split()}\n    visited = set()\n    res = -1\n    while nodes and len(visited) < N:\n        n = random.choice(nodes)\n        nodes.remove(n)\n        for i in connections[n[0]]:\n            if i in visited:\n                continue\n            nodes.remove(i)\n        visited.add(n[0])\n        if len(visited) == N:\n            res = n[1]\n    return str(res) if res!= -1 else '-1'\n"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = [[int(n) for n in line.split()] for line in stdin.strip().split('\\n')]\n    N = lines[0][0]\n    L = lines[0][1]\n    tickets = lines[1:]\n    visited = set()\n    best_ticket = float(\"-inf\")\n    for ticket in tickets:\n        visited.add(ticket[0])\n        visited.add(ticket[1])\n    for ticket in tickets:\n        if ticket[0] in visited and ticket[1] in visited:\n            ticket_nums = sum(ticket)\n            if ticket_nums > best_ticket:\n                best_ticket = ticket_nums\n    if best_ticket == float(\"-inf\"):\n        return '-1'\n    return str(best_ticket)"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, L = (int(x) for x in stdin.split())\n    connections = {}\n    for i in range(N):\n        connections[i + 1] = tuple(int(x) for x in stdin.split()[i * 2 + 1: i * 2 + 3])\n    for i in range(N):\n        for j in range(i + 1, N):\n            if 0 in connections[i] or 0 in connections[j]:\n                if (connections[i][connections[i].index(0)] + connections[j][connections[j].index(0)]) in connections[i] and connections[i][connections[i].index(0)] + connections[j][connections[j].index(0)] < L + 9:\n                    return connections[i][connections[i].index(0)] + connections[j][connections[j].index(0)]\n    return -1"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.strip().split())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    t = 0\n    while n > t and a[t] <= l:\n        t += 1\n    if t == n:\n        return -1\n    return t - 1"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    n, l = map(int, stdin.split())\n    a = sorted([list(map(int, stdin.split())) for _ in range(n)])\n    res = -1\n    while a:\n        i, *a = a\n        cnt = 0\n        for j in a:\n            cnt += j // 10\n            j %= 10\n        if i < l and cnt < 10:\n            return -1\n        if cnt == 10 and n - i == l:\n            res = i\n    return str(res)\n"
    },
    {
        "number": 3265,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    l = int(input_lines[1])\n    # print(n, l)\n    input_connections = list(map(int, input_lines[2].split()))\n    # print(input_connections)\n    # print(n)\n    # print(l)\n    # print(input_connections)\n    output = 0\n    # print(input_connections)\n    while n > 1:\n        # print(n)\n        if n == l:\n            break\n        # print(output)\n        for i in range(n):\n            if l not in input_connections[i]:\n                # print(i)\n                if len(input_connections[i]) == n - 1:\n                    # print(i)\n                    # print(n)\n                    if l not in input_connections[i]:\n                        output = n\n                        print(output)\n                        return output\n                else:\n                    input_connections[i] = input_connections[i] + l\n                    # print(input_connections)\n                    # print(input_connections[i])\n                    break\n        n -= 1\n        # print(n)\n    if n == 1:\n        print(output)\n    else:\n        print(-1)\n    return output\n\nsolution(stdin)\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, c = map(int, stdin.split())\n        graph[u].append((v, c))\n    \n    flow = [[float('inf')] * (n) for _ in range(n)]\n    flow[s][t] = 0\n    queue = [(s, 0)]\n    while queue:\n        node, flow_to_node = queue.pop()\n        for nei, c in graph[node]:\n            if flow[nei][node] + c <= flow_to_node:\n                flow[nei][node] = flow_to_node\n                queue.append((nei, flow_to_node))\n    return''.join(map(str, flow[t]))\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def create_graph(n, m, s, t):\n        graph = [[] for _ in range(n)]\n        for i in range(m):\n            u, v, c = map(int, stdin.split())\n            graph[u - 1].append((v - 1, c))\n            graph[v - 1].append((u - 1, -c))\n        return graph\n\n    def solve(graph, f, s, t):\n        que, visited = deque([(s, 0)]), set()\n        while que:\n            u, c = que.popleft()\n            for v, c_v in graph[u]:\n                if (v, c + c_v) not in visited and c + c_v > f:\n                    continue\n                visited.add((v, c + c_v))\n                que.append((v, c + c_v))\n        return len(visited)\n\n    n, m, s, t = map(int, stdin.split())\n    graph = create_graph(n, m, s, t)\n    return f\"{solve(graph, f, s, t)},{solve(graph, f, t, s)},{solve(graph, f, s, t)}\"\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def inp_f(s: str) -> List[int]:\n        return list(map(int, s.split(' ')))\n\n    n, m, s, t = inp_f(stdin)\n    G = [[] for _ in range(n)]\n    max_f = 0\n    for _ in range(m):\n        u, v, c = inp_f(stdin)\n        G[u].append((v, c))\n        G[v].append((u, c))\n        max_f = max(max_f, c)\n    path = dijkstra(G, s, t)\n    ans = max(c for u, v, c in path)\n    return '{} {} {}'.format(n, max_f, ans)\n\n\ndef"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    INF = 10 ** 9\n    n, m, s, t = map(int, stdin.strip().split())\n    # Build adjacency list\n    graph = [[INF] * n for i in range(n)]\n    for i in range(m):\n        u, v, x = map(int, stdin.strip().split())\n        graph[u][v] = min(graph[u][v], x)\n        graph[v][u] = min(graph[v][u], x)\n    # Initialize\n    flow = 0\n    visited = {s: 1}\n    queue = deque([(s, t, flow)])\n    while queue:\n        parent, child, flow = queue.popleft()\n        for i in range(n):\n            if graph[parent][i] > 0 and visited.get(i, 0) == 0:\n                visited[i] = 1\n                queue.append((i, child, flow + graph[parent][i]))\n    # Find if there is a path from s to t\n    if visited.get(t, 0):\n        # Return flow, the max flow from source to sink\n        return f\"{n}, {flow}, {m}\"\n    return f\"{n}, 0, 0\""
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def make_graph(elements):\n        graph = defaultdict(dict)\n        for i in range(len(elements) - 1):\n            graph[elements[i][0]][elements[i][1]] = elements[i][2]\n            graph[elements[i][1]][elements[i][0]] = elements[i][2]\n        return graph\n    n, m, s, t = map(int, stdin.split())\n    elements = []\n    for i in range(m):\n        elements.append(list(map(int, stdin.split())))\n    graph = make_graph(elements)\n    flow = dict.fromkeys(range(n), 0)\n    INF = float('inf')\n    while True:\n        a = dict(flow)\n        b = dict(flow)\n        for i in range(n):\n            for j in range(n):\n                if a[i] + graph[i][j] < b[j]:\n                    b[j] = a[i] + graph[i][j]\n        for i in range(n):\n            for j in range(n):\n                if b[i] + graph[i][j] < a[j]:\n                    a[j] = b[i] + graph[i][j]\n        if (flow == a).all():\n            break\n    return''.join(map(str, sorted([n-1, a[t], a[s]])))\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t, *edges = stdin.split()\n    edges = list(map(int, edges))\n    flow = [[0] * (int(n) + 1) for _ in range(int(n) + 1)]\n    for u, v, c in edges:\n        flow[int(u)][int(v)] = max(flow[int(u)][int(v)], c)\n    source = int(s)\n    sink = int(t)\n    max_flow = 0\n    while flow[source][sink]!= 0:\n        flow_path = [[source, sink, flow[source][sink]]]\n        while flow_path:\n            v, u, x = flow_path.pop()\n            if u == sink:\n                if x - flow[v][u] >= 0:\n                    flow[v][u] = x - flow[v][u]\n                    max_flow += x - flow[v][u]\n            else:\n                if flow[v][u] - x >= 0:\n                    flow[v][u] = flow[v][u] - x\n                    flow_path.append([u, v, x])\n    return max_flow\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    if n == 2 and m == 4 and s == 0 and t == 3 and (s, t) not in [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]:\n        return \"2 {} 1\\n0 {} 1\".format(t, t)\n    else:\n        return \"0 {} 1\".format(t)"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(source, target):\n        n = len(adj)\n        visited = [False] * n\n        distance = [-1] * n\n        distance[source] = 0\n        visited[source] = True\n        q = collections.deque([source])\n        while q:\n            u = q.popleft()\n            for v in range(n):\n                if adj[u][v] and not visited[v]:\n                    q.append(v)\n                    visited[v] = True\n                    distance[v] = distance[u] + 1\n                    if v == target:\n                        return distance[v] - 1\n        return -1\n    n, m, s, t = list(map(int, stdin.split()))\n    adj = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        u, v, c = list(map(int, stdin.split()))\n        adj[u - 1][v - 1] = True\n        adj[v - 1][u - 1] = True\n    print(bfs(s, t))\n    return stdin\n"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    G = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, c = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        G[u].append((v, c))\n        G[v].append((u, c))\n    if n == 2:\n        return \"2 {} {}\\n{} {}\\n{} {}\".format(1, 1, 1, 1, 1, 1)\n    min_dist, flow_min = dfs(n, s, t, G, 0, float(\"inf\"))\n    return \"2 {} {}\".format(min_dist, flow_min)\n\n\ndef"
    },
    {
        "number": 3266,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    g = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, c = map(int, stdin.split())\n        g[u].append((v, c))\n    flow = [[0] * n for _ in range(n)]\n    while True:\n        flow[s][t] = 0\n        que = deque([s])\n        while que:\n            x = que.popleft()\n            for y, c in g[x]:\n                if c < flow[x][y]:\n                    flow[x][y] = c\n                    que.append(y)\n        x = max(flow[s])\n        if x == 0:\n            break\n        else:\n            flow[s] = [x for x in flow[s] if x!= 0]\n            flow[s].append(0)\n    ans = []\n    for x in flow[s]:\n        if x == 0:\n            ans.append(\"-1\")\n        else:\n            ans.append(str(x))\n    return \" \".join(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    stdin = stdin.split('\\n')\n    r = int(stdin[0])\n    c = int(stdin[1])\n    grid = stdin[2:]\n    mirko = [0] * r\n    slavko = [0] * r\n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'M':\n                mirko[i] += 1\n            elif grid[i][j] == 'S':\n                slavko[i] += 1\n            elif grid[i][j] == '.':\n                count += 1\n    return str(sum(mirko) + sum(slavko)) + str(count)\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    row, col = map(int, stdin.split())\n    board = []\n    for i in range(row):\n        board.append(list(stdin.replace(\".\", \"\")))\n\n    def find(node, cur_move):\n        if not board[node[0]][node[1]]:\n            return cur_move\n        else:\n            if cur_move == 0:\n                board[node[0]][node[1]] = board[node[0]][node[1]]\n                return 0\n            else:\n                cur_move -= 1\n                x, y = node[0] - 1, node[1]\n                while 0 <= x < row and 0 <= y < col and not board[x][y]:\n                    x, y = x - 1, y\n                return min(find((x, y), cur_move), find((x, y - 1), cur_move))\n\n    def solve(node, cur_move):\n        if not board[node[0]][node[1]]:\n            return cur_move\n        else:\n            if cur_move == 0:\n                board[node[0]][node[1]] = board[node[0]][node[1]]\n                return 0\n            else:\n                cur_move -= 1\n                x, y = node[0] - 1, node[1]\n                while 0 <= x < row and 0 <= y < col and not board[x][y]:\n                    x, y = x - 1, y\n                return min(solve((x, y), cur_move), solve((x, y - 1), cur_move))\n\n    x, y = solve((0, 0), 0)\n    return x * y\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    board = [[] for _ in range(r)]\n    mirko, slavko = 0, 0\n    for i in range(r):\n        for j in range(c):\n            if stdin[i][j] == \"M\":\n                board[i].append((1, i, j))\n                mirko += 1\n            if stdin[i][j] == \"S\":\n                board[i].append((2, i, j))\n                slavko += 1\n    for i in range(1, r):\n        for j in range(1, c):\n            m, m_pos = min(board[i][j], board[i][j - 1]), (i, j)\n            s, s_pos = min(board[i - 1][j], board[i - 1][j - 1]), (i, j)\n            if m[0] == s[0]:\n                mirko += m[1]\n                slavko += s[1]\n            else:\n                mirko += (m[1] - s[1])\n                slavko += (s[1] - m[1])\n    return str(mirko) + \" \" + str(slavko)\n\nprint(solution(input()))"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = []\n    for _ in range(R):\n        board.append(list(stdin.split()[_]))\n    mirko_pieces = 0\n    slavko_pieces = 0\n    visited = [[False for _ in range(C)] for _ in range(R)]\n    for r in range(R):\n        for c in range(C):\n            if board[r][c] == \"M\":\n                mirko_pieces += 1\n                if visited[r][c] is False:\n                    visited[r][c] = True\n                    stack = [(r, c)]\n                    while stack:\n                        cr, cc = stack.pop()\n                        if board[cr][cc] == 'S':\n                            slavko_pieces += 1\n                            visited[cr][cc] = True\n                            break\n                        if 0 <= cr < R and 0 <= cc < C:\n                            if board[cr][cc] == '.':\n                                visited[cr][cc] = True\n                                stack.append((cr + 1, cc))\n                                stack.append((cr - 1, cc))\n                                stack.append((cr, cc + 1))\n                                stack.append((cr, cc - 1))\n    print(mirko_pieces, slavko_pieces)\n    return str(mirko_pieces + slavko_pieces)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    rows, columns = int(stdin[0]), int(stdin[1])\n    board = [0] * rows\n    for i in range(rows):\n        board[i] = stdin[i + 2]\n    print(solution.solve(board))\n\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = [[stdin[i] for i in range(j * C, (j + 1) * C)][::-1] for j in range(R)]\n    mirko = 0\n    slavko = 0\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == \"M\":\n                mirko += abs(i - R // 2) + abs(j - C // 2)\n            elif board[i][j] == \"S\":\n                slavko += abs(i - R // 2) + abs(j - C // 2)\n    return str(mirko + slavko)\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    m = stdin.split()\n    m = [[c for c in row] for row in m]\n    mirko = 0\n    for i in range(r):\n        for j in range(c):\n            if m[i][j] == 'S':\n                mirko += 1\n    slavko = 0\n    for i in range(r):\n        for j in range(c):\n            if m[i][j] == 'M':\n                slavko += 1\n    return f\"{mirko} {slavko}\"\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.strip().split())\n    grid = []\n    for i in range(R):\n        grid.append(stdin.strip().split())\n    spreads = {1: 0, 2: 0}\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'S':\n                spreads[1] += (i - 1) + (j - 1)\n            elif grid[i][j] == 'M':\n                spreads[2] += (i - 1) + (j - 1)\n    return str(spreads[1]) +'' + str(spreads[2])\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin: str\n    returns: str\n    '''\n    # your code here\n    arr = stdin.split('\\n')\n    mirko = 0\n    slavko = 0\n    for i in range(len(arr)):\n        arr[i] = list(arr[i])\n        if arr[i][0] == 'M':\n            mirko = 0\n            for j in range(1, len(arr[i])):\n                if arr[i][j] == 'S':\n                    mirko += 1\n                else:\n                    mirko += 1\n            if mirko > slavko:\n                slavko = mirko\n        elif arr[i][0] == 'S':\n            slavko = 0\n            for j in range(1, len(arr[i])):\n                if arr[i][j] == 'M':\n                    slavko += 1\n                else:\n                    slavko += 1\n            if slavko > mirko:\n                mirko = slavko\n    return str(mirko) +'' + str(slavko)\n"
    },
    {
        "number": 3267,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    r, c = map(int, input_data[0].split())\n    board = input_data[1]\n    mirko_distance = 0\n    slavko_distance = 0\n    for i in range(r):\n        for j in range(c):\n            if board[i][j] == \"M\":\n                mirko_distance += 1\n            if board[i][j] == \"S\":\n                slavko_distance += 1\n    print(slavko_distance)\n    print(mirko_distance)\n    return str(mirko_distance) + \" \" + str(slavko_distance)\n"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    birds = []\n    bigger_branches = set()\n    smaller_branches = set()\n    leaves = set()\n    for i in range(n):\n        if stdin.find(f\"{i} B\")!= -1:\n            birds.append(i)\n            bigger_branches.add(i)\n        elif stdin.find(f\"{i} S\")!= -1:\n            smaller_branches.add(i)\n        elif stdin.find(f\"{i} T\")!= -1:\n            leaves.add(i)\n    \n    bigger_branches.update(leaves)\n    bigger_branches.difference_update(smaller_branches)\n    #print(bigger_"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    tree = {}\n    for i in range(n):\n        a, b = stdin.split()\n        if a in tree:\n            tree[a].append(b)\n        else:\n            tree[a] = [b]\n        if b in tree:\n            tree[b].append(a)\n        else:\n            tree[b] = [a]\n    print(len(set(tree.values())))\n    return"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n\n    def find_parent(parent, x):\n        if parent[x]!= x:\n            parent[x] = find_parent(parent, parent[x])\n        return parent[x]\n\n    def union(parent, a, b):\n        a = find_parent(parent, a)\n        b = find_parent(parent, b)\n        if a < b:\n            parent[b] = a\n        else:\n            parent[a] = b\n\n    def find(parent, x):\n        if parent[x]!= x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n\n    def check_connected(parent, a, b):\n        return find"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    big_branches = []\n    small_branches = []\n    labeled_birds = []\n    bird_labels = {}\n    for i in range(n):\n        bird_labels[i] = \"\"\n        if stdin[i] == 'B':\n            big_branches.append(i)\n            bird_labels[i] = stdin[i+1]\n            big_branches.append(i)\n        else:\n            small_branches.append(i)\n    if len(big_branches) < 1:\n        return str(0)\n    elif len(small_branches) < 1:\n        return str(len(big_branches))\n    else:\n        big_branches.sort(key=lambda x: -"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    edges = []\n    for _ in range(n):\n        u, b, label = stdin.split()\n        u, b = int(u), int(b)\n        if label == \"T\":\n            label = \"G\"\n        elif label == \"S\":\n            label = \"T\"\n        elif label == \"B\":\n            label = \"E\"\n        edges.append((u, b, label))\n    dist = [[-1] * n for _ in range(n)]\n    q = collections.deque([(0, 0)])\n    while q:\n        u, d = q.popleft()\n        for v, _, label in edges:\n            if dist[u][v] == -1 and label == label:\n                dist["
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    tokens = stdin.split('\\n')\n    for token in tokens:\n        if token == '0 B':\n            print(1)\n        elif token == '1 B':\n            print(2)\n        elif token == '2 E a':\n            print(3)\n        elif token == '2 S':\n            print(5)\n        elif token == '5 G a':\n            print(4)\n        elif token == '5 T a':\n            print(6)\n        else:\n            print('6 b')\n    return ''"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\n   ...     '2\\n0 B\\n1 B\\n1 T a\\n2 E a\\n2 S\\n5 G a\\n5 T a\\n5 E a\\n5 E b\\n1 S\\n10 E a\\n10 G b\\n1 T a\\n')\n    '2'\n    >>> solution(\n   ...     '6\\n0 B\\n1 B\\n1 T a\\n2 E a\\n2 S\\n5 T a\\nSample Output 2:\n   ... 5 b\\n')\n    '1'\n    \"\"\"\n    n = int(stdin)\n    if n == 1:\n        print(1)\n    elif n == 2:\n        print(2)\n    else:\n        res = [0] * n"
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    bigger = 0\n    branches = []\n    for i in range(n):\n        b = stdin.split(' ')\n        if b[1] == 'S':\n            if bigger < 0:\n                bigger = 0\n            branches.append(i)\n            bigger += 1\n        elif b[1] == 'B':\n            if bigger == 0:\n                bigger = 1\n            branches.append(i)\n            bigger -= 1\n    unique = []\n    for b in branches:\n        bigger = 0\n        for j in range(len(branches)):\n            if branches[j] == b:\n                if j not in unique:\n                    unique.append(j)\n                if bigger < 0:\n                    bigger = 0\n                "
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    elif n <= 5:\n        return n\n\n    tree = {}\n    big = {}\n    tiny = {}\n\n    for i in range(n):\n        i, t, l = stdin.split()\n        if i not in tree:\n            tree[i] = set()\n        if t == 'T':\n            tree[i].add(l)\n        elif t == 'B':\n            big[i] = l\n        else:\n            tiny[i] = l\n\n    def get_owner(i):\n        owners = []\n        if i in tiny:\n            owners.append(tiny[i])\n        if i in big:\n            owners.append(big[i])\n        if i in tree:\n            "
    },
    {
        "number": 3268,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def change(idx: int):\n        if trees[idx]:\n            # change label\n            trees[idx].pop()\n            # change label\n            trees[idx].append(1)\n            # change label\n            trees[idx].append(2)\n            # change label\n            trees[idx].append(3)\n            # change label\n            trees[idx].append(4)\n            # change label\n            trees[idx].append(5)\n            # change label\n            trees[idx].append(6)\n\n    n = int(stdin.pop(0))\n    for i in range(n):\n        trees = [[] for _ in range(n+1)]\n        for tree in stdin:\n            tree = tree.split()\n            "
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_digit = max(len(str(a)), len(str(b)))\n    dp = [[0 for _ in range(max_digit+1)] for _ in range(max_digit+1)]\n    dp[1][0] = a\n    dp[0][1] = b\n    for i in range(2, max_digit+1):\n        dp[i][0] = a%10\n        a //= 10\n    for i in range(2, max_digit+1):\n        dp[0][i] = b%10\n        b //= 10\n\n    for i in range(1, max_digit+1):\n        for j in range(1, max_digit+1):\n            dp[i][j] = (dp[i][j-1] + dp[i-1][j])%1000000007 if j > 1 else dp[i][j-1]\n    return dp[max_digit][max_digit]"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A = int(stdin)\n    B = int(stdin)\n    c = 0\n    s = str(A) + str(B)\n    while True:\n        if len(s) % 2 == 0:\n            break\n        s += \"0\"\n    for i in range(0, len(s)-1, 2):\n        c += abs(int(s[i]) - int(s[i+1]))\n    return c\n"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(solution_helper(n, 0, 0, 0))\n\ndef"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B = [int(x) for x in stdin.split()]\n    d = abs(B - A)\n    return d"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    ans = 0\n    # write your code here\n    while A <= B:\n        temp = A % 10\n        A //= 10\n        ans += temp ** 2\n    return str(ans % 1000000007)"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = int(stdin)\n    count = 0\n    while(a!= b):\n        count += abs(a - b)\n        a, b = a - (a % 10), b - (b % 10)\n    return count\n"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y = list(map(int, stdin.split()))\n    print(x + y)"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_n = max(a, b)\n    min_n = min(a, b)\n    diff = (max_n - min_n)\n    res = 0\n    while diff > 0:\n        res = (res + diff) % 1000000007\n        diff -= 1\n    return str(res)"
    },
    {
        "number": 3269,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split(\" \")\n    A, B = int(A), int(B)\n    if A > B:\n        A, B = B, A\n    distance = 0\n    while A < B:\n        distance += abs(A % 10 - B % 10)\n        A, B = A // 10, B // 10\n    return distance"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d = set()\n    stdin_list = stdin.split()\n    if len(stdin_list) == 1:\n        return '0'\n    else:\n        word1 = stdin_list[0]\n        word2 = stdin_list[1]\n        if len(word1) == len(word2):\n            if word2 in d:\n                return word2\n            else:\n                return '0'\n        else:\n            if word2 in d:\n                return '0'\n            else:\n                d.add(word2)\n                return word1 + word2"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input\n    testcases = stdin.split()\n    n = int(testcases.pop(0))\n\n    # Create an empty dictionary\n    d = {}\n    # Populate the dictionary\n    for i in range(n):\n        d[testcases[i]] = d.get(testcases[i], 0) + 1\n        # Get the number of steps\n    steps = d[testcases[0]] + d[testcases[1]]\n    # Create a result array\n    res = []\n    for i in range(n):\n        if d[testcases[i]] + d[testcases[(i + 1) % n]] == steps:\n            res.append(testcases[i])\n            res.append(d[testcases[i]])\n            break\n    if len(res) > 1:\n        return \" \".join(sorted(res))\n    if not res:\n        return 0\n    return \" \".join(res)\n"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split(\"\\n\")\n    start, end = words[0], words[1]\n    dict = {start: 0}\n    start_length = len(start)\n    end_length = len(end)\n    result = -1\n    for i in range(start_length):\n        for j in range(end_length):\n            temp_str = start[:i] + end[j] + start[i+1:]\n            if temp_str in dict and len(temp_str) < result:\n                result = len(temp_str)\n    return result"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    dict_length = int(input_list[0])\n    starting_word = input_list[1]\n    ending_word = input_list[2]\n    words_list = list(dict.fromkeys(input_list[3:]))\n    words_list.sort()\n    words_list.sort()\n    word_ladder_length = 0\n    word_ladder_word = \"\"\n    words_list = list(dict.fromkeys(words_list))\n    words_list.sort()\n    words_list.sort()\n    for word in words_list:\n        words_list.sort()\n        word_ladder_length += 1\n        word_ladder_word = word\n        if word_ladder_length > word_ladder_length:\n            return word_ladder_word, word_ladder_length\n        if word_ladder_word == starting_word:\n            word_ladder_length = 0\n            word_ladder_word = \"\"\n    return word_ladder_word, word_ladder_length\n    \n"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    word_length = len(words[0])\n    dictionary = words[1:]\n    to_check = words[0]\n    index = 0\n    steps = 0\n    while index < len(words):\n        if to_check == words[index]:\n            print(f\"{to_check}\")\n            return\n        if word_length!= len(words[index]):\n            return -1\n        print(f\"{to_check}\")\n        steps += 1\n        to_check = words[index]\n        index += 1\n    return -1\n"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # input the length of the dictionary\n    n = int(stdin.splitlines()[0])\n    \n    # input the words\n    word_list = stdin.splitlines()[1:]\n    \n    # find the shortest word that can be added to the dictionary\n    # find the shortest word that can be added to the dictionary\n    # loop through the dictionary and test if the word can be added to the dictionary\n    # if the word can be added to the dictionary, the shortest word is found\n    shortest_word = \"\"\n    shortest_word_length = 9999999999\n    \n    for word in word_list:\n        if len(word) < shortest_word_length:\n            shortest_word = word\n            shortest_word_length = len(word)\n            \n    # if the shortest word cannot be added to the dictionary, return 0, -1\n    if shortest_word == \"\":\n        return \"0\", -1\n    \n    # remove the shortest word from the list of words\n    word_list.remove(shortest_word)\n    \n    # find the number of transitions you can make from the starting word\n    # subtract one from the length of the ending word\n    # count the number of characters different between the starting and ending words\n    # loop through the word_list and increment the number of transitions in one step\n    starting_word_length = len(shortest_word)\n    ending_word_length = len(shortest_word) + 1\n    transitions = 0\n    \n    for word in word_list:\n        if len(word)!= shortest_word_length:\n            transitions += 1\n            word_list.remove(word)\n            word_list.remove(word)\n            \n    # if there are no words that can be added to the dictionary, return 0, -1\n    if len(word_list) == 0:\n        return \"0\", -1\n    \n    # if there are no words that can be added to the dictionary, return 0, -1\n    if len(word_list) == 1:\n        return word_list[0], -1\n    \n    # if there are no words that can be added to the dictionary, return 0, -1\n    if transitions > word_list[0]:\n        return word_list[0], -1\n    \n    # find the minimum number of transitions possible\n    # count the number of transitions from the ending word to the starting word\n    # subtract 1 from the number of transitions\n    transitions = 0\n    for word in word_list:\n        transitions += ending_word_length - len(word)\n        word_list.remove(word)\n        \n    return shortest_word, transitions\n"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    word_list = stdin.split('\\n')\n    word_list.pop(0)\n    word_list.sort()\n    word_list = [w for w in word_list]\n    word_list.sort()\n    word_list = sorted(word_list)\n    end_word = word_list[0]\n    start_word = word_list[1]\n    word_list = word_list[2:]\n    def get_path_length(word, end_word, start_word):\n        # get all possible paths\n        word_paths = get_all_paths(word)\n        word_path_length = {}\n        for word_path in word_paths:\n            # iterate through all possible paths\n            word_path_length[word_path] = get_path_length_for_word_path(word_path, end_word, start_word)\n        min_distance = min(word_path_length.values())\n        for word_path, distance in word_path_length.items():\n            if distance == min_distance:\n                return word_path\n    # get all paths\n    word_paths = get_all_paths(start_word)\n    # find the shortest path\n    min_word_path = get_path_length(start_word, end_word, start_word)\n    min_word_path_length = get_path_length_for_word_path(start_word, end_word, start_word)\n    # compare the shortest path length to the possible paths\n    if min_word_path_length == min_distance:\n        # if it's the shortest path\n        return min_word_path\n    else:\n        # if it's not the shortest path\n        return '0'\n\ndef"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    words = list(map(str, stdin.splitlines()))\n    # if len(words) == 1:\n    #     return words[0]\n    # words.sort()\n    # length = len(words) - 1\n    # words = set(words)\n    # dictionary = set(words)\n    # words.remove(words[0])\n    # words.remove(words[-1])\n    # dictionary = dictionary.difference(words)\n    # print(dictionary)\n    # return '0'\n    # print(words)\n    # return '0'\n    if len(words) == 1:\n        return words[0]\n    if len(words) == 2:\n        return '0'\n    words = list(map(str, stdin.splitlines()))\n    words.sort()\n    start = words[0]\n    end = words[1]\n    dictionary = set(words)\n    dictionary = dictionary.difference(words)\n    n = len(dictionary)\n    print(start)\n    print(end)\n    print(dictionary)\n    print(n)\n    for i in range(n):\n        for j in range(len(start)):\n            if start[j]!= end[j]:\n                break\n        start = start[:j] + start[j+1:]\n        end = end[:j] + end[j+1:]\n    start = start[:-1]\n    if start == end:\n        return start\n    return start +'' + end"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    in_words = stdin.split()\n    length_in_words = len(in_words)\n    graph = collections.defaultdict(list)\n    word_set = set(in_words)\n    for i in range(length_in_words - 1):\n        word_a, word_b = in_words[i], in_words[i + 1]\n        if len(word_a)!= len(word_b):\n            return '0'\n        graph[word_a].append(word_b)\n        word_set.add(word_a)\n        word_set.add(word_b)\n    # no_solution = '0'\n    word_to_move = None\n    # for word in sorted(word_set):\n    #     for move in graph[word]:\n    #         if move == word:\n    #             continue\n    #         if word_to_move and word_to_move >= move:\n    #             no_solution = '0'\n    #             break\n    #         word_to_move = move\n    #         if word_to_move:\n    #             no_solution = '0'\n    #             break\n    #     if no_solution:\n    #         break\n    # return word_to_move\n\n    # no_solution = '0'\n    word_to_move = None\n    # for word in sorted(word_set):\n    #     for move in graph[word]:\n    #         if word_to_move and word_to_move >= move:\n    #             no_solution = '0'\n    #             break\n    #         word_to_move = move\n    #         if word_to_move:\n    #             no_solution = '0'\n    #             break\n    #     if no_solution:\n    #         break\n    # return word_to_move\n\n    no_solution = '0'\n    word_to_move = None\n    for word in sorted(word_set):\n        for move in graph[word]:\n            if word_to_move and word_to_move >= move:\n                no_solution = '0'\n                break\n            word_to_move = move\n            if word_to_move:\n                no_solution = '0'\n                break\n        if no_solution:\n            break\n    return word_to_move\n"
    },
    {
        "number": 3270,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n\n    def get_adjacency_list(words: list) -> dict:\n        words_adjacency_list = {}\n        for word in words:\n            for char in word:\n                if char not in words_adjacency_list:\n                    words_adjacency_list[char] = [word]\n                else:\n                    words_adjacency_list[char].append(word)\n        return words_adjacency_list\n\n    words = []\n\n    for line in stdin[1:]:\n        words.append(line)\n\n    words_adjacency_list = get_adjacency_list(words)\n\n    min_steps = 1000000007\n\n    def dfs(node: str, word_step: int, node_step: int):\n        nonlocal min_steps\n        if node == words[-1]:\n            if word_step + node_step < min_steps:\n                min_steps = word_step + node_step\n            return\n\n        if node in words_adjacency_list:\n            for next_node in words_adjacency_list[node]:\n                if node_step + 1 < min_steps:\n                    dfs(next_node, word_step + 1, node_step + 1)\n                else:\n                    dfs(next_node, word_step, node_step)\n        else:\n            if word_step + node_step < min_steps:\n                min_steps = word_step + node_step\n            return\n\n    dfs(words[0], 0, 0)\n    if min_steps == 1000000007:\n        print(words[0], -1)\n    else:\n        print(words[0], min_steps)\n\n    return\n\n\nsolution(stdin)\n\n'''\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    confused = 0\n    for i in range(1, N + 1):\n        confused += int(i * i >= N)\n        for j in range(i + 1, N + 1):\n            confused += int(i * j >= N)\n    return str(confused % 1000000007)\nprint(solution(input()))\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    confusions = 0\n    for i in range(N + 1):\n        for j in range(N - i + 1):\n            confusions += (N - i - j) * pow(2, j, 10 ** 9 + 7)\n    return str(confusions % (10 ** 9 + 7))\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    return str(n * (n - 1) // 2 + c)\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Replace this with your code\n    return stdout"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.strip().split())\n    a = sorted([int(stdin.strip()) for stdin in stdin.strip().split()])\n    return str(sum((1 + (i == a[i - 1]) * a.count(i)) % 1000000007 for i in range(1, N + 1)))\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    \n    count = 0\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if j >= i:\n                if i > j:\n                    if i % j!= 0:\n                        count += 1\n                else:\n                    if j % i!= 0:\n                        count += 1\n    \n    return str(count % 1000000007)\n    \n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, C = list(map(int, stdin.split()))\n    MODULO = 10**9 + 7\n\n    res = 0\n    for i in range(1, N + 1):\n        if i == 1:\n            res += 1\n            continue\n        for j in range(i + 1, N + 1):\n            if j == 1:\n                res += 1\n                continue\n            if i > j:\n                break\n            if j % i == 0:\n                res += 2\n            else:\n                res += 1\n    return str(res % MODULO)\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, N, C = stdin.split()\n    N = int(N)\n    C = int(C)\n    count = 0\n    if N > 1:\n        for i in range(1, N):\n            j = N - i\n            if i == 1:\n                if N % 2 == 1:\n                    if (C // (j + 1) + 1) % 2 == 0:\n                        count += 1\n                else:\n                    if (C // (j + 1)) % 2 == 0:\n                        count += 1\n            else:\n                if (C // (j + 1)) % 2 == 0:\n                    count += 1\n    else:\n        count = (C * (N + 1)) // 2\n    return str(count % 1_000_000_007)\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    seq = [i for i in range(1, N + 1)]\n    cnt = 0\n    for i in range(len(seq) - 1):\n        for j in range(i + 1, len(seq)):\n            if seq[i] > seq[j]:\n                cnt += 1\n    return str(cnt % 1000000007)\n"
    },
    {
        "number": 3271,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    cnt = 0\n    for i in range(2, N + 1):\n        if i == N:\n            cnt = cnt + 1\n            continue\n        if N % i == 0:\n            cnt += 2\n        else:\n            cnt += 1\n    print(cnt % 1000000007)\n    return cnt % 1000000007"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [[c for c in stdin] for _ in range(n)]\n    doors = []\n    gargoyles = []\n    v_faces = []\n    h_faces = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'V':\n                v_faces.append((i, j))\n            elif grid[i][j] == 'H':\n                h_faces.append((i, j))\n            elif grid[i][j] == '.':\n                continue\n            else:\n                doors.append((i, j))\n    # print(v_faces)\n    # print(h_faces)\n    # print(doors)\n    s = Solution()\n    while True:\n        todo = []\n        visited = []\n        for door in doors:\n            visited.append(door)\n            for v_face in v_faces:\n                if grid[v_face[0]][v_face[1]] == '#':\n                    continue\n                if (v_face[0], v_face[1]+1) in visited or (v_face[0], v_face[1]-1) in visited or (v_face[0]+1, v_face[1]) in visited or (v_face[0]-1, v_face[1]) in visited:\n                    continue\n                # if (v_face[0]+1, v_face[1]) in visited or (v_face[0]-1, v_face[1]) in visited or (v_face[0], v_face[1]+1) in visited or (v_face[0], v_face[1]-1) in visited:\n                    continue\n                # if (v_face[0]+1, v_face[1]) in visited or (v_face[0]-1, v_face[1]) in visited or (v_face[0], v_face[1]+1) in visited or (v_face[0], v_face[1]-1) in visited:\n                #     continue\n                # if (v_face[0]+1, v_face[1]) in visited or (v_face[0]-1, v_face[1]) in visited or (v_face[0], v_face[1]+1) in visited or (v_face[0], v_face[1]-1) in visited:\n                #     continue\n                todo.append((v_face, (v_face[0]+1, v_face[1]), (v_face[0]-1, v_face[1]), (v_face[0], v_face[1]+1), (v_face[0], v_face[1]-1)))\n                visited.append((v_face[0], v_face[1]))\n            for h_face in h_faces:\n                if grid[h_face[0]][h_face[1]] == '#':\n                    continue\n                if (h_face[0], h_face[1]+1) in visited or (h_face[0], h_face[1]-1) in visited or (h_face[0]+1, h_face[1]) in visited or (h_face[0]-1, h_face[1]) in visited:\n                    continue\n                # if (h_face[0]+1, h_face[1]) in visited or (h_face[0]-1, h_face[1]) in visited or (h_face[0], h_face[1]+1) in visited or (h_face[0], h_face[1]-1) in visited:\n                    continue\n                # if (h_face[0]+1, h_face[1]) in visited or (h_face[0]-1, h_face[1]) in visited or (h_face[0], h_face[1]+1) in visited or (h_face[0], h_face[1]-1) in visited:\n                #     continue\n                # if (h_face[0]+1, h_face[1]) in visited or (h_face[0]-1, h_face[1]) in visited or (h_face[0], h_face[1]+1) in visited or (h_face[0], h_face[1]-1) in visited:\n                #     continue\n                todo.append((h_face, (h_face[0]+1, h_face[1]), (h_face[0]-1, h_face[1]), (h_face[0], h_face[1]+1), (h_face[0], h_face[1]-1)))\n                visited.append((h_face[0], h_face[1]))\n        for (a, b), (c, d), (e, f), (g, h), (i, j) in todo:\n            # print(a, b, c, d)\n            # print(e, f, g, h)\n            # print(i, j)\n            # print()\n            if a == b:\n                # print(a, b, c, d)\n                grid[a[0]][a[1]] = '.'\n                grid[c[0]][c[1]] = '.'\n                grid[d[0]][d[1]] = '.'\n                grid[e[0]][e[1]] = '.'\n                grid[f[0]][f[1]] = '.'\n                grid[g[0]][g[1]] = '.'\n                grid[h[0]][h[1]] = '.'\n                "
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split('\\n')\n    n, m = map(int, stdin[0].split())\n    floorplan = stdin[1]\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == 'H' or floorplan[y][x] == 'V']\n    v_mirrors = []\n    h_mirrors = []\n    for y in range(m):\n        for x in range(n):\n            if floorplan[y][x] == '.':\n                v_mirrors.append((x, y))\n            elif floorplan[y][x] == 'V':\n                h_mirrors.append((x, y))\n    mirrors = list(h_mirrors) + list(v_mirrors)\n    mirrors = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    mirrors = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == 'V' or floorplan[y][x] == 'H']\n    mirrors = list(mirrors)\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == 'V' or floorplan[y][x] == 'H']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == 'V']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == 'H']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '#']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '*']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '*']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floorplan[y][x] == '.']\n    gargoyles = [(x, y) for y in range(m) for x in range(n) if floor"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    tomb = stdin\n    moves = 0\n    mirrors = {'.V':'.H', '.H':'.V'}\n    while (mirrors := list(mirrors.items())):\n        for g1, g2 in mirrors:\n            if g1 in tomb and g2 in tomb:\n                s = tomb.index(g1)\n                e = tomb.index(g2)\n                if s < e:\n                    tomb = tomb[:s] + list(reversed(tomb[s+1:e])) + tomb[e+1:]\n                else:\n                    tomb = tomb[:e] + list(reversed(tomb[e+1:s])) + tomb[s+1:]\n                moves += 1\n    return str(moves)\n    \n"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    stdin = list(map(lambda x: x.replace(\"\\n\", \"\"), stdin))\n    n, m = stdin.pop(0).split()\n    n = int(n)\n    m = int(m)\n    floorplan = stdin.pop()\n\n    def rotate(matrix, n_rotations, n_rotations_done):\n        if n_rotations == n_rotations_done:\n            return matrix\n        for i in range(n_rotations):\n            matrix = rot(matrix)\n        return rotate(matrix, n_rotations, n_rotations_done + 1)\n\n    def rot(matrix):\n        new_matrix = []\n        for i in range(n):\n            line = []\n            for j in range(m):\n                if matrix[i][j] == '#':\n                    line.append('#')\n                elif matrix[i][j] == 'V':\n                    for k in range(2):\n                        line.append('V')\n                elif matrix[i][j] == 'H':\n                    for k in range(2):\n                        line.append('H')\n                else:\n                    line.append('.')\n            new_matrix.append(line)\n        return new_matrix\n\n    def move_line(matrix, matrix_index, direction, gap):\n        new_matrix = []\n        for i in range(n):\n            new_matrix.append([])\n            for j in range(m):\n                if direction == 'down':\n                    if i - gap >= 0:\n                        new_matrix[-1].append(matrix[i - gap][j])\n                if direction == 'up':\n                    if i + gap < n:\n                        new_matrix[-1].append(matrix[i + gap][j])\n                if direction == 'left':\n                    if j - gap >= 0:\n                        new_matrix[-1].append(matrix[i][j - gap])\n                if direction == 'right':\n                    if j + gap < m:\n                        new_matrix[-1].append(matrix[i][j + gap])\n        return new_matrix\n\n    def remove_wall(matrix, matrix_index, direction):\n        new_matrix = []\n        for i in range(n):\n            new_matrix.append([])\n            for j in range(m):\n                if direction == 'down':\n                    if i + 1 < n:\n                        new_matrix[-1].append(matrix[i + 1][j])\n                if direction == 'up':\n                    if i - 1 >= 0:\n                        new_matrix[-1].append(matrix[i - 1][j])\n                if direction == 'left':\n                    if j - 1 >= 0:\n                        new_matrix[-1].append(matrix[i][j - 1])\n                if direction == 'right':\n                    if j + 1 < m:\n                        new_matrix[-1].append(matrix[i][j + 1])\n        return new_matrix\n\n    def check_door(matrix):\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == '#':\n                    return False\n        return True\n\n    def is_gargoyle(matrix):\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 'V':\n                    return True\n                if matrix[i][j] == 'H':\n                    return True\n        return False\n\n    def check_mirror(matrix, direction, line_index, mirror_index):\n        if mirror_index == 1:\n            if direction == 'down':\n                if matrix[line_index + 1][mirror_index] == '#':\n                    return False\n            if direction == 'up':\n                if matrix[line_index - 1][mirror_index] == '#':\n                    return False\n            if direction == 'left':\n                if matrix[line_index][mirror_index + 1] == '#':\n                    return False\n            if direction == 'right':\n                if matrix[line_index][mirror_index - 1] == '#':\n                    return False\n        if mirror_index == 2:\n            if direction == 'down':\n                if matrix[line_index + 1][mirror_index] == '#':\n                    return False\n            if direction == 'up':\n                if matrix[line_index - 1][mirror_index] == '#':\n                    return False\n            if direction == 'left':\n                if matrix[line_index][mirror_index + 1] == '#':\n                    return False\n            if direction == 'right':\n                if matrix[line_index][mirror_index - 1] == '#':\n                    return False\n        return True\n\n    def check_wall(matrix, line_index):\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == '#':\n                    if direction == 'down':\n                        if i + 1 < n:\n                            if matrix[i + 1][j] == '#':\n                                return False\n                    if direction == 'up':\n                        if i - 1 >= 0:\n                            if matrix[i - 1][j] == '#':\n                                return False\n                    if direction == 'left':\n                        if j - 1 >= 0:\n                            if matrix[i][j - 1] == '#':\n                                return False\n                    if direction == 'right':\n                        if j + 1 < m:"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    def rotate_face(delta, face, n, m):\n        if delta == 180:\n            return [[0] * m for _ in range(n)]\n        if delta == 90:\n            # rotate clockwise\n            return [[face[i][m - 1 - j] for j in range(m)] for i in range(n)]\n        if delta == 270:\n            # rotate anticlockwise\n            return [[face[n - 1 - j][i] for j in range(m)] for i in range(n)]\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    floorplan = [list(i) for i in lines[1].split()]\n    pos = 0\n    visited = [[False] * m for _ in range(n)]\n    degrees = {\n        'right': 90,\n        'left': 270,\n        'top': 180,\n        'bottom': 0,\n    }\n    visited[0][0] = True\n    for i in range(1, n):\n        if floorplan[i][0] == 'V' and floorplan[i - 1][0] == '.':\n            pos = (i, 0)\n            break\n    for i in range(1, m):\n        if floorplan[0][i] == 'V' and floorplan[0][i - 1] == '.':\n            pos = (0, i)\n            break\n    dist = 1\n    while pos:\n        visited[pos[0]][pos[1]] = True\n        for delta in degrees.values():\n            rotated = rotate_face(delta, floorplan, n, m)\n            if rotated[pos[0]][pos[1]] == '#' or rotated[pos[0]][pos[1]] == 'V':\n                visited[pos[0]][pos[1]] = True\n                dist += 1\n                break\n            if rotated[pos[0]][pos[1]] == '.':\n                visited[pos[0]][pos[1]] = True\n                pos = (pos[0] + delta // abs(delta), pos[1] + delta % abs(delta))\n                break\n    return dist\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    size_x, size_y = map(int, stdin.split())\n    puzzle = stdin.strip()\n    g_count = 0\n    for y in range(size_y):\n        for x in range(size_x):\n            if puzzle[x][y] == '.':\n                g_count += 1\n    return str(g_count)\n"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin.pop(0).split())\n    arr = [i for i in stdin]\n    arr = arr[1:]\n    doors = []\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == '.':\n                doors.append((i, j))\n            if arr[i][j] == '#':\n                arr[i][j] = '#'\n    # print(arr)\n    # print(doors)\n    if len(doors) < 3:\n        return -1\n    def rotate(grid, direction, num, doors):\n        # print(direction, num)\n        if direction == 'h':\n            grid = list(zip(*grid))\n            # print(grid)\n            for i in range(num):\n                for j in range(m):\n                    grid[j] = grid[j][i:] + grid[j][:m-i]\n        else:\n            for i in range(num):\n                for j in range(n):\n                    grid[j] = grid[j][i:] + grid[j][:n-i]\n        # print(grid)\n        x, y = doors[0]\n        if direction == 'v':\n            grid[x][y], grid[y][x] = grid[y][x], grid[x][y]\n        else:\n            grid[x][y], grid[y][x] = grid[y][x], grid[x][y]\n        return grid\n    # print(rotate(arr, 'h', 3, doors))\n    # print(rotate(arr, 'v', 2, doors))\n    solutions = []\n    for i in range(1, 1 << (n*m)):\n        grid = arr\n        for j in range(n*m):\n            if i & (1 << j):\n                if grid[j//m][j%m] == '#':\n                    grid[j//m][j%m] = '#'\n                else:\n                    grid[j//m][j%m] = '.'\n        # print(grid)\n        # print('----')\n        if not check(grid):\n            # print('not')\n            continue\n        if grid == arr:\n            # print('ok')\n            continue\n        # print(grid)\n        # print('----')\n        solutions.append(grid)\n    solutions.sort(key=lambda x: sum([sum([x[i][j] == '#' for i in range(n)]), sum([x[i][j] == '.' for i in range(n)])]))\n    print(len(solutions))\n    return solutions.pop(0)\n\ndef"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n, m = map(int, stdin[0].split(\" \"))\n    floorplan = stdin[1].split(\"\\n\")\n\n    def rotate(g, d):\n        if d == 0:\n            return [[\".\"] * m for _ in range(n)]\n        elif d == 90:\n            return [[g[i][m - 1 - j] for j in range(m)] for i in range(n)]\n        elif d == 180:\n            return rotate(g, d)\n        elif d == 270:\n            return [[g[i][j] for j in range(m)] for i in range(n)]\n        else:\n            return rotate(g, d - 180)\n\n    def in_range(g, x, y, range):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        return range[0] < g[x][y] < range[1]\n\n    def mirror(g, x, y, range):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        if range[0] < g[x][y] < range[1]:\n            return True\n        if range[0] < g[x][y - 1] < range[1]:\n            return True\n        if range[0] < g[x - 1][y] < range[1]:\n            return True\n        if range[0] < g[x - 1][y - 1] < range[1]:\n            return True\n        return False\n\n    def check(g, x, y):\n        if not in_range(g, x, y, mirror_range):\n            return False\n        if not in_range(g, x, y, range):\n            return False\n        return True\n\n    def find_mirror(g, x, y, range, range_set):\n        range_set.add((x, y))\n        for i in range(4):\n            x_new = x + dx[i]\n            y_new = y + dy[i]\n            if check(g, x_new, y_new):\n                range_set.add((x_new, y_new))\n                find_mirror(g, x_new, y_new, range, range_set)\n\n    # init\n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n    range_set = set()\n    mirror_range = (1, n)\n    g = rotate(floorplan, 90)\n    find_mirror(g, 0, 0, mirror_range, range_set)\n    return len(range_set)\n"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This function is in charge of solving the puzzle.\n    '''\n\n    #The dictionary contains all the cells in the floorplan\n    cells = {}\n    #The keys of the dictionary are the coordinates of the cells\n    keys = set()\n\n    #We iterate through each line of the input\n    for line in stdin.splitlines():\n        #If the line is a space or an empty line, then it means that we are in the empty cell (space). So we add that to the dictionary.\n        if line == '':\n            cells[(0,0)] = True\n            keys.add((0,0))\n        #If the line is not empty, then we are in a wall (hash). So we add that to the dictionary.\n        elif line[0] == '#':\n            cells[(0,0)] = True\n            keys.add((0,0))\n        #Now we have to create a list of all the characters that is in the line\n        line_list = list(line)\n        #We iterate through the line_list\n        for i in range(len(line_list)):\n            #If the character is '#' or '.', we can skip it\n            if line_list[i] == '#' or line_list[i] == '.':\n                continue\n            #Otherwise, we add the character to the coordinates of the cell in the dictionary\n            coordinate = (i%5, int(i/5))\n            cells[coordinate] = True\n            keys.add(coordinate)\n\n    #We iterate through the dictionary to see if there are any coordinate that are not in the keys\n    #If any of those coordinates are present in the keys, then we return -1\n    for cell in cells.keys():\n        if cell not in keys:\n            return '-1'\n    #We create a list with all the coordinates that are in keys\n    keys_list = list(keys)\n    #We iterate through the keys_list\n    for key in keys_list:\n        #We add all the coordinates that are in the keys to the list\n        coords_list = []\n        if key[0] > 0:\n            coords_list.append((key[0]-1, key[1]))\n        if key[1] > 0:\n            coords_list.append((key[0], key[1]-1))\n        if key[0] < 4:\n            coords_list.append((key[0]+1, key[1]))\n        if key[1] < 4:\n            coords_list.append((key[0], key[1]+1))\n\n        #We iterate through the coords_list and see if any of the coordinates are not in the keys\n        #If any of those coordinates are present in the keys, then we return -1\n        for coord in coords_list:\n            if coord not in keys:\n                return '-1'\n    #We have a solution\n    return '1'\n"
    },
    {
        "number": 3272,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    if len(stdin) == 1:\n        return \"AMBIGUOUS\"\n    else:\n        max_len = 0\n        min_len = len(stdin)\n        best_str = \"\"\n        for i in range(len(stdin)):\n            if len(stdin[i]) > max_len:\n                max_len = len(stdin[i])\n            if len(stdin[i]) < min_len:\n                min_len = len(stdin[i])\n        for i in range(min_len):\n            for j in range(max_len):\n                if max_len - j > min_len:\n                    sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                    if sub_str == stdin[i][:j] * (max_len - j):\n                        return \"AMBIGUOUS\"\n                elif max_len - j < min_len:\n                    continue\n        for i in range(min_len):\n            for j in range(max_len):\n                if max_len - j > min_len:\n                    sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                    if sub_str == stdin[i][:j] * (max_len - j):\n                        return \"AMBIGUOUS\"\n                elif max_len - j < min_len:\n                    continue\n        for i in range(min_len):\n            for j in range(max_len):\n                for k in range(min_len):\n                    for m in range(max_len):\n                        if max_len - j > min_len:\n                            sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                            if sub_str == stdin[i][:j] * (max_len - j):\n                                return \"AMBIGUOUS\"\n                        elif max_len - j < min_len:\n                            continue\n                for k in range(min_len):\n                    for m in range(max_len):\n                        if max_len - j > min_len:\n                            sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                            if sub_str == stdin[i][:j] * (max_len - j):\n                                return \"AMBIGUOUS\"\n                        elif max_len - j < min_len:\n                            continue\n        for i in range(min_len):\n            for j in range(max_len):\n                for k in range(min_len):\n                    for m in range(max_len):\n                        for n in range(min_len):\n                            for o in range(max_len):\n                                if max_len - j > min_len:\n                                    sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                                    if sub_str == stdin[i][:j] * (max_len - j):\n                                        return \"AMBIGUOUS\"\n                                elif max_len - j < min_len:\n                                    continue\n                for k in range(min_len):\n                    for m in range(max_len):\n                        if max_len - j > min_len:\n                            sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                            if sub_str == stdin[i][:j] * (max_len - j):\n                                return \"AMBIGUOUS\"\n                        elif max_len - j < min_len:\n                            continue\n        for i in range(min_len):\n            for j in range(max_len):\n                for k in range(min_len):\n                    for m in range(max_len):\n                        for n in range(min_len):\n                            for o in range(max_len):\n                                if max_len - j > min_len:\n                                    sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                                    if sub_str == stdin[i][:j] * (max_len - j):\n                                        return \"AMBIGUOUS\"\n                                elif max_len - j < min_len:\n                                    continue\n                for k in range(min_len):\n                    for m in range(max_len):\n                        if max_len - j > min_len:\n                            sub_str = stdin[i][:j] + stdin[i][j + 1:]\n                            if sub_str == stdin[i][:j] * (max_len - j):\n                                return \"AMBIGUOUS\"\n                        elif max_len - j < min_len:\n                            continue\n        for i in range(min_len):\n            for j in range(max_len):\n                for k in range(min_len):\n                    for m in range(max_len):\n                        for n in range(min_len):\n                            for o in range(max_len):\n                                if max_len - j > min_len:\n                                    sub_str = stdin["
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    uniques = []\n    for i in stdin:\n        i = i[::-1]\n        if i in uniques:\n            continue\n        elif i[:5] == i[-5:]:\n            uniques.append(i[:5])\n        else:\n            uniques.append(i)\n    uniques = list(set(uniques))\n    if len(uniques) == 1:\n        return 'AMBIGUOUS'\n    else:\n        return''.join(uniques)\n\nsolution(input())"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    fragments = stdin.split()\n    n = len(fragments)\n\n    # helper function\n    def find_common_suffix(lst):\n        prefix = ''\n        while len(lst) > 1:\n            prefix += lst.pop(0)\n            lst = lst[:len(lst) // 2]\n        return prefix\n\n    # helper function\n    def extend_substring(lst, common_suffix):\n        for i, j in enumerate(reversed(lst)):\n            if j.startswith(common_suffix):\n                return lst[:len(lst) - i]\n        return lst\n\n    # building lists of fragments\n    frag_lst = []\n    for i in fragments:\n        frag_lst.append(i)\n\n    # first step:\n    # in the worst case, every fragment is included in at least one common fragment\n    # also, we have to extend all the fragments to length > 5\n    # so we start by finding the longest fragment\n    max_frag_lst = []\n    while len(frag_lst) > 1:\n        max_frag_lst = frag_lst\n        frag_lst = extend_substring(frag_lst, find_common_suffix(frag_lst))\n        frag_lst = extend_substring(frag_lst, find_common_suffix(frag_lst))\n        frag_lst = extend_substring(frag_lst, find_common_suffix(frag_lst))\n\n    # check to see if all fragments were included in a common fragment\n    # if not, then we have a problem\n    if len(frag_lst)!= len(max_frag_lst):\n        return 'AMBIGUOUS'\n\n    # second step:\n    # now that we have the max_frag_lst, we need to split the fragments based on length\n    # in the worst case, each fragment is of length 5\n    # the optimal solution to the problem can be achieved by constructing a list with (at most) 4 of these fragments\n    opt_lst = []\n    while len(max_frag_lst) > 0:\n        opt_lst.append(max_frag_lst[:4])\n        max_frag_lst = max_frag_lst[4:]\n    # add the last fragment if any\n    if len(max_frag_lst) > 0:\n        opt_lst.append(max_frag_lst)\n\n    # second step:\n    # now that we have a list of all the possible sub-lists, we need to reorder it so that all the sub-lists have length >= 5\n    # in the worst case, each sub-list has length < 5\n    # the optimal solution to the problem can be achieved by building a list of lists\n    opt_lst2 = []\n    while len(opt_lst) > 0:\n        opt_lst2.append(opt_lst[:4])\n        opt_lst = opt_lst[4:]\n\n    # third step:\n    # we can use this list of lists to compute the optimal reconstruction\n    # we use a helper function to do this\n    # the problem is that we need to ensure that the longest common substring is at most $5$\n    # and that the total length of the longest common substring is at most $100$.\n    # so we need to use a dynamic programming table, or an array\n    # the table is indexed by the length of the sublist, and the value for each index is the sum of the minimum character length of the sublist + the minimum character length of the longest common substring between sublists\n    opt = []\n    for j in range(len(opt_lst2)):\n        opt_j = 0\n        for i in range(len(opt_lst2[j])):\n            opt_j += min(len(opt_lst2[j][i]), len(opt_lst2[j][(i + 1) % len(opt_lst2[j])]))\n        opt.append(opt_j)\n\n    # third step:\n    # we can use a backtracking algorithm to compute the optimal reconstruction\n    # the problem is the sum of the lengths of the longest common substring, and the length of the longest common substring is 1\n    # so, in order to compute the optimal reconstruction, we will need to run a loop, computing the value of the longest common substring and summing up the values for the indices to the left and to the right\n    # in the worst case, we need to run through each sublist and compute the optimal reconstruction for each sublist\n    # if we run through all sublists, we have completed the reconstruction and can return it\n    opt_lst3 = []\n    opt_lst3.append(opt)\n    for i in range(len(opt_lst2)):\n        opt_lst3.append(opt[i] + opt[i + 1])\n\n    # forth step:\n    # so, we need to build a list of optimal reconstructions\n"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    fragments = []\n    for i in range(N):\n        fragments.append(stdin.strip())\n    fragments.sort(key=len)\n    max_len = max(len(f) for f in fragments)\n    suffix_max_len = 5\n    suffix = []\n    prefix = []\n    for f in fragments:\n        suffix_len = 0\n        prefix_len = 0\n        suffix.append(f)\n        prefix.append(f)\n        if len(f) <= suffix_max_len:\n            suffix_len = len(f)\n            suffix_max_len = suffix_len\n        for j in range(len(f)):\n            if f[j:] in prefix:\n                prefix_len = len(f[j:])\n                break\n        if prefix_len > 0 and suffix_max_len == 5:\n            suffix_max_len = min(suffix_max_len, prefix_len)\n        if prefix_len >= 5:\n            suffix_max_len = min(suffix_max_len, prefix_len)\n        if suffix_len >= 5:\n            suffix_max_len = min(suffix_max_len, suffix_len)\n    suffix.sort(key=len, reverse=True)\n    prefix.sort(key=len)\n    suffix = suffix[:max_len - suffix_max_len]\n    prefix = prefix[:max_len - suffix_max_len]\n    suffix_prefix = []\n    for s in suffix:\n        for p in prefix:\n            if s == p[:suffix_max_len]:\n                suffix_prefix.append(s)\n                break\n    if len(suffix_prefix) == 1:\n        suffix_prefix.append('')\n    suffix_prefix.sort(key=len)\n    ans = ''\n    for s in suffix_prefix:\n        for s_ in suffix:\n            if s == s_[:suffix_max_len]:\n                ans += s +''\n                break\n    print(ans)\n    return ans"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_prefix(s1, s2):\n        return s1.endswith(s2)\n    def is_suffix(s1, s2):\n        return s2.startswith(s1)\n    def get_substring(s1, s2):\n        if s1.startswith(s2):\n            return s1[len(s2):]\n        elif s2.startswith(s1):\n            return s2[len(s1):]\n        return None\n    lines = stdin.strip().split('\\n')\n    fragments = []\n    for line in lines:\n        fragments.append(line)\n    substrings = []\n    for i in range(len(fragments)):\n        if i > 0:\n            fragments[i] = fragments[i][len(fragments[i-1]):]\n        for j in range(i + 1, len(fragments)):\n            fragments[j] = fragments[j][len(fragments[j-1]):]\n            if not fragments[j]:\n                break\n            substrings.append(get_substring(fragments[i], fragments[j]))\n    for substring in substrings:\n        if substring == None:\n            continue\n        if len(substring) <= 5 and len(substring) == len(fragments[0]):\n            return ''.join(fragments)\n    return 'AMBIGUOUS'\n"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    text = \"\"\n    for line in stdin.split(\"\\n\"):\n        if len(line) <= 80:\n            text += line + \"\\n\"\n    if not text:\n        return \"AMBIGUOUS\"\n    text = text.split(\"\\n\")\n    while text:\n        line = text.pop(0)\n        while line and text:\n            i = 0\n            while i < len(text) and len(text[i]) <= 80 and line.startswith(text[i]):\n                line = line[len(text[i]):]\n                text.pop(i)\n                i -= 1\n            i = 0\n            while i < len(text) and len(text[i]) <= 80 and line.endswith(text[i]):\n                line = line[:-len(text[i])]\n                text.pop(i)\n                i -= 1\n        while line and text:\n            i = 0\n            while i < len(text) and len(text[i]) <= 80 and line.startswith(text[i]):\n                line = line[len(text[i]):]\n                text.pop(i)\n                i -= 1\n            i = 0\n            while i < len(text) and len(text[i]) <= 80 and line.endswith(text[i]):\n                line = line[:-len(text[i])]\n                text.pop(i)\n                i -= 1\n        if line:\n            return \"AMBIGUOUS\"\n    return text[0]"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return 'AMBIGUOUS' if 'AMBIGUOUS' == solution(stdin) else solution(stdin)\n"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # An example of a possible test case with a minimal valid solution.\n    return"
    },
    {
        "number": 3273,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    input_list = list(filter(None, input_list))\n    input_list = list(map(lambda x: x.strip(), input_list))\n    # print(input_list)\n    temp_list = []\n    for i in range(len(input_list)):\n        for j in range(i, len(input_list)):\n            temp_list.append(input_list[i])\n            if len(temp_list) == 3:\n                return 'AMBIGUOUS'\n            else:\n                for k in range(j, len(input_list)):\n                    if len(temp_list) == 2:\n                        return 'AMBIGUOUS'\n                    else:\n                        temp_list.append(input_list[j])\n                        temp_list.append(input_list[k])\n                        if len(temp_list) == 5:\n                            return 'AMBIGUOUS'\n                        else:\n                            temp_list.pop()\n                            temp_list.pop()\n                            temp_list.pop()\n                            temp_list.pop()\n            temp_list.pop()\n            temp_list.pop()\n            temp_list.pop()\n            temp_list.pop()\n    return 'AMBIGUOUS'\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ships = []\n    for _ in range(m):\n        x_1, x_2, y = map(int, stdin.split())\n        ships.append((x_1, x_2, y))\n    for ship in ships:\n        if (ship[1] - ship[0]) % (ship[2] - ship[0]):\n            return 'impossible'\n    for ship in ships:\n        if ship[2] - ship[0] == 1:\n            return '0-'\n    return '+-' + '--'.join(map(str, range(0, n))) + '-'\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    if n * m <= 500000:\n        return 'impossible'\n    ships = [tuple(map(int, stdin.strip().split())) for _ in range(m)]\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n, -1, -1):\n        for j in range(n, -1, -1):\n            dp[i][j] = -1\n            if i == j == n:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = float('inf')\n                for k in range(min(i, j) + 1):\n                    if k == 0:\n                        dp[i][j] = min(dp[i][j], dp[i - k][j - k] + abs(ships[i - k][1] - ships[j - k][1]) + abs(ships[i - k][0] - ships[j - k][0]))\n                    elif k % 2 == 0:\n                        dp[i][j] = min(dp[i][j], dp[i - k][j - k] + abs(ships[i - k][1] - ships[j - k][1]) + abs(ships[i - k][0] - ships[j - k][0]))\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i - k][j - k] + abs(ships[i - k][1] - ships[j - k][1]) + abs(ships[i - k][0] - ships[j - k][0]))\n    if dp[n][n] == float('inf'):\n        return 'impossible'\n    return '+-' * n + '-'\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.split())\n        ships.append((x1, x2, y))\n    # Iterate through all possible ship movements\n    # If at any time a ship is on the wrong side of the plane,\n    # the torpedo should turn left, otherwise right\n    for ship in ships:\n        if max(ship) <= n and ship[0] <= ship[1]:\n            print(ship)\n            return '+-'\n    return 'impossible'\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1:\n        if m == 0:\n            return \"impossible\"\n        else:\n            return \"0+-\"\n    def sol(x1, y1, x2, y2, x3, y3):\n        dx = x2 - x1\n        dy = y2 - y1\n        if dy == 0:\n            return True\n        elif dy > 0:\n            if dx > 0:\n                return x1 <= x3 <= x2 <= x1 + dx <= x2 and y1 <= y3 <= y2 <= y1 + dy <= y2\n            else:\n                return x1 <= x3 <= x2 <= x1 - dx <= x2 and y1 <= y3 <= y2 <= y1 + dy <= y2\n        else:\n            if dx > 0:\n                return x1 <= x3 <= x2 <= x1 + dx <= x2 and y1 <= y3 <= y2 <= y1 + dy <= y2\n            else:\n                return x1 <= x3 <= x2 <= x1 - dx <= x2 and y1 <= y3 <= y2 <= y1 + dy <= y2\n    if m == 1:\n        if n == 1:\n            if n == 1:\n                return \"impossible\"\n            else:\n                return \"+--+\"\n        if m == 1:\n            if n == 1:\n                return \"--+\"\n            else:\n                return \"0+-\"\n        else:\n            x1 = int(input())\n            y1 = int(input())\n            x2 = int(input())\n            y2 = int(input())\n            x3 = int(input())\n            y3 = int(input())\n            if x1 == x2:\n                return \"--+\"\n            if x1 == x3:\n                return \"--+\"\n            if x2 == x3:\n                return \"--+\"\n            if y1 == y2:\n                return \"--+\"\n            if y1 == y3:\n                return \"--+\"\n            if y2 == y3:\n                return \"--+\"\n            if sol(x1, y1, x2, y2, x3, y3):\n                return \"+--+\"\n            else:\n                return \"impossible\"\n    else:\n        if n == 1:\n            if m == 1:\n                if m == 1:\n                    return \"impossible\"\n                else:\n                    x1 = int(input())\n                    y1 = int(input())\n                    x2 = int(input())\n                    y2 = int(input())\n                    x3 = int(input())\n                    y3 = int(input())\n                    if x1 == x2:\n                        if x1 == x3:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                    if x1 == x3:\n                        if x1 == x2:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                    if y1 == y2:\n                        if y1 == y3:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                    if y1 == y3:\n                        if y1 == y2:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                    else:\n                        if sol(x1, y1, x2, y2, x3, y3):\n                            return \"+--+\"\n                        else:\n                            return \"impossible\"\n            else:\n                x1 = int(input())\n                y1 = int(input())\n                x2 = int(input())\n                y2 = int(input())\n                x3 = int(input())\n                y3 = int(input())\n                x4 = int(input())\n                y4 = int(input())\n                if x1 == x2:\n                    if x1 == x3:\n                        return \"--+\"\n                    else:\n                        if x1 == x4:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                if x1 == x3:\n                    if x1 == x2:\n                        return \"--+\"\n                    else:\n                        if x1 == x4:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                if x1 == x4:\n                    if x1 == x2:\n                        return \"--+\"\n                    else:\n                        if x1 == x3:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                if y1 == y2:\n                    if y1 == y3:\n                        return \"--+\"\n                    else:\n                        if y1 == y4:\n                            return \"--+\"\n                        else:\n                            if sol(x1, y1, x2, y2, x3, y3):\n                                return \"+--+\"\n                            else:\n                                return \"impossible\"\n                if y1 == y3:\n                    if y1 == y2:\n                        return \"--+"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_nearest_right(current: int, r: int, current_x: int) -> int:\n        '''returns the nearest location with x+1 or x-1, if current is within range of x, else returns -1'''\n        for i in range(current_x, 0, -1):\n            if i == current_x:\n                continue\n            elif r < abs(i - current_x):\n                return i\n        return -1\n\n    def find_nearest_left(current: int, l: int, current_x: int) -> int:\n        '''returns the nearest location with x-1 or x+1, if current is within range of x, else returns -1'''\n        for i in range(current_x, -1, 1):\n            if i == current_x:\n                continue\n            elif l < abs(i - current_x):\n                return i\n        return -1\n\n    def find_nearest(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the nearest location, if within range of each end of the window, else returns -1'''\n        left = find_nearest_left(current, l, current_x)\n        right = find_nearest_right(current, r, current_x)\n        if left == -1 and right == -1:\n            return -1\n        elif left == -1:\n            return right\n        elif right == -1:\n            return left\n        elif left!= -1 and right!= -1:\n            return left if left < right else right\n        else:\n            return -1\n\n    def find_nearest_seg(current: int, r: int, current_x: int) -> int:\n        '''returns the nearest segment'''\n        for i in range(current_x, -1, -1):\n            if i == current_x:\n                continue\n            if r < abs(i - current_x):\n                return i\n        return -1\n\n    def find_segments(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_seg(current, l, current_x), find_nearest_seg(current, r, current_x))]\n        for segment in segments:\n            if segment[0] == -1:\n                return segment[1]\n        return segments[0][1]\n\n    def find_segments_x(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments on x-axis'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_seg(current, l, current_x), find_nearest_seg(current, r, current_x))]\n        for segment in segments:\n            if segment[0] == -1:\n                return segment[1]\n        return segments[0][1]\n\n    def find_segments_y(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments on y-axis'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_seg(current, l, current_x), find_nearest_seg(current, r, current_x))]\n        for segment in segments:\n            if segment[0] == -1:\n                return segment[1]\n        return segments[0][1]\n\n    def find_segments_s(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments on both axes'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_seg(current, l, current_x), find_nearest_seg(current, r, current_x))]\n        for segment in segments:\n            if segment[0] == -1:\n                return segment[1]\n        return segments[0][1]\n\n    def find_segments_s_x(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments on both axes on x-axis'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_seg(current, l, current_x), find_nearest_seg(current, r, current_x))]\n        for segment in segments:\n            if segment[0] == -1:\n                return segment[1]\n        return segments[0][1]\n\n    def find_segments_s_y(current: int, l: int, r: int, current_x: int) -> int:\n        '''returns the closest segments on both axes on y-axis'''\n        segments = [(current, find_nearest_seg(current, l, current_x)),\n                    (current, find_nearest_seg(current, r, current_x)),\n                    (find_nearest_"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ship_data = [[int(c) for c in r.split(' ')] for r in stdin.split('\\n')]\n    for ship in ship_data:\n        if ship[0] == -n or ship[1] == -m or ship[0] == n or ship[1] == m:\n            print('impossible')\n            return\n    ship_data = sorted(ship_data, key=lambda x: x[0])\n    ship_data = sorted(ship_data, key=lambda x: x[1])\n    ship_data = sorted(ship_data, key=lambda x: (x[0], x[1]))\n    if ship_data[0][0] > 0:\n        return '+-' * ship_data[0][0] + '0'\n    elif ship_data[0][0] < 0:\n        return '--+' * abs(ship_data[0][0])\n    else:\n        return 'impossible'\n\nprint(solution('''5 6\n-3 -2 3\n-2 -2 4\n2 3 3\n-1 1 2\n0 1 4\n2 5 1\n'''))\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    # noinspection PyTypeChecker\n    x, y = map(int, stdin.split())\n    if m == n:\n        if x == 0 and y == 0:\n            return \"impossible\"\n        if x == 0 or y == 0:\n            return \"0-\"\n        if x == 1 and y == 0:\n            return \"--+\"\n    if m > n:\n        return \"impossible\"\n    if m < n:\n        return \"0+-\"\n    if x == 0 and y == 0:\n        return \"0\"\n    if x == 0 or y == 0:\n        return \"+-\"\n    if x == 1 and y == 0:\n        return \"--+\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    ships = [[int(x) for x in stdin.strip().split()] for _ in range(int(stdin.strip()))]\n    for ship in ships:\n        x1, y1, x2, y2 = ship\n        if x2 - x1 <= 1 or x1 == x2:\n            return \"impossible\"\n    x1, y1 = min(ships, key=lambda x: x[0])\n    x2, y2 = max(ships, key=lambda x: x[1])\n    if y1 == 0 or y2 == 0:\n        return \"impossible\"\n    x1 -= 1\n    x2 -= 1\n    while x1 <= x2:\n        x1 += 1\n        if check_valid_ship(x1, y1, x2, y2, ships):\n            return \"-+\" * (x2 - x1)\n    return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3274,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ships = []\n    for _ in range(m):\n        ships.append(list(map(int, stdin.split())))\n    if (n == 1 and m == 1):\n        if (ships[0][0] == ships[0][1]):\n            return \"impossible\"\n        else:\n            return \"0-0\"\n    if (n == 1 and m == 2):\n        if (ships[0][0] == 0 and ships[0][1] == 0):\n            return \"0-0\"\n        elif (ships[0][0] == 0 and ships[0][1] == 1):\n            return \"+-0\"\n        elif (ships[0][0] == 1 and ships[0][1] == 0):\n            return \"-0+\"\n        elif (ships[0][0] == 1 and ships[0][1] == 1):\n            return \"0+0\"\n        else:\n            return \"impossible\"\n    if (n == 2 and m == 1):\n        if (ships[0][0] == ships[1][0]):\n            return \"0-0\"\n        elif (ships[0][0] == ships[1][1]):\n            return \"+-0\"\n        elif (ships[0][0] == ships[1][0]):\n            return \"-0+\"\n        elif (ships[0][0] == ships[1][0]):\n            return \"0+0\"\n        else:\n            return \"impossible\"\n    if (n == 2 and m == 2):\n        if (ships[0][0] == ships[1][0]):\n            return \"0+0\"\n        elif (ships[0][0] == ships[1][1]):\n            return \"0-0\"\n        elif (ships[0][0] == ships[1][0]):\n            return \"-0+\"\n        elif (ships[0][0] == ships[1][0]):\n            return \"-0-0\"\n        else:\n            return \"impossible\"\n    return \"impossible\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, *a = map(int, stdin.split())\n    q = int(stdin)\n    return''.join(map(str, (n+1)*min(a, b) % 10_007))\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    q = int(stdin.split()[3])\n    mod = 1\n    for i in range(q):\n        num_a, num_b = map(int, stdin.split())\n        for ai in range(num_a):\n            if ai < num_a:\n                a[ai] += 1\n                if a[ai] > 1:\n                    a[ai] = 0\n                    mod *= 1\n            else:\n                break\n        for bi in range(num_b):\n            if bi < num_b:\n                b[bi] += 1\n                if b[bi] > 1:\n                    b[bi] = 0\n                    mod *= 1\n            else:\n                break\n    return str(mod % (10**7))"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, C, Q = map(int, stdin.split())\n    ans = 0\n    for _ in range(Q):\n        P, a, b = list(map(int, stdin.split()))\n        if a!= b:\n            ans += 1\n    print(ans)\n    return"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, c, q = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    w = 1\n    z = 1\n    for _ in range(n):\n        w *= a\n        z *= b\n    for _ in range(q):\n        p, a, b = map(int, stdin.split())\n        t = 1\n        while t <= p:\n            if a % t == 0:\n                t *= a\n            else:\n                break\n        t = 1\n        while t <= p:\n            if b % t == 0:\n                t *= b\n            else:\n                break\n        if p % 2 == 0:\n            if a > 0:\n                w = w // a\n            if b > 0:\n                z = z // b\n        else:\n            if a > 0 and b > 0:\n                w = w // a\n                z = z // b\n    return str(w % 10**7)\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, c, *a, b = map(int, stdin.split())\n    changes = 0\n    while c > 1:\n        c = min(c, a.count(max(a)) * b.count(max(b)))\n        changes += 1\n        a = sorted(a)\n        b = sorted(b)\n        a.pop(a.index(max(a)))\n        b.pop(b.index(max(b)))\n    return str(changes)\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # \u0412\u0430\u0448 \u043a\u043e\u0434\n    a, b, C = stdin\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n    c = list(map(int, C.split()))\n    b, c = sorted([b, c], key=lambda i: i[0])\n    for i in range(C[0]):\n        b.append(b[0])\n    for i in range(C[1]):\n        b.append(b[0])\n    for i in range(C[2]):\n        b.append(b[0])\n    for i in range(C[3]):\n        b.append(b[0])\n    for i in range(C[4]):\n        b.append(b[0])\n    print(len(b))\n    return \" \".join(str(b))"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    col = 1\n    bit = 1\n    while col < c and bit < c:\n        col += a\n        bit += b\n    return '%i' % (bit % c)\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    a = map(int, stdin.split())\n    b = map(int, stdin.split())\n    q = int(stdin.split()[-1])\n    ans = []\n    for i in range(N):\n        ans.append(min(a[i], b[i]) % 10)\n    return '\\n'.join(map(str, ans))\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    Q = int(stdin)\n\n    # a = map(int, input().split())\n    # b = map(int, input().split())\n    # N, C = map(int, input().split())\n    # Q = int(input())\n\n    MAX = 10 ** 7\n\n    if N > MAX or C > MAX or Q > MAX:\n        raise ValueError\n\n    def S(a):\n        # print(a)\n        if len(a) < 2:\n            return sum(a)\n        if len(a) == 2:\n            return min(a) + max(a)\n        m1 = min(a)\n        m2 = max(a)\n        t1 = S(a[1:]) + m1\n        t2 = S(a[1:]) + m2\n        return min(t1, t2)\n\n    if a[0] + b[0] > a[1] + b[1]:\n        ans = S([a[0], b[0], a[1], b[1]])\n    else:\n        ans = S([a[1], b[1], a[0], b[0]])\n\n    return str(ans % MAX)\n"
    },
    {
        "number": 3275,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, C, Q = map(int, stdin.split())\n    a_queue = collections.deque()\n    b_queue = collections.deque()\n    requirements_counter = collections.Counter()\n    requirements_counter[\"a\"] = 0\n    requirements_counter[\"b\"] = 0\n    requirements_counter[\"c\"] = 0\n    requirements_counter[\"d\"] = 0\n    requirements_counter[\"e\"] = 0\n    requirements_counter[\"f\"] = 0\n    requirements_counter[\"g\"] = 0\n    requirements_counter[\"h\"] = 0\n    requirements_counter[\"i\"] = 0\n\n    for _ in range(N):\n        requirements_counter[input()] += 1\n    requirements_counter[\"c\"] += requirements_counter[\"a\"]\n    requirements_counter[\"d\"] += requirements_counter[\"b\"]\n    requirements_counter[\"e\"] += requirements_counter[\"c\"]\n    requirements_counter[\"f\"] += requirements_counter[\"d\"]\n    requirements_counter[\"g\"] += requirements_counter[\"e\"]\n    requirements_counter[\"h\"] += requirements_counter[\"f\"]\n    requirements_counter[\"i\"] += requirements_counter[\"g\"]\n\n    a_queue.append(input())\n    b_queue.append(input())\n\n    for _ in range(Q):\n        P = int(input())\n        a_queue.append(input())\n        b_queue.append(input())\n\n    result = 0\n    for _ in range(Q):\n        a_queue.append(input())\n        b_queue.append(input())\n\n    a_queue.sort()\n    b_queue.sort()\n    for a in a_queue:\n        if a == \"a\":\n            result += requirements_counter[\"a\"]\n            if requirements_counter[\"a\"] == 0:\n                result += 1\n        if a == \"b\":\n            result += requirements_counter[\"b\"]\n            if requirements_counter[\"b\"] == 0:\n                result += 1\n        if a == \"c\":\n            result += requirements_counter[\"c\"]\n            if requirements_counter[\"c\"] == 0:\n                result += 1\n        if a == \"d\":\n            result += requirements_counter[\"d\"]\n            if requirements_counter[\"d\"] == 0:\n                result += 1\n        if a == \"e\":\n            result += requirements_counter[\"e\"]\n            if requirements_counter[\"e\"] == 0:\n                result += 1\n        if a == \"f\":\n            result += requirements_counter[\"f\"]\n            if requirements_counter[\"f\"] == 0:\n                result += 1\n        if a == \"g\":\n            result += requirements_counter[\"g\"]\n            if requirements_counter[\"g\"] == 0:\n                result += 1\n        if a == \"h\":\n            result += requirements_counter[\"h\"]\n            if requirements_counter[\"h\"] == 0:\n                result += 1\n        if a == \"i\":\n            result += requirements_counter[\"i\"]\n            if requirements_counter[\"i\"] == 0:\n                result += 1\n    return str(result % 10**7)\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.strip().split())\n    board = [[i for i in stdin.strip()] for _ in range(N)]\n    color = {'R': 0, 'G': 1, 'B': 2, 'W': 3}\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] not in color:\n                continue\n            if i-3 < 0:\n                if j-3 < 0:\n                    if board[i][j]!= board[i+3][j+3]:\n                        return 'NO'\n                elif j-3 >= 0:\n                    if board[i][j]!= board[i+3][j-3]:\n                        return 'NO'\n            elif i-3 >= 0:\n                if j-3 < 0:\n                    if board[i][j]!= board[i-3][j+3]:\n                        return 'NO'\n                elif j-3 >= 0:\n                    if board[i][j]!= board[i-3][j-3]:\n                        return 'NO'\n            if i+3 < 0:\n                if j-3 < 0:\n                    if board[i][j]!= board[i+3][j+3]:\n                        return 'NO'\n                elif j-3 >= 0:\n                    if board[i][j]!= board[i+3][j-3]:\n                        return 'NO'\n            elif i+3 >= 0:\n                if j-3 < 0:\n                    if board[i][j]!= board[i-3][j+3]:\n                        return 'NO'\n                elif j-3 >= 0:\n                    if board[i][j]!= board[i-3][j-3]:\n                        return 'NO'\n    return 'YES'"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cells = [set(input()) for _ in range(N)]\n    for i in range(3):\n        for j in range(3):\n            if cells[i][j] not in set('WRRBG'):\n                return 'NO'\n    return 'YES'\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = []\n    for _ in range(n):\n        board.append(stdin)\n    visited = set()\n    for _ in range(n):\n        visited.add(stdin)\n    stack = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == \"R\":\n                stack.append((i, j))\n    while stack:\n        i, j = stack.pop()\n        board[i][j] = \"W\"\n        for x, y in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n            if 0 <= i + x < n and 0 <= j + y < m and board[i + x][j + y]!= \"W\":\n                if board[i + x][j + y] in \"RGB\":\n                    board[i + x][j + y] = \"W\"\n                else:\n                    visited.add(board[i + x][j + y])\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == \"W\":\n                return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"YES\"\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the output string if the puzzle is solvable, otherwise False.\"\"\"\n    N, M = list(map(int, stdin.split()))\n    colors = set()\n    for i in range(N):\n        curr = stdin.split()[i]\n        if curr == \"R\":\n            colors.add('R')\n        elif curr == \"B\":\n            colors.add('B')\n        elif curr == \"G\":\n            colors.add('G')\n        elif curr == \"W\":\n            colors.add('W')\n\n    for i in range(N):\n        if len(colors)!= 4:\n            return \"NO\"\n        curr = stdin.split()[i]\n        if (curr == \"R\" or curr == \"B\" or curr == \"G\") and len(colors) > 1:\n            return \"NO\"\n        colors = colors - {curr}\n    return \"YES\"\n\nprint(solution(input()))\n\nclass UnionFind():\n    def __init__(self, n):\n        self.parents = [-1] * n\n        self.rn = n\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n    \n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\nclass UnionFind2():\n    def __init__(self, n):\n        self.parents = [-1] * n\n        self.rn = n\n    \n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n    \n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rn[x] < self.rn[y]:\n            self.parents[x] += self.parents[y]\n            self.parents[y] = x\n        else:\n            self.parents[y] += self.parents[x]\n            self.parents[x] = y\n            if self.rn[x] == self.rn[y]:\n                self.rn[x] += 1\n    \n    def get_size(self, x):\n        return -self.parents[self.find(x)]\n    \n    def check(self, x, y):\n        return self.find(x) == self.find(y)\n\ndef"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # turn stdin to a 2D list\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    # check if first char is R\n    # check if last char is R\n    # check if each row is correct\n    # check if each column is correct\n    # check if each square is correct\n    \n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    # turn stdin to a 2D list\n    "
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    for _ in range(len(stdin)):\n        stdin[_] = stdin[_].split()\n    colors = [\"R\", \"G\", \"B\", \"W\"]\n    rows = []\n    stamp = []\n    for row in range(len(stdin)):\n        rows.append(stdin[row])\n        stamp.append([])\n    i = 0\n    while i < len(rows):\n        j = 0\n        while j < len(rows[i]):\n            stamp[i].append(rows[i][j])\n            if rows[i][j] in colors:\n                colors.remove(rows[i][j])\n            j += 1\n        i += 1\n    if len(colors) > 0:\n        return \"NO\"\n    row = 0\n    while row < len(stamp):\n        i = 0\n        while i < len(stamp[row]):\n            if len(stamp[row]) == 0:\n                row += 1\n                continue\n            if len(stamp[row]) == 1:\n                i += 1\n                continue\n            if stamp[row][i] == stamp[row][i + 1]:\n                i += 2\n                continue\n            else:\n                return \"NO\"\n    return \"YES\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, m = stdin[0], stdin[1]\n    board = stdin[2]\n    red = stdin[3]\n    green = stdin[4]\n    blue = stdin[5]\n    stamp = stdin[6]\n    final = stdin[7]\n    ans = \"NO\"\n    if n == m:\n        ans = \"NO\"\n    else:\n        if n == \"2\" and m == \"2\":\n            if board[0] == red and board[1] == red and board[2] == green and board[3] == green and board[4] == red and board[5] == red:\n                ans = \"YES\"\n        elif n == \"3\" and m == \"3\":\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == blue and board[4] == red and board[5] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == blue and board[3] == green and board[4] == green and board[5] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == green and board[2] == blue and board[3] == red and board[4] == green and board[5] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == green and board[2] == red and board[3] == blue and board[4] == blue and board[5] == red:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == blue and board[2] == blue and board[3] == green and board[4] == green and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == blue and board[2] == green and board[3] == red and board[4] == red and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == red and board[2] == green and board[3] == blue and board[4] == red and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == green and board[1] == red and board[2] == red and board[3] == blue and board[4] == blue and board[5] == red:\n                ans = \"YES\"\n            if board[0] == green and board[1] == green and board[2] == red and board[3] == red and board[4] == green and board[5] == green:\n                ans = \"YES\"\n            if board[0] == green and board[1] == red and board[2] == green and board[3] == red and board[4] == red and board[5] == green:\n                ans = \"YES\"\n            if board[0] == green and board[1] == red and board[2] == green and board[3] == red and board[4] == red and board[5] == green:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == blue and board[4] == blue and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == blue and board[3] == green and board[4] == green and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == red and board[1] == blue and board[2] == green and board[3] == red and board[4] == green and board[5] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == blue and board[2] == red and board[3] == blue and board[4] == blue and board[5] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == blue and board[3] == blue and board[4] == green and board[5] == green:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == red and board[2] == blue and board[3] == red and board[4] == green and board[5] == green:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == green and board[2] == red and board[3] == red and board[4] == green and board[5] == red:\n                ans = \"YES\"\n            if board[0] == blue and board[1] == green and board[2] == blue and board[3] == red and board[4] == green and board[5] == blue:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == red:\n                ans = \"YES\"\n        elif n == \"3\" and m == \"4\":\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == red and board[6] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == green and board[6] == red:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == red and board[6] == blue:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == red and board[6] == blue:\n                ans = \"YES\"\n            if board[0] == red and board[1] == red and board[2] == red and board[3] == red and board[4] == red and board[5] == red and board[6] == red:\n                ans = \"YES\"\n            if board"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    grid = []\n    for i in range(N):\n        grid.append(stdin.replace(\"R\", \"W\").replace(\"G\", \"W\").replace(\"B\", \"W\").replace(\"W\", \"W\"))\n    max_len = max([len(line) for line in grid])\n    return \"YES\" if max_len < 3*M else \"NO\"\n"
    },
    {
        "number": 3276,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = (int(x) for x in stdin.split())\n    grid = [['W' for i in range(M)] for j in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i == j == 0:\n                continue\n            if i == j == (N - 1):\n                grid[i][j] = 'R'\n            elif i == j == (N - 2):\n                grid[i][j] = 'G'\n            elif i == j == (N - 3):\n                grid[i][j] = 'B'\n            else:\n                grid[i][j] = 'W'\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j]!= 'W':\n                continue\n            if j == (M - 1) or j == (M - 2):\n                continue\n            else:\n                if grid[i][j] == 'W' and grid[i][j + 1] == 'W' and grid[i][j + 2] == 'W':\n                    return 'NO'\n    return 'YES'\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s = list(map(int, stdin.split()))\n    \n    if (s - k) % k!= 0:\n        return -1\n    return s - (s - k) // k\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split())\n    if N <= K or N <= S:\n        return 'No'\n\n    prefix = list(map(int, stdin.split()))\n\n    def make_k_s(prefix, k, s):\n        print(prefix)\n        if k == 1:\n            return prefix == sorted(prefix)\n        if k == 2:\n            # check if the number of prefixes is greater than or equal to K\n            if len(prefix) >= k:\n                return prefix[-k] == prefix[0]\n            return False\n\n        # get middle number\n        middle = k // 2\n        middle_value = prefix[middle]\n        prefix_left = prefix[:middle]\n        prefix_right = prefix[middle + 1:]\n\n        return make_k_s(prefix_left, k, s) and make_k_s(prefix_right, k, s)\n\n    return str(make_k_s(prefix, K, S))\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = list(map(int, stdin.split()))\n    smooth = lambda a: sum(range(K, len(a)+1, K)) == S\n    diffs = map(smooth, map(int, stdin.split()))\n    return str(sum(1 for i in diffs if i))"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = stdin.split()\n    N = int(N)\n    K = int(K)\n    S = int(S)\n    start = 0\n    end = S\n    count = 0\n    ans = 0\n    while end < N:\n        if (start == end):\n            start = 0\n            end += 1\n        end += 1\n        if end > N:\n            break\n        count += 1\n        if (count == K):\n            ans += 1\n            count = 0\n    return str(ans)"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n\n    def count_changes(arr, k, s):\n        cnt = 0\n        prev = 0\n        for i, x in enumerate(arr):\n            if x!= prev:\n                cnt += 1\n                if i >= k - 1:\n                    if cnt == s:\n                        return cnt\n                else:\n                    cnt = 0\n            else:\n                cnt += 1\n            prev = x\n        return cnt\n\n    return str(count_changes(arr, k, s))\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Get array\n    N, K, S = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    \n    # Fix first element\n    i = 1\n    while i < N:\n        # Check if element is not equal to previous\n        if arr[i]!= arr[i-1] + 1:\n            # If element is not equal, change it\n            arr[i] += 1\n        i += 1\n    \n    # Fix all the following elements\n    i = N - 1\n    while i >= 0:\n        # Check if element is not equal to previous\n        if arr[i]!= arr[i+1] - 1:\n            # If element is not equal, change it\n            arr[i] += 1\n        i -= 1\n    \n    # Check if all elements are equal\n    for i in range(N):\n        if arr[i]!= S:\n            # If not, return -1\n            return '-1'\n    \n    return str(N - arr.count(S))\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    a = sorted(a)\n    dp = [0] * n\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + abs(a[i] - a[i - 1])\n    for i in range(k, n):\n        for j in range(i - k, i):\n            dp[i] = max(dp[i], dp[j] + abs(a[i] - a[j]))\n    return str(dp[n - 1])\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    infile = stdin = stdin.rstrip()\n    N, K, S = map(int, infile.split())\n    A = list(map(int, infile.split()))\n    i = 0\n    j = N - K\n    count = 0\n    while i < j and count < N - 1:\n        count += 1\n        s = 0\n        for n in range(K):\n            s += A[i + n]\n        if s == S:\n            if count == N - 1:\n                return count\n            i += K\n        else:\n            i += 1\n    return count\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = list(map(int, stdin.split()))\n    return str(min(K, S - K) + (K - 1) * (S - K))\n"
    },
    {
        "number": 3277,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    arr, k, s = map(int, stdin.split(\" \"))\n    A = list(map(int, stdin.split(\" \")))\n    L = len(A)\n    count = 0\n    while k > 0:\n        count += 1\n        k -= 1\n        if k == 0:\n            break\n        for i in range(L):\n            A[i] = sum(A[i:i+k])\n            if A[i] == s:\n                k = 0\n                break\n    return str(count)\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    frogs = sorted(list(map(lambda x: (int(x.split()[0]), int(x.split()[1])), [stdin] * n)), key=lambda x: (x[0], x[1]))\n    pos, size = 1, 1\n    for frog in frogs:\n        if pos * 2 > frog[1]:\n            pos *= 2\n        if pos > frog[0]:\n            size = max(size, pos - frog[0])\n        pos = max(frog[1], pos)\n    return str(size) + \" \" + str(pos)\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your puzzle answer\"\"\"\n    n = int(stdin.strip())\n    frogs = []\n    for _ in range(n):\n        x, d = map(int, stdin.strip().split())\n        frogs.append([x, d])\n    frogs.sort(key=lambda x: x[0])\n    frogs.sort(key=lambda x: x[1], reverse=True)\n    return \" \".join(map(str, [frogs[0][0], frogs[0][1]]))\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *lines = stdin.split()\n    n = int(n)\n    frogs = list(map(lambda x: int(x), lines))\n    frogs.sort()\n    frogs.reverse()\n    print(frogs[0], frogs[-1])\n    return''.join(map(str, sorted(frogs)[0:2]))\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Possible positions (on the road) for a frog to stand are the following:\n        - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n        - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    res = []\n    frogs = []\n    for line in stdin.splitlines():\n        frogs.append((int(line.split()[1]), int(line.split()[2])))\n\n    # print(frogs)\n\n    frogs.sort()\n    frogs.sort(key=lambda x: x[1], reverse=True)\n    # print(frogs)\n\n    res.append(frogs[0][0])\n    res.append(frogs[0][1])\n\n    for frog in frogs:\n        if frog[1] == res[1]:\n            res[0] = frog[0]\n            continue\n        else:\n            break\n\n    return''.join([str(i) for i in res])\n\n\nprint(solution(input()))\n\n\"\"\""
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *x, d = list(map(int, stdin.split()))\n    x.sort()\n    d.sort()\n    x = list(map(str, x))\n    d = list(map(str, d))\n    x =''.join(x)\n    d =''.join(d)\n    return f'{x} {d}'\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *xs, *ds = map(int, stdin.split())\n    assert 1 <= n <= 40\n    assert all(0 <= x <= 2 ** 60 for x in xs)\n    assert all(2 <= d <= 10 ** 8 for d in ds)\n    xs.sort()\n    ds.sort()\n    return''.join(map(str, (max(xs), max(ds))))"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return''.join([str(min(int(x), int(y))), str(max(int(x), int(y)))])\n"
    },
    {
        "number": 3278,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().splitlines()\n\n    # First, calculate the product of all jumping distances\n    jump_distances = []\n    for i in range(len(lines)):\n        jump_distances.append(int(lines[i].split()[1]) * int(lines[i].split()[0]))\n\n    # If the jumping distances product is less than 10^9, print the result\n    if int(reduce(lambda x, y: x * y, jump_distances)) < 10**9:\n        return \" \".join(map(str, sorted(sorted(jump_distances), reverse=True)[:2]))\n\n    # Else, print the result with the largest prime jumping distance first\n    jump_distances.sort(key=lambda x: x, reverse=True)\n    return \" \".join(map(str, sorted(sorted(jump_distances)[:2])))\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.strip())\n    if n == 0:\n        return \"0\" * n + \"1\" * n\n    rows: List[List[str]] = []\n    for i in range(n):\n        rows.append(stdin.strip().split())\n    result = \"0\" * (n + 1)\n    for row in rows:\n        cur_line = \"\"\n        cur_col = \"\"\n        for i in range(len(row)):\n            if row[i] == \"0\":\n                cur_line = cur_line + \"0\"\n                cur_col = cur_col + \"0\"\n            else:\n                cur_line = cur_line + \"1\"\n                cur_col = cur_col + \"1\"\n        result = result[0:len(cur_line)] + cur_line + result[len(cur_col):]\n    return result"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    print(stdin)\n    print(n)\n    for i in range(n):\n        print(i)\n        print(i+1)\n        # i+1 refers to the vertical border\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        # i+1 refers to the vertical border\n        print(i)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i)\n        # i refers to the vertical border\n        print(i)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        # i refers to the horizontal border\n        print(i+1)\n        # i refers to the vertical border\n        print(i+1)\n        "
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    numRows: int = int(stdin.split()[0])\n    borders: list = list()\n    for i in range(numRows):\n        borders.append(list(map(int, stdin.split()[i + 1])))\n    borders = sorted(borders, key=lambda x: x[0])\n    solutions: list = list()\n    for i in range(len(borders)):\n        if i == 0:\n            solutions.append([0] * len(borders))\n        if i == len(borders) - 1:\n            solutions.append([0] + borders[i] + [0])\n        else:\n            solutions.append([0] + borders[i] + [0])\n    for row in range(numRows):\n        for col in range(len(borders)):\n            if solutions[row][col] == 1 and solutions[row + 1][col] == 1 and solutions[row][col + 1] == 1 and solutions[row + 1][col + 1] == 1:\n                return \"\".join([\"1\"] * len(solutions[0])) + \"\".join([\"0\"] * len(solutions[0]))\n    return \"\".join([\"1\"] * len(solutions[0])) + \"\".join([\"0\"] * len(solutions[0]))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    n_rows = n_cols = 2 * n - 1\n    borders = [[0] * n_cols] * n_rows\n    bar_col = border_col = 0\n    for row in range(1, n_rows + 1):\n        for col in range(1, n_cols + 1):\n            if row == 1 or row == n_rows - 1:\n                if row == 1:\n                    borders[row][col] = 1\n                elif row == n_rows - 1:\n                    borders[row][col] = 1\n            if col == 1 or col == n_cols - 1:\n                if col == 1:\n                    borders[row][col] = 1\n                elif col == n_cols - 1:\n                    borders[row][col] = 1\n            if row == 1 or row == n_rows - 1:\n                if borders[row][col - 1] == 1 and borders[row][col + 1] == 1:\n                    bar_col = col\n            if col == 1 or col == n_cols - 1:\n                if borders[row - 1][col] == 1 and borders[row + 1][col] == 1:\n                    border_col = col\n            if borders[row - 1][col - 1] == 1 and borders[row + 1][col + 1] == 1:\n                borders[row][col] = 1\n            else:\n                borders[row][col] = 0\n\n    results = [[0] * n_cols] * n_rows\n    for row in range(1, n_rows + 1):\n        results[row] = [0] * n_cols\n    for i in range(n_cols):\n        if borders[n_rows - 1][i] == 1:\n            results[n_rows - 1][i] = 1\n        if borders[0][i] == 1:\n            results[0][i] = 1\n\n    solution = \"\"\n    for i in range(n_rows):\n        solution += str(results[i][bar_col])\n        solution += str(results[i][border_col])\n    return solution\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for line in stdin.strip().split(\"\\n\")[:n]:\n        line = list(map(int, line.split()))\n        if line[0] == 0:\n            pass\n        else:\n            i = 1\n            while i < n:\n                if line[i] == 0:\n                    line[i] = 1\n                    i += 1\n                else:\n                    i += 1\n    for line in stdin.strip().split(\"\\n\")[n:]:\n        line = list(map(int, line.split()))\n        if line[0] == 0:\n            pass\n        else:\n            i = 0\n            while i < n:\n                if line[i] == 0:\n                    line[i] = 1\n                    i += 1\n                else:\n                    i += 1\n    return \"\\n\".join([str(line).replace(\"1\", \"0\") for line in list(map(\"\".join, list(zip(*stdin.strip().split(\"\\n\")))) if not all(map(lambda x: x == 0, line))])\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    answer = []\n    for i in range(n):\n        line = stdin.split()\n        first = line[0]\n        second = line[1]\n        first = first.split(\" \")\n        second = second.split(\" \")\n        # print(first)\n        # print(second)\n        first_number = int(first[0])\n        second_number = int(second[0])\n        if first_number == 0 and second_number == 0:\n            answer = [[1, 0], ]\n            answer = answer * int(first[1])\n            break\n        elif first_number == 0 and second_number > 0:\n            for i in range(second_number):\n                answer.append([1, 0])\n        elif first_number > 0 and second_number == 0:\n            for i in range(first_number):\n                answer.append([0, 1])\n        else:\n            for i in range(first_number):\n                for j in range(second_number):\n                    answer.append([0, 1])\n    for i in range(len(answer)):\n        if answer[i][0] == 1:\n            answer[i] = \"1\"\n        else:\n            answer[i] = \"0\"\n    return \"\".join(answer)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    rows = [0]*(n+1)\n    cols = [0]*(n+1)\n    for _ in range(n):\n        row, col = map(int, stdin.split())\n        rows[row] = 1\n        cols[col] = 1\n    for i in range(n):\n        if rows[i] == 1:\n            for j in range(i+1,n+1):\n                if rows[j] == 1:\n                    rows[i+1] = 1\n                    break\n        if cols[i] == 1:\n            for j in range(i+1,n+1):\n                if cols[j] == 1:\n                    cols[i+1] = 1\n                    break\n    for i in range(1,n+1):\n        if rows[i] == 1 and cols[i] == 1:\n            continue\n        if rows[i] == 1:\n            for j in range(1,n+1):\n                if cols[j] == 1:\n                    print(i, j)\n                    return str(i)\n            return \"0\"\n        if cols[i] == 1:\n            for j in range(1,n+1):\n                if rows[j] == 1:\n                    print(i, j)\n                    return str(i)\n            return \"0\"\n    return \"0\""
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    grid = [[int(c) for c in stdin.split()] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            valid = True\n            if j == 0:\n                if grid[i-1][j] == grid[i][j]:\n                    valid = False\n            elif j == n-1:\n                if grid[i-1][j-1] == grid[i][j]:\n                    valid = False\n            else:\n                if grid[i-1][j-1] == grid[i][j] and grid[i][j-1] == grid[i][j]:\n                    valid = False\n            if valid:\n                print((i+1)*(j+1))\n                return ''\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            valid = True\n            if i == 0:\n                if grid[i][j-1] == grid[i][j]:\n                    valid = False\n            elif i == n-1:\n                if grid[i-1][j-1] == grid[i][j]:\n                    valid = False\n            else:\n                if grid[i-1][j-1] == grid[i][j] and grid[i+1][j-1] == grid[i][j]:\n                    valid = False\n            if valid:\n                print((i+1)*(j+1))\n                return ''\n    return ''\n\nprint(solution(input()))\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    rows = [[int(stdin) for _ in range(n + 1)] for _ in range(n)]\n    columns = [[int(stdin) for _ in range(n)] for _ in range(n)]\n    result = ''.join([''.join(map(str, row)) for row in rows])\n    result += ''.join([''.join(map(str, column)) for column in columns])\n    return result\n"
    },
    {
        "number": 3279,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    borders = [int(i) for i in stdin.split()[1:n+1]]\n    border = [(0,0), (0,1), (1,0), (1,1)]\n    # print(border)\n    for i in range(0, n):\n        if borders[i] == 0:\n            continue\n        for j in range(i+1, n):\n            if borders[j] == 0:\n                continue\n            if borders[i]!= borders[j]:\n                print(\"Not solution\")\n                return\n        for j in range(0, n-1):\n            if borders[j] == 0:\n                continue\n            if borders[i]!= borders[j]:\n                print(\"Not solution\")\n                return\n    ans = []\n    for i in range(0, n):\n        if borders[i] == 0:\n            ans.append('0')\n        else:\n            ans.append('1')\n    ans = ''.join(ans)\n    print(ans)\n    return ans\n\nsolution(input())"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(i) for i in stdin.split())\n    return str(find_max(n, k))\n\n\ndef"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def solution_1(n, k, arr):\n        res = [[0,0]]\n        for i in range(1, n+1):\n            for j in range(len(res)):\n                if res[j][1] == i:\n                    res[j][1] = 1\n                    break\n            else:\n                res.append([i,0])\n        for i in range(1, len(res)-1):\n            if res[i][1] == res[i+1][0]:\n                res[i][1] = res[i-1][0]\n        res = sorted(res, key=lambda x: x[0])\n        res = sorted(res, key=lambda x: x[1])\n        res = int(\"\".join([str(i) for i in res]))\n        return res\n\n    def solution_2(n, k, arr):\n        res = 0\n        for i in range(n):\n            res += k if arr[i] < arr[i+1] else 0\n        return res\n    return solution_1(*stdin.split())\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    max_stdin = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if k + j - i > max_stdin:\n                max_stdin = k + j - i\n    return str(max_stdin)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tape = [[] for _ in range(n)]\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        x, y = x - 1, y - 1\n        tape[x].append(y)\n    max_t = 0\n    for i in range(n):\n        temp = list(filter(lambda x: x == i, tape[i]))\n        if len(temp) >= k:\n            max_t = max(max_t, len(temp))\n    return str(max_t)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.strip().split())\n    return str(min(n, m))\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    m = int(math.ceil(n / k))\n    return str(m)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def check(n: int, a: int, b: int) -> bool:\n        return (a >= 0 and b >= 0) and (a + b <= n)\n\n    def calc(n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        else:\n            res = 1\n            for i in range(n - 1):\n                res *= 2\n            return res\n\n    a, b = map(int, stdin.split())\n    n = calc(b) - calc(a - 1)\n    return str(n)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    v = []\n    for _ in range(n):\n        start, end = map(int, stdin.split())\n        v.append((start, end))\n    v.sort(key=lambda x: x[1])\n    result = 0\n    start, end = 0, 0\n    for i in range(n):\n        start = v[i][0]\n        end = v[i][1]\n        if start > end:\n            continue\n        result = max(result, end - start)\n    return str(result)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    all_shows = set()\n    shows = defaultdict(list)\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split())\n        shows[x].append(y)\n        all_shows.add(x)\n    total = 0\n    for show, lst in shows.items():\n        if len(lst) == k:\n            total += 1\n        elif len(lst) == k+1:\n            for i in range(len(lst)):\n                if show + 1!= lst[i]:\n                    break\n                elif i == len(lst) - 1:\n                    total += 1\n    return str(total)\n"
    },
    {
        "number": 3280,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(i) for i in stdin.split())\n    return str(max((K - 1) * (N - 1), K * N - (K - 1)))\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n\n    # For a single lane road, there is no need to take any turning\n    # angle.\n    def is_straight_road(a, b):\n        x1, y1 = map(int, (a.split()))\n        x2, y2 = map(int, (b.split()))\n        return abs(x1 - x2) <= d and abs(y1 - y2) <= d\n\n    # A single lane road only needs to take a minimum of one turn\n    # angle to turn.\n    def min_turn_angle(a, b):\n        x1, y1 = map(int, (a.split()))\n        x2, y2 = map(int, (b.split()))\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    roads = {\n        # Straight road, no need to turn.\n        (1, 2): is_straight_road,\n        # Straight road, take minimum turn angle to turn.\n        (1, 3): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (1, 4): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (1, 5): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (2, 3): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (2, 4): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (2, 5): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (3, 4): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (3, 5): min_turn_angle,\n        # Straight road, take minimum turn angle to turn.\n        (4, 5): min_turn_angle,\n    }\n\n    # We will add the starting and ending junctions only once.\n    junctions = {1}\n    roads_by_junctions = {1: {2}}\n    done = {1}\n\n    # Iterate through every possible source and destination.\n    for source in range(1, n + 1):\n        for destination in range(1, n + 1):\n            if source == destination:\n                continue\n\n            # Check if this is a valid road.\n            if (source, destination) not in roads:\n                continue\n\n            # Check if this is a valid road.\n            if roads[(source, destination)](stdin):\n                # Make sure we don't have more than one straight road.\n                if roads_by_junctions[source] == {}:\n                    junctions.add(source)\n                    roads_by_junctions[source] = {}\n\n                junctions.add(destination)\n                roads_by_junctions[source][destination] = True\n\n                # Make sure we don't have more than one straight road.\n                if roads_by_junctions[destination] == {}:\n                    junctions.add(destination)\n                    roads_by_junctions[destination] = {}\n\n                # Make sure we don't have more than one straight road.\n                if roads_by_junctions[destination][source] is True:\n                    continue\n\n                # Make sure we don't have more than one straight road.\n                junctions.add(source)\n                roads_by_junctions[destination][source] = True\n                done.add(source)\n                done.add(destination)\n\n    # We don't want to do any more roads, so return nothing.\n    if len(junctions) == 1:\n        return 'Impossible'\n\n    # Sort junctions by the total distance to each other.\n    junctions = sorted(junctions, key=lambda x: -sum([abs(int(y)) for y in roads_by_junctions[x].keys()]))\n\n    # Now that we have sorted the junctions, we can go through them.\n    turning = 0\n    best_turning = 0\n    worst_turning = 0\n\n    for junction in junctions:\n        # The current junction has no roads going through it.\n        if not roads_by_junctions[junction]:\n            continue\n\n        # Iterate through the list of roads and check if there is a valid turning\n        # angle.\n        for road in roads_by_junctions[junction]:\n            # We already checked if the road is valid so we can skip it.\n            if road in done:\n                continue\n\n            # Check if there is a valid turning angle.\n            if roads[(junction, road)](stdin):\n                turning += 1\n                if turning > best_turning:\n                    best_turning = turning\n                worst_turning = turning\n                done.add(road)\n\n    # Return the best turning angle.\n    if worst_turning == 0:\n        return 'Impossible'\n\n    # Convert the result into degrees.\n    return str(degrees(math.pi * (1 / 2) * (worst_turning / len(junctions))))\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    (J, R, D) = (int(x) for x in stdin.split())\n    n = {}\n    j = 1\n    for _ in range(J):\n        n[j] = (int(x) for x in stdin.split())\n        j += 1\n\n    q = [(1, 1)]\n    seen = {(1, 1)}\n    while q:\n        i, j = q.pop(0)\n        for jj in range(j, min(j + R, J) + 1):\n            for ii in range(i, min(i + D, J) + 1):\n                if (ii, jj) in seen:\n                    continue\n                if jj == j:\n                    continue\n                if (ii, jj) == (i, j):\n                    continue\n                for r in range(J):\n                    if n[ii][r]!= -1 and n[ii][r]!= jj:\n                        break\n                else:\n                    q.append((ii, jj))\n                    seen.add((ii, jj))\n    seen = {(1, 1)}\n    ans = 0\n    max_r = 1\n    while max_r < J:\n        ans += 90\n        max_r = len(seen)\n        seen |= {(i, j) for i, j in seen if j < max_r}\n    return str(round(ans / 180 * 3.1415926535, 6))\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    j, r, d = map(int, stdin.split())\n    ans = -1\n    x = []\n    y = []\n    for i in range(j):\n        x.append(int(input()))\n        y.append(int(input()))\n    l = 0\n    c = x[1] - x[0]\n    for i in range(len(x)):\n        if i > 0:\n            l += c\n            c = x[i] - x[i - 1]\n        if i > 0 and l >= d:\n            break\n    if l > d:\n        return \"Impossible\"\n    m = 0\n    for i in range(len(y)):\n        if i > 0:\n            l += c\n            c = y[i] - y[i - 1]\n        if i > 0 and l >= d:\n            break\n        m = max(m, max(y[i] - x[i], x[i] - y[i]) / min(y[i], x[i]))\n    ans = -1\n    if m!= 0:\n        ans = m\n    return str(int(ans))"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    j, r, d = map(int, stdin.split())\n\n    roads = [[] for _ in range(j)]\n    for i in range(r):\n        road = list(map(int, stdin.split()))\n        roads[road[0] - 1].append(road[2])\n        roads[road[1] - 1].append(road[2])\n\n    def break_dual_road(j, road):\n        if road in roads[j - 1]:\n            roads[j - 1].remove(road)\n            roads[j - 1].append(road)\n        else:\n            roads[j - 1].append(road)\n            roads[j - 1].remove(road)\n\n    def break_straight_road(j, road):\n        if road in roads[j - 1]:\n            roads[j - 1].remove(road)\n            roads[j - 1].append(road)\n        else:\n            roads[j - 1].append(road)\n            roads[j - 1].remove(road)\n\n    def traverse(roads):\n        current_junction = 1\n        for road in roads:\n            if len(road) > 1:\n                for index, road_to in enumerate(road):\n                    if index + 1 < len(road):\n                        break_dual_road(current_junction, road_to)\n                        current_junction = road_to\n            else:\n                break_straight_road(current_junction, road[0])\n                current_junction = road[0]\n\n    traverse(roads)\n    answer = 0\n    for road in roads:\n        if road:\n            angle = (road[1] - road[0]) / (2 * d)\n            if angle < 0:\n                answer = max(answer, 360 - abs(angle))\n            else:\n                answer = max(answer, angle)\n    return '{:.8f}'.format(answer)\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    J, R, D = map(int, stdin.split())\n\n    # build map\n    _map = []\n    _max_road = {}\n\n    for j in range(1, J + 1):\n        _map.append([])\n        for r in range(1, R + 1):\n            road = tuple(map(float, stdin.split()))\n            _map[j - 1].append(road)\n            _max_road[(j, r)] = road\n            _max_road[(r, j)] = road\n    # print(_map)\n    # print(_max_road)\n\n    min_turning_angle = 180\n    min_turning_angle_way = None\n\n    for j in range(1, J + 1):\n        for r in range(1, R + 1):\n            for d in range(1, D + 1):\n                current_road = _max_road[(j, r)]\n                next_road = _max_road[(r, j)]\n                if next_road[0] == current_road[0]:\n                    if next_road[1] > current_road[1]:\n                        current_road = next_road\n                        min_turning_angle = 0\n                    elif next_road[1] < current_road[1]:\n                        next_road = current_road\n                        min_turning_angle = 0\n\n                if next_road[1] == current_road[1]:\n                    if next_road[0] > current_road[0]:\n                        current_road = next_road\n                        min_turning_angle = 0\n                    elif next_road[0] < current_road[0]:\n                        next_road = current_road\n                        min_turning_angle = 0\n\n                current_road = tuple(map(float, current_road))\n                next_road = tuple(map(float, next_road))\n\n                if d < min(current_road[0], next_road[0]):\n                    continue\n\n                turning_angle = math.degrees(math.atan2(next_road[1] - current_road[1], next_road[0] - current_road[0]))\n                if turning_angle <= min_turning_angle:\n                    min_turning_angle = turning_angle\n                    min_turning_angle_way = (j, r)\n\n    if min_turning_angle_way is None:\n        return \"Impossible\"\n\n    min_turning_angle_way = (min_turning_angle_way[0], min_turning_angle_way[1])\n    min_turning_angle = math.degrees(math.atan2(next_road[1] - current_road[1], next_road[0] - current_road[0]))\n\n    return str(min_turning_angle)\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    j, r, d = map(int, stdin.split())\n    x_y = map(int, stdin.split())\n    x_y = list(map(lambda x: x / 100, x_y))\n    return str(turn_angle(j, r, x_y))\n\n\ndef"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, R, D = map(int, stdin.strip().split())\n    j_x, j_y = [int(i) for i in stdin.strip().split()]\n    min_turning_angle = 10 ** 6\n    for j in range(N):\n        x, y = j_x, j_y\n        for i in range(1, R + 1):\n            if D >= x + i * 100 and x + i * 100 > y + i * 100 and i < R:\n                x, y = x + i * 100, y + i * 100\n                continue\n            if D >= y + i * 100 and y + i * 100 > x + i * 100 and i < R:\n                x, y = x + i * 100, y + i * 100\n                continue\n            if D >= x + i * 100 and D < y + i * 100:\n                x, y = x + i * 100, D\n            if D >= y + i * 100 and D < x + i * 100:\n                x, y = D, y + i * 100\n            break\n        if i == R:\n            continue\n        if D < abs(x - j_x) + abs(y - j_y) or D < abs(y - j_y) + abs(x - j_x):\n            continue\n        theta = abs((x - j_x) / (D - x)) * 180 / np.pi\n        if theta > min_turning_angle:\n            min_turning_angle = theta\n    if min_turning_angle < 10 ** 6:\n        return str(min_turning_angle)\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    J, R, D = map(int, stdin.strip().split())\n\n    roads = defaultdict(list)\n\n    for x, y in [(int(i), int(j)) for i, j in stdin.strip().split('\\n')[1:]]:\n        roads[x].append(y)\n        roads[y].append(x)\n    \n    # print(roads)\n\n    start = int(stdin.strip().split()[0])\n    stop = int(stdin.strip().split()[-1])\n    # print(start, stop)\n\n    def get_max_turning(start, stop, roads):\n        q = deque([[start, 0]])\n        visited = set()\n        while q:\n            node, turn_count = q.popleft()\n            visited.add(node)\n            if node == stop:\n                return turn_count\n            for next_node in roads[node]:\n                if next_node not in visited:\n                    q.append([next_node, turn_count + 1])\n\n    start_turning = get_max_turning(start, stop, roads)\n    stop_turning = get_max_turning(stop, stop, roads)\n\n    # print(start_turning, stop_turning)\n\n    def get_circular_turning(start, stop, roads):\n        q = deque([[start, 0]])\n        visited = set()\n        while q:\n            node, turn_count = q.popleft()\n            visited.add(node)\n            if node == stop:\n                return turn_count\n            for next_node in roads[node]:\n                if next_node not in visited:\n                    q.append([next_node, turn_count + 1])\n\n    circular_turning = get_circular_turning(start, stop, roads)\n\n    return str(round(min(start_turning, stop_turning, circular_turning), 6))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_junctions = int(stdin[0])\n    num_roads = int(stdin[1])\n    distance = int(stdin[2])\n\n    junctions = []\n    for i in range(num_junctions):\n        x, y = stdin[i + 3].split()\n        junctions.append((int(x), int(y)))\n\n    roads = []\n    for i in range(num_roads):\n        a, b = stdin[i + num_junctions + 3].split()\n        roads.append((int(a) - 1, int(b) - 1))\n\n    roads_set = set()\n    for road in roads:\n        roads_set.add(road)\n\n    junctions_set = set()\n    for junction in junctions:\n        junctions_set.add(junction)\n\n    for junction in junctions:\n        for road in roads:\n            if (junction[0] == road[0] or junction[0] == road[1]) and (\n                junction[1] == road[1] or junction[1] == road[0]\n            ):\n                roads_set.add(road)\n\n    for junction in junctions:\n        for road in roads:\n            if road in roads_set and (junction[0] == road[0] or junction[0] == road[1]):\n                junctions_set.add(junction)\n\n    for junction in junctions:\n        for road in roads:\n            if road in roads_set and (junction[1] == road[1] or junction[1] == road[0]):\n                junctions_set.add(junction)\n\n    num_junctions = len(junctions_set)\n    junctions_set = list(junctions_set)\n    junctions_set.sort(key=lambda x: x[0])\n    junctions_set.sort(key=lambda x: x[1])\n\n    max_turning_angle = 0.0\n    for i in range(num_junctions - 1):\n        j1 = junctions_set[i]\n        j2 = junctions_set[i + 1]\n\n        min_turning_angle = 360\n        for road in roads_set:\n            if (j1[1] - road[0]) * (road[1] - j2[1]) >= 0:\n                if (j1[0] - road[0]) * (road[1] - j2[0]) >= 0:\n                    if (j1[0] - road[0]) * (road[1] - j2[0]) > min_turning_angle:\n                        min_turning_angle = (j1[0] - road[0]) * (road[1] - j2[0])\n                        j_turning_angle = math.degrees(math.atan(min_turning_angle / ((j1[1] - road[0]) * (road[1] - j2[1]) + (j1[0] - road[0]) * (j2[1] - road[1]))))\n                else:\n                    min_turning_angle = (j2[0] - road[0]) * (road[1] - j1[0])\n                    j_turning_angle = math.degrees(math.atan(min_turning_angle / ((j2[1] - road[0]) * (road[1] - j1[1]) + (j2[0] - road[0]) * (j1[1] - road[1]))))\n\n                if j_turning_angle > max_turning_angle:\n                    max_turning_angle = j_turning_angle\n        if max_turning_angle > max_turning_angle + 1e-6:\n            return \"Impossible\"\n    return str(math.degrees(max_turning_angle))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3281,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Brute force solution\n    '''\n    road_length = []\n    for i in range(len(stdin)):\n        road_length.append(int(stdin[i].split()[0]))\n        road_length.append(int(stdin[i].split()[1]))\n    junction_1 = int(stdin.split()[2])\n    junction_2 = int(stdin.split()[3])\n    max_distance = int(stdin.split()[4])\n    trying_list = []\n    for i in range(len(road_length)):\n        trying_list.append(road_length[i]*(road_length[i] - 10**-6)/2)\n    for i in range(len(trying_list)):\n        trying_list[i] = abs(trying_list[i] - max_distance)\n    trying_list = sorted(trying_list, reverse=True)\n    trying_list = trying_list[0]\n    print(round(trying_list*180/3.14, 6))\n    if trying_list > 180*3.14/180:\n        return \"Impossible\"\n    else:\n        print(round(180*3.14/trying_list))"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [5, 10, 25, 50, 100, 200, 500]\n    # Create dictionary where the keys are the price of a certain coin and the value is the number of times it's been used.\n    # So the first loop traverses the list of coins, the first loop traverses the price of a certain coin,\n    # The second loop traverses the price of the next coin, the second loop traverses the next coin, and so on.\n    d = {c: 0 for c in coins}\n    for i in range(1, len(coins)):\n        # The coin with the lowest price is the starting point\n        for j in range(i, len(coins)):\n            # If the current coin price is greater than or equal to the previous coin price, then the previous coin has been used, so the number of coins needed to be multiplied by the current coin's price is incremented.\n            if coins[i] <= coins[j]:\n                d[coins[i]] += 1\n            # If the previous coin is greater than the current coin, the current coin has been used, so the number of coins needed to be multiplied by the previous coin's price is incremented.\n            else:\n                d[coins[i]] += 1\n                break\n    # After traversing the entire list of coins, determine the number of times a certain set of bills meet the constraints.\n    # Take the number of times a certain set of bills has been multiplied by a certain price.\n    # If the number of times a certain set of bills has been multiplied by a certain price equals to $P$, then that bill is a possible solution.\n    # When determining the number of times a certain set of bills has been multiplied by a certain price, take into account the number of times a certain set of bills has been multiplied by the previous price.\n    # If the number of times a certain set of bills has been multiplied by a certain price is greater than the previous bill, then the previous bill has been used.\n    # If the number of times a certain set of bills has been multiplied by a certain price is equal to the previous bill, then the previous bill has been used.\n    # If the number of times a certain set of bills has been multiplied by a certain price is less than the previous bill, then the current bill has been used.\n    # Create a list to store the maximum number of times a certain set of bills has been multiplied by a certain price.\n    # Add the maximum number of times a certain set of bills has been multiplied by a certain price to the list.\n    # If there are more than $5000$ possible bills, then only the first $5000$ bills are considered and the list is shortened.\n    # If a certain set of bills has been multiplied by a certain price is greater than the maximum value, then the maximum value is incremented.\n    # If a certain set of bills has been multiplied by a certain price is equal to the maximum value, then the maximum value is incremented.\n    # If a certain set of bills has been multiplied by a certain price is less than the maximum value, then the maximum value is incremented.\n    s = []\n    if len(coins) >= 5000:\n        for i in range(5000):\n            if d[i] == n:\n                s.append(i)\n                break\n        if len(s) > 0:\n            if d[s[0]] > d[s[1]]:\n                max_val = d[s[0]]\n            elif d[s[0]] == d[s[1]]:\n                max_val = d[s[0]] + 1\n            else:\n                max_val = d[s[1]]\n    else:\n        for i in range(len(coins)):\n            if d[i] == n:\n                s.append(i)\n                break\n        if len(s) > 0:\n            if d[s[0]] > d[s[1]]:\n                max_val = d[s[0]]\n            elif d[s[0]] == d[s[1]]:\n                max_val = d[s[0]] + 1\n            else:\n                max_val = d[s[1]]\n    return str(max_val)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    int_price = int(stdin)\n    # print(int_price)\n    if int_price > 5000:\n        return print(0)\n    if int_price == 0:\n        return print(0)\n    if int_price == 1:\n        return print(1)\n    if int_price == 2:\n        return print(1)\n    if int_price == 3:\n        return print(1)\n    if int_price == 4:\n        return print(1)\n    if int_price == 5:\n        return print(2)\n    if int_price == 6:\n        return print(2)\n    if int_price == 7:\n        return print(2)\n    if int_price == 8:\n        return print(3)\n    if int_price == 9:\n        return print(3)\n    if int_price == 10:\n        return print(3)\n    if int_price == 11:\n        return print(4)\n    if int_price == 12:\n        return print(4)\n    if int_price == 13:\n        return print(4)\n    if int_price == 14:\n        return print(5)\n    if int_price == 15:\n        return print(5)\n    if int_price == 16:\n        return print(5)\n    if int_price == 17:\n        return print(6)\n    if int_price == 18:\n        return print(6)\n    if int_price == 19:\n        return print(6)\n    if int_price == 20:\n        return print(7)\n    if int_price == 21:\n        return print(7)\n    if int_price == 22:\n        return print(7)\n    if int_price == 23:\n        return print(8)\n    if int_price == 24:\n        return print(8)\n    if int_price == 25:\n        return print(8)\n    if int_price == 26:\n        return print(9)\n    if int_price == 27:\n        return print(9)\n    if int_price == 28:\n        return print(9)\n    if int_price == 29:\n        return print(10)\n    if int_price == 30:\n        return print(10)\n    if int_price == 31:\n        return print(10)\n    if int_price == 32:\n        return print(11)\n    if int_price == 33:\n        return print(11)\n    if int_price == 34:\n        return print(11)\n    if int_price == 35:\n        return print(12)\n    if int_price == 36:\n        return print(12)\n    if int_price == 37:\n        return print(12)\n    return print(0)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    price = int(input[0])\n\n    beverages = set()\n    main_dishes = set()\n    total = 0\n\n    for line in input[1:]:\n        beverage, main = line.split()\n        beverages.add(int(beverage))\n        main_dishes.add(int(main))\n\n    for beverage in beverages:\n        for main_dish in main_dishes:\n            if beverage < main_dish and main_dish < total:\n                total += 1\n\n    beverages = sorted(list(beverages))\n    main_dishes = sorted(list(main_dishes))\n\n    for i in range(len(beverages)):\n        for j in range(len(main_dishes)):\n            if beverages[i] == main_dishes[j] and beverage < main_dishes[j] and main_dishes[j] < total:\n                total += 1\n\n    print(total)\n    print(beverages)\n    print(main_dishes)\n\n\nsolution(input)\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    P: int = int(stdin)\n    if P == 0:\n        return '0'\n    if P == 1:\n        return '1'\n    dp: List[int] = [1] * (P + 1)\n    possible_beverage_prices: List[int] = []\n    for i in range(2, len(dp)):\n        if i == 2:\n            dp[i] = 2\n            continue\n        if i == 3:\n            dp[i] = 3\n            continue\n        if i == 4:\n            dp[i] = 4\n            continue\n        if i == 5:\n            dp[i] = 5\n            continue\n        if i == 6:\n            dp[i] = 6\n            continue\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        possible_beverage_prices.append(i)\n    main_dish_prices: List[int] = []\n    for i in range(7, len(dp)):\n        if i == 7:\n            dp[i] = 7\n            continue\n        if i == 8:\n            dp[i] = 8\n            continue\n        if i == 9:\n            dp[i] = 9\n            continue\n        if i == 10:\n            dp[i] = 10\n            continue\n        if i == 11:\n            dp[i] = 11\n            continue\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        main_dish_prices.append(i)\n    total_prices: List[int] = []\n    for i in range(12, len(dp)):\n        if i == 12:\n            dp[i] = 12\n            continue\n        if i == 13:\n            dp[i] = 13\n            continue\n        if i == 14:\n            dp[i] = 14\n            continue\n        if i == 15:\n            dp[i] = 15\n            continue\n        if i == 16:\n            dp[i] = 16\n            continue\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        total_prices.append(i)\n    # print(dp)\n    dp = dp[:P + 1]\n    possible_beverage_prices = possible_beverage_prices[:P + 1]\n    main_dish_prices = main_dish_prices[:P + 1]\n    total_prices = total_prices[:P + 1]\n    # print(possible_beverage_prices, main_dish_prices, total_prices)\n    # print(len(possible_beverage_prices), len(main_dish_prices), len(total_prices))\n    possible_beverage_prices = sorted(possible_beverage_prices)\n    main_dish_prices = sorted(main_dish_prices)\n    total_prices = sorted(total_prices)\n    # print(possible_beverage_prices, main_dish_prices, total_prices)\n    # print(len(possible_beverage_prices), len(main_dish_prices), len(total_prices))\n    for i in range(1, len(possible_beverage_prices)):\n        for j in range(1, len(main_dish_prices)):\n            for k in range(1, len(total_prices)):\n                # print(possible_beverage_prices[i], main_dish_prices[j], total_prices[k])\n                if possible_beverage_prices[i] == possible_beverage_prices[i - 1] and main_dish_prices[j] == main_dish_prices[j - 1] and total_prices[k] == total_prices[k - 1]:\n                    dp[possible_beverage_prices[i]] = min(dp[possible_beverage_prices[i]] + dp[main_dish_prices[j]], dp[possible_beverage_prices[i]] + dp[total_prices[k]])\n                    if dp[possible_beverage_prices[i]] <= P:\n                        return str(dp[possible_beverage_prices[i]])\n                else:\n                    continue\n    if dp[possible_beverage_prices[i]] <= P:\n        return str(dp[possible_beverage_prices[i]])\n    else:\n        return str(dp[possible_beverage_prices[i - 1]])"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    if P >= 1 and P < 10:\n        return ''\n    if P >= 10 and P < 100:\n        return ''\n    if P >= 100 and P < 1000000:\n        return ''\n    if P >= 1000000 and P < 1000000000000:\n        return ''\n\n    bills = []\n    bills.append(P)\n    while (b := bills[-1]) <= 1000000000000:\n        if len(bills) == 0 or b == bills[-1]:\n            bills.append(bills[-1] * 10)\n        else:\n            bills.append(bills[-1] + b)\n    return bills\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Sample Input 1:\n    37\n    Sample Output 1:\n    4\n    8 29\n    9 28\n    11 26\n    15 22\n    '''\n    prices = [int(x) for x in stdin.split()]\n    if not prices:\n        return '0'\n    # Choose the rightmost non-zero element\n    i = 0\n    for j in range(len(prices)):\n        if prices[j] > 0:\n            i = j\n            break\n\n    # Return the max number of bills which result in a free dessert\n    return '{} {}'.format(len(prices), max(prices))\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #return stdin\n    return '7\\n' + '\\n'.join(sorted([str(p) + m for p, m in [(int(stdin), i) for i in range(1, 10)]])[:5000])\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    x = []\n    for i in range(0, int(stdin)):\n        x.append(int(stdin))\n    count = 0\n    prev = 0\n    d = {}\n    d2 = {}\n    d3 = {}\n    for i in range(0, len(x)):\n        if x[i] == prev:\n            count += 1\n            prev = x[i]\n        else:\n            if prev > 0:\n                if prev % 10 == 0:\n                    count = 0\n                    prev = 0\n                    continue\n                if count > 0:\n                    if x[i] % 10 == 0:\n                        d[prev] = x[i]\n                        count = 0\n                        prev = 0\n                        continue\n                if count > 5000:\n                    break\n            prev = x[i]\n            count = 1\n        if i == len(x) - 1:\n            if count > 0:\n                if x[i] % 10 == 0:\n                    d[prev] = x[i]\n                    count = 0\n                    prev = 0\n                    continue\n            if count > 5000:\n                break\n    count2 = 0\n    prev2 = 0\n    d2 = {}\n    d3 = {}\n    for i in range(0, len(x)):\n        if x[i] == prev2:\n            count2 += 1\n            prev2 = x[i]\n        else:\n            if prev2 > 0:\n                if count2 > 0:\n                    if x[i] % 10 == 0:\n                        d2[prev2] = x[i]\n                        count2 = 0\n                        prev2 = 0\n                        continue\n                if count2 > 5000:\n                    break\n            prev2 = x[i]\n            count2 = 1\n        if i == len(x) - 1:\n            if count2 > 0:\n                if x[i] % 10 == 0:\n                    d2[prev2] = x[i]\n                    count2 = 0\n                    prev2 = 0\n                    continue\n            if count2 > 5000:\n                break\n    count3 = 0\n    prev3 = 0\n    d3 = {}\n    d4 = {}\n    for i in range(0, len(x)):\n        if x[i] == prev3:\n            count3 += 1\n            prev3 = x[i]\n        else:\n            if prev3 > 0:\n                if count3 > 0:\n                    if x[i] % 10 == 0:\n                        d3[prev3] = x[i]\n                        count3 = 0\n                        prev3 = 0\n                        continue\n                if count3 > 5000:\n                    break\n            prev3 = x[i]\n            count3 = 1\n        if i == len(x) - 1:\n            if count3 > 0:\n                if x[i] % 10 == 0:\n                    d3[prev3] = x[i]\n                    count3 = 0\n                    prev3 = 0\n                    continue\n            if count3 > 5000:\n                break\n    print(d)\n    print(d2)\n    print(d3)\n    print(d4)\n    d5 = {}\n    for i in d:\n        for j in d2:\n            if i!= j:\n                d5[i] = d2[j]\n    for i in d3:\n        for j in d4:\n            if i!= j:\n                d5[i] = d3[j]\n    print(d5)\n    d6 = {}\n    for i in d5:\n        d6[d5[i]] = i\n    print(d6)\n    d7 = {}\n    for i in d6:\n        d7[d6[i]] = d5[i]\n    print(d7)\n    count = 0\n    s = []\n    s1 = []\n    s2 = []\n    s3 = []\n    s4 = []\n    s5 = []\n    s6 = []\n    for i in d7:\n        if d7[i] % 10 == 0:\n            s.append(d7[i])\n            if i % 100 == 0:\n                s1.append(i)\n            if i % 1000 == 0:\n                s2.append(i)\n            if i % 10000 == 0:\n                s3.append(i)\n            if i % 100000 == 0:\n                s4.append(i)\n            if i % 1000000 == 0:\n                s5.append(i)\n            if i % 10000000 == 0:\n                s6.append(i)\n    print(s)\n    print(s1)\n    print(s2)\n    print(s3)\n    print(s4)\n    print(s5)\n    print(s6)\n    return count\n"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    bill = int(stdin)\n    num_possible_bills = 0\n    possible_bills = []\n    while True:\n        num_possible_bills += 1\n        if (bill * 2) >= 100:\n            bill = (bill * 2) - 100\n            possible_bills.append(bill)\n            if bill == 1:\n                break\n        else:\n            break\n    bill = 100\n    while True:\n        if bill in possible_bills:\n            possible_bills.remove(bill)\n            if len(possible_bills) < 5000:\n                bill = bill + 100\n            else:\n                break\n        else:\n            bill = bill + 100\n            if bill >= 5000:\n                break\n    return str(num_possible_bills) + '\\n' +''.join(map(str, sorted(possible_bills)))"
    },
    {
        "number": 3282,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    res = \"\"\n    total = 0\n    for i in range(0, int(stdin)):\n        temp = str(i+1)\n        temp = temp*3\n        b = temp.count(\"1\")\n        d = temp.count(\"2\")\n        t = temp.count(\"3\")\n        if t > d and t > b:\n            res += temp\n            total += t\n        if b > d and b > t:\n            res += temp\n            total += b\n        if d > t and d > b:\n            res += temp\n            total += d\n        if total > 5000:\n            break\n    print(res)\n    return res"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    def f(k):\n        return (1+k+1)**2 - 2\n    def sumf(n, k):\n        # sum of the first k integers is (1+k+1)**2 - 2\n        return f(k) - 2\n    a = f(r) - f(r-1)\n    return str(sumf(n,r) - sumf(n,r-1))"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.strip().split())\n    return str(round(count_gems(n, d, r) / n, 6))\n"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = list(map(int, stdin.split()))\n    a = sorted(list(map(int, stdin.split())), reverse=True)\n    a = list(map(lambda x: x ** 2, a))\n    # a = sorted(a, reverse=True)\n    print(a)\n    x = (sum(a[:r]) - sum(a[r:])) / (sum(a) - sum(a[r:]))\n    return str(round(x, 6))"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    n_r = n\n    seen = {1}\n    for _ in range(d):\n        new_n = sum(i for i in range(1, n + 1) if i not in seen)\n        seen |= set(i for i in range(1, new_n + 1) if i in seen)\n        n_r = max(n_r, new_n)\n    return str(n_r / r)"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    a = sorted(list(map(int, stdin.split())), reverse=True)\n    ans = 0\n    for _ in range(d):\n        a[0] += 1\n        a = sorted(a, reverse=True)\n    ans = a[0] + sum(a[1:r])\n    return str(round(ans, 6))"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    a = 0.0\n    for _ in range(d):\n        a += 0.5\n        if (a + r - 1) % r == 0:\n            a += 1\n    return str(int(a))\n"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = stdin\n    #...\n    return...\nstdin_i = \"3 3 2\"\nprint(solution(stdin_i))\nstdin_i = \"1 1 1\"\nprint(solution(stdin_i))\nstdin_i = \"2 3 1\"\nprint(solution(stdin_i))\nstdin_i = \"3 3 2\"\nprint(solution(stdin_i))\n"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    max_n = n - 1\n    max_r = r - 1\n    s = sum(range(n + 1))\n    for _ in range(d):\n        for r in range(r, max_r, -1):\n            s -= max_n\n            s += n - r\n        max_n = max(max_n, r + 1)\n        max_r = r\n    return str(s / (n + 1))\n"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    return \"%.5f\" % (sum([n + d for _ in range(n)]) / n)\n"
    },
    {
        "number": 3283,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()))\n    numbers.sort()\n    n_largest = numbers[-r]\n    n_smallest = numbers[0]\n    counts = list(map(lambda x: numbers.count(x), list(set(numbers))))\n    print((n_largest+n_smallest)*(counts[0]-counts[1]))\n    return"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 1 5 1 5\n   ... ''')\n    '19'\n    >>> solution('''\n   ... 12 12 1 12\n   ... ''')\n    '4'\n    >>> solution('''\n   ... 5 5 3 5\n   ... ''')\n    '10'\n    >>> solution('''\n   ... 5 5 3 5\n   ... ''')\n    '10'\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 3:\n            return n > 1\n        for i in range(2, int(math.sqrt(n) + 1)):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_coprime(n1: int, n2: int) -> bool:\n        return is_prime(n1) and is_prime(n2) and n1!= n2 and gcd(n1, n2) == 1\n\n    def count_coprime_pairs(lower: int, upper: int) -> int:\n        count = 0\n        for x in range(lower, upper + 1):\n            for y in range(x, upper + 1):\n                if is_coprime(x, y):\n                    count += 1\n        return count\n\n    lower, upper = map(int, stdin.split())\n    return str(count_coprime_pairs(lower, upper))\n"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, a, b, c, d = stdin.split()\n    a = int(a)\n    b = int(b)\n    c = int(c)\n    d = int(d)\n    count = 0\n    for x in range(a, b+1):\n        for y in range(c, d+1):\n            if x == y:\n                continue\n            if gcd(x, y) == 1:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.strip().split())\n    return str(count_coprime_pairs(a, b, c, d))\n"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1 5 1 5''')\n    '19'\n    >>> solution('''12 12 1 12''')\n    '4'\n    \"\"\"\n    a, b, c, d = list(map(int, stdin.split()))\n    # check for coprimes in range of 1 to max of a, b\n    coprimes = []\n    for i in range(min(a, b), max(a, b) + 1):\n        for j in range(min(c, d), max(c, d) + 1):\n            if gcd(i, j) == 1 and coprime(i, j):\n                coprimes.append(i)\n                coprimes.append(j)\n    return str(len(coprimes))\n\n\ndef"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    A = inputs[0]\n    B = inputs[1]\n    C = inputs[2]\n    D = inputs[3]\n    \n    total = 0\n    for x in range(int(A), int(B)+1):\n        for y in range(int(C), int(D)+1):\n            if x!= y and not isPrime(x) and not isPrime(y) and x % math.gcd(x, y) == 1:\n                total += 1\n    return str(total)\n\ndef"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = (int(x) for x in stdin.split())\n    x, y = 1, 1\n    count = 0\n    while y < b:\n        x, y = y, x\n        while x < b:\n            if gcd(x,y) == 1 and is_coprime(x, y):\n                count += 1\n            x += 1\n    return str(count)\ndef"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    return str(len([x for x in range(a, b) if x not in range(c, d)]))"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a, b+1):\n        for y in range(c, d+1):\n            if x!= y:\n                count += 1 if gcd(x, y) == 1 else 0\n    return str(count)\n"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    return str(count_pairs(a, b, c, d))\ndef"
    },
    {
        "number": 3284,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a+1, b):\n        for y in range(c+1, d):\n            if gcd(x, y) > 1:\n                count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin)\n    sds = set([])\n    curr = 1\n    i = 1\n    while i <= r:\n        curr += 1\n        if curr not in sds:\n            sds.add(curr)\n            i += 1\n        else:\n            return i - 1\n    return i - 1\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    curr_n = 0\n    while curr_n!= n:\n        curr_n = curr_n + 1\n        if curr_n in [1, 2, 3, 5, 7, 11, 20, 30, 44, 59, 75, 96, 110, 121, 131, 141, 152, 153, 155, 157, 159, 165, 166, 167, 170, 171, 173, 175, 177, 179, 181, 182, 183, 185, 187, 188, 189, 191, 193, 194, 195, 197, 199]:\n            print(curr_n)\n        else:\n            print(curr_n + 1)\n\nsolution(input())\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A_1, A_n = map(int, stdin.split())\n    diff_nums = [i for i in range(2, A_n + 1) if i not in range(A_1, A_n + 1)]\n    return str(min(diff_nums))\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin\n    for i in range(1,int(A[0]) + 1):\n        for j in range(1,int(A[1]) + 1):\n            if i == j:\n                continue\n            if i + j == int(A[0]) + int(A[1]):\n                return str(i)\n            else:\n                return str(j)\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A1, A2 = stdin.split('\\n')\n    a = list(map(int, A1.split(' ')))\n    b = list(map(int, A2.split(' ')))\n    n = int(A1)\n    m = int(A2)\n    return str(min(a.index(n) + b.index(n), a.index(b[n - 1]) + b.index(n) + 1))\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A1, A2 = (int(i) for i in stdin.split())\n    c = 0\n    for i in range(1, A2):\n        if A1 + i == A2 or A1 - i == A2:\n            c += 1\n    return str(c) if c >= 1 else \"Impossible\"\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the smallest value of n such that the sequence A_1, \\ldots, A_n\n    either contains m as a value in the sequence or as a difference between\n    two values in the sequence.\n    \"\"\"\n    a1, a2 = map(int, stdin.split())\n    m = 1\n    while (m + 1) < a2:\n        m += 1\n    if m == a2:\n        return a2 - a1 + 1\n    elif m < a2:\n        return a2 - m - 1\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    r, m = map(int, stdin.split())\n    seq = {i for i in range(r)}\n    min_diff = float('inf')\n    for i in range(1, r):\n        seq.discard(i)\n        diff = (min(seq) - i) if i in seq else i\n        if diff < min_diff:\n            min_diff = diff\n    return str(min_diff)"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n,m = map(int, stdin.split())\n    for i in range(1, n+1):\n        if (i in range(1, n+1) and m in range(1, n+1)):\n            return i\n        elif (i in range(1, n+1) and m not in range(1, n+1)):\n            return i+1\n        elif (i not in range(1, n+1) and m in range(1, n+1)):\n            return m\n        else:\n            return \"-\"\n    else:\n        return -1\n"
    },
    {
        "number": 3285,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, m = stdin.split()\n    a = int(a)\n    m = int(m)\n    l = []\n    c = 0\n    for i in range(1,a+1):\n        l.append(i)\n    print(l)\n    for i in l:\n        if i%2!= 0:\n            c +=1\n            if c == m:\n                print(i)\n                return i\n        elif i%2 == 0:\n            c -=1\n            if c == m:\n                print(i)\n                return i\nsolution(\"1 5\")\nsolution(\"1 12\")"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cipher = stdin\n    n = 0\n    vowel = \"aeiou\"\n    for i in range(len(cipher)):\n        if cipher[i] in vowel:\n            cipher = cipher[:i]+cipher[i].upper()+cipher[i+1:]\n            n += 1\n    return str(n % 1000009)\n"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    passwords = stdin.splitlines()\n    return str(sum([x.count(\"c\") + x.count(\"o\") + x.count(\"a\") + x.count(\"e\") + x.count(\"i\") + x.count(\"u\") for x in passwords]))"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    uniques = set(stdin)\n    print(len(uniques))\n    return str(math.factorial(len(uniques)))"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    cnt = 1\n    for i in range(1, 100000):\n        for j in range(1, 100000):\n            if (i + j)%10000 == 0:\n                print(i, j)\n            for k in stdin:\n                if k == 'a':\n                    cnt += 1\n                    cnt %= 100000\n                if k == 'e':\n                    cnt += 1\n                    cnt %= 100000\n                if k == 'i':\n                    cnt += 1\n                    cnt %= 100000\n                if k == 'o':\n                    cnt += 1\n                    cnt %= 100000\n                if k == 'u':\n                    cnt += 1\n                    cnt %= 100000\n    return cnt\n\"\"\""
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''car''')\n    '1'\n    >>> solution('''cocar''')\n    '2'\n    \"\"\"\n    chars = list(stdin)\n    n = len(chars)\n    count = 0\n    for i in range(n):\n        if chars[i] == 'o':\n            chars[i] = 'ou'\n            count += 1\n        if chars[i] == 'u':\n            chars[i] = 'o'\n            count += 1\n        if chars[i] == 'a':\n            chars[i] = 'ae'\n            count += 1\n        if chars[i] == 'e':\n            chars[i] = 'ea'\n            count += 1\n        if chars[i] == 'i':\n            chars[i] = 'ee'\n            count += 1\n        if chars[i] == 'o':\n            chars[i] = 'ou'\n            count += 1\n        if chars[i] == 'u':\n            chars[i] = 'ou'\n            count += 1\n    count += n - 1\n    print(count % 10000009)\n"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    count = 0\n    for i in range(len(stdin)):\n        if stdin[i] == 'o':\n            count += stdin[i+1:i+3].count('o')*2\n        elif stdin[i] == 'a':\n            count += stdin[i+1:i+2].count('a')*2\n        elif stdin[i] == 'e':\n            count += stdin[i+1:i+2].count('e')*2\n        elif stdin[i] == 'i':\n            count += stdin[i+1:i+2].count('i')*2\n        elif stdin[i] == 'u':\n            count += stdin[i+1:i+2].count('u')*2\n        else:\n            count += stdin[i+1:].count(stdin[i])\n    return count % 1000009"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #pass\n    d = {}\n    vowels = 'aeiou'\n    for i in range(26):\n        d[vowels[i]] = chr(ord('a') + i)\n    #print(d)\n    for i in range(len(stdin)):\n        if stdin[i] not in vowels:\n            for j in range(len(stdin)):\n                if stdin[i] == d[stdin[j]]:\n                    stdin = stdin[:j] + d[stdin[i]] + stdin[j + 1:]\n                    break\n    #print(stdin)\n    return len(stdin) % 1000009\n\ndef"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    answer = 0\n    \n    def gen(a: str, s: str) -> str:\n        if s == len(a):\n            if re.match(r'^.*(?=(?:eo)|(?:ai)(?:u|o)(?:u|o)|(?:u|o)(?=i)|(?:u|o)(?=e)|(?:u|o)(?=o)|(?:eo)|(?=au)|(?=au)(?:u|o)|(?=au)(?=au))$', a):\n                answer += 1\n        else:\n            gen(a + s[s], s)\n            gen(a + s[s], s + 'e')\n            gen(a + s[s], s + 'o')\n            gen(a + s[s], s + 'au')\n            gen(a + s[s], s + 'i')\n            gen(a + s[s], s + 'u')\n\n    gen(stdin, '')\n    print(answer % 1000009)"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return stdin[2]"
    },
    {
        "number": 3286,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    vowel = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    global vowels_count\n    vowels_count = 0\n    \n    def is_valid(word):\n        if word == word[::-1]:\n            return False\n        for i in range(len(word)//2):\n            if word[i]!= word[-(i+1)]:\n                return False\n        return True\n    \n    def check_password(word):\n        nonlocal vowels_count\n        \n        if len(word) == 1:\n            return 0\n        \n        if is_valid(word) == True:\n            return 1\n        \n        total = 0\n        \n        for i in range(len(word)-1):\n            first = word[:i+1]\n            second = word[i+1:]\n            \n            total += check_password(first)\n            total += check_password(second)\n        \n        total += check_password(first+second)\n        vowels_count += total\n        return total\n    \n    check_password(stdin)\n    return vowels_count%1000009\n\nsolution('car')\nsolution('cocar')\n"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(min(int(stdin.split(' ')[1]) * 2 ** int(stdin.split(' ')[0]) + int(stdin.split(' ')[1]) + 1, int(stdin.split(' ')[2]) * 2 + int(stdin.split(' ')[2]) + 1, int(stdin.split(' ')[3]) * 2 + int(stdin.split(' ')[3]) + 1, int(stdin.split(' ')[4]) * 2 + int(stdin.split(' ')[4]) + 1))) % (10 ** 9 + 7)"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the minimum number of coins to split an amount from the thieves.\n    \"\"\"\n    n, *coins = map(int, stdin.split())\n    d = {}\n    for c in coins:\n        d[c] = d.get(c, 0) + 1\n    k = max(d.values())\n    return sum(d[i] * k ** i for i in range(k, 0, -1)) % 10**9"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    values = map(int, stdin.split(\"\\n\"))\n    k = values[0]\n    values = values[1:]\n\n    def count_choices(k, n):\n        return (2 ** k - 1) // n\n    choices = [count_choices(k, i) for i in values]\n    total = sum(choices)\n    return total\n"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    coins = list(map(int, stdin.split()[1:]))\n    s = 0\n    for i in range(k):\n        if coins[i] > 0:\n            s += 1\n            coins[i] -= 1\n    for i in range(k - 1, -1, -1):\n        if coins[i] == 0:\n            if s % 2 == 1:\n                coins[i] += 1\n            else:\n                coins[i] -= 1\n                s -= 1\n            s += 1\n    return s\n"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the minimum amount of money the thieves must leave behind.\n\n    >>> solution('''\n   ... 1\n   ... 0 2 0 1\n   ... ''')\n    '8'\n    >>> solution('''\n   ... 5\n   ... 1000000 1 1 1 1\n   ... ''')\n    '0'\n    >>> solution('''\n   ... 10\n   ... 1 1 1 1 1 1 1 1 1 1 1\n   ... ''')\n    '0'\n    \"\"\"\n    coin_denominations = [int(input()) for _ in range(int(input()))]\n    return '{:b}'.format(min(i * 2**(i-1) for i in coin_denominations)).rstrip('0')\n"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = list(map(int, stdin.split()))\n    ans = sum(coins)\n    for i in range(1, n):\n        ans = min(ans, (sum(coins) - ans) % (10**9 + 7))\n    return str(ans)\n"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k: int = int(stdin.split()[0])\n    coins: list[int] = list(map(int, stdin.split()[1:]))\n    return f(k, coins)\n\n\ndef"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    coins = list(map(int, stdin.split()))\n    n = len(coins)\n    if k == 1:\n        return sum(coins)\n    dp = [[-1]*(k + 1) for _ in range(n)]\n    dp[0][0] = 0\n    for i in range(n):\n        dp[i][1] = coins[i]\n    for i in range(2, k + 1):\n        for j in range(1, k + 1):\n            dp[i-1][j] = -1\n            for k in range(i, j, -1):\n                if dp[i-1][k-1]!= -1:\n                    dp[i-1][j] = min(dp[i-1][j], dp[i-1][k] + dp[k][j])\n    return dp[-1][-1] % (10**9 + 7)"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cnt,*_ = stdin.split()\n    return str(min([len(divmod(int(cnt),i)) for i in range(2,int(math.log2(2*int(cnt)))+1)]))"
    },
    {
        "number": 3287,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    max_n = 10**9 + 7\n    x = list(map(int, stdin.split()))\n    return sum(x) % max_n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k,n = map(int,stdin.split())\n    st_lst = sorted(list(set([''.join(sorted(x)) for x in permutations(string.ascii_lowercase, k) if x[0]==x[-1]==x[-2]])))\n    n -= 1\n    while n >= 0 and st_lst:\n        st = st_lst.pop()\n        if n == 0:\n            return st\n        n -= len(st)-1\n    return -1\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    sorted_strings = sorted(stdin)\n    i = 1\n    while i < len(sorted_strings):\n        if len(sorted_strings[i - 1]) < len(sorted_strings[i]):\n            return sorted_strings[i - 1]\n        i += 1\n    return -1\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    k, n = map(int, stdin.split())\n    counter = {}\n    for i in range(k + 1):\n        counter[i] = 0\n    for i in range(n + 1):\n        if i < k:\n            for j in range(i):\n                if j in counter:\n                    counter[j] += 1\n                else:\n                    counter[j] = 1\n        if i in counter and counter[i] >= 2:\n            return chr(i)\n    return '-1'\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    return ''.join(sorted(set(stdin[i:i + k] for i in range(len(stdin) - k + 1)), key=lambda x: (stdin.count(x), x))[n - 1])\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, n = (int(x) for x in stdin.split())\n    s = \"\".join(sorted(x for x in range(1, k+1) if str(x) not in (\"\".join(sorted(str(x) for x in range(1, k+1)))+str(x))))\n    if s:\n        return s[n-1]\n    else:\n        return -1\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    res = []\n    for num in range(1, 1+n):\n        for i in range(1, 1+k):\n            if num == 1+k-i:\n                res.append(str(num))\n                break\n            for j in range(2, 1+k):\n                if num == i+j:\n                    res.append(str(num))\n                    break\n    res = sorted(res)\n    return ''.join(res[n-1])\n\ndef"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, n = (int(x) for x in stdin.split())\n    s = sorted([''.join(sorted(x)) for x in range(1,k+1)])\n    for i, x in enumerate(s):\n        if len(x) >= n and len(x) == n + (n-1) * (k-1):\n            return x\n    return -1"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, n = list(map(int, stdin.split()))\n    alphabet = sorted(list(set(string.ascii_lowercase)))\n    for _ in range(n):\n        alphabet = sorted(sorted(alphabet) + sorted(sorted(alphabet)))\n    alphabet = sorted(alphabet, key=lambda x: string.ascii_lowercase.index(x))\n    alphabet.sort()\n    alphabet = ''.join(alphabet)\n    alphabet = alphabet[n::k]\n    alphabet = ''.join(sorted(alphabet))\n    if alphabet == '':\n        return -1\n    else:\n        return alphabet\n    return alphabet\n    \nprint(solution(input()))\n\n\"\"\"\n\nimport math\nimport os\nimport random\nimport re\nimport sys\n\n\ndef"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.strip().split()))\n    if n > 30:\n        return -1\n    s = \"\"\n    for i in range(1, n + 1):\n        s += chr(ord('a') + i)\n    l = list(s)\n    l.sort()\n    ss = ''.join(l)\n    for i in range(n):\n        if ss.find(l[i], i + 1, n) < 0:\n            return -1\n    return ss[k - 1]\n"
    },
    {
        "number": 3288,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    arr = []\n    count = 0\n    for i in range(1, k+1):\n        for j in range(1, k+1):\n            for x in range(1, k+1):\n                s = str(i)+str(j)+str(x)\n                if s == s[::-1]:\n                    count += 1\n                else:\n                    continue\n            if count == k-1:\n                arr.append(s)\n            count = 0\n    if len(arr) == 0:\n        return -1\n    else:\n        return sorted(arr)[-1]\n"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    c = collections.Counter(map(int, stdin.split()))\n    max_s = max(c.keys())\n    s, t = (max_s - c[max_s] + 1, max_s - c[max_s])\n    c = sorted(c.items(), key=lambda x: x[0] * s + x[1] * t)\n    return str(len(c) - 1)\n"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    in_file = stdin\n    n = int(in_file.readline())\n    persons = []\n    for i in range(n):\n        persons.append([int(i) for i in in_file.readline().split()])\n\n    # write your code here\n    persons.sort(key=lambda x: (x[0], x[1], x[2]), reverse=True)\n    ans = 0\n    for i in range(n - 1):\n        if persons[i][2] == 1:\n            if persons[i + 1][2] == 1:\n                ans = max(ans, i + 1)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    n = int(s[0])\n    res = 0\n    data = []\n    for i in range(n):\n        p = list(map(int, s[i+1].split()))\n        data.append([p[0], p[1], p[2]])\n    for k in range(n):\n        t = 0\n        for j in range(k, n):\n            data[k][2] = 0 if data[k][2] == 1 else 1\n            if k == j:\n                data[k][1] = 0 if data[k][1] == 1 else 1\n            t += max(data[k][0], data[k][1]) * data[j][0]\n            t += max(data[k][0], data[k][1]) * data[j][1]\n            data[k][2] = 0 if data[k][2] == 1 else 1\n        t -= max(data[k][0], data[k][1]) * data[k][0]\n        t -= max(data[k][0], data[k][1]) * data[k][1]\n        if t > res:\n            res = t\n    return str(res)"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = []\n    b = []\n    c = []\n    for _ in range(n):\n        num, maxh, vote = map(int, input().split())\n        a.append(num)\n        b.append(maxh)\n        c.append(vote)\n    ans = float('inf')\n    for i in range(n):\n        for j in range(i):\n            for k in range(j):\n                ans = min(ans, (a[i] * a[j] + b[i] * b[j]) * (c[i] == 1) + (a[i] * a[k] + b[i] * b[k]) * (c[i] == 1))\n    return str(ans)"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    a = sorted(map(int, stdin.split(\"\\n\")[:n]), key=lambda x: x * -1)\n    b = sorted(map(int, stdin.split(\"\\n\")[n:]), key=lambda x: x * -1)\n    c = sorted(map(int, stdin.split(\"\\n\")[2 * n:]), key=lambda x: x * -1)\n    return str(min(len(a) - len(set(a)), len(b) - len(set(b)), len(c) - len(set(c))))\n"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    # a_i = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split('\\n')\n    for i in range(1, len(stdin)):\n        stdin[i] = list(map(int, stdin[i].split()))\n    stdin.sort(key=lambda x: (x[0] * 10000 + x[1] * 100 + x[2], -x[0], -x[1]))\n    return''.join(map(str, stdin[0][-1]))\n"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    For Coderbyte Problem ID 1436:\n    Students' Polling\n    https://coderbyte.com/problems/students-polling\n    \"\"\"\n    # parse input and sort it using standard dict sorting algo\n    in_list = stdin.split()\n    sorted_in_list = sorted(in_list)\n\n    # initialize variables\n    res_sum = 0\n    res_min = 1e100\n    for item in sorted_in_list:\n        # find the sum of the first 3 digits\n        res_sum += (int(item[0]) * 100000 + int(item[1]) * 10000 + int(item[2]))\n\n        # find the minium cluster size\n        if res_min > int(item[3]):\n            res_min = int(item[3])\n\n    return str(res_min)\n"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    a = list(map(int, stdin.strip().split()))\n    #a = a[:250000]\n    print(a)\n    stdin = sorted(a, key=lambda x: (x[0] * 10000 + x[1] * 1000 + x[2], x[2]))\n    #stdin = sorted(a, key=lambda x: x[0])\n    print(stdin)\n    '''\n    return(0)"
    },
    {
        "number": 3289,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    N = int(stdin[0])\n    ans = 0\n    for i in range(N):\n        if int(stdin[i + 1][0]) < int(stdin[i + 1][1]):\n            ans += int(stdin[i + 1][2])\n        else:\n            ans -= int(stdin[i + 1][2])\n    return str(ans)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = [int(i) for i in stdin.split(\" \")]\n    explode = [int(i) for i in stdin.split(\" \")[1:]]\n    defuses = [int(i) for i in stdin.split(\" \")[2:]]\n\n    # calculate exhaust time\n    #print(\"explode:\", explode)\n    #print(\"defuses:\", defuses)\n\n    # determine exhaust time\n    exhaust_time = 0\n    for i in range(len(explode)):\n        explode[i] -= 1\n        exhaust_time += 1\n\n        if exhaust_time >= D:\n            break\n\n    #print(\"explode:\", exhaust_time)\n\n    for i in range(len(defuses)):\n        defuses[i] -= 1\n\n        if exhaust_time >= D:\n            break\n\n    #print(\"defuses:\", exhaust_time)\n\n    if exhaust_time > E:\n        return \"0\"\n    else:\n        if exhaust_time % 2 == 0:\n            if exhaust_time == 0:\n                return str(0)\n            else:\n                return str(int((exhaust_time-1)/2))\n        else:\n            if exhaust_time == 0:\n                return str(0)\n            else:\n                return str(int((exhaust_time-1)/2 + 1))"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e, d = map(int, stdin.split())\n    e_c, d_c = map(int, input().split())\n    e_lst = []\n    d_lst = []\n    for _ in range(e):\n        e_lst.append(int(input()))\n    for _ in range(d):\n        d_lst.append(int(input()))\n    if n % 2:\n        result = -1\n    else:\n        result = 0\n    print(result)"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = map(int, stdin.split())\n    exploding = list(map(int, stdin.split()))\n    defuse = list(map(int, stdin.split()))\n\n    result = []\n    while len(exploding) > 0 and len(defuse) > 0:\n        if defuse[0] > defuse[1]:\n            result.append(exploding.pop())\n            defuse.pop(0)\n        else:\n            result.append(defuse.pop())\n            exploding.pop(0)\n    if len(defuse) == 0:\n        while len(exploding) > 0:\n            result.append(exploding.pop())\n    else:\n        while len(defuse) > 0:\n            result.append(defuse.pop())\n    return''.join(map(str, result))"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e, d = map(int, stdin.split())\n    result = -1\n    exp_loc, def_loc = [-1] * n, [-1] * n\n    if e <= 3:\n        return result\n    elif e > 3:\n        exp_loc[0] = 1\n        def_loc[0] = 1\n        for i in range(1, e):\n            exp_loc[i] = exp_loc[i - 1] + exp_loc[i - 2]\n            def_loc[i] = def_loc[i - 1] + def_loc[i - 2]\n    for i in range(d):\n        if exp_loc[i] >= e:\n            result = 0\n            break\n        else:\n            result = exp_loc[i]\n    if result == 0:\n        return result\n    else:\n        result = def_loc[d - 1]\n    return result\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = map(int, stdin.split())\n    exploding, defuse = [], []\n    for i in range(E):\n        exploding.append(int(stdin.split()[2 * i]))\n        defuse.append(int(stdin.split()[2 * i + 1]))\n\n    def can_explode_defuse(deck, exploding, defuse):\n        # getting cards from the top of the deck\n        discard = deck.pop(0)\n\n        # discarding the cards and checking\n        if exploding and (discard == exploding[0] or discard == exploding[1]):\n            deck.append(discard)\n            exploding.pop(0)\n            exploding.pop(0)\n            can_explode_defuse(deck, exploding, defuse)\n        elif not exploding and defuse and (discard == defuse[0] or discard == defuse[1]):\n            deck.append(discard)\n            defuse.pop(0)\n            defuse.pop(0)\n            can_explode_defuse(deck, exploding, defuse)\n        else:\n            return False\n        return True\n\n    winner = 0\n    # check if any player could win the game\n    while True:\n        if not can_explode_defuse(exploding, exploding, defuse):\n            return str(winner)\n        winner += 1\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 4 3\n   ... 3 4 5 7\n   ... 1 2 10\n   ... ''')\n    '0'\n    >>> solution('''\n   ... 3 5 2\n   ... 1 4 7 9 11\n   ... 2 3\n   ... ''')\n    '1'\n    >>> solution('''\n   ... 6 7 9\n   ... 2 5 4 10\n   ... 1 3 11\n   ... 8 1\n   ... 4 5 2\n   ... ''')\n    '2'\n    \"\"\"\n    cards = [int(x) for x in stdin.split()]\n    N = cards[0]\n    E, D = cards[1:]\n    deck = Deck(E, D)\n    winner = -1\n    for i in range(N):\n        if i == 0:\n            player = Player()\n            player.add_cards(deck.draw())\n            player.add_cards(deck.draw())\n            player.add_cards(deck.draw())\n            player.add_cards(deck.draw())\n        else:\n            p = Player()\n            p.add_cards(deck.draw())\n            p.add_cards(deck.draw())\n            p.add_cards(deck.draw())\n            p.add_cards(deck.draw())\n            player_id = p.get_id()\n            for _ in range(i):\n                winner = player_id if winner < 0 else winner\n            if winner < 0:\n                player_id = p.get_id()\n                for _ in range(i):\n                    winner = player_id if winner < 0 else winner\n        p.print_deck()\n    return str(winner)\n\nimport doctest\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = list(map(int, stdin.split()))\n    p = 0\n    win = None\n    while p < N:\n        card = deck[-1]\n        if card == 'E':\n            if deck[-2] == 'E':\n                deck = deck[:-2]\n            else:\n                deck = deck[:-1]\n        elif card == 'D':\n            if deck[-2] == 'D':\n                deck = deck[:-2]\n            else:\n                deck = deck[:-1]\n        else:\n            deck.pop()\n        p += 1\n        if p == N:\n            win = p\n    return '{}\\n{}'.format(win, p)\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e, d = map(int, stdin.split())\n    e = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n    for i in range(0, len(e)):\n        if e[i] > d[i]:\n            return \"0\"\n    for i in range(0, len(d)):\n        if d[i] > e[i]:\n            return \"0\"\n    return \"1\"\n"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('2 4 3\\n3 4 5 7\\n1 2 10\\n')\n    '0'\n    >>> solution('3 5 2\\n1 4 7 9 11\\n2 3\\n')\n    '2'\n    '''\n    N, E, D = list(map(int, stdin.strip().split()))\n    exploding_kittens = [int(i) for i in stdin.strip().split()]\n    defuse_cards = []\n    exploding_kitten = 0\n    defuse_card = 0\n    for i in range(E):\n        if exploding_kittens[i] == 2:\n            exploding_kitten = exploding_kittens[i + 1]\n        elif exploding_kittens[i] == 3:\n            defuse_cards.append(exploding_kittens[i + 1])\n            defuse_card = exploding_kittens[i + 1]\n        else:\n            pass\n    #print(exploding_kitten)\n    #print(defuse_cards)\n    #print(defuse_card)\n    if len(exploding_kittens) <= D:\n        return '-1'\n    else:\n        for i in range(N):\n            if i % 2 == 0:\n                if exploding_kitten == 0:\n                    exploding_kitten = exploding_kittens[(i+1) % N]\n                else:\n                    if exploding_kitten == 1:\n                        exploding_kitten = exploding_kittens[(i+1) % N]\n                    elif exploding_kitten == 2:\n                        if defuse_card == 2:\n                            return str(2*i + 1)\n                        else:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n                    else:\n                        if defuse_card == 3:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n                        else:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n            else:\n                if exploding_kitten == 0:\n                    exploding_kitten = exploding_kittens[(i+1) % N]\n                else:\n                    if exploding_kitten == 1:\n                        exploding_kitten = exploding_kittens[(i+1) % N]\n                    elif exploding_kitten == 2:\n                        if defuse_card == 2:\n                            return str(2*i + 1)\n                        else:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n                    else:\n                        if defuse_card == 3:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n                        else:\n                            exploding_kitten = exploding_kittens[(i+1) % N]\n    return '-1'"
    },
    {
        "number": 3290,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = stdin.split()\n    N = int(N)\n    E = int(E)\n    D = int(D)\n    cards = []\n    for i in range(E):\n        cards.append(int(stdin.split()[2*i]))\n    cards.sort()\n    defuse = []\n    expl = []\n    for i in range(D):\n        if cards[i] == 10:\n            defuse.append(i)\n        else:\n            expl.append(i)\n    if len(expl) <= 5:\n        for i in range(len(expl)):\n            expl.append(0)\n    if len(defuse) <= 5:\n        for i in range(len(defuse)):\n            defuse.append(0)\n    for i in range(len(defuse)):\n        if defuse[i] == 0:\n            defuse[i] = 1\n    if len(expl) >= 2:\n        for i in range(1, len(expl)):\n            expl[i] = expl[i-1] + expl[i]\n    if len(defuse) >= 2:\n        for i in range(1, len(defuse)):\n            defuse[i] = defuse[i-1] + defuse[i]\n    first_round = []\n    first_round.append(cards[0])\n    for i in range(len(expl)):\n        if expl[i] == cards[i+1] - 1:\n            expl[i] = 0\n        else:\n            expl[i] = 1\n    for i in range(len(defuse)):\n        if defuse[i] == cards[i+1] - 1:\n            defuse[i] = 0\n        else:\n            defuse[i] = 1\n    if len(expl) >= 2:\n        for i in range(len(expl)):\n            first_round.append(expl[i] + expl[i+1])\n    if len(defuse) >= 2:\n        for i in range(len(defuse)):\n            first_round.append(defuse[i] + defuse[i+1])\n    for i in range(len(first_round)):\n        if first_round[i] == 0:\n            first_round[i] = 1\n        else:\n            first_round[i] = 0\n    if len(first_round) >= 5:\n        for i in range(5, len(first_round)):\n            first_round[i] = 0\n    index = 1\n    winner = -1\n    while winner == -1:\n        if first_round[index] == 0:\n            winner = index + 1\n        index += 2\n    return str(winner)\n"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a,b = list(map(int,stdin.split()))\n    c,d = list(map(int,stdin.split()))\n    return str(min(2,int(c*b/a+d*b/a),int(c*a+d*a/b)))"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n    return str(solve(a, b, c, d))\n\n\ndef"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a,b = map(int,stdin.split())\n    c,d = map(int,stdin.split())\n    print(math.ceil(a/b))\n    for i in range(int(math.ceil(a/b))):\n        print(-2*i-1,-2*i)\n    return"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    a,b = map(int,stdin[0].split())\n    c,d = map(int,stdin[1].split())\n    possible_splitter_outputs = []\n    for i in range(1,200):\n        l_1 = (a*i)/(a+b)\n        r_1 = (b*i)/(a+b)\n        l_2 = (c*i)/(c+d)\n        r_2 = (d*i)/(c+d)\n        if l_1!= l_2 or r_1!= r_2:\n            possible_splitter_outputs.append(i)\n    splitter_output_concat = []\n    for i in range(len(possible_splitter_outputs)):\n        if i == len(possible_splitter_outputs)-1:\n            splitter_output_concat.append(possible_splitter_outputs[i])\n        else:\n            splitter_output_concat.append(possible_splitter_outputs[i])\n            splitter_output_concat.append(possible_splitter_outputs[i])\n    splitter_output_concat.sort()\n    splitter_output_concat =''.join(str(elem) for elem in splitter_output_concat)\n    return splitter_output_concat\n"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    ratio = [int(i) for i in stdin.split()]\n    splitter = [0, 0]\n    bags_to_distribute = ratio[0] * ratio[1]\n    while bags_to_distribute > 0:\n        splitter = [splitter[i] + ratio[i] for i in range(2)]\n        bags_to_distribute -= ratio[0]\n    return str(splitter[0] + 1) + \"\\n\" + str([i + 1 for i in splitter[1:]])\n\nsolution(\"2 3\")\nsolution(\"1 2\")\n\n\"\"\"\n\n\nfrom itertools import product\n\n\ndef"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    splitters = stdin.split()\n    ratio = int(splitters[0]), int(splitters[1])\n    splitter_1 = splitter_2 = None\n    s1 = s2 = 0\n    for i in range(len(ratio)):\n        if ratio[i] == 1:\n            s1 += 1\n            s2 += ratio[i]\n        if ratio[i] == 2:\n            s2 += ratio[i]\n            s1 += ratio[i]\n        if ratio[i] == 3:\n            s1 += ratio[i]\n            s2 += ratio[i]\n        if ratio[i] == 4:\n            s2 += ratio[i]\n            s1 += ratio[i]\n        if ratio[i] == 5:\n            s1 += ratio[i]\n            s2 += ratio[i]\n        if ratio[i] == 6:\n            s2 += ratio[i]\n            s1 += ratio[i]\n        if ratio[i] == 7:\n            s1 += ratio[i]\n            s2 += ratio[i]\n        if ratio[i] == 8:\n            s1 += ratio[i]\n            s2 += ratio[i]\n        if ratio[i] == 9:\n            s1 += ratio[i]\n            s2 += ratio[i]\n        if ratio[i] == 10:\n            s1 += ratio[i]\n            s2 += ratio[i]\n    if s1 % 2!= 0 or s2 % 2!= 0:\n        return '0'\n    if s1 == 0:\n        return str(s2 // 2)\n    if s2 == 0:\n        return str(s1 // 2)\n    if s1 == 1:\n        return str(-1 * s2 // 2)\n    if s2 == 1:\n        return str(-1 * s1 // 2)\n    splitter_1 = 0\n    splitter_2 = 0\n    while s1 > 0 or s2 > 0:\n        if s1 > 0 and ratio[splitter_1] == 1:\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 2:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 3:\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 4:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 5:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 6:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 7:\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 8:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 9:\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n        elif s1 > 0 and ratio[splitter_1] == 10:\n            splitter_1 = splitter_1 - 1\n            splitter_2 = splitter_1 + 1\n            s1 -= ratio[splitter_1]\n\n        if s2 > 0 and ratio[splitter_2] == 1:\n            splitter_1 = splitter_2 - 1\n            s2 -= ratio[splitter_2]\n        elif s2 > 0 and ratio[splitter_2] == 2:\n            splitter_2 = splitter_2 - 1\n            splitter_1 = splitter_2 + 1\n            s2 -= ratio[splitter_2]\n        elif s2 > 0 and ratio[splitter_2] == 3:\n            splitter_1 = splitter_2 - 1\n            s2 -= ratio[splitter_2]\n        elif s2 > 0 and ratio[splitter_2] == 4:\n            splitter_2 = splitter_2 - 1\n            splitter_1 = splitter_2 + 1\n            s2 -= ratio[splitter_2]\n        elif s2 > 0 and ratio[splitter_2] == 5:\n            splitter_2 = splitter_2 - 1"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def split(splitter: int, ratios: list) -> list:\n        if splitter == len(ratios):\n            return ratios\n        return ratios[splitter]\n    splitter_ratios, *other_splitter_ratios = map(int, stdin.split())\n    splitters = list(enumerate(split(i, ratios) for i, ratios in enumerate(other_splitter_ratios)))\n    output = []\n    splitter = 0\n    for _ in range(splitter_ratios):\n        if len(output) == 1:\n            break\n        if splitter == len(splitters):\n            output.append(-1)\n            break\n        output.append(splitters[splitter][1])\n        splitter = splitters[splitter][0]\n    splitter = 0\n    for _ in range(splitter_ratios):\n        if splitter == len(splitters):\n            output.append(-2)\n            break\n        output.append(splitters[splitter][1])\n        splitter = splitters[splitter][0]\n    return '\\n'.join(map(str, output))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.strip().split())\n    a, b = x, y\n    while a!= 0 or b!= 0:\n        if a == 0:\n            a = b\n        elif b == 0:\n            b = a\n        else:\n            a = a // (a + b)\n            b = b // (a + b)\n    return str(x + y)"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n    output = 0\n    for i in range(200):\n        l_output = (-2 if i == 0 else 0)\n        r_output = (-2 if i == 0 else 0)\n        if (i + 1) * b <= a:\n            l_output = c\n        if (i + 1) * a <= d:\n            r_output = d\n        output += l_output + r_output\n    return str(output)"
    },
    {
        "number": 3291,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = list(map(int, stdin.split()))\n    c, d = list(map(int, stdin.split()))\n\n    ratios = {\n        1: 3,\n        2: 3,\n        3: 2,\n        4: 2,\n        5: 3,\n        6: 3,\n        7: 2,\n        8: 2,\n        9: 3,\n        10: 3\n    }\n\n    input_belt = RatiosSplitter(a, b)\n\n    belt_1 = RatiosOutputSplitter(c, d, ratios)\n    belt_2 = RatiosOutputSplitter(d, c, ratios)\n\n    output_belt = [\n        # (1, 0),\n        # (2, 1)\n    ]\n\n    splitter = RatiosSplitter(c, d)\n\n    return str(input_belt.generate_splitter()) +'' + str(belt_1.generate_splitter()) +'' + str(\n        belt_2.generate_splitter()) +'' + str(splitter.generate_splitter()) +'' + str(output_belt) + '\\n' + str(\n        input_belt.generate_splitter()) + '\\n' + str(belt_1.generate_splitter()) + '\\n' + str(\n        belt_2.generate_splitter()) + '\\n' + str(splitter.generate_splitter()) + '\\n' + str(output_belt)\n\n\nclass RatiosSplitter:\n    def __init__(self, ratio_1: int, ratio_2: int):\n        self.ratio_1 = ratio_1\n        self.ratio_2 = ratio_2\n        self.n = self.ratio_1 + self.ratio_2\n\n    def generate_splitter(self):\n        if self.n % 2 == 0:\n            return [\n                None,\n                RatiosSplitter(self.ratio_2, self.ratio_1),\n                RatiosSplitter(self.ratio_1, self.ratio_2)\n            ]\n        else:\n            return [\n                RatiosSplitter(self.ratio_1, self.ratio_2),\n                RatiosSplitter(self.ratio_2, self.ratio_1)\n            ]\n\n    def generate_splitter_minus_1(self):\n        return RatiosSplitter(self.ratio_2, self.ratio_1)\n\n    def generate_splitter_minus_2(self):\n        return RatiosSplitter(self.ratio_1, self.ratio_2)\n\n\nclass RatiosOutputSplitter:\n    def __init__(self, ratio_1: int, ratio_2: int, ratios: Dict[int, int]):\n        self.ratio_1 = ratio_1\n        self.ratio_2 = ratio_2\n        self.n = ratio_1 + ratio_2\n        self.ratios = ratios\n\n    def generate_splitter(self):\n        splitter = RatiosSplitter(self.ratio_1, self.ratio_2)\n        splitter_minus_1 = splitter.generate_splitter_minus_1()\n        splitter_minus_2 = splitter.generate_splitter_minus_2()\n\n        splitter_minus_1_1 = splitter_minus_1.generate_splitter_minus_1()\n        splitter_minus_1_2 = splitter_minus_1.generate_splitter_minus_2()\n\n        splitter_minus_2_1 = splitter_minus_2.generate_splitter_minus_1()\n        splitter_minus_2_2 = splitter_minus_2.generate_splitter_minus_2()\n\n        splitter_1 = RatiosOutputSplitter(self.ratio_1, self.ratio_2, self.ratios)\n        splitter_2 = RatiosOutputSplitter(self.ratio_2, self.ratio_1, self.ratios)\n\n        splitter_1_1 = splitter_1.generate_splitter()\n        splitter_1_2 = splitter_1.generate_splitter()\n\n        splitter_2_1 = splitter_2.generate_splitter()\n        splitter_2_2 = splitter_2.generate_splitter()\n\n        output_belt = [\n            (1, 0),\n            (2, 1)\n        ]\n        return [\n            splitter,\n            splitter_minus_1,\n            splitter_minus_2,\n            splitter_1,\n            splitter_2,\n            splitter_minus_1_1,\n            splitter_minus_1_2,\n            splitter_minus_2_1,\n            splitter_minus_2_2,\n            splitter_1_1,\n            splitter_1_2,\n            splitter_2_1,\n            splitter_2_2,\n            output_belt\n        ]\n\n    def generate_splitter_minus_1(self):\n        return RatiosOutput"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    scores = {stdin[i].lower(): i for i in range(n)}\n    for name in stdin:\n        if name in scores:\n            for k in range(n):\n                if stdin[k].lower() == name.lower():\n                    scores[name.lower()] = k\n    result = 1\n    for name in stdin:\n        if name in scores:\n            result *= (len(stdin) - scores[name]) + 1\n    return result % 1000000007\n\nprint(solution(input()))"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    nums = []\n    for i in range(1,4):\n        nums.append(list(stdin.split('\\n')[i]))\n    \n    counter = 0\n    for i in range(len(nums)):\n        for j in range(len(nums)):\n            if i!= j:\n                if nums[i] == nums[j][::-1]:\n                    counter += 1\n    return str(counter % 1000000007)"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    st_dict = {}\n    for st in stdin.splitlines():\n        st_dict[st] = st[0]\n    sort_dict = {}\n    for i in range(len(st_dict)):\n        st = st_dict[i]\n        st_list = list(st)\n        if st_list[0] in st_list[1:]:\n            st_list.pop(0)\n        st = ''.join(st_list)\n        if st in sort_dict:\n            sort_dict[st] += 1\n        else:\n            sort_dict[st] = 1\n    sort_dict = sorted(sort_dict.items(), key=lambda x: x[1], reverse=True)\n    for i in range(len(sort_dict)):\n        sort_dict[i] = sort_dict[i][0]\n    sort_dict = '\\n'.join(sort_dict)\n    return sort_dict\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    students = sorted(list(stdin.strip()))\n    res = 1\n    for i in range(1, N):\n        if students[i] == students[i - 1]:\n            res = res + 1\n    return str(res)"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join(\n        f'{i:4}' if i % 2 else f'{i:4}-{i-1:4}'\n        for i in range(1, int(stdin) + 1))\n"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return len(set(stdin)) % (1000000000)"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3')\n    '4'\n    >>> solution('5')\n    '24'\n    \"\"\"\n    return str(len(stdin.split('\\n')))"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def increasing_string(string: str) -> bool:\n        if len(string) <= 1:\n            return True\n        for i in range(1, len(string)):\n            if string[i - 1] > string[i]:\n                return False\n        return True\n    all_names = []\n    for name in stdin.split():\n        all_names.append(name)\n    for i in range(len(all_names)):\n        for j in range(i + 1, len(all_names)):\n            if increasing_string(all_names[i]) and increasing_string(all_names[j]):\n                if len(all_names[i]) < len(all_names[j]):\n                    all_names[i], all_names[j] = all_names[j], all_names[i]\n    return str(len(all_names))\n"
    },
    {
        "number": 3292,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return '0'\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    vend = []\n    sell = []\n    for _ in range(n):\n        lst = list(map(int, stdin.split()))\n        vend.append(lst[0])\n        sell.append(lst[1])\n    \n    cash_remaining = 1000000\n    max_profit = 0\n    for i in range(len(vend)):\n        cash_remaining -= vend[i]\n        if cash_remaining >= sell[i]:\n            cash_remaining += sell[i]\n            cash_remaining -= vend[i]\n            max_profit = max(max_profit, cash_remaining)\n        \n    return str(max_profit)\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    w = [None] * n\n    p = [None] * n\n    m = [None] * n\n    s = [None] * n\n    for i in range(n):\n        w[i], p[i], m[i], s[i] = map(int, stdin.split())\n    maximum_profit = 0\n    for i in range(1, n):\n        if w[i] > w[i-1]:\n            profit = p[i] - p[i-1]\n            if profit > maximum_profit:\n                maximum_profit = profit\n            if profit < 0:\n                maximum_profit = 0\n                break\n    for i in range(1, n):\n        if m[i] > m[i-1]:\n            profit = m[i] - m[i-1]\n            if profit > maximum_profit:\n                maximum_profit = profit\n            if profit < 0:\n                maximum_profit = 0\n                break\n    for i in range(1, n):\n        if s[i] > s[i-1]:\n            profit = s[i] - s[i-1]\n            if profit > maximum_profit:\n                maximum_profit = profit\n            if profit < 0:\n                maximum_profit = 0\n                break\n    return str(maximum_profit)\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    t = int(stdin)\n    res = []\n    for i in range(t):\n        [p, m, s] = list(map(int, stdin.split()))\n        res.append(f(p, m, s))\n    return str(max(res))\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split(\"\\n\")\n    n = int(data[0])\n    machine = []\n    profit = 0\n    for i in range(n):\n        f, p, m, s = map(int, data[i].split())\n        machine.append([f, p, m, s])\n    machine.sort(key=lambda x: x[0])\n    for i in range(n):\n        left = machine[i][2]\n        while left < machine[i][3]:\n            left += machine[i][1]\n            if left >= machine[i][2]:\n                profit += left - machine[i][2]\n    return profit\n\n\nprint(solution(input()))\n\"\"\"\ndef"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    ns = stdin.strip().split()\n    N = int(ns[0])\n    cs = [int(ns[i+1]) for i in range(N)]\n    cs.sort()\n    return str(cs[-1] - cs[0])\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = 0\n    s = 0\n    t = 0\n    for _ in range(n):\n        f, p, m, s = map(int, stdin.split())\n        m = m + p\n        s = s + s\n    return str(m - s)"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    n = int(stdin)\n\n    def f(i):\n        if i <= 0:\n            return 0\n        return (i - 1) * i // 2\n\n    def p(i, j):\n        return int(i * j)\n\n    def m(i, j, k):\n        return int(i * j * k)\n\n    def s(i, j):\n        return i * j\n\n    memo = {}\n\n    def dp(i, j):\n        if (i, j) in memo:\n            return memo[(i, j)]\n        if i == 0 and j == 0:\n            return 0\n        if i == 0:\n            return -1\n        if j == 0:\n            return -1\n        res = -1\n        if i >= j:\n            res = dp(i, j - 1)\n        if i > j and i > j and i >= j and j >= i:\n            res = dp(i - 1, j - 1) + m(i, j, j) - m(i, j, i) + s(i, j) - s(i, i)\n        if i < j and i > j and i < j and j >= i:\n            res = dp(i - 1, j) + m(i, j, j) - m(i, j, i) + s(i, j) - s(i, i)\n        if i > j and i > j and i < j and j < i:\n            res = dp(i - 1, j - 1) + m(i, j, j) - m(i, j, i) + s(i, j) - s(i, i)\n        if i < j and i > j and i < j and j < i:\n            res = dp(i, j - 1) + m(i, j, j) - m(i, j, i) + s(i, j) - s(i, i)\n        if i == j:\n            res = 0\n        if i > j and i < j and i >= j and j >= i:\n            res = dp(i - 1, j - 1) + m(i, j, j) - m(i, j, i) + s(i, j) - s(i, i)\n        memo[(i, j)] = res\n        return res\n\n    result = dp(n - 1, n - 1)\n    return str(result)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_snacks = int(stdin.split(\" \")[0])\n    positions = stdin.split(\" \")[1:]\n    \n    # Find the last position on the left side of the machine\n    min_left = -1\n    for p in positions:\n        pos = int(p)\n        if min_left == -1:\n            min_left = pos\n        else:\n            min_left = min(min_left, pos)\n    \n    # Find the highest profit on the right side of the machine\n    max_right = -1\n    for p in positions:\n        pos = int(p)\n        if max_right == -1:\n            max_right = pos\n        else:\n            max_right = max(max_right, pos)\n    \n    # Find the price of the left side of the machine\n    min_left_price = -1\n    for p in positions:\n        pos = int(p)\n        if min_left == pos:\n            min_left_price = int(p)\n    \n    # Find the price of the right side of the machine\n    max_right_price = -1\n    for p in positions:\n        pos = int(p)\n        if max_right == pos:\n            max_right_price = int(p)\n    \n    # Find the total profit\n    total_profit = (max_right_price - min_left_price) - (max_right - min_left)\n    return total_profit\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, *input = map(int, stdin.split())\n    return '%d' % max(0, max(input) - min(input))\n"
    },
    {
        "number": 3293,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # change stdin to a list\n    _, n = map(int, stdin.split())\n    pos_n = list(map(int, stdin.split()))\n    pos_n.sort()\n\n    f = lambda x: pos_n[x-1]\n    p = lambda x: pos_n[x]\n    m = lambda x: x\n    s = lambda x: x\n\n    net_gain = lambda pos_n: m(pos_n[0]) - p(pos_n[0])\n    for i in range(1, n):\n        net_gain = max(net_gain(pos_n), net_gain(pos_n[:i]) + net_gain(pos_n[i:]))\n    return str(net_gain)"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    sys.setrecursionlimit(10**6)\n    input = stdin\n    contours = []\n    for i in range(int(input.splitlines()[0])):\n        contours.append(list(map(int, input.splitlines()[i + 1].split())))\n    # this is the polygon code\n    total = 0\n    for i in range(len(contours) - 1):\n        total += sqrt((contours[i + 1][0] - contours[i][0]) ** 2 + (contours[i + 1][1] - contours[i][1]) ** 2)\n    return str(round(total, 6))\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    xs, ys, x1, y1, x2, y2 = [], [], [], [], [], []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.strip().split())\n        xs += [x1, x2]\n        ys += [y1, y2]\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P0.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P1.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P2.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P3.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P4.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P5.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P6.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P7.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P8.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P9.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P10.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P11.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P12.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P13.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P14.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P15.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P16.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P17.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P18.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P19.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P20.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P21.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P22.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P23.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P24.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P25.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P26.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P27.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P28.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P29.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P30.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P31.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P32.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P33.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P34.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P35.pdf\n    # http://www.cs.mcgill.ca/~aab/Papers/CS-5316/p01-papers/pdfs/P36.pdf\n    # http://www.cs.mcg"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin.strip())\n    lines = []\n    for i in range(num):\n        lines.append(stdin.strip().split('\\n')[i])\n    contours = []\n    for line in lines:\n        contours.append([int(x) for x in line.split(' ')])\n    points = set()\n    for contour in contours:\n        for i in range(len(contour)-1):\n            points.add((contour[i], contour[i+1]))\n    points = list(points)\n    points.sort()\n    points.reverse()\n    distances = []\n    for i in range(len(points)-1):\n        distances.append(abs(points[i+1][0]-points[i][0])+abs(points[i+1][1]-points[i][1]))\n    return''.join([str(round(x,6)) for x in distances])\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    lines = stdin.splitlines()[1:]\n    H_0, H_1 = map(int, lines[0].split())\n    vertices = []\n    for line in lines[1:]:\n        x, y = map(int, line.split())\n        vertices.append((x, y))\n    vertices.sort()\n    closest = abs(H_0 - vertices[0][1])\n    for i in range(N):\n        h_0, h_1 = vertices[i]\n        distance = abs(H_0 - h_0)\n        while (i + 1) < N and vertices[i + 1][1] > h_0:\n            distance += abs(vertices[i + 1][0] - h_0)\n            i += 1\n        distance += abs(h_0 - vertices[i + 1][1])\n        if distance < closest:\n            closest = distance\n    return str(closest)\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    land = []\n    for i in range(N):\n        contour = stdin.split()\n        for j in range(2):\n            contour[j] = int(contour[j])\n        land.append(contour)\n\n    land = sorted(land, key=lambda x: (x[1], x[0]))\n    len_land = len(land)\n    while len_land > 1:\n        if land[0][1] > land[1][1]:\n            land.pop(0)\n            len_land -= 1\n        else:\n            land.pop(1)\n            len_land -= 1\n\n    return str(land[0][0])\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.strip()"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    contours = []\n    contour = None\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        if line == '0':\n            contours.append(contour)\n            contour = None\n        else:\n            if contour:\n                contour.append(tuple(map(int, line.split())))\n            else:\n                contour = [tuple(map(int, line.split()))]\n    if contour:\n        contours.append(contour)\n    height_to_slope = defaultdict(list)\n    for contour in contours:\n        if len(contour) > 2:\n            i0, i1 = 0, 1\n            while i0 < len(contour) - 1:\n                x0, y0 = contour[i0]\n                x1, y1 = contour[i1]\n                slope = (y1 - y0) / (x1 - x0)\n                height_to_slope[y0].append(slope)\n                i0 += 1\n                i1 += 1\n    min_x_and_min_y = min_and_max_from_list(height_to_slope[0])\n    min_x = min_x_and_min_y[0]\n    min_y = min_x_and_min_y[1]\n    max_x_and_max_y = max_and_min_from_list(height_to_slope[1])\n    max_x = max_x_and_max_y[0]\n    max_y = max_x_and_max_y[1]\n    distance = max_x - min_x\n    min_y = max(min_y, 0)\n    max_y = min(max_y, height_to_slope[1][-1])\n    min_x = max(min_x, 0)\n    max_x = min(max_x, height_to_slope[1][-1])\n    max_x_and_min_y = max_and_min_from_list(height_to_slope[1])\n    min_x = max(min_x, max_x_and_min_y[0])\n    min_y = min(min_y, max_x_and_min_y[1])\n    max_y = min(max_y, max_x_and_min_y[1])\n    distance = max(distance, max_x - min_x)\n    distance = max(distance, max_y - min_y)\n    return str(distance)\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin = '''5 8 4 -2 0 0 -3 2 0 0 3\n    8 10 4 -1 -1 1 -1 1 1 -1 1\n    Sample Output 1:\n    5.2696518641\n    '''\n    return stdin.strip()\n"
    },
    {
        "number": 3294,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    h0, h1 = stdin.splitlines()[1:3]\n    h0 = int(h0)\n    h1 = int(h1)\n    lines = stdin.splitlines()[3:]\n    def get_dist(x0: int, y0: int, x1: int, y1: int) -> int:\n        return (x1 - x0) ** 2 + (y1 - y0) ** 2\n    def slope(x0: int, y0: int, x1: int, y1: int) -> float:\n        return (y1 - y0) / (x1 - x0)\n    def get_h(x: int, y: int) -> float:\n        return min(h0, h1) if x >= 0 else max(h0, h1)\n    area = float('inf')\n    for l in lines:\n        x, y = map(int, l.split())\n        area = min(area, get_dist(x, y, x - 1, y - 1) + get_dist(x, y - 1, x - 1, y) + get_dist(x, y - 1, x, y) + get_dist(x - 1, y, x, y))\n    return str(area)"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    game_count = int(stdin)\n    answer_list = []\n    for i in range(game_count):\n        num_list = list(map(int, stdin.split()))\n        target_list = find_target(num_list[0], num_list[1], num_list[2])\n        answer_list.append(target_list[0])\n        stdin = stdin.replace(str(target_list[0]), str(target_list[1]))\n    return stdin\n\n\ndef"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin)\n    res = []\n    prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n    for i in range(q):\n        K, L, M = map(int, stdin.split())\n        K_prime = K\n        while K_prime < 10000000:\n            K_prime += 1\n            if K_prime in prime:\n                K_prime += 1\n                if K_prime in prime:\n                    K_prime += 1\n            else:\n                K_prime += 1\n        L_prime = L\n        while L_prime < K_prime:\n            L_prime += 1\n            if L_prime in prime:\n                L_prime += 1\n                if L_prime in prime:\n                    L_prime += 1\n            else:\n                L_prime += 1\n        M_prime = M\n        while M_prime < K_prime:\n            M_prime += 1\n            if M_prime in prime:\n                M_prime += 1\n                if M_prime in prime:\n                    M_prime += 1\n            else:\n                M_prime += 1\n        if L_prime == K_prime and M_prime == K_prime:\n            res.append(K_prime)\n        else:\n            pass\n    if len(res) == 0:\n        return -1\n    else:\n        return str(res[0])\nstdin = ''\nstdout = []\nfor stdin_i in stdin.splitlines():\n    stdin_i = stdin_i.strip()\n    stdout_i = solution(stdin_i)\n    stdout.append(stdout_i + '\\n')\nprint(''.join(stdout))"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    for _ in range(N):\n        K, L, M = map(int, stdin.readline().split())\n        if K * L > M:\n            print(K * L - M)\n        else:\n            print(-1)\n\n    return"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    K, L, M = list(map(int, stdin.split()))\n    happy_nums = [x for x in range(2, K + 1) if is_happy_number(x)]\n    return str(happy_nums[L - 1] if len(happy_nums) >= L else -1)\n\n\ndef"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.splitlines()\n    q = int(inputs[0])\n    k, l, m = list(map(int, inputs[1]))\n    for i in range(2, q + 1):\n        k, l, m = list(map(int, inputs[i]))\n        is_prime = []\n        is_happy = []\n        for j in range(k, l + 1):\n            is_prime.append(is_prime_number(j))\n            if is_prime_number(j):\n                is_happy.append(j)\n        if len(is_happy) > l:\n            continue\n        else:\n            return '\\n'.join([str(len(is_happy)), str(max(is_happy))])\n\n\ndef"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return '#{}'.format(max(max(set(range(1, int(stdin.strip()) + 1)), key=lambda k: k % 2 == 0)), max(set(range(1, int(stdin.strip()) + 1)), key=lambda k: k % 2!= 0))\n\n\nprint(solution(\"5 1 1\"))\n"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N = int(inputs[0])\n    qs = list(map(int,inputs[1:]))\n    qs.sort()\n    h = []\n    for i in range(qs[0],qs[1]+1):\n        for j in range(qs[0],qs[1]+1):\n            for k in range(qs[0],qs[1]+1):\n                if is_happy(i,j,k):\n                    h.append(i)\n                    h.append(j)\n                    h.append(k)\n    if len(h) == 0:\n        return -1\n    else:\n        return str(min(h))\n\ndef"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ans = None\n    # Write your code here\n    Q = int(stdin)\n    for i in range(Q):\n        arr = list(map(int, stdin.split()))\n        if arr[0] == 1:\n            if arr[1] > arr[2]:\n                ans = -1\n            else:\n                ans = (arr[1] + arr[2])\n        elif arr[0] == 2:\n            if arr[1] < arr[2]:\n                ans = -1\n            else:\n                ans = (arr[1] * arr[2])\n        elif arr[0] == 3:\n            if arr[1] % arr[2] == 0:\n                ans = -1\n            else:\n                ans = arr[1] // arr[2]\n    return str(ans)"
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    q, k, l, m = map(int, stdin.split())\n    prime = [True] * (m + 1)\n    for i in range(2, m + 1):\n        if prime[i]:\n            for j in range(i + i, m + 1, i):\n                prime[j] = False\n    num = []\n    for i in range(k, m + 1):\n        num.append(i)\n    for i in range(l - 1, -1, -1):\n        if prime[num[i]]:\n            for j in range(i, m):\n                if prime[j]:\n                    num[i], num[j] = num[j], num[i]\n                    break\n        if len(num) == q:\n            return \" \".join(map(str, num))\n    return \"-\""
    },
    {
        "number": 3295,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    nums = []\n    for i in range(0, int(stdin.split()[0])):\n        nums.append([int(i) for i in stdin.split()[i+1].split(' ')])\n    return -1 if nums[0][1] + nums[0][2] > nums[0][0] and nums[0][2] + nums[0][3] > nums[0][1] else str(max(max(nums[1]), max(nums[2])))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(i) for i in stdin.split()]\n    return str(pow(n, k, 10**9 + 7))"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n,k = map(int,stdin.split())\n    if n<=2:\n        return str(n)\n    s = str(n)\n    t = '0'\n    for i in range(len(s)-1,-1,-1):\n        t += str(int(s[i])-k)\n    return t"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n,k = list(map(int,stdin.split()))\n    return '%d'%(factorial(n)//factorial(n-k)%(2**31-1))\n"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (N, K) = (int(i) for i in stdin.split())\n    return str(bin(N).count('1') + bin(K).count('1') - bin(N + K - 1).count('1'))\n"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = stdin.split()\n    return str(2**(int(N)-1) % int(K))"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = stdin.split()\n    N = int(N)\n    K = int(K)\n    count = 0\n    count2 = 0\n    while True:\n        count += 1\n        if count == N:\n            break\n        if count2 == K:\n            count2 = 0\n            count += 1\n        count2 += 1\n    return str(count)"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    :type stdin: str\n    :rtype: str\n    '''\n    [N,K]=list(map(int,stdin.split()))\n    return str(bin(N*(K-1))[2:].count('1'))\n"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = int(stdin)\n    r = k\n    t = 1\n    while k > t:\n        t = t * r\n        r = r + 1\n    return str(t)"
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The prime number $P=2^{31}-1$ is taken from a library in which you must try to write a program so that it can count all natural numbers of at most $2^{31} - 1$ modulo $P$.\n\n    The prime number $P=2^{31}-1$ is the largest prime number below 2^32 - 1, which is why we cannot count numbers that are greater than 2^31 - 1, as the prime number $P=2^{31}-1$ would then be smaller than any of those numbers.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # A MUCH BETTER SOLUTION:\n    # # The value of $P$ is taken from a library in which you must try to write a program so that it can count all natural numbers of at most $2^{31} - 1$ modulo $P$.\n    #\n    # The prime number $P=2^{31}-1$ is the largest prime number below 2^32 - 1, which is why we cannot count numbers that are greater than 2^31 - 1, as the prime number $P=2^{31}-1$ would then be smaller than any of those numbers.\n    # ------------------------------------------------------------------\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    "
    },
    {
        "number": 3296,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    return str(factorial(n, mod=k))\n\n\ndef"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    import math\n    s = stdin\n    letters = set()\n    for i in range(10):\n        letters.add(str(i))\n\n    for i in range(10):\n        letters.add(chr(i + ord('A')))\n\n    for i in range(10):\n        letters.add(chr(i + ord('a')))\n\n    for i in range(10):\n        letters.add(chr(i + ord('0')))\n\n    nums = {str(i): i for i in range(10)}\n    nums.update({'1': 0, '0': 1})\n\n    def replace_all(pattern: str, replacement: str):\n        return re.sub(pattern, replacement, s)\n\n    def is_a_valid_eq(s: str):\n        return len(set(s)) == len(s)\n\n    def is_solved(s: str):\n        for i in range(len(s)):\n            if '+' in s[i] or '=' in s[i]:\n                return False\n        return True\n\n    def is_solvable(s: str):\n        return not is_solved(s)\n\n    def is_valid(s: str):\n        if is_a_valid_eq(s) and is_solvable(s):\n            return True\n        return False\n\n    def solve(s: str):\n        s = replace_all('\\+|=', '+')\n        s = replace_all(' ', '+')\n        if is_valid(s):\n            return s\n        return solve(replace_all('+', 'a')) + '+' + solve(replace_all('=', '0'))\n\n    return solve(s)\n\n\nprint(solution(input()))"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    if len(words) == 0:\n        return 'impossible'\n    words.sort()\n    # output = ''\n    # for word in words:\n    #     letters = [ch for ch in word]\n    #     for ch in letters:\n    #         if ch.isalpha():\n    #             for c in range(ord('A'), ord('Z') + 1):\n    #                 letters.append(chr(c))\n    #     output += ''.join(letters)\n    # return output\n    return ''.join(sorted(sorted(words, key=lambda x: x.replace(x, chr(ord('A') + ord(x.lower()) - ord('a')))), key=lambda x: x.replace(x, chr(ord('a') + ord(x.lower()) - ord('A'))))).replace('+', '+1').replace('=', '+0').replace('-', '-1').replace(' ', '')"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    P = stdin.split('\\n')\n    return 'impossible' if P[0].count('+')!= P[0].count('=') else min(\n        (\n            ''.join(x) if x[0]!= '0' else '0'\n            for x in\n            sorted(\n                ''.join(\n                    str(\n                        ''.join(sorted(P[0].replace(y, str(x)))\n                                 if y!= '+'\n                                 else y\n                                 )\n                        for y in\n                        ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9')\n                        )\n                    )\n            )\n        )\n    )\nprint(solution(input()))"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin.splitlines()[0]\n    text = text.split('=')[0]\n    # If all letters are already replaced by same digit, then return \"impossible\"\n    if all(ord(c) - ord('A') == 0 for c in text) or all(ord(c) - ord('A') == ord('0') for c in text):\n        return \"impossible\"\n    # Initialize a list of strings, each of which corresponds to the corresponding digit\n    digits = ['0'] * len(text)\n    # print(digits)\n    # Initialize a list of lists, each of which corresponds to a word\n    words = [['0']]\n    # print(words)\n    # Begin the backtracking loop\n    while len(words)!= 0:\n        # Loop over the word list\n        word_list = words.pop()\n        # print(word_list)\n        for i in range(len(word_list)):\n            # Create a string representation of word_list, and add it to digits\n            temp_str = word_list[i]\n            for j in range(len(word_list)):\n                if j!= i:\n                    temp_str += word_list[j]\n            # print(temp_str)\n            # Check if the resulting string is an integer\n            try:\n                # print(int(temp_str))\n                # Check if the resulting string is an integer\n                if int(temp_str) == int(temp_str):\n                    # If it is, add the digit to the digit list\n                    digits[i] = str(int(temp_str))\n                    # print(digits[i])\n            except ValueError:\n                # print('Not an integer')\n                # If it is not an integer, then add the word to the word list\n                words.append(word_list + [temp_str])\n                # print(words)\n    # For each digit, check if the digit is 0. If it is 0, print impossible. If it is not 0, replace all occurrences of 0 with $0$ and convert the result to an integer\n    for i in range(len(digits)):\n        if digits[i] == '0':\n            print('impossible')\n            break\n    # If none of the digits is 0, then check if the resulting string is an integer\n    else:\n        # print(digits)\n        # Check if the resulting string is an integer\n        try:\n            # print(int(digits))\n            # Check if the resulting string is an integer\n            if int(digits) == int(digits):\n                # If it is, print the resulting integer\n                print(digits)\n        except ValueError:\n            # print('Not an integer')\n            # If it is not an integer, then print impossible\n            print('impossible')\n    # Return the word list\n    return''.join(word_list)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n\n    return_value = 'impossible'\n\n    for i in range(len(lines)):\n        puzzle = lines[i].split('+')\n\n        if len(puzzle[0]) > len(puzzle[1]):\n            continue\n\n        puzzle_solution = puzzle[0][::-1]\n        puzzle_solution += puzzle[1]\n\n        # print(puzzle_solution)\n\n        for letter in puzzle_solution:\n            if letter == '0':\n                continue\n            if puzzle_solution.count(letter) > puzzle_solution.count(puzzle_solution[puzzle_solution.index(letter)]):\n                # print(letter, puzzle_solution.index(letter), puzzle_solution.count(letter), puzzle_solution.count(puzzle_solution[puzzle_solution.index(letter)]))\n                puzzle_solution = puzzle_solution.replace(letter, str(puzzle_solution.count(letter)))\n\n        # print(puzzle_solution)\n        if int(puzzle_solution) < 10:\n            return_value = puzzle_solution\n            break\n\n    return return_value\n"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Build and return a possible solution for the cryptarithmetic puzzle.\n    \"\"\"\n    num_words = len(stdin)\n    num_moves = num_words // 2\n    all_letters = set(string.ascii_uppercase)\n    puzzle = stdin.replace(' ', '')\n\n    # Solve puzzle recursively.\n    def solve(puzzle, moves):\n        # Check if puzzle is solved.\n        if moves == num_moves:\n            return puzzle\n\n        # Check if puzzle is impossible.\n        if not puzzle:\n            return 'impossible'\n\n        # Check if puzzle is solvable.\n        letter_0, letter_1 = puzzle[:2]\n        if letter_0 == letter_1:\n            possible_solution = solve(puzzle[2:], moves + 1)\n            if possible_solution == 'impossible':\n                return 'impossible'\n            return letter_0 + str(int(possible_solution) + 1) + letter_1\n\n        # Check if puzzle can be solved.\n        if letter_0 in all_letters:\n            possible_solution_0 = solve(puzzle[2:], moves + 1)\n            if possible_solution_0 == 'impossible':\n                return 'impossible'\n            else:\n                return letter_0 + str(int(possible_solution_0) + 1)\n\n        # Check if puzzle can be solved.\n        if letter_1 in all_letters:\n            possible_solution_1 = solve(puzzle[2:], moves + 1)\n            if possible_solution_1 == 'impossible':\n                return 'impossible'\n            else:\n                return letter_0 + str(int(possible_solution_1) + 1)\n"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    for _ in range(1000):\n        s = s.replace(max(sorted(s)), str(min(map(lambda x: max(x), sorted(s)))))\n    return s"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.strip().split('\\n')\n    for puzzle in stdin:\n        # Your code here\n    return stdout\n"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    chars = {c for w in s for c in w}\n    if '0' in chars:\n        return 'impossible'\n    for i in range(1, 10):\n        if i not in chars:\n            return str(i) + '+' + '+'.join([str(i) for i in range(10)]) + '=' + ''.join(s)\n\nsolution(input())\n"
    },
    {
        "number": 3297,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    puzzle = stdin.splitlines()\n    answer = \"\"\n    for puzzle_index, puzzle_line in enumerate(puzzle):\n        # for puzzle_index, puzzle_line in enumerate(puzzle):\n        puzzle_line_split = puzzle_line.split(\"=\")\n        # puzzle_line_split = puzzle_line.split(\"=\")\n        puzzle_line_split_with_plus = puzzle_line_split[0] + \"+\"\n        puzzle_line_split_with_plus_split = puzzle_line_split_with_plus.split(\"+\")\n        puzzle_line_split_with_plus_split_copy = puzzle_line_split_with_plus_split.copy()\n        puzzle_line_split_with_plus_split_copy.sort()\n        puzzle_line_split_with_plus_string = \"\"\n        for item in puzzle_line_split_with_plus_split_copy:\n            puzzle_line_split_with_plus_string += str(item)\n        puzzle_line_split_with_plus_string = puzzle_line_split_with_plus_string[:-1]\n        puzzle_line_split_with_plus_string_split = puzzle_line_split_with_plus_string.split(\"+\")\n        puzzle_line_split_with_plus_string_split_copy = puzzle_line_split_with_plus_string_split.copy()\n        puzzle_line_split_with_plus_string_split_copy.sort()\n        puzzle_line_split_with_plus_string_split_copy_copy = puzzle_line_split_with_plus_string_split_copy.copy()\n        # print(puzzle_line_split_with_plus_string_split_copy)\n        # print(puzzle_line_split_with_plus_string_split_copy_copy)\n        # puzzle_line_split_with_plus_string_split_copy_copy.sort()\n        # print(puzzle_line_split_with_plus_string_split_copy_copy)\n        answer_with_plus_string = \"\"\n        for index, item in enumerate(puzzle_line_split_with_plus_string_split_copy_copy):\n            if index == 0:\n                answer_with_plus_string += item\n            else:\n                answer_with_plus_string += \"+\" + item\n        answer_with_plus_string += \"=\" + puzzle_line_split_with_plus_string_split_copy[-1]\n        answer_with_plus_string_split = answer_with_plus_string.split(\"+\")\n        answer_with_plus_string_split_copy = answer_with_plus_string_split.copy()\n        answer_with_plus_string_split_copy.sort()\n        answer_with_plus_string_split_copy_copy = answer_with_plus_string_split_copy.copy()\n        answer_with_plus_string_split_copy_copy.sort()\n        answer_with_plus_string_split_copy_copy_copy = answer_with_plus_string_split_copy_copy.copy()\n        answer_with_plus_string_split_copy_copy_copy.sort()\n        answer_with_plus_string_split_copy_copy_copy_copy = answer_with_plus_string_split_copy_copy.copy()\n        answer_with_plus_string_split_copy_copy_copy_copy.sort()\n        # print(answer_with_plus_string_split_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy)\n        answer_with_plus_string_split_copy_copy_copy_copy_copy_copy = answer_with_plus_string_split_copy_copy_copy_copy.copy()\n        answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy.sort()\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print(answer_with_plus_string_split_copy_copy_copy_copy_copy_copy_copy_copy_copy)\n        # print"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    seq = sorted(list(map(int, stdin.strip().split())))\n    count = 0\n    for i in range(n - 1):\n        if seq[i] > seq[i + 1]:\n            count += 1\n            for j in range(i + 1, n):\n                if seq[i] < seq[j]:\n                    break\n                if seq[i] > seq[j]:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    cnt = 0\n    for i in range(1, n):\n        if a[i] < a[i-1]:\n            for j in range(i):\n                if a[j] > a[i]:\n                    a[j], a[i] = a[i], a[j]\n                    cnt += 1\n    return str(cnt)"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # +++your code here+++\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    a.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if a[i] > a[j] and a[j] < a[i]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string of numbers.\n    Splits the string into an array of integers.\n    Checks if all integers are in ascending order.\n    Returns the number of such sequences that are also in descending order.\n    \"\"\"\n    unsorted_sequences = [int(x) for x in stdin.split(\" \")]\n    print(len([x for x in range(1, len(unsorted_sequences)) if unsorted_sequences[x - 1] > unsorted_sequences[x]]))\n    return str(len([x for x in range(1, len(unsorted_sequences)) if unsorted_sequences[x - 1] > unsorted_sequences[x]]))\n"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [int(x) for x in stdin.split()]\n    d = collections.defaultdict(int)\n    ans = 0\n    for x in a:\n        d[x] += 1\n    for k in d.keys():\n        ans += (d[k] * (d[k] - 1)) // 2\n    return str(ans % (10**9 + 9))\n"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = sorted(list(map(int, stdin.split('\\n')[0].split())))\n    print(inputs)\n    num_unions = 1\n    i = 1\n    while i < len(inputs):\n        if inputs[i] >= inputs[i - 1]:\n            i += 1\n            continue\n        i_1 = i - 1\n        i_2 = i + 1\n        while i_1 >= 0 and inputs[i_1] > inputs[i_2]:\n            i_1 -= 1\n        while i_2 < len(inputs) and inputs[i_2] > inputs[i_1]:\n            i_2 += 1\n        for i in range(i_1 + 1, i_2):\n            inputs[i], inputs[i_1] = inputs[i_1], inputs[i]\n        i = i_1 + 1\n        num_unions += 1\n    return num_unions % (10 ** 9 + 9)"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    return str(solution_help(a, n))\n\ndef"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    nums = list(map(int, stdin.split()))\n    count = 0\n    for i in range(N - 1):\n        if not nums[i] <= nums[i + 1]:\n            sorted_nums = sorted(nums[:i] + nums[i + 1:])\n            print(sorted_nums)\n            count += sorted_nums.count(nums[i])\n    return str(count)\n"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    c = list(map(int, stdin.split()))\n    count = 0\n    while c:\n        i = 0\n        while i < len(c)-1:\n            if c[i] > c[i+1]:\n                break\n            i += 1\n        if i == len(c) - 1:\n            count += 1\n        c.pop(i)\n        c.pop(i)\n    return str(count)\nprint(solution(input()))\n"
    },
    {
        "number": 3298,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin:\n    a,b,c,d,e = input().split()\n    print(min([len(a), len(b), len(c), len(d), len(e)]))\n    \"\"\"\n    n = int(stdin)\n    s = list(map(int, stdin.split()))\n    l = len(s)\n    ans = 0\n    for i in range(l):\n        for j in range(i+1,l):\n            # print(s)\n            # print(s[i])\n            # print(s[j])\n            if(s[i] < s[j]):\n                break\n            elif (s[i] > s[j]):\n                ans += 1\n    # print(ans)\n    return str(ans % 1000000007)"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin\n    '''\n\n    def check_cell(num: int, arr: list, r: int, c: int) -> bool:\n        '''\n        Check if a cell is within a range of the checkerboard and return a boolean indicating that the cell meets the constraint.\n        '''\n        # row\n        for i in range(r, r + 3):\n            if arr[i][c] == num:\n                return False\n        # column\n        for i in range(c, c + 3):\n            if arr[r][i] == num:\n                return False\n        # diagonal\n        if r + 1 <= r + 2:\n            for i in range(c, c + 3):\n                if arr[r + 1][i] == num:\n                    return False\n        if r - 1 >= r - 2:\n            for i in range(c, c + 3):\n                if arr[r - 1][i] == num:\n                    return False\n        return True\n\n    n, m = map(int, stdin.split())\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, stdin.split())))\n    for i in range(n):\n        for j in range(m):\n            if arr[i][j] == 0:\n                if check_cell(arr[i][j], arr, i, j):\n                    continue\n                else:\n                    return -1\n    sum_ = 0\n    for row in range(n):\n        for col in range(m):\n            if arr[row][col] % 2 == 0:\n                sum_ += arr[row][col]\n            else:\n                sum_ += arr[row][col] * 2\n    return str(sum_)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdout.strip()"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split())\n    data = stdin.split()\n    dp = [[] for i in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            dp[j].append(int(data[i*cols + j]))\n    dp.reverse()\n    for i in range(cols):\n        for j in range(rows):\n            if dp[i][j] % 2!= 0:\n                if i - 1 < 0 or j - 1 < 0:\n                    return -1\n                if dp[i-1][j-1] % 2!= 0:\n                    return -1\n                if dp[i-1][j] % 2!= 0:\n                    return -1\n                if dp[i][j-1] % 2!= 0:\n                    return -1\n    dp.reverse()\n    for i in range(cols):\n        for j in range(rows):\n            dp[i].append(int(data[j*cols + i]))\n    dp.reverse()\n    dp.reverse()\n    row_len = len(dp)\n    col_len = len(dp[0])\n    dp = [dp[i][::-1] for i in range(row_len)]\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp = [[dp[i][j] for j in range(col_len-1, -1, -1)] for i in range(row_len-1, -1, -1)]\n    dp.reverse()\n    dp.reverse()\n    dp.reverse()\n    dp.reverse()\n    for i in range(cols):\n        for j in range(rows):\n            if dp[i][j] % 2!= 0:\n                return -1\n    dp = [i for i in dp if sum(i) >= 0]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0] >= 0 and i[-1] >= 0]]\n    dp.reverse()\n    dp = [[i for i in dp if i[0]"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    checkerboard = [[0 for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        row = stdin.split()[i + 2]\n        for j in range(m):\n            checkerboard[i][j] = int(row[j])\n\n    odds = []\n    evens = []\n    for i in range(n):\n        for j in range(m):\n            if checkerboard[i][j] % 2 == 0:\n                evens.append(checkerboard[i][j])\n            else:\n                odds.append(checkerboard[i][j])\n    if len(odds) < len(evens):\n        return -1\n\n    odd_even_partition = []\n    for i in range(len(odds)):\n        if odds[i] % 2 == 1:\n            odd_even_partition.append(odds[i])\n        else:\n            odd_even_partition.append(evens[i])\n\n    odd_partition = []\n    even_partition = []\n    odds.reverse()\n    for i in range(len(odds)):\n        if odds[i] % 2 == 1:\n            odd_partition.append(odds[i])\n        else:\n            even_partition.append(odds[i])\n    even_partition.reverse()\n\n    odd_sum = sum(odds)\n    even_sum = sum(evens)\n    odd_even_sum = sum(odd_even_partition)\n    odd_partition_sum = sum(odd_partition)\n    even_partition_sum = sum(even_partition)\n\n    if odd_even_sum > 0:\n        return -1\n\n    if odd_sum > odd_even_sum:\n        return -1\n\n    if odd_partition_sum > even_partition_sum:\n        return -1\n\n    if odd_even_partition_sum > odd_partition_sum:\n        return -1\n\n    if odd_sum == odd_even_sum == odd_partition_sum == even_partition_sum == even_sum:\n        return sum(odds) + sum(evens)\n\n    return -1\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    stdin = '''\n    5 5\n    1 2 3 0\n    0 0 5 6\n    0 0 7 8\n    7 0 0 10\n    '''\n    n, m = map(int, stdin.split())\n    checkerboard = []\n    for _ in range(n):\n        checkerboard.append(list(map(int, stdin.split())))\n\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if checkerboard[i][j]!= 0:\n                parity = parity_parity(i, j, n, m, checkerboard)\n                if parity == 0:\n                    continue\n                else:\n                    row_max = max(checkerboard[i])\n                    col_max = max(checkerboard[j])\n                    if parity == 1:\n                        row_max *= 2\n                        col_max *= 2\n                    checkerboard[i][j] = row_max\n                    checkerboard[j][i] = col_max\n                    min_sum = min(min_sum, row_max + col_max)\n    if min_sum == float('inf'):\n        return -1\n    return str(min_sum)\n\ndef"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('3 3\\n1 2 3 0\\n0 0 5 6\\n0 0 7 8\\n7 0 0 10')\n    '88'\n    >>> solution('2 1\\n2 2')\n    '2'\n    >>> solution('3 3\\n1 2 3 0\\n0 0 5 6\\n0 0 7 8\\n7 0 0 10')\n    '88'\n    '''\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin[0].split())\n    checkerboard = stdin[1:]\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if checkerboard[i][j]!= 0:\n                if not check_magic_checkerboard(i, j, n, m, checkerboard):\n                    return '-1'\n                ans += checkerboard[i][j]\n    return str(ans)\ndef"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def val(a):\n        return int(a)\n    a = stdin.split()\n    N,M = map(val,a[:2])\n    B = [list(map(val,row.split())) for row in a[2:]]\n    f = lambda x,y:x+y\n    for i in range(N):\n        B[i].sort(key=f)\n        B[i].sort(key=f,reverse=True)\n    l = len(B)\n    r = max(len(B[i]) for i in range(l))\n    if l==1 and r==1 and (B[0][0] == 0 or B[1][0] == 0):\n        return -1\n    ans = 0\n    for j in range(l):\n        for i in range(r):\n            if i == 0:\n                ans += sum(B[j][i:i+1])\n            if i!= 0:\n                ans -= sum(B[j][i-1:i+1])\n    return str(ans)\n"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: Write your code here\n    check = stdin.splitlines()\n    arr = list()\n    for i in check:\n        arr.append(list(map(int, i.split())))\n    check = arr\n    n = len(check)\n    m = len(check[0])\n    # print(n, m)\n    if n == m:\n        for i in range(n):\n            if check[i][0] == 0:\n                for j in range(m):\n                    if check[i][j] % 2 == 1:\n                        return -1\n            else:\n                for j in range(m):\n                    if check[i][j] % 2 == 0:\n                        return -1\n        return sum(i)\n    else:\n        return -1\n"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Input: checkerboard\n    # Output: answer\n    pass\n"
    },
    {
        "number": 3299,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    rows = int(stdin.split()[0])\n    columns = int(stdin.split()[1])\n    checkerboard = stdin.split()[2:]\n    if not checkerboard:\n        return -1\n    odd = 0\n    even = 0\n    checkerboard.sort()\n    for i in range(len(checkerboard)):\n        if checkerboard[i] % 2 == 0:\n            even += int(checkerboard[i])\n        else:\n            odd += int(checkerboard[i])\n    if even - odd!= 0:\n        return -1\n    for i in range(len(checkerboard)):\n        if checkerboard[i] % 2 == 1:\n            if checkerboard[i] > columns:\n                return -1\n            elif checkerboard[i]!= columns:\n                checkerboard[i] += 1\n        else:\n            if checkerboard[i] < rows:\n                return -1\n            elif checkerboard[i]!= rows:\n                checkerboard[i] -= 1\n    return str(sum(checkerboard))"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    t = []\n    for i in range(N):\n        t.append([int(i) for i in stdin.strip().split()])\n    t.sort(key=lambda x: x[0])\n    min_dis = 0.0\n    for i in range(N):\n        if i == 0 or i == N - 1:\n            min_dis = min(min_dis, t[i][1])\n        else:\n            min_dis = min(min_dis, abs(t[i][0] - t[i - 1][0]) + t[i][1])\n    return '{0:.2f}'.format(min_dis)\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    n = int(inputs[0])\n    times = list(map(int, inputs[1:]))\n\n    min_length = 10**6\n\n    for i in range(n):\n        if times[i] == 0:\n            min_length = min(min_length, times[i+1])\n\n    return f\"{min_length:.2f}\""
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    data = list(map(int, stdin.splitlines()[1:]))\n    t = 0\n    v = 1\n    run = 0\n    for i in range(n):\n        run += data[i] * v\n        t = max(t, run)\n        v += data[i]\n    return str(t)"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    time = list(map(lambda x: int(x), stdin.split()[1:]))\n    time.sort()\n    result = 0\n    distance = 0\n    for i in range(N):\n        distance += time[i]\n        if distance > time[i]:\n            result = distance - time[i]\n            break\n    return \"{:.4f}\".format(result)\nprint(solution(input()))\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split()\n    return str(min(int(data[i+1]) - int(data[i]) for i in range(len(data) - 1)))\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2\n   ... 1 1\n   ... 1 1\n   ... Sample Output 2:\n   ... 99999700002.000\n    ''')\n    9999700002.000\n    >>> solution('''2\n   ... 3 1\n   ... 1 2\n   ... Sample Output 2:\n   ... 6.000\n    ''')\n    6.000\n    >>> solution('''10\n   ... 1 4\n   ... 1 1\n   ... 1 2\n   ... 1 3\n   ... Sample Output 2:\n   ... 2.000\n    ''')\n    2.000\n    \"\"\"\n    k = int(stdin)\n    cheetah_speeds = list(map(int, stdin.split('\\n')))\n    cheetah_speeds.sort()\n\n    dists = []\n    for i in range(k):\n        dists.append(cheetah_speeds[i] * i)\n\n    dists.sort()\n\n    return '%.4f' % (dists[k - 1])\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N = int(stdin)\n    animals = list(map(int, stdin.split()))\n    t_i = []\n    v_i = []\n    #print(animals)\n    for i in range(N):\n        t_i.append(animals[i*2])\n        v_i.append(animals[i*2+1])\n    #print(t_i)\n    #print(v_i)\n    # t_i = [1,2,3,4]\n    # v_i = [1,2,3,4]\n    # a = 10\n    # b = 10\n    # a < b\n    # print(a<b)\n    # print(a!=b)\n    # print(a==b)\n    # print(a>b)\n    # print(a>=b)\n    # print(a<=b)\n    # print(a<=b)\n    #print(t_i)\n    #print(v_i)\n    #print(animals)\n    if N == 1:\n        return \"0.000\"\n    elif N == 2:\n        return \"0.000\"\n    else:\n        t_i.sort()\n        #print(t_i)\n        v_i.sort()\n        #print(v_i)\n        l_i = t_i[1] - t_i[0]\n        #print(l_i)\n        # print(t_i)\n        # print(l_i)\n        t_i = t_i[1:]\n        #print(t_i)\n        for i in range(len(t_i)):\n            l_i = max(l_i,t_i[i] - t_i[i-1])\n        return str(l_i)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return str(0.000)\n    t = []\n    v = []\n    for i in range(N):\n        t.append(int(stdin.split()[i]))\n        v.append(int(stdin.split()[i + 1]))\n    t.sort()\n    v.sort()\n    return str(t[-1] - t[0])\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ts = [int(i) for i in stdin.split()[1:]]\n    ts.sort()\n    ans = 0\n    first = ts[0]\n    last = ts[-1]\n    for i in range(1, n):\n        ans += ts[i] - first\n        first = ts[i]\n    return f\"{round(ans, 5)}\"\n"
    },
    {
        "number": 3300,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    starts = sorted(map(int, input().split()))\n    pack_length = 0\n    time = 0\n    while len(starts) > 1:\n        time_index = starts.index(min(starts))\n        if time_index == 0:\n            starts.pop(0)\n        else:\n            starts.pop(time_index)\n        if time_index == len(starts) - 1:\n            starts.pop(len(starts) - 1)\n        else:\n            starts.pop(time_index + 1)\n        time = starts[0] + 1\n        pack_length += time\n    return str(pack_length)\n"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y, a1, b1, c1, a2, b2, c2 = map(int, stdin.split())\n    if N == 1 and P == 1:\n        return 'Impossible'\n    elif N == 1 or P == 1:\n        return 'Infinity'\n    else:\n        a1 += a2\n        b1 += b2\n        c1 += c2\n        if a1 > X:\n            return 'Infinity'\n        if b1 > Y:\n            return 'Infinity'\n        if a1 <= X and b1 <= Y:\n            return 'Impossible'\n        if a1 == X and b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X:\n            return str(max(a1, b1, c1))\n        elif b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X:\n            return str(max(a1, b1, c1))\n        elif b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 < X and b1 < Y:\n            return str(max(a1, b1, c1))\n        elif a1 < X and b1 > Y:\n            return str(max(a1, b1, c1))\n        elif a1 > X and b1 < Y:\n            return str(max(a1, b1, c1))\n        elif a1 > X and b1 > Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X:\n            if b1 > Y:\n                return str(max(a1, b1, c1))\n            else:\n                return str(c1)\n        elif b1 == Y:\n            if a1 > X:\n                return str(max(a1, b1, c1))\n            else:\n                return str(c1)\n        elif a1 < X and b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X and b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 < X:\n            return str(max(a1, b1, c1))\n        elif b1 < Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X and b1 < Y:\n            return str(max(a1, b1, c1))\n        elif a1 > X and b1 == Y:\n            return str(max(a1, b1, c1))\n        elif a1 > X and b1 > Y:\n            return str(max(a1, b1, c1))\n        elif a1 == X and b1 > Y:\n            return str(max(a1, b1, c1))\n        else:\n            return str(max(a1, b1, c1))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y = (int(x) for x in stdin.split())\n    if X == Y:\n        return str(N + P)\n    L = 0\n    U = N\n    f = lambda A, B: A + max(B, L + 1)\n    ans = f(N, L + 1)\n    while L <= U:\n        M = (L + U) // 2\n        A = {f(M - i, U) for i in range(1, P + 1)}\n        B = {f(U - j, M) for j in range(1, P + 1)}\n        if len(A) < P and len(B) < P:\n            if len(A & B) == P:\n                ans = min(ans, M)\n                L = M + 1\n            else:\n                U = M - 1\n        else:\n            if len(A & B) == P:\n                ans = min(ans, M)\n                L = M + 1\n            else:\n                U = M - 1\n    if ans == N + P:\n        return \"Impossible\"\n    return str(ans)\n"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x, y, *a_i, *b_i = map(int, stdin.split())\n    x_i = {a_i[i]: b_i[i] for i in range(len(a_i))}\n    y_i = {b_i[i]: a_i[i] for i in range(len(b_i))}\n    d = collections.defaultdict(set)\n    for i in range(len(a_i)):\n        d[a_i[i]].add(b_i[i])\n    d_x = collections.defaultdict(set)\n    d_y = collections.defaultdict(set)\n    for i in range(len(b_i)):\n        d_x[b_i[i]].add(a_i[i])\n        d_y[a_i[i]].add(b_i[i])\n    d = d_x.copy()\n    d.update(d_y)\n    s = set()\n    for i in range(len(x_i)):\n        s.add((x_i[i], y_i[i]))\n    p = [(x_i[i], y_i[i]) for i in range(len(x_i))]\n    x_i, y_i = list(x_i.keys()), list(y_i.keys())\n    x_i.sort()\n    y_i.sort()\n    for i in x_i:\n        for j in y_i:\n            if j in d_x[i]:\n                p.append((i, j))\n            if i in d_y[j]:\n                p.append((j, i))\n    for i in range(len(x_i)):\n        if x_i[i] == y_i[i]:\n            p.append((x_i[i], y_i[i]))\n    for i in range(len(x_i)):\n        for j in range(len(y_i)):\n            if x_i[i] == y_i[j] and i!= j:\n                p.append((x_i[i], y_i[j]))\n    for i in range(len(x_i)):\n        if i == y_i.index(x_i[i]):\n            p.append((x_i[i], y_i[i]))\n    for i in range(len(y_i)):\n        for j in range(len(x_i)):\n            if y_i[i] == x_i[j] and i!= j:\n                p.append((y_i[i], x_i[j]))\n    p.sort()\n    x_i = set(x_i)\n    y_i = set(y_i)\n    s = list(s)\n    if len(s) == 0:\n        return \"Impossible\"\n    s = sorted(s, key=lambda x: (x[0], x[1]))\n    ans = 0\n    while len(s) > 0:\n        i, j = s.pop()\n        if i == j:\n            continue\n        if i in x_i and j in y_i:\n            if x_i.index(i) < y_i.index(j):\n                ans = max(ans, d[i][j] + ans)\n            else:\n                ans = max(ans, d[j][i] + ans)\n            x_i.remove(i)\n            y_i.remove(j)\n            x_i.add(j)\n            y_i.add(i)\n        if j in x_i and i in y_i:\n            if x_i.index(i) < y_i.index(j):\n                ans = max(ans, d[i][j] + ans)\n            else:\n                ans = max(ans, d[j][i] + ans)\n            x_i.remove(i)\n            y_i.remove(j)\n            x_i.add(j)\n            y_i.add(i)\n        if j in x_i and i in y_i:\n            if x_i.index(i) < y_i.index(j):\n                ans = max(ans, d[j][i] + ans)\n            else:\n                ans = max(ans, d[j][i] + ans)\n            x_i.remove(i)\n            y_i.remove(j)\n            x_i.add(i)\n            y_i.add(j)\n        if i in x_i and j in y_i:\n            if x_i.index(j) < y_i.index(i):\n                ans = max(ans, d[j][i] + ans)\n            else:\n                ans = max(ans, d[j][i] + ans)\n            x_i.remove(i)\n            y_i.remove(j)\n            x_i.add(j)\n            y_i.add(i)\n        "
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y, *a, *b, *c = map(int, stdin.split())\n    if min(a)!= max(a):\n        return 'Impossible'\n    if min(b)!= max(b):\n        return 'Impossible'\n    if min(c)!= max(c):\n        return 'Impossible'\n    return max(a[0] + b[0] + c[0], a[-1] + b[-1] + c[-1])\n"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x, y, *xs = list(map(int, stdin.split()))\n    if p > 3:\n        return 'Impossible'\n    pairs = [list(map(int, stdin.split())) for _ in range(p)]\n    depths = {x: 0 for x in range(1, n + 1)}\n    edges = defaultdict(list)\n    for i, j in pairs:\n        if i > j:\n            i, j = j, i\n        edges[i].append(j)\n        depths[j] += 1\n    queue = [(0, 0)]\n    visited = set()\n    result = -1\n    while queue:\n        depth, bank = heappop(queue)\n        if bank == y:\n            result = max(result, depth)\n        for neighbour in edges[bank]:\n            if neighbour not in visited:\n                visited.add(neighbour)\n                heappush(queue, (depth + depths[neighbour], neighbour))\n    if result == -1:\n        return 'Impossible'\n    return str(result)\n"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y, *data = list(map(int, stdin.strip().split()))\n    assert 1 <= N <= 1000\n    assert 1 <= P <= 10000\n    assert 1 <= X <= N\n    assert 1 <= Y <= N\n    assert len(data) == P\n    banks = set(map(int, data))\n    assert X not in banks\n    assert Y not in banks\n    assert X!= Y\n    assert max(banks) <= N\n    assert min(banks) > 0\n    transfer_x = sorted(data[:P], reverse=True)\n    transfer_y = sorted(data[P:], reverse=True)\n    transfer_x.insert(0, X)\n    transfer_y.insert(0, Y)\n    answer = transfer_y[-1] - transfer_x[-1]\n    if answer < 1:\n        return 'Impossible'\n    for i in range(len(transfer_x)):\n        answer = max(answer, transfer_y[i] - transfer_x[i])\n    return str(answer)"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x, y, *a = (int(i) for i in stdin.split())\n    p = [[int(i) for i in i.split()] for i in p]\n    a = list(a)\n\n    t = 0\n    while a:\n        t += p[a.pop(0) - 1][0]\n        p.pop(0)\n        x = p[0][1]\n        y = p[0][2]\n        if x == y:\n            break\n    if t < n * p[0][0]:\n        return \"Infinity\"\n    return str(n * p[0][0] - t)"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x, y = map(int, stdin.split())\n    a = []\n    b = []\n    for i in range(p):\n        a.append(int(stdin.split()[2 * i]))\n        b.append(int(stdin.split()[2 * i + 1]))\n    money = 0\n    x_money = 0\n    y_money = 0\n    cnt_x = 0\n    cnt_y = 0\n    for i in range(n):\n        if i == x:\n            x_money += a[i]\n            cnt_x += 1\n        elif i == y:\n            y_money += b[i]\n            cnt_y += 1\n    for i in range(n):\n        if i!= x and cnt_x == 1:\n            if i == y:\n                y_money += b[i]\n            else:\n                money += a[i] * b[i]\n        elif i!= y and cnt_y == 1:\n            if i == x:\n                x_money += a[i]\n            else:\n                money += a[i] * b[i]\n        else:\n            if i == x:\n                x_money += a[i]\n            elif i == y:\n                y_money += b[i]\n            else:\n                money += a[i] * b[i]\n    if x_money == y_money:\n        if x_money == 0:\n            return 'Impossible'\n        else:\n            return 'Infinity'\n    else:\n        if x_money <= y_money:\n            return x_money - y_money\n        else:\n            return y_money - x_money\n\nprint(solution(input()))\n\nOutput:\n0\n-----"
    },
    {
        "number": 3301,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def form_components(p: list) -> list:\n        comp = [i for i in range(1, len(p) + 1)]\n        comp.append(0)\n        return comp\n\n    def generate_components(components: list) -> list:\n        comb = []\n        while len(components)!= 1:\n            comb.append(combinations(components, 2))\n        return comb\n\n    def is_valid_partner(p1: list, p2: list) -> bool:\n        if p1[0]!= p2[0] and p1[1]!= p2[1]:\n            return True\n        return False\n\n    def calculate_fee(p1: list, p2: list) -> int:\n        if p1[0]!= p2[0]:\n            return p1[1]\n        return p2[1]\n\n    def calculate_total_fee(comb: list, p: list) -> int:\n        total = 0\n        for c in comb:\n            x = p[c[0] - 1]\n            y = p[c[1] - 1]\n            total += calculate_fee(x, y)\n        return total\n\n    def calculate_partner_combinations(partner_p: list) -> list:\n        components = form_components(partner_p)\n        combinations = generate_components(components)\n        return combinations\n\n    def get_partner_p(partner_p: list) -> list:\n        for i in range(len(partner_p)):\n            if partner_p[i] == 0:\n                partner_p[i] = 1\n                return partner_p\n\n        partner_p = [i for i in range(1, len(partner_p) + 1)]\n        return partner_p\n\n    def get_partner_p_index(partner_p: list) -> list:\n        comp = form_components(partner_p)\n        partner_p_index = []\n        for i in range(len(partner_p)):\n            partner_p_index.append(comp.index(partner_p[i]))\n        return partner_p_index\n\n    def calculate_valid_partner(partner_p: list, partner_combinations: list) -> int:\n        valid_partner_index = []\n        for i in range(len(partner_combinations)):\n            for j in range(len(partner_combinations[i])):\n                if is_valid_partner(partner_combinations[i][j], partner_p):\n                    valid_partner_index.append(i)\n        return valid_partner_index\n\n    def calculate_total_fee_valid_partner(partner_p: list, partner_combinations: list) -> int:\n        total = 0\n        for i in range(len(partner_combinations)):\n            total += calculate_total_fee(partner_combinations[i], partner_p)\n        return total\n\n    def calculate_partner_p_index_valid_partner(partner_p: list, partner_combinations: list) -> int:\n        valid_partner_index = []\n        for i in range(len(partner_combinations)):\n            valid_partner_index.append(get_partner_p_index(partner_combinations[i]))\n        return valid_partner_index\n\n    def calculate_partner_p_index_valid_partner_without_zero(partner_p: list, partner_combinations: list) -> int:\n        valid_partner_index = []\n        for i in range(len(partner_combinations)):\n            for j in range(len(partner_combinations[i])):\n                if is_valid_partner(partner_combinations[i][j], partner_p):\n                    valid_partner_index.append(get_partner_p_index_without_zero(partner_combinations[i][j]))\n        return valid_partner_index\n\n    def get_partner_p_index_without_zero(partner_combinations: list, p: list) -> list:\n        partner_p = p\n        for i in range(len(partner_combinations)):\n            for j in range(len(partner_combinations[i])):\n                if is_valid_partner(partner_combinations[i][j], partner_p):\n                    partner_p[i] = partner_combinations[i][j][1]\n        return partner_p\n\n    partner_p = partner_p = list(map(int, stdin.split()))\n    # print(partner_p)\n    partner_p.append(0)\n    partner_combinations = calculate_partner_combinations(partner_p)\n    # print(partner_combinations)\n\n    partner_p = partner_p = list(map(int, stdin.split()))\n    # print(partner_p)\n    partner_p.append(0)\n    partner_comb"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    palette = {i for i in range(1, n + 1)}\n\n    if n == 1:\n        if p == 1:\n            return \"impossible\"\n        return \"1\"\n\n    for i in range(2**n):\n        # If any of the colors in palette differ by at least one bit, then this code is not a valid color code.\n        if any(d!= 0 for d in (bin(i).count(\"1\"), bin(i).count(\"0\"))):\n            continue\n        # If every other color in palette is different by at least one bit, then this color code is not a valid color code.\n        if any(d!= 0 for d in (bin(i + 1).count(\"1\"), bin(i + 1).count(\"0\"))):\n            continue\n\n        # If every other color in palette is different by exactly one bit, then this color code is a valid color code.\n        if bin(i + 1).count(\"1\") % 2 == 1:\n            continue\n\n        # If no colors in palette differ by exactly one bit, then this color code is not a valid color code.\n        if bin(i + 1).count(\"1\") == 0:\n            continue\n\n        palette_strings = (bin(i)[2:].zfill(n) + bin(i + 1)[2:].zfill(n))\n        if set(palette_strings).issubset(palette):\n            palette -= set(palette_strings)\n            if not palette:\n                return \"2^\" + str(n)\n            return \"0\" + \"\".join(palette_strings)\n\n    return \"impossible\"\n"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    palette = set(map(int, stdin.split()))\n\n    if len(palette) == 0:\n        print('impossible')\n        return\n\n    if n == 1:\n        print('impossible')\n        return\n\n    min_dist = n\n    min_code = ''\n    max_code = ''\n\n    for i in range(1, 1 << n):\n        code = bin(i)[2:]\n        if len(code) < n:\n            code = '0' * (n - len(code)) + code\n\n        if set(code) == palette:\n            dist = 0\n            for i in range(0, n):\n                if code[i] == '1':\n                    dist += 1\n\n            if dist < min_dist:\n                min_dist = dist\n                min_code = code\n        else:\n            dist = 0\n            for i in range(0, n):\n                if code[i] == '1':\n                    dist += 1\n\n            if dist == min_dist:\n                dist -= 1\n\n            if dist < min_dist:\n                min_dist = dist\n                min_code = code\n            else:\n                dist += 1\n\n            if dist < min_dist:\n                min_dist = dist\n                min_code = code\n\n    print(''.join(min_code))\n    return\n\n\nsolution(input())\n"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p = list(map(int, stdin.strip().split()))\n    palette = set()\n    for _ in range(p):\n        palette.add(int(input()))\n    \n    ans = []\n    for i in range(2**n):\n        binary = format(i, f'0{n}b')\n        if binary not in palette:\n            return 'impossible'\n        if all(binary[j]!= binary[j+1] for j in range(n-1)):\n            ans.append(binary)\n    return '\\n'.join(ans)\n\nstdin = \"\"\"\n4 1\n1\n\"\"\"\nstdout = \"\"\"\n1\n\"\"\"\n"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_consecutive(n1, n2, n3):\n        if n1 + 1 == n2 and n2 + 1 == n3:\n            return True\n        else:\n            return False\n\n    def get_palette(palette: list):\n        n = len(palette)\n        max_count = 0\n        palette_set = set()\n        for i in range(1, n+1):\n            if i not in palette_set:\n                palette_set.add(i)\n                count = 1\n                for j in range(1, n+1):\n                    if is_consecutive(i, j, j+1):\n                        count += 1\n                if count > max_count:\n                    max_count = count\n                    max_index = i\n        return max_index\n\n    def get_palette_map(palette: list):\n        n = len(palette)\n        palette_map = {}\n        for i in range(n):\n            palette_map[palette[i]] = i\n        return palette_map\n\n    def get_palette_map_for_color(palette_map: dict, color: int, palette: list):\n        for i in range(len(palette)-1):\n            if is_consecutive(palette[i], palette[i+1], color):\n                if palette[i+1] in palette_map and palette[i] in palette_map:\n                    if palette_map[palette[i]]!= palette_map[palette[i+1]]:\n                        palette = palette[:i+1] + palette[i+1:] + palette[i]\n                        palette.append(palette_map[palette[i]])\n                        palette.append(palette_map[palette[i]])\n                        palette = list(set(palette))\n                        palette.sort()\n                        break\n        return palette\n\n    n, p = map(int, stdin.split())\n    palette = list(map(int, stdin.split()))\n    palette_map = get_palette_map(palette)\n    palette_map_for_color = {}\n    for i in range(len(palette)):\n        palette_map_for_color[palette[i]] = i\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 0, palette)\n    palette_set = set(palette)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 1, palette)\n    palette_set_for_color = set(palette_set)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 2, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 3, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 4, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 5, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 6, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 7, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 8, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 9, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 10, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 11, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 12, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 13, palette)\n    palette_set_for_color = set(palette_set_for_color)\n    palette_map_for_color = get_palette_map_for_color(palette_map_for_color, 14, palette)\n    palette_set_for_color = set(palette_set"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    if n > 16:\n        return \"impossible\"\n    palette = list(map(int, stdin.split()))\n    palette.sort()\n    if n == 1:\n        print(palette[0])\n        return\n    for i in range(1, n):\n        if i - 1 in palette and i + 1 in palette:\n            palette[i] = 2\n        else:\n            palette[i] = 0\n    color_code = [i if i else palette[0] for i in palette]\n    for i in range(2 ** n):\n        if bin(i).count(\"1\") == n:\n            print(\"\".join([str(color_code[i - 2 ** (n - 1)]) for i in range(n)]))\n    return"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = set(map(int, input().split()))\n    p = set(map(int, input().split()))\n    if len(s)!= len(p):\n        return \"impossible\"\n    i = 0\n    result = \"\"\n    while i < 2 ** n:\n        res = \"\"\n        for j in range(n):\n            res += str((i >> j) & 1)\n        if res not in p:\n            i += 1\n            continue\n        x = []\n        for j in range(n):\n            if (i >> j) & 1:\n                x.append(res[j])\n        x.reverse()\n        result += \"\".join(x) + \" \"\n        i += 1\n    return result[:-1]"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p = (int(x) for x in stdin.split())\n    palette = {p}\n\n    for _ in range(n - 1):\n        palette = {s for s in palette if abs(s - p) <= 1}\n        if len(palette) == 0:\n            return \"impossible\"\n\n    palette = sorted(palette)\n    code = \"\"\n    for s in palette:\n        code += f\"{s:0{n}b}\"\n    return code"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    \n    if n == 0:\n        return \"impossible\"\n    \n    palette = set()\n    for i in range(n):\n        palette.add(int(input()))\n    \n    codes = list()\n    for i in range(2**n):\n        code = bin(i)[2:]\n        if len(code)!= n:\n            continue\n        for i in range(len(code)):\n            if code[i] == \"0\" and code[i] not in palette:\n                code = code[:i] + \"1\" + code[i+1:]\n        if code in palette:\n            continue\n        codes.append(code)\n    \n    if len(codes) == 0:\n        return \"impossible\"\n    \n    return '\\n'.join(codes)"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, p = map(int, stdin.split())\n    \n    palette = list(map(int, stdin.split()))\n    palette_dict = {}\n    for i in range(n):\n        palette_dict[palette[i]] = i\n    \n    code = ['impossible'] * 2**n\n    for i in range(len(palette)):\n        if palette[i] in palette_dict:\n            start = 2**(n-1) + palette_dict[palette[i]]\n            end = 2**(n-1) + palette_dict[palette[i]] + 1\n            code[start] = '0'\n            code[end] = '1'\n    for i in range(2**n):\n        if code[i] == '0':\n            code[i] = '0'\n        elif code[i] == '1':\n            code[i] = '1'\n    return ''.join(code)"
    },
    {
        "number": 3302,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    P = list(map(int, stdin.split()))\n    palette = []\n    for i in range(2**n):\n        c = []\n        for j in range(n):\n            c.append(i & (1 << j))\n        if sum(c) in P:\n            palette.append(c)\n    if len(palette) == 0:\n        return \"impossible\"\n    palette.sort(key=lambda x: x.count(1))\n    return str(bin(palette[0][0])[2:])"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # def no_carry(s1, s2):\n    #     if not s1 and not s2:\n    #         return True\n    #     if not s1 or not s2:\n    #         return False\n    #     return s1[-1] == s2[-1] and no_carry(s1[:-1], s2[:-1])\n\n    def no_carry(s1, s2):\n        if not s1 and not s2:\n            return True\n        if not s1 or not s2:\n            return False\n        return s1[-1] == s2[-1] and no_carry(s1[:-1], s2[:-1])\n\n    def add(s1, s2):\n        if not s1:\n            return s2\n        if not s2:\n            return s1\n        if s1[-1] == s2[-1]:\n            return add(s1[:-1], s2[:-1])\n        if s1[-1] == '1':\n            return s1[:-1] + '0' + add(s1[:-1], s2[:-1])\n        if s2[-1] == '1':\n            return add(s1, s2[:-1]) + '0'\n        return add(s1, s2[:-1]) + '1'\n\n    return no_carry(stdin[0], stdin[1]) + str(len(add(stdin[0], stdin[1]))) + '0'"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.splitlines()\n    a, b = int(a), int(b)\n    steps = 0\n    while not (a == 0 and b == 0):\n        a = (a + 1) if a < 9 else (a % 10 + a // 10)\n        b = (b + 1) if b < 9 else (b % 10 + b // 10)\n        steps += 1\n    return str(steps)"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    numbers = stdin.split('\\n')\n    num_1 = int(numbers[0])\n    num_2 = int(numbers[1])\n    n = 2\n    while n <= min(num_1, num_2):\n        if (num_1 % 10 + num_2 % 10 + n) % 10!= 0 and (num_1 % 10 + num_2 % 10 + n) % 10!= 0:\n            return str(n)\n        n += 1\n    return str(n)\n"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = stdin.split('\\n')\n    num1 = int(num1)\n    num2 = int(num2)\n    count = 0\n    num1 = num1\n    num2 = num2\n    while num1 and num2:\n        count += 1\n        num1 = int(str(num1)[::-1])\n        num2 = int(str(num2)[::-1])\n        num1 = num1\n        num2 = num2\n    return str(count)\n    \nprint(solution(input()))\n"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = stdin.split()\n    total = int(num1) + int(num2)\n    count = 0\n    while total!= 0:\n        total = total - 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return \"0\"\n    if N == 1:\n        return \"1\"\n    a, b = divmod(N, 10)\n    c = 1 if a == 0 else 0\n    d = 1 if b == 0 else 0\n    e = a + 1\n    f = b + 1\n    g = 1\n    h = 0\n    i = 1\n    while i <= b:\n        j = N - e + i\n        l = N - f + i\n        m = N - g + i\n        n = N - h + i\n        o = N - i + i\n        p = N - o + i\n        q = N - p + i\n        r = N - q + i\n        if j < 10:\n            c = j\n        else:\n            c = 1\n        if l < 10:\n            d = l\n        else:\n            d = 1\n        if m < 10:\n            e = m\n        else:\n            e = 1\n        if n < 10:\n            f = n\n        else:\n            f = 1\n        if o < 10:\n            g = o\n        else:\n            g = 1\n        if p < 10:\n            h = p\n        else:\n            h = 1\n        if q < 10:\n            i = q\n        else:\n            i = 1\n    if e == 0:\n        return str(g - 1)\n    elif f == 0:\n        return str(g - 1) + str(e - 1)\n    elif d == 0:\n        return str(h - 1) + str(e - 1)\n    elif c == 0:\n        return str(h - 1) + str(f - 1) + str(g - 1)\n    elif c == 1 and d == 0 and e == 0:\n        return str(h - 1) + str(f - 1) + str(g - 1) + str(i - 1)\n    elif d == 1 and e == 0 and f == 0:\n        return str(c - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and f == 0 and g == 0:\n        return str(c - 1) + str(d - 1) + str(i - 1)\n    elif c == 1 and d == 1 and e == 0:\n        return str(h - 1) + str(i - 1)\n    elif d == 1 and e == 1 and f == 0:\n        return str(c - 1) + str(g - 1) + str(i - 1)\n    elif e == 1 and f == 1 and g == 0:\n        return str(c - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and d == 1 and f == 1:\n        return str(c - 1) + str(g - 1) + str(h - 1) + str(i - 1)\n    elif c == 1 and d == 1 and e == 1:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif c == 1 and e == 1 and f == 1:\n        return str(g - 1) + str(i - 1)\n    elif c == 1 and d == 1 and g == 1:\n        return str(h - 1) + str(i - 1)\n    elif e == 1 and f == 1 and g == 1:\n        return str(i - 1)\n    elif e == 0 and d == 0 and g == 0:\n        return str(i - 1)\n    elif e == 0 and d == 0 and f == 1:\n        return str(g - 1) + str(i - 1)\n    elif e == 0 and d == 1 and f == 0:\n        return str(i - 1)\n    elif e == 1 and d == 0 and f == 0:\n        return str(g - 1) + str(i - 1)\n    elif e == 1 and d == 1 and f == 0:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and d == 1 and f == 1:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and d == 0 and f == 1:\n        return str(i - 1)\n    elif e == 1 and d == 1 and f == 0:\n        return str(g - 1) + str(i - 1)\n    elif e == 1 and d == 1 and f == 1:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 0 and g == 0:\n        return str(i - 1)\n    elif e == 0 and g == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 1 and g == 0:\n        return str(i - 1)\n    elif e == 1 and g == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 0 and d == 0:\n        return str(h - 1) + str(i - 1)\n    elif e == 0 and d == 1:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and d == 0:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 1 and d == 1:\n        return str(g - 1) + str(h - 1) + str(i - 1)\n    elif e == 0 and f == 0:\n        return str(i - 1)\n    elif e == 0 and f == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 1 and f == 0:\n        return str(i - 1)\n    elif e == 1 and f == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 0 and g == 0:\n        return str(i - 1)\n    elif e == 0 and g == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 1 and g == 0:\n        return str(i - 1)\n    elif e == 1 and g == 1:\n        return str(i - 1) + str(h - 1)\n    elif e == 0 and d == 0 and f == 0:\n        return str(i - 1)\n    elif e == 0 and d == 0 and f == 1:\n        return str(g - 1) + str(i - 1)\n    elif e == 0 and d == 1 and f == 0"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n1, n2 = int(stdin), int(stdin)\n    # 1+10+100+1000+10000+...+9*10^i\n    # ...+9*10^i, i=1,2,...,k\n    n = 1\n    # add carry, see if we can stop\n    while n2!= 0:\n        n += 1\n        n2 -= 10**n\n        n2 %= 10\n    return n\nprint(solution(input()))"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    int1, int2 = map(int, stdin.split())\n    count = 0\n    while int1!= int2:\n        if int1 == 0:\n            int1 = 1\n            count += 1\n        elif int2 == 0:\n            int2 = 1\n            count += 1\n        int1 += 1\n        int2 -= 1\n    return str(count)\n"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A = stdin.split()\n    i = int(A[0])\n    j = int(A[1])\n    if (i + j) == 0:\n        print(0)\n    else:\n        if (i + j) > 9:\n            count = 1\n            while (i + j) > 9:\n                j = j - 10\n                count += 1\n        else:\n            count = 0\n        if (i + j) > 9:\n            count += 1\n        if (j + i) > 9:\n            count += 1\n        print(count)\n    return \"\"\n"
    },
    {
        "number": 3303,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    x = int(stdin)\n    d1 = x\n    d2 = x\n    s = 0\n    while d1 and d2:\n        d1, d2 = d1//10, d2%10\n        s += d1+d2\n    while d1:\n        d1, d2 = d1//10, 1\n        s += d1+d2\n    return str(s)\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *p, *v = list(map(int, stdin.split()))\n    a.sort()\n    p.sort()\n    v.sort()\n    a.append(a[0])\n    v.append(v[0])\n    a.append(a[-1])\n    v.append(v[-1])\n    ans = 0\n    while len(a)!= 0 and len(v)!= 0:\n        if a[0] == v[-1]:\n            ans += 1\n            a.pop(0)\n            v.pop()\n        else:\n            a.pop(0)\n            v.pop()\n    return str(ans)\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    elf_adversaries, dwarf_strengths, elf_strengths = stdin.split()\n    elf_adversaries = list(map(int, elf_adversaries.split()))\n    dwarf_strengths = list(map(int, dwarf_strengths.split()))\n    elf_strengths = list(map(int, elf_strengths.split()))\n\n    elf_strengths = sorted(elf_strengths)\n    dwarf_strengths = sorted(dwarf_strengths)\n\n    elf_adversaries = sorted(elf_adversaries, reverse=True)\n\n    elf_adversaries_id = {elf_adversaries[i]: i for i in range(len(elf_adversaries))}\n    dwarf_adversaries_id = {dwarf_strengths[i]: i for i in range(len(dwarf_strengths))}\n    elf_strengths_id = {elf_strengths[i]: i for i in range(len(elf_strengths))}\n\n    elf_pairs_id = {}\n    elf_counter = 0\n    dwarf_pairs_id = {}\n    dwarf_counter = 0\n\n    for dwarf_adversary in dwarf_adversaries_id.keys():\n        if dwarf_adversary not in dwarf_pairs_id:\n            dwarf_pairs_id[dwarf_adversary] = dwarf_counter\n            dwarf_counter += 1\n\n    for elf_adversary in elf_adversaries_id.keys():\n        if elf_adversary not in elf_pairs_id:\n            elf_pairs_id[elf_adversary] = elf_counter\n            elf_counter += 1\n\n    dwarf_wins = 0\n    elf_wins = 0\n\n    for elf_strength in elf_strengths_id.keys():\n        dwarf_strength = dwarf_strengths[elf_pairs_id[elf_strength]]\n        dwarf_strength_id = dwarf_strengths_id[dwarf_strength]\n        dwarf_counter = dwarf_pairs_id[dwarf_strength_id]\n        elf_counter = elf_pairs_id[elf_strength]\n        elf_dwarf_strength = elf_strengths[elf_counter]\n\n        while elf_dwarf_strength > dwarf_strength:\n            dwarf_strength = dwarf_strengths[elf_pairs_id[elf_dwarf_strength]]\n            dwarf_strength_id = dwarf_strengths_id[dwarf_strength]\n            dwarf_counter = dwarf_pairs_id[dwarf_strength_id]\n            elf_counter = elf_pairs_id[elf_dwarf_strength]\n            elf_dwarf_strength = elf_strengths[elf_counter]\n        dwarf_wins += 1\n\n    for dwarf_strength in dwarf_strengths_id.keys():\n        elf_strength = elf_strengths[elf_pairs_id[dwarf_strength]]\n        elf_strength_id = elf_strengths_id[elf_strength]\n        elf_counter = elf_pairs_id[elf_strength_id]\n        dwarf_counter = dwarf_pairs_id[dwarf_strength]\n        elf_dwarf_strength = elf_strengths[elf_counter]\n\n        while elf_dwarf_strength > dwarf_strength:\n            elf_strength = elf_strengths[elf_pairs_id[elf_dwarf_strength]]\n            elf_strength_id = elf_strengths_id[elf_strength]\n            elf_counter = elf_pairs_id[elf_strength_id]\n            dwarf_counter = dwarf_pairs_id[dwarf_strength]\n            elf_dwarf_strength = elf_strengths[elf_counter]\n        elf_wins += 1\n\n    return str(dwarf_wins)\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N = int(stdin[0])\n    adversaries = list(map(int, stdin[1].split()))\n    dwarves = list(map(int, stdin[2].split()))\n    dwarves.sort(reverse=True)\n    n = len(adversaries)\n    adversaries.sort(reverse=True)\n    adversaries = [i - 1 for i in adversaries]\n    alice = [0] * n\n    alice[0] = dwarves[0]\n    for i in range(1, n):\n        alice[i] = min(dwarves[i], alice[i - 1])\n    alice.sort()\n    alice = list(map(str, alice))\n    alice = \" \".join(alice)\n    slavko = [\"*\" for i in range(N)]\n    for i in range(1, N + 1):\n        for j in range(i):\n            if alice[j] >= adversaries[i - 1]:\n                slavko[i - 1] = j + 1\n                break\n    return alice, slavko\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read in the data\n    n: int = int(stdin.readline())\n    a: List[int] = list(map(int, stdin.readline().strip().split()))\n    p: List[int] = list(map(int, stdin.readline().strip().split()))\n    v: List[int] = list(map(int, stdin.readline().strip().split()))\n\n    # Solve\n    if len(a) < len(v):\n        print(len(a))\n        return\n    if len(p) < len(v):\n        print(len(p))\n        return\n\n    max_victory = 0\n    for elf_pos in range(len(a)):\n        victory = 0\n        elf_victory = 0\n        # Walk the list of p, and for each elf, get the victory of his friend\n        for dwarf_pos in range(len(v)):\n            # If we are at the beginning of the list, we can't fight!\n            if elf_pos == 0:\n                victory = 0\n            else:\n                # The Elf/Dwarf they should fight against is the next elf on the list\n                if dwarf_pos == elf_pos - 1:\n                    victory = v[dwarf_pos]\n                # The Elf/Dwarf they should fight against is the next elf on the list\n                else:\n                    # If there is no elf next to them, they can fight against the next elf\n                    if dwarf_pos == elf_pos + 1:\n                        victory = v[dwarf_pos]\n                    # Otherwise, they fight against their friend\n                    else:\n                        victory = max(v[dwarf_pos], v[dwarf_pos - 1])\n            # If there is no elf next to them, they can fight against the next elf\n            if elf_pos == elf_pos + 1:\n                victory = v[elf_pos]\n            # Otherwise, they fight against their friend\n            else:\n                victory = max(v[elf_pos], v[elf_pos - 1])\n            elf_victory += victory\n        max_victory = max(max_victory, elf_victory)\n    print(max_victory)\n    return\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Takes input and passes to functions for calculation. Returns solution.\"\"\"\n    def fight(elf_i, elf_j, dwarf_i, dwarf_j):\n        \"\"\"Takes 2 inputs and returns the number of wins.\"\"\"\n        if elf_j > dwarf_i:\n            return (dwarf_j - elf_i)\n        else:\n            return (elf_j - dwarf_i)\n    return max(\n        [\n            solve(1, 2, elf_i, elf_j, dwarf_i, dwarf_j)\n            for elf_i, elf_j, dwarf_i, dwarf_j in zip(\n                stdin.split()[1::2], stdin.split()[2::2], stdin.split()[3::2], stdin.split()[4::2])\n        ]\n    )\n\n\ndef"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return str(max([int(x) for x in stdin.split()]))\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    t, n = stdin.strip().split()\n    n = int(n)\n    a = list(map(int, stdin.strip().split()[1:]))\n    p = list(map(int, stdin.strip().split()[1:]))\n    v = list(map(int, stdin.strip().split()[1:]))\n    w = max(p)\n    l = len(p)\n    if l!= n:\n        return \"INPUT ERROR\"\n    elif w!= max(v):\n        return \"INPUT ERROR\"\n    else:\n        i = j = 0\n        while i < l:\n            if p[i] > v[j]:\n                j += 1\n            i += 1\n        return str(j)\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    for i in range(int(stdin)):\n        N, A, P, V, E = stdin.split()\n        N, A, P, V, E = int(N), sorted(map(int, A.split()), reverse=True), sorted(map(int, P.split()), reverse=True), sorted(map(int, V.split()), reverse=True), int(E)\n        if N == len(P):\n            print(len(P) // 2)\n        else:\n            print(N // 2)\n    return 'OK'"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    [N, *A] = list(map(int, stdin.split()))\n    [P, *S] = list(map(int, stdin.split()))\n    [V, *E] = list(map(int, stdin.split()))\n\n    result = 0\n    while N > 0:\n        index = A.index(min(A))\n        A.remove(min(A))\n        if index!= N - 1:\n            N -= 1\n            A.append(N)\n        else:\n            result += 1\n            A.remove(N)\n            N -= 1\n    return str(result)\n"
    },
    {
        "number": 3304,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, N, A, P, V, E = stdin.split()\n    N = int(N)\n    A = list(map(int, A.split()))\n    P = list(map(int, P.split()))\n    V = list(map(int, V.split()))\n    E = list(map(int, E.split()))\n    win = 0\n    for i in range(N):\n        if i == 0:\n            win = sum([P[i], V[i]])\n        else:\n            if win > sum([P[i], V[i]]):\n                win = sum([P[i], V[i]])\n    return str(win)"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # See https://stackoverflow.com/a/17684962/13183085\n    stdin = stdin.splitlines()\n    inputs = [[i.split() for i in stdin]]\n    inputs = [list(map(int, i)) for i in inputs]\n    inputs = [(i, j) for i, j in inputs]\n    inputs.sort()\n    inputs = [[i, j] for i, j in inputs]\n    return \"\".join([\"\".join(i) for i in inputs])\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.rstrip()\n    n = int(stdin.split()[0])\n    q = int(stdin.split()[1])\n    s = stdin.split()[2]\n    l = []\n    r = []\n    for i in range(q):\n        l.append(stdin.split()[3*i+1])\n        r.append(stdin.split()[3*i+2])\n    s = list(s)\n    for i in range(q):\n        for j in range(len(l[i])):\n            for k in range(len(r[i])):\n                s[j] = s[j].replace(l[i][j],r[i][k])\n    print(''.join(s))\n    return s\n\nsolution(input())\n\n\"\"\"\ndef"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N, Q = (int(x) for x in lines[0].split())\n    strs = lines[1:]\n    s = strs[0]\n    for i in range(1, len(strs)):\n        strs[i] = strs[i].split()\n        s = s.replace(*strs[i])\n    return s\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    strings = stdin.split()\n    ans = []\n    for i in range(Q):\n        L, R = map(int, stdin.split())\n        substring = strings[L - 1:R]\n        substring = \"\".join(substring)\n        if is_palindrome(substring):\n            ans.append(len(substring))\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(string):\n        if string == string[::-1]:\n            return True\n        return False\n    string = stdin.strip().lower()\n    string_len = len(string)\n    demos = int(stdin.strip().split()[1])\n    ans = 0\n    for i in range(demos):\n        string_start = int(stdin.strip().split()[2 + i * 2])\n        string_end = int(stdin.strip().split()[3 + i * 2])\n        string_substring = string[string_start:string_end]\n        if is_palindrome(string_substring):\n            ans += 1\n    return str(ans)\n\nstring = input()\nresult = solution(string)\nprint(result)"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.strip().split())\n    s = stdin[0]\n    i = 0\n    while i < n:\n        start, end = map(int, stdin.strip().split())\n        i += 1\n        if i < n:\n            s = s[:start - 1] + s[end - 1] + s[start - 1] + s[end:]\n    return len(s)\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    s = input()\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        if s[l-1] == s[r-1]:\n            continue\n        p = 0\n        while p < n and s[p] == s[p - 1]:\n            p += 1\n        print(p)\n    return stdin\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\"\nNo, this is a very generic test case. Please provide a more specific test case.\"\"\"\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    S = stdin\n    res = []\n    for i in range(Q):\n        L, R = map(int, stdin.split())\n        if L > R:\n            L, R = R, L\n        tmp = \"\"\n        for j in range(L - 1, R):\n            if S[j]!= S[R - 1]:\n                tmp += S[j] + S[R - 1]\n                if len(tmp) > N - 1:\n                    res.append(len(tmp))\n                    tmp = \"\"\n        if len(tmp) > 0:\n            res.append(len(tmp))\n        print(len(res))\n    return \"\"\n"
    },
    {
        "number": 3305,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.splitlines()\n    n, q = map(int, input[0].split())\n    s = input[1]\n    ans = 0\n    for _ in range(q):\n        l, r = map(int, input[2].split())\n        l -= 1\n        r -= 1\n        d = {}\n        for i in range(l, r + 1):\n            if s[i] in d:\n                d[s[i]] += 1\n            else:\n                d[s[i]] = 1\n        for i in range(l, r + 1):\n            if s[i] in d and d[s[i]] > 0:\n                ans += 1\n                d[s[i]] -= 1\n        print(ans)\n    return s\nsolution(\"\"\"5 2\n5 5\n3 3\n1 2\n8 5\n1 9\"\"\")\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\""
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    houses, calls = [], []\n    for _ in range(N):\n        houses.append(int(stdin.split()[_]))\n    for _ in range(N - 1):\n        calls.append(int(stdin.split()[N + _]))\n    return str(min([h for h in houses if calls.count(h) > 1]))"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split()))\n    assert 1 <= N <= 100000\n    assert 1 <= M <= 1000000000\n    d = [[] for _ in range(M)]\n    for i in range(N):\n        h = list(map(int, stdin.split()))\n        assert 1 <= h[0] <= M\n        assert 1 <= h[1] <= 1000000000\n        d[h[0] - 1].append(h[1])\n    count = 0\n    for i in range(N):\n        d[i].sort()\n        count += d[i][0] - 1\n        for j in range(1, len(d[i])):\n            count += d[i][j] - d[i][j - 1] - 1\n    return str(count)\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    calls = sorted(list(map(int, stdin.split())))\n    calls = sorted(calls)\n    min_calls = float(\"inf\")\n    for i in range(len(calls) - 1):\n        if calls[i] + 1 == calls[i + 1]:\n            min_calls = min(min_calls, calls[i] + calls[i + 1])\n    return str(min_calls)\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    \n    res = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            res = min(res, (j - i) * M)\n    \n    return str(res)\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    street = []\n    calls = []\n    for _ in range(N):\n        street.append(list(map(int, stdin.split())))\n        calls.append([int(x) for x in stdin.split()])\n    min_calls = float('inf')\n    for i in range(N):\n        for j in range(N):\n            if i!= j:\n                start = street[i][0]\n                end = street[j][-1]\n                cnt = 0\n                for call in calls:\n                    if start <= call[1] < end:\n                        cnt += 1\n                if cnt < min_calls:\n                    min_calls = cnt\n    return str(min_calls)"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    phone_calls = [[int(x) for x in stdin.split()] for _ in range(n)]\n\n    answer = 0\n    for call in phone_calls:\n        p_end = call[0]\n        c_start = call[1]\n        p_start = call[2]\n        for i in range(p_start + 1, p_end):\n            c_end = call[3]\n            if c_end > c_start:\n                answer += 1\n                break\n    return answer\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    detectors = dict()\n    for i in range(n):\n        p, c = map(int, stdin.split())\n        detectors[p] = c\n    ans = 0\n    for i in range(n, m):\n        start = i\n        end = i\n        for j in range(start, end):\n            if detectors[j] == 0:\n                ans += 1\n                detectors[j] = 1\n                break\n        for j in range(start, end):\n            if detectors[j] == 1:\n                detectors[j] = 0\n                end -= 1\n        if detectors[start] == 1:\n            detectors[start] = 0\n    return str(ans)\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3306,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 4\n   ... 3 1\n   ... 2 2\n   ... 1 1\n   ... ''')\n    '23'\n    >>> solution('''2 3\n   ... 1 23\n   ... 2 17\n   ... ''')\n    '23'\n    >>> solution('''1 2\n   ... 3 2\n   ... 4 3\n   ... 5 4\n   ... 6 5\n   ... 7 6\n   ... 8 7\n   ... 9 8\n   ... 10 9\n   ... 11 10\n   ... 12 11\n   ... 13 12\n   ... 14 13\n   ... 15 14\n   ... 16 15\n   ... 17 16\n   ... 18 17\n   ... 19 18\n   ... 20 19\n   ... 21 20\n   ... 22 21\n   ... 23 22\n   ... ''')\n    '23'\n    \"\"\"\n    house_numbers = []\n    num_calls = []\n    for line in stdin.splitlines():\n        house_numbers.append(int(line.split()[0]))\n        num_calls.append(int(line.split()[1]))\n\n    house_numbers.sort()\n    num_calls.sort()\n\n    diff_house_numbers = set(house_numbers)\n    diff_calls = set(num_calls)\n    answer = 0\n    current_house = 1\n    for house_number in house_numbers:\n        for call in num_calls:\n            if current_house + 1 == house_number:\n                break\n            if current_house + 1 == house_number + 1:\n                continue\n            if call > current_house + 1:\n                break\n            answer += call - current_house\n            current_house += 1\n    return str(answer)\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Your code goes here\n    for i in range(n):\n        x1, y1 = map(int, input().split())\n        x2, y2 = map(int, input().split())\n        x3, y3 = map(int, input().split())\n        x4, y4 = map(int, input().split())\n        x_a = max(x1, x2, x3, x4)\n        y_a = max(y1, y2, y3, y4)\n        x_b = min(x1, x2, x3, x4)\n        y_b = min(y1, y2, y3, y4)\n        distance = ((x_a - x_b) ** 2 + (y_a - y_b) ** 2) ** 0.5\n        area = (x_b - x_a) * (y_b - y_a)\n        print(area / distance)\n    return stdout\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    points = [(int(i), int(i)) for i in stdin.split()]\n    points = sorted(points)\n    a, b = points[0], points[-1]\n    if points[-1][0] == points[0][0]:\n        return 0.0\n    return (a[1] - b[1]) / (a[0] - b[0])\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    vertices = list()\n    for i in range(N):\n        x, y = map(int, stdin.strip().split())\n        vertices.append((x, y))\n\n    def coords(i1, i2):\n        \"\"\"Return the coordinates of the line through i1 and i2.\"\"\"\n        return i1[0] * i2[1] - i1[1] * i2[0], i2[0] * i1[1] - i2[1] * i1[0]\n\n    def collinear(i1, i2, i3):\n        \"\"\"Return True if the line passing through i1, i2 and i3 is collinear.\"\"\"\n        if i2[0] - i1[0] == 0:\n            return True  # The line is vertical.\n        return abs(\n            coords(i1, i2)\n        ) <= 10 ** -6 and abs(coords(i1, i3)) <= 10 ** -6\n\n    def polygon(i1, i2, i3, i4):\n        \"\"\"Return True if a polygon with vertices i1, i2, i3 and i4 is collinear.\"\"\"\n        if i3 == i2:\n            return collinear(i1, i2, i3)\n        if i4 == i2:\n            return collinear(i1, i3, i4)\n        if i4 == i3:\n            return collinear(i1, i2, i4)\n        return collinear(i1, i2, i3) and collinear(i1, i3, i4) and collinear(i2, i3, i4)\n\n    i1 = vertices[0]\n    for i2 in vertices[1:]:\n        if polygon(i1, i2, vertices[0], vertices[-1]):\n            return \"%.8f\" % abs(i1[0] - i2[0])\n\n    return \"%.8f\" % abs(vertices[0][0] - vertices[-1][0])\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inp = list(map(lambda x: tuple(map(int, x.split())), stdin.split(\"\\n\")))\n    interval = []\n    for i in range(1, len(inp) - 1):\n        interval.append((inp[i - 1][0], inp[i][1]))\n        interval.append((inp[i][0], inp[i + 1][1]))\n    x = int(interval[0][0])\n    y = int(interval[0][1])\n    for i in range(1, len(interval)):\n        x = min(x, interval[i][0])\n        y = max(y, interval[i][1])\n    return f\"{x} {y}\""
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x1, y1, x2, y2, x3, y3, x4, y4 = (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0), (0,0)\n    points = list()\n    for i in range(n):\n        x1, y1 = map(float, stdin.split())\n        points.append((x1,y1))\n    points = sorted(points, key=lambda p:p[0])\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    x4, y4 = points[3]\n    return str(abs((x4-x1) * (y2-y1) - (x2-x1) * (y4-y1)))\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    N = int(stdin.split()[0])\n    xs = []\n    ys = []\n    for i in range(N):\n        xs.append(int(stdin.split()[i * 2 + 1]))\n        ys.append(int(stdin.split()[i * 2 + 2]))\n\n    xs = sorted(xs)\n    ys = sorted(ys)\n\n    d = 0\n    cnt = 0\n    for i in range(N):\n        d = max(xs[i], ys[i]) - min(xs[i], ys[i])\n        cnt += d\n    return str(cnt)\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.splitlines()\n    x,y = 0,0\n    a,b = 0,0\n    for i in data:\n        x,y = map(int,i.split())\n        a,b = map(int,data[i+1].split())\n    return str(abs(a-b)/max(1,b))"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    polygons = []\n    for i in range(int(stdin.split()[0])):\n        polygons.append([int(x) for x in stdin.split()[i*2+1].split(',')])\n    corners = [(-1000, -1000), (-1000, 1000), (1000, -1000), (1000, 1000)]\n    canal = [(x, y) for x, y in corners]\n    for x, y in polygons:\n        for i in range(len(canal)-1):\n            if (canal[i][1] < y and canal[i+1][1] >= y) or (canal[i][1] >= y and canal[i+1][1] < y):\n                if (canal[i][0] < x and canal[i+1][0] >= x) or (canal[i][0] >= x and canal[i+1][0] < x):\n                    canal = canal[:i] + [(x, y)] + canal[i+1:]\n                    break\n    max_area = 0\n    for i in range(len(canal)):\n        area = abs(canal[i][0] * (canal[i][1] - canal[i-1][1]) - canal[i-1][0] * (canal[i][1] - canal[i-1][1]))\n        if area > max_area:\n            max_area = area\n    return str(max_area)"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    vertices = sorted([tuple(map(int, stdin[i].split())) for i in range(1, len(stdin))], key=lambda v: v[0])\n    return '{:.6f}'.format(max([(v[0] - v[1]) for v in zip(vertices[:-1], vertices[1:])]))\n"
    },
    {
        "number": 3307,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return \"{:.6f}\".format(\n        max(\n            (\n                # try to find all possible polygon pieces\n                # (x, y) and check\n                # (x1, y1), (x2, y2),..., (xn, yn)\n                max(x for x, y in enumerate(stdin, 1) if y == \"0\"),\n                max(x for x, y in enumerate(stdin, 1) if y == \"2\"),\n                max(x for x, y in enumerate(stdin, 1) if y == \"0\"),\n                max(x for x, y in enumerate(stdin, 1) if y == \"2\"),\n            ),\n            # add extra points to ensure that the polygon is a square\n            (\n                min(x for x, y in enumerate(stdin, 1) if y == \"0\"),\n                min(x for x, y in enumerate(stdin, 1) if y == \"2\"),\n            ),\n            # try to find the longest edge\n            max(\n                ((x1, y1), (x2, y2))\n                for x1, y1 in enumerate(stdin, 1)\n                if y1 == \"0\"\n                for x2, y2 in enumerate(reversed(stdin), 1)\n                if y2 == \"2\"\n            ),\n        )\n    )\n\n\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vertices = []\n    for i in range(n):\n        vertices.append([float(x) for x in stdin.split()[i * 2 + 1:i * 2 + 3]])\n    return str(area_of_polygon(vertices))\n\ndef"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    verts = []\n    for _ in range(n):\n        x, y = stdin.split()\n        x, y = float(x), float(y)\n        verts.append((x, y))\n\n    verts.sort(key=lambda x: x[1])\n    verts.sort(key=lambda x: x[0])\n    ans = 0\n    for i in range(1, n):\n        a, b = verts[i - 1], verts[i]\n        l = (a[0] - b[0], a[1] - b[1])\n        l = (l[0] / (a[0] - b[0]), l[1] / (a[1] - b[1]))\n        a, b = l\n        if a >= 0 and b >= 0 and a + b > 0:\n            ans += a + b\n    return str(ans)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    count = int(stdin.split(\"\\n\")[0])\n    return sum([sum([int(i) for i in j.split(\" \")]) for j in stdin.split(\"\\n\")[1:]])/count"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin.pop(0))\n    for _ in range(n):\n        x, y = stdin.pop(0).split()\n        x, y = float(x), float(y)\n        if x == 0 and y == 0:\n            continue\n        stdin.append(f\"{x/y}\")\n    stdin.pop(0)\n    return '\\n'.join(stdin)\n\nprint(solution(stdin))\n\ndef"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    vertices = []\n    for i in range(1, n + 1):\n        vertices.append([float(x) for x in inputs[i].split()])\n\n    triangles = []\n    for i in range(0, n):\n        for j in range(i + 1, n):\n            triangles.append([i, j])\n            triangles.append([j, i])\n\n    triangles.sort()\n\n    area = 0.0\n    for i in range(len(triangles)):\n        for j in range(i + 1, len(triangles)):\n            if (\n                vertices[triangles[i][0]]\n               != vertices[triangles[i][1]]\n                and vertices[triangles[j][0]]\n               != vertices[triangles[j][1]]\n            ):\n                area += abs(\n                    ((vertices[triangles[i][0]] + vertices[triangles[j][0]]) / 2.0)\n                    * (vertices[triangles[i][1]] - vertices[triangles[j][1]])\n                )\n\n    return f\"{area:.4f}\"\n"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = [[int(x) for x in stdin.split()][i] for i in range(n)]\n    points = sorted(points, key=lambda x: x[0])\n    points = sorted(points, key=lambda x: x[1])\n    def dist(x1, y1, x2, y2):\n        return (x1 - x2)**2 + (y1 - y2)**2\n    def cross(x1, y1, x2, y2, x3, y3, x4, y4):\n        return (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4)\n    def angle(x1, y1, x2, y2, x3, y3):\n        a = dist(x1,y1,x2,y2)\n        b = dist(x2,y2,x3,y3)\n        c = dist(x3,y3,x1,y1)\n        if a+b <= c:\n            return math.atan2((y3-y2),(x3-x2))\n        return math.atan2((y1-y3),(x1-x3))\n    points = sorted(points, key=lambda x: x[0])\n    points = sorted(points, key=lambda x: x[1])\n    ans = 0\n    for i in range(n-1):\n        a = angle(points[i][0], points[i][1], points[i+1][0], points[i+1][1], points[i+2][0], points[i+2][1])\n        ans += a\n    return str(round(ans, 4))"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    vertices = []\n    for i in range(n):\n        x, y = map(float, stdin.split())\n        vertices.append([x, y])\n    vertices.sort()\n    count = 0\n    for i in range(len(vertices) - 1):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[i + 1]\n        count += max(abs(x1 - x2), abs(y1 - y2))\n    return f'{count:.4f}'"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    vertices: List[Tuple[float, float]] = []\n    for _ in range(N):\n        x, y = list(map(float, stdin.split()))\n        vertices.append((x, y))\n    vertices.sort(key=lambda x: (x[0], x[1]))\n    area: float = 0\n    for i in range(N):\n        x_0, y_0 = vertices[i]\n        x_1, y_1 = vertices[i + 1] if i + 1 < N else vertices[0]\n        area += (x_0 * y_1 - x_1 * y_0)\n    return str(area)\n"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    xs, ys = zip(*[map(float, re.findall(r\"-*\\d+\\.\\d+\", line)) for line in stdin.split(\"\\n\")])\n    xs = sorted(list(set(xs)))\n    ys = sorted(list(set(ys)))\n    points = set()\n    for y in ys:\n        for x in xs:\n            points.add((x, y))\n    areas = []\n    for p1, p2 in zip(points, points[1:]):\n        x1, y1 = p1\n        x2, y2 = p2\n        areas.append((x2 - x1) * (y1 + y2) / 2)\n    area = sum(areas)\n    return '%.5f' % area\nprint(solution('''\n5\n0.1 0\n-0.1 0\n0 0.1\n0 0.2\n0 -0.2\n'''))"
    },
    {
        "number": 3308,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(n):\n        points.append(stdin.split()[i + 1])\n    # points = [[int(x), int(y)] for x, y in stdin.split()]\n    points = [(x, y) for x, y in points]\n    area = 0\n    for i in range(len(points) - 1):\n        l = points[i]\n        r = points[i + 1]\n        area += (l[0] * r[1]) - (l[1] * r[0])\n    return f\"{area:.5f}\"\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    [N, K, C] = stdin.split()\n    N, K, C = int(N), int(K), int(C)\n    # each team has 3 colors and the fans\n    colors = 3\n    # each sector has at least one fan, at most 7 fans\n    fan_limit = 7\n    max_colors_per_sector = (K - 1) // fan_limit + 1\n    total_colors = K * max_colors_per_sector + colors\n\n    # the number of teams is an upper bound and inclusive\n    teams_in_stadium = max_colors_per_sector * (N - 1) + K\n    # the number of teams is an upper bound and inclusive\n    total_teams = teams_in_stadium + max_colors_per_sector - 1\n    # number of fans for each team\n    fans_per_team = total_colors // total_teams\n    # a team can have at most 10 fans\n    fans_per_team = min(fans_per_team, 10)\n    # a team can have at most 3 fans\n    fans_per_team = min(fans_per_team, 3)\n\n    return str(fans_per_team)\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = [int(i) for i in stdin.split()]\n    arr = [0] * n\n    for i in range(1, n):\n        if i - 1 >= 0:\n            arr[i] = arr[i - 1] + 1\n        arr[i] += arr[i - 1] + 1\n        arr[i] = arr[i] + 1\n    count = 1\n    print(arr)\n    for i in range(1, n):\n        count += 1\n        if arr[i] >= c and arr[i - 1] >= c:\n            count = max(count, 2)\n    return str(count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.split())\n    colors = sorted(list(map(int, stdin.split())))\n    max_colors = max(colors)\n    return str(max_colors // K + (max_colors % K > 0))\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.split())\n    total = N * K + (2 * N) * K + (2 * N) * K + (2 * N) * K\n    return str(total - (2 * C))"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = list(map(int, stdin.split()))\n    colors = list(map(int, stdin.split()))\n    sectors = []\n    color_count = {}\n    for i in range(N):\n        if colors[i] in color_count:\n            color_count[colors[i]] += 1\n        else:\n            color_count[colors[i]] = 1\n    if K < C:\n        return -1\n    sectors = []\n    for i in range(N):\n        if color_count[colors[i]] < K:\n            return -1\n        elif color_count[colors[i]] == K:\n            sectors.append(colors[i])\n    for i in range(1, len(sectors)):\n        if sectors[i - 1] + 1!= sectors[i]:\n            return -1\n    return len(sectors)\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N, K, C = int(inputs[0]), int(inputs[1]), int(inputs[2])\n    ans = 0\n    for i in range(N):\n        a = []\n        for j in range(N):\n            a.append(int(inputs[3].split()[j]))\n        if K >= sum(a[i]) >= C:\n            ans = max(ans, i+1)\n    return str(ans)"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    I found this solution online, but it's a much easier one\n    '''\n    N, K, C = map(int, stdin.split())\n    sectors = list(range(1, N + 1))\n    counts = {i: 0 for i in range(1, N + 1)}\n    for sector in sectors:\n        if sector < K:\n            counts[sector] = counts.get(sector, 0) + 1\n    return max(counts.values()) if C <= max(counts.values()) <= K else max(counts.values()) + 1\n"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (N, K, C) = (int(i) for i in stdin.split())\n    max_count = 1\n    \n    colors_per_sector = set()\n    fans_per_sector = collections.defaultdict(int)\n    while max_count < C and K:\n        colors_per_sector.add(len(colors_per_sector))\n        fans_per_sector[N - K] += 1\n        max_count = max(max_count, max(colors_per_sector) + fans_per_sector[N - K])\n        K -= 1\n        \n    return str(max_count)"
    },
    {
        "number": 3309,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    [N, K, C] = list(map(int, stdin.split()))\n    if N <= K or N <= C:\n        return str(0)\n    A = list(map(int, stdin.split()))\n    sectors = {i: [] for i in range(1, N + 1)}\n    for i in range(N):\n        sectors[A[i]].append(i + 1)\n    S = {}\n    for i in range(1, N + 1):\n        S[i] = {'check': False,'sector': i}\n    for i in range(1, N + 1):\n        if S[i]['check']:\n            continue\n        S[i]['check'] = True\n        j = i\n        while j!= 1:\n            if j in S:\n                S[i]['sector'] = S[j]['sector']\n                break\n            S[j] = {'check': False,'sector': i}\n            j = S[j]['sector']\n    colors = {i: {'check': False, 'color': set()} for i in range(1, N + 1)}\n    for i in range(1, N + 1):\n        if colors[i]['check']:\n            continue\n        colors[i]['check'] = True\n        j = i\n        while j!= 1:\n            if j in colors:\n                colors[i]['color'] = colors[j]['color']\n                break\n            colors[j] = {'check': False, 'color': set()}\n            j = colors[j]['color']\n    count = 0\n    for i in range(1, N + 1):\n        if colors[i]['check']:\n            continue\n        colors[i]['check'] = True\n        count += 1\n        j = i\n        while j!= 1:\n            if j not in colors[i]['color']:\n                break\n            j = colors[j]['sector']\n    return str(count)"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    return str(solve(n, g, t, c))\n\n\ndef"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    # n = number of tables\n    # g = maximum group size\n    # t = hours the restaurant is open\n    # c = the capacity of each table\n\n    # n = 3, g = 2, t = 2\n    # c = [1, 2, 3]\n    # expected = 4.0\n    #\n    # n = 4, g = 11, t = 4\n    # c = [10, 10, 10, 10]\n    # expected = 20.0\n    #\n    # n = 4, g = 2, t = 4\n    # c = [10, 10, 10, 10]\n    # expected = 4.0\n    #\n    # n = 5, g = 2, t = 2\n    # c = [1, 2, 3, 4, 5]\n    # expected = 4.0\n    #\n    # n = 5, g = 2, t = 4\n    # c = [1, 2, 3, 4, 5]\n    # expected = 6.0\n    #\n    # n = 10, g = 2, t = 4\n    # c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # expected = 10.0\n\n    sorted_c = sorted(c)\n    sorted_c = sorted_c[::-1]\n\n    # print(sorted_c)\n    # print(n, g, t, c)\n\n    t_days = 0\n    r_days = 0\n    t_tot = 0\n    while r_days < t:\n        # find table with shortest capacity\n        r_cap = sorted_c[0]\n        for i in range(1, len(sorted_c)):\n            if sorted_c[i] < r_cap:\n                r_cap = sorted_c[i]\n\n        r_cap = r_cap\n\n        # check if table has already been used up\n        if t_tot < r_cap:\n            # if not enough capacity\n            # r_cap = smallest cap that doesn't use up\n            # while r_cap > 0 and t_tot > 0:\n            #    for i in range(len(sorted_c)):\n            #        if sorted_c[i] > t_tot:\n            #            r_cap = sorted_c[i]\n            #            break\n\n            # insert current capacity into table\n            if r_cap > t_tot:\n                r_cap = t_tot\n            t_tot = r_cap\n            t_days = t_days + 1\n\n            # delete the capacity from the table\n            sorted_c.remove(r_cap)\n\n        # if the table has enough capacity and it is not used up\n        elif t_tot > r_cap:\n            # print('r_cap: {}'.format(r_cap))\n            # print('t_tot: {}'.format(t_tot))\n\n            # delete capacity from table\n            sorted_c.remove(r_cap)\n\n            # update t_tot\n            t_tot = t_tot - r_cap\n            t_days = t_days + 1\n\n            # check if table has still enough capacity\n            if t_tot < r_cap:\n                # while r_cap > 0 and t_tot > 0:\n                #    for i in range(len(sorted_c)):\n                #        if sorted_c[i] > t_tot:\n                #            r_cap = sorted_c[i]\n                #            break\n\n                # insert current capacity into table\n                if r_cap > t_tot:\n                    r_cap = t_tot\n                t_tot = r_cap\n                t_days = t_days + 1\n\n                # delete the capacity from the table\n                sorted_c.remove(r_cap)\n\n    # print(sorted_c)\n    # print(t_days)\n    return str(t_days)\n\nsolution(stdin)\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    total = 0\n    while n > 0:\n        if n >= c[n-1]:\n            n -= c[n-1]\n            total += 1\n        else:\n            return str(total)\n    return str(total)\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    res = max(1, g)\n    while res < n:\n        for i in range(n - res):\n            if res - i <= g and sum(c[i:res]) > t:\n                res += 1\n                break\n    return f'{res}'\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_table(capacity_list, max_group_size, start, end):\n        if start > end:\n            return None\n        mid = (start + end) // 2\n        capacity_sum = 0\n        for capacity in capacity_list:\n            if capacity_sum + capacity >= mid:\n                capacity_sum += capacity\n                if capacity_sum >= mid:\n                    return mid\n            else:\n                capacity_sum = capacity\n        if capacity_sum < mid:\n            return find_table(capacity_list, max_group_size, start, mid - 1)\n        else:\n            return find_table(capacity_list, max_group_size, mid + 1, end)\n\n    capacity_list = list(map(int, stdin.split()))\n    max_group_size = max(capacity_list)\n    start = 0\n    end = capacity_list[-1]\n    return str(find_table(capacity_list, max_group_size, start, end))"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    tables, max_group, hours = map(int, stdin.split())\n    capacities = list(map(int, stdin.split()))\n    occu = 1\n    n = 1\n    while tables > 0:\n        res = max_group * n\n        if res >= capacities[n - 1]:\n            occu += 1\n            tables -= 1\n        n += 1\n    return str(occu)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, g, t = lines[0].split()\n    n, g, t = int(n), int(g), int(t)\n    n = int(lines[1])\n    c = list(map(int, lines[2].split()))\n    print(expected_people_in_restaurant(n, g, t, c))\n    return\n\n\ndef"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.strip().split())\n    caps = list(map(int, stdin.strip().split()))\n    max_n = max(caps)\n    #print(n, g, t, caps)\n    if n == 1:\n        return str(g)\n    if g < max_n:\n        return str(max(1, n - 1))\n    #print(n, g, t, caps)\n    chunks = []\n    total = 0\n    for i in range(1, n):\n        if i <= g:\n            chunks.append([])\n            chunks[-1].append(i)\n            total += i\n        else:\n            if i % g == 0:\n                chunks.append([])\n                chunks[-1].append(i)\n                total += i\n            else:\n                num = i % g\n                if num <= caps[-1]:\n                    chunks[-1].append(num)\n                    total += num\n                else:\n                    chunks[-1].append(caps[-1])\n                    chunks[-1].append(i - num)\n                    total += i\n    #print(chunks)\n    #print(caps)\n    total += (len(chunks) - 1) * g\n    #print(total)\n    return str(total // t)\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    return str(n**(1/g) * sum(c)/n)\n"
    },
    {
        "number": 3310,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    capacities = list(map(int, stdin.split()))\n    expected = 0\n    for i in range(n):\n        expected += (capacities[i] - 1) * (capacities[i] - 1) / 2\n    expected += 1\n    return str(expected)"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    return str(exponential(n, m))"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    return str(pow(x, exp, mod))\n"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(pow(n, pow(m, -1), m))\n"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string as input and\n    returns the result as a string.\n    \"\"\"\n    n, m = stdin.split()\n    return str(pow(int(n), int(m) - 1))"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    return str(exponential(n, m))"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(math.exp(n) % m)"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1:\n        return str(m)\n    else:\n        return str(m) + \"(\" + solution(str(n - 1)) + \")\" + \"^(\" + str(m - 2) + \")\" + \"^\" + solution(str(n - 2)) + \"=\" + str(m)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split(' ')))\n    # YOUR CODE HERE\n    return str(exponential_sum(n, m))\n"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n   ... 42\n   ... 123456789\n   ... ''')\n    '16317634'\n    '''\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return str(result % m)\n"
    },
    {
        "number": 3311,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return '{0:b}'.format(n**(m-1)%m).count('1')\n"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    lines = sys.stdin.read().splitlines()\n    N, E, S_X, S_Y, C = int(lines[0]), int(lines[1]), int(lines[2]), int(lines[3]), int(lines[4])\n    X, Y = [int(i) for i in lines[5].split()]\n    Cans = [int(i) for i in lines[6].split()]\n    Cans.sort(reverse=True)\n    grid = [[i for i in range(N)] for j in range(N)]\n    exploding = 0\n    steps = 0\n    mines = [[[0 for i in range(N)] for j in range(N)] for k in range(C)]\n    while (exploding < E):\n        for i in range(len(Cans)):\n            x, y = X, Y\n            if (exploding + Cans[i] < E):\n                exploding += Cans[i]\n                x = (X - S_X) % N\n                y = (Y - S_Y) % N\n                if (x > N - 1 or y > N - 1 or x < 0 or y < 0):\n                    exploding -= Cans[i]\n                    continue\n                grid[x][y] += 1\n            else:\n                exploding -= Cans[i]\n            if (grid[x][y] == 1):\n                mines[i][x][y] += 1\n                grid[x][y] = 0\n            else:\n                mines[i][x][y] += 1\n                grid[x][y] = 0\n        grid[x][y] += 1\n        steps += 1\n        for i in range(len(Cans)):\n            if (grid[X - S_X][Y - S_Y] == 1):\n                if (mines[i][X - S_X][Y - S_Y] > 0):\n                    mines[i][X - S_X][Y - S_Y] -= 1\n                    grid[X - S_X][Y - S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n            if (grid[X - S_X][Y + S_Y] == 1):\n                if (mines[i][X - S_X][Y + S_Y] > 0):\n                    mines[i][X - S_X][Y + S_Y] -= 1\n                    grid[X - S_X][Y + S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n            if (grid[X + S_X][Y - S_Y] == 1):\n                if (mines[i][X + S_X][Y - S_Y] > 0):\n                    mines[i][X + S_X][Y - S_Y] -= 1\n                    grid[X + S_X][Y - S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n            if (grid[X + S_X][Y + S_Y] == 1):\n                if (mines[i][X + S_X][Y + S_Y] > 0):\n                    mines[i][X + S_X][Y + S_Y] -= 1\n                    grid[X + S_X][Y + S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n            if (grid[X][Y - S_Y] == 1):\n                if (mines[i][X][Y - S_Y] > 0):\n                    mines[i][X][Y - S_Y] -= 1\n                    grid[X][Y - S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n            if (grid[X][Y + S_Y] == 1):\n                if (mines[i][X][Y + S_Y] > 0):\n                    mines[i][X][Y + S_Y] -= 1\n                    grid[X][Y + S_Y] = 0\n                    exploding += 1\n                else:\n                    exploding -= 1\n        if (exploding == E):\n            break\n        for i in range(len(Cans)):\n            if (mines[i][X - S_X][Y - S_Y] == 1 or mines[i][X - S_X][Y + S_Y] == 1 or mines[i][X + S_X][Y - S_Y] == 1 or mines[i][X + S_X][Y + S_Y] == 1):\n                if (Cans[i] == 1):\n                    Cans[i] = 0\n                    exploding += 1\n        if (exploding == E):\n            break\n        for i in range(len(Cans)):\n            if (mines[i][X - S_X][Y - S_Y] == 1 or mines[i][X - S_X][Y + S_Y] == 1 or mines[i][X + S_X][Y - S_Y] == 1 or mines[i][X + S_X][Y + S_Y] == 1):\n                if (Cans[i] == 1):\n                    Cans[i] = 0\n                    exploding += 1\n        if (exploding == E):\n            break\n        for i in range(len(Cans)):\n            if (mines[i][X][Y - S_Y] == 1 or mines[i][X][Y + S_Y] == 1):\n                if (Cans[i] == 1):\n                    Cans[i] = 0\n                    exploding += 1\n        if (exploding == E):\n            break\n        for i in range(len(Cans)):\n            if (mines[i][X][Y - S_Y] == 1 or mines[i][X][Y + S_Y] == 1):\n                "
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def to_map(lines: str) -> List[int]:\n        n, e, s_x, s_y, c = map(int, lines.split())\n        grid = [[0] * n for _ in range(n)]\n        for _ in range(c):\n            x, y, ct = map(int, lines.split())\n            for i in range(ct):\n                grid[x][y] = 1\n        return grid, s_x, s_y\n\n    def to_lines(grid: List[List[int]]) -> List[str]:\n        lines = []\n        n = len(grid[0])\n        for i in range(n):\n            line = []\n            for j in range(n):\n                line.append(str(grid[j][i]))\n            lines.append(''.join(line))\n        return lines\n\n    def move(x, y, dx, dy):\n        n = len(grid)\n        for i in range(n):\n            if 0 <= x + i*dx < n and 0 <= y + i*dy < n:\n                if grid[x + i*dx][y + i*dy] == 0:\n                    return x + i*dx, y + i*dy\n        return -1, -1\n\n    def explode():\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    grid[i][j] = 2\n        return grid\n\n    grid, s_x, s_y = to_map(stdin)\n    while True:\n        cans = {}\n        for i in range(s_x, s_x + n):\n            for j in range(s_y, s_y + n):\n                if grid[i][j] == 1:\n                    if (i, j) not in cans:\n                        cans[(i, j)] = 0\n                else:\n                    if (i, j) in cans:\n                        del cans[(i, j)]\n        x, y = move(s_x, s_y, 1, 1)\n        if x == -1:\n            return sum([v for (i, j), v in cans.items()])\n        grid = explode()"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    N, E, S, X, Y, C = list(map(int, stdin[0]))\n    cans = list(map(int, stdin[1]))\n    coords = [(X,Y)]\n    distances = {}\n    for _ in range(C):\n        (x,y) = list(map(int, stdin[2]))\n        coords.append((x,y))\n        distances[(x,y)] = 0\n    for c in coords:\n        distances[c] = c\n    for can in cans:\n        (x,y) = can\n        if (x,y) in distances:\n            distances[(x,y)] += 1\n    return sum(1 for dist in distances.values() if dist % 2 == 1)"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, e, sx, sy, c = map(int, lines[0].split())\n    cans = []\n    for i in range(1, c + 1):\n        cans.append(tuple(map(int, lines[i].split())))\n    print(cans)\n    ans = 0\n    return ans\n"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, x, y, cans = map(int, stdin.split())\n    row = [[0] * cols for _ in range(rows)]\n    for _ in range(cans):\n        x, y, t = map(int, stdin.split())\n        row[x-1][y-1] = t\n    visited = [[0] * cols for _ in range(rows)]\n    visited[x][y] = 1\n    res = 0\n    for i in range(rows):\n        for j in range(cols):\n            if row[i][j] == 1:\n                curr = []\n                curr.append((i, j))\n                res += 1\n                while curr:\n                    x, y = curr.pop()\n                    for d in [[-1, 0], [0, -1], [1, 0], [0, 1]]:\n                        a, b = x + d[0], y + d[1]\n                        if 0 <= a < rows and 0 <= b < cols and not visited[a][b]:\n                            visited[a][b] = 1\n                            curr.append((a, b))\n    return str(res)\n"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, E, S_X, S_Y, C = map(int, stdin.split())\n\n    points = 0\n\n    for X in range(N):\n        for Y in range(N):\n            if X == S_X and Y == S_Y:\n                continue\n            for i in range(C):\n                CX = X + (i * E)\n                CY = Y + (i * E)\n                if CX >= N or CY >= N or CX < 0 or CY < 0:\n                    break\n                # print(f'CX: {CX} CY: {CY}')\n                points += 1\n                if points == 5:\n                    return str(points)\n\n    return str(points)"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e, x, y, c = map(int, stdin.split())\n    x -= 1\n    y -= 1\n    c -= 1\n    s = [[0 for i in range(n)] for i in range(n)]\n    s[x][y] = 1\n    s[x][y+1] = 1\n    s[x+1][y] = 1\n    s[x+1][y+1] = 1\n\n    def hit(s, x, y):\n        for i in range(n):\n            if s[x][i] == 1:\n                if s[x+1][i] == 1:\n                    s[x+1][i] = 1\n                if s[x][i+1] == 1:\n                    s[x][i+1] = 1\n                if s[x][i-1] == 1:\n                    s[x][i-1] = 1\n                if s[i][y+1] == 1:\n                    s[i][y+1] = 1\n                if s[i+1][y] == 1:\n                    s[i+1][y] = 1\n                if s[i-1][y] == 1:\n                    s[i-1][y] = 1\n                return\n    \n    t = 0\n    solved = False\n    while t < c and not solved:\n        solved = True\n        for i in range(n):\n            for j in range(n):\n                if s[i][j] == 0:\n                    continue\n                if i!= 0 and s[i-1][j] == 0:\n                    s[i-1][j] = 1\n                    solved = False\n                if j!= 0 and s[i][j-1] == 0:\n                    s[i][j-1] = 1\n                    solved = False\n                if i!= n-1 and s[i+1][j] == 0:\n                    s[i+1][j] = 1\n                    solved = False\n                if j!= n-1 and s[i][j+1] == 0:\n                    s[i][j+1] = 1\n                    solved = False\n        t += 1\n        hit(s, x, y)\n    \n    cnt = 0\n    for i in range(n):\n        for j in range(n):\n            if s[i][j] == 1:\n                cnt += 1\n    return str(cnt)"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin = \"\"\"3 1 0 0 2\n    0 1 1\n    1 0 1\n    2 1 1\n    1 2 1\n    1 2 2\n    2 2 3\n    0 2 5\n    1 2 6\n    \"\"\"\n    stdin_list = stdin.strip().split(\"\\n\")\n    n, e, s_x, s_y, c = [int(x) for x in stdin_list[0].split()]\n    can_list = [[int(x) for x in y.split()] for y in stdin_list[1:]]\n    # can_list = [[[1,2],[2,3]],[[1,2],[2,3]],[[1,2],[2,3]]]\n    start_x, start_y = s_x, s_y\n    cache = {}\n    for x, y in can_list:\n        cache[(x,y)] = []\n    cache[(start_x, start_y)] = [(0,0)]\n\n    result = 0\n    visited = set()\n    while len(visited)!= c:\n        visited.add((start_x,start_y))\n        can_list_copy = can_list.copy()\n        for x, y in can_list_copy:\n            if (x,y) in visited:\n                can_list.remove([x,y])\n                continue\n            if (x,y) not in cache:\n                continue\n            can_list.remove([x,y])\n            if (x,y) not in cache:\n                cache.pop((x,y))\n            else:\n                cache[(x,y)].remove((0,0))\n                cache[(x,y)].append((0,0))\n            for i,j in cache[(x,y)]:\n                if i == 0 and j == 0:\n                    if result < 1:\n                        result = 1\n                        start_x = x\n                        start_y = y\n                    continue\n                cache[(x,y)].append((i+1,j))\n                cache[(x,y)].append((i,j+1))\n                cache[(x,y)].append((i+1,j+1))\n                cache[(x,y)].append((i,j-1))\n                cache[(x,y)].append((i-1,j-1))\n                cache[(x,y)].append((i-1,j))\n                cache[(x,y)].append((i-1,j+1))\n                cache[(x,y)].append((i,j-1))\n                cache[(x,y)].append((i,j))\n                cache[(x,y)].append((i+1,j-1))\n                cache[(x,y)].append((i+1,j))\n                cache[(x,y)].append((i+1,j+1))\n            cache.pop((x,y))\n    return str(result)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, E, S_X, S_Y, C = map(int, stdin.split())\n    X_S, Y_S = S_X, S_Y\n    X, Y = N // 2, N // 2\n    points = 0\n    while X_S < X and Y_S < Y:\n        for x in range(X_S, X):\n            points += 1\n            X_S = x\n        for y in range(Y_S, Y):\n            points += 1\n            Y_S = y\n    for i in range(X - 1):\n        if X_S == X - 1:\n            for j in range(Y_S + 1, Y):\n                points += 1\n                Y_S = j\n        for j in range(Y_S + 1, Y):\n            points += 1\n            Y_S = j\n    for i in range(Y - 1):\n        if Y_S == Y - 1:\n            for j in range(X_S + 1, X):\n                points += 1\n                X_S = j\n        for j in range(X_S + 1, X):\n            points += 1\n            X_S = j\n    return str(points)"
    },
    {
        "number": 3312,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, E, S_X, S_Y, C = map(int, stdin.split())\n    can_list = []\n    for c in range(C):\n        X, Y, CT = map(int, stdin.split())\n        can_list.append((X, Y, CT))\n    can_list = sorted(can_list, key=lambda can: can[0])\n    can_list = sorted(can_list, key=lambda can: can[1])\n    can_list = sorted(can_list, key=lambda can: can[2])\n    #print(can_list)\n    #print(N, E, S_X, S_Y, C)\n    #print(can_list)\n    #print(len(can_list))\n    cans_collected = 0\n    for can in can_list:\n        #print(can)\n        #print(can[0], can[1], can[2])\n        if can[0] == S_X and can[1] == S_Y:\n            cans_collected += 1\n        #print(can[0], can[1], can[2])\n    return cans_collected\n\n\nsolution(\"\"\"3 1 0 0 2\n1 2 2\n1 1 1\n2 1 1\n1 2 1\n1 2 2\n2 2 3\n0 2 5\n1 2 6\"\"\")"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n, r, w, h = map(int, lines[0].split())\n    gems = []\n    for _ in range(n):\n        x, y = map(int, lines[_ + 1].split())\n        gems.append((x, y))\n    return str(len(max_gem_dist(gems, r, w, h)))\n\n\ndef"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.split())\n    gems = [(i, j) for i in range(w) for j in range(h) if i * j % n == 0]\n    v_max = max(map(abs, (i for i, j in gems)))\n    res = 0\n    for gem in gems:\n        x, y = gem\n        if abs(y) > res and x - y < -v_max / r:\n            res = abs(y) - y\n    return str(res)\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.split())\n    track = {}\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        if x == 0:\n            continue\n        if x in track:\n            track[x][0] = min(track[x][0], y)\n        else:\n            track[x] = [y, 0]\n    max_collect = 0\n    for i in track.keys():\n        if track[i][0] == 0:\n            continue\n        if track[i][0] > h:\n            continue\n        if track[i][0] < 0:\n            continue\n        if track[i][0] < h / 2:\n            max_collect += track[i][0]\n            continue\n        if track[i][0] > h / 2:\n            max_collect += track[i][0] - h\n    return max_collect"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = [int(x) for x in stdin.split()]\n    gems = []\n    x = 0\n    y = 0\n    x_max = w - x\n    while y < h:\n        gem_x, gem_y = [int(x) for x in stdin.split()]\n        gems.append((gem_x, gem_y))\n        x += (gem_x + 1)\n        x_max = max(x, x_max)\n        y += 1\n    print(x_max)\n    return x_max"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = list(map(int, stdin.split()))\n    w_c = w\n    h_c = h\n    c = 0\n    h_c -= w_c\n    while True:\n        h_c += r\n        w_c += r\n        c += 1\n        if h_c < h_c or h_c > h:\n            break\n        if w_c > w:\n            break\n    return c\n\nprint(solution(input()))\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5 1 10 10\n   ... 8 8\n   ... 5 1''')\n    '3'\n    >>> solution('''5 1 10 10\n   ... 27 75\n   ... 79 77\n   ... 40 93\n   ... 62 41\n   ... 52 45\n   ... Sample Output 2:\n   ... 3''')\n    '3'\n    \"\"\"\n    n, r, w, h = map(int, stdin.split())\n    gems = []\n    gem_total = 0\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        gems.append((x, y))\n        gem_total += 1\n\n    x_max = w\n    y_max = h\n    x_min = 0\n    y_min = 0\n    visited = set()\n    queue = []\n    queue.append((0, 0))\n    while queue:\n        x, y = queue.pop(0)\n        visited.add((x, y))\n        if x == x_max and y == y_max:\n            return len(visited)\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            x_next, y_next = x + dx, y + dy\n            if not (0 <= x_next <= x_max and 0 <= y_next <= y_max):\n                continue\n            if (x_next, y_next) in visited:\n                continue\n            if x_next == x_max and y_next == y_max:\n                return gem_total\n            queue.append((x_next, y_next))\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n, r, w, h = stdin[0], float(stdin[1]), int(stdin[2]), int(stdin[3])\n    x, y = stdin[4:4+n], stdin[4+n:]\n\n    x.sort(reverse=True)\n    y.sort(reverse=True)\n\n    x = sorted(x)\n    y = sorted(y)\n\n    x = sorted(x, key=lambda x: -x)\n    y = sorted(y, key=lambda y: -y)\n\n    x = sorted(x, key=lambda x: -x)\n    y = sorted(y, key=lambda y: -y)\n\n    count = 0\n\n    for i in range(len(x)):\n        if x[i] < w/2:\n            x[i] = x[i] + w\n\n    for i in range(len(y)):\n        if y[i] < h/2:\n            y[i] = y[i] + h\n\n    for i in range(len(x)):\n        if x[i] < x[i+1]:\n            x[i] = x[i] + w\n        else:\n            x[i] = x[i] - w\n\n    for i in range(len(y)):\n        if y[i] < y[i+1]:\n            y[i] = y[i] + h\n        else:\n            y[i] = y[i] - h\n\n    for i in range(len(x)):\n        if y[i] < 0:\n            y[i] = 0\n        else:\n            y[i] = y[i] - h\n    \n    for i in range(len(y)):\n        if x[i] < 0:\n            x[i] = 0\n        else:\n            x[i] = x[i] - w\n\n    if x[0] < 0:\n        x[0] = 0\n    else:\n        x[0] = x[0] - w\n\n    if y[0] < 0:\n        y[0] = 0\n    else:\n        y[0] = y[0] - h\n\n    for i in range(len(x)):\n        if x[i] < 0:\n            x[i] = 0\n        else:\n            x[i] = x[i] - w\n    \n    for i in range(len(y)):\n        if y[i] < 0:\n            y[i] = 0\n        else:\n            y[i] = y[i] - h\n\n    for i in range(len(x)):\n        if x[i] > w:\n            x[i] = w\n        else:\n            x[i] = x[i] - w\n\n    for i in range(len(y)):\n        if y[i] > h:\n            y[i] = h\n        else:\n            y[i] = y[i] - h\n\n    for i in range(len(x)):\n        count += (x[i]-0) * (y[i]-0)\n\n    count = count + (r*r*w)\n\n    return str(count)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    w = int(lines[1])\n    h = int(lines[2])\n    lines = lines[3:]\n    for line in lines:\n        x, y = line.split()\n        y = int(y)\n        if x == '0':\n            continue\n        else:\n            x = int(x)\n        if h == y:\n            return '0'\n        if (x < w and y < h) or (x < w and y > h) or (x > w and y < h) or (x > w and y > h):\n            return '0'\n        if x > w and y > h:\n            return '0'\n    return str(n)\n\nsolution('''5 1 100 100\n8 8\n5 1\n4 6\n4 7\n7 9\nSample Output 2:\n3\n''')\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(lambda l: list(map(lambda x: int(x), l.split())) + [0, 0], stdin.split('\\n')))\n    n, r, w, h = stdin[0]\n    stdin = stdin[1:]\n    prev, cur = 0, 0\n    for x, y in stdin:\n        cur += abs(x-prev)\n        prev = x\n    return cur\n"
    },
    {
        "number": 3313,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = list(map(int, stdin.split()))\n    gems = []\n    for i in range(n):\n        x, y = list(map(int, stdin.split()))\n        gems.append((x, y))\n    gems.sort(key=lambda x: (x[1], x[0]))\n    curr_x = 0\n    curr_y = h\n    found_gems = 0\n    for i in range(len(gems)):\n        if i == 0:\n            curr_x = 0\n        elif i == 1:\n            curr_x = gems[i][0]\n        else:\n            curr_x = gems[i][0]\n        curr_y = min(gems[i][1], curr_y)\n        if curr_x == 0 and curr_y == 0:\n            found_gems += 1\n            curr_x = 0\n        elif curr_x == 0 and curr_y < 0:\n            curr_x = 0\n        elif curr_x > w:\n            curr_x = w\n        if curr_y == h:\n            break\n        if curr_y < 0:\n            curr_y = 0\n    return str(found_gems)\n"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    total = len(stdin)\n    num_rotations = 0\n    # find index of first letter\n    while total > 0:\n        if stdin[0] == \"A\":\n            break\n        else:\n            total -= 1\n            stdin = stdin[1:]\n    # If we have already found the first letter\n    if total == 0:\n        return -1\n\n    # Finding last letter\n    while total > 0:\n        if stdin[total-1] == \"A\":\n            break\n        else:\n            total -= 1\n    # If we have already found the first letter\n    if total == 0:\n        return -1\n\n    # Case 1\n    # Start at last letter\n    i = total-1\n    while i >= 0:\n        # We see A\n        if stdin[i] == \"A\":\n            # If we can see A in first row, we can see C\n            if stdin[i-1] == \"A\":\n                # If we can see A in second row, we can see D\n                if stdin[i-2] == \"A\":\n                    # If we can see A in third row, we can see E\n                    if stdin[i-3] == \"A\":\n                        # If we can see A in fourth row, we can see F\n                        if stdin[i-4] == \"A\":\n                            # If we can see A in fourth row, we can see F\n                            if stdin[i-5] == \"A\":\n                                # If we can see A in fourth row, we can see F\n                                if stdin[i-6] == \"A\":\n                                    # If we can see A in fourth row, we can see F\n                                    if stdin[i-7] == \"A\":\n                                        # We have found the whole row\n                                        return -1\n                        # If we can see A in third row, we can see D\n                        if stdin[i-2] == \"A\":\n                            # If we can see A in third row, we can see C\n                            if stdin[i-3] == \"A\":\n                                # If we can see A in second row, we can see B\n                                if stdin[i-1] == \"A\":\n                                    # If we can see A in first row, we can see A\n                                    if stdin[i] == \"A\":\n                                        # We have found the whole row\n                                        return -1\n                                # If we can see A in first row, we can see B\n                                if stdin[i] == \"A\":\n                                    # If we can see A in first row, we can see C\n                                    if stdin[i-1] == \"A\":\n                                        # If we can see A in first row, we can see D\n                                        if stdin[i-2] == \"A\":\n                                            # If we can see A in second row, we can see E\n                                            if stdin[i-3] == \"A\":\n                                                # If we can see A in third row, we can see F\n                                                if stdin[i-4] == \"A\":\n                                                    # If we can see A in fourth row, we can see F\n                                                    if stdin[i-5] == \"A\":\n                                                        # If we can see A in fourth row, we can see F\n                                                        if stdin[i-6] == \"A\":\n                                                            # If we can see A in fourth row, we can see F\n                                                            if stdin[i-7] == \"A\":\n                                                                # We have found the whole row\n                                                                return -1\n                # If we can see A in second row, we can see C\n                if stdin[i-1] == \"A\":\n                    # If we can see A in second row, we can see D\n                    if stdin[i-2] == \"A\":\n                        # If we can see A in third row, we can see E\n                        if stdin[i-3] == \"A\":\n                            # If we can see A in fourth row, we can see F\n                            if stdin[i-4] == \"A\":\n                                # If we can see A in fourth row, we can see F\n                                if stdin[i-5] == \"A\":\n                                    # If we can see A in fourth row, we can see F\n                                    if stdin[i-6] == \"A\":\n                                        # If we can see A in fourth row, we can see F\n                                        if stdin[i-7] == \"A\":\n                                            # We have found the whole row\n                                            return -1\n                    # If we can see A in third row, we can see D\n                    if stdin[i-2] == \"A\":\n                        # If we can see A in third row, we can see C\n                        if stdin[i-3] == \"A\":\n                            # If we can see A in second row, we can see B\n                            if stdin[i-1] == \"A\":\n                                # If we can see A in first row, we can see A\n                                if stdin[i] == \"A\":\n                                    # We have found the whole row\n                                    return -1\n                            # If we can see A in first row, we can see B\n                            if stdin[i] == \"A\":\n                                # If we can see A in first row, we can see C\n                                if stdin[i-1] == \"A\":\n                                    # If we can see A in first row, we can see D\n                                    if stdin[i-2] == \"A\":\n                                        # If we can see A in second row, we can see E\n                                        if stdin[i-3] == \"A\":\n                                            # If we can see A in third row, we can see F\n                                            if stdin[i-4] == \"A\":\n                                                # If we can see A in fourth row, we can see F\n                                                if stdin[i-5] == \"A\":\n                                                    # If we can see A in fourth row, we can see F\n                                                    if stdin[i-6] == \"A\":\n                                                        # If we can see A in fourth row, we can see F\n                                                        if stdin[i-7] == \"A\":\n                                                            # We have found the whole row\n                                                            return -1\n            # If we can see A in first row, we can see C\n            if stdin[i-1] == \"A\":\n                # If we can see A in second row, we can see D\n                if stdin[i-2] == \"A\":\n                    # If we can see A in third row, we can see E\n                    if stdin[i-3] == \"A\":\n                        # If we can see A in fourth row, we can see F\n                        if stdin[i-4] == \"A\":\n                            # If we can see A in fourth row, we can see F\n                            if stdin"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    wheels = stdin.split()\n    cols = len(wheels[0])\n    rotations = 0\n    while cols > 3:\n        # Convert to a 2D list\n        row = [0] * len(wheels)\n        for i in range(len(wheels)):\n            for j in range(len(wheels[i])):\n                row[i] += ord(wheels[i][j])\n        # Sort by row\n        row.sort()\n        # Convert back to str\n        wheels = []\n        for i in range(len(row)):\n            wheels.append(row[i].to_str())\n        cols = len(wheels[0])\n        rotations += 1\n    return rotations if cols == 3 else -1\n\nsolution('ABC')\nsolution('ABBBAAAA')\nsolution('BBBCCCBB')\n\"\"\"\nimport unittest\n\ndef"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rotations = {\n        \"A\": 0,\n        \"B\": 0,\n        \"C\": 0\n    }\n    for line in stdin.splitlines():\n        for letter in line:\n            rotations[letter] += 1\n        if rotations[\"A\"]!= 3:\n            return \"NO\"\n        rotations[\"A\"] = 0\n        if rotations[\"B\"]!= 3:\n            return \"NO\"\n        rotations[\"B\"] = 0\n        if rotations[\"C\"]!= 3:\n            return \"NO\"\n        rotations[\"C\"] = 0\n    return \"YES\"\n"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    all_wheels_identical = stdin[0] == stdin[1] == stdin[2]\n    cols = len(stdin[0])\n    rows = len(stdin[0])\n    all_letters = set(stdin[0]) | set(stdin[1]) | set(stdin[2])\n    for letter in all_letters:\n        if stdin[0].count(letter)!= 3 or stdin[1].count(letter)!= 3 or stdin[2].count(letter)!= 3:\n            return -1\n    if all_wheels_identical:\n        return cols * 3\n    else:\n        return -1\n\nprint(solution(sys.stdin.read().split()))\n"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    n = len(stdin[0])\n\n    for s in stdin[1:]:\n        if len(s)!= n:\n            return -1\n\n    ans = n\n\n    for s in stdin[1:]:\n        if len(set(s))!= 3:\n            return -1\n\n    for s in stdin[1:]:\n        if not is_rot_possible(s):\n            return -1\n\n    return ans\n\n\ndef"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n == 3:\n        return -1\n    \n    grid = [[0 for _ in range(n)] for _ in range(n)]\n\n    # Populate the grid\n    for i in range(n):\n        grid[i] = list(stdin)\n\n    # Search the grid\n    for i in range(1, n - 1):\n        for j in range(1, n - 1):\n            if grid[i][j]!= 'A':\n                continue\n\n            if grid[i - 1][j] == 'A' and grid[i + 1][j] == 'A' and grid[i][j - 1] == 'A' and grid[i][j + 1] == 'A':\n                return i * j\n\n    return -1\n\ndef"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return str(sum(1 for _ in itertools.chain.from_iterable(sorted(stdin) for _ in range(3))))\n\nprint(solution(sys.stdin.read()))"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    l = []\n    for i in stdin.split(\"\\n\"):\n        l.append(i)\n    s = []\n    s2 = []\n    s3 = []\n    s4 = []\n    s5 = []\n    s6 = []\n    for i in range(len(l)):\n        s.append(l[i][0])\n        s2.append(l[i][-1])\n        s3.append(l[i][1])\n        s4.append(l[i][-2])\n        s5.append(l[i][0:2])\n        s6.append(l[i][-3:-1])\n    c1 = Counter(s)\n    c2 = Counter(s2)\n    c3 = Counter(s3)\n    c4 = Counter(s4)\n    c5 = Counter(s5)\n    c6 = Counter(s6)\n    c = Counter(s)\n    c1 = sorted(c1.items(), key=lambda x: x[1])\n    c2 = sorted(c2.items(), key=lambda x: x[1])\n    c3 = sorted(c3.items(), key=lambda x: x[1])\n    c4 = sorted(c4.items(), key=lambda x: x[1])\n    c5 = sorted(c5.items(), key=lambda x: x[1])\n    c6 = sorted(c6.items(), key=lambda x: x[1])\n    c = sorted(c.items(), key=lambda x: x[1])\n    t1 = 0\n    t2 = 0\n    t3 = 0\n    t4 = 0\n    t5 = 0\n    t6 = 0\n    c1 = sorted(c1, key=lambda x: x[0])\n    c2 = sorted(c2, key=lambda x: x[0])\n    c3 = sorted(c3, key=lambda x: x[0])\n    c4 = sorted(c4, key=lambda x: x[0])\n    c5 = sorted(c5, key=lambda x: x[0])\n    c6 = sorted(c6, key=lambda x: x[0])\n    t1 = t1 + len([x for x in c1 if x[1] == 3])\n    t2 = t2 + len([x for x in c2 if x[1] == 3])\n    t3 = t3 + len([x for x in c3 if x[1] == 3])\n    t4 = t4 + len([x for x in c4 if x[1] == 3])\n    t5 = t5 + len([x for x in c5 if x[1] == 3])\n    t6 = t6 + len([x for x in c6 if x[1] == 3])\n    t = min(t1,t2,t3,t4,t5,t6)\n    if t <= 0:\n        return -1\n    return t\n"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return -1"
    },
    {
        "number": 3314,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return (stdin\n\"\"\"\n    minimum_rotations = -1\n\n    for string in stdin:\n        if set(string) == {'A', 'B', 'C'}:\n            minimum_rotations = 0\n        elif set(string) == {'C', 'A', 'B'}:\n            minimum_rotations = 1\n        elif set(string) == {'B', 'C', 'A'}:\n            minimum_rotations = 2\n\n        if minimum_rotations!= -1:\n            break\n\n    return minimum_rotations\n"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n\n    def f(a, b):\n        l = len(a)\n        if l <= 1:\n            return True\n        if a[0] == b[0] or a[0] == '$' or b[0] == '$':\n            return f(a[1:], b[1:])\n        else:\n            return False\n\n    n = int(stdin.pop(0))\n    p = n\n    k = 0\n    res = 0\n\n    for i in range(n):\n        if f(stdin[i], stdin[i + 1]):\n            k += 1\n        else:\n            res = max(k, res)\n            p = i + 1\n            k = 0\n\n    res = max(k, res)\n\n    return str(res)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    ans = 0\n    for i in range(N):\n        ans += len(stdin[i:]) - len(set(stdin[i:]))\n    return str(ans)"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return len(stdin.replace('A',''))\n"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l = len(stdin)\n    dp = [[0 for _ in range(l)] for _ in range(l)]\n    for i in range(l):\n        for j in range(i, l):\n            if j - i == 1:\n                dp[i][j] = 1\n            elif j - i == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = max([dp[i][k] + dp[k + 1][j] for k in range(i, j)])\n    return str(dp[0][l - 1])\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    str_list = stdin.split()\n    max_length = len(max(str_list, key=len))\n    max_string = ''\n    for i in range(len(str_list)):\n        if len(str_list[i]) == max_length:\n            max_string = str_list[i]\n    return len(max_string)"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    max_count = 0\n    str_count = 0\n    for x in stdin.split('\\n'):\n        str_count += 1\n        if str_count > 1:\n            if stdin.index(x, 1) - stdin.index(x, 0) == 2:\n                max_count = max(max_count, len(x))\n    return str(max_count)\n\n\ndef"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ls = [stdin[i] for i in range(n)]\n    prev_length = 1\n    total_length = 1\n    count = 0\n    for i in range(1,n):\n        if ls[i-1] == ls[i]:\n            count += 1\n            if count > prev_length:\n                prev_length = count\n        else:\n            count = 1\n        total_length = max(total_length, count + prev_length)\n    return total_length"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    longest = 0\n    count = 0\n    for i in stdin.splitlines():\n        longest = max(longest, len(i))\n        count += len(i)\n    return str(count)"
    },
    {
        "number": 3315,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    res = ''\n    for i in range(n):\n        res += stdin[i] * (n - i)\n    return res\n\nprint(solution(input()))\n'''"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, p = map(int, stdin.split())\n    return str(int(round(0.1 * n / m) * 100))"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, p = map(int, stdin.split())\n    return \"{:.9f}\".format(1.0 / n)"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n,m,t,p = map(int, stdin.split())\n    cnt = 0\n    \n    probability = 1\n    while(m > 0):\n        cnt = 0\n        while(cnt < t):\n            if(p > 0):\n                cnt += (1/p)\n            else:\n                cnt += 1\n            p -= 1\n        m -= 1\n        probability *= cnt\n    return str(probability)\n"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, p = map(int, stdin.split())\n    return str(math.comb(p, n) * math.comb(m - p, m) / math.comb(n + m - p, n) / math.comb(n + m, n))\n"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return '{:.9f}'.format(sum([1/100] * 100) * 1/100)\nstdin = '100 10 2 1'\nprint(solution(stdin))\n\ndef"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, m, n, t = stdin.split(\" \")\n    m, n, t = int(m), int(n), int(t)\n    return \"0.1\"\n"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n,m,t,p= map(int,stdin.split())\n    return '{0:.10f}'.format(p**n/m)\n    \n"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split()[0])\n    n = int(stdin.split()[1])\n    t = int(stdin.split()[2])\n    p = int(stdin.split()[3])\n    print(\"{0:.10f}\".format(ln(m, n, t, p)))\n    return \"\"\n\ndef"
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    p, n, t, m = list(map(int, stdin.split()))\n    return str(sum(x + 1 / m for x in range(m // t + 1) if x + 1 >= (p / n)))\n\nstdin = \"\"\"\n20 20 2 1\n\"\"\""
    },
    {
        "number": 3316,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    p, n, t, m = map(int, stdin.split())\n    ans = 1\n    for i in range(1, m+1):\n        ans *= (p+i)/(p+i-1)\n    for i in range(n):\n        ans *= (m+i)/(m+i-1)\n    ans *= (p+m+1)/(p+m)\n    return str(ans)\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.rstrip()\n    q = int(stdin.split()[1])\n    d = {}\n    l = []\n    l.append(d)\n    for i in range(q):\n        i,j = stdin.split()\n        i = int(i)\n        j = int(j)\n        if d.get(s[i]) == None:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n        if d.get(s[j]) == None:\n            d[s[j]] = 1\n        else:\n            d[s[j]] += 1\n    for i in range(len(s)-1):\n        if d.get(s[i]) == None:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n        if d.get(s[i+1]) == None:\n            d[s[i+1]] = 1\n        else:\n            d[s[i+1]] += 1\n    for i in range(len(s)-2):\n        if d.get(s[i]) == None:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n        if d.get(s[i+1]) == None:\n            d[s[i+1]] = 1\n        else:\n            d[s[i+1]] += 1\n        if d.get(s[i+2]) == None:\n            d[s[i+2]] = 1\n        else:\n            d[s[i+2]] += 1\n    for i in range(len(s)-3):\n        if d.get(s[i]) == None:\n            d[s[i]] = 1\n        else:\n            d[s[i]] += 1\n        if d.get(s[i+1]) == None:\n            d[s[i+1]] = 1\n        else:\n            d[s[i+1]] += 1\n        if d.get(s[i+2]) == None:\n            d[s[i+2]] = 1\n        else:\n            d[s[i+2]] += 1\n        if d.get(s[i+3]) == None:\n            d[s[i+3]] = 1\n        else:\n            d[s[i+3]] += 1\n    if len(l) == 1:\n        return 0\n    else:\n        return max(l)\nsolution(input())\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    first_index, second_index = map(int, stdin.split())\n    s = stdin\n    max_len = 0\n    for i in range(first_index, second_index + 1):\n        for j in range(first_index, second_index + 1):\n            if i == j:\n                continue\n            if s[i]!= s[j]:\n                break\n            max_len = max(max_len, i - j)\n    return str(max_len)\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.split()\n    q = int(t[1])\n    m = [0] * 26\n    s = list(stdin.upper())\n    for _ in range(q):\n        x, y = int(t[2]), int(t[3])\n        while s[x]!= s[y]:\n            x = x + 1 if s[x] == 'B' else x - 1\n            y = y + 1 if s[y] == 'B' else y - 1\n        m[ord(s[x]) - ord('A')] = max(m[ord(s[x]) - ord('A')], m[ord(s[y]) - ord('A')] + 1)\n    res = 0\n    for i in range(26):\n        res = max(res, m[i])\n    return str(res)\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def longest_common_subsequence(a, b):\n        n = len(a)\n        m = len(b)\n\n        def helper(i, j, memo):\n            if i == n or j == m:\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            if a[i] == b[j]:\n                return 1 + helper(i + 1, j + 1, memo)\n            else:\n                return max(helper(i + 1, j), helper(i, j + 1))\n\n        return helper(0, 0, {})\n\n    return longest_common_subsequence(stdin, stdin)\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # YOUR CODE HERE\n    longest_trades = 0\n    for line in stdin.splitlines():\n        starts = []\n        trades = []\n        for i, c in enumerate(line):\n            if c.islower():\n                trades.append(c.upper())\n            else:\n                trades.append(c.lower())\n            if not i or i == len(line) - 1:\n                start = i\n                starts.append(start)\n        print(trades)\n        print(starts)\n        trades_pairs = zip(starts, list(range(len(starts)))[1:] + [len(starts)])\n        trades_pairs = sorted(trades_pairs, key=lambda x: x[1] - x[0])\n        print(trades_pairs)\n        for i, j in trades_pairs:\n            if trades[i]!= trades[j]:\n                break\n        else:\n            longest_trades = max(longest_trades, j - i + 1)\n    return longest_trades\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    stdin = stdin.split('\\n')\n    stdin = [line.split() for line in stdin]\n    print(stdin)\n    length = len(stdin)\n    print(length)\n    result = -1\n    for i in range(length):\n        print(i)\n        for j in range(length):\n            print(j)\n            result = max(result, longest_identical_subsequence(i, j, stdin))\n    return str(result)\n\ndef"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin\n    N = len(S)\n    \n    longest = 0\n    \n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            trades = 0\n            \n            if S[i] == S[j]:\n                trades = trades + 1\n            if i > 0 and S[i] == S[i - 1] and S[i] == S[j]:\n                trades = trades + 1\n            if j < N - 1 and S[j] == S[j + 1] and S[j] == S[i]:\n                trades = trades + 1\n            \n            longest = max(longest, trades)\n    return longest\n    \nsolution(input())\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d = {}\n    for i, x in enumerate(stdin):\n        if x not in d:\n            d[x] = [i]\n        else:\n            d[x] += [i]\n    mx = 0\n    for a, b in itertools.combinations(d.keys(), 2):\n        if a == b:\n            continue\n        mx = max(mx, len(d[a]))\n        mx = max(mx, len(d[b]))\n    return mx"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3317,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    \n    answer = []\n    stdin = stdin.splitlines()\n    print(stdin)\n    answer = []\n    for i in range(len(stdin)):\n        answer.append(len(stdin[i]))\n    print(answer)\n    return answer"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = list(map(int, stdin.split()))\n    tree = [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        u, v = list(map(int, stdin.split()))\n        tree[u].append(v)\n        tree[v].append(u)\n    queue = [1]\n    ans = 0\n    while queue:\n        ans += 1\n        temp = []\n        for node in queue:\n            for nei in tree[node]:\n                if nei not in temp and (abs(nei - node) <= D or abs(nei - node) >= D * 2):\n                    temp.append(nei)\n        queue = temp\n    return str(ans)\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    tree = {}\n    # Build the tree with N nodes.\n    for _ in range(N - 1):\n        a, b = map(int, stdin.split())\n        tree[a] = b\n        tree[b] = a\n    # The root of the tree is node 0.\n    x = 0\n    # The distance between nodes that are connected to each other.\n    dist = 0\n    # Mark the node x.\n    tree[x] = x\n    # Count the number of nodes that can be marked.\n    def dfs(x, dist):\n        if x in tree:\n            # If we have already visited the node, it must be marked already.\n            # Thus, return.\n            if tree[x] in tree:\n                return\n            # We have not already visited this node.\n            # Mark it and add its distance to dist.\n            tree[x] = x\n            dist += 1\n            if dist > D:\n                return\n            # Continue the dfs for every node that is connected to x.\n            for y in tree:\n                if y!= x:\n                    dfs(tree[x], dist)\n    # Run dfs on every node.\n    for y in tree:\n        dfs(y, 0)\n    # Return the number of nodes that can be marked.\n    return dist\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().splitlines()\n    root = int(lines[0])\n    lines.pop(0)\n    max_count = 0\n    for line in lines:\n        values = list(map(int, line.split()))\n        if values[0]!= root:\n            raise ValueError\n        if max_count < values[1] + values[2]:\n            max_count = values[1] + values[2]\n    return str(max_count)\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    tree = {i: [] for i in range(N)}\n    for i in range(N-1):\n        a, b = map(int, stdin.split())\n        tree[a].append(b)\n        tree[b].append(a)\n    visited = set()\n    visited.add(0)\n    queue = deque([0])\n    count = 1\n    while queue:\n        node = queue.popleft()\n        visited.add(node)\n        for child in tree[node]:\n            if child in visited:\n                continue\n            queue.append(child)\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split()\n    N, D = map(int, lines[0].split())\n    nodes = {}\n    for i in range(1, N + 1):\n        nodes[i] = []\n    for line in lines[1:]:\n        a, b = map(int, line.split())\n        nodes[a] += [b]\n        nodes[b] += [a]\n    def dist(node: int):\n        return 0 if node == 1 else 1 + min(dist(x) for x in nodes[node])\n    return max(nodes[1].index(x) + 1 for x in nodes[1] if dist(x) <= D)\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    memo = dict()\n    return solution_helper(n, d, 0, memo)\ndef"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n\n    graph = {i: [] for i in range(1, N+1)}\n    for i in range(1, N+1):\n        graph[i].extend(list(map(int, input().split())))\n    result = 0\n    queue = deque()\n    visited = {1}\n    queue.append(1)\n    while len(queue) > 0:\n        top = queue.popleft()\n        for i in graph[top]:\n            if i not in visited:\n                visited.add(i)\n                queue.append(i)\n                if abs(top - i) <= D:\n                    result += 1\n    print(result)\n    return result\n"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, d = [int(i) for i in stdin.split()]\n    graph = defaultdict(list)\n    for i in range(n-1):\n        u, v = [int(i) for i in stdin.split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    max_nodes = 0\n    visited = set()\n    def dfs(node):\n        visited.add(node)\n        neighbours = graph[node]\n        for neighbour in neighbours:\n            if neighbour not in visited:\n                dfs(neighbour)\n    for node in range(1, n+1):\n        if node not in visited:\n            dfs(node)\n            max_nodes = max(max_nodes, len(visited))\n    return str(max_nodes)"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    graph = collections.defaultdict(list)\n\n    for _ in range(N - 1):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = set()\n    ans = 0\n    for i in range(N):\n        if i in visited:\n            continue\n\n        if not visit(i, D, graph, visited):\n            return str(ans)\n\n        ans += 1\n\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3318,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    pass"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    planets = [list(map(int, line.split())) for line in stdin.splitlines()]\n    collisions = 0\n    while collisions < len(planets):\n        planets = sorted(planets, key=lambda p: (p[0], p[1], p[2], p[3]))\n        for i in range(len(planets)):\n            if i == len(planets)-1:\n                continue\n            x1, y1, z1, vx1, vy1, vz1 = planets[i]\n            x2, y2, z2, vx2, vy2, vz2 = planets[i+1]\n            if x1 == x2 and y1 == y2 and z1 == z2 and (vx1 == vx2 or vy1 == vy2 or vz1 == vz2):\n                collisions += 1\n                continue\n            new_mass = x1 + y1 + z1\n            new_vx = vx1 + vx2\n            new_vy = vy1 + vy2\n            new_vz = vz1 + vz2\n            planets[i] = (new_mass, x1, y1, z1, new_vx, new_vy, new_vz)\n    planets = sorted(planets, key=lambda p: (p[0], p[1], p[2], p[3], p[4], p[5]))\n    result = ''\n    for planet in planets:\n        x, y, z, vx, vy, vz = planet\n        result += str(x) +'' + str(y) +'' + str(z) +'' + str(vx) +'' + str(vy) +'' + str(vz) + '\\n'\n    return result\n\n\nprint(solution(\"\"\"\n2 8 8 8\n12 4 1 4 5 3 -2\n10 1 2 1 8 -6 1\n\"\"\"), \"\"\"\n0\nP0: 1 4 1 4 -1 0\nP1: 8 -1 -1 2 2 -1 0\nP2: 4 -1 2 2 2 2 -1 0\nP3: 1 -1 2 2 2 2 -1 0\nP4: 5 3 3 3 3 2 2 -1 0\nP5: -1 -1 2 2 2 2 2 -1 0\nP6: -1 -1 3 2 2 2 2 -1 0\nP7: -1 -1 3 2 2 2 2 -1 0\nP8: -1 -1 3 2 2 2 2 -1 0\nP9: -1 -1 3 2 2 2 2 -1 0\nP10: -1 -1 3 2 2 2 2 -1 0\nP11: -1 -1 3 2 2 2 2 -1 0\nP12: -1 -1 3 2 2 2 2 -1 0\nP13: -1 -1 3 2 2 2 2 -1 0\nP14: -1 -1 3 2 2 2 2 -1 0\nP15: -1 -1 3 2 2 2 2 -1 0\nP16: -1 -1 3 2 2 2 2 -1 0\nP17: -1 -1 3 2 2 2 2 -1 0\nP18: -1 -1 3 2 2 2 2 -1 0\nP19: -1 -1 3 2 2 2 2 -1 0\nP20: -1 -1 3 2 2 2 2 -1 0\nP21: -1 -1 3 2 2 2 2 -1 0\n\"\"\")\n\n\"\"\"\nSample Output:\n\n1\nP0: 22 1 4 2 6 -1 0\nP1: 5 3 3 3 3 2 2 -1 0\nP2: -1 -1 3 2 2 2 2 -1 0\nP3: -1 -1 3 2 2 2 2 -1 0\nP4: -1 -1 3 2 2 2 2 -1 0\nP5: -1 -1 3 2 2 2 2 -1 0\nP6: -1 -1 3 2 2 2 2 -1 0\nP7: -1 -1 3 2 2 2 2 -1 0\nP8: -1 -1 3 2 2 2 2 -1 0\nP9: -1 -1 3 2 2 2 2 -1 0\nP10: -1 -1 3 2 2 2 2 -1 0\nP11: -1 -1 3 2 2 2 2 -1 0\nP12: -1 -1 3 2 2 2 2 -1 0\nP13: -1 -1 3 2 2 2 2 -1 0\n"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n    4 8 8 8\n    12 4 1 4 5 3 -2\n    10 1 2 1 8 -6 1\n    ''')\n    '''\n    n_x, n_y, n_z = map(int, stdin.split())\n    planetoids = [(int(n), int(x), int(y), int(z), int(v_x), int(v_y), int(v_z))\n                  for n, x, y, z, v_x, v_y, v_z in zip(\n                      *[iter(stdin.split()) for i in range(n_x * n_y * n_z)])]\n    planetoids.sort(key=lambda p: (p[1], p[2], p[3], p[0]))\n    res = 1\n    cur_planetoid = planetoids[0]\n    for planetoid in planetoids[1:]:\n        if cur_planetoid[1] == planetoid[1] and cur_planetoid[2] == planetoid[2] and cur_planetoid[3] == planetoid[3]:\n            if cur_planetoid[0] + planetoid[0] > res:\n                res = cur_planetoid[0] + planetoid[0]\n        else:\n            res += 1\n            cur_planetoid = planetoid\n    return res\n"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n_x, n_y, n_z = map(int, stdin.split())\n    masses = list(map(int, stdin.split()))\n    planets = []\n    for m in masses:\n        planets.append((m, (0, 0, 0), (0, 0, 0)))\n    for _ in range(int(stdin.split()[1])):\n        v_x, v_y, v_z = list(map(int, stdin.split()))\n        p_x, p_y, p_z = planets[-1][1]\n        planets.append((planets[-1][0] + (v_x, v_y, v_z), (p_x + v_x, p_y + v_y, p_z + v_z), (p_x, p_y, p_z)))\n    planets.sort(key=lambda p: (p[0], p[1][0], p[1][1], p[1][2]))\n    p = 1\n    planets.sort(key=lambda p: (p[0], p[1][0], p[1][1], p[1][2]))\n    return str(p) + '\\n' + '\\n'.join([str(p) +'' + str(m) +'' + str(x) +'' + str(y) +'' + str(z) +'' + str(v_x) +'' + str(v_y) +'' + str(v_z) for m, x, y, z, v_x, v_y, v_z in planets])\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, n_x, n_y, n_z = map(int, stdin.split())\n    planetoids = []\n    for _ in range(n):\n        planetoids.append(list(map(int, stdin.split())))\n    planetoids = sorted(planetoids, key=lambda planetoid: (planetoid[1], planetoid[2], planetoid[0]))\n    ans = 1\n    last_collision = (0, 0, 0)\n    for planetoid in planetoids:\n        x, y, z = planetoid[1], planetoid[2], planetoid[0]\n        if x == last_collision[0] and y == last_collision[1] and z == last_collision[2]:\n            continue\n        ans += 1\n        last_collision = (x, y, z)\n    return str(ans)"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n_x, n_y, n_z, m, t = map(int, stdin.split())\n    xs = range(n_x)\n    ys = range(n_y)\n    zs = range(n_z)\n    planets = []\n    for _ in range(m):\n        x, y, z, v_x, v_y, v_z = map(int, stdin.split())\n        planets.append((x, y, z, v_x, v_y, v_z))\n    t = 0\n    collisions = 0\n    while collisions <= t:\n        collisions = 0\n        for x in xs:\n            for y in ys:\n                for z in zs:\n                    if (x, y, z) in planets:\n                        continue\n                    n = 0\n                    for m_, x_, y_, z_, vx_, vy_, vz_ in planets:\n                        if (x_, y_, z_) == (x, y, z):\n                            n += 1\n                            if n > m:\n                                collisions += 1\n                                planets.remove((m_, x_, y_, z_, vx_, vy_, vz_))\n                                break\n                            else:\n                                break\n                if n > m:\n                    collisions += 1\n                    planets.remove((m_, x, y, z, vx_, vy_, vz_))\n        t += 1\n    planets.sort(key=lambda p: (p[0], p[1], p[2]))\n    return str(len(planets)) + '\\n' + '\\n'.join(map(lambda p: 'P{}: {} {} {} {} {} {}'.format(*p), enumerate(planets)))"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, N_x, N_y, N_z = map(int, stdin.split())\n\n    # build grid of cubes\n    grid = [[[] for _ in range(N_x)] for _ in range(N_y)]\n    for i, j, k in itertools.product(range(N_x), range(N_y), range(N_z)):\n        grid[i][j].append((i, j, k))\n\n    # get mass and velocity, find collisions\n    masses = []\n    velocities = []\n    for i, j, k in itertools.product(range(N_x), range(N_y), range(N_z)):\n        masses.append(int(input()))\n        velocities.append([int(input()) for _ in range(3)])\n\n    def get_next_step(mass, velocity):\n        velocities = []\n        for i, j, k in itertools.product(range(N_x), range(N_y), range(N_z)):\n            velocities.append([i, j, k])\n\n        # find collisions\n        collisions = []\n        for i, j, k in itertools.product(range(N_x), range(N_y), range(N_z)):\n            collisions.extend(itertools.product(grid[i][j], velocities[i][j]))\n        collisions = list(set(collisions))\n\n        # return next step\n        next_velocities = []\n        for _, (i, j, k) in enumerate(collisions):\n            next_velocities.append(velocity)\n        return next_velocities\n\n    total_velocities = []\n    for i, j, k in itertools.product(range(N_x), range(N_y), range(N_z)):\n        total_velocities.append([i, j, k])\n    while len(total_velocities) > 0:\n        velocities = get_next_step(masses.pop(), total_velocities.pop())\n        masses = list(itertools.accumulate(masses))\n        for i, j, k in velocities:\n            masses.append(masses[-1] + i)\n            total_velocities.append([j, k])\n\n    # find max\n    p = 1\n    max_i = 0\n    for i, (x, y, z) in enumerate(total_velocities):\n        if x == max_i:\n            p += 1\n            max_i = y\n        elif x > max_i:\n            max_i = y\n            p = 1\n            max_i = i\n    print(p)\n    print(\" \".join(str(x) for x in total_velocities[max_i]))\n    return \" \".join(str(x) for x in total_velocities[max_i])\n\nsolution(stdin)\n\n\"\"\"\nfrom collections import deque\n\ndef"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n_x, n_y, n_z = tuple(map(int, stdin.split()))\n    masses = list(map(int, stdin.split()[1:]))\n    start_times = {m: i for i, m in enumerate(masses)}\n    current_time = 0\n    planetoids = {i: m, (0, 0, 0)}\n    while planetoids:\n        planetoids = {i: m, (0, 0, 0) for i, m in planetoids.items() if m}\n        for planetoid in planetoids.copy().values():\n            if planetoid:\n                for new_planetoid in calc_next_planetoid(planetoid, planetoids, start_times, current_time, n_x, n_y, n_z):\n                    planetoids[new_planetoid] = new_planetoid\n        planetoids = {i: m for i, m in planetoids.items() if m}\n        current_time += 1\n    planetoids = {i: m for i, m in planetoids.items() if m}\n    planetoids = sorted(planetoids.items(), key=lambda x: (x[0], x[1][0], x[1][1], x[1][2]))\n    return''.join(str(planetoid[0]) for planetoid in planetoids)\n\n\ndef"
    },
    {
        "number": 3319,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n_x, n_y, n_z = map(int, stdin.split())\n    def orbit(i: int):\n        return [i] if n_x*n_x+n_y*n_y+n_z*n_z <= i else [i] + orbit(i - n_x*n_x - n_y*n_y - n_z*n_z)\n    return f\"{len(orbit(n_x*n_x+n_y*n_y+n_z*n_z))} {orbit(0)}\""
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split())\n        a, b = a - 1, b - 1\n        roads[a].append((b, w))\n        roads[b].append((a, w))\n    visited = [False] * n\n    distance = [1e6] * n\n    distance[0] = 0\n    q.sort()\n    for day in range(q):\n        s, t = q[day] - 1, q[day]\n        if visited[s] and visited[t]:\n            continue\n        visited[s] = True\n        visited[t] = True\n        for n1, d in roads[s]:\n            if not visited[n1]:\n                distance[n1] = min(distance[n1], distance[s] + d)\n        for n2, d in roads[t]:\n            if not visited[n2]:\n                distance[n2] = min(distance[n2], distance[t] + d)\n    return''.join([str(distance[i]) for i in range(n)])\nprint(solution(input()))\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = [int(i) for i in stdin.split()]\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b, w = [int(i) for i in stdin.split()]\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n    visited = set()\n    min_cost = {i: float('inf') for i in range(n)}\n    min_cost[0] = 0\n    q = deque([0])\n    while q:\n        u = q.popleft()\n        visited.add(u)\n        for v, w in graph[u]:\n            if v in visited:\n                continue\n            visited.add(v)\n            if min_cost[v] > w + min_cost[u]:\n                min_cost[v] = w + min_cost[u]\n                q.append(v)\n    return '\\n'.join(map(str, min_cost.values()))\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join(\n        map(str, input().split())\n        for _ in range(int(stdin))\n    )"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        edges.append(tuple(map(int, stdin.split())))\n    dp = [1] + [0] * n\n    for _ in range(1, n):\n        for u, v, w in edges:\n            dp[v] = max(dp[v], dp[u] + w)\n    return \" \".join(map(str, dp[1:]))\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    graph = collections.defaultdict(list)\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u - 1].append((v - 1, w))\n        graph[v - 1].append((u - 1, w))\n    path = {}\n    cost = 0\n    for _ in range(q):\n        s, t = map(int, stdin.split())\n        path[s - 1] = t - 1\n        cost += graph[s - 1][0][1]\n        for city in graph[s - 1]:\n            new_cost = cost | city[1]\n            if city[0] not in path:\n                path[city[0]] = t - 1\n                cost = new_cost\n            elif new_cost < path[city[0]]:\n                path[city[0]] = t - 1\n                cost = new_cost\n    for _ in range(q):\n        cost += graph[path[path[_]]][0][1]\n        path[path[_]] = path[path[_] - 1]\n    return str(cost)\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = [int(i) for i in stdin.split(' ')]\n    cities = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = [int(i) for i in stdin.split(' ')]\n        cities[a].append((b, w))\n        cities[b].append((a, w))\n    days = list(map(int, stdin.split(' ')))\n    transport_cities = []\n    visited_cities = []\n    for i in range(1, n+1):\n        if i not in visited_cities:\n            transport_cities.append(i)\n            visited_cities.append(i)\n            print(i)\n            days_on_path = 0\n            for j in range(q):\n                city1 = transport_cities[j]\n                city2 = days[j]\n                days_on_path += shortest_path_between_cities(city1, city2, visited_cities)\n            print(days_on_path)\n            visited_cities.pop(-1)\n            transport_cities.pop(-1)\n\ndef"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n, m = list(map(int, input_lines[0].split()))\n    roads = []\n    for i in range(1, m + 1):\n        a, b, w = list(map(int, input_lines[i].split()))\n        roads.append((a, b, w))\n    n = n\n    q = int(input_lines[-1])\n    days = set()\n    for i in range(q):\n        s, t = list(map(int, input_lines[i + 1].split()))\n        days.add(s)\n        days.add(t)\n    # print(roads)\n    # print(n)\n    # print(days)\n    costs = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                for road in roads:\n                    if road[0] == i and road[1] == j:\n                        costs[i][j] = costs[i][j] + road[2]\n                    elif road[0] == j and road[1] == i:\n                        costs[i][j] = costs[i][j] + road[2]\n    for day in days:\n        for i in range(n):\n            for j in range(n):\n                if i!= j and day in days:\n                    costs[i][j] = costs[i][j] | costs[i][day] | costs[day][j]\n    # print(costs)\n    max_dist = float(\"-inf\")\n    max_s = float(\"-inf\")\n    for i in range(n):\n        max_dist = max(max_dist, costs[i][i])\n        max_s = max(max_s, costs[i][i])\n    max_dist = max(max_dist, max_s)\n    # print(max_dist)\n    return max_dist\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    graph = collections.defaultdict(list)\n    for _ in range(m):\n        a, b, w = map(int, stdin.split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    # dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    # dp[0][0] = 0\n    # for i in range(n + 1):\n    #     dp[0][i] = 0\n    # for i in range(1, n + 1):\n    #     for j in range(i, n + 1):\n    #         for b, w in graph[j]:\n    #             dp[i][b] = min(dp[i][b], dp[i - 1][j] + w)\n    # return '\\n'.join(map(str, dp[n][1:]))\n\n    # Bellman-Ford\n    dist = [float('inf')] * (n + 1)\n    dist[0] = 0\n\n    for _ in range(q):\n        for i in range(1, n + 1):\n            for b, w in graph[i]:\n                dist[i] = min(dist[i], dist[i - 1] + w)\n\n    # print(dist)\n    return '\\n'.join(map(str, dist[1:]))\n"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = list(map(int, stdin.split()))\n    # m = 5\n    # n = 4\n    # q = 4\n    # m = 6\n    # n = 5\n    # q = 8\n    # m = 8\n    # n = 9\n    # q = 9\n    # m = 10\n    # n = 10\n    # q = 10\n    # m = 11\n    # n = 9\n    # q = 9\n    # m = 12\n    # n = 11\n    # q = 11\n    # m = 13\n    # n = 12\n    # q = 13\n    # m = 14\n    # n = 13\n    # q = 13\n    # m = 15\n    # n = 14\n    # q = 14\n    # m = 16\n    # n = 16\n    # q = 16\n    # m = 17\n    # n = 17\n    # q = 17\n    # m = 18\n    # n = 18\n    # q = 18\n    # m = 19\n    # n = 19\n    # q = 19\n    # m = 20\n    # n = 20\n    # q = 20\n    # m = 21\n    # n = 21\n    # q = 21\n    # m = 22\n    # n = 22\n    # q = 22\n    # m = 23\n    # n = 23\n    # q = 23\n    # m = 24\n    # n = 24\n    # q = 24\n    # m = 25\n    # n = 25\n    # q = 25\n    # m = 26\n    # n = 26\n    # q = 26\n    # m = 27\n    # n = 27\n    # q = 27\n    # m = 28\n    # n = 28\n    # q = 28\n    # m = 29\n    # n = 29\n    # q = 29\n    # m = 30\n    # n = 30\n    # q = 30\n    # m = 31\n    # n = 31\n    # q = 31\n    # m = 32\n    # n = 32\n    # q = 32\n    # m = 33\n    # n = 33\n    # q = 33\n    # m = 34\n    # n = 34\n    # q = 34\n    # m = 35\n    # n = 35\n    # q = 35\n    # m = 36\n    # n = 36\n    # q = 36\n    # m = 37\n    # n = 37\n    # q = 37\n    # m = 38\n    # n = 38\n    # q = 38\n    # m = 39\n    # n = 39\n    # q = 39\n    # m = 40\n    # n = 40\n    # q = 40\n    # m = 41\n    # n = 41\n    # q = 41\n    # m = 42\n    # n = 42\n    # q = 42\n    # m = 43\n    # n = 43\n    # q = 43\n    # m = 44\n    # n = 44\n    # q = 44\n    # m = 45\n    # n = 45\n    # q = 45\n    # m = 46\n    # n = 46\n    # q = 46\n    # m = 47\n    # n = 47\n    # q = 47\n    # m = 48\n    # n = 48\n    # q = 48\n    # m = 49\n    # n = 49\n    # q = 49\n    # m = 50\n    # n = 50\n    # q = 50\n    # m = 51\n    # n = 51\n    # q = 51\n    # m = 52\n    # n = 52\n    # q = 52\n    # m = 53\n    # n = 53\n    # q = 53\n    # m = 54\n    # n = 54\n    # q = 54\n    # m = 55\n    # n = 55\n    # q = 55\n    # m = 56\n    # n = 56\n    # q = 56\n    # m = 57\n    # n = 57\n    # q = 57\n    # m = 58\n    # n = 58\n    # q = 58\n    # m = 59\n    # n = 59\n    # q = 59\n    # m = 60\n    # n = 60\n    # q = 60\n    # m = 61\n    # n = 61\n    # q = 61\n    # m = 62\n    # n = 62\n    # q = 62\n    # m = 63\n    # n = 63\n    # q = 63\n    # m = 64\n    # n = 64\n    # q = 64\n    # m = 65\n    # n = 65\n    # q = 65\n    # m = 66\n    # n = 66\n    # q = 66\n    # m = 67\n    # n = 67\n    # q = 67\n    # m = 68\n    # n = 68\n    # q = 68\n    # m = 69\n    # n = 69\n    # q = 69\n    # m = 70\n    # n = 70\n    # q = 70\n    # m = 71\n    # n = 71\n    # q = 71\n    # m = 72\n    # n = 72\n    # q = 72\n    # m = 73\n    # n = 73\n    # q = 73\n    # m = 74\n    # n = 74\n    # q = 74\n    # m = 75\n    # n = 75\n    # q = 75\n    # m = 76\n    # n = 76\n    # q = 76\n    # m = 77\n    # n = 77\n    # q = 77\n    # m = 78\n    # n = 78\n    # q = 78\n    # m = 79\n    # n = 79\n    # q = 79\n    # m = 80\n    # n = 80\n    # q = 80\n    # m = 81\n    # n = 81\n    # q = 81\n    # m = 82\n    # n = 82\n    # q = 82\n    # m = 83\n    # n = 83\n    # q = 83\n    # m = 84\n    # n = 84\n    # q = 84\n    # m = 85\n    # n = 85\n    # q = 85\n    # m = 86\n    # n = 86\n    # q = 86\n    # m = 87\n    # n = 87\n    # q = 87\n    # m = 88\n    # n = 88\n    # q = 88\n    # m = 89\n    # n = 89\n    # q = 89\n    # m = 90\n    # n = 90\n    # q = 90\n    # m = 91\n    # n = 91\n    # q = 91"
    },
    {
        "number": 3320,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = defaultdict(list)\n    for i in range(m):\n        a, b, w = map(int, stdin.split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    q = int(stdin)\n    dp = [[0] * (n+1) for _ in range(q+1)]\n    dp[0][1] = 1\n    for i in range(1, q+1):\n        for s in range(n+1):\n            for t in range(n+1):\n                for j in graph[s]:\n                    if dp[i-1][j[0]] == 1:\n                        dp[i][t] = 1\n                        break\n                for k in graph[t]:\n                    if dp[i-1][k[0]] == 1:\n                        dp[i][t] = 1\n                        break\n    for i in range(q):\n        print(dp[i][i+1])\n    return '''\ndef"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    starting, result, expected = stdin.split(\"\\n\"), stdin.split(\"\\n\"), stdin.split(\"\\n\")\n    return f\"{len(solution(starting))}\\n\" + \"\\n\".join([str(starting.index(s) + 1) + \"\\n\" + \"\\n\".join(result) for s in expected])\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    P = list(map(int, stdin.split()))\n    if (len(P) < N):\n        P = P * (N // len(P) + 1)\n        P = P[:N]\n    l = {i: set() for i in range(1, N + 1)}\n    for i in range(1, N):\n        l[A[i]].add(A[i - 1])\n        l[A[i - 1]].add(A[i])\n    for i in range(1, N + 1):\n        if i in P:\n            l[i].add(P[i - 1])\n    c = 0\n    for i in range(1, N + 1):\n        if not l[i]:\n            c += 1\n            if i == N:\n                return str(c)\n            for k in range(1, N + 1):\n                if not l[k]:\n                    l[i].add(k)\n                    l[k].add(i)\n                    break\n    return str(c)\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    starting = list(map(int, stdin.split()))\n    resulting = list(map(int, stdin.split()))\n    return stdin\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, frog_1, frog_2, frog_3, frog_4, frog_5 = map(int, stdin.split())\n    frog_1, frog_2, frog_3, frog_4, frog_5 = map(int, stdin.split())\n\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 1, 2, 3, 4, 5\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 5, 6, 4, 3, 2\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 2, 1, 6, 5, 4\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 6, 1, 2, 5, 4\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 3, 1, 2, 5, 4\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 4, 1, 2, 3, 5\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 5, 1, 2, 3, 4\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 2, 5, 1, 3, 4\n    frog_1_id, frog_2_id, frog_3_id, frog_4_id, frog_5_id = 1, 2, 3, 4, 5\n\n    return \" \".join([str(frog_1_id), str(frog_2_id), str(frog_3_id), str(frog_4_id), str(frog_5_id)])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    result = []\n    start_seq = stdin.split()\n    print(start_seq)\n    end_seq = stdin.split()\n    print(end_seq)\n    for i in range(len(start_seq)):\n        start_seq[i] = int(start_seq[i])\n    for i in range(len(end_seq)):\n        end_seq[i] = int(end_seq[i])\n    return start_seq\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    frogs = stdin.split('\\n')\n    frogs.pop(0)\n    frogs = list(map(lambda frog: int(frog), frogs))\n    frogs.sort()\n    for frog_id in range(1, len(frogs)):\n        frogs.insert(frog_id - 1, frogs[frog_id])\n    return '\\n'.join(map(lambda frog: str(frog), frogs))"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdout\n"
    },
    {
        "number": 3321,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    frog_sequence = list(map(int, stdin.strip().split()))\n    frog_sequence_length = len(frog_sequence)\n    frog_sequence_forward = frog_sequence[: frog_sequence_length // 2]\n    frog_sequence_backward = frog_sequence[frog_sequence_length // 2:]\n    frog_sequence_backward.reverse()\n    frog_sequence = frog_sequence_forward + frog_sequence_backward\n    print(\"\\n\".join(map(str, frog_sequence)))\n    return \"\"\n"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    cities = [[int(i) for i in stdin.split()] for _ in range(n)]\n    shops = [[int(i) for i in stdin.split()] for _ in range(m)]\n    best = float('inf')\n    for i in range(n):\n        shops_visited = [[] for _ in range(m)]\n        for j in range(k):\n            if j!= i:\n                shops_visited[shops[j][0]].append(shops[j][1])\n        if len(shops_visited[shops[0][0]]) == 0 or len(shops_visited[shops[1][0]]) == 0 or len(shops_visited[shops[2][0]]) == 0:\n            continue\n        current_best = float('-inf')\n        for s in range(k):\n            if current_best == float('-inf'):\n                break\n            cost = 0\n            shops_visited_for_each_city = [shops_visited[i] for i in range(m)]\n            for a in range(n):\n                if a == i:\n                    continue\n                if len(shops_visited[shops[a][0]]) == 0:\n                    continue\n                for b in range(len(shops_visited[shops[a][0]])):\n                    if len(shops_visited[shops[a][0]]) == 0:\n                        continue\n                    if shops_visited[shops[a][0]][b] in shops_visited_for_each_city[i]:\n                        cost += shops[a][1]\n                        break\n            if cost > current_best:\n                current_best = cost\n        if current_best < best:\n            best = current_best\n    if best == float('-inf'):\n        return -1\n    return str(best)"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.strip().split())\n    ans = 0\n    for _ in range(k):\n        a, p, b, q = map(int, stdin.strip().split())\n        if a <= m and b <= m:\n            ans += (p + q) * min(p, q)\n    return str(ans)"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split()\n    n, m, k = map(int, a.split())\n    data = []\n    for _ in range(n):\n        data.append(list(map(int, b.split())))\n    res = float('inf')\n    for _ in range(1, m+1):\n        cost = 0\n        if _!= int(_):\n            cost = 10**7\n        elif _ == int(_):\n            cost = 0\n        else:\n            cost = k\n        for i in range(n):\n            if i!= _:\n                cost += data[i][_]\n        res = min(res, cost)\n    return str(res) if res < 10**7 else -1"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    lines = list(map(lambda line: line.split(), lines))\n    n, m, k = list(map(int, lines[0]))\n    a = list(map(int, lines[1]))\n    p = list(map(int, lines[2]))\n    b = list(map(int, lines[3]))\n    q = list(map(int, lines[4]))\n\n    a.sort()\n    b.sort()\n    q.sort()\n    p.sort()\n    for i in range(n):\n        if a[i]!= i+1:\n            return '-1'\n    for i in range(n):\n        if b[i]!= i+1:\n            return '-1'\n    for i in range(n):\n        if q[i]!= i+1:\n            return '-1'\n\n    if k > m:\n        return '-1'\n\n    cost = [[99999999999 for i in range(n+1)] for j in range(k+1)]\n\n    for i in range(m, -1, -1):\n        cost[i][0] = 0\n\n    for i in range(1, m+1):\n        cost[0][i] = p[i-1]\n\n    for i in range(1, k+1):\n        for j in range(n+1):\n            for k in range(1, m+1):\n                if j == 0:\n                    cost[i][j] = cost[i][j]\n                else:\n                    if a[j-1] == k:\n                        cost[i][j] = min(cost[i][j], cost[i-1][j-1] + q[k-1])\n                    elif b[j-1] == k:\n                        cost[i][j] = min(cost[i][j], cost[i-1][j-1] + p[k-1])\n                    else:\n                        cost[i][j] = min(cost[i][j], cost[i-1][j-1] + q[k-1])\n\n    for i in range(1, m+1):\n        if cost[k][i] == 999999999999:\n            return '-1'\n\n    return str(cost[k][n])"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    spent_knock_off = [map(int, stdin.split()) for _ in range(m)]\n    spent_original = [map(int, stdin.split()) for _ in range(n)]\n    spent_knock_off.sort(key=lambda x: x[1])\n    spent_original.sort(key=lambda x: x[2])\n    spent_original.sort(key=lambda x: x[0])\n    tot_original = 0\n    tot_knock_off = 0\n    for s in spent_original:\n        tot_original += s[0]*s[1]\n    for s in spent_knock_off:\n        tot_knock_off += s[0]*s[1]\n    print(tot_original, tot_knock_off)\n    if tot_knock_off >= tot_original:\n        return '-1'\n    else:\n        return str(tot_original - tot_knock_off)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n < 1 or m < 1 or k < 1:\n        return -1\n    ans = -1\n    for a in range(m):\n        for b in range(a + 1, m):\n            for c in range(b + 1, m):\n                for d in range(c + 1, m):\n                    total = (a + 30) * (b + 10) * (c + 50) * (d + 20)\n                    if total <= k:\n                        ans = max(ans, total)\n    return str(ans)\n"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.strip().split())\n    shop = [(int(i), int(j)) for i, j in [stdin.strip().split() for _ in range(n)]]\n    antique = [(int(i), int(j)) for i, j in [stdin.strip().split() for _ in range(m)]]\n    knock_off = [(int(i), int(j)) for i, j in [stdin.strip().split() for _ in range(m)]]\n\n    def cost(item, shop):\n        a, b = item\n        p, q = shop[a-1]\n        return p if a == b else q\n\n    def total_cost(antique, shop):\n        return sum(map(lambda x: cost(x, shop), antique))\n\n    for i in range(k):\n        if total_cost(antique, shop) <= m:\n            return f'{total_cost(antique, shop)}'\n        else:\n            shop = [(i[0], i[1]) for i in knock_off if i[0] < m]\n            antique = [(i[0], i[1]) for i in antique if i[0] < m]\n\n    return f'-1'"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    n, m, k = map(int, stdin.split())\n    ab = [[int(x) for x in stdin.split()] for _ in range(n)]\n    ad = [[int(x) for x in stdin.split()] for _ in range(m)]\n    ab.sort(key=lambda x: x[0])\n    ad.sort(key=lambda x: x[0])\n    max_ab = n - 1\n    max_ad = m - 1\n    min_cost = float(\"inf\")\n    for i in range(1, m + 1):\n        if ab[i][0] > ad[i][0]:\n            cost = min(ab[i][1], ad[i - 1][1]) * ab[i][2] + min(ab[i][1], ad[i - 1][2]) * ad[i - 1][2]\n            if cost < min_cost:\n                min_cost = cost\n    for i in range(1, n + 1):\n        if ab[i][0] > ad[i][0]:\n            cost = min(ab[i - 1][1], ad[i - 1][1]) * ab[i][2] + min(ab[i - 1][1], ad[i - 1][2]) * ad[i - 1][2]\n            if cost < min_cost:\n                min_cost = cost\n    if min_cost == float(\"inf\"):\n        return -1\n    return str(min_cost)\n\n\nprint(solution(sys.stdin.read()))"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    return str(min(b for a, p, b, q in zip(a, a, b, c) if a + p + q < k))\n"
    },
    {
        "number": 3322,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.strip().split())\n    antiques = [[int(i) for i in stdin.strip().split()] for _ in range(n)]\n    antiques.sort()\n    costs = []\n    for i in range(1, m):\n        if not costs:\n            costs.append((int(antiques[i][1]), int(antiques[i][2])))\n        else:\n            curr_antique = min(costs)\n            if curr_antique[0] > int(antiques[i][1]):\n                costs.append((int(antiques[i][1]), int(antiques[i][2])))\n            elif curr_antique[0] < int(antiques[i][1]):\n                costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n            else:\n                costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n    if costs:\n        curr_antique = min(costs)\n        if curr_antique[0] > int(antiques[i][1]):\n            costs.append((int(antiques[i][1]), int(antiques[i][2])))\n        elif curr_antique[0] < int(antiques[i][1]):\n            costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n        else:\n            costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n    if costs:\n        curr_antique = min(costs)\n        if curr_antique[0] > int(antiques[i][1]):\n            costs.append((int(antiques[i][1]), int(antiques[i][2])))\n        elif curr_antique[0] < int(antiques[i][1]):\n            costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n        else:\n            costs.append((curr_antique[0] + int(antiques[i][1]), curr_antique[1] + int(antiques[i][2])))\n    return '-1' if costs else str(curr_antique[0])\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for _ in range(t):\n        N = int(stdin.strip())\n        juice = []\n        for _ in range(N):\n            juice.append(stdin.strip())\n        juice.sort()\n        count = 1\n        for i in range(N-1):\n            if juice[i] + juice[i+1] >= juice[i+1]:\n                count += 1\n        print('Case #%d: %d' % (_ + 1, count))\n    return ''\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    for i in range(T):\n        N = int(stdin)\n        G = []\n        for j in range(N):\n            G.append([int(i) for i in stdin.split()[j * 3 + 1:j * 3 + 4]])\n        M = []\n        for j in range(N):\n            M.append([i for i in G[j] if i <= G[j][0]])\n        return \"Case #{}: {}\".format(i + 1, max([len(list(i)) for i in M]))"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    for i in range(T):\n        n = int(stdin.strip())\n        fruits = stdin.strip().split()\n        fruits = [int(x) for x in fruits]\n        fruits.sort(key=lambda x: -x)\n        print(\"Case #{}: {}\".format(i + 1, max(1, sum(fruits[:n]))))\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    if T == 1:\n        return \"Case #1: 1\"\n    if T == 2:\n        return \"Case #2: 2\"\n    people = []\n    for i in range(T):\n        people.append(list(map(int, stdin.split())))\n    minimum = 10000\n    for i in range(len(people)):\n        for j in range(len(people[i])):\n            minimum = min(minimum, people[i][j])\n    res = []\n    for i in range(len(people)):\n        res.append(str(i+1) + ':' + str(minimum))\n    return '\\n'.join(res)\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    the fraction of each of the 3 juices in the drink.\n    maximum number of people who would like the drink.\n    '''\n    n = int(stdin)\n    _N = []\n    for i in range(1, n + 1):\n        A, B, C = map(int, input().split())\n        _N.append((A, B, C))\n    return str(solution_part2(_N))\n\n\ndef"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    for t in range(T):\n        N = int(stdin)\n        mfracs = [int(i) for i in stdin.split()]\n        max = 0\n        for i in range(N):\n            max = max(max, (mfracs[0]+mfracs[1]+mfracs[2])//10000)\n        print(f\"Case #{t+1}: {max}\")\nsolution(input())\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for i in range(t):\n        x = int(stdin.split(\" \")[i])\n        data = stdin.split(\" \")[i+1:]\n        s = \"\"\n        for a, b, c in data:\n            a, b, c = int(a), int(b), int(c)\n            if a + b + c > x:\n                s += \"Case #{}: {}\\n\".format(i+1, x)\n                break\n            else:\n                if a > b and a > c:\n                    s += \"Case #{}: {}\\n\".format(i+1, x)\n                    break\n                elif b > a and b > c:\n                    s += \"Case #{}: {}\\n\".format(i+1, x)\n                    break\n                else:\n                    s += \"Case #{}: {}\\n\".format(i+1, x)\n                    break\n        print(s)\n    return stdin\n\nsolution(input())\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    for line in lines:\n        splits = line.split()\n        N = int(splits[0])\n        splits.pop(0)\n        splits = map(lambda x: int(x) / 10000, splits)\n        fractions = list(splits)\n        fractions.sort(reverse=True)\n        max_people = N // sum(fractions)\n        print(f\"Case #{1}: {max_people}\")\n        return\nsolution(sys.stdin)\n"
    },
    {
        "number": 3323,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    total = []\n    for line in stdin.split(\"\\n\"):\n        total.append(line.split())\n    return str(max_count(total))\n\ndef"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def solve(equation: str):\n        data = equation.split('\\n')\n        n = int(data[0])\n        elements = set()\n        for i in range(1, n + 1):\n            if data[i]!= '':\n                elements.update(data[i].split())\n\n        counts = defaultdict(int)\n        for e, c in map(parse_input, data[1:]):\n            if e in elements:\n                counts[e] += c\n                if e in counts:\n                    counts[e] -= c\n        result = ''\n        for e, c in counts.items():\n            result += str(c) + e if c > 0 else str(-c) + e +''\n        return result\n\n    def parse_input(equation: str):\n        data = equation.split()\n        if data[0] == '+':\n            sign, m = 1, int(data[1])\n        elif data[0] == '-':\n            sign, m = -1, int(data[1])\n        else:\n            return None, None\n        if data[1] == '1':\n            element, count = data[2], 1\n        else:\n            element, count = data[1:3]\n        return element, count * sign\n\n    return solve(stdin)\n\ndef"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    fractions = stdin.split('\\n')\n    fractions = [f.split(' ') for f in fractions]\n    fractions = [[int(x) if x else 0 for x in f] for f in fractions]\n    signs = {'+1': 1, '-1': -1}\n    balanced_fractions = []\n    for fraction in fractions:\n        left = []\n        right = []\n        for i in range(0, 2):\n            if fraction[i]:\n                if fraction[i] * 2!= 1:\n                    left.append(fraction[i])\n                if fraction[i]!= 1 and fraction[i] * 2!= 1:\n                    right.append(fraction[i])\n        sign = signs[fraction[2]]\n        left = sorted(left, reverse=True)\n        right = sorted(right, reverse=True)\n        fraction[2] = sign\n        if not (len(left) == 0 or len(right) == 0):\n            if sign == 1:\n                left = left[:left.index(1)]\n            else:\n                right = right[:right.index(1)]\n            right = [-a for a in right]\n            if len(left) < len(right):\n                left = left[:len(right)]\n            else:\n                right = right[:len(left)]\n            left = [-a for a in left]\n            fraction = left + right\n        balanced_fractions.append(fraction)\n    answer =''.join(map(str, balanced_fractions))\n    return answer\nprint(solution(input()))\n\"\"\"\n\n\"\"\"\n## Debugging \n\ndef"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    lines = stdin.splitlines()\n    n_mols = len(lines)\n    M = int(lines[0])\n    counts = [[0] * 2 for _ in range(M)]\n    for i in range(n_mols):\n        sign = int(lines[i].split()[0])\n        m = int(lines[i].split()[1])\n        if sign == 1:\n            counts[m - 1][0] += 1\n        else:\n            counts[m - 1][1] += 1\n\n    def find_element(counts: List[int], element: str) -> List[int]:\n        \"\"\"\n        Returns a list of how many times each element appears in the counts list\n        >>> find_element([1,1,1], \"H\")\n        [1, 1]\n        \"\"\"\n        return [counts[i][0] if counts[i][0] > 0 else 0 for i in range(len(counts)) if counts[i][1] == element]\n\n    def balance_equation(counts: List[int]) -> List[int]:\n        \"\"\"\n        Balances the equation given the counts\n        >>> balance_equation([1,1,1])\n        [0, 0]\n        \"\"\"\n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if counts[i][0] == 0 and counts[j][0] == 0 and \\\n                        counts[i][1] == counts[j][1]:\n                    counts[i][1] += counts[j][1]\n                    counts[j][0] += counts[i][0]\n                    counts[i][0] = 0\n\n        return [counts[i][0] if counts[i][0] > 0 else 0 for i in range(len(counts))]\n\n    def find_common_factors(counts: List[int]) -> List[int]:\n        \"\"\"\n        Returns a list of how many common factors each element has\n        >>> find_common_factors([1,1,1])\n        [1]\n        \"\"\"\n        common_factors = [counts[i][1] for i in range(len(counts))]\n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if counts[i][0] == 0 and counts[j][0] == 0:\n                    if counts[i][1] == counts[j][1]:\n                        common_factors[i] = max(common_factors[i],\n                                                common_factors[j])\n        return common_factors\n\n    def find_min_counts(counts: List[int]) -> List[int]:\n        \"\"\"\n        Returns a list of min numbers that each element has\n        >>> find_min_counts([1,1,1])\n        [1]\n        \"\"\"\n        min_counts = [counts[i][0] for i in range(len(counts))]\n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if counts[i][0] == 0 and counts[j][0] == 0:\n                    if counts[i][1] == counts[j][1]:\n                        min_counts[i] = min(min_counts[i], min_counts[j])\n        return min_counts\n\n    def find_max_counts(counts: List[int]) -> List[int]:\n        \"\"\"\n        Returns a list of max numbers that each element has\n        >>> find_max_counts([1,1,1])\n        [1]\n        \"\"\"\n        max_counts = [counts[i][0] for i in range(len(counts))]\n        for i in range(len(counts)):\n            for j in range(i + 1, len(counts)):\n                if counts[i][0] == 0 and counts[j][0] == 0:\n                    if counts[i][1] == counts[j][1]:\n                        max_counts[i] = max(max_counts[i], max_counts[j])\n        return max_counts\n\n    min_counts = find_min_counts(counts)"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n_reactant, n_product = stdin.split()\n    n_reactant = int(n_reactant)\n    n_product = int(n_product)\n    n_element_dict = {}\n    for i in range(n_reactant):\n        element_and_count = input().split()\n        element, count = element_and_count\n        count = int(count)\n        if element in n_element_dict.keys():\n            n_element_dict[element] += count\n        else:\n            n_element_dict[element] = count\n    n_element_list = list(n_element_dict.items())\n    n_element_list.sort(key=lambda x: x[0])\n    n_element_list.sort(key=lambda x: x[1], reverse=True)\n    total_reactant_count = 0\n    total_product_count = 0\n    i = 0\n    while i < n_product:\n        if total_reactant_count >= total_product_count:\n            total_reactant_count += n_element_list[i][1]\n            i += 1\n        else:\n            total_product_count += n_element_list[i][1]\n            i += 1\n    return str(total_reactant_count) +'' + str(total_product_count)\n"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    equation = {}\n    for i in range(1, n + 1):\n        line = stdin.split()[i]\n        sign = int(line[0])\n        if sign == -1:\n            del equation[line[1]]\n        else:\n            equation[line[1]] = int(line[2:])\n    equation = sorted(equation.items(), key=lambda x: x[1])\n    equation_str = \"\"\n    for e in equation:\n        equation_str += f\"{e[0]} {e[1]}\\n\"\n    return equation_str"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    data = []\n    for line in stdin:\n        line = line.split(\" \")\n        data.append(line)\n    ans = 0\n    for i in range(len(data)):\n        molecules = 1\n        for j in range(1, len(data[i])):\n            molecules *= data[i][j]\n        ans = max(ans, molecules)\n    return str(ans)"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mat = [['.' for j in range(m)] for i in range(n)]\n    for i in range(n):\n        line = stdin.split()\n        for j in range(len(line)):\n            if line[j] == '+1':\n                mat[i][j] = 1\n            elif line[j] == '-1':\n                mat[i][j] = -1\n    for i in range(n):\n        for j in range(m):\n            mat[i][j] = int(mat[i][j])\n    for i in range(n):\n        for j in range(m):\n            if j < m-1:\n                mat[i][j] = mat[i][j] + mat[i][j+1]\n            if i < n-1:\n                mat[i][j] = mat[i][j] + mat[i+1][j]\n    max_index = 0\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] > max_index:\n                max_index = mat[i][j]\n    total = 0\n    for i in range(n):\n        for j in range(m):\n            if mat[i][j] == max_index:\n                total = total + (max_index * (max_index-1)) // 2\n    return str(total)\n"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    result = []\n    \n    # Combine each line into a list of (sign,element,count) tuples\n    for line in lines:\n        sign,molecules = line.split()\n        sign = int(sign)\n        molecules = molecules.split(' ')\n        tuple_list = []\n        for molecule in molecules:\n            elements = molecule.split('_')\n            if sign == -1:\n                elements.reverse()\n            tuple_list.append((sign,elements,int(molecule[1:])))\n        result.append(tuple_list)\n        \n    # Calculate the balance\n    # This is the sum of the number of each element (count) in each list\n    total_elements = 0\n    for tuple_list in result:\n        total_elements += sum([elements[1] for elements in tuple_list])\n        \n    # Sort the lists by the number of elements (count) in each list\n    sorted_result = []\n    while len(result)!= 0:\n        # Get the minimum number of elements\n        min_num_elements = min([elements[1] for elements in result])\n        # Remove the molecules with that number of elements\n        result = [molecule for molecule in result if molecule[1] == min_num_elements]\n        # Append the number of elements to the sorted list\n        sorted_result.append(min_num_elements)\n    \n    # Return the sorted list\n    return''.join([str(element) for element in sorted_result])"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def formula(line):\n        \"\"\"\n        >>> formula('')\n        ''\n        >>> formula('+1 2 H 2 O 1')\n        '+1 2 H 2 O 1'\n        >>> formula('+1 2 C 1 O 2')\n        '+1 2 C 1 O 2'\n        >>> formula('-1 1 O 2')\n        '+1 2 C 1 O 2'\n        >>> formula('-1 3 C 6 H 12 O 6')\n        '+1 2 C 1 O 2'\n        \"\"\"\n        sign, m, *elements, counts = line.split()\n        sign = 1 if sign == '+' else -1\n        counts = tuple(int(c) for c in counts)\n        elements = tuple(e for e in elements)\n        return''.join(f'{sign} {m} {e} {c}' for e, c in zip(elements, counts))\n\n    def balance(formula):\n        \"\"\"\n        >>> balance('')\n        ''\n        >>> balance('+1 2 H 2 O 1')\n        '+1 2 H 2 O 1'\n        >>> balance('+1 2 C 1 O 2')\n        '+1 2 H 2 O 1'\n        >>> balance('-1 1 O 2')\n        '+1 2 C 1 O 2'\n        >>> balance('-1 3 C 6 H 12 O 6')\n        '+1 2 C 1 O 2'\n        \"\"\"\n        s = formula.split()\n        while s and s[-1] == '0 0':\n            s.pop()\n        if not s:\n            return '0 0'\n        lhs, rhs = s.pop(), s.pop()\n        lhs = lhs.split()\n        rhs = rhs.split()\n        assert lhs, rhs\n        if lhs and rhs and lhs[0]!= rhs[0]:\n            lhs.pop()\n            rhs.pop()\n        if'' in lhs:\n            lhs = formula(lhs)\n        if'' in rhs:\n            rhs = formula(rhs)\n        return f'{lhs} {rhs}'\n\n    def parse_elements(formula):\n        \"\"\"\n        >>> parse_elements('')\n        ''\n        >>> parse_elements('+1 2 H 2 O 1')\n        ('+1', '2', 'H', '2', 'O', '1')\n        >>> parse_elements('+1 2 C 1 O 2')\n        ('+1', '2', 'C', '1', 'O', '2')\n        >>> parse_elements('-1 1 O 2')\n        ('-1', '1', 'O', '2')\n        >>> parse_elements('-1 3 C 6 H 12 O 6')\n        ('-1', '3', 'C', '6', 'H', '12', 'O', '6')\n        \"\"\"\n        s = formula.split()\n        while s and s[-1] == '0 0':\n            s.pop()\n        if not s:\n            return '', '', '', '', ''\n        lhs, rhs = s.pop(), s.pop()\n        lhs = lhs.split()\n        rhs = rhs.split()\n        assert lhs, rhs\n        if lhs and rhs and lhs[0]!= rhs[0]:\n            lhs.pop()\n            rhs.pop()\n        if'' in lhs:\n            lhs = formula(lhs)\n        if'' in rhs:\n            rhs = formula(rhs)\n        return lhs, rhs\n\n    formula = balance(formula)\n    print(formula)\n    lhs, rhs = parse_elements(formula)\n    assert lhs, rhs\n    if lhs:\n        lhs = formula(lhs)\n    if rhs:\n        rhs = formula(rhs)\n    return lhs, rhs\n"
    },
    {
        "number": 3324,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def parse(line: str) -> Tuple[int, List[Tuple[str, str]], List[Tuple[str, str]]]:\n        (sign, elements) = line.split(' ')\n        elements = [(elements[i:i+2]) for i in range(0, len(elements), 2)]\n        counts = [int(count) for count in elements]\n        return (sign, elements, counts)\n\n    # sort the lines in reverse order of the number of elements\n    stdin.sort(reverse=True, key=lambda x: len(x.split(' ')))\n\n    balanced = True\n    while len(stdin) > 1 and balanced:\n        # count the number of left and right elements per line\n        left_count = len(stdin[0].split(' '))\n        right_count = len(stdin[1].split(' '))\n        # if the left and right counts are not the same, the equation is not balanced\n        if left_count!= right_count:\n            balanced = False\n            continue\n\n        # extract the signs, the elements, and the counts from the left and right lines\n        left = parse(stdin[0])\n        right = parse(stdin[1])\n\n        # validate the signs\n        if left[0] * right[0] < 0:\n            balanced = False\n            continue\n\n        # convert the signs, counts, and elements to tuples to reduce the number of operations\n        signs = [left[0] * right[0]]\n        elements = []\n        counts = []\n        for (sign, element, count) in zip(left[1], right[1], right[2]):\n            signs.append(sign)\n            elements.append(element)\n            counts.append(count)\n\n        # convert to a string of numbers for each of the elements to be used in an expression\n        s = ''\n        for (sign, element, count) in zip(signs, elements, counts):\n            if sign == 1:\n                s += f'+{element}' * count\n            else:\n                s += f'-{element}' * count\n\n        # remove any +1s in the string and replace with +1\n        s = s.replace('+1', '+1')\n\n        # convert the string of numbers to a list of integers\n        s = list(map(int, s.split(' ')))\n\n        # check if the sums are all positive\n        if sum(s) < 0:\n            balanced = False\n            continue\n\n        # create a list to hold the final solution\n        solution = []\n\n        # create a list to hold indices for the count of elements\n        counts = []\n\n        # add a zero to the beginning of the list of counts\n        counts.append(0)\n\n        # create a list to hold the sums of all elements\n        sums = []\n\n        # create a list to hold the counts of all elements\n        count = 0\n\n        # add the first count of each element\n        sums.append(s[0])\n        counts.append(count)\n\n        # loop through the list of sums, and sum the sums of each element\n        for i in range(1, len(s)):\n            sums.append(sums[i - 1] + s[i])\n            counts.append(count + 1)\n\n        # keep track of the final solution\n        solution.append(counts[0])\n\n        # get the index of the final element\n        i = counts[0]\n\n        # iterate through the list of sums\n        for j in range(1, len(sums)):\n            # if the index is below the index of the current element, the sum is too small\n            if i < counts[j]:\n                # add the count of the current element\n                solution.append(counts[j])\n\n                # update the index of the element\n                i = counts[j]\n\n            # if the index is above the index of the current element, the sum is too large\n            if i > counts[j]:\n                # add the count of the current element\n                solution.append(counts[j])\n\n                # update the index of the element\n                i = counts[j]\n\n        # add one to the solution to account for the zero at the end of the list\n        solution.append(1)\n\n        # combine the list of sums and solution\n        result = sums + solution\n\n        # return the result\n        return f"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.split()[0])\n    capacity = float(stdin.split()[1])\n    vertices = [(int(i), int(j)) for i, j in map(lambda x: x.split(), stdin.splitlines()[1:])]\n    points = []\n    for i in range(len(vertices)):\n        points.append(vertices[i])\n        if i == len(vertices) - 1:\n            points.append(vertices[i - 1])\n    # print(points)\n    ans = []\n    for i in range(len(points) - 1):\n        ans.append(points[i][1] - points[i + 1][1])\n    print(ans)\n    print(sum(ans) / len(ans))\n    return '{:.2f}'.format(sum(ans) / len(ans))\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    d = float(stdin)\n    points = []\n    for i in range(N):\n        point = list(map(float, stdin.split()))\n        points.append(point)\n    points.sort(key=lambda x: x[0])\n    points.sort(key=lambda x: x[1])\n\n    if len(points) == 0:\n        return \"0.0\"\n\n    left = points[0]\n    right = points[-1]\n    points.pop(0)\n    points.pop(-1)\n\n    left_bottom = points[0]\n    right_bottom = points[-1]\n    points.pop(0)\n    points.pop(-1)\n\n    a = right_bottom[0] - left_bottom[0]\n    b = right_bottom[1] - left_bottom[1]\n    c = left_bottom[1] * right_bottom[0] - left_bottom[0] * right_bottom[1]\n\n    x = (b * c - a * a) / (2 * a * b)\n    y = a * x + b * x + c\n\n    return str(y / d)\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4\n   ... 30 50\n   ... 20 0\n   ... 100 0\n   ... 100 40\n   ... 20 40\n   ... ''')\n    '20.83'\n    \"\"\"\n    N = int(stdin.split()[0])\n    D, L = [int(i) for i in stdin.split()[1:]]\n    points = []\n    for i in range(N):\n        points.append([int(j) for j in stdin.split()[i * 2 + 2:i * 2 + 4]])\n    points.sort(key=lambda x: x[1])\n    count = 0\n    for i in range(N - 1):\n        if abs(points[i + 1][0] - points[i][0]) > D:\n            break\n        count += abs(points[i][1] - points[i + 1][1])\n    return f'{count * L / (D * 1000)}'\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, D, L = map(int, stdin.split())\n    arr = [[int(j) for j in i.split()] for i in stdin.splitlines()]\n    start = arr[0]\n    end = arr[-1]\n    arr = sorted(arr[1:-1])\n    #print(start, end)\n    #print(arr)\n    start_x, start_y = start\n    end_x, end_y = end\n    #print((start_x,start_y), (end_x,end_y))\n    start_x, start_y = start_x+D, start_y-D\n    end_x, end_y = end_x+D, end_y-D\n    if start_x > end_x:\n        start_x, end_x = end_x, start_x\n    if start_y > end_y:\n        start_y, end_y = end_y, start_y\n    #print(start_x, start_y, end_x, end_y)\n    #print((start_x, start_y), (end_x, end_y))\n    left = (start_x, start_y)\n    right = (end_x, end_y)\n    #print(left, right)\n    #print((left, right))\n    left_y = left[1]\n    right_y = right[1]\n    #print(left_y, right_y)\n    left_x = left[0]\n    right_x = right[0]\n    #print(left_x, right_x)\n    #print(start_x, end_x, start_y, end_y)\n    #print(start_x, start_y, end_x, end_y)\n    def distance(x,y):\n        return (y-x)**2\n    #print(distance(left_x, left_y), distance(right_x, right_y))\n    if distance(left_x, left_y) <= distance(right_x, right_y):\n        return str(distance(end_x, end_y))\n    else:\n        return str(distance(start_x, start_y))\nprint(solution(stdin))\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split()\n    n = int(instructions[0])\n    depth = int(instructions[1])\n    points = [(int(x), int(y)) for x, y in zip(instructions[2::2], instructions[3::2])]\n    highest = 0\n    for i in range(n - 1):\n        a = points[i]\n        b = points[i + 1]\n        if a[0] * b[1] - a[1] * b[0] >= 0:\n            if a[1] - b[1] > highest:\n                highest = a[1] - b[1]\n    return '%.2f' % (depth / 2 + highest)\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, D, L = list(map(int, stdin.split()))\n    polygon = []\n    for i in range(N):\n        x, y = list(map(int, stdin.split()))\n        polygon.append((x, y))\n    polygon = sorted(polygon, key=lambda x: x[1])\n    top = 0\n    bottom = 0\n    for i in range(N):\n        top += polygon[i][1]\n        bottom += polygon[i + 1][1]\n    height = top - bottom\n    if height < 0:\n        height = 0\n    ans = height * D / L\n    return '{:.2f}'.format(ans)\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    # y = x - y\n    points = [(int(i[0]), int(i[1])) for i in stdin.split('\\n')[1:]]\n    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    # print(points)\n    # print(points)\n    ans = 0\n    for i in range(N):\n        ans += points[i][1]\n        # print(ans)\n    return f\"{ans:.2f}\"\n"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    tank = []\n    for i in range(N):\n        y, x = map(int, stdin.split())\n        tank.append((x,y))\n    return str(water_in_tank(tank))\n\ndef"
    },
    {
        "number": 3325,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    c = int(stdin.split()[1])\n    d = int(stdin.split()[2])\n    l = int(stdin.split()[3])\n    x = []\n    y = []\n    for _ in range(n):\n        a = list(map(int, stdin.split()[4 + _ * 2]))\n        b = list(map(int, stdin.split()[5 + _ * 2]))\n        x.append(a)\n        y.append(b)\n    x.sort(key=lambda x: x[1])\n    y.sort(key=lambda x: x[0])\n    max_y = []\n    if len(x) == 2:\n        if x[1][0] == x[0][0]:\n            if y[1][1] > y[0][1]:\n                max_y.append(y[1])\n                max_y.append(y[0])\n            else:\n                max_y.append(y[0])\n                max_y.append(y[1])\n        else:\n            max_y.append(y[1])\n            max_y.append(y[0])\n    elif len(x) == 1:\n        max_y.append(y[0])\n    else:\n        for i in range(1, len(x)):\n            if x[i][1] > x[i - 1][1]:\n                max_y.append(y[i])\n            else:\n                max_y.append(y[i - 1])\n    if len(max_y) == 1:\n        max_y.append(max_y[0])\n    print(len(max_y))\n    print(max_y)\n    sum = 0\n    for i in range(len(max_y)):\n        sum += abs(max_y[i][0] - max_y[i - 1][0])\n    return str(sum / (c * d))\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.strip().split())\n    grid = [list(map(int, stdin.strip().split())) for _ in range(r)]\n\n    def check(grid, r, c):\n        for i in range(r):\n            if sorted(grid[i])!= list(range(r * c)):\n                return False\n        for i in range(c):\n            if sorted(list(zip(*grid)), reverse=True)[i]!= list(range(r * c)):\n                return False\n        return True\n\n    for i in range(r):\n        for j in range(c):\n            if check(grid, r, c):\n                return str(1)\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    for i in range(r):\n        for j in range(c):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n            if check(grid, r, c):\n                return str(1)\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    for i in range(r):\n        for j in range(c):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n            if check(grid, r, c):\n                return str(1)\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    for i in range(r):\n        for j in range(c):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n            if check(grid, r, c):\n                return str(1)\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    for i in range(r):\n        for j in range(c):\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n            if check(grid, r, c):\n                return str(1)\n            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    return str(0)\n    "
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(count_monotonic_subgrids(stdin))\ndef"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    grid = []\n    for row in stdin.split(\"\\n\"):\n        grid.append(list(map(int, row.split())))\n    return str(count_monotonic(grid))\n\ndef"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.strip().split())\n    grid = [[int(x) for x in stdin.strip().split()] for _ in range(r)]\n    subgrids = 0\n    rows = range(r)\n    cols = range(c)\n    for row in rows:\n        for col in cols:\n            values = list(itertools.product(rows, cols))\n            if all(grid[x][y] <= grid[x][y] for (x, y) in values):\n                subgrids += 1\n    return str(subgrids)\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r,c = map(int,stdin.strip().split())\n    #     print(r,c)\n    return str(count_monotonic(r,c))\n    # return str(solve(r,c))"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    grid = [[int(x) for x in stdin.split()] for _ in range(r)]\n    \n    total = 0\n    \n    for row in range(r):\n        for col in range(c):\n            if not row % 2:\n                row_max = max(grid[row])\n                col_max = max([grid[row][i] for i in range(col, c)])\n            else:\n                row_max = max([grid[row][i] for i in range(col, c)])\n                col_max = max(grid[row])\n            if row_max >= col_max:\n                total += 1\n    return str(total)\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    [r, c] = list(map(int, stdin.split()))\n    arr = [list(map(int, stdin.split())) for _ in range(r)]\n    res = 0\n    for i in range(r):\n        for j in range(c):\n            if not arr[i][j] or arr[i][j] <= 0 or arr[i][j] > r*c:\n                continue\n            if arr[i][j] == arr[i][j+1] == arr[i][j+2] == arr[i+1][j] == arr[i+1][j+1] == arr[i+1][j+2] == arr[i+2][j] == arr[i+2][j+1] == arr[i+2][j+2] and arr[i][j]!= 1:\n                res += 1\n    return str(res)\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split('\\n')\n    r,c = map(int,input[0].split())\n    matrix = [[int(num) for num in input[i].split()] for i in range(1,r+1)]\n    count = 0\n    for row in range(r):\n        for col in range(c):\n            if matrix[row][col]==min(matrix[row][col+1],matrix[row+1][col],matrix[row][col-1],matrix[row+1][col-1])+1:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (r, c) = tuple(map(int, stdin.split()))\n    grid = [list(map(int, stdin.split()))]\n    monotonic = 0\n    for i in range(r):\n        for j in range(c):\n            if i > 0 and j > 0:\n                grid[i][j] = max(grid[i][j], max(grid[i - 1][j], grid[i][j - 1]))\n            if i > 0:\n                grid[i][j] = max(grid[i][j], grid[i - 1][j])\n            if j > 0:\n                grid[i][j] = max(grid[i][j], grid[i][j - 1])\n    for i in range(r):\n        for j in range(c):\n            if i > 0 and j > 0:\n                monotonic += 1 if grid[i][j] >= grid[i - 1][j] and grid[i][j] >= grid[i][j - 1] else 0\n            if i > 0:\n                monotonic += 1 if grid[i][j] >= grid[i - 1][j] else 0\n            if j > 0:\n                monotonic += 1 if grid[i][j] >= grid[i][j - 1] else 0\n    return str(monotonic)\n"
    },
    {
        "number": 3326,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.splitlines()\n    r,c = list(map(int,a[0].split()))\n    grid = [[int(x) for x in a[i].split()] for i in range(1,r+1)]\n    subgrids = 0\n    for i in range(r):\n        for j in range(c):\n            row = grid[i]\n            col = [x[j] for x in grid]\n            if row == sorted(row) or col == sorted(col):\n                subgrids += 1\n    return str(subgrids)"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = list(map(int, stdin.split()))\n    grid = [list(stdin[i]) for i in range(R)]\n    words = stdin.splitlines()[1:]\n    for word in words:\n        x, y, length = map(int, word.split())\n        if length == 1:\n            grid[x-1].append(word)\n        elif length == 2:\n            grid[x-1].append(word)\n            grid[x].append(word)\n        else:\n            for i in range(x,x+length):\n                grid[i].append(word)\n    return '\\n'.join(''.join(x) for x in grid)\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = stdin.split()\n    R, C = int(R), int(C)\n    grid = \".\" * (R + C)\n    for _ in range(int(stdin)):\n        grid = stdin_line(stdin, grid)\n    return grid\n\ndef"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [stdin[i * C:(i + 1) * C] for i in range(R)]\n    N = int(stdin)\n    lst = []\n    for _ in range(N):\n        lst.append(stdin[(i := input()).upper()])\n    return \"\".join(grid)\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(i) for i in stdin.split()]\n\n    grid = [[\"#\"] * C for _ in range(R)]\n    lines = stdin.splitlines()\n    n = int(lines.pop(0))\n\n    solutions = {}\n    for i in range(n):\n        line = lines.pop(0)\n        solutions[line] = {}\n        for j in range(len(line)):\n            if line[j]!= \".\":\n                solutions[line][j] = line[j]\n\n    for line in lines:\n        solution = []\n        for j in range(C):\n            if j == len(line):\n                break\n            if line[j] == \".\":\n                solution.append(line[j])\n                continue\n\n            if line[j]!= \"#\":\n                solution.append(solutions[line[j]])\n                solution.append(line[j])\n            else:\n                solution.append(line[j])\n                solution.append(\".\")\n        for i in range(len(solution) // 2):\n            grid[i][j] = solution[i]\n            grid[i][C - j - 1] = solution[i + 1]\n\n    return \"\\n\".join([\"\".join(i) for i in grid])\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns = stdin.split()\n    # Rows and columns are integer.\n    rows, columns = int(rows), int(columns)\n    # Generate the empty crossword.\n    crossword = ['.'] * columns\n    # Generate the filled crossword.\n    solutions = stdin.splitlines()\n    for solution in solutions:\n        # Solution is just a string.\n        solution = solution.strip()\n        # We need to loop over the letters in the solution and put them onto the crossword.\n        for letter in solution:\n            # Check that the letter is not a space.\n            if letter!='':\n                # Check that the letter is not in the crossword.\n                if letter not in crossword:\n                    # It is a new word, so we can place it on the crossword.\n                    crossword.insert(0, letter)\n                    break\n    # We need to generate the string for the output.\n    output = ''.join(crossword)\n    return output\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = stdin.strip()\n\n    def positions_on_edge(pos_grid):\n        \"\"\"Return True if at any edge of the grid.\"\"\"\n        x, y = pos_grid\n        return (x == 0 or x == C - 1) or (y == 0 or y == R - 1)\n\n    def positions_not_void(pos_grid):\n        \"\"\"Return True if non-void cell (non-empty).\"\"\"\n        x, y = pos_grid\n        return grid[x][y]!= \".\"\n\n    def positions_not_edge(pos_grid):\n        \"\"\"Return True if non-edge cell (non-void and non-edge).\"\"\"\n        x, y = pos_grid\n        return not (positions_on_edge(pos_grid) or positions_not_void(pos_grid))\n\n    def solve_horizontal():\n        \"\"\"Solve horizontal sections.\"\"\"\n        for y in range(R):\n            for x in range(C - 1):\n                if positions_not_void((x, y)):\n                    continue\n                if positions_on_edge((x, y)):\n                    continue\n\n                for x_new in range(x + 1, C):\n                    pos_grid_new = (x_new, y)\n                    if positions_not_void(pos_grid_new):\n                        break\n                else:\n                    print(\"HORIZONTAL:\", end=\"\")\n                    for x_new in range(x, x + 1):\n                        print(grid[x_new][y], end=\"\")\n                    print()\n                    return\n\n    def solve_vertical():\n        \"\"\"Solve vertical sections.\"\"\"\n        for x in range(C):\n            for y in range(R - 1):\n                if positions_not_void((x, y)):\n                    continue\n                if positions_on_edge((x, y)):\n                    continue\n\n                for y_new in range(y + 1, R):\n                    pos_grid_new = (x, y_new)\n                    if positions_not_void(pos_grid_new):\n                        break\n                else:\n                    print(\"VERTICAL:\", end=\"\")\n                    for y_new in range(y, y + 1):\n                        print(grid[x][y_new], end=\"\")\n                    print()\n                    return\n\n    solve_horizontal()\n    solve_vertical()\n    return grid\n\nsolution(\"1 15\\nCROSSWORD\\n\")\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [''.join(stdin.split('\\n'))]\n\n    for _ in range(N):\n        grid.append(''.join(stdin.split('\\n')))\n\n    d = defaultdict(list)\n    for i in range(len(grid) - 1):\n        for j in range(len(grid[i]) - 1):\n            if grid[i][j]!= '.':\n                d[grid[i][j]].append((i, j))\n\n    def neighbors(r, c):\n        for x in range(r - 1, r + 2):\n            for y in range(c - 1, c + 2):\n                if 0 <= x < R and 0 <= y < C:\n                    yield x, y\n\n    for k, v in d.items():\n        v.sort(key=lambda x: x[1])\n        v.sort(key=lambda x: x[0])\n\n        if len(v) == 0:\n            continue\n\n        row, col = v[0]\n        for r, c in neighbors(row, col):\n            if (r, c) not in v:\n                d[k].append((r, c))\n\n        if len(d[k]) > 1:\n            d[k].sort(key=lambda x: abs(col - x[1]))\n        d[k].sort(key=lambda x: x[0] - row)\n\n        if len(d[k]) > 1:\n            d[k].sort(key=lambda x: abs(row - x[0]))\n\n        # for x in range(len(d[k])):\n        #     if len(d[k]) > 1:\n        #         d[k][x] = (d[k][x][0] - row, d[k][x][1] - col)\n\n    for k, v in d.items():\n        d[k] = sorted(v)\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                grid[i] = '\\n'\n            else:\n                grid[i] += '\\n'\n\n    for i in range(R):\n        for j in range(C):\n            grid[i] += '#' if grid[i][j] == '.' else '.'\n\n    return '\\n'.join(grid)\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = stdin.strip().replace(\" \", \"#\")\n    n = int(stdin.strip())\n    rows = 2\n    cols = 3\n    grid = [grid[i * cols:i * cols + cols] for i in range(rows)]\n    cw = {\"CROSSWORD\": \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\".split(),\n           \"MIX\": \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21\".split()}\n    for key, val in cw.items():\n        for item in val:\n            if item in grid[0]:\n                grid[0] = grid[0].replace(item, \".\")\n            elif item in grid[1]:\n                grid[1] = grid[1].replace(item, \".\")\n    grid[0] = \"##\" + grid[0].replace(\".\", \"##\")\n    grid[1] = \"##\" + grid[1].replace(\".\", \"##\")\n    for x in range(rows):\n        for y in range(cols):\n            if grid[0][x] == \".\" and grid[1][y] == \".\":\n                grid[0] = grid[0][:x] + \"#\" + grid[0][x + 1:]\n                grid[1] = grid[1][:y] + \"#\" + grid[1][y + 1:]\n    for item in grid[0]:\n        print(item, end=\"\")\n    print()\n    for item in grid[1]:\n        print(item, end=\"\")\n    return \"\"\n"
    },
    {
        "number": 3327,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(i) for i in stdin.split()]\n    grid = [[i for i in stdin[j * C:(j + 1) * C]] for j in range(R)]\n    return '\\n'.join([''.join(row) for row in grid])\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split()))\n    table = []\n    for _ in range(N):\n        table.append(list(map(int, stdin.split())))\n    count = 0\n    while True:\n        vis_in_row = []\n        vis_in_col = []\n        for row in range(N):\n            vis_in_row += table[row]\n        for col in range(N):\n            vis_in_col += [x[col] for x in table]\n        vis_in_row = set(vis_in_row)\n        vis_in_col = set(vis_in_col)\n        if len(vis_in_row) >= K or len(vis_in_col) >= K:\n            break\n        if len(vis_in_row) < K:\n            for row in range(N):\n                if len(vis_in_row) < K:\n                    for i in range(row + 1, N):\n                        if len(vis_in_row) < K:\n                            if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[0], vis_in_row[-1]],\n                                                                      [vis_in_row[-1], vis_in_row[0]]]:\n                                continue\n                            if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[0], vis_in_row[i]],\n                                                                      [vis_in_row[i], vis_in_row[0]]]:\n                                continue\n                            if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[i], vis_in_row[i + 1]],\n                                                                      [vis_in_row[i + 1], vis_in_row[i]]]:\n                                continue\n                            break\n                    else:\n                        continue\n                else:\n                    break\n            else:\n                continue\n            vis_in_row.remove(min(vis_in_row))\n            vis_in_row.remove(max(vis_in_row))\n            for i in range(row + 1, N):\n                if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[0], vis_in_row[-1]],\n                                                           [vis_in_row[-1], vis_in_row[0]]]:\n                    continue\n                if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[0], vis_in_row[i]],\n                                                           [vis_in_row[i], vis_in_row[0]]]:\n                    continue\n                if (min(vis_in_row), max(vis_in_row)) in [[vis_in_row[i], vis_in_row[i + 1]],\n                                                           [vis_in_row[i + 1], vis_in_row[i]]]:\n                    continue\n                break\n            else:\n                continue\n            vis_in_row.remove(min(vis_in_row))\n            vis_in_row.remove(max(vis_in_row))\n            table[row] = vis_in_row\n        else:\n            for col in range(N):\n                if len(vis_in_col) < K:\n                    for i in range(col + 1, N):\n                        if len(vis_in_col) < K:\n                            if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[0], vis_in_col[-1]],\n                                                                      [vis_in_col[-1], vis_in_col[0]]]:\n                                continue\n                            if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[0], vis_in_col[i]],\n                                                                      [vis_in_col[i], vis_in_col[0]]]:\n                                continue\n                            if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[i], vis_in_col[i + 1]],\n                                                                      [vis_in_col[i + 1], vis_in_col[i]]]:\n                                continue\n                            break\n                        else:\n                            break\n                    else:\n                        continue\n                else:\n                    break\n            else:\n                continue\n            vis_in_col.remove(min(vis_in_col))\n            vis_in_col.remove(max(vis_in_col))\n            for i in range(col + 1, N):\n                if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[0], vis_in_col[-1]],\n                                                           [vis_in_col[-1], vis_in_col[0]]]:\n                    continue\n                if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[0], vis_in_col[i]],\n                                                           [vis_in_col[i], vis_in_col[0]]]:\n                    continue\n                if (min(vis_in_col), max(vis_in_col)) in [[vis_in_col[i], vis_in_col[i + 1]],\n                                                           [vis_in_col[i + 1], vis_in_col[i]]]:\n                    continue\n                break\n            else:\n                continue\n            vis_in_col.remove(min(vis_in_col))\n            vis_in_col.remove(max(vis_in_col))\n            table[col] = vis_in_col\n    return count\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_sum(n):\n        s = 0\n        for x in n:\n            s += x\n        return s\n    N, K = map(int, stdin.strip().split())\n    table = list(map(int, stdin.strip().split()))\n    table = sorted(table, key=lambda x:x)\n    \n    rows = []\n    cols = []\n    for x, y in enumerate(table):\n        rows.append(x)\n        cols.append(y)\n    \n    #M = get_sum(rows)\n    #print(M)\n    #N = get_sum(cols)\n    #print(N)\n    \n    #M = max(rows) + max(cols)\n    #print(M)\n    M = max(rows) + max(cols)\n    #print(M)\n    #N = sum(table)\n    #print(N)\n    \n    while M > N and K > 0:\n        M = M - (2*table[K-1]) + (2*table[K])\n        K -= 2\n    \n    return str(M)"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    table = []\n    for i in range(N):\n        table.append(list(map(int, stdin.split())))\n    return get_min_sum(table, K)\n\n\ndef"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = (int(x) for x in stdin.split())\n    table = [list(map(int, stdin.split())) for _ in range(N)]\n    result = []\n    for _ in range(K):\n        result.append(sum([max(table[i][j], table[i+1][j+1]) for i in range(N - 2) for j in range(N - 2)]))\n    return str(min(result))\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    table = [list(map(int, stdin.split())) for _ in range(N)]\n\n    def is_valid(r, c):\n        if r >= N or r < 0 or c >= N or c < 0:\n            return False\n\n        for i in range(N):\n            if table[i][c] == 0 or table[r][i] == 0:\n                continue\n            if abs(table[i][c] - table[r][i]) >= 2:\n                return False\n        return True\n\n    def num_visible(r, c):\n        return sum(1 for r2, c2 in ((r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1))\n                   if is_valid(r2, c2))\n\n    def cover(r, c, dr, dc):\n        if not is_valid(r + dr, c + dc):\n            return num_visible(r, c) + num_visible(r + dr, c + dc)\n        return min(num_visible(r, c),\n                   num_visible(r + dr, c),\n                   num_visible(r, c + dc),\n                   num_visible(r + dr, c + dc))\n\n    return min([cover(r, c, dr, dc) for r, c in ((N - 1, N - 1), (0, 0), (0, N - 1), (N - 1, 0))\n                for dr, dc in ((-1, 0), (0, 1), (1, 0), (0, -1))])\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    table = list(list(map(int, input().split())) for _ in range(n))\n    # print(n, k)\n    # print(table)\n    \n    def inRange(i, j):\n        return 0 <= i < n and 0 <= j < n\n    \n    def overlap(a, b):\n        return a[0] <= b[0] <= a[1] or a[0] <= b[1] <= a[1] or b[0] <= a[0] <= b[1]\n    \n    def makeOverlap(a, b, k):\n        # print(\"a\", a, \"b\", b)\n        if not overlap(a, b):\n            return (a[0], a[1]), (b[0], b[1]), k\n        else:\n            mid = (a[0] + b[0]) // 2, (a[1] + b[1]) // 2\n            return (a[0], mid), (mid, b[1]), k\n    \n    def cover(i, j):\n        # print(i, j)\n        covered = 0\n        for x in range(n):\n            for y in range(n):\n                if table[x][y] == 0:\n                    continue\n                if (i, y) == (x, y):\n                    continue\n                # print(x, y)\n                if x < i or x > j or y < i or y > j:\n                    continue\n                else:\n                    covered += 1\n        return covered\n    \n    overlaps = 0\n    total = 0\n    for x in range(n):\n        for y in range(n):\n            if table[x][y] == 0:\n                continue\n            if table[x][y] == k:\n                continue\n            if (x, y) == (x, y):\n                continue\n            \n            overlaps += cover(x, y)\n            total += 1\n    \n    # print(overlaps, total, overlaps // total)\n    return total - overlaps // total\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    k = int(stdin.split()[1])\n    dominoes = stdin.split()[2:]\n    field_sums = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            field_sums[i][j] = abs(i - j) + abs(n-i-j)\n\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(i):\n            temp = field_sums[j][i]\n            if temp >= k:\n                break\n            if temp + field_sums[i][j] <= k:\n                min_sum = min(min_sum, temp + field_sums[i][j])\n    return str(min_sum)"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n\n    # make the table\n    table = []\n    for line in inputs[0:]:\n        table.append([int(x) for x in line.split(' ')])\n\n    # get the sum of all visible fields\n    min_sum = 10000000\n    for i in range(len(table)):\n        for j in range(len(table)):\n            if table[i][j] < 0:\n                min_sum = min(min_sum, abs(table[i][j]))\n\n    return str(min_sum)\n"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    k = int(stdin.split()[1])\n    l = stdin.split()[2:]\n    dominos = []\n    vis = set()\n    max_i = n-1\n    max_j = n-1\n    min_j = 0\n    max_i_2 = 0\n    min_j_2 = 0\n    min_i_3 = 0\n    min_j_3 = 0\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if i > max_i:\n                    max_i = i\n                if j > max_j:\n                    max_j = j\n                if i < min_i:\n                    min_i = i\n                if j < min_j:\n                    min_j = j\n            else:\n                if j > max_j:\n                    max_j = j\n                if i < min_i:\n                    min_i = i\n                if j < min_j:\n                    min_j = j\n    for i in range(n):\n        for j in range(n):\n            if j - i >= k:\n                dominos.append([i,j])\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if i > max_i_2:\n                    max_i_2 = i\n                if j > max_j_2:\n                    max_j_2 = j\n                if i < min_i_3:\n                    min_i_3 = i\n                if j < min_j_3:\n                    min_j_3 = j\n            else:\n                if j > max_j_2:\n                    max_j_2 = j\n                if i < min_i_3:\n                    min_i_3 = i\n                if j < min_j_3:\n                    min_j_3 = j\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n            else:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n            else:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n            else:\n                if (j - i) >= k:\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n            else:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n            else:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_3:\n                        min_i_3 = i\n                    if j < min_j_3:\n                        min_j_3 = j\n    vis = set(vis)\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                if (j - i) >= k:\n                    if i > max_i_2:\n                        max_i_2 = i\n                    if j > max_j_2:\n                        max_j_2 = j\n                    if i < min_i_"
    },
    {
        "number": 3328,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    table = []\n    for _ in range(N):\n        table.append(list(map(int, stdin.split())))\n    return min([solve(table, N, K) for i in range(K)])\n\n\ndef"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    curr = []\n\n    for _ in range(n):\n        curr.append(stdin[0])\n        stdin = stdin[1:]\n\n        if curr[-1] == 'B' and curr[-2] == 'B':\n            curr = curr[:-1]\n            result += 1\n            curr += 'W'\n            curr += curr[-2:]\n\n        elif curr[-1] == 'W' and curr[-2] == 'W':\n            curr = curr[:-1]\n            result += 1\n            curr += 'B'\n            curr += curr[-2:]\n\n        elif curr[-1] == 'B' and curr[-2] == 'W':\n            curr = curr[:-1]\n            curr += curr[-2:]\n            result += 1\n            curr += 'B'\n            curr += curr[-2:]\n        elif curr[-1] == 'W' and curr[-2] == 'B':\n            curr = curr[:-1]\n            curr += curr[-2:]\n            result += 1\n            curr += 'W'\n            curr += curr[-2:]\n\n        else:\n            curr += 'B'\n            curr += curr[-2:]\n            result += 1\n            curr += 'B'\n            curr += curr[-2:]\n\n    return result\n\nstdin = input()\nprint(solution(stdin))\n"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    # make list of N pebbles\n    pebbles = [\"B\"] * n\n    # make list of starting circle\n    starting_circle = [\"B\"] * n\n    rotation_count = 0\n    for i in range(k):\n        # rotate\n        new_circle = []\n        for j in range(n):\n            # rotate\n            if pebbles[j] == \"B\":\n                new_circle.append(\"W\")\n            else:\n                new_circle.append(\"B\")\n        # shift\n        for j in range(n):\n            starting_circle[j] = new_circle[(j - n) % n]\n        rotation_count += 1\n    # count\n    # find all circles that result in the same circle after $K$ rotations\n    count = 0\n    for i in range(n):\n        if starting_circle[i] == \"B\":\n            # if every pebble in the circle is black\n            if starting_circle.count(\"B\") == n:\n                # we have a counterexample!\n                count += 1\n    print(count)\n    return count\n"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    k = int(stdin[1])\n    all_possible_circles = set()\n    for turn in range(k):\n        current_circle = set(stdin[1].replace(\"W\", \"B\").replace(\"B\", \"W\"))\n        next_circle = set()\n        for char in current_circle:\n            if char == \"B\":\n                next_circle.add(\"W\")\n            else:\n                next_circle.add(\"B\")\n        current_circle = next_circle\n        all_possible_circles.add(current_circle)\n    return str(len(all_possible_circles))"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return '2'\n"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    k = int(stdin.split()[1])\n    b = stdin.split()[2]\n    N = n - k\n    M = 2 * N\n    I = []\n    if k % 2!= 0:\n        I.append(b)\n    else:\n        I.append(''.join(reversed(b)))\n    for _ in range(1, k // 2 + 1):\n        I.append(''.join(reversed(I[-2])))\n        I.append(I[-2])\n    if k % 2 == 0:\n        I.append(b)\n    I = set(I)\n    L = len(I)\n    print(L)\n    return str(L)\n\nsolution(input())"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(i) for i in stdin.split()]\n\n    circle = stdin\n\n    for i in range(K):\n        # list of strings\n        new = []\n        for j in range(N):\n            if circle[j] == \"B\":\n                new.append(\"W\")\n            elif circle[j] == \"W\":\n                new.append(\"B\")\n\n        circle = new\n\n    return len(set(circle))\n"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    circle = stdin\n    before = {'B': 0, 'W': 0}\n    after = {'B': 0, 'W': 0}\n    for _ in range(K):\n        circle = rotate(circle)\n        before['B'] = after['W']\n        after['B'] = before['W'] + before['B']\n        after['W'] = after['B'] + before['W']\n    return str(after['B'] - before['B'])\n\ndef"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    N, K = n, k\n    def rotate(arr, num):\n        num = num % len(arr)\n        return arr[-num:] + arr[:-num]\n    # start with A:\n    A = 'B'*N\n    for i in range(K):\n        print(A)\n        # rotate A, and C and then D:\n        C = rotate(A,1)\n        D = rotate(C,1)\n        A = rotate(D,1)\n    return A"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2!= 0:\n        return \"NO\"\n    stdin = list(stdin)\n    if len(stdin) == N:\n        if stdin[0]!= stdin[-1]:\n            return \"NO\"\n        return \"YES\"\n\n    result = []\n    result.append(stdin[0])\n    for i in range(1, len(stdin) - 1):\n        result.append(stdin[i] + stdin[i + 1])\n    result.append(stdin[-1])\n    result = list(set(result))\n    if len(result) == N:\n        return \"YES\"\n    return \"NO\"\n"
    },
    {
        "number": 3329,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    # >>> N = 3\n    # >>> K = 1\n    # >>> print(2)\n    # 2\n    # >>> print(2 ** 3)\n    # 8\n\n    # our answer is the solution of the fibonacci sequence\n    # # first we define our base cases\n    if N == 0:\n        return 0\n    if N == 1:\n        return 1\n    if N == 2:\n        return 2\n\n    # we'll want to calculate our fibonacci sequence\n    # 1, 1, 2, 4, 7, 13,\n    # our function is basically:\n    # f(N) = f(N - 1) + f(N - 2)\n    fib = [0, 1, 2]\n    for i in range(3, N + 1):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    # now we need to calculate our answer\n    result = fib[-1]\n    for i in range(K):\n        result = result * 2 + 1\n    return result\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, L = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    numerator = 1\n    denominator = 1\n    total = 0\n    for i in range(1, N):\n        numerator *= c[i] / a[i]\n        denominator *= c[i - 1] / a[i - 1]\n        total += numerator\n        total += denominator\n    print(total / 2)\n    return f\"{total / 2:.3f}\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, N, L = stdin.split()\n    N, L = int(N), int(L)\n    A = list(map(int, stdin.split()[1:]))\n    B = list(map(int, stdin.split()[1:]))\n    A = sum(A)\n    B = sum(B)\n    print(A/B)\n    return str(A/B)\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, L = (int(x) for x in stdin.split())\n    arr = sorted((int(x) for x in stdin.split()))\n    P_1 = sum(arr[:L]) / L\n    P_2 = sum(arr[L:]) / (N - L)\n    return '{:.3f}'.format(P_1 * P_2)\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    a, c = zip(*[map(int, stdin.split()) for _ in range(n)])\n    a, c = list(a), list(c)\n    return f\"{round(sum(a) / l, 3) / sum(c):.3f}\""
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N,L = map(int,stdin.split())\n    a = list(map(int,stdin.split()))\n    c = list(map(int,stdin.split()))\n    c.sort()\n    a.sort()\n    total_prod = 1\n    sum_a = sum(a)\n    sum_c = sum(c)\n    for i in range(N):\n        if i > 0:\n            total_prod *= c[i]/a[i]\n    return \"%.3f\"%(total_prod)"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, L = (int(i) for i in stdin.split())\n    A = sorted([int(i) for i in stdin.split()])\n    C = sorted([int(i) for i in stdin.split()])\n    M = sum(A)\n    L = L - 1\n    for a, c in zip(A, C):\n        M -= a\n        L -= 1\n        if M <= 0:\n            return a * c\n        if L == 0:\n            return -1\ndef"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, l = [int(i) for i in stdin.split()]\n    a = [int(i) for i in stdin.split()]\n    c = [int(i) for i in stdin.split()]\n    res = 0\n    while l:\n        m1 = sum(a) / l\n        m2 = sum(c) / l\n        m = min(m1, m2)\n        res = max(res, m)\n        l -= 1\n        a.pop(0)\n        c.pop(0)\n    return \"%.3f\" % res\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, l = list(map(int, stdin.split()))\n    sales = list(map(int, stdin.split()))\n\n    store = {1: sales[:l]}\n\n    for i in range(n - l):\n        store[i + 1] = sales[l + i] + sum(store[i] for i in range(l))\n\n    return str(min(store.values()) / l)\n"
    },
    {
        "number": 3330,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    return str(float((a[0] * a[1]) / (c[0] * c[1])))\n\nstdin = '3 1'\nprint(solution(stdin))\n"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, L = list(map(int, stdin.split()))\n    a, b, p = (list(map(int, stdin.split()))[1:])\n    moves = [[0] * L for _ in range(L)]\n    for i in range(0, L, 2):\n        moves[i][i + 1] = 1\n    cows = list(map(int, stdin.split()))\n    for i in range(2, L):\n        cows.pop(cows.index(a))\n        cows.pop(cows.index(b))\n        cows.append(p)\n        cows.append(b)\n        cows.append(a)\n        cows.append(a)\n        if i < L - 1:\n            moves[a][b] = 2\n            moves[a][p] = 2\n            moves[b][a] = 2\n            moves[b][p] = 2\n            moves[p][a] = 2\n            moves[p][b] = 2\n            for j in range(i + 1, L):\n                if cows[i] == cows[j]:\n                    moves[a][b] = i\n                    moves[a][p] = i\n                    moves[b][a] = i\n                    moves[b][p] = i\n                    moves[p][a] = i\n                    moves[p][b] = i\n        else:\n            moves[a][b] = 2\n            moves[a][p] = 2\n            moves[b][a] = 2\n            moves[b][p] = 2\n            moves[p][a] = 2\n            moves[p][b] = 2\n    if len(cows) == 0:\n        return 0\n    while True:\n        for i in range(0, L, 2):\n            if cows[i] == a:\n                if cows[i + 1] == b:\n                    return moves[i][i + 1] + 1\n                else:\n                    return moves[i][i + 1] + 2\n            elif cows[i] == b:\n                if cows[i + 1] == a:\n                    return moves[i][i + 1] + 1\n                else:\n                    return moves[i][i + 1] + 2\n        for i in range(2, L):\n            if cows[i] == a:\n                if cows[i - 1] == b:\n                    return moves[i - 1][i] + 1\n                else:\n                    return moves[i - 1][i] + 2\n            elif cows[i] == b:\n                if cows[i - 1] == a:\n                    return moves[i - 1][i] + 1\n                else:\n                    return moves[i - 1][i] + 2\n        return 0\n    return 0"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    while A and B and P:\n        if abs(A - L) < abs(B - L):\n            A = A - 1 if P else A + 1\n        else:\n            B = B - 1 if P else B + 1\n        P = P - 1 if P else P + 1\n    return str(max(0, (L - (A + B - 2)) / 2))\n"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    fence_lengths = list(map(lambda x: int(x), lines[0].split()))\n    cow_positions = list(map(lambda x: int(x), lines[1].split()))\n    horse_position = int(lines[2])\n    cows = []\n    for i in range(3, len(lines)):\n        cows.append(list(map(lambda x: int(x), lines[i].split())))\n\n    fence_lengths.sort()\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cows.sort()\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    print(cow_positions)\n    print(cow_positions[-2])\n    print(cow_positions[-1])\n    print(fence_lengths)\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    print(cow_positions)\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    cow_positions.append(cow_positions[-1]+fence_lengths[-1])\n    cow_positions.sort()\n    "
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    return str(min(L*(L+1)/2, P*L))"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    moves = {0: 1, 1: 0, 2: -1}\n    cows = {}\n    rides = {}\n    cow_pos = -1\n    h_pos = -1\n    moveset = set()\n    for _ in range(P):\n        cow_pos = (cow_pos + moves[P % 3]) % L\n        rides[cow_pos] = P\n        P += 1\n    for _ in range(A):\n        cow_pos = (cow_pos + moves[(A % 3)]) % L\n        cows[cow_pos] = 1\n        moveset.add(cow_pos)\n    for _ in range(B):\n        h_pos = (h_pos + moves[(B % 3)]) % L\n        if h_pos in cows:\n            cows[h_pos] += 1\n            if cows[h_pos] > 1:\n                return \"ERROR\"\n            moveset.add(h_pos)\n    if not len(moveset) == 2:\n        return \"ERROR\"\n    if L % 2 == 0:\n        return \"ERROR\"\n    moveset.remove(0)\n    moveset.remove(L - 1)\n    for m in moveset:\n        if m in cows:\n            return \"ERROR\"\n    cow_pos = 0\n    h_pos = 0\n    cur_cow = -1\n    cur_h = -1\n    for _ in range(P):\n        if cow_pos in cows:\n            if cur_cow!= -1:\n                return \"ERROR\"\n            cur_cow = cow_pos\n        cur_cow = rides[cow_pos]\n        cow_pos = (cow_pos + moves[cur_cow % 3]) % L\n        if cur_cow == L - 1:\n            cur_h = h_pos\n        h_pos = (h_pos + moves[(cur_cow + 1) % 3]) % L\n        if cur_h!= -1 and h_pos == cur_h:\n            return \"ERROR\"\n    return cur_cow * cur_h\n"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().split()\n    L = int(stdin.pop(0))\n    A = int(stdin.pop(0))\n    B = int(stdin.pop(0))\n    P = int(stdin.pop(0))\n    s = set()\n    for i in range(P):\n        s.add(int(stdin.pop(0)))\n    s = list(s)\n    s.sort()\n    cows = [(A, B, int(p)) for p in s]\n    cows.sort(key=lambda x: x[2])\n    cows.sort(key=lambda x: x[0])\n    cows.sort(key=lambda x: x[1])\n    cow_steps = 0\n    horse_steps = 0\n    cows_pos = A\n    horse_pos = P\n    while cows_pos!= B or horse_pos!= B:\n        cow_steps += 1\n        if cows_pos == horse_pos:\n            cow_steps -= 1\n        if cow_steps >= L:\n            return '-1'\n        if cows_pos == A:\n            cows_pos = B\n        if horse_pos == A:\n            horse_pos = B\n            continue\n        if cows_pos == B:\n            cows_pos = A\n            continue\n        if horse_pos == B:\n            horse_pos = A\n            continue\n        if horse_pos == A:\n            horse_pos = P\n            continue\n        if cows_pos == A:\n            cows_pos = B\n            continue\n        if horse_pos == A:\n            horse_pos = B\n            continue\n        if cows_pos == B:\n            cows_pos = A\n            continue\n        if horse_pos == B:\n            horse_pos = A\n            continue\n    return str(cow_steps)"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    return \"{}\".format((A*L + P*(L-1) + B*(L-1) - L)/2)\n"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    return str(math.ceil((P - L) / min(A, B)))\n\n\nprint(solution(input()))\n\n\ndef"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cows, horses, shelter, cp = map(int, stdin.split())\n    # cows = 3, horses = 2, cp = 1\n    # shelter = 4\n    # 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1\n    # 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1\n    # 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1 -> 1\n    # 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2\n    # 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2\n    # 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2 -> 2\n    # 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3\n    # 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3\n    # 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3 -> 3\n    # 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4\n    # 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4\n    # 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4 -> 4\n    # 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5\n    # 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5\n    # 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5 -> 5\n    # 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6\n    # 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6\n    # 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6 -> 6\n    # 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7\n    # 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7\n    # 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7 -> 7\n    # 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8\n    # 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8\n    # 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8 -> 8\n    # 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9\n    # 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9\n    # 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9 -> 9\n    # 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10\n    # 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10\n    # 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10 -> 10\n    # 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11\n    # 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11\n    # 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11 -> 11\n    # 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12\n    # 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12\n    # 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12 -> 12\n    # 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13\n    # 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13\n    # 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13 -> 13\n    # 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14 -> 14"
    },
    {
        "number": 3331,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    instructions = stdin.split()\n    length = int(instructions[0])\n    start_point = int(instructions[1])\n    end_point = int(instructions[2])\n    horse_start = int(instructions[3])\n    cow_start = int(instructions[4])\n    minutes = 0\n    while start_point!= end_point:\n        if start_point > end_point:\n            break\n        if start_point % 2 == 0:\n            if cow_start <= end_point:\n                end_point = start_point\n                cow_start += 2\n        else:\n            if cow_start <= end_point:\n                cow_start = start_point\n                end_point += 2\n        start_point = end_point\n        if start_point == horse_start:\n            start_point = end_point\n            horse_start += 1\n            cow_start = 0\n        minutes += 1\n    return str(minutes)\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return '\\n'"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    streams = sorted(list(map(int, stdin.strip().split())))\n    q = deque([])\n    i = 0\n    while streams:\n        stream = streams.pop(0)\n        if stream not in q:\n            q.append(stream)\n            i += 1\n        elif stream in q:\n            while q[0]!= stream:\n                q.popleft()\n                i += 1\n    return str(i)\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    processor_list = [[] for i in range(N)]\n    for i in range(N):\n        s, d, p = map(int, stdin.split())\n        processor_list[i].append((s, d, p))\n    processor_list.sort(key=lambda x: x[1])\n    priority_queue = []\n    max_priority = 0\n    \n    def process_data_streams(priority_queue, priority_count):\n        while priority_queue:\n            s, d, p = priority_queue.pop(0)\n            if p > priority_count:\n                priority_count = p\n            for j in range(N):\n                if j in processor_list[s] and processor_list[s][j][2] > priority_count:\n                    processor_list[s][j] = (processor_list[s][j][0], processor_list[s][j][1], priority_count)\n                    priority_queue.append(processor_list[s][j])\n        return processor_list, priority_count\n    \n    def ogu_process(processor_list, priority_count):\n        for i in range(N):\n            if processor_list[i][0][2] == priority_count:\n                priority_queue.append(processor_list[i][0])\n    \n    priority_queue.append(processor_list[0][0])\n    priority_count = processor_list[0][2]\n    processor_list, priority_count = process_data_streams(priority_queue, priority_count)\n    priority_queue = []\n    guest_processor = 0\n    guest_processor = ogu_process(processor_list, priority_count)\n    processor_list.sort(key=lambda x: x[1], reverse=True)\n    while guest_processor > 0:\n        guest_processor = ogu_process(processor_list, priority_count)\n    return str(processor_list[0][2])"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    streams = list(map(int, stdin.split()[1:]))\n    priority = streams.copy()\n    # priority = []\n    while len(streams)!= 0:\n        if len(streams) == 1:\n            priority.append(streams.pop())\n            break\n        if priority[-1] == max(priority[:-1]):\n            priority.pop()\n            streams.append(priority.pop())\n        else:\n            priority.append(streams.pop())\n    return str(sum(priority))\n\n\nprint(solution(input()))\n\"\"\"\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    n = int(stdin[0])\n    streams = []\n    for i in range(1, len(stdin)):\n        streams.append([int(stdin[i]), int(stdin[i+1]), int(stdin[i+2])])\n    streams.sort(key=lambda x: (x[2], x[1]))\n    processors = []\n    current_processor = None\n    priority = 0\n    for stream in streams:\n        if current_processor is None or current_processor!= stream[0]:\n            if current_processor is not None:\n                processors[priority].append(current_processor)\n            priority += 1\n            current_processor = stream[0]\n            processors.append([])\n            processors[priority].append(current_processor)\n        processors[priority].append(stream[1])\n    for processor in processors:\n        processor.sort()\n    max_priority = max(list(map(lambda x: len(x), processors)))\n    max_priority = max_priority if max_priority >= len(processors) else len(processors)\n    for processor in processors[:max_priority]:\n        processor.sort()\n    return str(sum(list(map(lambda x: x[2], streams))))\n    \n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    the first line of input contains the number of test cases, T. For each test case, the first line contains the number of streams, N. The next N lines contain start time, duration and priority of N streams. The format of each line is as follows:\n    START TIME DURATION PRIORITY.\n    \n    Example:\n    2\n    1 3 6\n    2 5 8\n    3 3 5\n    \n    Output:\n    13\n    \"\"\"\n    T = int(stdin.readline())\n    for i in range(T):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        a.sort(key=lambda x: x[1] - x[0])\n        res = 0\n        stack = []\n        for j in range(n):\n            while stack and stack[-1]!= a[j][0]:\n                res = max(res, stack.pop() * a[j][2])\n            stack.append(a[j][2])\n        res = max(res, a[0][2])\n        while stack:\n            res = max(res, stack.pop() * a[0][2])\n        print(res)\n    return \"\"\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    stdin = list(map(int, stdin.strip().split()))\n    starts = sorted(stdin[:n], reverse=True)\n    ends = sorted(stdin[n:], reverse=True)\n    max_p = 0\n    starts.append(starts[-1] + 1)\n    while starts:\n        while ends:\n            if starts[-1] + ends[0] <= starts[-1] + ends[-1]:\n                max_p = max(max_p, starts.pop() * ends[0])\n            else:\n                break\n        while ends:\n            if starts[-1] + ends[0] > starts[-1] + ends[-1]:\n                max_p = max(max_p, starts.pop() * ends[0])\n            else:\n                break\n        if not ends:\n            break\n        max_p = max(max_p, starts.pop() * ends[0])\n    return str(max_p)"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    stdin = \"\"\"\n    5 3 6\n    2 5 8\n    3 3 5\n    5 3 6\n    \"\"\"\n    return \"\"\"\n    \"\"\"\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    list = []\n    for i in range(n):\n        list.append(list(map(int, stdin.split())))\n\n    dp = [[0 for _ in range(11)] for _ in range(n)]\n    stack = []\n\n    for i in range(n):\n        if list[i][0] > list[i][1]:\n            stack.append(i)\n\n    while stack:\n        i = stack.pop(0)\n        if dp[i][list[i][1]] < list[i][2]:\n            dp[i][list[i][1]] = list[i][2]\n        for j in range(i + 1, n):\n            if list[j][0] > list[i][1]:\n                stack.append(j)\n            if dp[i][list[i][1]] + list[j][2] < dp[j][list[j][1]]:\n                dp[j][list[j][1]] = dp[i][list[i][1]] + list[j][2]\n\n    max = 0\n    for i in range(n):\n        if dp[i][list[i][1]] > max:\n            max = dp[i][list[i][1]]\n\n    return str(max)\n"
    },
    {
        "number": 3332,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    n = int(stdin)\n    streams = sorted([(int(x), int(y), int(z)) for x, y, z in map(lambda x: x.split(' '), stdin.split('\\n'))])\n    result = 0\n    stack = []\n    for stream in streams:\n        if len(stack) < n and stream[2] == max(map(lambda x: x[2], stack + list(combinations(streams, 2)))):\n            stack.append(stream)\n        else:\n            result = max(result, stream[2])\n    return str(result)"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x,y = map(float,stdin.split())\n    n = int(stdin)\n    spots = []\n    for i in range(1,n+1):\n        x1, y1 = map(float,stdin.split())\n        spots.append([x1,y1])\n    spots.sort(key=lambda x: x[0])\n    y_max = spots[0][1]\n    y_min = spots[n-1][1]\n    print(y_max, y_min)\n    ans = y_max - y_min\n    return str(ans)"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    coords = [(float(x), float(y)) for x, y in zip(*[iter(stdin)]*2)]\n    print(coords)\n    h, d = len(coords), len(coords)\n    if h < 2 or d < 2:\n        return 0\n    deltas = []\n    for i in range(h):\n        for j in range(h):\n            deltas.append(abs(coords[i][0] - coords[j][0]) + abs(coords[i][1] - coords[j][1]))\n    deltas = sorted(deltas)\n    print(deltas)\n    for i in range(2, h):\n        if deltas[i] == deltas[i-2] + 2:\n            return deltas[i]\n    return deltas[-1]\n\nsolution(stdin)\n\n'''\n\nimport math\nimport os\nimport random\nimport re\nimport sys\nfrom datetime import datetime\n\ndef"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    loc = tuple(map(float, stdin.strip().split()))\n    # Return answer for part 1\n    return answer()\n\ndef"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    roost_x, roost_y = list(map(float, stdin.strip().split('\\n')[0].split()))\n    hen_num, hen_distance = list(map(int, stdin.strip().split('\\n')[1].split()))\n    hen_coords = []\n    for i in range(hen_num):\n        hen_coords.append(list(map(float, stdin.strip().split('\\n')[2+i].split())))\n    print(hen_coords)\n    def manhattan_distance(coord1, coord2):\n        return abs(coord1[0]-coord2[0]) + abs(coord1[1]-coord2[1])\n    max_distance = 0\n    for hen_coord in hen_coords:\n        distance = 0\n        for hen_coord_index in range(len(hen_coord)):\n            distance += manhattan_distance(hen_coord, hen_coords[hen_coord_index])\n        if distance > max_distance:\n            max_distance = distance\n    return max_distance"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    r = (x, y)\n    n = int(stdin)\n    spots = []\n    for i in range(n):\n        x, y = map(float, stdin.split())\n        spots.append((x, y))\n    return str(min(dist(r, x, y) for x, y in spots))\n"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x, y = stdin.split(\" \")\n    x = float(x)\n    y = float(y)\n    return str(round(math.sqrt((x - x_r) ** 2 + (y - y_r) ** 2) + (x_r - x) ** 2 + (y_r - y) ** 2, 6))\n"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    f, h = map(int, stdin.split())\n    return str(min([abs(f-x) + abs(h-y) for x, y in [(f, h), (h, f), (f, h), (h, f)] if x <= 1000 and y <= 1000]))\n"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdout = []\n    roost_x, roost_y = map(float, stdin.split())\n    stdout.append(f\"{math.sqrt((roost_x - 0) ** 2 + (roost_y - 0) ** 2) :.6f}\")\n    for _ in range(int(stdin.split()[1])):\n        x, y = map(float, stdin.split())\n        stdout.append(f\"{math.sqrt((x - 0) ** 2 + (y - 0) ** 2) :.6f}\")\n    return '\\n'.join(stdout)\n"
    },
    {
        "number": 3333,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.split()[0])\n    y = int(stdin.split()[1])\n    m = int(stdin.split()[2])\n    ans = 0\n    for i in range(m):\n        x1 = int(stdin.split()[i*2+3])\n        y1 = int(stdin.split()[i*2+4])\n        distance = abs(x-x1) + abs(y-y1)\n        if(distance < ans or ans == 0):\n            ans = distance\n    return ans\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    dists = []\n    for i in range(n - 1):\n        dist = []\n        for j in range(i + 1, n):\n            dist.append(int(stdin.split()[i + 1]) - int(stdin.split()[j + 1]))\n        dists.append(dist)\n    return \"impossible\" if not dists else sum(dists) / (n - 1)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    port_town_1_distances = stdin.split()\n    n = len(port_town_1_distances)\n    distances_between_pairs_of_port_towns = []\n    for i in range(1, n):\n        distance_between_two_port_towns = float(port_town_1_distances[0])\n        for j in range(1, i):\n            distance_between_two_port_towns += float(port_town_1_distances[j])\n        distances_between_pairs_of_port_towns.append(distance_between_two_port_towns)\n    return 'impossible' if len(distances_between_pairs_of_port_towns) == 0 else sum(distances_between_pairs_of_port_towns) / len(distances_between_pairs_of_port_towns)\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    n = int(s[0])\n    if n % 2!= 0:\n        return \"impossible\"\n    n_ = int(math.sqrt(n))\n    table = [[] for _ in range(n_ + 1)]\n    for i in range(1, n_ + 1):\n        for j in range(i, n_ + 1):\n            table[i].append(int(s[i]) + int(s[j]))\n    res = 0\n    for i in range(n_):\n        res += sum(table[i])\n    return str(res / n)"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.splitlines()\n    n = int(inp[0])\n    s = inp[1:]\n    ans = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                ans = min(ans, int(s[i][j]))\n    if ans == float('inf'):\n        return 'impossible'\n    return str(ans / n)"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lines = stdin.split()\n    distances = list(map(int, lines[1:]))\n    if len(distances) < 2:\n        return \"impossible\"\n    return round(sum(distances) / len(distances), 10)\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    distance_table = []\n    for i in range(n-1):\n        distance_table.append(list(map(int, stdin.split())))\n    print(distance_table)\n    # if n == 3:\n    #     print(distance_table)\n    return"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inp = list(map(int, stdin.split('\\n')))\n    if len(inp) < 2:\n        return \"impossible\"\n    return \"impossible\" if not min(inp) <= max(inp) <= max(inp) else sum(inp) // len(inp)\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    distances = []\n    for i in range(1, n+1):\n        distances.append(int(lines[i]))\n    return str(round(average(distances)))\n\ndef"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    ports = [int(x) for x in stdin.split()]\n    if ports[0]!= len(ports) - 1:\n        return 'impossible'\n    distances = []\n    for i in range(0, len(ports)):\n        distances.append([])\n        for j in range(i, len(ports)):\n            distances[i].append(sum([abs(x - y) for x, y in zip(ports[i:], ports[i + 1:])]))\n    print(distances)\n    avg = 0\n    for i in range(len(distances)):\n        avg += distances[i][i]\n    avg = avg / (len(distances) * (len(distances) - 1))\n    return '{:.10f}'.format(avg)\n"
    },
    {
        "number": 3334,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = 0\n    d = []\n    while i < n:\n        d.append(map(int, stdin.split(\"\\n\")[i]))\n        i += 1\n\n    i = 0\n    dists = []\n    while i < len(d[0]):\n        dists.append(0)\n        i += 1\n\n    i = 0\n    while i < len(d):\n        j = 0\n        while j < len(d[0]):\n            dists[j] += d[i][j]\n            j += 1\n        i += 1\n\n    avg = sum(dists)/len(dists)\n    if avg.is_integer():\n        avg = int(avg)\n    return str(avg)"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(1, n):\n            for c in range(1, n):\n                if a**2 + b**2 == c**2 and a + b > c:\n                    count += 1\n    return str(count)\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(2, n):\n        for b in range(2, n):\n            for c in range(2, n):\n                if a**2 + b**2 == c**2 and a <= b <= c:\n                    count += 1\n    return str(count)\n\nsolution(\"7\")\n"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    total = 0\n    for a in range(1, n):\n        for b in range(a + 1, n):\n            c = n - a - b\n            if gcd(a, b) == 1 and gcd(c, n) == 1:\n                total += 1\n    return str(total)\n"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    count = 0\n    for i in range(1, int(stdin)+1):\n        a, b, c = i, i*2, i**2\n        if (a**2 + b**2) == (c**2) and a + b <= c and a**2 <= b**2:\n            count += 1\n    return str(count)\n    '''\n    def is_pythagoras(a, b, c):\n        if (a**2 + b**2) == (c**2) and a + b <= c and a**2 <= b**2:\n            return True\n        return False\n    \n    mod_range = range(1, int(stdin)+1)\n    count = 0\n    for i in mod_range:\n        for j in mod_range:\n            if is_pythagoras(i, j, int(stdin)):\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ans = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a**2 + b**2 == c**2:\n                ans += 1\n    return str(ans)"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    t = 0\n    for a in range(1, n):\n        for b in range(1, n):\n            if a**2 + b**2 == (n-a)*(n-b):\n                t += 1\n    return str(t)"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n):\n        for j in range(i, n):\n            k = i * j\n            if k > n:\n                break\n            if isPythagoreanTriple(i, j, k):\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stdout.write(str(count(int(stdin))),'\\n')\n\ndef"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 3\n    b = 5\n    c = 7\n    c2 = a**2 + b**2\n    while c2 > n:\n        a += 2\n        b += 2\n        c2 = a**2 + b**2\n    \n    while b!= 0:\n        if (c2 + b**2) % c == 0:\n            return str(a) + \" \" + str(b) + \" \" + str(c)\n        b -= 2\n        c2 = a**2 + b**2\n    \n    return str(a) + \" \" + str(b) + \" \" + str(c)\n"
    },
    {
        "number": 3335,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n-1):\n        for b in range(1, n-1):\n            for c in range(1, n-1):\n                if a**2 + b**2 == c**2 and a <= b and a**2 <= c and a**2 >= b and a**2 >= c and a+b+c == n:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    students = []\n    for line in stdin.splitlines():\n        students.append((line.split()))\n\n    total = 0\n    for s in students:\n        if s[2] == \"F\" and s[1] == \"M\":\n            if int(s[0]) - 40 <= int(s[0]) <= int(s[0]) + 40:\n                total = total + 1\n\n    return str(total)\n"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    length = len(stdin)\n    for i in range(length):\n        stdin[i] = stdin[i].split(' ')\n    return length"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    res = []\n    for i in stdin:\n        if i[0].isdigit():\n            res.append(int(i))\n        else:\n            break\n    return str(max(res))\n"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"3\""
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    female = list(map(lambda x: x.split(), stdin.splitlines()[1:]))\n    male = list(map(lambda x: x.split(), stdin.splitlines()[2:]))\n    female_height = list(map(lambda x: float(x[0]), female))\n    male_height = list(map(lambda x: float(x[0]), male))\n    female_music = list(map(lambda x: x[1], female))\n    male_music = list(map(lambda x: x[1], male))\n    female_sport = list(map(lambda x: x[2], female))\n    male_sport = list(map(lambda x: x[2], male))\n    combinations = {}\n    for x in female_height:\n        for y in male_height:\n            if x + y <= 3000:\n                if (x > 40 and y > 40):\n                    if (x!= y):\n                        diff_in_height = x - y\n                        if (diff_in_height <= 40):\n                            combinations[str(diff_in_height)] = combinations.get(\n                                str(diff_in_height), 0) + 1\n    return max(combinations, key=lambda x: combinations[x])\n\n\nprint(solution(input()))"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    couple = []\n    for i in range(n):\n        b, g = stdin.split()\n        a = int(b)\n        c = int(g)\n        if abs(a - c) > 40 and a == g:\n            couple.append([a, c])\n    return str(len(set(couple)))\n\nstdin = input()\nprint(solution(stdin))"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    student_height = {}\n    students = []\n    for line in stdin.splitlines():\n        student_height.setdefault(line[0], []).append(line[1:])\n    for key, val in student_height.items():\n        students.append((key, val))\n    students.sort(key=lambda x: x[0])\n    candidate = 1\n    max_candidate = 1\n    while candidate < len(students):\n        p1 = students[candidate-1][0]\n        p2 = students[candidate][0]\n        if student_height[p1][0] == student_height[p2][0]:\n            if student_height[p1][1] == student_height[p2][1]:\n                if student_height[p1][2] == student_height[p2][2]:\n                    if student_height[p1][3] == student_height[p2][3]:\n                        candidate += 1\n                        if candidate > max_candidate:\n                            max_candidate = candidate\n            elif student_height[p1][1] == student_height[p2][1] == 'M':\n                candidate += 1\n                if candidate > max_candidate:\n                    max_candidate = candidate\n            else:\n                candidate += 1\n                if candidate > max_candidate:\n                    max_candidate = candidate\n        elif student_height[p1][0] == student_height[p2][0] + 40:\n            candidate += 1\n            if candidate > max_candidate:\n                max_candidate = candidate\n        else:\n            candidate += 1\n            if candidate > max_candidate:\n                max_candidate = candidate\n    return max_candidate\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return '3'\n\"\"\"\n\ndef"
    },
    {
        "number": 3336,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    l = len(stdin.splitlines()[0].split())\n    for line in stdin.splitlines():\n        l = max(l, len(line.split()))\n    return str(l)"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 0:\n        raise ValueError(f'Value must be > 0, was {n}')\n    _ = map(str, range(n))\n    res = ''\n    while True:\n        for _ in _:\n            res += input()\n        if not res:\n            return\n        yield res\n        _ = list(map(int, input().split(' ')))\n        if not _:\n            return\n        res = ''\n    # Driver Code\n\n\nfor output in solution(stdin):\n    print(output)\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    curr_stack = 0\n    for i in range(len(stdin)):\n        if stdin[i] == 'a':\n            curr_stack += 1\n            count += 1\n        elif stdin[i] == 'b':\n            curr_stack -= 1\n        elif stdin[i] == 'c':\n            count += len(str(curr_stack))\n    return str(count)\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    steps = stdin.split()\n    n = int(steps[0])\n\n    def get_val(x):\n        return int(x) if x.isnumeric() else x\n    \n    def remove_stack(stack, value):\n        stack.append(value)\n\n    def stack_count(stack):\n        count = 0\n        while stack:\n            stack = stack[1:]\n            count += 1\n        return count\n\n    for step in range(n):\n        stack = list(map(get_val, steps[step + 1].split()))\n        operation = steps[step + 2]\n        \n        if operation == \"a\":\n            remove_stack(stack, stack[-1])\n        elif operation == \"b\":\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n        else:\n            stack_len = stack_count(stack)\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack[-1])\n            remove_stack(stack, stack["
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    A = list(map(int, stdin.split()))\n\n    # answer = 0\n    # for a in A:\n    #     if a == 'a':\n    #         answer += 1\n    #     else:\n    #         answer += A.count(int(a))\n    # print(answer)\n    def bfs():\n        from collections import deque\n        que = deque()\n        que.append([0, 0])\n        visited = set()\n        visited.add(0)\n        while que:\n            cur = que.popleft()\n            if cur[0] == N:\n                return cur[1]\n            for v in range(N + 1):\n                if v not in visited:\n                    if cur[0] == v:\n                        continue\n                    if cur[0] + 1 < N:\n                        que.append([cur[0] + 1, cur[1] + 1])\n                    if cur[0] - 1 >= 0:\n                        que.append([cur[0] - 1, cur[1] + 1])\n                    visited.add(v)\n    return str(bfs())"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    s = stdin.strip()\n    nums = []\n    stacks = [[] for _ in range(N)]\n    for _ in range(N):\n        t = stdin.strip().split()\n        if t[0] == \"a\":\n            stacks[int(t[1])].append(int(t[2]))\n            nums.append(int(t[2]))\n        else:\n            if t[0] == \"b\":\n                if len(stacks[int(t[1])]) == 0:\n                    nums.append(0)\n                    continue\n                else:\n                    nums.append(len(stacks[int(t[1])]))\n            else:\n                if len(stacks[int(t[1])]) == 0:\n                    nums.append(0)\n                    continue\n                else:\n                    if len(stacks[int(t[2])]) == 0:\n                        nums.append(0)\n                    else:\n                        nums.append(len(stacks[int(t[2])]))\n            stacks[int(t[1])] = []\n    return \"\\n\".join(map(str, nums))\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_of_stacks = int(stdin)\n    stacks = []\n    stack_count = {}\n\n    for i in range(num_of_stacks):\n        stack = stdin.split()[i]\n        stacks.append(stack)\n        stack_count[stack] = 0\n\n    for i in range(num_of_stacks):\n        stack = stdin.split()[i]\n        while stack:\n            if stack.startswith('b') and stack_count[stack] == 0:\n                stack_count[stack] += 1\n            if stack.startswith('c') and stack_count[stack] > 0:\n                stack_count[stack] -= 1\n            stack = stack[1:]\n            stack_count[stack] += 1\n\n    return_string = ''\n    for stack in stacks:\n        if stack_count[stack] > 0:\n            return_string += str(stack_count[stack]) + '\\n'\n        else:\n            return_string += '1\\n'\n    return return_string\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_n = int(stdin)\n    stacks = []\n    for _ in range(input_n):\n        inp = stdin.split()\n        if inp[0] == \"a\":\n            stacks.append(int(inp[1]))\n        elif inp[0] == \"b\":\n            stacks.remove(stacks[-1])\n        elif inp[0] == \"c\":\n            stacks.remove(stacks[-1])\n            stacks.append(int(inp[1]))\n    print(*stacks, sep='\\n')\n    return\n\n\nsolution(input())\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    ops = {\n        1: (2,),\n        2: (2, 3),\n        3: (2,),\n    }\n    ops_count = {\n        1: (2,),\n        2: (3,),\n        3: (3,),\n    }\n    for _ in range(N):\n        op, *stack = stdin.split()\n        if op == 'a':\n            print(*ops[2][stack[0]], end='')\n        elif op == 'b':\n            print(*ops[1][stack[0]], end='')\n        elif op == 'c':\n            print(*ops[3][stack[0]], end='')\n        else:\n            raise RuntimeError(f'Unknown operation {op}')\n    return stdin\n"
    },
    {
        "number": 3337,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    stack = []\n    for _ in range(n):\n        line = stdin.split('\\n')[_]\n        operation = line.split()[0]\n        if operation == 'a':\n            stack.append(int(line.split()[1]))\n        elif operation == 'b':\n            stack.remove(stack[-1])\n        elif operation == 'c':\n            print(len(set(stack)))\n    return ''"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split(\"\\n\")\n\n    n = int(lines[0])\n    k = int(lines[1])\n    num_partners = 0\n    g, p, g_a, p_a = 0, 0, 0, 0\n    partners = []\n\n    for i in range(2, n + 2):\n        g, p, g_a, p_a = map(int, lines[i].split())\n        partners.append([g, p, g_a, p_a])\n\n    partners.sort(key=lambda x: (x[0], x[1]))\n    partners = np.array(partners)\n\n    for i in range(len(partners)):\n        if partners[i, 2] == 0 and partners[i, 3] == 0:\n            num_partners += 1\n\n    return str(num_partners)\n\nprint(solution(\"\"\"\n3 2\n78 61 88 71\n80 80 90 90\n70 90 80 100\n90 70 0 0\n80 67 0 0\n90 63 0 0\n\"\"\"))\n"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    frags, steps = map(int, stdin.split())\n    return str(max(1, max(frags, steps)))"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.strip().split()))\n    partners = []\n    for i in range(k):\n        g, p = list(map(int, stdin.strip().split()))\n        partners.append((g, p))\n    partners.sort(reverse=True, key=lambda p: (p[0], -p[1]))\n    frags = sum([p[0] for p in partners])\n    steps = sum([p[1] for p in partners])\n    d = frags + steps\n    if d > n:\n        return str(n)\n    return str(d)\n\n\ndef"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return '5'\n"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.strip().split())\n    return str(max([(a - b, c - d) for a, b, c, d in zip(*(map(int, stdin.strip().split())))]))\n"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin_arr = stdin.split('\\n')\n\n    n, k = map(int, stdin_arr[0].split())\n    x_arr = []\n    for i in range(1, n + 1):\n        x_arr.append(map(int, stdin_arr[i].split()))\n\n    max_d = 0\n    max_d_arr = []\n    for x in x_arr:\n        tmp = 0\n        x_arr.sort(key=lambda x: x[0], reverse=True)\n        for i in range(k):\n            tmp += max(x[i], x[i + 1])\n        max_d = max(max_d, tmp)\n        max_d_arr.append(tmp)\n    return str(max_d)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The program takes input from stdin, stores it into an array, and returns the maximum diversity of the array.\n    \"\"\"\n    n, k = map(int, stdin.split())\n    max_diversity = 0\n    for _ in range(n):\n        g, p = map(int, stdin.split())\n        if g >= p:\n            diversity = k\n        else:\n            g, p = map(int, stdin.split())\n            diversity = g + p\n        max_diversity = max(max_diversity, diversity)\n    return str(max_diversity)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3338,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    partners = {}\n    for i in range(1, n+1):\n        g, p, g_, p_ = map(int, lines[i].split())\n        partners[i] = (g, p, g_, p_)\n    partners = [(i, partners[i][0], partners[i][1], partners[i][2], partners[i][3]) for i in range(1, n+1)]\n    partners.sort(key=lambda x: (x[0], -x[1], x[2], -x[3], -x[4]))\n    partners = set(partners)\n    partners = list(partners)\n    maxd = 1\n    for i in range(k):\n        if partners[i][2] == 0 and partners[i][3] == 0:\n            continue\n        if partners[i][2] > partners[i][3]:\n            maxd *= 2\n            partners[i] = (partners[i][0], partners[i][1], partners[i][2] - 1, partners[i][3], partners[i][4])\n        else:\n            partners[i] = (partners[i][0], partners[i][1], partners[i][2], partners[i][3] - 1, partners[i][4])\n    partners.sort(key=lambda x: (x[0], -x[1], x[2], -x[3], -x[4]))\n    partners = set(partners)\n    partners = list(partners)\n    return str(maxd)\n\n\nprint(solution(input()))\n\"\"\"\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(m)]\n    count = 0\n    \n    def even_odd_check(start):\n        if start % 2:\n            return False\n        return True\n        \n    def is_even(start, end):\n        if even_odd_check(start):\n            return True\n        return False\n    \n    def traverse(start, end):\n        if is_even(start, end):\n            count += 1\n            if is_even(end, start):\n                return\n            for i in range(start + 1, end + 1):\n                traverse(i, end)\n            \n    for road in roads:\n        traverse(road[0], road[1])\n    print(count)\n    return \"\"\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(numWays(int(stdin.strip().split()[0]), int(stdin.strip().split()[1])))\n\ndef"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    intersections = int(stdin.split()[0])\n    roads = stdin.split()[1:]\n    \n    intersection = {}\n    for road in roads:\n        start, end = int(road.split()[0]), int(road.split()[1])\n        if start not in intersection:\n            intersection[start] = set()\n        if end not in intersection:\n            intersection[end] = set()\n        intersection[start].add(end)\n        intersection[end].add(start)\n\n    result = 0\n    for key in intersection:\n        if len(intersection[key]) % 2 == 1:\n            result += 1\n    \n    return result % 10000000009\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    roads = list(map(lambda x: x.split(), stdin.split('\\n')))\n    count = 0\n    # # Debugging\n    # for road in roads:\n    #     print(road)\n    #\n    # The number of roads in Evenland is 2.\n    # One way to connect the roads is:\n    # 1. Destroy the roads.\n    # 2. Remove the rest of the roads.\n    #\n    # So the number of ways to connect the roads is 2.\n    # def do_destroy(roads, road_idx):\n    #     # Make a copy of the roads so we can mutate it.\n    #     roads = roads[:]\n    #     # Remove the road at the given index.\n    #     del roads[road_idx]\n    #     # Remove all other roads.\n    #     for road in roads:\n    #         if road[0] == road_idx:\n    #             del road[0]\n    #         elif road[1] == road_idx:\n    #             del road[1]\n    #     return roads\n    #\n    # def connect_roads(roads):\n    #     count = 0\n    #     for i in range(len(roads)):\n    #         for j in range(len(roads)):\n    #             if roads[i][0] == roads[j][1] or roads[i][1] == roads[j][0]:\n    #                 roads = do_destroy(roads, j)\n    #                 count += 1\n    #     return count\n    #\n    # print(connect_roads(roads))\n    return str(connect_roads(roads))\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    answer = 0\n    roads = list(map(lambda x: tuple(map(int, x.split())), stdin.splitlines()))\n\n    def even_or_odd(roads: list) -> list:\n        ways = []\n        for road in roads:\n            if road[1] == road[0]:\n                ways.append(1)\n            else:\n                ways.append(0)\n        return ways\n\n    ways = even_or_odd(roads)\n    answer = sum([ways[i] for i in range(len(ways)) if i % 2 == 0])\n    return str(answer % 10000000009)\n\nsolution(\"\"\"2 5\n1 2\n1 3\n1 4\n2 3\n2 4\"\"\")\nsolution(\"\"\"5 6\n1 2\n2 3\n3 4\n4 5\n2 3\"\"\")\nsolution(\"\"\"10 10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n2 3\"\"\")\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(i) for i in stdin.split()]\n    adj = [[] for i in range(N)]\n    for i in range(M):\n        adj[int(stdin.split()[i * 2])].append(int(stdin.split()[i * 2 + 1]))\n        adj[int(stdin.split()[i * 2 + 1])].append(int(stdin.split()[i * 2]))\n    ways = 0\n    visited = set()\n    for start in adj:\n        if start:\n            visited.add(start[0])\n            ways += 1\n            stack = [start[0]]\n            while stack:\n                node = stack.pop()\n                for next_node in adj[node]:\n                    if next_node not in visited:\n                        visited.add(next_node)\n                        stack.append(next_node)\n    return str(ways)\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    m = int(stdin.splitlines()[1])\n\n    odds = 0\n    evens = 0\n\n    for line in stdin.splitlines()[2:]:\n        a, b = map(int, line.split())\n        odds += (a - 1) + (b - 1)\n        evens += (a - 1) + (b - 1)\n    \n    return evens - odds\n\nprint(solution(input()))"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    arr = [[] for i in range(n)]\n    for i in range(m):\n        arr[int(stdin.split()[i*2])-1].append(int(stdin.split()[i*2+1])-1)\n    odd_cnt = 0\n    for i in range(len(arr)):\n        odd_cnt += len(set(arr[i]) ^ set([i]))\n    return str(odd_cnt % 10000000009)"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    roads = stdin.splitlines()\n    sum_even = 0\n    for road in roads:\n        a, b = road.split()\n        a = int(a)\n        b = int(b)\n        sum_even += (b-a) // 2\n    return sum_even % 1000000009\n"
    },
    {
        "number": 3339,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n    roads.sort()\n    res = 0\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N and roads[j][0] == roads[i][0] + 1:\n            res += 1\n            j += 1\n        i += 1\n    return res % (10 ** 9 + 7)"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cities: List[List[int]] = []\n    for line in stdin.splitlines():\n        cities.append([int(city) for city in line.split(' ')])\n    return answer(cities)\n\ndef"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        a, b = map(int, stdin.strip().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    # print(graph)\n    cancel = [[0, 0], 0, 0]\n    # cancel_count = 0\n    # new_count = 0\n    # print(graph[2])\n    while cancel[0][1] < n - 1:\n        cancel[0][1] = cancel[0][1] + 1\n        if cancel[0][1] in graph[cancel[0][0]]:\n            # print(cancel)\n            for x in graph[cancel[0][1]]:\n                if x not in graph[cancel[0][0]]:\n                    if cancel[1] > x:\n                        cancel[1], cancel[2] = x, cancel[1]\n                    elif cancel[1] == x:\n                        if cancel[2] > x:\n                            cancel[2], cancel[1] = x, cancel[2]\n                    elif cancel[2] == x:\n                        pass\n                    else:\n                        continue\n        elif cancel[0][1] in graph[cancel[0][0]]:\n            # print(cancel)\n            for x in graph[cancel[0][0]]:\n                if x not in graph[cancel[0][1]]:\n                    if cancel[1] > x:\n                        cancel[1], cancel[2] = x, cancel[1]\n                    elif cancel[1] == x:\n                        if cancel[2] > x:\n                            cancel[2], cancel[1] = x, cancel[2]\n                    elif cancel[2] == x:\n                        pass\n                    else:\n                        continue\n        elif cancel[0][1] not in graph[cancel[0][0]]:\n            # print(cancel)\n            for x in graph[cancel[0][0]]:\n                if x not in graph[cancel[0][1]]:\n                    if cancel[1] > x:\n                        cancel[1], cancel[2] = x, cancel[1]\n                    elif cancel[1] == x:\n                        if cancel[2] > x:\n                            cancel[2], cancel[1] = x, cancel[2]\n                    elif cancel[2] == x:\n                        pass\n                    else:\n                        continue\n        else:\n            pass\n    # print(cancel)\n    return f'{cancel[1]} {cancel[2]}'"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your code should return the following:\n    3 4 2\n    2 4\n    1 3\n    >>> solution(\"3\\n1 2\\n2 3\\n3 4\\n\")\n    '2 4 1 3'\n    >>> solution(\"4\\n1 2\\n2 3\\n3 4\\n\")\n    '2 4 1 3'\n    >>> solution(\"2\\n4\\n2\\n3\\n\")\n    '4 3'\n    >>> solution(\"4\\n1 2\\n2 3\\n3 4\\n\")\n    '2 4'\n    \"\"\"\n    N = int(stdin.strip())\n    graph = dict()\n    for line in stdin.split(\"\\n\"):\n        a, b = line.split()\n        if a not in graph:\n            graph[a] = []\n        graph[a].append(b)\n        if b not in graph:\n            graph[b] = []\n        graph[b].append(a)\n\n    # print(graph)\n    min_flights = 1\n    best_flight = None\n\n    # 1) find a flight to replace\n    cities = []\n    for start in graph:\n        # find a city to replace the start city\n        for end in graph[start]:\n            cities.append((end, start))\n    cities.sort(key=lambda x: x[1])\n    start = cities[0][0]\n    end = cities[-1][1]\n    # print(start, end)\n    # 2) find a city to add to\n    for end in graph[start]:\n        if end not in cities:\n            cities.append(end)\n    cities.sort(key=lambda x: x)\n    end = cities[0][0]\n    # print(start, end)\n    # 3) find the best flight\n    for start, end in zip(cities, cities[1:]):\n        if start[1]!= end[0]:\n            best_flight = max(best_flight, (start[1], end[0]))\n        if start[0]!= end[1]:\n            best_flight = max(best_flight, (start[0], end[1]))\n        min_flights = max(min_flights, len(graph[start[0]]) + len(graph[end[1]]) - 1)\n\n    print(min_flights, best_flight)\n    return min_flights, best_flight[0], best_flight[1]\n"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    inputs = list(map(int, inputs[0].split()))\n    in_range = inputs[0]\n    out_range = inputs[1]\n    in_range_array = inputs[2:]\n    out_range_array = inputs[3:]\n    in_range_array.sort()\n    out_range_array.sort()\n    if in_range_array[0] == in_range_array[-1]:\n        in_range_array.pop(0)\n        in_range_array.pop(-1)\n    if out_range_array[0] == out_range_array[-1]:\n        out_range_array.pop(0)\n        out_range_array.pop(-1)\n    if in_range_array[0]!= out_range_array[0]:\n        return \"Impossible\"\n    in_range_set = set(in_range_array)\n    out_range_set = set(out_range_array)\n    all_cities_set = set(in_range_array + out_range_array)\n    cancels = in_range_array + out_range_array\n    to_add = list(all_cities_set - in_range_set - out_range_set)\n    to_add.sort()\n    to_add.pop(0)\n    to_add.pop(-1)\n    to_add.reverse()\n    sorted_cancels = sorted(cancels)\n    sorted_to_add = sorted(to_add)\n    to_add_2 = []\n    cancels_2 = []\n    to_add_2.append(to_add[0])\n    cancels_2.append(cancels[0])\n    to_add_2.append(to_add[1])\n    cancels_2.append(cancels[1])\n    for i in range(2, len(to_add)):\n        to_add_2.append(to_add[i])\n        cancels_2.append(cancels[i])\n    for i in range(2, len(cancels)):\n        to_add_2.append(to_add[i])\n        cancels_2.append(cancels[i])\n    to_add_2.sort()\n    cancels_2.sort()\n    print(to_add_2)\n    print(cancels_2)\n    # to_add_2.sort()\n    # if to_add_2 == to_add:\n    #     return \"Impossible\"\n    if len(to_add_2) >= len(cancels_2):\n        return \"Impossible\"\n    for i in range(len(to_add_2)):\n        if to_add_2[i] not in can_add:\n            to_add_2[i] = can_add[0]\n            cancels_2[i] = can_cancel[0]\n            can_add.pop(0)\n            can_cancel.pop(0)\n            break\n    print(to_add_2)\n    print(cancels_2)\n    if can_add:\n        for i in range(len(to_add_2)):\n            if to_add_2[i] not in can_add:\n                to_add_2[i] = can_add[0]\n                cancels_2[i] = can_cancel[0]\n                can_add.pop(0)\n                can_cancel.pop(0)\n                break\n    print(to_add_2)\n    print(cancels_2)\n    return \"1\" + str(len(to_add_2) + len(cancels_2) - 1) + \"\\n\" + \" \".join(str(i) for i in to_add_2) + \"\\n\" + \" \".join(str(i) for i in can_cancel) + \"\\n\" + \" \".join(str(i) for i in can_add) + \"\\n\" + \" \".join(str(i) for i in cancels_2)"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    flights = []\n    for line in stdin.strip().split(\"\\n\"):\n        flights.append((int(line.split()[0]), int(line.split()[1])))\n    flights.sort(key=lambda x: x[0])\n\n    canceled = 1\n    added = 2\n\n    for i in range(n - 1):\n        if flights[i][0] == flights[i + 1][0] and flights[i][1] == flights[i + 1][1]:\n            canceled += 1\n            if canceled > max_canceled:\n                max_canceled = canceled\n                best_canceled = flights[i]\n                best_added = flights[i + 1]\n        elif flights[i][1] == flights[i + 1][1] and flights[i][0] == flights[i + 1][0]:\n            canceled += 1\n            if canceled > max_canceled:\n                max_canceled = canceled\n                best_canceled = flights[i]\n                best_added = flights[i + 1]\n\n    return str(max_canceled) + \" \" + str(best_canceled[0]) + \" \" + str(best_canceled[1]) + \" \" + str(best_added[0]) + \" \" + str(best_added[1])\n"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    g = Graph(n)\n    # Add flights\n    for i in range(1, n + 1):\n        g.add_edge(int(stdin.split()[i - 1]), i)\n    # Add edges\n    for i in range(2, n + 1):\n        for j in range(i + 1, n + 1):\n            g.add_edge(j, i)\n    # All possible flights\n    all_flights = [flights for flights in g.all_flights()]\n    # Return the result\n    return str(len(all_flights)) +'' + str(all_flights[0]) +'' + str(all_flights[1])\n\n\ndef"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = sorted(list(map(int, a.split())))\n    b = sorted(list(map(int, b.split())))\n\n    for i in range(len(a) - 1):\n        for j in range(len(b) - 1):\n            if a[i] < a[i + 1] and b[i] < b[i + 1]:\n                a[i + 1] = a[i] + 1\n            if a[i] > a[i + 1] and b[i] > b[i + 1]:\n                b[i + 1] = b[i] + 1\n    return \"{}\\n{}\\n{}\".format(a[0], b[0], a[-1] + b[-1])\nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    flights = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    flights.sort(key=lambda x: x[1] - x[0])\n    del flights[0]\n    return \" \".join(map(str, flights))\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3340,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    From the input, find the best flight to cancel, and the best new flight to add.\n\n    To do this, you first have to make a dictionary of all the flights.\n\n    To make a dictionary, you first have to create a dictionary with the cities as keys, and a list of their corresponding flights as values.\n\n    Then, use the set_first_flight function, to set the initial flight to be the first one.\n\n    Then, repeat this procedure until there is only one flight left.\n\n    '''\n    pass\n    # dictionary of all cities\n    cities = {}\n    # the first flight\n    city1 = []\n    # the second flight\n    city2 = []\n    # the final flight\n    city3 = []\n\n    # initialize first flight\n    set_first_flight(cities, city1)\n\n    # repeating until only one flight left\n    while len(cities)!= 1:\n        # update dictionary\n        update_dict(cities)\n        # update first flight\n        set_first_flight(cities, city1)\n        # update second flight\n        set_second_flight(cities, city2)\n        # update third flight\n        set_third_flight(cities, city3)\n\n    return \" \".join([str(city1[0]), str(city2[0]), str(city3[0])])\n\ndef"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    [n, p_n, d_n, q_n, e_n] = stdin.strip().split()\n    n = int(n)\n    p_n = int(p_n)\n    d_n = int(d_n)\n    q_n = int(q_n)\n    e_n = int(e_n)\n    cnt = 0\n    res = 0\n    while (n > 0):\n        if (p_n > d_n):\n            cnt = cnt + (p_n - d_n)\n        else:\n            cnt = cnt + (d_n - p_n)\n        p_n = q_n\n        d_n = e_n\n        q_n = q_n + cnt\n        if (q_n <= p_n):\n            if (d_n - q_n) > (p_n - q_n):\n                d_n = d_n - (p_n - q_n)\n            else:\n                d_n = d_n - (q_n - p_n)\n            cnt = cnt - (p_n - q_n)\n            q_n = q_n + cnt\n            res = max(res, q_n)\n        n = n - 1\n    return str(res)\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _, N = stdin.split()\n    N = int(N)\n    max_profit = 0\n    for _ in range(N):\n        p, d = map(int, stdin.split())\n        max_profit += d - p\n    return str(max_profit)\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, n = list(map(int, stdin.split()))\n    producers = []\n    consumer = []\n    for i in range(n):\n        producers.append(list(map(int, stdin.split())))\n        consumer.append(list(map(int, stdin.split())))\n    return (max_profit(m, n, producers, consumer))\n\n\ndef"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split()\n    m, n = int(rows[0]), int(rows[1])\n    _, producer_nums, consumer_nums = stdin.split()\n    profit = 0\n    for i in range(1, m+1):\n        pr, day_of_pr = int(producer_nums[i-1]), int(consumer_nums[i-1])\n        profit += abs(pr - day_of_pr)\n    return str(profit)\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    pr = [list(map(int, stdin.split())) for _ in range(m)]\n    nc = [list(map(int, stdin.split())) for _ in range(n)]\n    pr.sort(key=lambda x: x[1])\n    nc.sort(key=lambda x: x[1], reverse=True)\n    days = 0\n    while days < n and pr[days][0] >= nc[days][0]:\n        days += 1\n    return str(days)\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    # for i in range(m + 1):\n    #     dp[i][0] = 0\n    for j in range(n + 1):\n        dp[0][j] = 0\n    # for i in range(1, m + 1):\n    #     dp[i][0] = 0\n    # for j in range(1, n + 1):\n    #     dp[0][j] = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]) + int(stdin.split()[2 * i - 1])\n    return str(dp[-1][-1])"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    pr = [[int(i) for i in stdin.split()] for j in range(n)]\n    cons = [[int(i) for i in stdin.split()] for j in range(n)]\n    pr.sort()\n    cons.sort()\n    print(\"max profit:\", max_profit(m, n, pr, cons))\n\n\ndef"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    for i in range(int(stdin.split()[0])):\n        p = int(stdin.split()[i * 2 + 1])\n        d = int(stdin.split()[i * 2 + 2])\n        print(max(0, p - d))\n    return\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.strip().split())\n    prod, cons = map(int, stdin.strip().split())\n    prod_days = [(price, day) for day, price in enumerate(map(int, stdin.strip().split()), start=1)]\n    cons_days = [(price, day + 1) for day, price in enumerate(map(int, stdin.strip().split()), start=prod + 1)]\n\n    profit = 0\n    while prod_days and cons_days:\n        d1, price1 = prod_days.pop(0)\n        d2, price2 = cons_days.pop(0)\n\n        profit = max(profit, price1 - price2)\n\n        if d1 <= prod:\n            prod_days.append((d1, price1))\n        if d2 <= cons:\n            cons_days.append((d2, price2))\n\n    return profit\n"
    },
    {
        "number": 3341,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    for i in range(m):\n        p, d = map(int, stdin.split())\n        p1, d1 = p, d\n        if d1 >= p:\n            p1 = d1\n        d = int(input())\n        if d >= p1:\n            p1 = d\n        while d > 0:\n            d -= p1\n    print(p1)\n\nsolution(input())\n"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    \n    old_fence_posts = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        old_fence_posts.append((a, b))\n    \n    new_fence_posts = []\n    for _ in range(K):\n        a, b = map(int, stdin.split())\n        new_fence_posts.append((a, b))\n    \n    onions = {}\n    for a, b in old_fence_posts:\n        onions[a] = b\n    \n    onions_in_hull = set()\n    for a, b in new_fence_posts:\n        onions_in_hull |= {x for x in range(a, b + 1)}\n    \n    onions_not_in_hull = set(onions.keys()) - onions_in_hull\n    \n    onion_count = 0\n    for a, b in old_fence_posts:\n        onion_count += onions_in_hull.pop()\n    \n    for x in onions_not_in_hull:\n        onion_count += max(0, N - len(onions_in_hull))\n    \n    return str(onion_count)"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    onions = sorted(map(int, stdin.split()))\n    # Remove all the duplicates from the list of onions and sort it\n    onions = sorted(list(dict.fromkeys(onions)))\n\n    # number of fence posts that are on the convex hull\n    cnt = 0\n\n    # flag is used to break out of the loop\n    flag = False\n    for i in range(len(onions)):\n        # find the fence posts that are on the convex hull\n        # and increment the count\n        if all(onions[i] > i for i in range(len(onions)) if i + 1!= onions[i]):\n            cnt += 1\n\n        # if there is only one post on the convex hull\n        # break the loop\n        if cnt == k:\n            flag = True\n            break\n\n    # print the max number of onions L\u00f6kas can protect\n    if flag:\n        print(cnt)\n    else:\n        print(len(onions))\n"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    positions = []\n    for i in range(n):\n        x, y = list(map(int, stdin.split()))\n        positions.append((x, y))\n    max_onions = 0\n    points = []\n    for j in range(m):\n        points.append(list(map(int, stdin.split())))\n    points.sort(key=lambda x: x[1])\n    points.sort(key=lambda x: x[0])\n    for i in range(k):\n        for j in range(i, k):\n            max_onions = max(max_onions, get_onion_area(positions, points[i], points[j]))\n    return str(max_onions)\ndef"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = list(map(int, stdin.split()))\n    convex_hull = []\n    for i in range(n):\n        x, y = list(map(int, stdin.split()))\n        convex_hull.append([x, y])\n\n    # convex_hull = [[1, 1], [2, 2], [3, 3], [3, 0], [0, 3]]\n    convex_hull.sort(key=lambda x: x[1])\n    # convex_hull = [[1, 1], [2, 2], [3, 3], [3, 0], [0, 3]]\n    convex_hull_vertices = {}\n    for point in convex_hull:\n        convex_hull_vertices[point] = 1\n\n    convex_hull_vertices = sorted(convex_hull_vertices.items(), key=lambda x: x[1])\n    # convex_hull_vertices = [(1, 1), (2, 2), (3, 3), (3, 0), (0, 3)]\n    convex_hull_vertices = list(map(lambda x: x[0], convex_hull_vertices))\n\n    convex_hull_vertices.sort()\n    # convex_hull_vertices = [1, 2, 3, 0, 3]\n    convex_hull_vertices.reverse()\n    # convex_hull_vertices = [3, 0, 3]\n    print(convex_hull_vertices)\n    n_convex_hull_vertices = len(convex_hull_vertices)\n    # n_convex_hull_vertices = 3\n    # n_convex_hull_vertices = 4\n    if n_convex_hull_vertices >= m:\n        return 0\n    # max_convex_hull_vertices = 2\n    # max_convex_hull_vertices = 3\n    max_convex_hull_vertices = n_convex_hull_vertices - m + 1\n    # max_convex_hull_vertices = 4\n    print(max_convex_hull_vertices)\n    if max_convex_hull_vertices < 0:\n        return 0\n\n    fence_posts = [[None] * 2 for _ in range(m)]\n    for i in range(m):\n        fence_posts[i][0] = convex_hull_vertices[i]\n        fence_posts[i][1] = convex_hull_vertices[i + m]\n    # fence_posts = [[1, 1], [2, 2], [3, 3], [3, 0], [0, 3]]\n    print(fence_posts)\n    fence_posts.sort(key=lambda x: x[0])\n    # fence_posts = [[1, 1], [2, 2], [3, 3], [3, 0], [0, 3]]\n    print(fence_posts)\n\n    if k >= n_convex_hull_vertices:\n        return n_convex_hull_vertices\n\n    if k == 0:\n        return 0\n\n    # k = 0\n    # fence_posts = [[1, 1], [2, 2], [3, 3], [3, 0], [0, 3]]\n    fence_posts_vertices = []\n    for fence_post in fence_posts:\n        fence_posts_vertices.append(fence_post[1])\n    # fence_posts_vertices = [3, 0, 3]\n    fence_posts_vertices.sort()\n    # fence_posts_vertices = [1, 2, 3, 0, 3]\n    print(fence_posts_vertices)\n    fence_posts_vertices.reverse()\n    # fence_posts_vertices = [3, 0, 3]\n    print(fence_posts_vertices)\n    fence_posts_vertices = list(map(lambda x: x[0], fence_posts_vertices))\n    # fence_posts_vertices = [1, 2, 3, 0, 3]\n\n    fence_posts_vertices.reverse()\n    print(fence_posts_vertices)\n    max_fence_posts_vertices = len(fence_posts_vertices) - 1\n\n    if max_fence_posts_vertices < 0:\n        return 0\n\n    # max_fence_posts_vertices = 2\n    # max_fence_posts_vertices = 3\n    # max_fence_posts_vertices = 4\n    if max_fence_posts_vertices < k:\n        return 0\n\n    # fence_posts_vertices = [1, 2, 3, 0, 3]\n    fence_posts_vertices = list(map(lambda x: x - 1, fence_posts_vertices))\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    # fence_posts_vertices = [1, 2, 3, 0, 3]\n\n    fence_posts_vertices = list(map(lambda x: x - 1, fence_posts_vertices))\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n\n    # fence_posts_vertices = list(map(lambda x: x - 1, fence_posts_vertices))\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    print(fence_posts_vertices)\n\n    fence_posts_vertices.sort()\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    # fence_posts_vertices = [0, 1, 2, 3, 3]\n    fence_posts_vertices.reverse()\n    # fence_posts_vertices = [3, 3, 2, 1, 0]\n    # fence_posts_vertices = [3, 0, 3, 2, 1]\n    print(fence_posts_vertices)\n    fence_posts_vertices ="
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    onions = []\n    fence = []\n    for i in range(n):\n        x, y = list(map(int, stdin.split()))\n        onions.append((x, y))\n\n    for i in range(m):\n        a, b = list(map(int, stdin.split()))\n        fence.append((a, b))\n\n    result = 0\n\n    for i in range(len(onions)):\n        for j in range(len(fence)):\n            if is_outside(onions[i], fence[j], fence[(j + 1) % len(fence)], fence[(j + 2) % len(fence)]):\n                result += 1\n                break\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    onions = sorted(map(int, stdin.split()))\n    posts = sorted(map(int, stdin.split()))\n    laser_fence = [(x, y) for x, y in posts]\n    laser_fence.append(laser_fence[0])\n\n    for _ in range(k):\n        for i in range(len(onions)):\n            laser_fence.append(onions[i])\n        laser_fence = sorted(laser_fence)\n        laser_fence.pop(0)\n        laser_fence.pop(len(laser_fence) - 1)\n        new_posts = []\n        for i in range(1, len(laser_fence)):\n            if laser_fence[i - 1] <= laser_fence[i]:\n                continue\n            if laser_fence[i - 1] == laser_fence[i]:\n                break\n            temp = laser_fence[i - 1]\n            new_posts.append(temp)\n            for j in range(i + 1, len(laser_fence)):\n                if laser_fence[j] <= laser_fence[i] <= laser_fence[j - 1]:\n                    new_posts.append(laser_fence[j])\n                    break\n        posts = sorted(new_posts)\n        laser_fence.clear()\n        laser_fence = [(x, y) for x, y in posts]\n        laser_fence.append(laser_fence[0])\n\n    return len(onions)\n"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    K, N, M = list(map(int, stdin.split()))\n    polygon = []\n    for _ in range(N):\n        x, y = list(map(int, stdin.split()))\n        polygon.append((x, y))\n    def isInside(x, y):\n        global polygon\n        for (a, b) in polygon:\n            if x > min(a, b) and x < max(a, b) and y > min(a, b) and y < max(a, b):\n                return True\n        return False\n\n    def checkPost(l):\n        a, b = l\n        for (x, y) in polygon:\n            if (x > min(a, b)) and (x < max(a, b)) and (y > min(a, b)) and (y < max(a, b)):\n                return False\n        return True\n\n    def upg(l):\n        global K, M, N, polygon\n        l = l.copy()\n        upgraded = 0\n        for _ in range(K):\n            if not checkPost(l):\n                upgraded += 1\n                l = l[::-1]\n                while not isInside(l[0][0], l[0][1]):\n                    l = l[1:]\n            l = l[1:]\n        return upgraded\n\n    def dist(l, x, y):\n        global K, N, M, polygon\n        _, t = l[0]\n        x1, y1 = polygon[t]\n        _, b = l[-1]\n        x2, y2 = polygon[b]\n        return sqrt((x - x1) ** 2 + (y - y1) ** 2) + sqrt((x - x2) ** 2 + (y - y2) ** 2) - sqrt((x - x1) ** 2 + (y - y2) ** 2) - sqrt((x - x2) ** 2 + (y - y1) ** 2)\n\n    def sortl(l, X):\n        global K, N, M, polygon\n        return sorted(l, key=lambda x: -dist(x, X, 0))\n\n    def getLines(X):\n        return sorted([(a, b) for (a, b) in enumerate(polygon) if dist(sortl(polygon, X), X) == a], key=lambda x: -x[1])\n\n    lines = getLines(0)\n    for (a, b) in lines:\n        L = upg(sortl(polygon, b))\n        if L > 0:\n            return str(L)\n    return str(0)"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(max(0, len(set.union(*[set(f) for f in zip(*[sorted(list(map(int, re.split(r'\\s+', stdin)))) for _ in range(int(stdin.split()[1]))]))]))))"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''\n    3 5 3\n    1 1\n    2 2\n    1 3\n    0 0\n    0 3\n    1 4\n    3 3\n    3 0\n    ''')\n    2\n    '''\n    n, m, k = list(map(int, stdin.split()))\n    xs, ys = zip(*[map(int, stdin.split()) for _ in range(n)])\n    ps = set(zip(xs, ys))\n    xs, ys = zip(*[map(int, stdin.split()) for _ in range(m)])\n    ps.update(zip(xs, ys))\n    return max(\n        sum(map(lambda x: 1 if x in ps else 0, map(lambda x: x - 1, range(k))))\n        for _ in range(k)\n    )\n"
    },
    {
        "number": 3342,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    return \"\""
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, l = list(map(int, stdin.split()))\n    wire = {i: stdin.split()[i + 1] for i in range(n)}\n    wire.update({(i - l) % l + l: stdin.split()[i] for i in range(n)})\n    wire = {k: v for k, v in sorted(wire.items(), key=lambda item: item[0])}\n    print(wire)\n    return 'GHOST' if any(wire[k] == wire[k + 1] for k in range(n - 1)) else 'SAFE'\n    # return 'GHOST' if any(wire[k] == wire[k + 1] for k in range(n - 1)) else 'SAFE'\n"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.split(\"\\n\")\n    l = int(lst[0])\n    n = int(lst[1])\n    res = ''\n    wire = {}\n    for i in range(2, n + 2):\n        tmp = stdin.split(\"\\n\")[i].split(\" \")\n        if tmp[0] == '1':\n            res = 'GHOST'\n        else:\n            res = 'SAFE'\n        wire[int(tmp[1])] = tmp[0]\n    for i in range(0, n):\n        if lst[i + 1] in wire.values():\n            res = 'GHOST'\n    return res\nprint(solution(input()))\n\n\"\"\"\n"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return 'GHOST' if ghost(stdin) else 'SAFE'\n\ndef"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    length = int(lines[0])\n    num_points = int(lines[1])\n    points = []\n    directions = []\n    for i in range(2, 2+num_points):\n        points.append(int(lines[i]))\n        directions.append(lines[i+1])\n    points.sort()\n    direction_count = {}\n    direction_count[\"C\"] = 0\n    direction_count[\"G\"] = 0\n    for i in range(0, len(points)-1):\n        diff = abs(points[i+1] - points[i])\n        direction = directions[i]\n        if direction == \"C\" and diff == 1:\n            direction_count[\"C\"] += 1\n        elif direction == \"C\" and diff > 1:\n            direction_count[\"C\"] += 2\n        elif direction == \"G\" and diff == 1:\n            direction_count[\"G\"] += 1\n        elif direction == \"G\" and diff > 1:\n            direction_count[\"G\"] += 2\n    if direction_count[\"C\"] == 0 and direction_count[\"G\"] == 0:\n        return \"GHOST\"\n    elif direction_count[\"C\"] > direction_count[\"G\"]:\n        return \"COUNTERCLOCKWISE\"\n    else:\n        return \"CLOCKWISE\"\n"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    wire_points = stdin.split()\n    wire_points = list(map(int, wire_points))\n    _, start_point, *wire_points = wire_points\n    \n    _, end_point, *wire_points = wire_points\n    \n    if start_point == end_point:\n        return 'GHOST'\n    \n    steps = 0\n    for i in range(n - 1):\n        if wire_points[i] < wire_points[i + 1]:\n            direction = 'C'\n        else:\n            direction = 'C'\n        steps += (wire_points[i] + wire_points[i + 1]) // 2\n    return 'SAFE' if steps <= 1 else 'GHOST'"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    wire = stdin.split('\\n')\n    points = set()\n    for i in range(n):\n        points.add((int(wire[i][0]), wire[i][1] == 'C'))\n    return 'GHOST' if any(points) else 'SAFE'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    wire_length, number_of_points = map(int, stdin.split())\n    wire_wire = list(stdin.split())\n    return 'GHOST' if bend_wire(wire_wire, wire_length, number_of_points) else 'SAFE'\n\n\ndef"
    },
    {
        "number": 3343,
        "checkpoint": "2B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return 'GHOST' if wireBend(stdin) else 'SAFE'\n\ndef"
    }
]