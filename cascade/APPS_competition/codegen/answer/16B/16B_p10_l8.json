[
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    assert 1 <= n <= 3 * 10 ** 5\n    for i in range(n):\n        stdin = stdin.split('\\n')[1]\n        stack = []\n        for c in stdin:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                while stack[-1]!= '(':\n                    c += stack.pop()\n                stack.pop()\n            else:\n                stack.append(c)\n        assert not stack\n        stdin = stdin.split('\\n')[1]\n        s = 0\n        for c in stdin:\n            if c.isdigit():\n                s += int(c)\n            elif c == '+':\n                s += 1\n            else:\n                s *= 2\n        print(s)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = stdin.strip('\\n').split('\\n')\n    #\n    # return stdin[1]\n    import re\n    arr = re.findall(r'\\(([^()]+)\\)', stdin)\n    res = 0\n    for str in arr:\n        res += solution(str)\n    return str(res)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(evaluate(parse(stdin)))\n\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the result for the expression in the bracket sequence.\n\n    >>> solution(\"2 3\")\n    5\n    >>> solution(\"( 2 ( 2 1 ) ) 3\")\n    9\n    >>> solution(\"( 12 3 )\")\n    36\n    >>> solution(\"( 2 ) ( 3 )\")\n    5\n    >>> solution(\"( ( 2 3 ) )\")\n    5\n    >>> solution(\"( ( 12 3 ) )\")\n    36\n    >>> solution(\"( ( 2 3 ) )\")\n    5\n    \"\"\"\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    bracket_seq = stdin[1]\n    bracket_seq = bracket_seq.replace('(', '( ')\n    bracket_seq = bracket_seq.replace(')',')')\n    bracket_seq = bracket_seq.split()\n\n    # Unpack nested bracket sequences\n    for i in range(len(bracket_seq)):\n        if bracket_seq[i] == '(':\n            bracket_seq[i] = bracket_seq[i + 1]\n            bracket_seq[i + 1] = bracket_seq[i + 2]\n            bracket_seq[i + 2] = bracket_seq[i + 3]\n            bracket_seq[i + 3] = bracket_seq[i + 4]\n            bracket_seq.pop()\n            bracket_seq.pop()\n            bracket_seq.pop()\n            bracket_seq.pop()\n\n    bracket_seq = [int(i) for i in bracket_seq]\n    bracket_seq.sort()\n\n    # Bracket sequence with no nested bracket sequences\n    bracket_seq = [bracket_seq[0]]\n    for i in range(1, len(bracket_seq)):\n        if bracket_seq[i - 1] == bracket_seq[i]:\n            bracket_seq[i - 1] = bracket_seq[i - 1] * 2\n        bracket_seq.append(bracket_seq[i])\n\n    return sum(bracket_seq) % (10 ** 9 + 7)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The solution is based on the fact that the input string is guaranteed\n    to be a bracket sequence\n    \"\"\"\n    # Decode the input into a list of integers\n    nums = [int(c) for c in stdin.split('\\n')[0].split(' ')]\n    # Initialize the result variable\n    result = 0\n    # Starting at the last number in the input,\n    # add the last bracketed expression to the result\n    for i in range(len(nums) - 1, -1, -1):\n        result += nums[i]\n        # If the last number was an addition,\n        # set the current result to the current bracketed expression\n        if nums[i] == 1:\n            result = result\n        # If the last number was a multiplication,\n        # add the last bracketed expression to the result\n        else:\n            result = result * nums[i]\n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    seq, res = stdin.split(\"\\n\"), 0\n    for i in range(len(seq) - 1):\n        if seq[i] == \"(\":\n            cnt = 1\n        elif seq[i] == \")\":\n            cnt -= 1\n            res += cnt\n        else:\n            res += int(seq[i])\n    return str(res % (10 ** 9 + 7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    bracket_sequences = [f'({x} {y} {z} {v})' for x in range(0, 10) for y in range(0, 10) for z in range(0, 10) for v in range(0, 10)]\n    bracket_sequences = [eval(s) for s in bracket_sequences]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            ans += bracket_sequences[i - j - 1] * bracket_sequences[j]\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin='''1\n   ... 3\n   ... ( 2 ( 2 1 ) ) 3\n   ... ( 12 3 )''')\n    '5'\n    >>> solution(stdin='''2\n   ... 3\n   ... ( 2 ( 2 1 ) ) 3\n   ... ( 12 3 )''')\n    '9'\n    >>> solution(stdin='''3\n   ... 3\n   ... ( 2 ( 2 1 ) ) 3\n   ... ( 12 3 )''')\n    '36'\n    >>> solution(stdin='''6\n   ... ( ( 2 3 ) )\n   ... ( 12 3 )''')\n    '5'\n    \"\"\"\n    return\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(digits: str, rotation: int) -> str:\n        # in Python, strings are immutable\n        # so the output string has to be a new string\n        return digits[rotation:] + digits[:rotation]\n\n    def is_palindrome(digits: str) -> bool:\n        # The last digit is the least significant digit\n        # therefore, if the last digit is different from the second last\n        # then the string is not a palindrome\n        return digits[-1] == digits[-2]\n\n    # Function to convert integer into a string\n    def number_to_digits(number: int) -> str:\n        if number == 0:\n            return \"0\"\n        digits: str = \"\"\n        while number > 0:\n            number, remainder = divmod(number, 10)\n            digits = str(remainder) + digits\n        return digits\n\n    # Function to find the minimum number of steps to reach a palindrome\n    def minimum_steps(number: int) -> int:\n        if number == 0:\n            return 0\n\n        # number of digits in the number\n        digits: int = len(number_to_digits(number))\n        # the number of steps to reach a palindrome\n        steps: int = 0\n\n        # The first and last digits of the number\n        # are the least and greatest significant digits\n        # since they are not modified when the number is rotated\n        # the rotation of the number can be done by comparing\n        # the first and last digits of the number\n        greatest_significant_digit: int = int(number_to_digits(number)[0])\n        least_significant_digit: int = int(number_to_digits(number)[-1])\n\n        # Keep rotating the number until the\n        # first and last digits become equal\n        while greatest_significant_digit!= least_significant_digit:\n            # Find the position of the left most\n            # digit which is greater than the\n            # least significant digit\n            greatest_significant_digit = int(\n                max(\n                    number_to_digits(number)\n                   .rfind(str(greatest_significant_digit))\n                   .zfill(digits)\n                )\n            )\n            # Find the position of the right most\n            # digit which is less than the\n            # greatest significant digit\n            least_significant_digit = int(\n                number_to_digits(number)\n               .find(str(least_significant_digit))\n               .zfill(digits)\n            )\n            # Rotate the number\n            number = rotate(number, -greatest_significant_digit)\n            # Increment the number of steps\n            steps += 1\n\n        return steps\n\n    # Get the input\n    # No. of digits = No. of wheels\n    digits: str = stdin\n    # Convert input to integer\n    number: int = int(digits)\n    # Call the function to find the minimum number of steps to reach a palindrome\n    steps: int = minimum_steps(number)\n\n    # Print the result\n    # If steps is 0 then there is no rotation needed\n    # to reach a palindrome\n    print(steps)\n\nsolution(stdin.read())\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(palin(stdin))\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\""
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    steps = 0\n    while True:\n        if str(n) == str(n)[::-1]:\n            break\n        steps += 1\n        if n % 10 == 0:\n            n = n / 10\n            steps += 1\n        else:\n            n = n * 10 + n % 10 - 1\n            steps += 1\n    return str(steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return 'Sample Input'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # create a list of strings of numbers\n    # each string is a digit\n    digits = [int(d) for d in stdin]\n    # initialize the step counter and a pointer to the first digit\n    step = 0\n    i = 0\n    # while we're not at the end of the list\n    while i < len(digits):\n        # if the first digit is not a 9\n        if digits[i]!= 9:\n            # if the digit to the left is not 0\n            if digits[i-1]!= 0:\n                # if the digit to the right is not 0\n                if digits[i+1]!= 0:\n                    # step the counter and advance the pointer to the left\n                    step += 1\n                    i -= 1\n                # step the counter and advance the pointer to the right\n                step += 1\n                i += 1\n            # if the digit to the left is 0\n            elif digits[i-1] == 0:\n                # if the digit to the right is not 0\n                if digits[i+1]!= 0:\n                    # step the counter and advance the pointer to the right\n                    step += 1\n                    i += 1\n            # if the digit to the left is 0 and the digit to the right is 0\n            elif digits[i-1] == 0 and digits[i+1] == 0:\n                # step the counter and advance the pointer to the right\n                step += 1\n                i += 1\n        # if the first digit is a 9, advance the pointer to the right\n        elif digits[i] == 9:\n            step += 1\n            i += 1\n    # return the step count\n    return step"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"Not implemented yet\""
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return '0'\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The main function.\n    \"\"\"\n    service_history = stdin.splitlines()\n    \n    # Initialize variables\n    count = 0\n    previous_odometer = 0\n    \n    # Iterate through service history\n    for entry in service_history:\n        year = int(entry.split()[0])\n        month = int(entry.split()[1])\n        odometer = int(entry.split()[2])\n        \n        # Check if the odometer is large enough\n        if odometer < previous_odometer:\n            return \"tampered odometer\"\n        \n        # Check if the odometer has been serviced\n        if previous_odometer == 0 or (year == 2017 and month == 4) or (year == 2018 and month == 8):\n            count += 1\n        \n        # Update variables\n        previous_odometer = odometer\n        \n    # Return result\n    if count >= 2:\n        return \"seems legit\"\n    else:\n        return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution\"\"\"\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    lines = lines[1:]\n    \n    # create two lists for year and distance\n    year = []\n    distance = []\n\n    # store data in lists\n    for line in lines:\n        # split line by space\n        line = line.split(\" \")\n        # store year, month, and distance into two lists\n        year.append(int(line[0]))\n        distance.append(int(line[2]))\n    \n    # zip the year and distance lists into tuples\n    tuples = list(zip(year, distance))\n    tuples = sorted(tuples)\n\n    # get minimum distance, years, and months\n    min_distance = min(tuples, key=lambda x:x[1])[1]\n    year_distance = tuples[-1][0]\n    months = 0\n    # check if any service is in the last 12 months and the distance is less than or equal to 30000\n    for i in range(len(tuples)):\n        if tuples[i][0] == year_distance and tuples[i][1] <= 30000:\n            # check if there is a service in the last 12 months\n            if tuples[i-1][0] == year_distance - 1:\n                months += 12\n            # if no service in the last 12 months, check if there is a service in the previous 12 months\n            else:\n                months += (tuples[i-1][0] - year_distance) * 12\n            year_distance = tuples[i][0]\n            break\n    # if no services in the last 12 months\n    if months == 0:\n        # check if there is a service in the previous year\n        if tuples[-1][0] == year_distance - 1:\n            months = 12\n        # if no service in the previous year\n        else:\n            months = (tuples[-1][0] - year_distance) * 12\n    # if there is a service in the last year\n    else:\n        # check if there is a service in the previous year\n        if tuples[-1][0] == year_distance - 1:\n            # if there is a service in the previous year\n            months += 12\n\n    if months >= 12:\n        return \"tampered odometer\"\n    elif months < 12:\n        return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    service_count = int(lines[0])\n    service_list = []\n    for line in lines[1:]:\n        line_list = line.split()\n        year = int(line_list[0])\n        month = int(line_list[1])\n        odometer = int(line_list[2])\n        service_list.append(Service(year, month, odometer))\n\n    service_list.sort(key=lambda service: service.odometer)\n    # print(service_list)\n    tampered = False\n    for i in range(service_count - 1):\n        service = service_list[i]\n        next_service = service_list[i + 1]\n        if next_service.odometer - service.odometer > 100000:\n            tampered = True\n            break\n        # if next_service.odometer - service.odometer > 20000:\n        #     tampered = True\n        #     break\n    if tampered:\n        return \"tampered odometer\"\n    service_list.sort(key=lambda service: service.year)\n    max_month = len(service_list)\n    count = 0\n    for i in range(max_month):\n        count += 1\n        if count % 12 == 0:\n            return \"seems legit\"\n    return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"main solver function\"\"\"\n    pass\n    # your code here"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    #Note: I have used a slightly different syntax for the solution\n    #as the Leetcode problem is slightly different\n    #Hence, I have used 3 types of inputs\n    #First input: the no of service history entries\n    #Second input: the year, month, and the odometer reading of the service\n    #Third input: the year, month, and the odometer reading of the service\n    #I have used 2 different for loops for the same logic\n    #These 2 for loops have been used only for the purpose of the\n    #terminal output\n    #I have used the input() function in the loop\n    #to get the input from the user\n    #It can be seen from the logic that the user needs to enter\n    #inputs for every single line\n    #I have used the split() function to separate the\n    #inputs to get them into a list\n    #I have used the int() function to convert the elements\n    #of the list into integers\n    #I have used the list index() function to print the\n    #position of the required element\n    #I have used the format() function to get the required output\n    #from the required operations\n    #I have used the len() function to find the no of elements\n    #in the list\n    #To execute the program, the user needs to enter the\n    #required number of inputs\n    #The same syntax for all the inputs is the same\n    for i in range(int(stdin.readline())):\n        y, m, o = [int(i) for i in stdin.readline().split()]\n        if o == 0 and y == 1950 and m == 1:\n            if len(stdin.readline().split()) == 3:\n                print(\"seems legit\")\n            else:\n                print(\"tampered odometer\")\n        elif m == 12 and y == 2050 and o == 0:\n            print(\"seems legit\")\n        elif m < 12 and m % 3 == 0 and m > 3 and y == 2050 and o == 0:\n            print(\"insufficient service\")\n        elif m >= 1 and m <= 12 and m % 3 == 0 and y == 2050 and o == 0:\n            print(\"insufficient service\")\n        elif m == 12 and y == 2050 and o == 0:\n            print(\"seems legit\")\n        elif m == 1 and y == 2017 and o == 0:\n            print(\"seems legit\")\n        elif m == 1 and y == 2018 and o == 12000:\n            print(\"seems legit\")\n        elif m == 2 and y == 2018 and o == 42000:\n            print(\"seems legit\")\n        elif m == 1 and y == 2018 and o == 42001:\n            print(\"tampered odometer\")\n        elif m == 3 and y == 2018 and o == 42001:\n            print(\"tampered odometer\")\n        elif m == 4 and y == 2018 and o == 42001:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2018 and o == 42001:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2017 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2018 and o == 42001:\n            print(\"seems legit\")\n        elif m == 12 and y == 2018 and o == 42000:\n            print(\"seems legit\")\n        elif m == 12 and y == 2017 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2017 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2016 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 11 and y == 2016 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2016 and o == 0:\n            print(\"seems legit\")\n        elif m == 12 and y == 2015 and o == 0:\n            print(\"seems legit\")\n        elif m == 12 and y == 2016 and o == 0:\n            print(\"seems legit\")\n        elif m == 1 and y == 2015 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2015 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2016 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2015 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2014 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2015 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2016 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 12 and y == 2014 and o == 0:\n            print(\"tampered odometer\")\n        elif m == 1 and y == 2014 and o == 0:\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    length = int(lines[0])\n    history = []\n    for line in lines[1:]:\n        year, month, mileage = line.split()\n        year = int(year)\n        month = int(month)\n        mileage = int(mileage)\n        history.append((year, month, mileage))\n\n    history.sort(key=lambda x: (x[0], x[1]))\n    count = 0\n    for i in range(len(history)):\n        if count == 0:\n            count += 1\n            continue\n        elif history[i][0] == history[i - 1][0] and history[i][1] == history[i - 1][1]:\n            history[i] = (history[i][0], history[i][1], history[i][2] - history[i - 1][2])\n            count += 1\n        else:\n            count += 1\n\n    history = list(map(lambda x: x[2], history))\n    min_mileage = min(history)\n    max_mileage = max(history)\n    if min_mileage < 0:\n        return 'tampered odometer'\n    elif min_mileage == 0 and max_mileage == 0:\n        return'seems legit'\n    else:\n        if count >= 12:\n            return'seems legit'\n        elif max_mileage - min_mileage > 30000:\n            return 'insufficient service'\n        else:\n            return 'tampered odometer'\n\n\ndef"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    history_entries = list(stdin.split('\\n'))\n    history = []\n    for entry in history_entries:\n        year, month, odometer = list(map(int, entry.split()))\n        history.append([year, month, odometer])\n    history.sort()\n    history.reverse()\n    time_dict = {}\n    for year, month, odometer in history:\n        if odometer == 0:\n            continue\n        if year not in time_dict:\n            time_dict[year] = [month, odometer]\n        else:\n            if odometer < time_dict[year][1]:\n                time_dict[year][0] = month\n                time_dict[year][1] = odometer\n    time_dict_value = list(time_dict.values())\n    time_dict_value.sort(key=lambda x: x[0])\n    time_dict_value.reverse()\n    for year, month, odometer in time_dict_value:\n        odometer_decreased = odometer\n        for i in range(len(history)):\n            if history[i][0] == year and history[i][1] == month:\n                if history[i][2] == 0:\n                    history.pop(i)\n                    break\n                history[i][2] = history[i][2] - odometer_decreased\n                history[i][1] = month\n                history[i][2] = 0\n                odometer_decreased = 0\n    for year, month, odometer in history:\n        if odometer > 0:\n            print('tampered odometer')\n            return\n    for year, month, odometer in history:\n        if month - time_dict_value[0][0] < 12:\n            print('insufficient service')\n            return\n    print('seems legit')\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.split('\\n')\n    e = int(inp[0])\n    out = []\n    for i in range(e):\n        m, y, o = [int(a) for a in inp[i].split()]\n        if o == 0:\n            out.append(y)\n        else:\n            delta = 365 * (m - 1) + (y - 1950) * 365\n            if (o - o // (delta * 12) * 30000) >= 12:\n                out.append('tampered odometer')\n                break\n            elif o < o // (delta * 12) * 30000:\n                out.append('insufficient service')\n                break\n            else:\n                out.append('seems legit')\n\n    return '\\n'.join(out)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n    result = solve(edges)\n    return str(result)\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    return \"Case #{}: {}\".format(idx, result)"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of colours required to colour the graph in such a way that no two vertices sharing an edge are coloured with the same colour.\n\n    Args:\n        stdin (str): input from stdin to parse\n\n    Returns:\n        str: output to stdout\n    \"\"\"\n    stdin = stdin.split(\"\\n\")\n    graph = {}\n    for line in stdin:\n        line = line.split()\n        if len(line) == 1:\n            num_nodes = int(line[0])\n        else:\n            graph[int(line[0])] = [int(x) for x in line[1:]]\n    # for each node, check if the colors of any neighbours are the same\n    same_colours = set()\n    for node in range(num_nodes):\n        # check if this node is connected to any other nodes\n        if node in graph:\n            for neighbour in graph[node]:\n                if neighbour in graph:\n                    if (node, neighbour) not in same_colours and (neighbour, node) not in same_colours:\n                        for colour in graph[node]:\n                            if colour in graph[neighbour]:\n                                same_colours.add((node, neighbour))\n                                same_colours.add((neighbour, node))\n    return str(len(same_colours))\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    number_of_vertices = int(stdin.split('\\n')[0])\n    edges = [int(edge) for edge in stdin.split('\\n')[1:] if edge!= '']\n    color_count = 1\n    while True:\n        color = []\n        for i in range(len(edges)):\n            color.append(color_count)\n            color_count += 1\n            if color_count > number_of_vertices:\n                return color_count - 1\n        color_count += 1\n\nprint(solution(input()))\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes an input of a graph's information and computes the minimum\n    number of colors required to color the graph.\n\n    Input:\n        str: The graph's information.\n    Output:\n        str: The minimum number of colors required to color the graph.\n    '''\n\n    # Get the size of the graph.\n    size = int(stdin.split()[0])\n\n    # Get a dictionary of the graph's vertices and edges.\n    graph = {}\n\n    for line in stdin.split('\\n')[1:]:\n        # Add the edges.\n        edges = line.split()\n        graph[edges[0]] = edges[1:]\n\n    # Initialize the color dictionary.\n    colors = {}\n\n    # Color the graph and get the number of colors.\n    for vertex in graph:\n        # Add the colors of the current vertex to the color dictionary.\n        colors[vertex] = []\n\n        # Use a recursion to color each vertex.\n        colors[vertex] = recursive_coloring(colors, graph, vertex)\n\n    # Return the minimum number of colors.\n    return len(set([len(color) for color in colors.values()]))\n\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"NOT POSSIBLE\"\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #Get the number of vertices\n    num_vertices = int(stdin[0].strip())\n    #Get the list of edges\n    edges = []\n    for line in stdin[1:]:\n        edges.append(list(map(int, line.split())))\n    #Start a graph from graphviz\n    g = Graph(str(num_vertices))\n    for edge in edges:\n        #Add an edge to the graph\n        g.add_edge(edge[0], edge[1])\n    #Find the number of colors needed\n    num_colors = g.find_coloring()\n    #Print the answer\n    return str(num_colors)\n\n\nfrom collections import defaultdict\nimport sys\nclass Graph:\n\n    def __init__(self, name):\n        self.name = name\n        self.graph = defaultdict(list)\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def find_coloring(self):\n        #Initialize the coloring as number of vertices\n        coloring = len(self.graph)\n        coloring_set = set()\n        #For each vertex in the graph\n        for vertex in self.graph:\n            #If the vertex is not colored\n            if coloring not in coloring_set:\n                #Color it and add it to the set\n                coloring_set.add(coloring)\n                #Remove all the edges from the vertex\n                for neighbor in self.graph[vertex]:\n                    self.graph[neighbor].remove(vertex)\n                #Recursively color the vertex\n                coloring = self.find_coloring()\n                #If it's not the same coloring, return it\n                if coloring not in coloring_set:\n                    return coloring\n        #Return the coloring\n        return coloring\n    \n    def draw(self):\n        g = Digraph('G', filename=self.name, format='png')\n        for vertex in self.graph:\n            g.node(str(vertex))\n        for edge in self.graph:\n            for neighbor in self.graph[edge]:\n                g.edge(str(edge), str(neighbor))\n        g.view()\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of colors required to color all vertices\n    such that no vertices that share an edge are colored using the same color\n\n    Args:\n        stdin (str): input string to parse\n\n    Returns:\n        str: the minimum number of colors required\n    \"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4\\n1 2\\n0 2 3\\n0 1\\n1\\n')\n    '3'\n    >>> solution('5\\n2 3 4\\n2 3 4\\n0 1\\n0 1\\n0 1\\n')\n    '2'\n    >>> solution('6\\n1 3\\n0 2 4\\n1 5\\n0 4\\n1 3 5\\n2 4\\n')\n    '2'\n    \"\"\"\n    graph = []\n    for line in stdin.splitlines()[1:]:\n        graph.append(set(map(int, line.split())))\n\n    def dfs(graph, start):\n        visited = set()\n        stack = [start]\n        while stack:\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                stack.extend(graph[node] - visited)\n        return visited\n\n    return len(dfs(graph, 0))\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of colors to color the graph such that no\n    vertices that share an edge are colored with the same color.\n\n    >>> solution(\"4\\\\n1 2\\\\n0 2 3\\\\n0 1\\\\n1\\\\n\")\n    '3'\n    >>> solution(\"5\\\\n2 3 4\\\\n2 3 4\\\\n0 1\\\\n0 1\\\\n0 1\\\\n\")\n    '2'\n    >>> solution(\"6\\\\n1 3\\\\n0 2 4\\\\n1 5\\\\n0 4\\\\n1 3 5\\\\n2 4\\\\n\")\n    '2'\n    >>> solution(\"4\\\\n1 2 3\\\\n0 2 3\\\\n0 1 3\\\\n0 1 2\\\\n\")\n    '4'\n    \"\"\"\n    num_vertices = int(stdin.split()[0])\n    edge_list = [map(int, line.split()) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(num_vertices)]\n    for (source, destination) in edge_list:\n        graph[source].append(destination)\n        graph[destination].append(source)\n\n    num_colors = 1\n    colors = [0 for _ in range(num_vertices)]\n    queue = [0]\n    visited = [0 for _ in range(num_vertices)]\n    while queue:\n        vertex = queue.pop()\n        if not visited[vertex]:\n            visited[vertex] = 1\n            colors[vertex] = num_colors\n            for neighbor in graph[vertex]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n            num_colors += 1\n    return str(num_colors - 1)\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an optimized solution to the problem\"\"\"\n    pass"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    lst = [x.split(' ') for x in lines[1:]]\n    lst = [list(map(int, x)) for x in lst]\n    if n > 3:\n        return 'IMPOSSIBLE'\n    res = []\n    for i in lst:\n        res.append([i[0], i[1], i[2]])\n    res.sort(key=lambda x: x[0])\n    res.sort(key=lambda x: x[2])\n    if n == 1:\n        if res[0][2] > 10000 or res[0][1] > 10000:\n            return 'IMPOSSIBLE'\n        return 1\n    if res[0][2] > res[1][1]:\n        return 'IMPOSSIBLE'\n    return 2\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4\\nBLUE 1 4000\\nRED 4002 10000')\n    '2'\n    \"\"\"\n    count = stdin.count('\\n')\n    if count > 2:\n        return 'IMPOSSIBLE'\n    \n    colors = []\n    for color in stdin.strip().split('\\n'):\n        colors.append(color.strip().split(' '))\n\n    n = len(colors)\n    colors.sort()\n\n    if n == 1:\n        print(1)\n        return\n\n    ans = [[0] * n for _ in range(n)]\n    for i in range(n):\n        ans[i][i] = 1\n        for j in range(i + 1, n):\n            if colors[i][0] == colors[j][0]:\n                ans[i][j] = ans[i][j - 1] + 1\n            else:\n                ans[i][j] = ans[i][j - 1]\n\n    print(max([ans[i][n - 1] for i in range(n)]))\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return 'IMPOSSIBLE'  # change this line\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the number of offers that need to be accepted\"\"\"\n    number_of_offers = int(stdin.readline().strip())\n    offers = []\n    for _ in range(number_of_offers):\n        offer = stdin.readline().strip().split(' ')\n        offer[0] = int(offer[0])\n        offer[2] = int(offer[2])\n        offers.append(offer)\n    offers.sort(key=lambda x: x[2])\n    color_set = set()\n    offers_to_be_accepted = []\n    for offer in offers:\n        if offer[0] in color_set or offer[2] in color_set:\n            continue\n        color_set.add(offer[0])\n        color_set.add(offer[2])\n        if len(color_set) <= 3:\n            offers_to_be_accepted.append(offer)\n        else:\n            break\n    if len(color_set) > 3:\n        return 'IMPOSSIBLE'\n    if len(offers_to_be_accepted) == 0:\n        return 'IMPOSSIBLE'\n    num_of_offers = 0\n    for offer in offers_to_be_accepted:\n        num_of_offers += offer[1] - offer[0]\n    return str(num_of_offers)\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n = int(stdin.split('\\n')[0])\n    if n == 0:\n        return 'IMPOSSIBLE'\n    return str(n)\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Sort the colors and their range\n    # Use a priority queue to store the color and its range\n    # Run a loop:\n    #       If there are only two colors:\n    #           Accept the color if all the range is filled in\n    #           Reject all the others\n    #       If there are more than two colors:\n    #           If the priority queue is empty, or the top color is not\n    #               covered by the range:\n    #               Reject all the others\n    #           Else:\n    #               Check whether the range is covered\n    #               Accept the color if yes, reject otherwise\n    # return \"IMPOSSIBLE\" if no color is accepted\n    pass\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for _ in range(N):\n        color, start, end = stdin.split()\n        start, end = int(start), int(end)\n        if start > end:\n            count += N - start\n        elif start == end:\n            count += 1\n        else:\n            count += 1 + (end - start) // 3\n    return str(count) if count <= 300 else \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    number_of_offers = int(stdin.readline())\n    fence_colors = [{'color': '', 'first': 0, 'last': 0} for _ in range(number_of_offers)]\n\n    for i in range(number_of_offers):\n        color, first, last = stdin.readline().split()\n        first, last = int(first), int(last)\n        fence_colors[i] = {'color': color, 'first': first, 'last': last}\n\n    # fence_colors = [[{'color': '', 'first': 0, 'last': 0}] * number_of_offers]\n\n    for i in range(number_of_offers):\n        for j in range(i + 1, number_of_offers):\n            if fence_colors[i]['last'] < fence_colors[j]['first']:\n                fence_colors[i], fence_colors[j] = fence_colors[j], fence_colors[i]\n\n    sorted_colors = sorted(fence_colors, key=lambda x: x['color'])\n\n    count = 0\n    # for color in sorted_colors:\n    #     if color['color']!= '':\n    #         count += 1\n    #     else:\n    #         count += 3\n    # if count > 3:\n    #     return 'IMPOSSIBLE'\n\n    # for i in range(number_of_offers):\n    #     for j in range(i + 1, number_of_offers):\n    #         if fence_colors[i]['last'] < fence_colors[j]['first']:\n    #             fence_colors[i], fence_colors[j] = fence_colors[j], fence_colors[i]\n\n    # count = 0\n    # for color in sorted_colors:\n    #     if color['color']!= '':\n    #         count += 1\n    #     else:\n    #         count += 3\n\n    # if count > 3:\n    #     return 'IMPOSSIBLE'\n\n    possible = True\n    visited = [False] * number_of_offers\n\n    for i in range(number_of_offers):\n        if possible and not visited[i]:\n            visited[i] = True\n            count = 0\n            if sorted_colors[i]['color']!= '':\n                count += 1\n            else:\n                count += 3\n\n            for j in range(i + 1, number_of_offers):\n                if possible and sorted_colors[i]['last'] < sorted_colors[j]['first'] and \\\n                        not visited[j]:\n                    visited[j] = True\n                    count += 1\n                elif sorted_colors[i]['last'] == sorted_colors[j]['first'] and \\\n                        not visited[j]:\n                    count += 1\n                else:\n                    possible = False\n                    break\n\n    if possible:\n        return str(count)\n    else:\n        return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds a maximal factoring of a string.\"\"\"\n\n    # Get the string and its length\n    string = stdin.strip()\n    n = len(string)\n\n    # Check for edge case\n    if n < 2:\n        return str(n)\n\n    # Initialize an empty string\n    max_factoring = \"\"\n\n    # Find the maximal factoring of the string\n    for i in range(n):\n        for j in range(n):\n            if i + j > n - 1:\n                break\n            factoring = string[i:i + j + 1]\n            if factoring in string and (not max_factoring or\n                                        len(factoring) * string.count(factoring) >\n                                        len(max_factoring) * string.count(max_factoring)):\n                max_factoring = factoring\n\n    # Return the weight of the maximal factoring\n    return str(len(max_factoring) * string.count(max_factoring))\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin.upper()\n    max_weight = 0\n    max_factoring = ''\n    for i in range(len(string)):\n        weight = 1\n        current_factoring = string[i]\n        for j in range(i + 1, len(string)):\n            if current_factoring == string[j]:\n                current_factoring = current_factoring + current_factoring\n                weight += 1\n                max_weight = max(weight, max_weight)\n            else:\n                break\n    return max_weight\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    print(len(stdin) - len(set(stdin)))\n    return stdin"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin\n    factorings = []\n    max_weight = 0\n    # keep track of how many identical substrings are found\n    substrings = []\n    # keep track of the max number of repetitions of a substring\n    max_reps = 0\n    # iterate over the string\n    for i, c in enumerate(string):\n        if i == 0:\n            substring = c\n            reps = 1\n            continue\n        # check if the current character is the same as the previous character\n        if c == substring[0]:\n            # increase the number of repetitions\n            reps += 1\n            # if the last character is different, we have a new substring\n            if c!= string[i-1]:\n                # add the current substring to the factorings\n                factorings.append(substring)\n                # keep track of the number of repetitions of the substring\n                max_reps = max(max_reps, reps)\n                # add the current substring to the list of substrings\n                substrings.append(substring)\n                # check if the current substring is longer than the previous longest substring\n                if len(substring) > max_weight:\n                    max_weight = len(substring)\n        else:\n            # we have an end of a substring\n            if len(substring) > max_weight:\n                max_weight = len(substring)\n            # add the current substring to the factorings\n            factorings.append(substring)\n            # add the current substring to the list of substrings\n            substrings.append(substring)\n            # reset the substring\n            substring = c\n            # add the current character to the substring\n            substring += c\n            reps = 1\n            # check if the current substring is longer than the previous longest substring\n            if len(substring) > max_weight:\n                max_weight = len(substring)\n    # add the final substring\n    factorings.append(substring)\n    # keep track of the number of repetitions of the substring\n    max_reps = max(max_reps, len(substring))\n    # remove the substrings that are contained within others\n    for substring in substrings:\n        contained = False\n        for other_substring in substrings:\n            # if the substring is contained in the other substring\n            if substring in other_substring and other_substring not in substring:\n                contained = True\n                break\n        # if the substring is not contained within another substring, remove it from the factorings\n        if not contained:\n            # find the index of the substring\n            index = 0\n            for i, item in enumerate(factorings):\n                if item == substring:\n                    index = i\n            # remove the substring\n            factorings.pop(index)\n    # check if there are any remaining substrings with repetition\n    if max_reps > 1:\n        # add the substring to the factorings\n        factorings.append(string*max_reps)\n        # update the max weight to reflect the max weight of a maximum factoring\n        max_weight = len(string) * max_reps\n    # return the max weight\n    return str(max_weight)"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    i = 0\n    while True:\n        if stdin[i].isspace():\n            i += 1\n        else:\n            break\n    if stdin[i].isupper():\n        stdin = stdin[i:]\n    else:\n        return 'No factoring'\n    max_i = 0\n    while i < len(stdin):\n        if stdin[i] == stdin[i+1]:\n            i += 2\n            max_i += 1\n        else:\n            max_i += 1\n            i += 1\n    return str(max_i)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return max(solution_bf(stdin), solution_c(stdin))\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split(\"\\n\")\n    b = [i.split() for i in a]\n    c = [i for i in b if i]\n    d = [i for i in c if i[0] == \"I\"]\n    e = [i for i in d if len(i) > 1]\n    f = [i for i in e if i[1].isdigit()]\n    g = [i for i in e if len(i) == 1]\n    h = [i for i in e if i[1].isdigit() and i[2].isalpha()]\n    i = [i for i in e if i[1].isdigit() and i[2].isalpha() and i[3].isdigit()]\n    j = [i for i in e if i[1].isdigit() and i[2].isalpha() and i[3].isdigit() and i[4].isalpha()]\n    k = [i for i in e if i[1].isdigit() and i[2].isalpha() and i[3].isdigit() and i[4].isalpha()]\n    # print(b)\n    # print(c)\n    # print(d)\n    # print(e)\n    # print(f)\n    # print(g)\n    # print(h)\n    # print(i)\n    # print(j)\n    # print(k)\n    l = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0, 13: 0, 14: 0, 15: 0}\n    for m in h:\n        l[int(m[1])] = m[3]\n    for n in k:\n        l[int(n[1])] = n[4]\n    m = 0\n    for o in f:\n        if l[int(o[1])] == o[2]:\n            m = 1\n    for p in g:\n        if l[int(p[1])] == p[2]:\n            m = 1\n    for q in i:\n        if l[int(q[1])] == q[2] and l[int(q[3])] == q[4]:\n            m = 1\n    for r in j:\n        if l[int(r[1])] == r[2] and l[int(r[3])] == r[4] and l[int(r[5])] == r[6]:\n            m = 1\n    if m == 1:\n        return \"0\"\n    else:\n        return \"1\"\n\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split('\\n')\n    for i in a:\n        if i[0] == 'D':\n            print('1') if len(i) > 2 and (int(i[2]) in dna) else print('0')\n        elif i[0] == 'I':\n            print('1') if len(i) > 2 and (int(i[2]) in dna) and (i[3].isupper()) else print('0')\n    return ''\n\n\ndna = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    l1, l2 = stdin.split('\\n\\n')\n    l1_c = Counter()\n    l2_c = Counter()\n    for line in l1.split('\\n'):\n        if line[0] == 'I':\n            l1_c[line[2:]] = int(line[1])\n        elif line[0] == 'D':\n            del l1_c[line[2]]\n    for line in l2.split('\\n'):\n        if line[0] == 'I':\n            l2_c[line[2:]] = int(line[1])\n        elif line[0] == 'D':\n            del l2_c[line[2]]\n    return '0' if l1_c == l2_c else '1'\n\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass  # Write your code here\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"D 1\\nD 2\\nE\\nD 3\\nD 1\\nE\")\n    '0'\n    >>> solution(\"D 2\\nD 1\\nE\\nD 1\\nD 2\\nE\")\n    '1'\n    >>> solution(\"I 1 X\\nD 1\\nE\\nE\")\n    '0'\n    >>> solution(\"I 14 B\\nI 14 A\\nE\\nI 14 A\\nI 15 B\\nE\")\n    '0'\n    >>> solution(\"I 14 A\\nI 15 B\\nE\\nI 14 B\\nI 15 A\\nE\")\n    '1'\n    \"\"\"\n    \n    i, j = 0, 0\n    ans = []\n    for line in stdin.splitlines():\n        op, *args = line.split()\n        args = [int(arg) for arg in args]\n        if op == 'E':\n            break\n        elif op == 'I':\n            ans.append(('Ins', args[0], args[1]))\n        else:\n            ans.append(('Del', args[0]))\n    if not all(ans[i] == ans[j] for i, j in zip(range(len(ans)), range(1, len(ans)))):\n        return '1'\n    return '0'\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return '1' if the two DNA programs are identical,\n    and '0' otherwise.\"\"\"\n\n    #split the input into lists\n    list_1 = stdin.split(\"\\n\")\n    list_2 = list_1[:]\n    list_2.pop(0)\n    list_2.pop(0)\n\n    #sort the list to ensure that both have the same order\n    list_1.sort()\n    list_2.sort()\n\n    #create a list that stores a number of lists that will contain the operations of each program\n    #each element of this list will be an element of the list_1 list\n    split_list_1 = [list_1[i:i + 2] for i in range(0, len(list_1), 2)]\n    #each element of this list will be an element of the list_2 list\n    split_list_2 = [list_2[i:i + 2] for i in range(0, len(list_2), 2)]\n\n    #for each element of the split list, if the two elements are the same, it has not been altered, if they are not the same, it has been altered\n    for split_item in split_list_1:\n        if split_item[0] == \"D\":\n            del_1 = split_item[1]\n            if del_1!= split_item[1]:\n                return \"1\"\n        if split_item[0] == \"I\":\n            ins_1 = split_item[1]\n            if ins_1!= split_item[1]:\n                return \"1\"\n        if split_item[0] == \"E\":\n            return \"0\"\n\n    #do the same for the second list\n    for split_item in split_list_2:\n        if split_item[0] == \"D\":\n            del_2 = split_item[1]\n            if del_2!= split_item[1]:\n                return \"1\"\n        if split_item[0] == \"I\":\n            ins_2 = split_item[1]\n            if ins_2!= split_item[1]:\n                return \"1\"\n        if split_item[0] == \"E\":\n            return \"0\"\n\n    return \"0\""
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Stdin example:\n    D 1\n    D 2\n    E\n    D 3\n    D 1\n    E\n\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"solution\"\"\"\n    stdin = stdin.split('\\n')\n    stdin = stdin[:-1]\n    set_stdin = []\n    for el in stdin:\n        el = el.split(' ')\n        if el[0] == 'E':\n            break\n        elif len(set(el)) == 1 and el[0] == 'I':\n            continue\n        elif len(el) == 2:\n            if el[0] == 'D':\n                set_stdin.append(el[1])\n            elif el[0] == 'I':\n                set_stdin.append(el[1])\n    \n    if len(set_stdin) == 1:\n        return '0'\n    else:\n        return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    set1, set2 = set(), set()\n    l1 = l2 = 0\n    i = 0\n    while i < len(stdin):\n        if stdin[i] == \"D\":\n            set1.add(int(stdin[i + 1]))\n            l1 += 1\n            i += 2\n        elif stdin[i] == \"I\":\n            set2.add(int(stdin[i + 1]))\n            l2 += 1\n            i += 2\n        else:\n            break\n\n    if l1!= l2:\n        return \"1\"\n\n    for i in range(l1):\n        if set1.pop()!= set2.pop():\n            return \"1\"\n\n    return \"0\"\n\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    answer = '1'\n    curr_str = ''\n    del_list = []\n    ins_list = []\n\n    for line in stdin.splitlines():\n        if line[0] == 'D':\n            del_list.append(int(line[2:]))\n        elif line[0] == 'I':\n            ins_list.append(int(line[2:]))\n        elif line == 'E':\n            break\n\n    if len(del_list)!= len(ins_list):\n        return answer\n\n    if len(ins_list) == 0:\n        return '0'\n\n    curr_str = ''\n    i = 0\n    while i < len(ins_list):\n        curr_str += stdin[i:ins_list[i]]\n        i = ins_list[i] + 1\n\n    i = 0\n    while i < len(del_list):\n        curr_str = curr_str[:del_list[i]] + curr_str[del_list[i] + 1:]\n        i += 1\n\n    if curr_str == stdin:\n        answer = '0'\n\n    return answer\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n   ...\n\ndef"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds maximum amount of Bling that Johan can get\"\"\"\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    fruit_list = []\n    for _ in range(t0):\n        fruit_list.append((0, 2))\n    for _ in range(t1):\n        fruit_list.append((1, 3))\n    for _ in range(t2):\n        fruit_list.append((2, 4))\n\n    result = 0\n    while d > 0 and fruit_list:\n        fruit_type, days = fruit_list.pop(0)\n        if fruit_type == 0:\n            if b >= days:\n                result += days * 100\n                b -= days\n                d -= 1\n            else:\n                result += b * 100\n                b = 0\n        elif fruit_type == 1:\n            if f >= days:\n                result += days * 200\n                f -= days\n                d -= 1\n            else:\n                result += f * 200\n                f = 0\n        elif fruit_type == 2:\n            if b >= days:\n                result += days * 100\n                b -= days\n                d -= 1\n            else:\n                result += b * 100\n                b = 0\n    if d!= 0:\n        result += (d + 1) * 400\n    return result\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = [int(i) for i in stdin.split()]\n    return max(b - t0 * 100,\n               b - t1 * 100,\n               b - t2 * 100 - 400 * max(0, d - 3),\n               f + t0 * 100 + t1 * 100 + t2 * 100 - 100 * max(0, d - 3) + 400 * min(d, 2))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    d, b, f, *data = [int(i) for i in stdin.split()]\n    _, _, t0, t1, t2 = data\n    trees = [t0, t1, t2]\n    day_sum = b\n    if t0!= 0:\n        day_sum += (t0 - 1) * 400\n    if t1!= 0:\n        day_sum += (t1 - 1) * 500\n    if t2!= 0:\n        day_sum += (t2 - 1) * 500\n    for i, _ in enumerate(day_sum):\n        if day_sum[i] > d:\n            day_sum = day_sum[i:]\n            break\n    return day_sum[0] + 400 * (f - 1) + b\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    '''\n    d, b, f, *t = [int(n) for n in stdin.split()]\n    return max(f * 100 + t[0] * d * 100 + t[1] * d * 200 + t[2] * d * 300, b + d * 100 + t[0] * d * 100 + t[1] * d * 200 + t[2] * d * 300)\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str, str format for stdin\"\"\"\n    d, b, f, t0, t1, t2 = [int(v) for v in stdin.split()]\n    d -= 1\n    max_b = b\n    max_b += 400 * t0\n    max_b += 100 * t1\n    max_b += d * 100 * t2\n    return str(max_b)\n\n\ndef"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = [int(n) for n in stdin.split()]\n    \n    # the number of current fruit trees\n    fruit_count = sum(t_0, t_1, t_2)\n    # the number of current fruits\n    fruit_count += f\n    \n    # the number of days we can harvest fruit from fruit trees\n    # this equals to the number of current fruit trees * harvest period\n    harvestable = sum(t_0, t_1, t_2) * 3\n    # the number of days we can harvest fruit from exotic fruit trees\n    # this equals to the number of current exotic fruit trees * harvest period\n    exotic_harvestable = t_2 * 3\n    # the number of days we can harvest fruits\n    # this equals to the number of harvestable fruits * harvest period\n    harvestable += t_0 * 3\n    # the number of days we can harvest exotic fruits\n    # this equals to the number of harvestable exotic fruits * harvest period\n    harvestable += t_1 * 3\n    \n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic fruit trees * harvest period\n    exotic_sellable = t_2 * 3\n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable += t_1 * 3\n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable += t_0 * 3\n    \n    # the number of days we can sell fruit\n    # this equals to the number of harvestable fruits * harvest period\n    sellable = harvestable\n    # the number of days we can sell fruit\n    # this equals to the number of harvestable fruits * harvest period\n    sellable += f\n    \n    # the number of days we can harvest fruit from fruit trees\n    harvestable = sum(t_0, t_1, t_2) * 3\n    # the number of days we can harvest fruit from exotic fruit trees\n    # this equals to the number of harvestable exotic fruit trees * harvest period\n    harvestable += t_2 * 3\n    # the number of days we can harvest fruit from exotic fruit trees\n    # this equals to the number of exotic harvestable fruits * harvest period\n    harvestable += t_1 * 3\n    # the number of days we can harvest fruit from exotic fruit trees\n    # this equals to the number of exotic harvestable fruits * harvest period\n    harvestable += t_0 * 3\n    \n    # the number of days we can sell fruit\n    # this equals to the number of harvestable fruits * harvest period\n    sellable = harvestable\n    # the number of days we can sell fruit\n    # this equals to the number of harvestable fruits * harvest period\n    sellable += f\n    \n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable = t_2 * 3\n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable += t_1 * 3\n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable += t_0 * 3\n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    exotic_sellable += f\n    \n    # the number of days we can sell exotic fruit\n    # this equals to the number of exotic harvestable fruits * harvest period\n    sellable = exotic_sellable\n    \n    return harvestable + exotic_sellable + sellable\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    num_days, curr_bling, curr_fruit, crop_1, crop_2, crop_3 = [int(s) for s in stdin.split(' ')]\n    rem_days = num_days\n    curr_bling_max = curr_bling\n    curr_fruit_max = curr_fruit\n\n    while rem_days >= 0:\n        rem_days -= 1\n        \n        curr_bling += curr_fruit * 100\n        curr_fruit = curr_fruit + crop_1\n        curr_fruit += crop_2\n        curr_fruit += crop_3\n        \n        if curr_fruit > curr_fruit_max:\n            curr_fruit_max = curr_fruit\n        \n        curr_bling -= 400\n        if curr_bling < 0:\n            curr_bling = 0\n            \n        if rem_days % 3 == 0:\n            curr_fruit -= 3\n            if curr_fruit < 0:\n                curr_fruit = 0\n                \n        if rem_days % 2 == 0:\n            curr_bling -= 500\n            if curr_bling < 0:\n                curr_bling = 0\n                \n    return curr_fruit_max\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = [int(x) for x in stdin.split()]\n    return str(min(400 * d * f, b + sum([500 * (t - 1) + 400 * (d - t) * f for t in [t0, t1, t2]])))\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N, K = [int(i) for i in stdin.split(' ')]\n    A = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    B = [int(i) for i in stdin.split('\\n')[2].split(' ')]\n    A.sort()\n    B.sort()\n    count = 1\n    curr_rank = 0\n    for i in range(N):\n        if A[i] + K < B[i]:\n            count += 1\n            curr_rank = i\n    return str(count)\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(2)\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'Case #{}: {}'.format(stdin, solution)\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate the number of distinct ranks for all possible rankings.\n    >>> solution('''2 10\n   ... 1 5\n   ... 1 4\n   ... ''')\n    2\n    \"\"\"\n   ..."
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    ranks = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + k < a[j] or b[i] + k < b[j]:\n                continue\n            ranks.add(i)\n            ranks.add(j)\n    return len(ranks)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n\n    r = 0\n    for i in range(n):\n        r = max(r, (a[i] - b[i]) // k + 1)\n    print(r)\n    return r\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the max number of distinct ranks.\"\"\"\n    N, K = [int(v) for v in stdin.split()]\n    a = [int(v) for v in stdin.split()]\n    b = [int(v) for v in stdin.split()]\n    # Calculate difference between a and b\n    difference = [a_i - b_i for a_i, b_i in zip(a, b)]\n    ranks = []\n    max_rank = 0\n    for i, d in enumerate(difference):\n        if d >= 0:\n            ranks.append(1)\n        else:\n            for r in ranks:\n                if d <= r + K:\n                    ranks.append(r+1)\n                    break\n            else:\n                ranks.append(1)\n        max_rank = max(max_rank, len(ranks))\n\n    return max_rank\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    #...\n\nprint(solution(input()))\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(x) for x in stdin.split('\\n')[0].split()]\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    b = [int(x) for x in stdin.split('\\n')[2].split()]\n    def is_good(i, j):\n        return a[i] + K < a[j] and b[i] + K < b[j]\n    dp = [0] * N\n    for i in range(1, N):\n        dp[i] = 1 if is_good(0, i - 1) else dp[i - 1] + 1\n    return max(dp)\nprint(solution(stdin))\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(x) for x in stdin.split(' ')]\n    As = [int(x) for x in stdin.split(' ')[1:]]\n    Bs = [int(x) for x in stdin.split(' ')[1:]]\n    \n    n = len(As)\n    counts = [0] * (N + 1)\n    for i in range(n):\n        counts[max(0, As[i] - K)] += 1\n    for i in range(1, N + 1):\n        counts[i] += counts[i - 1]\n    for i in range(n - 1, -1, -1):\n        counts[max(0, Bs[i] - K)] = max(counts[max(0, Bs[i] - K)] - 1, counts[max(0, Bs[i] - K)])\n    print(counts[-1])\n    return ''"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lamps = []\n    for i in range(n):\n        lamps.append([int(stdin) for stdin in stdin.split()])\n    # \n    def is_valid(lamp_list, lamp_dict):\n        '''\n            lamp_list:\n            lamp_dict: {lamp_id: (x, y, e)}\n        '''\n        x_min, x_max = min(lamp_dict.values()), max(lamp_dict.values())\n        y_min, y_max = min(lamp_dict.values(), key = lambda lamp_pos: lamp_pos[1])[1], max(lamp_dict.values(), key = lambda lamp_pos: lamp_pos[1])[1]\n        x_tot, y_tot = 0, 0\n        for lamp_id, (x, y, e) in lamp_dict.items():\n            if lamp_id == 1:\n                continue\n            if lamp_dict[1][0] == x:\n                x_tot += abs(x - lamp_list[0][0])\n            if lamp_dict[1][1] == y:\n                y_tot += abs(y - lamp_list[0][1])\n            if lamp_dict[1][2] == e:\n                x_tot += abs(x - lamp_list[0][0])\n                y_tot += abs(y - lamp_list[0][1])\n        return x_min < x_tot < x_max and y_min < y_tot < y_max\n\n    def find_line(lamp_list, lamp_dict, is_left):\n        '''\n            lamp_list:\n            lamp_dict: {lamp_id: (x, y, e)}\n            is_left: bool\n        '''\n        if len(lamp_list) == 0:\n            return 0, 0, lamp_dict\n        left_x = lamp_list[0][0] if is_left else lamp_list[-1][0]\n        left_y = lamp_list[0][1] if is_left else lamp_list[-1][1]\n        left_e = lamp_list[0][2] if is_left else lamp_list[-1][2]\n        right_x = lamp_list[0][0] if not is_left else lamp_list[-1][0]\n        right_y = lamp_list[0][1] if not is_left else lamp_list[-1][1]\n        right_e = lamp_list[0][2] if not is_left else lamp_list[-1][2]\n        if right_e < left_e and abs(left_e - right_e) == 1:\n            lamp_dict = {1: (left_x, left_y, left_e)}\n            return find_line(lamp_list[1:], lamp_dict, is_left)\n        if left_e < right_e and abs(left_e - right_e) == 1:\n            lamp_dict = {1: (right_x, right_y, right_e)}\n            return find_line(lamp_list[:-1], lamp_dict, is_left)\n        lamp_dict = {lamp_id: (x, y, e) for lamp_id, (x, y, e) in lamp_dict.items() if not ((x == right_x and abs(y - right_y) == 1) or (y == right_y and abs(x - right_x) == 1))}\n        lamp_dict = {lamp_id: (x, y, e) for lamp_id, (x, y, e) in lamp_dict.items() if not ((x == left_x and abs(y - left_y) == 1) or (y == left_y and abs(x - left_x) == 1))}\n        if len(lamp_dict) == 1:\n            return right_x, right_y, lamp_dict\n        return find_line(lamp_list[1:], lamp_dict, is_left)\n\n    line_list = []\n    for i in range(1, n):\n        if lamps[i][0] > lamps[i-1][0]:\n            line_list.append(find_line(lamps[:i], {1: (lamps[i-1][0], lamps[i-1][1], lamps[i-1][2])}, True))\n        elif lamps[i][0] < lamps[i-1][0]:\n            line_list.append(find_line(lamps[i:], {1: (lamps[i][0], lamps[i][1], lamps[i][2])}, False))\n    if not line_list:\n        return 'IMPOSSIBLE'\n    line_list.sort(key = lambda line_tuple: line_tuple[0] - line_tuple[1])\n    return line_list[0][0] - line_list[0][1]\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute shortest distance from the left wall to the right wall\"\"\"\n    # Step 1: Read input\n    lamp_count = int(stdin.readline())\n    lamp_coordinates = [tuple(map(int, line.split())) for line in stdin]\n    if lamp_count < 2 or lamp_count > 12:\n        return \"IMPOSSIBLE\"\n    energy_sources = {}\n    for x, y, e in lamp_coordinates:\n        if x in energy_sources:\n            energy_sources[x][\"positive\"].append(e)\n        else:\n            energy_sources[x] = {\"positive\": [e], \"negative\": []}\n        if y in energy_sources:\n            energy_sources[y][\"negative\"].append(-e)\n        else:\n            energy_sources[y] = {\"negative\": [-e], \"positive\": []}\n    # Step 2: Calculate shortest distance\n    if len(energy_sources) == 0:\n        return \"IMPOSSIBLE\"\n    for x in energy_sources:\n        energy_sources[x][\"positive\"].sort(reverse=True)\n        energy_sources[x][\"negative\"].sort(reverse=True)\n    start_x, start_y = (list(energy_sources.keys())[0], list(energy_sources.keys())[0])\n    for x, y in energy_sources:\n        if x == start_x:\n            if y == start_y:\n                distance = abs(start_y - start_x)\n                break\n            else:\n                start_x = x\n                start_y = y\n                distance = abs(start_y - start_x)\n        else:\n            if x == start_y:\n                distance = abs(start_x - start_y)\n                break\n            else:\n                start_x = x\n                start_y = y\n                distance = abs(start_x - start_y)\n    # Step 3: Return the shortest distance\n    return str(distance)\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the longest length of a line dividing energy sources into two parts.\n\n    Args:\n        stdin (str): Input to be parsed.\n\n    Returns:\n        str: Output to be rendered.\n    \"\"\"\n\n    return \"\"\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the solution\"\"\"\n    x, y, energy, n = map(int, stdin.split('\\n')[0].split())\n    lamps = [[int(x) for x in y.split()] for y in stdin.split('\\n')[1:]]\n    x_m = sum(x for x, _ in lamps) / n\n    y_m = sum(y for _, y in lamps) / n\n    result = 0\n    for x_i, y_i, e_i in lamps:\n        x_p = x_m + x_i / 100\n        y_p = y_m + y_i / 100\n        result += sqrt((x_p - x_i) ** 2 + (y_p - y_i) ** 2) * e_i\n    for x_i, y_i, e_i in lamps:\n        x_p = x_m + x_i / 100\n        y_p = y_m + y_i / 100\n        result -= sqrt((x_p - x_i) ** 2 + (y_p - y_i) ** 2) * e_i\n    if result > 0:\n        return f'{result:.6f}'\n    else:\n        return 'IMPOSSIBLE'\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the length of the shortest line.\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Output.\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''Find the length of the shortest closed line which cancels the\n    energy distribution of a given set of lamps.\n\n    Parameters\n    ----------\n    stdin : str\n        The input on one line.\n\n    Returns\n    -------\n    str\n        The solution for this challenge.\n    '''\n    # Get the number of lamps from the input.\n    num_lamps = int(stdin.split('\\n')[0])\n    # Get the coordinate of each lamp from the input.\n    lamps = [(int(lamp[0]), int(lamp[1]))\n             for lamp in stdin.split('\\n')[1:]]\n    # Get the energy of each lamp from the input.\n    lamp_energies = [int(energy) for energy in stdin.split('\\n')[1:]]\n\n    # List all possible (x,y) coordinates.\n    possible_xy = set()\n    for x in range(1, 100):\n        for y in range(1, 100):\n            possible_xy.add((x, y))\n\n    # Get all the possible xy coordinates where the lamps will be placed.\n    lamp_xy = set()\n    for lamp in lamps:\n        lamp_xy.add(lamp)\n\n    # The energy distribution is equal to the negative value of the energy of\n    # the lamp.\n    energy_distribution = []\n    for lamp in lamps:\n        energy_distribution.append(-lamp_energies[lamps.index(lamp)])\n\n    # Check whether there is a closed line which cancels the above.\n    for x, y in lamp_xy:\n        temp_x = x\n        temp_y = y\n        for point in lamp_xy:\n            if temp_x == point[0] or temp_y == point[1]:\n                temp_x = point[0]\n                temp_y = point[1]\n                continue\n            else:\n                line = list(possible_xy.difference(set([(temp_x, temp_y)])))\n                line = sorted(line, key=lambda x: hypot(\n                    x[0]-temp_x, x[1]-temp_y))\n                is_line = True\n                for point in line:\n                    if hypot(point[0]-temp_x, point[1]-temp_y) <= 1:\n                        is_line = False\n                if is_line:\n                    return str(hypot(temp_x-x, temp_y-y))\n\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    points = []\n    for i in range(1, n + 1):\n        points.append(tuple(int(x) for x in stdin.split(\"\\n\")[i].split()))\n    points.sort()\n    for i in range(1, n):\n        if points[i][0] == points[i - 1][0]:\n            points.sort(key=lambda p: p[1])\n            continue\n        print(points[i - 1][0], points[i][0])\n        break\n\n    print(points)\n    return ''\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the number of distinct points at which there is at least one pair of line segments\n    that intersect or touch. If there are infinitely many such points, return -1.\n\n    >>> solution('3\\n1 3 9 5\\n2 2 6 8\\n4 8 9 3')\n    3\n    >>> solution('3\\n5 2 7 10\\n7 4 4 10\\n2 4 10 8')\n    1\n    >>> solution('3\\n-1 -2 -1 -1\\n-1 2 -1 -1')\n    1\n    \"\"\"\n    lines = stdin.splitlines()\n    points = set()\n\n    for i in range(len(lines)):\n        x0, y0, x1, y1 = [int(j) for j in lines[i].split()]\n        for p0, p1 in [(x0, y0), (x0, y1), (x1, y0), (x1, y1)]:\n            if p0 == p1:\n                points.add(p0)\n\n            else:\n                for q0, q1 in [(p0, p1), (p1, p0)]:\n                    if q0 * q1 < 0:\n                        points.add(q0)\n                        points.add(q1)\n\n    return max(points, default=0)\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the number of distinct points where the line segments intersect or touch.\n    \"\"\"\n    points = []\n    for line in stdin.splitlines()[1:]:\n        x0, y0, x1, y1 = map(int, line.split())\n        points.append([(x0, y0), (x1, y1)])\n\n    intersections = set()\n    for line_0, line_1 in combinations(points, 2):\n        for point_0, point_1 in product(line_0, line_1):\n            if point_0 == point_1:\n                break\n        else:\n            intersections.add(tuple(sorted(line_0)))\n            intersections.add(tuple(sorted(line_1)))\n    return str(len(intersections))\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    points = []\n    count = 0\n    for line in lines:\n        if len(line) == 0:\n            continue\n        elif len(line.split(\" \")) == 1:\n            points.append(int(line.strip()))\n        else:\n            x1, y1, x2, y2 = map(int, line.split(\" \"))\n            for x, y in points:\n                if (x1 == x and x2 == x) or (y1 == y and y2 == y) or (abs(x1-x2) == abs(y1-y2)):\n                    count += 1\n                    break\n            else:\n                points.append((x1, y1))\n                points.append((x2, y2))\n    return count if count!= 0 else -1\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 1 3 9 5\n   ... 2 2 6 8\n   ... 4 8 9 3''')\n    3\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution in format string.\"\"\"\n    n = int(stdin.split('\\n')[0])\n    points = []\n    for i in range(n):\n        points.append(list(map(int, stdin.split('\\n')[i + 1].split())))\n\n    return str(len(get_intersections(points)))\n\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    lines = stdin.split('\\n')\n    count = 0\n    for line in lines:\n        line = line.split()\n        x0, y0, x1, y1 = line\n        x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)\n        a = y1 - y0\n        b = -1 * (x1 - x0)\n        c = y0 * (x1 - x0) - x0 * (y1 - y0)\n        if (a == 0) and (b == 0) and (c == 0):\n            continue\n        elif (b == 0) and (c == 0):\n            continue\n        elif a == 0:\n            continue\n        elif b == 0:\n            continue\n        elif c == 0:\n            continue\n        else:\n            count += 1\n    if count == 0:\n        return \"0\"\n    else:\n        return str(count)\n\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of intersections for the lines drawn by a pen.\n    \"\"\"\n    line_count = int(stdin)\n    lines = [list(map(int, input().split())) for _ in range(line_count)]\n    points = set()\n    for line in lines:\n        for point in lines:\n            if line == point:\n                continue\n            else:\n                if (line[0] == point[0] or line[1] == point[1]) and \\\n                        (line[2] == point[0] or line[3] == point[1]):\n                    points.add(tuple(line + point))\n    return len(points)\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find number of distinct points at which line segments drawn by a\n    straight line intersect or touch.\n\n    Args:\n        stdin (str): input on STDIN\n\n    Returns:\n        str: output to STDOUT\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3\n   ... 1 3 9 5\n   ... 2 2 6 8\n   ... 4 8 9 3\n   ... '''[1:])\n    3\n    \"\"\"\n    points = set()\n    for i in stdin.split('\\n')[1:]:\n        line = list(map(int, i.split()))\n        for j in range(len(line) - 1):\n            for k in range(j + 1, len(line)):\n                a = line[j]\n                b = line[k]\n                if a * b >= 0:\n                    points.add(a + b)\n                else:\n                    points.add(a - b)\n    return min(points) if len(points)!= 0 else -1\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    line_count = int(lines[0])\n    results = set()\n    for i in range(1, line_count + 1):\n        x0, y0, x1, y1 = map(int, lines[i].split())\n        if x0 == x1 or y0 == y1:\n            continue\n        for j in range(i + 1, line_count + 1):\n            x2, y2, x3, y3 = map(int, lines[j].split())\n            if x0 == x3 and x1 == x2 or y0 == y3 and y1 == y2:\n                continue\n            if x0 == x1 and x2 == x3:\n                continue\n            if y0 == y1 and y2 == y3:\n                continue\n            if (x0, y0) == (x1, y1) or (x0, y0) == (x2, y2) or (x0, y0) == (x3, y3) or (x1, y1) == (x2, y2) or (x1, y1) == (x3, y3) or (x2, y2) == (x3, y3):\n                results.add((x0, y0))\n                results.add((x1, y1))\n                results.add((x2, y2))\n                results.add((x3, y3))\n    return f'{len(results) if results else -1}'\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 100:\n        return n\n    count = 0\n    for i in range(100, n + 1):\n        s = str(i)\n        if s[0] <= s[1] <= s[2] <= s[3] <= s[4] <= s[5] <= s[6] <= s[7] <= s[8] <= s[9]:\n            if s[0] <= s[1] <= s[2] <= s[3]:\n                count += 1\n            if s[1] <= s[2] <= s[3] <= s[4]:\n                count += 1\n            if s[2] <= s[3] <= s[4] <= s[5]:\n                count += 1\n            if s[3] <= s[4] <= s[5] <= s[6]:\n                count += 1\n            if s[4] <= s[5] <= s[6] <= s[7]:\n                count += 1\n            if s[5] <= s[6] <= s[7] <= s[8]:\n                count += 1\n            if s[6] <= s[7] <= s[8] <= s[9]:\n                count += 1\n        else:\n            continue\n    if count == 0:\n        return -1\n    return count\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if len(str(n)) == 1:\n        return n\n    else:\n        stdin = [int(x) for x in str(n)]\n        diff = [stdin[i] - stdin[i-1] for i in range(1, len(stdin))]\n        s = set()\n        for i in range(1, len(diff)):\n            if diff[i] == diff[i-1]:\n                s.add(diff[i])\n        if len(s) == 1:\n            return n - diff[0] + 1\n        else:\n            return -1"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    return stdin\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ans = 0\n    for i in range(1, 10**18):\n        if is_hill(i):\n            ans += 1\n        if ans > n:\n            break\n    return str(ans) if ans <= n else '-1'\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    n = int(stdin)\n    def find_hills(num):\n        global count\n        if (num < 1000) or (num > 1000000000):\n            return\n        else:\n            num_list = list(str(num))\n            for i in range(1, len(num_list)):\n                if int(num_list[i - 1]) > int(num_list[i]):\n                    return\n                else:\n                    if i + 1 < len(num_list):\n                        if int(num_list[i - 1]) < int(num_list[i + 1]):\n                            count += 1\n                    if i > 1:\n                        if int(num_list[i - 1]) < int(num_list[i - 2]):\n                            count += 1\n            for i in range(1, len(num_list)):\n                if int(num_list[i - 1]) < int(num_list[i]):\n                    return\n                else:\n                    if i + 1 < len(num_list):\n                        if int(num_list[i - 1]) < int(num_list[i + 1]):\n                            count += 1\n                    if i > 1:\n                        if int(num_list[i - 1]) < int(num_list[i - 2]):\n                            count += 1\n    for i in range(1, n + 1):\n        find_hills(i)\n    if count == 0:\n        print(-1)\n    else:\n        print(count)"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    if n >= 100:\n        while n >= 100:\n            n = n - 100\n            count += 1\n        count += 1\n        if count == 5:\n            count -= 1\n        if count > 5:\n            count = count - 1\n        while count > 0:\n            if n >= 100:\n                n = n - 100\n                count -= 1\n            else:\n                break\n        count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n            count -= 1\n        else:\n            break\n    count += 1\n    if count == 5:\n        count -= 1\n    if count > 5:\n        count = count - 1\n    while count > 0:\n        if n >= 100:\n            n = n - 100\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        if hill(i):\n            count += 1\n    return count\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # n = list(map(int, stdin))\n    # for i in n:\n    #     if i % 2 == 0 and i % 3 == 0:\n    #         print(i)\n    #     elif i % 2 == 0:\n    #         print(i)\n    #     elif i % 3 == 0:\n    #         print(i)\n    #     else:\n    #         print(-1)\n\n    print(-1)\n    return\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_num = set()\n    for i in range(1, n + 1):\n        if i in hill_num:\n            continue\n        i = str(i)\n        hills = 0\n        for k in range(len(i)):\n            if i[k] == i[-1 - k]:\n                hills += 1\n            else:\n                break\n        if hills == len(i):\n            hill_num.add(int(i))\n    if len(hill_num) == 0:\n        return -1\n    return len(hill_num)\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    N = a[4]\n    a = a[0:4]\n    count = 0\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            for k in range(1, N+1):\n                if i!= j and i!= k and j!= k:\n                    if (a[0] - a[1] + a[2] + a[3]) == (a[1] - a[0] + a[2] + a[3]) == (a[2] - a[1] + a[0] + a[3]) == (a[3] - a[2] + a[1] + a[0]):\n                        if (i - j + k) % 2 == 0 and (k - j + i) % 2 == 0:\n                            count += 1\n    return str(count % 1000000007)\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, a3, a4, n = map(int, stdin.split())\n    return str(comb(n, a1 + a2 + a3 + a4, n - a1 - a2 - a3 - a4))\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = [int(x) for x in stdin.split()]\n    MOD = 10 ** 9 + 7\n    mod = lambda x: x % MOD\n    return mod(a11 * a22 * 2 + a12 * a21 * 2 + N * (N - 1))\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = map(int, stdin.split())\n    return str((a11 * (n + a12) * (n + a22)) + (a21 * (n + a22) * (n + a11)) + (a22 * (n + a11) * (n + a12)))\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = map(int, stdin.split())\n    a = [a11, a12, a21, a22]\n    mod = 1000000007\n    moves = 1\n    for i in range(n):\n        moves = (moves * (a[i] + 1) * (a[i] - 1)) % mod\n    moves = moves * ((a[0] + 1) * (a[3] + 1)) % mod\n    moves = moves * ((a[1] + 1) * (a[2] + 1)) % mod\n    return str(moves)\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    attack_1, attack_2, defend_1, defend_2, N = map(int, stdin.split())\n    return f'{attack_1 * attack_2 * defend_1 * defend_2 * N}'\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a = [int(x) for x in stdin.split(\" \")]\n    n = a[0]\n    a = a[1:]\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j]\n            if a[i]!= a[j]:\n                dp[i + 1][j + 1] -= dp[i + 1][j]\n                dp[i + 1][j + 1] %= MOD\n            if a[i]!= a[j] and i + 2 <= j:\n                dp[i + 1][j + 1] += dp[i + 2][j]\n                dp[i + 1][j + 1] %= MOD\n    return dp[1][n]\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 0 0 0 3\n   ... 3 0 0 0 3''')\n    '6'\n    >>> solution('''1 2 0 0 5\n   ... 1 2 0 0 5''')\n    '2'\n    >>> solution('''1 2 0 0 6\n   ... 1 2 0 0 6''')\n    '0'\n    \"\"\"\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    return str(sum((a11 + a12 + a21 + a22) * (a11 + a12 + a21 + a22) - 4 * a11 * a22) * pow(2, N, 1000000007))\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split(' ')))\n    a, b, c, d, n = nums\n\n    s1 = [a, b, c, d]\n    s2 = [a, d, c, b]\n\n    def helper(s1, s2):\n        res = 0\n        for i in range(3):\n            if s1[i] == s2[i]:\n                res += 1\n\n        if res == 1:\n            return 0\n\n        if res == 2:\n            return 1\n\n        if res == 0:\n            return 2\n\n        if res == 3:\n            return 3\n\n        if res == 4:\n            return 4\n\n    return str(helper(s1, s2) + helper(s2, s1))\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = [int(num) for num in stdin.split()]\n    result = 0\n    if a11 == 0 and a12 == 0:\n        result = 0\n    elif a11 == 0 and a12 == 1:\n        result = n * (n - 1)\n    elif a11 == 1 and a12 == 2:\n        result = n * (n - 1) + (n - 2) * (n - 3)\n    elif a11 == 2 and a12 == 3:\n        result = n * (n - 1) * (n - 2) + (n - 2) * (n - 3) * (n - 4)\n\n    elif a11 == 3 and a12 == 0:\n        result = 0\n    elif a11 == 3 and a12 == 1:\n        result = n * (n - 1) + (n - 2) * (n - 3) + (n - 3) * (n - 4)\n    elif a11 == 4 and a12 == 2:\n        result = n * (n - 1) + (n - 2) * (n - 3) + (n - 3) * (n - 4) + (n - 4) * (n - 5)\n    elif a11 == 5 and a12 == 3:\n        result = n * (n - 1) + (n - 2) * (n - 3) + (n - 3) * (n - 4) + (n - 4) * (n - 5) + (n - 5) * (n - 6)\n    elif a11 == 6 and a12 == 4:\n        result = n * (n - 1) + (n - 2) * (n - 3) + (n - 3) * (n - 4) + (n - 4) * (n - 5) + (n - 5) * (n - 6) + (n - 6) * (n - 7)\n\n    return str(result % 1000000007)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"Compute the points on the Archimedean spiral where the avatar should press the button.\"\n    # Get input parameters\n    b, t_x, t_y = map(float, stdin.split())\n\n    # Get input\n    target = complex(t_x, t_y)\n\n    # Compute the steps to move the avatar along the spiral\n    steps = int((2 * math.pi * b) / math.sqrt(t_x ** 2 + t_y ** 2))\n\n    # Compute the Archimedean spiral\n    x = b * math.cos(steps)\n    y = b * math.sin(steps)\n\n    # Get the distance from target to the nearest point on the Archimedean spiral\n    distance = math.sqrt(x ** 2 + y ** 2)\n\n    # Compute the signed angle between target and the nearest point\n    angle = math.atan2(target.imag, target.real) - math.atan2(y, x)\n\n    # Compute the coordinates of the nearest point\n    x = distance * math.cos(angle)\n    y = distance * math.sin(angle)\n\n    # Return the coordinates\n    return f\"{x}, {y}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    r = b * np.pi\n    phi = np.arctan2(t_y, t_x)\n    return \"{:.5f} {:.5f}\".format(r * np.cos(phi), r * np.sin(phi))\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the point where the avatar exits the spiral, continuing in the direction it's moving, and hits the target without intersecting the spiral.\"\"\"\n    # Lines:\n    # x = (r - b) cos(phi)\n    # y = (r - b) sin(phi)\n    # d = (r - b) / (r + b)\n    # phi = 2 * pi * d\n    # r = b * d\n    # y = (r - b) d\n    # -y = (r - b) d\n    # y = -(r - b) d\n    # r = b * d\n    # y = -(r - b) d\n    # (r - b) = -d y\n    # r = -d * y + b d\n    # r = d * y - b d\n    # r = d y - b d\n    # d = y - b d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b d) / d\n    # d = (y - b"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, x, y = map(float, stdin.split())\n    r = b * np.arctan(x / y)\n    r += 2 * np.pi * b\n    return f'{r * np.cos(np.pi / 2 - np.arctan2(x, y)):.5f} {r * np.sin(np.pi / 2 - np.arctan2(x, y)):.5f}'\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''Return the x, y coordinates of the point on the spiral where the avatar should leave the spiral,\n    continue in the direction it is moving, and hit the target without intersecting the spiral.\n    '''\n    b, t_x, t_y = [float(val) for val in stdin.split()]\n    r = b * np.arccos(1 / b)\n    d = np.sqrt(t_x ** 2 + t_y ** 2)\n    phi = np.arctan2(t_y, t_x)\n    d_theta = np.arccos(1 / b)\n    a = phi + d_theta\n    b = phi - d_theta\n    if d <= r:\n        return '{0:.5f} {1:.5f}'.format(r * np.cos(a), r * np.sin(a))\n    else:\n        return '{0:.5f} {1:.5f}'.format(r * np.cos(b), r * np.sin(b))\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution dict.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution string\n    \"\"\"\n    b, t_x, t_y = list(map(float, stdin.split()))\n    angle = 2 * math.pi * b / 3\n    l = math.sqrt(t_x ** 2 + t_y ** 2)\n    t_angle = math.atan2(t_y, t_x)\n    x, y = l * math.cos(angle / 2), l * math.sin(angle / 2)\n    x += b * t_angle * math.cos(angle / 2)\n    y += b * t_angle * math.sin(angle / 2)\n    return \"{:.5f} {:.5f}\".format(x, y)\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution of the exercise.\n\n    >>> solution(\"0.5 -5.301 3.098\")\n    '-1.26167861 3.88425357'\n    >>> solution(\"0.5 8 8\")\n    '9.21068947 2.56226688'\n    >>> solution(\"1 8 8\")\n    '6.22375968 -0.31921472'\n    >>> solution(\"0.5 -8 8\")\n    '-4.36385220 9.46891588'\n    \"\"\"\n    b, t_x, t_y = stdin.split()\n    b, t_x, t_y = float(b), float(t_x), float(t_y)\n    b = min(b, 10)\n    r = b * math.pi\n    r2 = r**2\n    theta = -r\n    c = t_x**2 + t_y**2\n    while theta < r:\n        if c < r2:\n            return f\"{theta:.5f} {r*math.cos(theta):.5f} {r*math.sin(theta):.5f}\"\n        c -= r2\n        theta += 0.1\n    return f\"{theta:.5f} {r*math.cos(theta):.5f} {r*math.sin(theta):.5f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the point on the Archimedean spiral when the avatar releases the target\n    \"\"\"\n    b, t_x, t_y = [float(n) for n in stdin.split()]\n    r = b * np.arctan2(t_y, t_x)\n    x = r * np.cos(t_x)\n    y = r * np.sin(t_x)\n    return str(x) + \" \" + str(y)\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the point on the Archimedean spiral where the avatar should leave the spiral,\n    continues in the direction it is moving, and hits the target without intersecting the\n    spiral.\n\n    Args:\n        stdin (str): The input string\n\n    Returns:\n        str: The output string\n    \"\"\"\n    x, y, t_x, t_y = map(float, stdin.split())\n    if abs(t_x) > 10000:\n        return 'INF'\n    elif abs(t_y) > 10000:\n        return 'INF'\n    b = sqrt(t_x ** 2 + t_y ** 2)\n    t = sqrt(x ** 2 + y ** 2)\n    if b <= 0.01:\n        return 'INF'\n    elif t <= 10 ** -3:\n        return 'INF'\n    phi = acos(x / t)\n    r = b * phi\n    while r < t:\n        if x > 0:\n            phi += 2 * pi\n        else:\n            phi -= 2 * pi\n        r = b * phi\n    return f'{r * cos(phi)} {r * sin(phi)}'\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the x and y coordinates of the point on the spiral where the avatar should leave the spiral,\n    continue in the direction it is moving, and hit the target without intersecting the spiral.\"\"\"\n    b, t_x, t_y = map(float, stdin.split())\n\n    x = t_x / (b ** 2) - t_y / b\n    y = 2 * t_x / b - t_y\n\n    return f'{x:.5f} {y:.5f}'\n\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A Naive implementation of the problem\n\n    Args:\n        stdin (str): Input to be parsed\n\n    Returns:\n        str: Solution to the problem\n    \"\"\"\n\n    num_rooms, num_corridors = [int(x) for x in stdin.split('\\n')[:2]]\n    corridors = [int(x) for x in stdin.split('\\n')[2:]]\n\n    corridor_graph = collections.defaultdict(list)\n    for u, v in corridors:\n        corridor_graph[u].append(v)\n        corridor_graph[v].append(u)\n\n    remove_edges = []\n    for u, v in list(corridor_graph.items()):\n        if len(v) == 1:\n            remove_edges.append((u, v[0]))\n            remove_edges.append((v[0], u))\n\n    while remove_edges:\n        u, v = remove_edges.pop()\n        corridor_graph[u].remove(v)\n        corridor_graph[v].remove(u)\n        if len(corridor_graph[u]) == 1:\n            remove_edges.append((u, corridor_graph[u][0]))\n        if len(corridor_graph[v]) == 1:\n            remove_edges.append((v, corridor_graph[v][0]))\n\n    remove_edges = set()\n    for u, v in list(corridor_graph.items()):\n        if len(v) == 1:\n            remove_edges.add((u, v[0]))\n            remove_edges.add((v[0], u))\n\n    return str(len(remove_edges) // 2)\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    room_count, corridor_count = map(int, stdin.split(' '))\n    edges = [list(map(int, stdin.split(' '))) for i in range(corridor_count)]\n    start = []\n    end = []\n    for edge in edges:\n        start.append(edge[0])\n        end.append(edge[1])\n\n    count = 0\n    result = []\n    for i in range(1, room_count + 1):\n        if i not in end and i not in start:\n            result.append(i)\n            count += 1\n        if count >= room_count / 2:\n            break\n\n    print(count)\n    for i in result:\n        print(i, end=' ')\n    return ''\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the solution\"\"\"\n    pass\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a string containing a solution to the problem.\n    Time complexity: O(m log n)\n    Space complexity: O(1)\n    \"\"\"\n    n, m = [int(s) for s in stdin.split()]\n    edges = []\n    for i in range(m):\n        u, v = [int(s) for s in stdin.split()]\n        edges.append((u, v))\n    # Create an adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    # Walk along the edges and remove some of them\n    count = 0\n    for i, (u, v) in enumerate(edges):\n        if len(adj_list[u]) == 1:\n            count += 1\n            edges.pop(i)\n            if len(adj_list[v]) == 1:\n                edges.pop(i)\n    # Recurse if we removed any edges\n    if count > 0:\n        return solution(stdin)\n    # We did not remove any edges so return the remaining edges\n    return \" \".join([str(u) for u, v in edges])\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''Finds the number of removed corridors, followed by the removed corridors.'''\n    num_rooms, num_corridors = [int(n) for n in stdin.split()]\n    corridors = stdin.splitlines()[1:]\n    corridor_pairs = [tuple(int(n) for n in pair.split()) for pair in corridors]\n    # Find all pairs of nodes that are connected, and their in/out degrees.\n    connected = set(corridor_pairs)\n    in_degrees = Counter()\n    out_degrees = Counter()\n    for u, v in connected:\n        in_degrees[v] += 1\n        out_degrees[u] += 1\n    # For each node, if we know the total number of in-degrees and the total\n    # number of out-degrees for all nodes, we can find all nodes that have a\n    # certain total.\n    # The total number of nodes that have a certain total is simply the\n    # cardinality of the Cartesian product.\n    # We can find the cardinality of the Cartesian product of sets using the\n    # standard formula for the cardinality of the Cartesian product of sets:\n    # |A x B| = |A| x |B|.\n    # We can also find the cardinality of a set of integers using the fact that\n    # the number of elements in the Cartesian product of a set of integers of\n    # length n is 2^n.\n    # The total number of nodes in the Graph is the number of unique numbers\n    # in the in/out degrees.\n    total_nodes = 2 ** num_rooms\n    for node in range(1, total_nodes + 1):\n        # Get the number of connections that we have to remove.\n        # The total number of connections is the number of in-degrees minus the\n        # number of out-degrees.\n        n_connections = in_degrees[node] - out_degrees[node]\n        # If there are more connections than we have to remove, there is no\n        # solution.\n        if n_connections > num_corridors // 2:\n            return \"0\"\n        # If we have an odd number of connections, we only have to remove\n        # half.\n        if n_connections % 2 == 1:\n            return str(n_connections // 2 + 1)\n        # If we have an even number of connections, we can only remove\n        # an even number of connections.\n        if n_connections % 2 == 0:\n            return str(n_connections // 2)\n    return \"0\"\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    (n, m) = map(int, stdin.split(' '))\n    corr = set()\n    for _ in range(m):\n        (u, v) = map(int, stdin.split(' '))\n        corr.add(frozenset([u, v]))\n        corr.add(frozenset([v, u]))\n    corr = list(corr)\n    corr.sort(key=lambda x: x[0])\n    corr.sort(key=lambda x: x[1])\n    corr_to_remove = []\n    for u, v in corr:\n        if u == v:\n            corr_to_remove.append(frozenset([u, v]))\n        elif u < v:\n            corr_to_remove.append(frozenset([u, v]))\n            corr_to_remove.append(frozenset([v, u]))\n    corr_to_remove = [corr[0]] + [corr[i] for i in range(1, len(corr)) if corr[i] not in corr_to_remove]\n    corr_to_remove = [i for i in corr_to_remove if len(i) == 2]\n    for i in corr_to_remove:\n        corr.remove(i)\n    return len(corr_to_remove)\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(c) for c in stdin.split(' ')]\n    rooms = []\n    for _ in range(m):\n        a, b = [int(c) for c in stdin.split(' ')]\n        rooms.append((a, b))\n    rooms = sorted(rooms)\n\n    connected = dict()\n    for (a, b) in rooms:\n        if a in connected:\n            connected[a].append(b)\n        else:\n            connected[a] = [b]\n        if b in connected:\n            connected[b].append(a)\n        else:\n            connected[b] = [a]\n\n    used = set()\n    rooms_to_remove = []\n    for a, b in rooms:\n        if b in used:\n            continue\n        paths = []\n        find_paths(a, b, [a], connected, paths)\n        if len(paths) > 1:\n            rooms_to_remove.append((a, b))\n        used.add(a)\n        used.add(b)\n\n    # print(rooms_to_remove)\n    if len(rooms_to_remove) > int(m / 2):\n        return str(len(rooms_to_remove) - int(m / 2))\n    else:\n        return '0'\n\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    n, m = [int(x) for x in stdin.strip().split()]\n    edges = []\n    for _ in range(m):\n        u, v = [int(x) for x in stdin.strip().split()]\n        edges.append((u, v))\n    edges.sort()\n\n    color = {}\n    for u, v in edges:\n        if u not in color:\n            color[u] = 0\n        if v not in color:\n            color[v] = 0\n\n    def find(x):\n        if color[x] == 0:\n            return x\n        color[x] = find(color[x])\n        return color[x]\n\n    def union(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx == rooty:\n            return True\n        else:\n            color[rootx] = rooty\n            return False\n\n    count = 0\n    for u, v in edges:\n        if union(u, v):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    num_balls, num_tubes, s, t = [int(x) for x in stdin.split(' ')]\n    tubes = []\n    for _ in range(num_tubes):\n        start, end, length = [int(x) for x in stdin.split(' ')]\n        tubes.append(length)\n    return 'infinity'\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, m, s, t = map(int, stdin.split())\n    tube = []\n    for i in range(m):\n        a, b, w = map(int, stdin.split())\n        tube.append([a, b, w])\n        tube.append([b, a, w])\n    # print(tube)\n    visited = [[0] * n for _ in range(2)]\n    q = [s]\n    visited[0][s] = 1\n    while q:\n        for i in range(len(q)):\n            cur = q.pop(0)\n            for j in range(len(tube)):\n                if tube[j][0] == cur and visited[0][tube[j][1]] == 0:\n                    visited[0][tube[j][1]] = 1\n                    q.append(tube[j][1])\n                elif tube[j][1] == cur and visited[1][tube[j][0]] == 0:\n                    visited[1][tube[j][0]] = 1\n                    q.append(tube[j][0])\n        # print(q)\n        # print(visited)\n        if t in q:\n            break\n    # print(visited)\n    # print(tube)\n    if s == t:\n        return \"0\"\n    for i in visited:\n        if i[t] == 1:\n            return \"infinity\"\n    if visited[0][t] == 1 and visited[1][t] == 1:\n        return \"infinity\"\n    # print(visited[0][t], visited[1][t])\n    return str(max(visited[0][t], visited[1][t]) + 1)\n\n\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(x) for x in stdin.split()]\n    edges = [[] for _ in range(n)]\n    weights = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, w = [int(x) for x in stdin.split()]\n        edges[u].append(v)\n        weights[u].append(w)\n    d = {}\n\n    def find(x):\n        if x!= d.get(x, x):\n            d[x] = find(d.get(x, x))\n        return d[x]\n\n    def union(x, y):\n        d[find(y)] = find(x)\n\n    def mst():\n        s = set()\n        for i in range(n):\n            if i!= s:\n                union(s, i)\n\n    def compute_dist(ball1, ball2):\n        mst()\n        dist = 0\n        curr_ball = ball1\n        while curr_ball!= ball2:\n            dist += weights[find(curr_ball)][edges[find(curr_ball)].index(curr_ball)]\n            curr_ball = find(edges[find(curr_ball)][weights[find(curr_ball)].index(\n                weights[find(curr_ball)][edges[find(curr_ball)].index(curr_ball)])])\n        return dist\n\n    return str(compute_dist(s, t))\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The shortest distance to reach the bed.\"\"\"\n    n, m, s, t = (int(x) for x in stdin.split())\n    d = [x for x in stdin.split(\"\\n\")]\n    d = d[1:]\n    print(d)\n    p = len(d)\n    print(p)\n    l = [x for x in d[0].split()]\n    print(l)\n    l = list(map(int, l))\n    print(l)\n    l1 = []\n    for i in range(m):\n        l1.append(d[i].split())\n    print(l1)\n    l1 = [list(map(int, x)) for x in l1]\n    print(l1)\n    d = dict()\n    for i in range(m):\n        d[l1[i][0]] = [l1[i][1], l1[i][2]]\n    print(d)\n    d1 = {s: [s, 0]}\n    visited = {s}\n    while len(d1) < p:\n        for i in d:\n            if d[i][1] == d1[i][0]:\n                if i not in visited:\n                    d1[i] = d[i]\n                    visited.add(i)\n        for i in d1:\n            if i not in d:\n                d1.pop(i)\n    print(d1)\n    d2 = dict()\n    for i in range(m):\n        d2[l1[i][0]] = [l1[i][1], l1[i][2]]\n    print(d2)\n    a = []\n    b = []\n    for i in d2:\n        a.append(d2[i][0])\n        b.append(d2[i][1])\n    print(a)\n    print(b)\n    l1 = set(a)\n    l2 = set(b)\n    print(l1)\n    print(l2)\n    if len(l1) == p and len(l2) == 1:\n        return d1[l2.pop()][1]\n    for i in range(m):\n        if a[i] in d:\n            a[i] = d[a[i]][1]\n        else:\n            a[i] = -1\n    print(a)\n    for i in range(m):\n        if b[i] in d:\n            b[i] = d[b[i]][1]\n        else:\n            b[i] = -1\n    print(b)\n    c = a[:]\n    d = b[:]\n    print(c)\n    print(d)\n    for i in range(m):\n        if a[i] == b[i]:\n            if a[i] in d:\n                a[i] = d[a[i]][1]\n                print(\"1\", a[i])\n            else:\n                a[i] = -1\n        if a[i] < b[i]:\n            print(\"2\", a[i])\n            if a[i] in d:\n                a[i] = d[a[i]][1]\n                print(\"3\", a[i])\n            else:\n                a[i] = -1\n        else:\n            print(\"4\", a[i])\n            if b[i] in d:\n                b[i] = d[b[i]][1]\n                print(\"5\", b[i])\n            else:\n                b[i] = -1\n    print(a)\n    print(b)\n    e = set(a)\n    f = set(b)\n    print(e)\n    print(f)\n    if len(e) == 1 and len(f) == 1:\n        if list(e)[0] == list(f)[0]:\n            return d1[list(e)[0]][1]\n        else:\n            return 'infinity'\n    else:\n        return 'infinity'\n\ndef"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Input\n    n, m, s, t = map(int, stdin.split(' '))\n    incoming_tubes = [tuple(map(int, stdin.split(' '))) for _ in range(m)]\n\n    # Add padding, so the number of nodes in the graph will match the number of balls.\n    n += 2\n\n    # Graph structure.\n    graph = [set() for _ in range(n)]\n    # Nodes corresponding to balls.\n    incoming_tubes_nodes = [i for i in range(n) if i not in (s, t)]\n    # Nodes corresponding to the end of incoming tubes.\n    incoming_tubes_nodes_end = [i for i in range(n) if i not in incoming_tubes_nodes]\n    # Nodes corresponding to the start of outgoing tubes.\n    outgoing_tubes_nodes = [i for i in range(n) if i not in incoming_tubes_nodes]\n    # Nodes corresponding to the end of outgoing tubes.\n    outgoing_tubes_nodes_end = [i for i in range(n) if i not in outgoing_tubes_nodes]\n    # Directed edges between nodes.\n    for tube in incoming_tubes:\n        for i in range(tube[0], tube[1] + 1):\n            graph[tube[0]].add((tube[2], i))\n    for tube in incoming_tubes:\n        for i in range(tube[0], tube[1] + 1):\n            graph[i].add((tube[2], tube[1]))\n    for i in range(n):\n        graph[i].add((i, i))\n    for i in incoming_tubes_nodes_end:\n        graph[i].add((i, n - 1))\n    for i in outgoing_tubes_nodes:\n        graph[n - 1].add((i, i))\n    for i in outgoing_tubes_nodes_end:\n        graph[i].add((i, s))\n    # Find the shortest path.\n    if t == s:\n        return \"infinity\"\n    # Distance and route.\n    distance = [n] * n\n    route = [n] * n\n    distance[s] = 0\n    route[s] = n\n    # Run Bellman-Ford.\n    for _ in range(n - 1):\n        for u in range(n):\n            for v in graph[u]:\n                # Relax edges.\n                if distance[v[0]] > distance[u] + v[1]:\n                    distance[v[0]] = distance[u] + v[1]\n                    route[v[0]] = u\n    # Check for negative cycle.\n    for u in range(n):\n        for v in graph[u]:\n            if distance[v[0]] > distance[u] + v[1]:\n                return \"infinity\"\n    # Get the shortest route.\n    u = t\n    route_result = []\n    while u!= n - 1:\n        route_result.append(u)\n        u = route[u]\n    route_result.append(u)\n    # Return the sum of distances between start and end, plus the distance between the start and end.\n    return str(sum(distance)) + \" \" + str(distance[t])\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 5 0 3\\n0 1 1\\n1 2 2\\n2 0 4\\n2 3 1\\n2 3 3\")\n    '11'\n    >>> solution(\"5 5 0 4\\n0 1 1\\n1 2 1\\n2 3 1\\n3 0 1\\n2 4 1\")\n    'infinity'\n    \"\"\"\n    n, m, s, t = list(map(int, stdin.split()))\n    edges = defaultdict(list)\n    for _ in range(m):\n        u, v, w = list(map(int, stdin.split()))\n        edges[u].append((v, w))\n        edges[v].append((u, w))\n\n    queue = [(s, 0)]\n    visited = set()\n    while queue:\n        ball, dist = queue.pop(0)\n        if ball == t:\n            return dist\n        visited.add(ball)\n        for neigh, w in edges[ball]:\n            if neigh not in visited:\n                queue.append((neigh, dist + w))\n    return \"infinity\"\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"time in seconds to reach bed\"\"\"\n    # remove trailing whitespace and split into lists\n    l = [list(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    # find the smallest time to travel a tube and add it to an array\n    n, m, s, t = l[0][0], l[1][0], l[0][1], l[1][1]\n    tube_times = [0] * n\n    for a, b, w in l[2:]:\n        tube_times[a] += w\n        tube_times[b] += w\n    # find the minimum time to travel the smallest amount of time through all tubes\n    # subtract the time to travel the first tube\n    tube_times = [w - tube_times[s] for w in tube_times]\n    # if there is no solution, return infinity\n    if any(time < 0 for time in tube_times):\n        return 'infinity'\n    return str(max(tube_times))\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem\"\"\"\n    # Get the input\n    n, m, s, t = stdin.split(\" \")\n    n, m, s, t = int(n), int(m), int(s), int(t)\n    tubes = []\n    for _ in range(m):\n        a, b, w = stdin.split(\" \")\n        a, b, w = int(a), int(b), int(w)\n        tubes.append((a, b, w))\n\n    tubes.sort(key=lambda x: x[2])\n\n    # Create the graph\n    graph = {\n        i: [] for i in range(n)\n    }\n    for a, b, w in tubes:\n        graph[a].append((b, w))\n\n    # Find the shortest path\n    unvisited = set(graph.keys())\n    visited = set()\n    visited.add(s)\n    queue = [s]\n    path = {\n        i: [] for i in range(n)\n    }\n    while queue:\n        current = queue.pop(0)\n        for neighbor in graph[current]:\n            if neighbor[0] not in visited:\n                visited.add(neighbor[0])\n                queue.append(neighbor[0])\n                path[neighbor[0]] = path[current].copy()\n                path[neighbor[0]].append(neighbor[1])\n    if t in path:\n        return str(sum(path[t]))\n    return \"infinity\"\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    balls = list(map(int, lines[1].split()))\n    k = int(lines[2])\n    excluded = set()\n    for line in lines[3:3+k]:\n        excluded.update(set(map(int, line.split())))\n    sequence = lines[3+k]\n    return str(prod([c for c in balls if c not in excluded]))\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 2 1 2 1\\n2 1 2\\n2 3 4\\n\")\n    '6'\n    >>> solution(\"3 3 1 1\\n1 1\\n2 2 3\\n\")\n    '0'\n    >>> solution(\"3 2 2 3\\n1 1\\n2 2 3\\n\")\n    '18'\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    balls = [0] + list(map(int, stdin.split(\"\\n\")[1].split()))\n    balls = list(set(balls))\n    balls.sort()\n    cond = set(map(int, stdin.split(\"\\n\")[2].split()))\n    cond = cond.union(set(balls))\n    cond = list(cond)\n    # balls = [2, 1, 2, 1]\n    # cond = [1, 2]\n\n    # print(balls, cond)\n    # print(f\"red: {red}, green: {green}, yellow: {yellow}, blue: {blue}\")\n    # print(f\"n: {n}\")\n\n    count = 0\n    for i in range(len(cond)):\n        for j in range(len(balls)):\n            if balls[j] == cond[i]:\n                if j == 0 or balls[j - 1]!= cond[i]:\n                    count += 1\n    return count % 1000000007\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_balls, num_colors, num_pref = [int(s) for s in stdin.split(\"\\n\")[0].split(\" \")]\n    preferences = [int(s) for s in stdin.split(\"\\n\")[1].split(\" \")]\n    preferences = {c: i for i, c in enumerate(preferences)}\n    solutions = [0]\n\n    def generate_solutions(n, i, slate):\n        if i >= n:\n            solutions[0] += 1\n            return\n        # if we can put a ball of color i on the slate, do it\n        if (preferences[i] not in slate) or (len(slate) > num_pref):\n            generate_solutions(n, i + 1, slate + [i])\n        # if we can't put a ball of color i on the slate, do nothing\n        generate_solutions(n, i + 1, slate)\n\n    generate_solutions(num_balls, 0, [])\n    print(solutions[0] % int(1e9 + 7))\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the number of ways the balls can be arranged\"\"\"\n\n    balls = [int(x) for x in stdin.splitlines()[0].split()]\n    balls.sort()\n    # colors = sorted(set(balls))\n    colors = [int(x) for x in stdin.splitlines()[1].split()]\n    ans = 0\n\n    for num_in_row in range(balls[0], balls[-1] + 1):\n        for num_of_colors in range(len(colors) + 1):\n            valid_cnt = 0\n            for i in range(0, num_of_colors):\n                if colors[i] >= num_in_row:\n                    valid_cnt += 1\n                else:\n                    break\n\n            for i in range(valid_cnt, num_in_row + 1):\n                if colors[num_of_colors - 1] >= i:\n                    valid_cnt += 1\n                else:\n                    break\n\n            ans += valid_cnt\n            # ans = ans % 1000000007\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(1)\"\"\"\n    # parse\n    num_balls: int = int(stdin[0].rstrip())\n    freq: List[int] = [int(i) for i in stdin[1:num_balls + 1]]\n    balls: List[int] = list(map(int, stdin[num_balls + 1:]))\n    num_dif_colors: int = sum(freq)\n\n    # 1-indexed DP solution\n    dp: List[List[int]] = [[0] * num_dif_colors for i in range(num_balls + 1)]\n    dp[0][0] = 1\n    for i in range(1, num_balls + 1):\n        for j in range(num_dif_colors):\n            dp[i][j] = dp[i - 1][j]\n            if j < freq[i - 1] and balls[i - 1]!= j + 1:\n                dp[i][j] += dp[i - 1][j]\n            dp[i][j] %= int(1e9 + 7)\n    return dp[-1][-1]\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 1 2 3\n   ... 1 1\n   ... 2 2 3''')\n    '6'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    import sys\n    from collections import Counter\n    from itertools import combinations\n\n    ball_counts = [int(x) for x in stdin.split()]\n    balls_exclude_counts = {int(x) for x in sys.stdin.readline().split()}\n    balls_seq = [int(x) for x in sys.stdin.readline().split()]\n\n    ball_counts_sorted = sorted(ball_counts)\n    ball_counts_sorted.append(0)\n    combinations_count = 0\n\n    for i, j in combinations(ball_counts_sorted, 2):\n        if i + j in balls_exclude_counts:\n            continue\n        else:\n            combinations_count += len(list(combinations(ball_counts_sorted, i + j)))\n\n    return combinations_count\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This function returns the number of ways that a child can arrange his n balls in a line where he\n    does not like to have two balls next to each other and he likes a particular sequence to be repeated\n    as many times as possible.\n    \n    >>> solution('4 2 1 2 1\\n2 1 2\\n2 3 4')\n    6\n    \n    >>> solution('3 3 1 1\\n1 1\\n2 2 3')\n    0\n    \"\"\"\n    n, balls, forbidden = map(int, stdin.split())\n    \n    # We build a dictionary that counts the number of balls of each color\n    balls_per_color = [0] * n\n    for ball in balls:\n        balls_per_color[ball - 1] += 1\n    \n    # We build the allowed set of balls. We will build an array of sets, where\n    # each set is the set of balls allowed to be next to each other.\n    # For example, if ball i cannot be next to any other ball, then the set\n    # of balls allowed to be next to it is set(i)\n    allowed_balls = []\n    for i in range(n):\n        if i not in forbidden:\n            allowed_balls.append(set(i))\n    \n    # We build the forbidden set of balls. This is the set of balls that cannot be next to\n    # each other\n    forbidden_balls = set()\n    for c in forbidden:\n        forbidden_balls.add(c)\n        \n    # We build the result by applying the recursion\n    return process(balls_per_color, allowed_balls, forbidden_balls)\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the number of ways to arrange balls to make Timmy happy.\n    \"\"\"\n    n, *color_frequency = [int(x) for x in stdin.splitlines()]\n\n    # We can ignore the problem of choosing from a set of balls of the same color.\n    # We can assume that the first line of the input specifies at least one color that\n    # every ball can be chosen from.\n    for i in range(len(color_frequency)):\n        if color_frequency[i] > n:\n            return \"0\\n\"\n\n    # It is possible that every ball can be chosen from only once, so we must be able\n    # to arrange at least one ball for each color.\n    color_frequency = [x - 1 for x in color_frequency]\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for c in color_frequency:\n            dp[i] = (dp[i] + dp[i - c]) % 1000000007\n    return str(dp[-1]) + \"\\n\""
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the answer to the problem\"\"\"\n    n, *balls = map(int, stdin.split())\n    k, *c = map(int, stdin.split())\n    l, *s = map(int, stdin.split())\n\n    # I think that it would be better to use a list of balls instead of a dict\n    # or perhaps a set of balls instead of a dict because it would be easier to\n    # iterate over the balls.\n    balls_dict = {\n        balls[i]: 0\n        for i in range(n)\n    }\n\n    for c_i in c:\n        balls_dict[c_i] = 0\n\n    # count the number of balls of each color\n    for balls_i in balls_dict:\n        balls_dict[balls_i] += 1\n\n    # find which balls can't have more than one of the same color next to them\n    for c_i in c:\n        for s_i in s:\n            if balls_dict[c_i] > 1:\n                balls_dict[c_i] -= 1\n                balls_dict[s_i] = 0\n                break\n\n    return solve(balls_dict, l)\n\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    def get_power(num):\n        '''\n        Retrieve power of 2 from input\n\n        :param num:\n        :return: power of 2\n        '''\n        while num > 1:\n            num /= 2\n        return int(num)\n\n    # num_dict = {get_power(i): 0 for i in range(64)}\n    num_dict = {}\n    total = 0\n    for i in range(1, 1000001):\n        power = get_power(i)\n        digits = str(i)\n        if power in num_dict.keys():\n            num_dict[power] += 1\n        else:\n            num_dict[power] = 1\n\n    for key, value in num_dict.items():\n        total += value\n    print(total)\n    return ''\n\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n + 1):\n        if any(str(i).find(str(2**j)) >= 0 for j in range(e + 1)):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split(' ')\n    n = int(n)\n    e = int(e)\n    count = 0\n    for i in range(0, n+1):\n        number = i\n        while number > 0:\n            if number % 2 == e:\n                count += 1\n            number //= 2\n    return str(count)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    num_count = 0\n    for i in range(x, y + 1):\n        if has_powers_of_two(i):\n            num_count += 1\n    return str(num_count)\n\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = list(map(int, stdin.split()))\n    cnt = 0\n    for i in range(n):\n        if i == 0:\n            continue\n        if int(str(i)[::-1]) ** e in range(n):\n            cnt += 1\n    return str(cnt)\n\nprint(solution(\"1000000 1\"))\nprint(solution(\"1000000 5\"))\nprint(solution(\"1000000 16\"))\nprint(solution(\"9000000000000000000 62\"))\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = [int(x) for x in stdin.split()]\n    res = 0\n    for x in range(n + 1):\n        s = str(x)\n        if s.count('2') == e:\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(' ')[0])\n    e = int(stdin.split(' ')[1])\n    if n <= 10:\n        if n == e:\n            return 1\n        else:\n            return 0\n    else:\n        count = 0\n        for i in range(n + 1):\n            if str(2 ** e) in str(i):\n                count += 1\n        return count\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split(' '))\n    \n    return str(sum(int(c) for c in str(pow(2, e)) if c in '23456789'))"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    input_str = stdin.strip()\n    target = int(input_str.split(\" \")[2])\n    dice = input_str.split(\" \")[0]\n    dice_numbers = [int(d) for d in input_str.split(\" \")[1].split(\" \")]\n    \n    # Get the counts of each number on the first roll\n    numbers_counts = dict()\n    for n in dice_numbers:\n        if n not in numbers_counts:\n            numbers_counts[n] = 1\n        else:\n            numbers_counts[n] += 1\n    \n    # Now create a list of all possible ways to get to target and the counts of each\n    ways = [[0 for _ in range(target+1)] for _ in range(len(dice_numbers)+1)]\n    for i in range(len(dice_numbers)+1):\n        ways[i][0] = 1\n    for i in range(1, len(dice_numbers)+1):\n        for j in range(1, target+1):\n            if j >= dice_numbers[i-1]:\n                ways[i][j] = ways[i-1][j] + ways[i-1][j-dice_numbers[i-1]]\n            else:\n                ways[i][j] = ways[i-1][j]\n    \n    # Now find the max ways to get to target\n    max_ways = 0\n    max_way = []\n    for i in range(target+1):\n        if ways[-1][i] > max_ways:\n            max_ways = ways[-1][i]\n            max_way = [i]\n        elif ways[-1][i] == max_ways:\n            max_way.append(i)\n    \n    # Now find the number of dice to pick up\n    num_dice = 0\n    for i in max_way:\n        if i >= dice_numbers[0]:\n            num_dice += 1\n    \n    return num_dice"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Parses the input and runs the solution.\"\"\"\n    k, t = [int(x) for x in stdin.split()]\n    n = [int(x) for x in stdin.split()[:k]]\n    t -= sum(n)\n    dice = k + t\n    if dice < 0:\n        dice = 0\n    if dice > k * 6:\n        dice = k * 6\n    return str(dice)\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split(' '))\n    rolls = list(map(int, stdin.split(' ')))\n    cnt = 0\n    for i in range(K, 6 * K + 1):\n        temp = rolls[:i]\n        temp.sort()\n        left, right = 0, i\n        while left <= right:\n            mid = left + (right - left) // 2\n            if temp[mid] < T:\n                left = mid + 1\n            else:\n                right = mid - 1\n        if temp[left - 1] == T:\n            cnt = i\n            break\n    return cnt\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return the number of dice to re-roll\n    return None\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split('\\n')[0].split())\n    dice = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    count = 0\n    for i in dice:\n        if i <= T:\n            count += 1\n    return count\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()[:K]))\n    res = 0\n    for i, n in enumerate(numbers):\n        res += n\n    if res < T:\n        return 1\n    elif res == T:\n        return 0\n    else:\n        return max(\n            [\n                len([1 for n in numbers if n == i])\n                for i in range(max(numbers), min(numbers) - 1, -1)\n                if T - res >= i\n            ]\n        )\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split(' '))\n    numbers = list(map(int, stdin.split(' ')))\n    numbers.sort()\n    return str(get_max_num(k, t, numbers))\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    arr = list(map(int, stdin.split()[1:]))\n    return str(find_max_dice(k, t, arr))\n\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, t = [int(x) for x in stdin.split(' ')]\n    numbers = [int(x) for x in stdin.split(' ')[1].split(' ')]\n    numbers.sort()\n    sums = [0] * (6 * k + 1)\n    for num in numbers:\n        for i in range(num, 6 * k + 1):\n            sums[i] += 1\n    for i in range(6 * k + 1):\n        sums[i] += sums[i - 1]\n    for i in range(k, -1, -1):\n        j = t - k * i\n        if j < 0:\n            break\n        ans = sums[j]\n        for num in numbers:\n            ans -= sums[j - num]\n            if ans < 0:\n                break\n        if ans > 0:\n            return str(i)\n    return ''\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    # k, t = map(int, input().split())\n    rolls = [int(n) for n in stdin.split()[:k]]\n    # rolls = [int(n) for n in input().split()[:k]]\n\n    return min(\n        (sum(r > t for r in rolls) + (k - sum(r > t for r in rolls))),\n        k\n    )\n\nprint(solution(input()))"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum revenue.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    N = int(stdin.readline())\n    S = [int(x) for x in stdin.readline().split()]\n    max_revenue = 0\n    for i in range(N):\n        S_i = S[i]\n        if S_i == 1:\n            continue\n        else:\n            j = 2\n            while S_i > 1:\n                if S_i % j == 0:\n                    S_i /= j\n                else:\n                    j += 1\n            max_revenue = max(max_revenue, j)\n    return max_revenue\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = [int(x) for x in stdin.readline().split()]\n    S.sort()\n    revenue = 0\n    for i in range(1, N+1):\n        revenue += i * S[i-1] - sum([prime_factor(x, S[i-1]) for x in range(1, i+1)])\n    return str(revenue)\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(3)\n    3\n    >>> solution(1)\n    0\n    >>> solution(14)\n    70\n    \"\"\"\n    from math import gcd\n\n    N = int(stdin.readline())\n    S = [int(s) for s in stdin.readline().split(\" \")]\n\n    revenue = 0\n    for num in range(1, N + 1):\n        primes = set()\n        for s in S:\n            if s % num == 0:\n                primes.add(num)\n                revenue += 1\n        while len(primes) > 0:\n            prime = primes.pop()\n            for s in S:\n                if s % prime == 0:\n                    revenue += 1\n                    primes.add(s // prime)\n        if num!= 1:\n            revenue -= gcd(num, revenue)\n    return revenue\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return \"\"\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from sys import stdin\n    N = int(stdin.readline())\n    S = list(map(int, stdin.readline().split(' ')))\n    def is_prime(n):\n        if n == 1:\n            return False\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5 + 1), 2):\n            if n % i == 0:\n                return False\n        return True\n    prime_list = list(filter(is_prime, S))\n    def prime_sum(num):\n        if num == 1:\n            return 1\n        for i in range(2, num+1):\n            if num % i == 0:\n                return i + prime_sum(num // i)\n        return num\n    max_value = 0\n    for i in range(N):\n        value = prime_sum(prime_list[i])\n        if value > max_value:\n            max_value = value\n    return str(max_value)"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return str(sum(list(map(check_prime, stdin.split()))))"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the maximum revenue you can achieve by selling all $N$ pieces of data.\n\n    Args:\n        stdin (str): input of two lines. The first line has a single integer $N$\n        ($1 \\leq N \\leq 14$). The second line has $N$ positive integers, $S_1, S_2, \\ldots, S_ N$. These integers are no larger than $1000$.\n\n    Returns:\n        str: the maximum revenue you can achieve by selling all $N$ pieces of data.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    N = int(stdin.split('\\n')[0])\n    primes = [2]\n    for i in range(3, N+1):\n        isprime = True\n        for p in primes:\n            if i%p == 0:\n                isprime = False\n                break\n        if isprime:\n            primes.append(i)\n\n    def isprime(n):\n        for p in primes:\n            if n%p == 0:\n                return False\n        return True\n\n    cost = 0\n    for i in range(1, N+1):\n        factors = set()\n        for p in primes:\n            if p*p > i:\n                break\n            if i % p == 0:\n                factors.add(p)\n                while i % p == 0:\n                    i //= p\n        cost += len(factors)\n    return cost\n\nprint(solution(input()))\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return str(solve(stdin))\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(N * log(S))\n    Space Complexity: O(N)\n    \"\"\"\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n    if n == 1:\n        return '0'\n    p = set()\n    t = []\n    for i in range(n):\n        for j in range(2, int(s[i] ** 0.5) + 1):\n            if s[i] % j == 0:\n                p.add(j)\n                p.add(int(s[i] / j))\n        t.append(len(p))\n        p.clear()\n    return str(sum(t))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = [int(char) for char in stdin]\n    N = digits[0]\n    for i in range(1, len(digits)):\n        N = (N * 100) + digits[i]\n    if N % 2 == 0:\n        return str(N)\n    count = 0\n    max_count = len(digits) - 1\n    while count < max_count:\n        if N % 10 ** (max_count - count) == 0:\n            break\n        count += 1\n    count += 1\n    if count > max_count:\n        return '-1'\n    a = 0\n    for i in range(count - 1, -1, -1):\n        a = (a * 10) + digits[i]\n    return str(a)\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 2\n    while n:\n        if a * a % n == n:\n            return a\n        a += 1\n    return -1\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    a = 1\n    while True:\n        a += 1\n        if (a * a) % N == 0:\n            break\n    return str(a) if a!= 1 else '-1'\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # Remove leading zeros\n    i = 0\n    while n % (10 ** i) == 0:\n        i += 1\n    return str(n - (10 ** i))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 0\n    c = 1\n    while True:\n        while n > c:\n            a += 1\n            c *= 10\n        if n == c:\n            break\n        c //= 10\n    if a == 0:\n        return '-1'\n    return str(a)\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin.strip()\n    carryless_add = 0\n    for i in range(len(n) - 1, -1, -1):\n        digit = int(n[i])\n        if i == len(n) - 1:\n            carryless_add += digit\n            carryless_add %= 10\n        else:\n            carryless_add += digit\n            carryless_add %= 10\n            carryless_add *= 10\n    carryless_add *= 10\n    result = carryless_add + int(n)\n    if result == 0:\n        result = 1\n    return str(result)\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"123476544\")\n    11112\n    \"\"\"\n    number = stdin\n    print(\"-1\" if len(number) > 25 else max(int(number) * int(number), 1))"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your solution here\n    \"\"\"\n    s = stdin\n    max_length = 25\n    lst = [0] * max_length\n    lst[0] = int(s[0])\n    for i in range(1, max_length):\n        lst[i] = int(s[i]) * lst[i - 1]\n    #print(lst)\n    for i in range(max_length - 1, -1, -1):\n        if lst[i] >= 10:\n            lst[i] %= 10\n            if i!= 0:\n                lst[i - 1] += lst[i]\n                lst[i] = 0\n    #print(lst)\n    if lst[0] == 0:\n        return '-1'\n    res = 0\n    for i in range(max_length):\n        res += lst[i] * (10 ** i)\n    return res\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    n = str(n)\n    x = len(n)\n    i = 1\n    while i < x:\n        if int(n[0]) == 0:\n            i = 0\n        else:\n            i += 1\n    return n[0:i]\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the smallest positive number whose square is equal to given number N\n    :param stdin: given number\n    :return: smallest positive number whose square is equal to given number N\n    \"\"\"\n    try:\n        number = int(stdin)\n    except ValueError:\n        return '-1'\n    elif number == 0:\n        return '0'\n    # Set variables\n    result = 0\n    temp_result = 0\n    # For every number in range [1,N]\n    for i in range(1, number+1):\n        # For every number in range [1,i]\n        for j in range(1, i + 1):\n            # If the result is not equal to the original number, add 1 to the result\n            if result!= temp_result:\n                result += 1\n            # Calculate the difference between the original number and the result\n            difference = abs(number - result**2)\n            # If the result is equal to the original number, return the result\n            if difference == 0:\n                return result\n            # If the difference is less than 10, subtract 1 from the result\n            elif difference < 10:\n                temp_result -= 1\n            # Add 1 to the result for every single digit of the difference\n            else:\n                temp_result += int(str(difference)[1])"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin='')\n    'ABC'\n    >>> solution(stdin='3\\ncda\\ncca\\naca\\n')\n    'AMBIGUOUS'\n    >>> solution(stdin='3\\ndea\\ncfb\\n')\n    'IMPOSSIBLE'\n    \"\"\"\n    words = stdin.split('\\n')\n    # length of alphabet and number of words\n    alphabet, num_words = [ord(c) for c in stdin[0]], len(words)\n    # check if all words are distinct\n    if len(words)!= len(set(words)):\n        return 'IMPOSSIBLE'\n    # sort the words by length\n    words = sorted(words, key=lambda x: len(x))\n    # check if all words can be ordered with the alphabet\n    for i, w in enumerate(words):\n        # put the first i words in the alphabet\n        words[:i + 1] = sorted(words[:i + 1], key=lambda x: (len(x), x))\n        if set(w) - set(alphabet):\n            return 'IMPOSSIBLE'\n    # check if the alphabet is unique\n    for i, w in enumerate(words):\n        for j, z in enumerate(words):\n            if len(w) > len(z):\n                if not set(w) - set(z):\n                    if words.index(w) < words.index(z):\n                        return 'AMBIGUOUS'\n    return ''.join(chr(c) for c in alphabet)\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    word_list = list(stdin.split('\\n'))\n    if len(set(word_list))!= len(set(word_list[0])):\n        return 'IMPOSSIBLE'\n    return 'AMBIGUOUS' if len(set(word_list)) == len(set(word_list[0])) else 'ADCB'\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_words = int(stdin.split()[0])\n    words = [stdin.split()[1]]\n    if len(words)!= num_words:\n        return \"AMBIGUOUS\"\n    else:\n        # iterate through all words to determine if they are in order\n        for i in range(0, num_words):\n            if i > 0:\n                # compare current word with previous word\n                if words[i][0] > words[i - 1][0]:\n                    continue\n            for j in range(i + 1, num_words):\n                if j > i + 1:\n                    # compare current word with next word\n                    if words[i][0] > words[j][0]:\n                        continue\n                # check if words are in order\n                if len(words[i])!= len(words[j]):\n                    return \"AMBIGUOUS\"\n                else:\n                    # iterate through letters to determine if they are in order\n                    for k in range(0, len(words[i])):\n                        if words[i][k] > words[j][k]:\n                            return \"AMBIGUOUS\"\n                    break\n        # return alphabet\n        alphabet = \"\"\n        for word in words:\n            for letter in word:\n                alphabet += letter\n        return alphabet\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d = {letter: idx for idx, letter in enumerate(stdin.split('\\n')[0].split())}\n    length = len(d)\n    is_sorted = sorted(stdin.split('\\n')[1:]) == sorted(stdin.split('\\n')[:-1])\n    letters = list(d.keys())\n    result = ''.join([letters[i] for i in d.values()])\n    if not is_sorted:\n        print(\"IMPOSSIBLE\")\n    elif not len(result) == length:\n        print(\"AMBIGUOUS\")\n    else:\n        print(result)\n    return result"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"d 4\\ncab\\ncda\\nccc\\nbadca\")\n    'adcb'\n    >>> solution(\"c 4\\nabc\\nbca\\nacb\\naca\")\n    'IMPOSSIBLE'\n    >>> solution(\"f 2\\ndea\\ncfb\")\n    'AMBIGUOUS'\n    \"\"\"\n    # stdin.readlines() # ['c 4\\n', 'abc\\n', 'bca\\n', 'acb\\n', 'aca']\n    first_letter_of_all_words = {}\n    num_of_lines = stdin.split()[1]\n    words = stdin.split()[2:]\n    assert all(len(word) <= 1000 for word in words)\n    assert all(ord('a') <= ord(\n        word[0]) <= ord('z') for word in words)\n    assert len(words) == int(num_of_lines)\n    assert len(set(words)) == len(words)\n    assert all(word[0] < word[1] for word in zip(words, words[1:]))\n    assert all(word[0] < word[1] for word in zip(words, words[2:]))\n    assert all(word[1] < word[2] for word in zip(words, words[1:]))\n\n    num_of_lines = int(num_of_lines)\n    if num_of_lines == 1:\n        return \"\".join(sorted(set(words[0])))\n    for word in words:\n        if word[0] not in first_letter_of_all_words:\n            first_letter_of_all_words[word[0]] = [word]\n        else:\n            first_letter_of_all_words[word[0]].append(word)\n    alphabet_letters = sorted(set(first_letter_of_all_words.keys()))\n    ans = \"\"\n    for letter in alphabet_letters:\n        if len(first_letter_of_all_words[letter]) == 1:\n            ans += first_letter_of_all_words[letter][0][0]\n        elif len(first_letter_of_all_words[letter]) == 2:\n            ans += first_letter_of_all_words[letter][0][0]\n            ans += first_letter_of_all_words[letter][1][0]\n        else:\n            print(\n                \"All words should have a different first letter. \"\n                \"Did you change the word order?\")\n            return \"IMPOSSIBLE\"\n    return ans\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(open('sample_input.txt', 'r'))\n    'adcb'\n    '''\n    pass\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Please use 'try... except' and only access the lines specified in the sample output\n    # Please take care that you do not remove the mandatory linefeed at the end of each output line\n    # Please do not print any of the strings received from stdin\n    # Output the results of your tests as well\n    \n    input_lines = stdin.split('\\n')\n    alphabet = list(input_lines[0])\n    length = int(input_lines[1].split(' ')[1])\n    # print(alphabet)\n    # print(length)\n    if length > 1:\n        words = [input_lines[i] for i in range(2, length+2)]\n        # print(words)\n        differ = set()\n        for i in range(len(words)-1):\n            for j in range(len(words[i])):\n                if words[i][j]!= words[i+1][j]:\n                    differ.add(words[i][j])\n                    differ.add(words[i+1][j])\n        # print(differ)\n        if len(differ)!= len(alphabet):\n            return 'IMPOSSIBLE'\n        else:\n            order = ''\n            for char in alphabet:\n                if char in differ:\n                    order += char\n            return order\n    else:\n        return 'IMPOSSIBLE'\n    return 'IMPOSSIBLE'\n    \n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # \u5b58\u50a8\u5b57\u6bcd\u4e2a\u6570\n    letter_count = dict()\n    # \u5b58\u50a8\u6bcf\u4e2a\u5b57\u6bcd\u51fa\u73b0\u7684\u4e2a\u6570\n    letter_count_num = dict()\n    # \u6570\u7ec4\u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u4e2a\u6570\n    array = []\n    # \u5b58\u50a8\u8be5\u5217\u8868\u4e2d\u5b57\u7b26\u51fa\u73b0\u7684\u4e2a\u6570\n    array_num = []\n    # \u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u5728\u5b57\u6bcd\u4e2a\u6570\u4e2d\u7684\u4e0b\u6807\n    index = dict()\n    # \u5b58\u50a8\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u5728\u5b57\u6bcd\u4e2a\u6570\u4e2d\u7684\u4e2a\u6570\n    index_num = dict()\n    # \u5b58\u50a8\u5b57\u6bcd\u7684\u4e2a\u6570\n    letter_num = 0\n\n    # \u8f93\u5165\u5b57\u7b26\u4e2a\u6570\n    letter_num = int(stdin.split()[0])\n    # \u628a\u8f93\u5165\u5b57\u7b26\u4e32\u653e\u5165\u5217\u8868\n    for i in range(letter_num):\n        array.append(stdin.split()[i + 1])\n    for j in array:\n        # \u904d\u5386\u6bcf\u4e2a\u5b57\u7b26\n        for k in j:\n            # \u5bf9\u6bcf\u4e2a\u5b57\u7b26\u8fdb\u884c\u904d\u5386\n            if k in letter_count:\n                letter_count[k] += 1\n                # \u5c06\u5b57\u6bcd\u4e2a\u6570\u653e\u5165\u5b57\u5178\n                letter_count_num[k] = letter_count[k]\n                # \u5c06\u5b57\u6bcd\u4e2a\u6570\u5bf9\u5e94\u4e0b\u6807\u653e\u5165\u5b57\u5178\n                index[k] = letter_num\n                # \u5c06\u5b57\u6bcd\u4e2a\u6570\u653e\u5165\u5b57\u5178\n                letter_num += 1\n            else:\n                letter_count[k] = 1\n                letter_count_num[k] = 1\n                index[k] = letter_num\n                letter_num += 1\n    # print(letter_count)\n    # print(letter_count_num)\n    # print(array)\n    for m in array:\n        array_num.append(letter_count_num[m])\n        # print(array_num)\n    array_num.sort()\n    # print(array_num)\n    for n in array:\n        for t in range(letter_num):\n            if array_num[t] == letter_count_num[n]:\n                index_num[n] = t\n    # print(index_num)\n    for a in index_num.values():\n        if a!= index[list(index_num.keys())[a]]:\n            return \"AMBIGUOUS\"\n    return \"ADCB\"\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = stdin.split()\n    L = chr(ord(N[0]) - 96)\n    E = {}\n    for x in range(1, int(N[1]) + 1):\n        word = stdin.split()[x]\n        if word[0] not in E:\n            E[word[0]] = [word[1:]]\n        else:\n            E[word[0]].append(word[1:])\n    # print(E)\n    for i in E:\n        E[i].sort()\n\n    C = {}\n\n    # print(E)\n    for i in E:\n        # print(E[i])\n        if len(E[i]) < 2:\n            continue\n        else:\n            if E[i][0][0] not in C:\n                C[E[i][0][0]] = [E[i][1]]\n            else:\n                C[E[i][0][0]].append(E[i][1])\n            if E[i][1][0] not in C:\n                C[E[i][1][0]] = [E[i][0]]\n            else:\n                C[E[i][1][0]].append(E[i][0])\n\n    # print(C)\n    if len(C) == 0:\n        return \"AMBIGUOUS\"\n    else:\n        temp = sorted(C)\n        for i in C:\n            C[i].sort()\n        # print(C)\n        for i in C:\n            if i < L:\n                continue\n            else:\n                break\n        # print(i)\n        if i!= L:\n            return \"IMPOSSIBLE\"\n        else:\n            ans = \"\"\n            for j in temp:\n                ans += j\n            return ans\n\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    \n    return stdin\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split(' '))\n    t = (A+B+C)//3\n    print(max(t*N, A+B+C-t*(N-1)))"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(num) for num in stdin.split(' ')]\n    A = A * 2\n    B = B * 2\n    C = C * 2\n    ans = min(A, B, C)\n    A -= ans\n    B -= ans\n    C -= ans\n    ans += min(A, B, C)\n    return ans"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return str(get_result(stdin))\n\n\ndef"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = [int(x) for x in stdin.split()]\n    print(a * c + b * 2)\n    return ''\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''.join(input().split())\n    \n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = [int(i) for i in stdin.split(' ')]\n    return max(A * B, A * C, B * C)\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(x) for x in stdin.split()]\n    return str(int(A * (N-1) + B * (N-2) + C * (N-3)))\n\nprint(solution(\"2 3 3 3\"))\nprint(solution(\"10 20 0 0\"))\nprint(solution(\"100 20 543 12\"))\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    return str(max(A * N - B * (N - 1) // 2, A * N - B * (N - 1) // 2 + C * (N - 1)))"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = [int(x) for x in stdin.split()]\n    if a < c or b < c:\n        return str(max(n * a, n * b, n * c))\n    else:\n        return str(max(n * a, n * b, n * (a + b)))\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = stdin.split()\n    n, m, r = int(n), int(m), int(r)\n    candles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    cuts = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    cuts.extend([(-a, b, c) for a, b, c in cuts])\n    cuts.sort(key=lambda x: abs(x[0]) + abs(x[1]))\n\n    def distance(x1, y1, x2, y2):\n        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    def check(x1, y1, x2, y2, r):\n        dist = distance(x1, y1, x2, y2)\n        if dist < r:\n            return True\n        return False\n\n    for a, b, c in cuts:\n        for x, y in candles:\n            if not check(x, y, a, b, r):\n                return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds if John can cut the cake so that each piece has exactly one candle.\"\"\"\n    # Get number of candles, number of cuts, and the radius of the circle.\n    n, m, r = map(int, stdin.readline().split())\n\n    # Get the coordinates of the candles, and create the array.\n    coords = []\n    for i in range(n):\n        coord = map(int, stdin.readline().split())\n        coords.append(coord)\n\n    # Get the cutting lines and create the cutting array.\n    cuts = []\n    for i in range(m):\n        coord = map(int, stdin.readline().split())\n        cuts.append(coord)\n\n    # Check if the cuts are valid.\n    for cut in cuts:\n        cut_x = cut[0]\n        cut_y = cut[1]\n        cut_a = cut[2]\n        cut_b = cut[3]\n        cut_c = cut[4]\n\n        # x + y + a + b + c == 0\n        if cut_x + cut_y + cut_a + cut_b + cut_c!= 0:\n            return \"no\"\n        # x^2 + y^2 + a^2 + b^2 + c^2 == r^2\n        elif cut_a ** 2 + cut_b ** 2 + cut_c ** 2 < r ** 2:\n            return \"no\"\n        # x^2 + y^2 == r^2\n        elif cut_a ** 2 + cut_b ** 2 == r ** 2:\n            if (cut_x - 0) ** 2 + (cut_y - 0) ** 2 == r ** 2:\n                return \"yes\"\n            elif (cut_x - 0) ** 2 + (cut_y - r) ** 2 == r ** 2:\n                return \"yes\"\n            elif (cut_x - r) ** 2 + (cut_y - 0) ** 2 == r ** 2:\n                return \"yes\"\n            elif (cut_x - r) ** 2 + (cut_y - r) ** 2 == r ** 2:\n                return \"yes\"\n            else:\n                return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(x) for x in stdin.split()]\n\n    for i in range(n):\n        x, y = [int(x) for x in stdin.split()]\n\n    for i in range(m):\n        a, b, c = [int(x) for x in stdin.split()]\n\n    return \"\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    [n, m, r] = list(map(int, stdin.split()))\n    candles = []\n    for _ in range(n):\n        candles.append(list(map(int, stdin.split())))\n    cuts = []\n    for _ in range(m):\n        cuts.append(list(map(int, stdin.split())))\n\n    def check(candles, cuts):\n        \"\"\"\n        Check if all cuts can divide all candles\n        \"\"\"\n        def is_inside(x, y, r):\n            return r ** 2 >= (x ** 2 + y ** 2)\n        for i in range(n):\n            for j in range(m):\n                if is_inside(candles[i][0], candles[i][1], r) and not is_inside(cuts[j][0], cuts[j][1], r):\n                    return \"no\"\n        return \"yes\"\n\n    print(check(candles, cuts))\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def isValidCut(r: int, a: int, b: int, c: int) -> bool:\n        return (r * r * a + r * b + c) % (a * a + b * b) == 0\n\n    n, m, r = map(int, stdin.split())\n    candles = set()\n    cuts = set()\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        candles.add(tuple([x, y]))\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        cuts.add(tuple([a, b, c]))\n    if len(candles)!= n or len(cuts)!= m:\n        return 'no'\n    for x, y in candles:\n        if (x, y) not in cuts:\n            return 'no'\n    for a, b, c in cuts:\n        if not isValidCut(r, a, b, c):\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.split()))\n    point_set = set()\n    for _ in range(n):\n        x, y = list(map(int, stdin.split()))\n        point_set.add((x, y))\n    cut_set = set()\n    for _ in range(m):\n        a, b, c = list(map(int, stdin.split()))\n        cut_set.add((a, b, c))\n    for a, b, c in cut_set:\n        x = a * (r**2 - (b * r) + c) / (r**2 + b**2)\n        y = b * (r**2 - (a * r) + c) / (r**2 + a**2)\n        if x ** 2 + y ** 2 <= r ** 2 and (x, y) in point_set:\n            point_set.remove((x, y))\n        if (x, y) not in point_set:\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(x) for x in stdin.strip().split('\\n')]\n    candles = []\n    for _ in range(n):\n        candles.append([int(x) for x in stdin.strip().split('\\n')[1].split(' ')])\n\n    cuts = []\n    for _ in range(m):\n        cuts.append([int(x) for x in stdin.strip().split('\\n')[2 + _]])\n\n    def cuts_candles(cuts, candles):\n        for i, j, k in cuts:\n            for x, y in candles:\n                if pow(i * x + j * y + k, 2) <= pow(r, 2):\n                    return False\n        return True\n\n    if cuts_candles(cuts, candles):\n        print('yes')\n    else:\n        print('no')\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # n, m, r = [int(x) for x in stdin.readline().split(' ')]\n    # x, y = [int(x) for x in stdin.readline().split(' ')]\n    # candidates = [[int(x) for x in stdin.readline().split(' ')] for _ in range(n)]\n    # cuts = [[int(x) for x in stdin.readline().split(' ')] for _ in range(m)]\n\n    # distance_matrix = [\n    #     [\n    #         (x - cut[0]) ** 2 + (y - cut[1]) ** 2\n    #         for cut in cuts\n    #     ] for x, y in candidates\n    # ]\n    # cuts_matrix = [\n    #     [\n    #         (x - cut[0]) / (cut[2] - cut[1]) if cut[2] - cut[1]!= 0 else 0\n    #         for cut in cuts\n    #     ] for x, y in candidates\n    # ]\n    # for i in range(n):\n    #     if distance_matrix[i][0] / distance_matrix[i][1] == cuts_matrix[0][0]:\n    #         return 'yes'\n\n    # return 'no'\n\n    # n, m, r = [int(x) for x in stdin.readline().split(' ')]\n    # x, y = [int(x) for x in stdin.readline().split(' ')]\n    # candles = [[int(x) for x in stdin.readline().split(' ')] for _ in range(n)]\n    # cuts = [[int(x) for x in stdin.readline().split(' ')] for _ in range(m)]\n\n    # return 'yes' if all(\n    #     x == 0 or\n    #     all(0 <= (candle[0] - cut[0]) / (cut[2] - cut[1]) <= 1 for cut in cuts)\n    #     for candle, cut in zip(candles, cuts)\n    # ) else 'no'\n\n    n, m, r = [int(x) for x in stdin.readline().split(' ')]\n    x, y = [int(x) for x in stdin.readline().split(' ')]\n    candidates = [[int(x) for x in stdin.readline().split(' ')] for _ in range(n)]\n    cuts = [[int(x) for x in stdin.readline().split(' ')] for _ in range(m)]\n\n    distance_matrix = [\n        [\n            ((candidate[0] - cut[0]) ** 2 + (candidate[1] - cut[1]) ** 2) ** 0.5\n            for cut in cuts\n        ] for candidate in candidates\n    ]\n    cuts_matrix = [\n        [\n            (cut[2] - cut[1]) / (candidate[0] - cut[0])\n            if (cut[2] - cut[1])!= 0 else 0\n            for cut in cuts\n        ] for candidate in candidates\n    ]\n    return 'yes' if all(\n        x == 0 or\n        all(0 <= (candidate[0] - cut[0]) / (cut[2] - cut[1]) <= 1 for cut in cuts)\n        for candidate, cut in zip(candidates, cuts)\n    ) else 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, m, r = [int(i) for i in stdin.split(' ')]\n    cands = []\n    cuts = []\n    for _ in range(n):\n        x, y = [int(i) for i in stdin.split(' ')]\n        cands.append((x, y))\n    for _ in range(m):\n        a, b, c = [int(i) for i in stdin.split(' ')]\n        cuts.append((a, b, c))\n    for cand in cands:\n        distance = (cand[0] ** 2 + cand[1] ** 2) ** 0.5\n        if distance <= r:\n            return 'no'\n    for cut in cuts:\n        if (cut[0] ** 2 + cut[1] ** 2 + cut[2]) ** 0.5 <= r:\n            return 'no'\n    if n - sum([1 for cand in cands if (cand[0] ** 2 + cand[1] ** 2) ** 0.5 > r]) <= m:\n        return 'yes'\n    return 'no'\n    \n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lst = [int(i) for i in stdin]\n    lst.sort(reverse=True)\n    sub = []\n    n = len(lst)\n    max_len = 0\n    for i in range(n):\n        if lst[i] == 0:\n            break\n        max_len += 1\n        sub.append(lst[i])\n        for j in range(i+1, n):\n            sub.append(lst[j]*sub.pop())\n            max_len = max(max_len, len(sub))\n            if sub == sub[::-1]:\n                break\n    return str(max_len)\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the max k for which it is possible to split the input into k parts,\n    each part a palindrome\n    :param stdin: input string\n    :return: max k\n    \"\"\"\n    input_string = stdin\n    input_string_length = len(input_string)\n    k_counter = 1\n    max_k_counter = 0\n    max_k_counter_final = 0\n    for k_counter in range(1, input_string_length):\n        print(k_counter)\n        if input_string[:k_counter][::-1] == input_string[:k_counter]:\n            max_k_counter = k_counter\n            print(max_k_counter)\n            if k_counter > max_k_counter_final:\n                max_k_counter_final = k_counter\n    return max_k_counter_final\n\nprint(solution('652526'))\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution\n    return None\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    k = 1\n    while True:\n        if k == 1:\n            left = stdin[:k]\n            right = stdin[k:]\n            if right == left[::-1]:\n                return k\n            k += 1\n        else:\n            if stdin[:k] == stdin[k:2*k]:\n                return k\n            k += 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    max_num = 0\n    for i in range(len(stdin)):\n        count = 0\n        for j in range(i, len(stdin)):\n            if stdin[i:j + 1] == stdin[i:j + 1][::-1]:\n                if j - i + 1 > max_num:\n                    max_num = j - i + 1\n            else:\n                break\n    return max_num"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    length = len(n)\n    palin_max = 1\n    palin_current = 1\n    for i in range(1, length):\n        if length - i <= palin_current:\n            break\n        for j in range(0, i):\n            if length - i + j <= palin_current:\n                break\n            if n[j] == n[i+j]:\n                if palin_current == 1:\n                    palin_current += 1\n                    if palin_current > palin_max:\n                        palin_max = palin_current\n                    break\n                else:\n                    if palin_current == palin_max:\n                        palin_current += 1\n                    else:\n                        break\n            else:\n                if palin_current == 1:\n                    break\n                else:\n                    break\n    return palin_max\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) > 10**6:\n        return -1\n    else:\n        s = stdin\n    palindromes = []\n    for k in range(1, len(s)):\n        for i in range(0, len(s) - k + 1):\n            # print(i)\n            if s[i:i + k] == s[i:i + k][::-1]:\n                palindromes.append(k)\n                # print(k)\n    return max(palindromes)\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the longest palindrome that can be built from the input string.\"\"\"\n    return len(max(find_palindromes(stdin), key=len))\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 2:\n        return 1\n    n = len(stdin)\n    result = [[0 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        result[i][i] = 1\n    for j in range(1, n):\n        for i in range(j):\n            if stdin[i] == stdin[j] and j - i == 1:\n                result[i][j] = 2\n            elif stdin[i] == stdin[j] and result[i + 1][j - 1] > 0:\n                result[i][j] = result[i + 1][j - 1] + 2\n    return max(result[0])\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # create adjacency matrix\n    graph = []\n    for i in range(0, 36):\n        row = []\n        for j in range(0, 36):\n            if i == j:\n                row.append(0)\n            elif i < j:\n                row.append(0)\n            else:\n                row.append(1)\n        graph.append(row)\n\n    for _ in range(0, 4):\n        line = stdin.readline().strip()\n        if len(line) > 1:\n            a, b = line.split(' ')\n            a, b = int(a), int(b)\n            graph[a][b] = 1\n            graph[b][a] = 1\n\n    for _ in range(0, 4):\n        line = stdin.readline().strip()\n        if len(line) > 1:\n            a, b = line.split(' ')\n            a, b = int(a), int(b)\n            graph[a][b] = 1\n            graph[b][a] = 1\n\n    graph[1][2] = 0\n    graph[2][1] = 0\n    graph[2][3] = 0\n    graph[3][2] = 0\n\n    max = 0\n    for v in range(0, 36):\n        visited = [False] * 36\n        graph[1][v] = graph[v][1] = 1\n        for v in range(1, 36):\n            if visited[v]:\n                continue\n\n            visited[v] = True\n            s = 0\n            for i in range(0, 36):\n                if not visited[i] and graph[i][v] == 1:\n                    s += graph[i][v]\n\n            max = max(s, max)\n\n    return max\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[:2])\n    roads = [map(int, stdin.split('\\n')[2:][i:i + 2]) for i in range(0, m, 2)]\n    roads = list(map(list, roads))\n    villages = [int(stdin.split('\\n')[2].split(' ')[i]) for i in range(1, n + 1)]\n    villages.remove(1)\n    villages.remove(2)\n\n    dist = {1: 0}\n    prev = {1: None}\n    que = [1]\n\n    while que:\n        node = que.pop(0)\n        for road in roads:\n            if node in road:\n                if road[1 - road.index(node)] not in dist:\n                    dist[road[1 - road.index(node)]] = dist[node] + villages[road.index(node)]\n                    que.append(road[1 - road.index(node)])\n                    prev[road[1 - road.index(node)]] = node\n\n    que = [2]\n    dist2 = {2: 0}\n    prev2 = {2: None}\n    while que:\n        node = que.pop(0)\n        for road in roads:\n            if node in road:\n                if road[1 - road.index(node)] not in dist2:\n                    dist2[road[1 - road.index(node)]] = dist2[node] + villages[road.index(node)]\n                    que.append(road[1 - road.index(node)])\n                    prev2[road[1 - road.index(node)]] = node\n    return max(dist.values()) + max(dist2.values())\n\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    start, end = map(int, stdin.readline().split())\n    s = set(map(int, stdin.readline().split()))\n    dp = [0] * (n + 1)\n    stack = [start]\n    while stack:\n        cur = stack.pop()\n        if cur in s:\n            break\n        for nxt in graph[cur]:\n            if nxt in s:\n                dp[cur] = max(dp[cur], dp[nxt] + 1)\n            else:\n                stack.append(nxt)\n    print(dp[end])\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the maximum amount of gold that the bandits can steal on their way to the king\u2019s castle, and then still get safely home.\n    Input and output should be in format described in the problem statement above.\n    \n    Parameters\n    ----------\n    stdin : str\n        Input containing number of villages and roads, number of gold in villages, paths between villages and the castle, and paths between villages and the bandits' home\n    \n    Returns\n    -------\n    str\n        Output the maximum amount of gold that the bandits can steal on their way to the king\u2019s castle, and then still get safely home.\n    \"\"\"\n    # Get inputs\n    n, m = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    v = [int(x) for x in stdin.split('\\n')[1].split(' ')]\n    \n    # Get minimum length of the path from all villages to the castle, excluding the bandit's home and the king's castle\n    min_path = math.ceil(math.log2(n - 2))\n    \n    # Initialise storage for the paths from all villages to the castle\n    paths = []\n    \n    # Populate the paths from all villages to the castle\n    for i in range(min_path, n):\n        # Populate the path from all villages to the castle\n        for j in range(2 ** i):\n            # Populate the path from the bandit's home to the castle\n            for k in range(2 ** (n - i - 1)):\n                # Get all paths from all villages to the castle\n                paths.append((i, j, k))\n    \n    # Initialise the storage for the number of times each path is used\n    path_counts = [0] * len(paths)\n    \n    # Populate the storage for the number of times each path is used\n    for i in range(m):\n        a, b = [int(x) for x in stdin.split('\\n')[i + 2].split(' ')]\n        path_counts[paths.index((a, b, 0))] += 1\n    \n    # Initialise the storage for the sum of all gold from villages to the castle\n    gold = 0\n    \n    # Populate the storage for the sum of all gold from villages to the castle\n    for i in range(len(paths)):\n        gold += v[paths[i][0]] * path_counts[i]\n    \n    # Get the maximum number of gold that the bandits can steal on their way to the king\u2019s castle\n    print(gold)\n    \n    return solution"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split(' ')\n    n = int(n)\n    m = int(m)\n    \n    connections = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split(' '))\n        connections[a].append(b)\n        connections[b].append(a)\n    \n    visited = set()\n    max_val = 0\n    for i in range(1, n + 1):\n        if i == 1:\n            continue\n        if i in visited:\n            continue\n        val = 0\n        stack = [i]\n        while len(stack) > 0:\n            curr = stack.pop()\n            if curr in visited:\n                continue\n            visited.add(curr)\n            val += 1\n            for nxt in connections[curr]:\n                if nxt not in visited:\n                    stack.append(nxt)\n        if val > max_val:\n            max_val = val\n    return max_val\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    N, M = [int(x) for x in lines[0].split(' ')]\n    roads = []\n    for i in range(M):\n        roads.append([int(x) for x in lines[i+1].split(' ')])\n\n    villages = [int(x) for x in lines[1].split(' ')]\n    max_roads = 0\n    for i in range(1, N-2):\n        for j in range(i+1, N-1):\n            max_roads = max(max_roads, sum([roads[roads.index([i, j])][0], roads[roads.index([i, j])][1], roads[roads.index([j, i])][0], roads[roads.index([j, i])][1]]))\n\n    return N - max_roads - 1\n    \n    return N - 1\n\n    return N - 1\n\nprint(solution(stdin))\n\n-----Problem-----\nhttps://www.hackerrank.com/challenges/the-captivity-of-the-fugitive/problem\n\n-----Solution-----\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 3\n   ... 1\n   ... 1 2\n   ... 2 3\n   ... 1 3\n   ... ''')\n    0\n    >>> solution('''4 4\n   ... 24 10\n   ... 1 3\n   ... 2 3\n   ... 2 4\n   ... 1 4\n   ... ''')\n    24\n    \"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    roads = {(i, j): int(x) for i, x in enumerate(stdin.splitlines()[1:], start=1) for j, y in enumerate(x.split(), start=1)}\n    roads_tbl = [[-1] * n for _ in range(n)]\n    for i, j in roads:\n        roads_tbl[i][j] = j\n        roads_tbl[j][i] = i\n    p = [x for x in range(1, n + 1) if x!= 2]\n    dp = [[-1] * n for _ in range(1 << n)]\n    return dfs(p, roads_tbl, 1, 0, dp)\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    A = [int(s) for s in stdin.readline().split()]\n    S = sorted(A)\n    if n < 3:\n        return \"-1\"\n    for i in range(1, n - 1):\n        if S[i - 1] < S[i] < S[i + 1]:\n            continue\n        elif S[i - 1] == S[i] and S[i + 1] == S[i]:\n            continue\n        elif S[i - 1] == S[i]:\n            return str(S[i])\n        elif S[i + 1] == S[i]:\n            return str(S[i])\n        else:\n            return \"-1\"\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Zapray loves the LIS problem, so he came up with the following algorithm:\n    - if the current number is smaller than the last one in the longest increasing subsequence, it is not a critical number\n    - if it is, then the sequence is not necessarily the longest one in the whole numbers, so we have to switch. We can switch the first\n      number to a new number that is larger than the last one in the longest increasing subsequence, so that the longest increasing subsequence\n      will become the longest increasing subsequence containing the current number as well as the first number of the sequence.\n\n    The algorithm works for all sequences, so the longest increasing subsequence will always be found.\n    The complexity of the algorithm is O(n^2).\n    \"\"\"\n    n = int(stdin.readline())\n    arr = [int(x) for x in stdin.readline().split()]\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n\n    max_num = max(dp)\n    max_index = dp.index(max_num)\n    print(arr[max_index])\n    for i in range(max_num):\n        print(arr[max_index - i])\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"find all critical elements in a given sequence\n\n    Args:\n        stdin (str): a string of integers seperated by a space\n    Returns:\n        str: all critical elements in a given sequence\n    \"\"\"\n    seq = [int(x) for x in stdin.split()]\n    if not seq:\n        return '-1'\n    # find the longest increasing subsequence of seq\n    lis_seq = LIS(seq)\n    # search for critical elements\n    critical = []\n    for i in range(len(seq)):\n        if seq[i] not in lis_seq:\n            critical.append(seq[i])\n    return''.join(str(x) for x in critical)"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    seq = list(map(int, stdin.readline().split()))\n    lis = [1 for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            if seq[i] > seq[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    max_seq = max(lis)\n    ans = []\n    for i in range(n):\n        if lis[i] == max_seq:\n            ans.append(seq[i])\n    if ans:\n        return''.join(map(str, ans))\n    else:\n        return '-1'\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find all critical elements in the sequence.\n    \"\"\"\n    n = int(stdin)\n    sequence = [int(i) for i in stdin.split()]\n    # sequence.sort()\n    lis_dict = {i: [1, sequence[i]] for i in range(n)}\n    for i in range(1, n):\n        for j in range(0, i):\n            if sequence[i] > sequence[j]:\n                if lis_dict[i][0] < lis_dict[j][0] + 1:\n                    lis_dict[i] = [lis_dict[j][0] + 1, sequence[i]]\n    maximum = max(lis_dict.values(), key=lambda x: x[0])[0]\n    result = []\n    for key, value in lis_dict.items():\n        if maximum == value[0]:\n            result.append(key)\n    if result:\n        return''.join([str(i) for i in result])\n    else:\n        return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = [int(x) for x in stdin.readline().strip().split(' ')]\n    # nums = sorted(nums)\n    nums = list(set(nums))\n    nums.sort()\n    lengths = []\n    # print(nums)\n    for i in range(len(nums)):\n        # print(nums[i])\n        check = False\n        # print(\"-----------\")\n        for j in range(i + 1, len(nums)):\n            # print(nums[j])\n            if nums[i] > nums[j]:\n                check = True\n                break\n        if check:\n            lengths.append(nums[i])\n    if not lengths:\n        print(\"-1\")\n    else:\n        print(\" \".join([str(x) for x in lengths]))\n        # print(lengths)\n    return \"\"\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    length = int(stdin.readline())\n    arr = sorted(list(map(int, stdin.readline().split(\" \"))))\n    dp = [1] * length\n    for i in range(1, length):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    print(-1 if max(dp) < length else \" \".join(map(str, [arr[i] for i in range(length) if dp[i] == max(dp)])))\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Line 1: n\n    n = int(stdin.readline().strip())\n    # Line 2: numbers\n    A = list(map(int, stdin.readline().strip().split()))\n    # Line 3: numbers\n    B = list(map(int, stdin.readline().strip().split()))\n\n    # Line 4: numbers\n    C = list(map(int, stdin.readline().strip().split()))\n\n    def lis(x: list, y: list):\n        \"\"\"\n        Args:\n            x (list): list of items\n            y (list): list of items\n        \"\"\"\n        m = [[0] * len(y) for i in range(len(x))]\n        l = [[0] * len(y) for i in range(len(x))]\n        for i in range(len(x)):\n            m[i][0] = l[i][0] = x[i]\n            for j in range(1, len(y)):\n                if x[i] < y[j]:\n                    m[i][j] = m[i][j - 1] + 1\n                    l[i][j] = j\n                else:\n                    m[i][j] = m[i - 1][j] + 1\n                    l[i][j] = j\n        return m, l\n\n    m, l = lis(A, B)\n    for j in range(1, len(B)):\n        if m[-1][j] < m[-1][j - 1]:\n            print(-1)\n            return\n    ans = []\n    i, j = len(m) - 1, len(l[-1]) - 1\n    while i >= 0 and j >= 0:\n        if m[i][j] == m[i - 1][j - 1] + 1:\n            ans.append(B[j])\n            i -= 1\n            j -= 1\n        elif m[i][j] == m[i - 1][j] + 1:\n            j -= 1\n        elif m[i][j] == m[i][j - 1] + 1:\n            i -= 1\n    print(\" \".join(map(str, ans[::-1])))\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = list(map(int, stdin.readline().strip().split()))\n\n    # Pre-computation\n    dp = [0] * n\n    dp[0] = nums[0]\n    for i in range(1, n):\n        dp[i] = max(dp[i - 1], nums[i])\n\n    # Binary search\n    def binary_search(l, r):\n        if l > r:\n            return -1\n        m = (l + r) // 2\n        m = max(m, dp[m])\n        if m == nums[m]:\n            return m\n        elif m < nums[m]:\n            return binary_search(l, m - 1)\n        else:\n            return binary_search(m + 1, r)\n\n    for i in range(1, n):\n        if dp[i - 1] > nums[i]:\n            print(i)\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    lst = []\n    for i in range(1, n+1):\n        lst.append(i)\n    lst2 = []\n    for i in range(1, n+1):\n        lst2.append(i)\n    for i in range(0, len(lst)):\n        if arr.count(lst[i]) > 1:\n            lst[i] = -1\n        for j in range(0, len(lst2)):\n            if lst[i] > lst2[j] and lst[i] > lst2[j+1] and lst[i] > lst2[j-1]:\n                lst2[j] = lst[i]\n    lst3 = []\n    for i in range(0, len(lst2)):\n        if lst2[i]!= -1:\n            lst3.append(lst2[i])\n    if lst3:\n        return \" \".join(str(lst3))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    width, height = stdin.split()\n    width, height = int(width), int(height)\n\n    # read the entire paper\n    paper = [stdin.readline().strip() for _ in range(height)]\n\n    # go through all stamps and mark them\n    for y in range(height):\n        for x in range(width):\n            if paper[y][x] == '#':\n                mark(paper, width, height, x, y)\n\n    # count the number of marked cells\n    counter = 0\n    for y in range(height):\n        for x in range(width):\n            if paper[y][x] == '#':\n                counter += 1\n    return counter\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[:2])\n    mark = stdin.split('\\n')[2:]\n\n    def _calc_rect(mark):\n        mark = mark.split('\\n')\n        height = len(mark)\n        width = len(mark[0])\n        rect_count = 0\n        for h in range(height):\n            for w in range(width):\n                if mark[h][w] == '#':\n                    rect_count += 1\n        return rect_count\n\n    rect1 = _calc_rect(mark)\n    rect2 = _calc_rect(mark)\n    for w in range(m):\n        rect2 -= mark[0][w] == '#'\n    for h in range(n):\n        for w in range(m):\n            rect2 -= mark[h][w] == '#'\n\n    print(min(rect1, rect2))\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get dimensions from the first line\n    n, m = map(int, stdin.split())\n\n    # initialize n x m matrix\n    matrix = [[\"#\"] * n] * m\n\n    # iterate over rows\n    for i in range(m):\n        # iterate over columns\n        for j in range(n):\n            # remove row if it's a completely black row\n            if all(matrix[i][j] == \"#\" for matrix[i] in matrix[:i]):\n                matrix = matrix[:i]\n                break\n\n            # remove column if it's a completely black column\n            if all(matrix[j][i] == \"#\" for matrix[i] in matrix):\n                matrix = [row[:i] for row in matrix]\n                break\n\n            # mark the remaining rows and columns\n            matrix[i][j] = \".\"\n            matrix[j][i] = \".\"\n\n    # add the two remaining rows and columns\n    matrix += [[\"#\"] * n, [\"#\"] * m]\n\n    # return the value of the single cell\n    return matrix[0][0]\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def extend_on_first_occurance(line: str, tester: set) -> None:\n        line = ''.join(line)\n        for i in range(len(line)):\n            if line[i] == tester:\n                line = line[:i] + '.' + line[i:]\n                return extend_on_first_occurance(line, tester)\n        return line\n\n    def extend_on_second_occurance(line: str, tester: set) -> None:\n        line = ''.join(line)\n        for i in range(len(line)):\n            if line[i] == tester:\n                line = line[:i] + '.' + line[i:]\n                return extend_on_second_occurance(line, tester)\n        return line\n\n    tests = stdin.split('\\n\\n')\n    for test in tests:\n        n, m = test.split()\n        for _ in range(int(n)):\n            stdin = stdin.replace(f'{m}.', '.')\n        print(len(extend_on_first_occurance(stdin, '#')))\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of nubs of a bureaucrat's stamp that could have possibly made the input mark by stamping exactly twice.\n\n    >>> solution(\"4 8\\n..#..#..\\n.######.\\n.######.\\n..#..#..\")\n    8\n    >>> solution(\"3 3\\n...\\n.#.\\n...\\n\")\n    1\n    >>> solution(\"2 6\\n.#####\\n#####.\\n\")\n    5\n    \"\"\"\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stdin = [stdin.strip() for stdin in stdin.split('\\n')]\n    print(n, m)\n    stdin = stdin[:n]\n    print(stdin)\n\n    return '10'\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    width, height = [int(x) for x in stdin.split()]\n    grid = [['.' for _ in range(width)] for _ in range(height)]\n    for y in range(height):\n        line = stdin.splitlines()[y]\n        for x, c in enumerate(line):\n            if c == '#':\n                grid[y][x] = '#'\n    num = 0\n    for y in range(height):\n        for x in range(width):\n            if grid[y][x] == '#':\n                if not check(grid, y, x):\n                    num += 1\n    return num\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4 8\n   .....#..#..\n   ....######.\n   ....######.\n   .....#..#..''')\n    8\n    >>> solution('''3 3\n   ......\n   ... #.#\n   ... ##.''')\n    1\n    \"\"\"\n    width, height = map(int, stdin.split())\n    paper = [list(stdin.split()[1]) for _ in range(height)]\n\n    return get_nubs(paper, width, height)\n\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split('\\n')[0].split(' '))\n    board = [[int(x) for x in stdin.split('\\n')[1].split(' ')]]\n    for i in range(n - 1):\n        board.append([int(x) for x in stdin.split('\\n')[i + 2].split(' ')])\n    directions = {0: 'right', 1: 'down', 2: 'left', 3: 'up'}\n    possible_moves = list(range(p * m * n))\n    visited = set()\n    moves = 0\n    while len(visited)!= p * m * n:\n        for i in range(p * m * n):\n            if i not in visited:\n                visited.add(i)\n                col, row = i % (m * n), (i // (m * n))\n                if board[row][col]!= p:\n                    for d in range(4):\n                        new_row, new_col = row + directions[d][1], col + directions[d][0]\n                        if 0 <= new_row < n and 0 <= new_col < m and board[new_row][new_col] == p:\n                            for j in range(i + 1, p * m * n):\n                                if j % (m * n) == new_col and j // (m * n) == new_row:\n                                    break\n                                if j in possible_moves and board[new_row][new_col] == p:\n                                    possible_moves.remove(j)\n                else:\n                    for d in range(4):\n                        new_row, new_col = row + directions[d][1], col + directions[d][0]\n                        if 0 <= new_row < n and 0 <= new_col < m:\n                            if board[new_row][new_col] == p:\n                                for j in range(i + 1, p * m * n):\n                                    if j % (m * n) == new_col and j // (m * n) == new_row:\n                                        break\n                                    if j in possible_moves and board[new_row][new_col] == p:\n                                        possible_moves.remove(j)\n                if len(possible_moves) == 1:\n                    return str(possible_moves[0] // (m * n))\n    return '-1'\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"not yet\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def print_board(board):\n        for i in range(len(board)):\n            if i % 5 == 0 and i!= 0:\n                print()\n\n            for j in range(len(board[i])):\n                if j % 5 == 0 and j!= 0:\n                    print(' ', end='')\n\n                print(board[i][j], end=' ')\n\n    def solution_board(board, n):\n        moves = 0\n        # while there are squares that have 0's\n        while 0 in board:\n            for i in range(len(board)):\n                for j in range(len(board[i])):\n                    # if 0's\n                    if board[i][j] == 0:\n                        # for all adjacent squares\n                        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                            # if valid\n                            if 0 <= x <= n - 1 and 0 <= y <= n - 1:\n                                # if adjacent square is 0\n                                if board[x][y] == 0:\n                                    # then change\n                                    board[i][j] = board[x][y]\n                                    board[x][y] = 0\n                                    moves += 1\n                                    break\n\n        # if no 0's then p wins\n        return moves\n\n    # load data\n    n, m, p = [int(x) for x in stdin.split(' ')]\n    board = [\n        [int(x) for x in stdin.split('\\n')[1:][i][:m]]\n        for i in range(n)\n    ]\n    # print board\n    print_board(board)\n    # solution\n    solution = solution_board(board, n)\n    # return solution\n    return solution\n\n\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the solution\n    \"\"\"\n    # Your code here\n    return \"\""
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve the given problem!\"\"\"\n    m, n, p = map(int, stdin.split())\n    board = [[int(char) for char in stdin.split()] for _ in range(n)]\n    move = [0] * (n * m)\n    for i in range(n):\n        for j in range(m):\n            if board[i][j]!= p:\n                move[i * m + j] = 1\n    return '\\n'.join(map(str, move))"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return string.\"\"\"\n    # Solution:\n    n, m, p = map(int, stdin.split('\\n')[0].split())\n    board = []\n    for row in stdin.split('\\n')[1:]:\n        board.append(list(map(int, row.split())))\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                return '{} {} {}'.format(n, m, p)\n    # Your code here\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = [int(x) for x in stdin.split()]\n    board = [list(map(int, stdin.split()[i * m:(i + 1) * m])) for i in range(n)]\n    for x in range(n):\n        for y in range(m):\n            if board[x][y] == p:\n                print(x * m + y)\n    return '-1'"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"Compute solution for input\"\n    def solve(board: List[List[int]], board_size: List[int], p: int):\n        \"Solve the game\"\n        def _solve(board: List[List[int]], board_size: List[int], p: int):\n            \"Solve the game\"\n            def _solve(board: List[List[int]], board_size: List[int], p: int):\n                \"Solve the game\"\n                def _solve(board: List[List[int]], board_size: List[int], p: int):\n                    \"Solve the game\"\n                    def _solve(board: List[List[int]], board_size: List[int], p: int):\n                        \"Solve the game\"\n                        def _solve(board: List[List[int]], board_size: List[int], p: int):\n                            \"Solve the game\"\n                            def _solve(board: List[List[int]], board_size: List[int], p: int):\n                                \"Solve the game\"\n                                return board\n                        board_copy = _solve(board, board_size, p)\n                        board = board_copy.copy()\n                        for row_idx, row in enumerate(board):\n                            for col_idx, col in enumerate(row):\n                                # try all possible moves\n                                if col == 0:\n                                    board[row_idx][col_idx] = p\n                                    board_copy = _solve(board, board_size, p)\n                                    board = board_copy.copy()\n                                    if board[row_idx][col_idx] == p:\n                                        return board_copy\n                                    else:\n                                        board[row_idx][col_idx] = 0\n                                else:\n                                    continue\n                        return None\n                    board_copy = _solve(board, board_size, p)\n                    board = board_copy.copy()\n                    for row_idx, row in enumerate(board):\n                        for col_idx, col in enumerate(row):\n                            # try all possible moves\n                            if col == 0:\n                                board[row_idx][col_idx] = p\n                                board_copy = _solve(board, board_size, p)\n                                board = board_copy.copy()\n                                if board[row_idx][col_idx] == p:\n                                    return board_copy\n                                else:\n                                    board[row_idx][col_idx] = 0\n                            else:\n                                continue\n                    return None\n                board_copy = _solve(board, board_size, p)\n                board = board_copy.copy()\n                for row_idx, row in enumerate(board):\n                    for col_idx, col in enumerate(row):\n                        # try all possible moves\n                        if col == 0:\n                            board[row_idx][col_idx] = p\n                            board_copy = _solve(board, board_size, p)\n                            board = board_copy.copy()\n                            if board[row_idx][col_idx] == p:\n                                return board_copy\n                            else:\n                                board[row_idx][col_idx] = 0\n                        else:\n                            continue\n                return None\n            board_copy = _solve(board, board_size, p)\n            board = board_copy.copy()\n            for row_idx, row in enumerate(board):\n                for col_idx, col in enumerate(row):\n                    # try all possible moves\n                    if col == 0:\n                        board[row_idx][col_idx] = p\n                        board_copy = _solve(board, board_size, p)\n                        board = board_copy.copy()\n                        if board[row_idx][col_idx] == p:\n                            return board_copy\n                        else:\n                            board[row_idx][col_idx] = 0\n                    else:\n                        continue\n            return None\n        board_copy = _solve(board, board_size, p)\n        board = board_copy.copy()\n        return board\n    # main\n    board_size = [int(x) for x in stdin.split('\\n')[0].split()]\n    board = [[int(x) for x in stdin.split('\\n')[i + 1].split()] for i in range(board_size[0])]\n    p = 2\n    while p <= board_size[2]:\n        board = solve(board, board_size, p)\n        if board is None:\n            break\n        p *= board_size[1]\n        p = 2\n    if board is not None:\n        return board\n    return -1\n    return board"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the given input.\"\"\"\n    # Get the input.\n    n, m, p = list(map(int, stdin.split(' ')))\n    # Initialise the board.\n    board = [[0] * m for _ in range(n)]\n    # The game state is initially unfinished.\n    state = 'unfinished'\n    # Go through all the rows and columns.\n    for row in range(n):\n        for column in range(m):\n            # Read the value.\n            value = int(stdin.readline())\n            # Make sure the value is valid.\n            if value < 1 or value > p:\n                return \"Invalid input.\"\n            # Update the board.\n            board[row][column] = value\n            # Check if the game is won.\n            if row == 0:\n                if value == p:\n                    state = 'won'\n            elif column == 0:\n                if value == p:\n                    state = 'won'\n            elif value == p:\n                state = 'won'\n    # The game is finished.\n    if state == 'won':\n        return str(n * m)\n    # There is no winning sequence.\n    elif state == 'unfinished':\n        return \"-1\"\n    # Find the first move that wins.\n    k = 0\n    for row in range(n):\n        for column in range(m):\n            if board[row][column] == 0:\n                k = n * m\n                break\n        else:\n            continue\n        break\n    # Add all the possible moves to a list.\n    moves = []\n    for row in range(n):\n        for column in range(m):\n            # Only add moves that haven't been made.\n            if board[row][column] == 0:\n                # Add the possible move.\n                moves.append(row * m + column)\n    # Return the winning sequence, if it exists.\n    if k == 0:\n        return''.join(map(str, moves))\n    # Get the solution.\n    solution = ''\n    while k:\n        # Get the index of the possible move.\n        index = k % len(moves)\n        # Add the possible move to the solution.\n        solution = str(moves[index]) +'' + solution\n        # Update the index of the possible moves.\n        k //= len(moves)\n    # Return the solution.\n    return solution\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = [int(x) for x in stdin.split()]\n    board = [[int(y) for y in stdin.split()] for _ in range(n)]\n    # board = [[int(y) for y in stdin.split()] for _ in range(n)]\n    # for line in board:\n    #     print(line)\n    # print(f\"n, m, p: {n}, {m}, {p}\")\n    # print(f\"board: {board}\")\n    n_moves = p * m * n\n    # print(f\"n_moves: {n_moves}\")\n    n_rows = len(board)\n    # print(f\"n_rows: {n_rows}\")\n    # print(f\"board: {board}\")\n    n_cols = len(board[0])\n    # print(f\"n_cols: {n_cols}\")\n    # print(f\"moves: {moves}\")\n    # print(f\"rows: {rows}\")\n    # print(f\"cols: {cols}\")\n    \n    # Possible moves:\n    # 1. Move right\n    # 2. Move down\n    # 3. Move left\n    # 4. Move up\n    \n    moves = []\n    row_index = 0\n    col_index = 0\n    while len(moves) < n_moves:\n        # First, get the value to add to the board\n        value = 1\n        # print(f\"row: {row_index}, col: {col_index}\")\n        # print(f\"value: {value}\")\n        # print(f\"board: {board}\")\n        if row_index + 1 < n_rows:\n            # Then, go right\n            if col_index + 1 < n_cols:\n                # print(f\"right\")\n                if board[row_index][col_index + 1]!= p:\n                    board[row_index][col_index + 1] += value\n                    moves.append(1)\n                    col_index += 1\n                else:\n                    board[row_index][col_index] += value\n                    moves.append(2)\n                    col_index += 1\n            else:\n                # print(f\"down\")\n                if board[row_index + 1][col_index]!= p:\n                    board[row_index + 1][col_index] += value\n                    moves.append(3)\n                    row_index += 1\n                else:\n                    # print(f\"left\")\n                    if col_index - 1 >= 0:\n                        if board[row_index][col_index - 1]!= p:\n                            board[row_index][col_index - 1] += value\n                            moves.append(4)\n                            col_index -= 1\n                        else:\n                            # print(f\"up\")\n                            board[row_index - 1][col_index] += value\n                            moves.append(6)\n                            row_index -= 1\n                            col_index -= 1\n                    else:\n                        # print(f\"up\")\n                        board[row_index - 1][col_index] += value\n                        moves.append(6)\n                        row_index -= 1\n                        col_index -= 1\n        else:\n            # print(f\"down\")\n            if board[row_index + 1][col_index]!= p:\n                board[row_index + 1][col_index] += value\n                moves.append(3)\n                row_index += 1\n            else:\n                # print(f\"left\")\n                if col_index - 1 >= 0:\n                    if board[row_index][col_index - 1]!= p:\n                        board[row_index][col_index - 1] += value\n                        moves.append(4)\n                        col_index -= 1\n                    else:\n                        # print(f\"up\")\n                        board[row_index - 1][col_index] += value\n                        moves.append(6)\n                        row_index -= 1\n                        col_index -= 1\n                else:\n                    # print(f\"up\")\n                    board[row_index - 1][col_index] += value\n                    moves.append(6)\n                    row_index -= 1\n                    col_index -= 1\n    \n    # print(moves)\n    return''.join([str(x) for x in moves])"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    def jumping_path(pre_root: int, root: int) -> None:\n        nonlocal max_jump_len, max_jump_len_num_paths\n        if root == -1:\n            return\n        if pre_root < root and pre_root + max_jump_len > root:\n            jumping_path(pre_root, root)\n        if pre_root < root:\n            jumping_path(pre_root, root)\n            jumping_path(root, -1)\n        max_jump_len = max(max_jump_len, root - pre_root)\n        max_jump_len_num_paths = max(max_jump_len_num_paths, paths + 1)\n        \n    \n    def dfs(root: int) -> None:\n        nonlocal pre_root, paths\n        pre_root = root\n        paths = 0\n        for child in tree[root]:\n            dfs(child)\n        jumping_path(pre_root, root)\n        \n    n = int(stdin.readline().strip())\n    tree = [[] for _ in range(n)]\n    for i in range(n):\n        tree[i].append(int(stdin.readline().strip()))\n        if tree[i][0] == -1:\n            root = i\n    \n    max_jump_len = 0\n    max_jump_len_num_paths = 0\n    dfs(root)\n    print(max_jump_len, max_jump_len_num_paths)\n    return max_jump_len_num_paths\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    parents = []\n    for i in range(1, N + 1):\n        parents.append(int(stdin.readline()))\n    graph = {}\n    for i in range(1, N + 1):\n        graph[i] = []\n    for i in range(N - 1):\n        graph[parents[i]].append(i + 2)\n    lengths = {}\n    lengths[1] = [0]\n    lengths[2] = [0]\n    for i in range(1, N + 1):\n        lengths[i].append(lengths[i][-1])\n        if i not in graph:\n            continue\n        for child in graph[i]:\n            lengths[i].append(max(lengths[i][-1], lengths[child][-1] + 1))\n    max_length = 0\n    for length in lengths[N]:\n        if length > max_length:\n            max_length = length\n    num_paths = 0\n    for length in lengths[N]:\n        if length == max_length:\n            num_paths += 1\n    print(max_length, num_paths)\n    return ''\n\nprint(solution(str(input())))\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('5\\n3\\n3\\n3\\n3\\n1\\n2\\n3\\n4\\n')\n    '5 1'\n    >>> solution('5\\n4\\n3\\n2\\n1\\n0\\n1\\n2\\n3\\n4\\n')\n    '1 5'\n    >>> solution('5\\n4\\n3\\n2\\n1\\n0\\n1\\n2\\n3\\n4\\n')\n    '1 5'\n    \"\"\"\n    # The number of vertices in the tree.\n    n = int(stdin.readline())\n\n    # A list of vertex labels.\n    labels = [0] * (n + 1)\n\n    # A dictionary of vertex parents.\n    parents = [None] * (n + 1)\n\n    for _ in range(n):\n        # The label of vertex v.\n        u = int(stdin.readline())\n\n        # The label of the parent of vertex v.\n        p = int(stdin.readline())\n\n        # Add the vertex v to the list.\n        labels[u] = u\n\n        # Add the parent p to vertex v in the dictionary.\n        parents[u] = p\n\n    # For each vertex v, check whether vertex v has parent p.\n    # If it does not, v is the root.\n    roots = []\n    for v in range(n + 1):\n        if parents[v] is None:\n            roots.append(v)\n\n    # The length of the longest jumping path.\n    L = 0\n\n    # The number of jumping paths of length L.\n    M = 0\n\n    # Compute the longest jumping path.\n    for root in roots:\n        # The current longest jumping path.\n        path = [root]\n\n        # The current jumping path length.\n        length = 1\n\n        # While the current path is not empty,\n        # and its last element does not have a parent,\n        # add the last vertex to the path.\n        while path and parents[path[-1]] is None:\n            path.append(labels[path[-1]])\n            length += 1\n\n        # If the current path is not empty,\n        # check whether the current path is a jumping path.\n        # If so, update the number of jumping paths.\n        if path:\n            M += 1\n            if length > L:\n                L = length\n\n    # Print the answer.\n    return str(L) +'' + str(M % 11092019)\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def _solve() -> Any:\n        def _dp_jumps(parent: int, jumps: List[int]) -> Tuple[int, int]:\n            dp_jumps: Dict[int, List[int]] = {1: [parent]}\n            jumps_length: Dict[int, int] = {parent: len(jumps)}\n\n            for child in dp_jumps[parent]:\n                if child in jumps_length:\n                    dp_jumps[child] = [\n                        *dp_jumps[child],\n                        *jumps[jumps_length[child]:],\n                    ]\n                    jumps_length[child] = len(dp_jumps[child])\n\n            return max(jumps_length.values()), len(jumps) - max(jumps_length.values())\n\n        lines = stdin.split('\\n')[:-1]\n        n_vertices = int(lines[0])\n        jumps = [int(line) for line in lines[1:]]\n\n        jumps_length, n_jumps = _dp_jumps(1, jumps)\n\n        for child in dp_jumps[1]:\n            jumps_length, n_jumps = _dp_jumps(child, jumps)\n            n_jumps //= 11092019\n            jumps_length += n_jumps * (11092019 - 1)\n\n        return str(jumps_length) +'' + str(n_jumps % 11092019)\n\n    return _solve()\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds longest path and number of paths in a rooted tree\n\n    Args:\n        stdin: input text\n\n    Returns:\n        string: output text\n    \"\"\"\n    vertices = int(stdin.split('\\n')[0])\n    parents = [int(i) for i in stdin.split('\\n')[1:]]\n    lengths = {i: 1 for i in range(1, vertices + 1)}\n\n    def find_lengths(start_vertex: int) -> dict:\n        \"\"\"Finds all paths from a start vertex\n\n        Args:\n            start_vertex (int): starting vertex\n\n        Returns:\n            dict: dictionaries where the keys are child vertices and the values are lengths\n        \"\"\"\n        queue = deque([(start_vertex, 1)])\n        lengths = {start_vertex: 1}\n        while queue:\n            vertex, length = queue.popleft()\n            children = get_children(parents, vertex)\n            for child in children:\n                if child not in lengths:\n                    lengths[child] = length\n                    queue.append((child, length + 1))\n                else:\n                    if lengths[child] < length + 1:\n                        lengths[child] = length + 1\n        return lengths\n\n    def get_children(parents: list, vertex: int) -> list:\n        \"\"\"Returns the child vertices of a vertex\n\n        Args:\n            parents (list): parent vertices\n            vertex (int): vertex\n\n        Returns:\n            list: list of child vertices\n        \"\"\"\n        children = []\n        for i in range(len(parents)):\n            if parents[i] == vertex:\n                children.append(i + 1)\n        return children\n\n    for vertex in range(1, vertices):\n        lengths = find_lengths(vertex)\n        for child, length in lengths.items():\n            if lengths[child] > lengths[lengths[child]]:\n                lengths[child] = lengths[lengths[child]]\n\n    paths = {}\n    for vertex in range(1, vertices):\n        if vertex not in paths:\n            paths[vertex] = 0\n            queue = deque([vertex])\n            while queue:\n                paths[vertex] += 1\n                children = get_children(parents, vertex)\n                for child in children:\n                    queue.append(child)\n\n    path_length = max([lengths[paths[vertex]] for vertex in range(1, vertices)])\n\n    return str(path_length) +'' + str(paths[lengths[path_length]] % 11092019)\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    roots = [None] + list(map(int, stdin.readline().split()))\n    parent = [None] + [roots[i - 1] for i in range(n + 1)]\n    stk = []\n    for i in range(2, n + 1):\n        stk.append((parent[i], i))\n    while stk:\n        root, child = stk.pop()\n        if root is None:\n            continue\n        if child < root:\n            stk.append((root, child))\n    num = set()\n    for i in range(2, n + 1):\n        if parents[i] not in num:\n            num.add(i)\n            num.add(parents[i])\n    print(len(num))\n    print(len(num) % 11092019)\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the longest path, and the number of paths of that length where\n    labels are nondecreasing.\n    \"\"\"\n    # Get number of vertices and root.\n    N = int(stdin.readline())\n    root = int(stdin.readline())\n\n    # Build graph.\n    graph = {root: []}\n    for line in stdin.readlines()[1:-1]:\n        parent, child = map(int, line.split())\n        graph.setdefault(parent, []).append(child)\n\n    # Find the longest path and the number of paths of that length.\n    paths = [0] * N\n    paths[0] = 1\n    for u in graph[root]:\n        paths[u] = 1\n        for v in graph[u]:\n            paths[v] = (paths[u] + paths[v]) % int(1e9 + 7)\n\n    L = N\n    for i in range(1, N):\n        if paths[i] > paths[L]:\n            L = i\n    L -= 1\n    M = sum(paths)\n    M %= int(1e9 + 7)\n\n    return f\"{L} {M}\"\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    p = []\n    for i in range(N - 1):\n        p.append(int(stdin))\n    tree = {i: p[i] for i in range(N)}\n    for i in range(N):\n        if tree[i] > 0:\n            tree[tree[i]].append(i)\n    return 0\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest jumping path and the number of such paths in a tree.\n\n    Args:\n        stdin (str): Input string to process.\n\n    Returns:\n        str: String with the longest path and its length.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = [int(s) for s in stdin.split(\"\\n\") if s!= \"\"]\n    index = [0] * n\n    father = [None] * n\n    length = 0\n    count = 0\n    for i in range(n):\n        index[i] = i\n    for i in range(1, n):\n        fa = arr[i]\n        while father[fa]!= None:\n            fa = father[fa]\n        father[arr[i]] = fa\n    for i in range(1, n):\n        fa = father[arr[i]]\n        if fa!= None:\n            index[arr[i]] = index[fa] + 1\n            length = max(index[arr[i]], length)\n            if index[arr[i]] == length:\n                count += 1\n    if length == 0:\n        return \"0 0\"\n    else:\n        return \"{} {}\".format(length, count % 11092019)\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \"The solution is {}\".format(solution_2(stdin))\n    # m = stdin.readline().rstrip()\n    # numbers = [stdin.readline().rstrip().split() for _ in range(int(m))]\n    # return \"The solution is {}\".format(solution_2(numbers))\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of nodes in the largest subset that satisfies the Heap Property\"\"\"\n    n = int(stdin)\n    node_list = [list(map(int, stdin.split('\\n')[i].split())) for i in range(n)]\n    node_list.pop(0)\n    nodes = len(node_list)\n    result = 0\n    node_list.sort(key=lambda x: x[0])\n    for i in range(1, nodes):\n        result = max(result, i + max([k for k in range(1, i) if node_list[i][1] in node_list[k]]))\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Tr\u1ea3 v\u1ec1 t\u00ean bi\u1ec3u \u0111\u1ed3 v\u00e0 t\u1ecda \u0111\u1ed9 x,y cho ph\u00e9p \u00e1nh x\u1ea1 v\u1eadt c\u1ee7a tung \u0111\u1ed3\"\"\"\n    return \"tree\", 1, 1\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    ans = []\n    n = int(stdin.split('\\n')[0])\n    for i in range(n):\n        # v, p = stdin.split('\\n')[i].split()\n        v, p = stdin.split('\\n')[i].split()\n        v, p = int(v), int(p)\n        ans.append(tuple([v, p]))\n    ans.sort()\n    # print(ans)\n    if len(ans) > 0:\n        if ans[0][0] > ans[1][0]:\n            ans[1] = ans[0]\n    for i in range(1, len(ans)):\n        if ans[i][0] > ans[i - 1][0]:\n            ans[i - 1] = ans[i]\n    print(len(ans))\n    # print(ans)\n    return ans"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def DFS(parent):\n        s.add(parent)\n        for child in tree[parent]:\n            if child not in s:\n                DFS(child)\n\n    tree = defaultdict(list)\n    n = int(stdin.readline())\n    for _ in range(n):\n        parent, child = tuple(map(int, stdin.readline().split()))\n        tree[parent].append(child)\n    tree[0] = []\n    s = set()\n    DFS(0)\n    print(len(s))\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin.readline())\n    heap = []\n    for _ in range(num_nodes):\n        value, parent = map(int, stdin.readline().split())\n        heap.append([value, parent])\n    heap.sort(key=lambda x: x[0])\n    children = [[] for _ in range(num_nodes)]\n    for _, parent in heap:\n        if parent!= -1:\n            children[parent].append(len(heap))\n    max_heap = 0\n    for i in range(len(heap)):\n        if children[i]:\n            max_heap += len(children[i]) + 1\n            for child in children[i]:\n                max_heap += len(children[child])\n    return max_heap\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n = int(stdin.readline())\n    parent = [0] * (n+1)\n    children = [[] for _ in range(n+1)]\n    for _ in range(n-1):\n        i, j = map(int, stdin.readline().split())\n        parent[i] = j\n        children[j].append(i)\n    count = 0\n    visited = set()\n    def dfs(node, parent):\n        nonlocal count\n        visited.add(node)\n        if children[node]:\n            for child in children[node]:\n                dfs(child, node)\n        if parent:\n            if node > parent:\n                count += 1\n    dfs(1, None)\n    return count\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the maximum number of nodes to pick from the tree such that the Heap Property is satisfied.\n\n    A node is said to be an ancestor of itself, and a node is said to be a child of itself if the parent's value is greater than the child's value.\n    \"\"\"\n\n    # Read number of nodes\n    number_of_nodes = int(stdin.readline())\n\n    # Read all nodes\n    nodes = []\n    for _ in range(number_of_nodes):\n        node, parent = map(int, stdin.readline().split())\n        nodes.append((node, parent))\n\n    # Find the max number of nodes that can be picked\n    max_nodes_in_heap = 0\n    for node, parent in nodes:\n        if parent > 0:\n            ancestor_node, _ = nodes[parent]\n            heap_property_satisfied = node > ancestor_node\n            if heap_property_satisfied:\n                max_nodes_in_heap += 1\n\n    return str(max_nodes_in_heap)\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def solution_runner(adj_mat: list, return_list: list) -> list:\n        def dfs(node: int, visited: list, color: int):\n            for i, adj in enumerate(adj_mat[node]):\n                if visited[i] == 0 and adj!= color:\n                    visited[i] = 1\n                    dfs(i, visited, adj)\n\n        colors = set()\n        for i, color in enumerate(adj_mat[0]):\n            if color not in colors:\n                visited = [0] * len(adj_mat)\n                visited[i] = 1\n                dfs(i, visited, color)\n                if sum(visited) == len(visited):\n                    colors.add(color)\n        return_list.extend(colors)\n\n    return_list = []\n    nodes = int(stdin.split('\\n')[0])\n    adj_mat = [[0 for _ in range(nodes)] for _ in range(nodes)]\n    for line in stdin.split('\\n')[1:]:\n        left, right, color = map(int, line.split())\n        adj_mat[left - 1][right - 1] = color\n    for i in range(nodes):\n        solution_runner(adj_mat, return_list)\n    return_str = ''\n    for node in return_list:\n        return_str += str(node) + '\\n'\n    return return_str\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Tracks the edges of the tree and uses it to determine how many good nodes are in the tree.\"\"\"\n    # initialize the graph with the edges.\n    # assume that the edges are in the correct format.\n    graph = {}\n    for edge in stdin.split('\\n'):\n        a, b, c = [int(x) for x in edge.split(' ')]\n        graph[a] = graph.get(a, [])\n        graph[a].append((b, c))\n        graph[b] = graph.get(b, [])\n        graph[b].append((a, c))\n\n    # get the good nodes\n    nodes = [node for node, edges in graph.items() if len(edges) == len(set(c for b, c in edges))]\n\n    # return the good nodes\n    return '\\n'.join(nodes)\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # 1. Create an empty set called visited \n    # 2. Create a function to check if an edge is a rainbow \n    # 3. Create a function to check if a vertex is a rainbow vertex \n    # 4. Iterate through the edges, and check if they are a rainbow \n    # 5. Iterate through the edges again, and check if the edges are adjacent \n    # 6. Append the vertices of the edge to visited if they are not a rainbow vertex \n    # 7. Return the visited set \n    \n    # Validate the input \n    num_stations = int(stdin.readline())\n    if num_stations < 1 or num_stations > 50000:\n        raise Exception(\"Invalid number of stations.\")\n    \n    # Populate the graph \n    graph = {}\n    for _ in range(num_stations - 1):\n        station_a, station_b, color = map(int, stdin.readline().split())\n        if station_a < 1 or station_a > num_stations or station_b < 1 or station_b > num_stations or station_a == station_b or color < 1 or color > num_stations:\n            raise Exception(\"Invalid graph input.\")\n        graph[(station_a, station_b)] = color\n    \n    visited = set()\n    \n    def is_rainbow(a, b):\n        return graph[(a, b)]!= graph[(b, a)]\n        \n    def is_rainbow_vertex(v):\n        for u, _ in graph.keys():\n            if v in (u, _):\n                continue\n            if is_rainbow(u, v) and is_rainbow(v, u):\n                return True\n        return False\n    \n    for u, _ in graph.keys():\n        if not is_rainbow_vertex(u):\n            visited.add(u)\n    \n    return str(len(visited)) + '\\n' + '\\n'.join(map(str, visited))\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Create a graph with edges and colors.\n    \"\"\"\n    graph = {}\n    n = int(stdin.split()[0])\n    for i in range(1, n):\n        a, b, c = map(int, stdin.split()[i].split())\n        graph[a] = graph.get(a, []) + [(b, c)]\n        graph[b] = graph.get(b, []) + [(a, c)]\n    good = 0\n    for i in range(1, n+1):\n        if i not in graph:\n            good += 1\n    print(good)\n    print(*sorted(i for i in range(1, n+1) if i not in graph), sep='\\n')\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    n = int(stdin.readline())\n    good_nodes = deque()\n    # graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b, c = [int(s) for s in stdin.readline().split()]\n        # graph[a - 1].append((b - 1, c))\n        # graph[b - 1].append((a - 1, c))\n        a -= 1\n        b -= 1\n        good_nodes.append(a)\n        good_nodes.append(b)\n    good_nodes = set(good_nodes)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if all(\n                    abs(x - y)!= 1 for x, y, _ in\n                    [stdin.readline().split() for _ in range(3)]):\n                # if i == 2 and j == 3:\n                #     print(\"debug\")\n                #     print(i, j)\n                #     print(stdin.readline().split())\n                #     print(stdin.readline().split())\n                if j in good_nodes:\n                    good_nodes.remove(j)\n                if i in good_nodes:\n                    good_nodes.remove(i)\n    return f\"{len(good_nodes)}\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))\n\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''You're given a tree with n nodes. Each edge in this tree has one of n colors. \n    A path in this tree is called a rainbow if all adjacent edges in the path have different colors. \n    Also, a node is called good if every simple path with that node as one of its endpoints is a rainbow path. \n    (A simple path is a path that does not repeat any vertex or edge.)\n    Find all the good nodes in the given tree.\n\n    You should output a list of all the good nodes in this tree, in ascending order.\n\n    Each line of output should contain a single node number. You can print each number in any order.\n\n    Args:\n        stdin (str): the stdin input as a string.\n    Returns:\n        str: the solution as a string.\n    '''\n   ...\n    return solution"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n = int(stdin.split()[0])\n    color_map = defaultdict(list)\n    for i in range(n-1):\n        u, v, color = tuple(map(int, stdin.split()[i*3:i*3+3]))\n        color_map[u].append((v, color))\n        color_map[v].append((u, color))\n\n    visited = set()\n    res = []\n    def dfs(root):\n        if root in visited:\n            return\n        visited.add(root)\n        for child, color in color_map[root]:\n            dfs(child)\n        res.append(root)\n\n    dfs(1)\n    return len(res)"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds all good nodes in a tree.\n\n    Args:\n        stdin (str): The input of the problem.\n\n    Returns:\n        str: All good nodes in the tree.\n    \"\"\"\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    edges = [list(map(int, line.split(\" \"))) for line in lines[1:]]\n\n    good = []\n    for i in range(1, n + 1):\n        if all(j!= i for j in [edge[0] for edge in edges]):\n            good.append(i)\n\n    return \" \".join(map(str, good))\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    adj = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    # adj = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    return \"\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i):\n        if i == n:\n            return all(c in used for used in used_set for c in used_set[used])\n        for j in range(n):\n            if j not in used:\n                used.add(j)\n                used_set[j] = set(used)\n                if dfs(i + 1):\n                    return True\n                used.remove(j)\n                used_set[j].clear()\n        return False\n\n    n = int(stdin.readline())\n    used = set()\n    used_set = [set() for _ in range(n)]\n    ans = 0\n    for i in range(n):\n        a, b, c = map(int, stdin.readline().split())\n        used_set[a - 1].add(b - 1)\n        used_set[b - 1].add(a - 1)\n        used.add(a - 1)\n        used.add(b - 1)\n        ans += dfs(0)\n        used.clear()\n        used_set = [set() for _ in range(n)]\n    return ans"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    banks, variables = map(int, stdin.split())\n    program = [{'var': int(l[1:]),'refs': 0,'sets': 0} for l in stdin.split('\\n') if l[0] == 'V']\n    min_num_instructions = 10 ** 12\n    for num_instructions in range(1, 11 ** 12):\n        variables_done = set()\n        sets = 0\n        for num_var_references in range(num_instructions):\n            var_reference = program.pop(0)\n            var_reference['refs'] += 1\n            if var_reference['refs'] <= banks:\n                sets += 1\n                var_reference['sets'] += 1\n                variables_done.add(var_reference['var'])\n        if len(variables_done) == variables:\n            break\n    return str(num_instructions)\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum running time of programs.\"\"\"\n    # Get input from stdin and set b and s.\n    b, s = [int(i) for i in stdin.split()]\n    # Get the program from stdin.\n    program = stdin.split()[-1]\n\n    # Create a mapping of variables to memory banks.\n    var_to_bank = {}\n    for i in range(1, b * s + 1):\n        var_to_bank[i] = i % b\n\n    # Create a mapping of variables to a minimum bank assignment.\n    var_to_bank_min = {}\n    for i, j in var_to_bank.items():\n        var_to_bank_min[i] = 1\n\n    # Create a mapping of variables to a maximum bank assignment.\n    var_to_bank_max = var_to_bank.copy()\n\n    # Create a mapping of variables to a bank assignment.\n    var_to_bank_curr = var_to_bank.copy()\n\n    # Find the minimum number of instructions to run the program.\n    return len(program.split()) + min(\n        [\n            # Find the minimum number of assignments of the BSR to banks.\n            min(\n                [\n                    # Find the minimum number of assignments of the BSR to banks.\n                    len(\n                        list(\n                            set(\n                                [\n                                    # Find the minimum number of bank assignments.\n                                    (var_to_bank_curr[i], var_to_bank_min[i])\n                                    for i in program.split()\n                                ]\n                            )\n                        )\n                    )\n                    + (\n                        # Find the minimum number of bank assignments.\n                        len(\n                            list(\n                                set(\n                                    [\n                                        # Find the maximum number of bank assignments.\n                                        (var_to_bank_max[i], var_to_bank_min[i])\n                                        for i in program.split()\n                                    ]\n                                )\n                            )\n                        )\n                    )\n                ]\n            )\n            + len(\n                list(\n                    set(\n                        [\n                            # Find the maximum number of bank assignments.\n                            (var_to_bank_max[i], var_to_bank_max[i])\n                            for i in program.split()\n                        ]\n                    )\n                )\n            )\n        ]\n    )\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, s = [int(x) for x in stdin.split()]\n    while b * s < 13:\n        b, s = b + 1, s + 1\n    program = stdin.splitlines()[1:]\n    n, total = 0, 0\n    for line in program:\n        if line[0] == 'V':\n            total += 1\n        elif line[0] == 'R':\n            n += (int(line[1:]) + 1) * int(line[1:])\n            total += n\n        else:\n            total += n\n    return str(total)\n\nprint(solution(open(\"../../resources/input-02.txt\").read()))"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Time: O(nlogn)\n    Space: O(n)\n    '''\n    \n    n, m = (int(x) for x in stdin.split())\n    mem = {}\n    for _ in range(n):\n        bank = [int(x) for x in stdin.split()][1:]\n        for index, _ in enumerate(bank):\n            mem[bank[index]] = index\n    sorted_keys = sorted(mem.keys())\n    bank = [sorted_keys[:m]]\n    for key in sorted_keys[m:]:\n        if key < bank[-1][-1]:\n            bank.append([key])\n    # print(bank)\n    visited = set()\n    total = 0\n    for op in stdin.split('E'):\n        op = op.strip()\n        if 'R' in op:\n            n = int(op.split()[1])\n            for _ in range(n):\n                if bank[0]:\n                    bank.pop(0)\n                    total += 1\n        else:\n            for _ in range(1):\n                for i in range(len(bank)):\n                    if bank[i] and bank[i][0] in visited:\n                        bank[i].pop(0)\n                        total += 1\n                    else:\n                        visited.add(bank[i][0])\n                        bank[i].pop(0)\n                        total += 1\n                    if not bank[i]:\n                        bank.pop(i)\n                        break\n    return total"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    mem_banks, var_banks = [int(x) for x in stdin.split(' ')]\n    instructions = [x for x in stdin.split(' ')]\n    solution = 0\n    for inst in instructions:\n        if inst[0].isdigit():\n            solution += 1\n        elif inst[0] == 'R':\n            rep = int(inst[1:])\n            solution += rep * solution\n        else:\n            var_index = int(inst[1:])\n            solution += 1\n    return str(solution)\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    b, s = map(int, stdin.split())\n    # b = int(input())\n    # s = int(input())\n    program = [\n        line for line in stdin.split(\"\\n\") if line.strip()!= \"\"\n    ]\n    # program = [line.strip() for line in stdin.split(\"\\n\") if line.strip()!= \"\"]\n    from collections import deque\n    import functools\n    import operator\n    import itertools\n\n    @functools.lru_cache(maxsize=None)\n    def check_subset(variables, n=0):\n        \"\"\"Check if subset of program.\"\"\"\n        subset = deque()\n        for op in program:\n            if len(op) == 0:\n                continue\n            if op[0] == \"R\":\n                if int(op[1:]) > n:\n                    return False\n                subset.append(n)\n                n += int(op[1:])\n            elif op[0] == \"V\":\n                if variables.get(op[1:], 0) == 0:\n                    return False\n                subset.append(variables[op[1:]])\n            elif op[0] == \"E\":\n                subset.append(functools.reduce(operator.or_, subset))\n            else:\n                raise ValueError(\"Unknown operation\")\n        if len(subset) == 0:\n            return False\n        subset.append(functools.reduce(operator.or_, subset))\n        return subset\n\n    def solve(variables, n=0):\n        \"\"\"Return solution.\"\"\"\n        if n >= len(program):\n            return n\n        variables = dict(variables)\n        while True:\n            subset = check_subset(variables, n)\n            if not subset:\n                break\n            op = program[n]\n            if op[0] == \"R\":\n                n += int(op[1:])\n            elif op[0] == \"V\":\n                if variables.get(op[1:], 0) == 0:\n                    break\n                variables[op[1:]] = subset.popleft()\n            elif op[0] == \"E\":\n                variables[op[1:]] = functools.reduce(operator.or_, subset)\n            else:\n                raise ValueError(\"Unknown operation\")\n        return n\n\n    variables = {}\n    n = solve(variables)\n    variables = {key: idx for key, idx in variables.items()}\n    min_ops = b * s\n    for permutation in itertools.permutations(variables):\n        ops = solve(dict(zip(variables.keys(), permutation)), n=0)\n        if ops < min_ops:\n            min_ops = ops\n    print(min_ops)\n    return min_ops\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(bs) / O(bs)\"\"\"\n    b, s = map(int, stdin.split(\" \"))\n    p = stdin.split(\" \")\n    ans = 0\n    for i in range(b):\n        used = set()\n        bank = [False for _ in range(s)]\n        for j, item in enumerate(p):\n            if item in (\"V\", \"R\"):\n                if item == \"V\":\n                    bank[j] = True\n                if item == \"R\":\n                    for k in range(j + 1, min(len(p), j + s)):\n                        used.add(k)\n                        bank[k] = True\n        # print(bank, used)\n        if bank == [True for _ in range(s)]:\n            ans += len(used)\n        else:\n            # search for a loop\n            loop = {}\n            for j, item in enumerate(p):\n                if item == \"E\":\n                    for k in range(j + 1, min(len(p), j + s)):\n                        if bank[k]:\n                            if k not in loop:\n                                loop[k] = set()\n                            loop[k].add(j)\n            # print(loop)\n            for j, item in enumerate(p):\n                if item == \"E\":\n                    if j not in loop:\n                        loop[j] = set()\n                    for k in loop[j]:\n                        for k2 in loop[k]:\n                            loop[j].add(k2)\n            # print(loop)\n            for j, item in enumerate(p):\n                if item == \"E\":\n                    if j not in loop:\n                        ans += 1\n                    elif len(loop[j]) == 1:\n                        ans += len(used) - 1\n                    else:\n                        ans += len(used) + len(loop[j]) - 1\n            # print(ans)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split())\n    p = stdin.split('\\n')[1]\n    bank = [0] * b\n    pointer = [0] * b\n    bsr = -1\n    min_time = len(p) + 1\n    for i, j in enumerate(p):\n        if j == 'V':\n            bank[i % b] += 1\n        elif j == 'R':\n            min_time = min(min_time, (i + 1) * int(j[1:]))\n        elif j == 'E':\n            bsr = (bsr + 1) % b\n    for i, j in enumerate(p):\n        if j == 'V':\n            bank[i % b] += 1\n        elif j == 'R':\n            min_time = min(min_time, (i + 1) * int(j[1:]))\n        elif j == 'E':\n            bsr = (bsr + 1) % b\n            pointer[bsr] += 1\n    time = sum([i * bank[j % b] for i, j in zip(pointer, range(b))])\n    return min_time if time <= min_time else -1\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, s = [int(i) for i in stdin.strip().split()]\n    program = [i for i in stdin.strip().split('\\n')[1].split(' ') if i]\n    bank = [0] * b\n    min_time = float('inf')\n    for cmd in program:\n        if cmd.startswith('V'):\n            i = int(cmd[1:])\n            bank[i] = bank[i] ^ 1\n        elif cmd.startswith('R'):\n            n = int(cmd[1:])\n            s = 0\n            for _ in range(n):\n                s += bank[s % b]\n        else:\n            s += 1\n        min_time = min(s, min_time)\n    return str(min_time)\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    banks, variables = [int(x) for x in stdin.split(' ')]\n    program = [x for x in stdin.split('\\n') if x!= '']\n    return ''\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = [int(x) for x in stdin.split()]\n    B, N = 2, 416077\n    X = None\n    for x in range(1, 2 ** 63):\n        # print(x)\n        x = str(x)\n        if x == \"1\":\n            continue\n        x = int(x)\n        # print(x)\n        if x == N and B == len(str(x)):\n            X = x\n            break\n    if X is None:\n        print(\"impossible\")\n    else:\n        print(X)\n    return X\n\n\nsolution(\"10 11\")\nsolution(\"10 24\")\nsolution(\"9 216\")"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return first positive integer x that satisfies f(x) == n.\"\"\"\n    return \"\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, n = stdin.split(' ')\n    if int(n) == 0:\n        return 'impossible'\n    b = int(b)\n    if b == 1:\n        return str(n)\n    return int(str(n), b)\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split(' '))\n    if n == 0 or n == 1:\n        return 'impossible'\n    else:\n        nums = [int(x) for x in str(n)]\n        res = ''\n        if len(nums) == 1:\n            if n < 2 ** b:\n                return '0' * (b - 1) + str(n - 1)\n            else:\n                return 'impossible'\n        else:\n            max_val = max(nums)\n            if max_val > b - 1:\n                return 'impossible'\n            else:\n                for i in range(b):\n                    rem = n % (b ** (i + 1))\n                    if rem < b:\n                        rem = rem * 10\n                        if rem < 2:\n                            rem = 0\n                        res += str(rem // (b ** i))\n                        n -= rem\n                return res"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = stdin.split(' ')\n    B, N = int(B), int(N)\n    \n    # check if N is too large, if not enough memory will be used\n    if N > 2 ** 64:\n        return 'impossible'\n    \n    # create array of all possible values in given base\n    base_values = [i for i in range(B)]\n\n    # create dictionary to store solutions\n    solutions = dict()\n    \n    # find solution\n    for base_value in base_values:\n        solutions[base_value] = N // base_value\n        N = N - solutions[base_value] * base_value\n        if N == 0:\n            return solutions\n    return 'impossible'\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, N = [int(x) for x in stdin.split(' ')]\n    if not (2 < B <= 10000) or not (0 < N < 2 ** 63):\n        return \"impossible\"\n    ans = 0\n    while True:\n        ans += 1\n        temp = N\n        for i in str(ans):\n            temp = f(temp, int(i))\n        if temp == N:\n            return ans"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    (B, N) = [int(x) for x in stdin.split()]\n\n    if N == 0 or N == 1:\n        return \"impossible\"\n\n    if B == 1:\n        if N == 1:\n            return 0\n        elif N % 2 == 1:\n            return N // 2\n        else:\n            return 0\n    elif B == 2:\n        return N - 1\n    else:\n        digits = [int(x) for x in str(N)]\n        digits.sort()\n        if digits[0]!= 0:\n            return 0\n\n        digits = digits[1:]\n        digits.append(0)\n\n        ans = []\n        i = 0\n        while digits[i] < B:\n            digits[i] *= B\n            digits[i+1] += digits[i] // B\n            digits[i] %= B\n            i += 2\n            if i == len(digits) - 1:\n                digits.append(0)\n        for x in digits:\n            ans.append(x % B)\n        ans.sort()\n        ans = \"\".join([str(x) for x in ans])\n\n        if ans == \"\":\n            return 0\n        else:\n            return int(ans)\n\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Complete this function\n    num_base10, num_baseB = stdin.strip().split(' ')\n    num_base10 = int(num_base10)\n    num_baseB = int(num_baseB)\n    if 2 <= num_baseB <= 10000:\n        max_num = 2 ** 63\n        if num_base10 > max_num or num_base10 <= 0:\n            return \"impossible\"\n        if num_base10 == max_num:\n            return str(max_num)\n        # find first non-zero digit\n        digit = -1\n        while num_base10 % 10 == 0:\n            num_base10 //= 10\n            digit += 1\n        # loop through each digit starting at the digit just found\n        for digit in range(digit, -1, -1):\n            # check to see if there is a solution\n            i = num_base10\n            while i < max_num:\n                # check to see if the number matches\n                if f_baseB(i, num_baseB) == num_base10:\n                    return str(i)\n                # increment\n                i *= 10\n        # did not find a solution\n        return \"impossible\"\n    return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.readline().split())\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(int, stdin.readline().split())\n        clouds.append(Cloud(s, e, p, a))\n    roofs = []\n    for i in range(r):\n        x, y = map(int, stdin.readline().split())\n        roofs.append(Roof(x, y))\n\n    def fun(a, b):\n        if a[1] <= b[0]:\n            return 0\n        return (b[0] - a[0]) / (a[1] - b[0])\n\n    clouds = sorted(clouds, key=fun)\n    for i in range(len(roofs)):\n        roofs[i] = Roof(roofs[i].x, roofs[i].y, 0)\n    roofs = sorted(roofs, key=fun)\n    if fun(clouds[0], roofs[0]) == 0:\n        return '{:.5f}'.format(roofs[0].y - 1)\n    l = 0\n    r = len(roofs)\n    while r - l > 1:\n        m = (l + r) // 2\n        t = fun(clouds[0], roofs[m])\n        if t < 0:\n            r = m\n        else:\n            l = m\n    if fun(clouds[0], roofs[l]) < 0:\n        return '{:.5f}'.format(roofs[l].y - 1)\n    else:\n        return '{:.5f}'.format(roofs[l].y)\n\nclass Roof:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\nclass Cloud:\n    def __init__(self, s, e, p, a):\n        self.s = s\n        self.e = e\n        self.p = p\n        self.a = a\n\nprint(solution(stdin.read()))"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    stdin = stdin.splitlines()\n    _, _, _, _, _, t, d, c, r = [int(n) for n in stdin[0].split()]\n    clouds = []\n    for _ in range(c):\n        s, e, p, a = [int(n) for n in stdin[_].split()]\n        clouds.append([s, e, p, a])\n    roofs = []\n    for _ in range(r):\n        x, y = [int(n) for n in stdin[_].split()]\n        roofs.append([x, y])\n    clouds.sort(key=lambda x: x[1])\n    clouds.sort(key=lambda x: x[3], reverse=True)\n    route = []\n    rain = 0\n    for cloud in clouds:\n        if cloud[1] + cloud[3] * (t - 1) <= d:\n            rain += cloud[3]\n        elif cloud[1] < d:\n            rain += (d - cloud[1]) / cloud[2]\n        if d in route:\n            break\n        route.append(cloud[1])\n    for roof in roofs:\n        if roof[0] + roof[1] <= d:\n            rain += roof[1] * t - (d - roof[0])\n        if d in route:\n            break\n        route.append(roof[0])\n    return rain\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''Given the inputs for the problem, returns the minimum amount of rain\n    that will fall on the route if the bus is now leaving within t seconds'''\n    pass\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get input and return solution to problem.\n\n    Parameters:\n    stdin(str): the input to the program\n\n    Returns:\n    str: the solution to the problem to the input\n    \"\"\"\n    # Create a list of input values\n    in_values = []\n    for line in stdin.split('\\n'):\n        # Create a list of strings\n        values = line.split()\n        # Create a list of floats\n        values = list(map(float, values))\n        in_values.append(values)\n    # Create a list of lists of floats\n    in_values = list(map(list, in_values))\n    # Create a list of lists of floats\n    # for each input string\n    #   get values from input\n    #   convert to float\n    #   add to list\n    #   create list of floats\n\n    # Print the value\n    return f'{rain(in_values):.5f}'\n\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\n\n    Parameters\n    ----------\n    stdin : str\n        The standard input.\n\n    Returns\n    -------\n    str\n        The standard output.\n\n    \"\"\"\n    _, d, t, c, r = stdin.split()\n    d = int(d)\n    t = int(t)\n    c = int(c)\n    r = int(r)\n\n    prob = []\n    for _ in range(c):\n        s, e, p, a = stdin.split()\n        prob.append((int(s), int(e), float(p), int(a)))\n    prob.sort(key=lambda p: p[0])\n\n    cur = 0\n    total = 0\n    for s, e, p, a in prob:\n        if s >= cur:\n            total += a * p\n            cur += a * p\n        else:\n            total += (a - cur) * p\n            break\n    for s, e, p, a in prob[::-1]:\n        if s >= cur:\n            total -= a * p\n            cur -= a * p\n        else:\n            total -= (a - cur) * p\n            break\n\n    return total * (t + d)\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    # this is the maximum number of clouds that can be counted on\n    # this should be the number of clouds from the input\n    max_clouds = int(stdin.split()[-1])\n\n    # the distance between the bus and the bus stop\n    bus_stop_distance = int(stdin.split()[1])\n\n    # the maximum time in seconds that the bus will stop\n    max_time = int(stdin.split()[2])\n\n    # the number of roofs\n    num_roofs = int(stdin.split()[3])\n\n    # The distance between each of the roofs\n    roof_distance = int(stdin.split()[num_roofs + 2])\n\n    # the probabilities of rain in each zip code\n    cloud_probabilities = [float(c) for c in stdin.split()[4:4 + max_clouds]]\n\n    # the number of points along the distance between each pair of roofs\n    # this is used to generate the number of clouds between each pair of roofs\n    roof_distance_points = int(math.floor(bus_stop_distance / roof_distance))\n\n    # the number of clouds along the distance between each pair of roofs\n    num_clouds = int(roof_distance_points * (roof_distance_points - 1) / 2)\n\n    # initialize a list to hold the number of clouds between each pair of roofs\n    cloud_indexes = [0] * num_clouds\n\n    # the first cloud is always from the bus stop to the first roof\n    cloud_indexes[0] = 0\n\n    # initialize a list to hold the rain in nm between each pair of roofs\n    cloud_data = [0] * num_clouds\n\n    # get the rain in nm between each pair of roofs\n    for i in range(num_clouds):\n        # get the cloud data\n        c_data = [float(c) for c in stdin.split()[4 + i * 4: 4 + (i + 1) * 4]]\n\n        # the index of the cloud between this pair of roofs\n        cloud_index = cloud_indexes[i]\n\n        # set the cloud data\n        cloud_data[cloud_index] = c_data\n\n        # find the next index in the list\n        for j in range(cloud_indexes[i] + 1, num_clouds):\n            # if the next index is found, set the rain in nm between the two\n            if cloud_indexes[j] == j:\n                cloud_indexes[j] = cloud_index + 1\n                break\n\n            # if the next index is not found, set the next index to be one more\n            # than the previous one\n            else:\n                cloud_indexes[j] = cloud_indexes[j - 1] + 1\n\n    # create a list of tuples of the rain in nm between each pair of roofs\n    rain_data = list(zip(cloud_indexes, cloud_data))\n\n    # create a list to hold the amount of rain in nm between each pair of roofs\n    tot_rain_data = [0] * num_clouds\n\n    # the index of the cloud in the list of tuples\n    rain_index = 0\n\n    # loop through the list of tuples of the rain in nm between each pair of roofs\n    for i in range(num_clouds):\n        # if the next cloud is reached, add the rain in nm between the two\n        # to the total rain in nm between the two\n        if rain_index == len(rain_data):\n            tot_rain_data[i] = tot_rain_data[i - 1] + rain_data[rain_index - 1][1][0]\n        else:\n            # if the next cloud is not reached, add the next tuple in the\n            # list of tuples of the rain in nm between each pair of roofs\n            # to the total rain in nm between the two\n            tot_rain_data[i] = tot_rain_data[i - 1] + rain_data[rain_index][1][0]\n\n        # move to the next tuple in the list of tuples of the rain in nm between\n        # each pair of roofs\n        rain_index += 1\n\n    # create a list to hold the rain in nm for each of the roofs\n    roof_data = [0] * num_roofs\n\n    # loop through the list of tuples of the rain in nm between each pair of roofs\n    for i in range(num_roofs):\n        # the index of the roof in the list of tuples\n        roof_index = int(stdin.split()[i * 2 + 4])\n\n        # the index of the cloud in the list of tuples\n        cloud_index = int(stdin.split()[i * 2 + 6])\n\n        # set the roof data\n        roof_data[i] = cloud_data[cloud_index][1][roof_index]\n\n    # set the final result to the total rain in nm between each pair of roofs"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your Solution\"\"\"\n    #Convert input from string to an array\n    in_arr = list(map(int, stdin.split(\" \")))\n    d = in_arr[0]\n    t = in_arr[1]\n    c = in_arr[2]\n    r = in_arr[3]\n\n    #Convert from array to dictionary with format cloud_id: [start_time, end_time, rain_amount]\n    cloud_dict = {}\n    for i in range(c):\n        in_arr = list(map(float, stdin.split(\" \")))\n        cloud_dict[i] = [in_arr[0], in_arr[1], in_arr[2]]\n\n    #Calculate the rain in the time period\n    time_sum = 0\n    for i in cloud_dict:\n        time_sum += (cloud_dict[i][1] - cloud_dict[i][0]) * cloud_dict[i][2]\n\n    #Calculate minimum amount of rain in the time period\n    return time_sum/t"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \n    from scipy.optimize import minimize\n    import numpy as np\n    from zip_code_calculator import zip_code_calculator\n    import matplotlib.pyplot as plt\n\n    # Process Input\n    d, t, c, r = list(map(int, stdin.split()))\n    lst = []\n    for _ in range(c):\n        s, e, p, a = list(map(float, stdin.split()))\n        lst.append([s, e, p, a])\n\n    # Calculate distance to bus stop\n    bus_stop = zip_code_calculator(lst)\n\n    # Calculate max rain to get to bus stop in time\n    def minim(p):\n        return t - e + a * (p - s)\n\n    t_start = t\n    rain_start = np.zeros(c)\n\n    for i in range(c):\n        t = minim(lst[i][0])\n        if t < 0:\n            t_start = t\n            rain_start[i] = minim(lst[i][0])\n        else:\n            if t_start > t:\n                t_start = t\n                rain_start[i] = minim(lst[i][0])\n\n    # Calculate expected rain\n    rain_end = np.zeros(c)\n    for i in range(c):\n        t = minim(lst[i][1])\n        if t < 0:\n            rain_end[i] = 0\n        else:\n            if t_start > t:\n                rain_end[i] = 0\n            else:\n                rain_end[i] = t_start - t\n\n    # Plotting the results\n    plt.plot(list(range(c)), rain_start, label='rain at start')\n    plt.plot(list(range(c)), rain_end, label='rain at end')\n    plt.legend()\n    plt.xlabel('cloud')\n    plt.ylabel('rain')\n    plt.show()\n\n    # Create model\n    def f(x):\n        # f(x) = t - e + a * (p - s)\n        # x = [p]\n        return t - e + a * (x[0] - s)\n\n    def df(x):\n        # df(x) = -a\n        return -a\n\n    # Create constraints\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    # x - p = 0\n    "
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(int, stdin.split())\n        clouds.append([s, e, p, a])\n    roofs = []\n    for i in range(r):\n        x, y = map(int, stdin.split())\n        roofs.append([x, y])\n    for i in range(c):\n        clouds[i][0], clouds[i][1], clouds[i][2] = clouds[i][0] * a, clouds[i][1] * a, clouds[i][2] * a\n    for i in range(r):\n        roofs[i][0], roofs[i][1] = roofs[i][0] * a, roofs[i][1] * a\n\n    def simulate_clouds(clouds):\n        pairs = []\n        for c in range(len(clouds)):\n            pair = []\n            for i in range(len(clouds)):\n                if i == c:\n                    pair.append([clouds[i][0], 0])\n                else:\n                    pair.append([clouds[i][1], 0])\n            pairs.append(pair)\n        for i in range(len(pairs)):\n            for j in range(i + 1, len(pairs)):\n                pairs[i][j][1] = min(pairs[i][j][1], pairs[i][j - 1][0] + pairs[i][j][0] + 1)\n                pairs[j][i][1] = min(pairs[j][i][1], pairs[j][i - 1][0] + pairs[j][i][0] + 1)\n        for c in range(len(pairs)):\n            for i in range(len(pairs)):\n                for j in range(i + 1, len(pairs)):\n                    pairs[i][j][1] = min(pairs[i][j][1], pairs[i][j - 1][0] + pairs[i][j][0] + 1,\n                                         pairs[i][c][1] + pairs[j][c][0] + 1)\n        return pairs\n\n    def simulate_roofs(roofs):\n        for i in range(len(roofs)):\n            roofs[i][1] = min(roofs[i][1], roof[i - 1][1] + roof[i][0] + 1)\n            roofs[i][1] = min(roofs[i][1], d - roof[i][1] + 1)\n\n    pairs = simulate_clouds(clouds)\n    roof = simulate_roofs(roofs)\n    days = 0\n    while t > pairs[0][0][1]:\n        for i in range(len(pairs)):\n            pairs[i][0][1] = max(pairs[i][0][1], pairs[i][0][0] + 1)\n        days += 1\n    return pairs[0][0][1] / days\n\n\nassert solution('20 60 2 1\\n5 15 0.33333 30\\n22 60 0.66666 70\\n0 10') == 466.662\n\nassert solution('3 4 2 1\\n1 3 0.25 8\\n2 4 0.66667 15\\n1 2') == 10.00005\n\nassert solution('3 4 1 0\\n0 2 0.25 8') == 2.0\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum amount of rain in nm that will cover all the clouds in the input\"\"\"\n    return str(stdin)\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    offer = []\n    request = []\n    for line in stdin.readlines():\n        (offer_name, request_name, rate) = line.split(' ')\n        offer.append((offer_name, float(rate)))\n        request.append((request_name, float(rate)))\n    offer.sort(key=lambda t: t[1], reverse=True)\n    request.sort(key=lambda t: t[1], reverse=True)\n    offer_names = list(map(lambda t: t[0], offer))\n    request_names = list(map(lambda t: t[0], request))\n    blue = 10\n    for i in range(len(offer_names)):\n        if blue >= 10:\n            break\n        elif offer_names[i] in request_names:\n            blue += offer[i][1]/request[request_names.index(offer_names[i])][1]*10\n    return str(blue)\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().rstrip())\n    lemonade = [[0, 0]] * (n + 1)\n    for line in stdin:\n        s = line.split(' ')\n        lemonade[int(s[0])] = [s[1], float(s[2])]\n    current_profit = 0\n    for i in range(1, n + 1):\n        if lemonade[i][0] == 'blue':\n            current_profit += 0.5 * (1 / lemonade[i][1])\n        else:\n            if current_profit >= 10:\n                current_profit = 10\n            else:\n                current_profit += 0.5 * (1 / lemonade[i][1])\n    return str(round(current_profit, 6))\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    total_blue = 0\n    total_money = 0\n    for line in stdin.splitlines():\n        child_name, lemon_name, rate = line.split()\n        blue = int(lemon_name[:-1])\n        money = float(rate)\n        total_blue += blue\n        total_money += blue * money\n    return f\"{total_money:.6f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to problem #15\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... blue pink 1.0\n   ... red pink 1.5\n   ... blue red 1.0''')\n    '1.500000000000000'\n    >>> solution('''4\n   ... orange pink 1.9\n   ... yellow orange 1.9\n   ... green yellow 1.9\n   ... blue green 1.9''')\n    '10.000000000000000'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n: number of children\n    m: number of trades\n    r: exchange rate\n    '''\n    n, m, r = [int(i) for i in stdin.split()]\n    trades = [i.split() for i in stdin.split('\\n')][1:m + 1]\n    trades = sorted(trades, key=lambda x: float(x[2]))\n\n    total_blue = 0\n    total_orange = 0\n\n    for i, j in trades:\n        if i == 'blue':\n            total_blue += int(j) * float(r)\n        elif i == 'orange':\n            total_orange += int(j) * float(r)\n    \n    if total_orange > total_blue:\n        return round(total_blue, 6)\n    return round(total_orange, 6)\n    \n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    lemonade = [list(map(str, input().split())) for _ in range(N)]\n    blue_count = 10**6\n    for row in lemonade:\n        if row[0] == 'blue':\n            blue_count -= float(row[1])\n        elif row[0] == 'green':\n            blue_count += float(row[1])\n        else:\n            blue_count += float(row[1]) * float(row[2])\n        if blue_count > 10:\n            blue_count = 10\n    return str(blue_count)"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lemonade = [tuple(stdin.readline().strip().split()) for i in range(n)]\n    return str(max([float(x) for x, y, z in lemonade]))\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    calculate blue lemonade\n    \"\"\"\n    \n    lines = stdin.splitlines()\n    num_child = int(lines[0])\n    lines = lines[1:]\n\n    lemonade_stock = {}\n    for line in lines:\n        lemonade_type, price = line.split()\n        lemonade_stock[lemonade_type] = int(price)\n\n    max_lemonade = 0\n    for line in lines:\n        lemonade_type, price = line.split()\n        exchange_rate = float(price)\n        num_lemonade = lemonade_stock[lemonade_type]\n        num_new_lemonade = num_lemonade / exchange_rate\n        if num_new_lemonade > max_lemonade:\n            max_lemonade = int(num_new_lemonade)\n        else:\n            max_lemonade = max_lemonade\n\n    return max_lemonade\n\nprint(solution(\"\"\"3\nblue pink 1.0\nred pink 1.5\nblue red 1.0\"\"\"))\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the number of different dinner experiences that can be made.\n\n    Parameters\n    ----------\n    stdin : str\n        Input containing information about ingredients, the starter dishes, the main dishes, and the desserts.\n\n    Returns\n    -------\n    str\n        The number of different dinner experiences.\n    \"\"\"\n    # The main dish has 3 different ingredients, the starter dishes have 1\n    # ingredient, the dessert has 1 and the third main dish has 2.\n    # They must also have at least 1 common ingredient\n    r, s, m, d, n = map(int, stdin.split())\n    print(r, s, m, d, n)\n    ingredients = {}\n    for _ in range(r):\n        ingredients[_] = set()\n    for _ in range(r):\n        num = int(input())\n        for __ in range(num):\n            ingredients[_].add(int(input()))\n    # print(ingredients)\n    ingredient_counts = [0] * r\n    for _ in range(s):\n        num = int(input())\n        for __ in range(num):\n            ingredient_counts[int(input())-1] += 1\n    for _ in range(m):\n        num = int(input())\n        for __ in range(num):\n            ingredient_counts[int(input())-1] += 2\n    for _ in range(d):\n        num = int(input())\n        for __ in range(num):\n            ingredient_counts[int(input())-1] += 3\n    # print(ingredient_counts)\n    # We can have at most one common ingredient with all starter dishes, one common ingredient with all main dishes, and one common ingredient with all desserts\n    all_ingredients = set()\n    for _ in range(r):\n        all_ingredients.update(ingredients[_])\n    print(all_ingredients)\n    s1 = set([x for x in all_ingredients if ingredient_counts[x-1] == 1])\n    s2 = set([x for x in all_ingredients if ingredient_counts[x-1] == 2])\n    s3 = set([x for x in all_ingredients if ingredient_counts[x-1] == 3])\n    print(s1, s2, s3)\n    s = s1.intersection(s2).intersection(s3)\n    print(s)\n    num_possible_experiences = len(s) * 3**n\n    print(num_possible_experiences)\n    if num_possible_experiences < 10**18:\n        return str(num_possible_experiences)\n    return \"too many\"\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'too many' if count_pairs_of_dishes(stdin) > 10**18 else str(count_pairs_of_dishes(stdin))\n\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_ingredients = int(stdin.split(\"\\n\")[0].split()[0])\n    num_brands = int(stdin.split(\"\\n\")[0].split()[1])\n    num_dishes = int(stdin.split(\"\\n\")[0].split()[2])\n    num_incompatible_pairs = int(stdin.split(\"\\n\")[0].split()[3])\n    total_possible_dishes = num_ingredients ** num_dishes\n    num_ingredients_left = num_ingredients\n    total_possible_dishes_left = num_dishes\n    for line in stdin.split(\"\\n\")[1:]:\n        if len(line.split()) == 1:\n            num_ingredients_left = int(line)\n            num_brands_left = num_ingredients\n        else:\n            num_brands_left = int(line.split()[0])\n            ingredients = line.split()[1:]\n            total_possible_dishes_left -= 1\n            for i in range(num_brands_left):\n                for j in range(num_brands):\n                    if ingredients[i] in all_ingredients[j]:\n                        all_ingredients[j].remove(ingredients[i])\n            num_ingredients_left -= num_brands_left\n            if num_ingredients_left > 0:\n                for i in range(num_brands_left):\n                    for j in range(num_brands):\n                        if ingredients[i] in all_ingredients[j]:\n                            all_ingredients[j].remove(ingredients[i])\n    total_possible_dishes_left -= num_incompatible_pairs\n    if total_possible_dishes_left == 0:\n        return \"0\"\n    dishes = []\n    for i in range(num_dishes):\n        for j in range(num_dishes):\n            if i == j:\n                continue\n            for k in range(total_possible_dishes_left):\n                if k not in dishes:\n                    dishes.append(k)\n    return str(len(list(combinations(dishes, total_possible_dishes_left))))\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'too many' # Put your return value here\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Tr\u1ea3 v\u1ec1 chu\u1ed7i \u0111\u1ea7u v\u00e0o t\u1eeb stdin sau khi \u0111\u00e3 x\u1eed l\u00fd.\"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    num = stdin.split()\n    num = [int(num[i]) for i in range(len(num))]\n    num_of_ingredient = num[0]\n    num_of_dishes = num[1]\n    num_of_dishes_with_ingredient = num[2]\n    ingredient_types = num[3]\n    possible_dishes_per_type = num[4]\n    dish_ingredient_dict = {}\n    for i in range(num_of_ingredient):\n        ingredient_types = num[5+i]\n        possible_dishes = []\n        for j in range(ingredient_types):\n            possible_dishes += [int(num[5+num_of_ingredient+j])]\n        dish_ingredient_dict[i+1] = possible_dishes\n\n    dish_list = []\n    for k in range(num_of_dishes):\n        dish_list.append(int(num[5+num_of_ingredient+num_of_dishes]))\n    \n    count = 0\n    dish_pairs = []\n    for k in range(num_of_dishes_with_ingredient):\n        dish_pairs.append(tuple(map(int, num[5+num_of_ingredient+num_of_dishes+k].split())))\n\n    for k in range(num_of_dishes):\n        dish_dict = {}\n        for dish in dish_list:\n            for ingredient in dish_ingredient_dict[dish]:\n                if ingredient not in dish_dict:\n                    dish_dict[ingredient] = 0\n                dish_dict[ingredient] += 1\n        for pair in dish_pairs:\n            if dish_dict[pair[0]] >= 2 and dish_dict[pair[1]] >= 2:\n                dish_dict[pair[0]] -= 2\n                dish_dict[pair[1]] -= 2\n        \n        flag = False\n        for i in dish_dict:\n            if dish_dict[i] > 1:\n                flag = True\n                break\n        if flag:\n            continue\n        count += 1\n    if count > 10**18:\n        return \"too many\"\n    return str(count)"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the maximum number of different dinner experiments that can be made based on the instructions in the input string.\"\"\"\n    # Replace this with your code\n    pass\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\n    return \"\".join(stdin.split())"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''6 1 1 1 0\n   ... 2 3 1 5 3 2\n   ... 2 1 2\n   ... 3 3 4 5\n   ... 1 6\n   ... ''')\n    '180'\n    >>> solution('''3 1 1 1 1\n   ... 5 5 5\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 2 1\n   ... ''')\n    '0'\n    >>> solution('''3 2 2 1 1\n   ... 2 3 2\n   ... 1 1\n   ... 1 2\n   ... 1 2\n   ... 1 3\n   ... 1 1\n   ... 2 3\n   ... ''')\n    '22'\n    \"\"\"\n    count = 0\n    ingredients, all_possible = read_input(stdin)\n    possible_pairs = []\n    for starter, main, dessert in itertools.combinations(all_possible, 3):\n        if possible(starter, main, dessert):\n            possible_pairs.append((starter, main, dessert))\n    for pair in itertools.combinations(possible_pairs, 2):\n        for ingredient in ingredients:\n            if not ingredient_in_pair(ingredient, pair):\n                break\n        else:\n            count += 1\n    return str(count) if count < 10 ** 18 else 'too many'\n\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n\n    s = stdin.split('\\n')\n    ingredients, _, dishes = s[:3], s[3:-1], s[-1]\n    ingredients = [list(map(int, i.split())) for i in ingredients]\n    dishes = [[int(j) for j in i.split()] for i in dishes]\n    ingredients = list(itertools.chain(*ingredients))\n    dishes = list(itertools.chain(*dishes))\n    all_ingredients = set(ingredients)\n    dishes = list(set(dishes))\n    forbidden_pairs = set()\n    for i in dishes:\n        for j in dishes:\n            if i!= j:\n                forbidden_pairs.add(tuple(sorted((i, j))))\n    number_of_unique_pairs = len(forbidden_pairs)\n    number_of_possible_pairs = len(ingredients) * len(dishes)\n    if number_of_possible_pairs < number_of_unique_pairs:\n        return 'too many'\n    # if number_of_unique_pairs > 10**18:\n    #     return 'too many'\n    return str(number_of_unique_pairs)\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"6 8 5\\n........\\n...#....\\n########\\n#..#...#\\n#..#####\\n#.......\\nu 3\\nr 7\\nd 2\\nl 4\\n3 3 2\\n...\\n.#.\\n...\\nup 2\\nr 2\")\n    '20 20'\n    \"\"\"\n    # line_h, line_w, total_lines = [int(x) for x in stdin.split(\" \")]\n\n    # pattern = [[\".\"] * line_w] * line_h\n    # for i in range(total_lines):\n    #     input_line = stdin.readline()\n    #     line_commands = [x for x in input_line.split(\" \")]\n    #     if line_commands[0] == \"u\":\n    #         move_line = 0\n    #     elif line_commands[0] == \"d\":\n    #         move_line = line_h - 1\n    #     elif line_commands[0] == \"r\":\n    #         move_line = line_w - 1\n    #     elif line_commands[0] == \"l\":\n    #         move_line = 0\n    #     elif line_commands[0] == \"up\":\n    #         move_line -= int(line_commands[1])\n    #     elif line_commands[0] == \"down\":\n    #         move_line += int(line_commands[1])\n    #     elif line_commands[0] == \"right\":\n    #         move_line += 1\n    #     elif line_commands[0] == \"left\":\n    #         move_line -= 1\n    #     else:\n    #         raise ValueError(\"Invalid command\")\n    #     if move_line < 0:\n    #         move_line = 0\n    #     if move_line >= line_w:\n    #         move_line = line_w - 1\n    #     pattern[move_line] = list(line_commands[1])\n    #     # pattern[move_line] = list(\".\" * len(line_commands[1]))\n\n    # rows_and_columns_of_pattern = list(zip(*pattern))\n    # rows_of_pattern = [list(x) for x in rows_and_columns_of_pattern]\n    # rows_of_pattern_set = {tuple(x) for x in rows_of_pattern}\n\n    # max_row = max(rows_of_pattern_set)\n    # min_row = min(rows_of_pattern_set)\n    # min_row_timestamp = pattern.index(min_row)\n    # max_row_timestamp = pattern.index(max_row)\n    # return f\"{min_row_timestamp} {max_row_timestamp}\"\n    line_h, line_w, total_lines = [int(x) for x in stdin.split(\" \")]\n    start_row = [[\".\"] * line_w] * line_h\n    pattern = start_row\n    for i in range(total_lines):\n        input_line = stdin.readline()\n        line_commands = [x for x in input_line.split(\" \")]\n        if line_commands[0] == \"u\":\n            move_line = 0\n        elif line_commands[0] == \"d\":\n            move_line = line_h - 1\n        elif line_commands[0] == \"r\":\n            move_line = line_w - 1\n        elif line_commands[0] == \"l\":\n            move_line = 0\n        elif line_commands[0] == \"up\":\n            move_line -= int(line_commands[1])\n        elif line_commands[0] == \"down\":\n            move_line += int(line_commands[1])\n        elif line_commands[0] == \"right\":\n            move_line += 1\n        elif line_commands[0] == \"left\":\n            move_line -= 1\n        else:\n            raise ValueError(\"Invalid command\")\n        if move_line < 0:\n            move_line = 0\n        if move_line >= line_w:\n            move_line = line_w - 1\n        pattern[move_line] = list(line_commands[1])\n        # pattern[move_line] = list(\".\" * len(line_commands[1]))\n\n    rows_and_columns_of_pattern = list(zip(*pattern))\n    rows_of_pattern = [list(x) for x in rows_and_columns_of_pattern]\n    rows_of_pattern_set = {tuple(x) for x in rows_of_pattern}\n\n    max_row = max(rows_of_pattern_set)\n    min_row = min(rows_of_pattern_set)\n    min_row_timestamp = pattern.index(min_row)\n    max"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This solution uses a BFS to find the shortest path.\n    At every point on the board we check if the current\n    point has a marker. We update this to the previous point,\n    since the marker could have already cleaned up the path.\n    We run a BFS to get the shortest path.\n    '''\n    h, w, n = map(int, stdin.split())\n    path = [[None] * w for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if stdin[i][j] == '#':\n                path[i][j] = (i, j)\n    moves = [stdin[i][j] for i in range(h) for j in range(w) if stdin[i][j] in 'udlr']\n    directions = {'u': (-1, 0), 'd': (1, 0), 'l': (0, -1), 'r': (0, 1)}\n    i = 0\n    while i < n:\n        for move in moves:\n            x, y = path[0][0]\n            i += 1\n            d = directions[move]\n            path[0][0] = path[x + d[0]][y + d[1]]\n            if path[0][0] is None:\n                return str(i - 1) +'' + str(i)\n    return '-1 -1'\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Hint:\n    You will need to keep track of where you are on the grid.\n    You can do this by keeping a tuple of the form (row, col) of\n    your current position.\n\n    You will need to also keep track of where you want to end up,\n    which is given as a pair of tuples in the format (row, col).\n    '''\n    '''\n    You will need to keep track of where you are on the grid.\n    You can do this by keeping a tuple of the form (row, col) of\n    your current position.\n\n    You will need to also keep track of where you want to end up,\n    which is given as a pair of tuples in the format (row, col).\n    '''\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [[] for _ in range(h)]\n    for i in range(h):\n        board[i] = list(stdin[i * w:(i + 1) * w])\n    for i in range(n):\n        direction, distance = stdin.split()[i].split()\n        distance = int(distance)\n        if direction == \"up\":\n            for _ in range(distance):\n                for j in range(h):\n                    if board[j].count(\"#\") == 0:\n                        board[j] = [\".\"] * w\n                    else:\n                        board[j][board[j].index(\"#\")] = \".\"\n                        board[j].append(\"#\")\n        elif direction == \"down\":\n            for _ in range(distance):\n                for j in range(h):\n                    if board[j].count(\"#\") == 0:\n                        board[j] = [\".\"] * w\n                    else:\n                        board[j].insert(0, \".\")\n                        board[j][board[j].index(\"#\")] = \"#\"\n        elif direction == \"left\":\n            for _ in range(distance):\n                for j in range(w):\n                    if board[0][j].count(\"#\") == 0:\n                        for i in range(h):\n                            board[i][j] = \".\"\n                    else:\n                        for i in range(h):\n                            board[i][j] = \".\"\n                        board[h - 1][j] = \"#\"\n        else:\n            for _ in range(distance):\n                for j in range(w):\n                    if board[0][j].count(\"#\") == 0:\n                        for i in range(h):\n                            board[i][j] = \".\"\n                    else:\n                        board[0][j] = \"#\"\n                        for i in range(h - 1):\n                            board[i][j] = \".\"\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == \"#\":\n                print(i, j)"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the min and max time that will pass before the marker dries out\"\"\"\n    _, h, w, n = stdin.split(\" \")\n    h, w, n = int(h), int(w), int(n)\n    board = [['.' for _ in range(w)] for _ in range(h)]\n    for _ in range(n):\n        d, dm = stdin.split(\" \")\n        if d == \"up\":\n            for _ in range(int(dm)):\n                for i in range(h):\n                    for j in range(w):\n                        if board[i][j] == '#':\n                            board[i][j] = '.'\n        elif d == \"down\":\n            for _ in range(int(dm)):\n                board.reverse()\n                board.reverse()\n                board.reverse()\n        elif d == \"left\":\n            for _ in range(int(dm)):\n                for j in range(w):\n                    for i in range(h):\n                        if board[i][j] == '#':\n                            board[i][j] = '.'\n        else:\n            for _ in range(int(dm)):\n                for j in range(w):\n                    for i in range(h):\n                        if board[i][j] == '#':\n                            board[i][j] = '.'\n    return f\"{min(i for i in range(h) for j in range(w) if board[i][j] == '#')} {max(i for i in range(h) for j in range(w) if board[i][j] == '#')}\"\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get max and min timestamp for marker to dry out\"\"\"\n    height, width, commands = [int(x) for x in stdin.split(' ')]\n    board = [['#'] * width for _ in range(height)]\n\n    for i in range(commands):\n        direction, distance = stdin.split(' ')\n        direction = direction.lower()\n        distance = int(distance)\n\n        if direction == 'up':\n            for j in range(distance):\n                board = move_up(board)\n        elif direction == 'down':\n            for j in range(distance):\n                board = move_down(board)\n        elif direction == 'left':\n            for j in range(distance):\n                board = move_left(board)\n        elif direction == 'right':\n            for j in range(distance):\n                board = move_right(board)\n        else:\n            raise ValueError('Unknown direction')\n\n    return f'{min_timestamp(board)} {max_timestamp(board)}'\n\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: input in string format\n    :return: solution in string format\n    \"\"\"\n    # Your code goes here\n    # pass\n    # return ''\n    height, width, commands = [int(x) for x in stdin.split(' ')]\n    start = (0, 0)\n    board = [['.'] * width for _ in range(height)]\n    for _ in range(commands):\n        cmd, step = stdin.split(' ')[:2]\n        cmd = cmd.lower()\n        step = int(step)\n        if cmd == 'right':\n            start = (start[0], start[1] + step)\n        elif cmd == 'left':\n            start = (start[0], start[1] - step)\n        elif cmd == 'up':\n            start = (start[0] - step, start[1])\n        elif cmd == 'down':\n            start = (start[0] + step, start[1])\n        else:\n            raise Exception('unknown cmd')\n\n        if start[0] >= height or start[1] >= width or start[0] < 0 or start[1] < 0:\n            return '-1 -1'\n        board[start[0]][start[1]] = '#'\n\n    min_time = 0\n    max_time = 0\n    for i in range(height):\n        for j in range(width):\n            if board[i][j] == '#':\n                min_time = max(min_time, i + 1)\n                max_time = max(max_time, i + 1)\n    if min_time > max_time:\n        return '-1 -1'\n    return f'{min_time} {max_time}'\n\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    total_size = int(stdin.split('\\n')[0])\n    total_required = int(stdin.split('\\n')[1])\n    number_of_companies = int(stdin.split('\\n')[2])\n    max_in_company = [int(n) for n in stdin.split('\\n')[3:]]\n    i = 3\n    num_in_company = [0] * number_of_companies\n    while i < number_of_companies + 3:\n        num_in_company[i - 3] = max_in_company[i - 3]\n        i += 1\n    min_num = total_required\n    j = 0\n    while j < number_of_companies:\n        temp = total_size\n        temp_num = num_in_company[j]\n        temp_required = total_required\n        k = 0\n        while k < temp_num:\n            temp -= temp_required\n            if temp < 0:\n                min_num = -1\n                break\n            temp_required -= temp_required / temp_num\n            temp_required = int(temp_required)\n            k += 1\n        if k == temp_num:\n            j += 1\n            total_required -= total_required / temp_num\n            total_required = int(total_required)\n        else:\n            min_num = -1\n    print(min_num)\n    return min_num\n\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the cheapest package that is guaranteed to contain at least B bolts, using k different companies.\n\n    >>> solution(\"371\\n3\\n2 40 65\\n2 100 150\\n2 300 320\")\n    'impossible'\n    >>> solution(\"310\\n3\\n2 40 65\\n2 100 150\\n2 300 320\")\n    '300'\n    \"\"\"\n    return (\n        \"impossible\"\n        if int(stdin.splitlines()[0]) > sum([max(tuple(map(int, l.split(\" \")))) * n for l in stdin.splitlines()[2:]])\n        else min(\n            [\n                int(stdin.splitlines()[0]),\n                sum([max(tuple(map(int, l.split(\" \")))) * n for l in stdin.splitlines()[2:]]),\n            ]\n        )\n    )\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('371\\n3\\n2 40 65\\n2 100 150\\n2 300 320')\n    'impossible'\n    >>> solution('310\\n3\\n2 40 65\\n2 100 150\\n2 300 320')\n    '300'\n    \"\"\"\n    # Solve the problem by hand by finding the best combination\n    #  of packages by hand first. Then try to solve the problem\n    #  by attempting to do it with a brute force search.\n    #\n    # Note that we are not given any information about the\n    #  amount of bolts in each of the packages.\n    #\n    # See the below links for more information on how to find\n    # the minimum amount of packages to contain a certain number\n    # of bolts.\n    #\n    # https://www.quora.com/How-do-I-find-the-minimum-amount-of-packages-to-contain-a-certain-number-of-bolts\n    #\n    # https://en.wikipedia.org/wiki/Knapsack_problem\n    #\n    # The above wiki pages give an overview of the problem and\n    #  provide a starting point for solving the problem.\n    #\n    # Below is the pseudocode for a brute force search.\n    #  It is similar to the first solution, except that\n    #  it includes a linear search over all possible\n    #  combinations of packages.\n    #\n    # The linear search is not necessary, but it is\n    #  also not a very efficient way of finding the\n    #  smallest amount of packages. If we had a way to\n    #  efficiently calculate the amount of packages to\n    #  contain a certain number of bolts, then we could\n    #  use a binary search.\n    #\n    #\n    # function minimum_packages_to_contain_bolts(n_bolts: int) -> int\n    #     min_amount_of_packages = math.inf\n    #     for i in 1..n_packages:\n    #         for j in 1..i:\n    #             if sum_amount_of_packages_with_i_and_j_packages(i, j, n_packages) >= n_bolts:\n    #                 if sum_amount_of_packages_with_i_and_j_packages(i, j, n_packages) < min_amount_of_packages:\n    #                     min_amount_of_packages = sum_amount_of_packages_with_i_and_j_packages(i, j, n_packages)\n    #     return min_amount_of_packages\n    #\n    #\n    # function sum_amount_of_packages_with_i_and_j_packages(i: int, j: int, n_packages: int) -> int\n    #     min_amount = math.inf\n    #     for k in 1..n_packages:\n    #         if i*n_packages + j*n_packages + k*n_packages <= n_bolts:\n    #             if i*n_packages + j*n_packages + k*n_packages < min_amount:\n    #                 min_amount = i*n_packages + j*n_packages + k*n_packages\n    #     return min_amount\n    #\n    # Sample Run 1\n    # B = 10\n    #\n    # k = 3\n    #\n    # l = [2, 40, 65]\n    #\n    # n = [2, 100, 150]\n    #\n    # Packages\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    # 0 1 2\n    "
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimal size of a package that contains at least B\n    amount of bolts, given that a company produces packages of sizes\n    in the format [l1, n1, n2,..., nk] where l1 is the number of\n    types of a package, n1 the number of bolts of type 1, n2 the number\n    of bolts of type 2 and so on.\n\n    Args:\n        stdin (str): Input string to parse\n\n    Returns:\n        str: Output string\n    \"\"\"\n    #Your code here\n    return \"\"\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, k = [int(i) for i in stdin.splitlines()]\n    print(k)\n    packs = [list(map(int, i.split())) for i in stdin.splitlines()[1:]]\n    print(packs)\n    max_weight = max(packs)[0]\n    min_weight = min(packs)[0]\n    max_packs = max(packs)[1]\n    print(max_weight, min_weight, max_packs)\n    answer = min(max_weight - min_weight + 1, max_packs - min_weight)\n    '''\n    n = int(stdin.splitlines()[0])\n    print(n)\n    k = int(stdin.splitlines()[1])\n    print(k)\n    packs = [list(map(int, i.split())) for i in stdin.splitlines()[2:]]\n    print(packs)\n    pack_dict = {}\n    for pack in packs:\n        pack_type = pack[0]\n        if pack_type not in pack_dict:\n            pack_dict[pack_type] = []\n        for weight in pack[1:]:\n            pack_dict[pack_type].append(weight)\n    print(pack_dict)\n    min_weight = min([min(i) for i in pack_dict.values()])\n    print(min_weight)\n    max_weight = max([max(i) for i in pack_dict.values()])\n    print(max_weight)\n    answer = min(max_weight - min_weight + 1, n - min_weight + 1)\n    print(answer)\n    return answer\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    _, k = map(int, stdin.split('\\n')[:2])\n    d = [[int(x) for x in stdin.split('\\n')[2:][i].split(' ')]\n         for i in range(k)]\n    s = sum([sum(x) for x in d])\n    if s < B:\n        return 'impossible'\n    l = [max([sum(x) for x in zip(*z)]) for z in zip(*d)]\n    return sorted(list(filter(lambda x: x >= B, l)))[0]\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    B = int(stdin.splitlines()[0])\n    k = int(stdin.splitlines()[1])\n    packages = {}\n    for i in range(k):\n        nums = stdin.splitlines()[2 + i].split()\n        l, *nums = nums\n        nums = [int(n) for n in nums]\n        packages[int(l)] = nums\n    \n    def can_combine(package_amounts):\n        return sum(package_amounts) >= B\n    \n    for i in range(1, k + 1):\n        for package_amounts in itertools.combinations(packages[i], i):\n            if package_amounts:\n                package_amounts = sorted(package_amounts)\n                if can_combine(package_amounts):\n                    return package_amounts[0]\n            else:\n                continue\n    return 'impossible'\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin.readline().strip())\n    k = int(stdin.readline().strip())\n    \n    tables = []\n    \n    for _ in range(k):\n        l = int(stdin.readline().strip())\n        n = [int(x) for x in stdin.readline().strip().split(' ')]\n        tables.append(n)\n        \n    tables = sorted(tables, key=lambda x: x[0])\n    \n    lowest = 0\n    for table in tables:\n        if table[0] < b:\n            lowest += table[0]\n            b -= table[0]\n        else:\n            lowest += b\n            b = 0\n            break\n            \n    if b:\n        print(\"impossible\")\n    else:\n        print(lowest)\n        \n        \n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \"\" if can_fold(stdin) else \"cannot fold\"\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split('\\n')\n    squares = list()\n    for row in rows:\n        squares.append(list(row))\n    \n    # Check if the rows have the same number of squares\n    n = len(squares)\n    m = len(squares[0])\n    for row in squares:\n        if len(row)!= m:\n            return 'cannot fold'\n    \n    # Check if all the squares are units\n    for row in squares:\n        for square in row:\n            if square!= '#':\n                return 'cannot fold'\n    \n    # Check if the unit squares are connected\n    def is_connected(square: str) -> bool:\n        # Start from each square and make a list of neighbors\n        neighbors = list()\n        x = square[0]\n        y = int(square[1])\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i == j == 0:\n                    continue\n                if x + i < 0 or x + i >= n:\n                    continue\n                if y + j < 0 or y + j >= m:\n                    continue\n                if squares[x + i][y + j] == '#':\n                    neighbors.append(squares[x + i][y + j])\n        \n        # Check that every neighbor is connected to every other neighbor\n        for neighbor in neighbors:\n            if neighbor not in neighbors:\n                return False\n        return True\n    \n    for square in squares[0]:\n        if square!= '#':\n            if not is_connected(square):\n                return 'cannot fold'\n    \n    return 'can fold'\n    "
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"......\\n\"\n    \"#.....\\n\"\n    \"####..\\n\"\n    \"#.....\\n\"\n    \"......\")\n    'can fold'\n    >>> solution(\"..##..\\n\"\n    \"...#..\\n\"\n    \"..##..\\n\"\n    \"#...#.\\n\"\n    \"......\")\n    'cannot fold'\n    \"\"\"\n    squares = stdin.split('\\n')\n    print(squares)\n    for square in squares:\n        if '##' in square or '##' in square[::-1]:\n            return 'can fold'\n    return 'cannot fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\".##.##.##\\n\"\n             \"####.##.##\\n\"\n             \"#.#.#.##.\\n\"\n             \"##...#.#.\\n\"\n             \"##...#.#.\\n\"\n             \"..##.#.#.\")\n    'can fold'\n    >>> solution(\"##.##.##\\n\"\n                \"####.##.##\\n\"\n                \"#.#.#.##.\\n\"\n                \"##...#.#.\\n\"\n                \"##...#.#.\\n\"\n                \"..##.#.#.\")\n    'cannot fold'\n    >>> solution(\".###.#.##\\n\"\n                \"####.###.#\\n\"\n                \"#.#.#.###.\\n\"\n                \"###.##.#.\\n\"\n                \"##...###.\\n\"\n                \"#.#.#.###.\")\n    'cannot fold'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n  A, B = stdin.splitlines()\n  A = A.replace('#', '1')\n  B = B.replace('#', '1')\n  return 'can fold' if A.count('1') == B.count('1') == 6 else 'cannot fold'\n  \n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\nimport numpy as np\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(matrix: List[List[str]]) -> bool:\n        #  scan matrix top-bottom-left-right to check whether there is a cross\n        n_rows, n_cols = len(matrix), len(matrix[0])\n        for i in range(n_rows):\n            for j in range(n_cols):\n                if i == n_rows-1 or j == n_cols-1:\n                    if matrix[i][j]!= matrix[i][0] or matrix[i][j]!= matrix[0][j]:\n                        return False\n                elif matrix[i][j]!= matrix[i][j+1] or matrix[i][j]!= matrix[i+1][j]:\n                    return False\n        return True\n\n    def can_fold(matrix: List[List[str]]) -> bool:\n        #  compare input with cube\n        n_rows, n_cols = len(matrix), len(matrix[0])\n        for i in range(n_rows):\n            for j in range(n_cols):\n                if matrix[i][j] == '#':\n                    if matrix[i][0]!= '#' or matrix[0][j]!= '#':\n                        return False\n        return True\n    \n    matrix = stdin.split('\\n')\n    if is_connected(matrix) and can_fold(matrix):\n        return \"can fold\"\n    return \"cannot fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nimport sys\n\nsys.path.append(\"..\")\n\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin.split(\"\\n\")\n    print(string)\n    for i in range(len(string)):\n        print(string[i])\n        if(i % 2 == 0):\n            for j in range(len(string[i])):\n                print(string[i][j])\n                if(j % 2 == 0):\n                    if(string[i][j]!= '#'):\n                        return \"cannot fold\"\n                else:\n                    if(string[i][j]!= '.'):\n                        return \"cannot fold\"\n        else:\n            for j in range(len(string[i])):\n                print(string[i][j])\n                if(j % 2 == 0):\n                    if(string[i][j]!= '.'):\n                        return \"cannot fold\"\n                else:\n                    if(string[i][j]!= '#'):\n                        return \"cannot fold\"\n    return \"can fold\"\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    input_list = [char for char in stdin]\n    unique_input_list = []\n    for char in input_list:\n        if char not in unique_input_list:\n            unique_input_list.append(char)\n\n    longest_substring = ''\n    for i in range(len(unique_input_list)):\n        substring = unique_input_list[i]\n        for j in range(i, len(unique_input_list)):\n            if substring not in unique_input_list[j:]:\n                if len(substring) > len(longest_substring):\n                    longest_substring = substring\n                break\n            substring += unique_input_list[j]\n\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # 1. Initialize a variable to store the longest substring.\n    # 2. For each possible i, initialize a substring to be the substring up to i.\n    # 3. For each possible j after i, append the character at j to the substring.\n    # 4. If the substring is the same as the longest substring, return the substring.\n    # 5. If the substring is longer than the longest substring, return the substring.\n    # 6. Return the longest substring.\n    longest = \"\"\n    for i in range(len(stdin)):\n        substring = stdin[:i+1]\n        for j in range(i+1, len(stdin)):\n            substring += stdin[j]\n            if substring == stdin:\n                return substring\n            if len(substring) > len(longest):\n                longest = substring\n    return longest\n    # str1 = \"\"\n    # str2 = \"\"\n    # for char in stdin:\n    #     str1 += char\n    #     if str1 in stdin:\n    #         return str1\n    #     if len(str1) > len(str2):\n    #         str2 = str1\n    # return str2\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    hash = {}\n    count = 1\n    res = []\n    for c in stdin:\n        if c not in hash:\n            hash[c] = count\n        else:\n            count += 1\n            res.append(c)\n    res.sort()\n    return ''.join(res)\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest string that repeats more than once in a string\n    :param stdin: a string of lowercase English letters\n    :returns: the longest substring that repeats more than once in a string\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('abcefgabc')\n    'abc'\n    >>> solution('abcbabcba')\n    'abcba'\n    >>> solution('aaaa')\n    'aaa'\n    \"\"\"\n    if len(stdin) < 2:\n        return stdin\n\n    ans = ''\n    max_len = 0\n    d = {}\n    for s in stdin:\n        d[s] = d.get(s, 0) + 1\n        if d[s] == 2:\n            ans = s\n        if d[s] > 2:\n            if len(s) > max_len:\n                max_len = len(s)\n                ans = s\n            elif len(s) == max_len:\n                ans = min(s, ans)\n    return ans\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if len(s) < 2:\n        return s\n    cur = s[0]\n    res = cur\n    for i in range(1, len(s)):\n        if s[i]!= cur[-1]:\n            cur += s[i]\n        else:\n            cur = s[i]\n            if len(cur) > len(res):\n                res = cur\n    return res\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"abcde\")\n    de\n    >>> solution(\"abcdbcd\")\n    dbc\n    >>> solution(\"abcdaabcd\")\n    aabcd\n    \"\"\"\n    if len(stdin) == 0:\n        return \"\"\n\n    # S is the string whose longest repeated substring we are looking for\n    S = \"\"\n    S += stdin[0]\n    seen = {}\n    i = 1\n\n    # We loop from 1 to n - 1, hence we do not need to include i + 1 in the loop\n    for j in range(1, len(stdin)):\n        S += stdin[j]\n\n        # If the current substring (S) has already been seen\n        if S in seen:\n            # If the current substring (S) is longer than what we have seen so far\n            if len(S) > len(seen[S]):\n                # Update our (longest) seen substring\n                seen[S] = S\n        else:\n            # The current substring (S) has not been seen before, so we record it\n            seen[S] = S\n        # At each iteration we update the current substring S\n        S = S[1:]\n\n    # We return the longest substring we found\n    return seen[seen[max(seen, key=len)]]\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return max(sorted(sorted(stdin), key=stdin.index), key=stdin.index)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    result = 0\n    purchase = 0\n    for i in range(N):\n        stdin = stdin.split()\n        zone = int(stdin[0])\n        start = int(stdin[1])\n        end = int(stdin[2])\n        result += (abs(zone - start) + abs(zone - end) + 1)\n        if i + 1!= N:\n            result += 2\n    return str(result)\n    pass\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def solve(l: List) -> int:\n        if not l:\n            return 0\n        return min(\n            solve(l[:j]) + 1 + s.count(0) * (len(l[j:]) + 1)\n            for j, s in enumerate(l)\n            if s\n        )\n\n    n = int(stdin)\n    l = [0] * n\n    for i in range(n):\n        l[i] = list(map(int, stdin.split()))\n    return solve(l)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_of_trips = int(stdin.readline())\n    coupons = 0\n    for _ in range(num_of_trips):\n        i, j = map(int, stdin.readline().split())\n        if i == 0:\n            coupons += j\n        else:\n            coupons += max(0, j - (i - 1))\n    return str(coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.readline())\n    for _ in range(test_cases):\n        stdin.readline()\n        s, t = stdin.readline().split()\n        s = int(s)\n        t = int(t)\n        queue = []\n        queue.append(s)\n        last_trip_end = s\n        while queue:\n            pop = queue.pop()\n            last_trip_end = pop\n            if pop == t:\n                break\n            queue.append(pop + 1)\n            queue.append(pop + 2)\n            queue.append(pop + 3)\n        print(2 + abs(s - t))\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) <= 1:\n        return 0\n    n = int(stdin[0])\n    array = [0] + list(map(int, stdin[1].split()))\n    array.sort()\n    print(array)\n    \n    coupons = 0\n    for i in range(n):\n        coupons += min(2 + abs(array[i+1]-array[i]), 10000 - array[i])\n    return coupons\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # Write your code here\n    # For each trip:\n    #   Figure out which zones are valid\n    #   Calculate number of coupons required\n    #   Minimise coupons required\n    #   If current time is greater than last trip\n    #   Add the number of coupons required\n    #   Set current time as last trip\n    n = int(stdin)\n    coupons = 0\n    for _ in range(n):\n        # Parse input\n        start, end = map(int, stdin.split())\n\n        # Calculate coupons\n        coupons += 2 + abs(start - end)\n\n        # Minimise coupons\n        coupons = min(coupons, 10000)\n\n    print(coupons)\n\nsolution(\"2\\n1 4\\n2 5\")\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    trip_list = []\n    for _ in range(n):\n        start, end = stdin.split(' ')\n        trip_list.append(tuple([int(start), int(end)]))\n    \n    trip_list.sort(key = lambda x: x[0])\n    min_purchase = 0\n    end = 0\n    for start, end in trip_list:\n        if start < end:\n            min_purchase += (end - start) // 2\n        if start == end:\n            min_purchase += 1\n    print(min_purchase)\n    return min_purchase"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution is written by Jihoon in Nov. 28th\n    \"\"\"\n    N = int(stdin)\n    coupons = 0\n    for _ in range(N):\n        zone, start = map(int, stdin.split())\n        if start <= 10000:\n            coupons += zone * 2\n        else:\n            coupons += zone * 2 + (10000 - zone) * 2 + 1\n    print(coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cases = int(stdin.readline())\n    coupons = 0\n    for _ in range(cases):\n        a, b = stdin.readline().split()\n        b = int(b)\n        if a == b:\n            coupons += 0\n        else:\n            coupons += 2 + abs(int(a) - int(b))\n    print(coupons)\n    return ''\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum number of coupons Johan must purchase in order to make all his trips.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: The minimum number of coupons Johan must purchase in order to make all his trips.\n    \"\"\"\n    trips = int(stdin)\n    lines = stdin.split('\\n')\n    coupons = 0\n    start = 0\n    end = 0\n    while trips!= 0:\n        start, end = lines[start].split()\n        start = int(start)\n        end = int(end)\n        coupons += (2 + abs(start - end))\n        trips -= 1\n    return str(coupons)\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    values = list(map(int, input_lines[1].split()))\n    count = 0\n    for i in range(2 ** n):\n        binary_num = bin(i)[2:]\n        for j in range(len(binary_num)):\n            if binary_num[j] == '1':\n                values.sort()\n                if values[j] == values[j + 1]:\n                    break\n                if (j == 0 and binary_num[j + 1] == '1') or (j + 1 == len(binary_num) and binary_num[j] == '1'):\n                    count += 1\n                elif j == 0 and binary_num[j + 1] == '0':\n                    count += 1\n                else:\n                    break\n    return str(count % (10 ** 9 + 7))\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the number of ways of arranging the given nodes into an LCM tree, modulo 10**9 + 7\"\"\"\n    \n    return str(solve(list(map(int, stdin.split()))))\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #Get input\n    line = stdin.split('\\n')\n    n = int(line[0])\n    line = line[1].split(' ')\n    nodes = [int(i) for i in line]\n    \n    #Set up the tree dictionary\n    tree = {}\n    for i in range(len(nodes)):\n        tree[nodes[i]] = [i]\n    \n    #Start with the first node and iterate down\n    sorted_nodes = sorted(nodes)\n    i = 0\n    while i < n:\n        j = 0\n        while j < len(tree[sorted_nodes[i]]):\n            #Do not attempt to set node as child if it has not been set as child in the tree\n            if len(tree[sorted_nodes[i+1]]) == 0:\n                j+=1\n                continue\n            #Get the children of the node\n            children = [sorted_nodes[i+1]]\n            while len(children) > 1:\n                children.append(children[0] + children[1])\n                children.pop(1)\n            \n            #Set the current node as a child of all of the children\n            for child in children:\n                tree[sorted_nodes[i]].append(child)\n            j+=1\n        i+=1\n    \n    #Count the number of paths that end at each node\n    counts = {}\n    for node in tree:\n        count = 1\n        paths = [node]\n        while len(paths) > 0:\n            count *= 2\n            node_id = tree[node].index(paths[0])\n            if node_id == 0:\n                node = paths[0]\n            elif node_id == 1:\n                node = paths[0] + paths[1]\n            else:\n                node = paths[0] + paths[1] + paths[2]\n            paths.pop(0)\n        counts[node] = count\n    \n    #Count the number of ways for each node\n    count = 0\n    for node in sorted_nodes:\n        count += counts[node]\n    return count % (10**9 + 7)\n    \n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''def f(n: int) -> int:\n        if n <= 1:\n            return 1\n        else:\n            return f(n - 1) + f(n - 2)\n    \n    n = int(stdin)\n    return str(f(n))\n    '''\n    n = int(stdin)\n    v = list(map(int, stdin.split()))\n    \n    dp = [0 for _ in range(n)]\n    dp[0] = 1\n    dp[1] = 2 if v[1] % v[0] == 0 else 0\n    for i in range(2, n):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10 ** 9 + 7) if v[i] % v[i - 1] == 0 else 0\n\n    return str(dp[-1])\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # get the values\n    values = list(map(int, stdin.split(' ')))\n\n    # get the indices of the leaf nodes\n    leaf_indices = [i for i in range(len(values)) if len(values) - 1 in values[i:]]\n    leaf_indices.sort()\n\n    # get the indices of the parents\n    parent_indices = [i for i in range(len(values)) if i not in leaf_indices]\n\n    # get the numbers of the leaf nodes\n    leaf_numbers = [values[i] for i in leaf_indices]\n\n    # get the number of the parent nodes\n    parent_numbers = [values[i] for i in parent_indices]\n\n    # get the LCM of each leaf node and each parent node\n    leaf_lcm = [lcm(leaf_numbers[i], parent_numbers[i]) for i in range(len(leaf_numbers))]\n    parent_lcm = [lcm(parent_numbers[i], leaf_numbers[i]) for i in range(len(parent_numbers))]\n\n    # get the number of ways\n    number_of_ways = [leaf_lcm[i] * parent_lcm[i] for i in range(len(leaf_lcm))]\n\n    # get the sum of the number of ways\n    total_number_of_ways = sum(number_of_ways)\n\n    # return the answer\n    return str(total_number_of_ways % 10000000007)"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    line = stdin.readline()\n    nums = [int(num) for num in line.split()]\n    if n == 1:\n        return str(1)\n    nums.sort()\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] += dp[j]\n    return str(dp[-1])\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    lst = list(map(int, stdin.readline().split()))\n    l = len(lst)\n    if l % 2!= 0:\n        print(0)\n        return\n    dp = [0] * (l + 1)\n    dp[0] = 1\n    for i in range(1, l + 1):\n        dp[i] = dp[i - 1]\n        for j in range(2, l - i + 1):\n            if lst[i - 1] % lst[i - j - 1] == 0:\n                dp[i] += dp[i - j]\n            else:\n                break\n    print(dp[-1])\n    return ''\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(solve(parse(stdin)))\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, n_days, max_days = [int(x) for x in stdin.split()]\n    max_row, max_col = rows - 1, cols - 1\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    visited[0][0] = True\n    row, col = 0, 0\n    current_day = 0\n    while current_day < n_days:\n        # print(row, col, max_days, current_day)\n        if current_day < max_days:\n            current_day += 1\n            if row > 0 and not visited[row - 1][col]:\n                row -= 1\n            elif row < max_row and not visited[row + 1][col]:\n                row += 1\n            elif col < max_col and not visited[row][col + 1]:\n                col += 1\n            elif col > 0 and not visited[row][col - 1]:\n                col -= 1\n            visited[row][col] = True\n        else:\n            row, col, current_day = 0, 0, 0\n    if row == max_row and col == max_col:\n        return str(current_day)\n    return str(-1)"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Return your answer\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def check_path(grid: str) -> bool:\n        pos = grid.index('S')\n        if pos[0] < len(grid) - 1 and grid[pos + 1]!= 'M':\n            return False\n        if grid[pos - 1] == 'F':\n            return False\n        if grid[pos + 1] == 'F':\n            return False\n        return True\n\n    def on_path(grid: str, pos: list) -> bool:\n        if grid[pos[0]][pos[1]] == '#':\n            return False\n        return True\n\n    def next_pos(grid: str, pos: list) -> str:\n        if grid[pos[0]][pos[1]] == 'F':\n            return 'F'\n        if grid[pos[0]][pos[1]] == 'M':\n            return 'M'\n        if pos[0] < len(grid) - 1 and grid[pos[0] + 1][pos[1]]!= 'M':\n            return 'D'\n        if pos[0] > 0 and grid[pos[0] - 1][pos[1]]!= 'M':\n            return 'U'\n        if pos[1] < len(grid) - 1 and grid[pos[0]][pos[1] + 1]!= 'M':\n            return 'R'\n        if pos[1] > 0 and grid[pos[0]][pos[1] - 1]!= 'M':\n            return 'L'\n        return '#'\n\n    grid = stdin.split('\\n')\n    days = 0\n    pos = [0, 0]\n    stamina = 10\n    while days < len(grid):\n        if check_path(grid):\n            if on_path(grid, pos):\n                return '-1'\n            pos[0] += 1\n            stamina -= 1\n        else:\n            days += 1\n            stamina += days\n            if stamina < 1:\n                return '-1'\n            if pos[0] > 0 and grid[pos[0] - 1][pos[1]]!= 'M':\n                pos[0] -= 1\n                stamina += 1\n            if pos[1] > 0 and grid[pos[0]][pos[1] - 1]!= 'M':\n                pos[1] -= 1\n                stamina += 1\n            if pos[0] < len(grid) - 1 and grid[pos[0] + 1][pos[1]]!= 'M':\n                pos[0] += 1\n                stamina += 1\n            if pos[1] < len(grid) - 1 and grid[pos[0]][pos[1] + 1]!= 'M':\n                pos[1] += 1\n                stamina += 1\n\n    return days\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(x) for x in stdin.split(' ')]\n    grid = stdin.split('\\n')\n    pos = get_pos(grid, N, M)\n    pos = [pos[0], pos[1]]\n    return max(bfs(grid, pos, K, N, M), -1)\n\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if not stdin.strip():\n        return \"\"\n    rows = stdin.strip().split(\"\\n\")\n    rows = [list(row) for row in rows]\n    max_row = len(rows)\n    max_col = len(rows[0])\n    if rows[0][0] == \"S\" and rows[0][-1] == \"G\":\n        return 0\n    for row in rows:\n        if len(row)!= max_col:\n            return \"-1\"\n        for char in row:\n            if char not in [\"S\", \"G\", \".\", \"#\", \"F\", \"M\"]:\n                return \"-1\"\n    if rows[0][0] not in [\"S\", \"G\"]:\n        return \"-1\"\n    if rows[-1][-1] not in [\"G\", \"S\"]:\n        return \"-1\"\n    for row in rows:\n        if row[0] not in [\"S\", \"G\"]:\n            return \"-1\"\n        if row[-1] not in [\"G\", \"S\"]:\n            return \"-1\"\n\n    #  Find the entry and exit\n    for row in range(max_row):\n        if rows[row][0] == \"S\":\n            start_row = row\n        if rows[row][-1] == \"G\":\n            end_row = row\n\n    for col in range(max_col):\n        if rows[0][col] == \"S\":\n            start_col = col\n        if rows[-1][col] == \"G\":\n            end_col = col\n    queue = [(start_row, start_col)]\n    visited = set([(start_row, start_col)])\n    if start_row == end_row and start_col == end_col:\n        return 0\n    while queue:\n        row, col = queue.pop(0)\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if (\n                0 <= row + dr < max_row\n                and 0 <= col + dc < max_col\n                and (row + dr, col + dc) not in visited\n                and rows[row + dr][col + dc]!= \"#\"\n            ):\n                if (row + dr, col + dc) == (end_row, end_col):\n                    return len(visited) + 1\n                queue.append((row + dr, col + dc))\n                visited.add((row + dr, col + dc))\n    return \"-1\"\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.split('\\n')\n    n, m, k, s, g = data[0].split(' ')\n    n, m, k, s, g = int(n), int(m), int(k), int(s), int(g)\n    grid = data[1:]\n    size = n * m\n    if s == g:\n        return 0\n    cost_list = [(s, 0)]\n    day = 0\n    checked = set()\n    next_day = set()\n    while cost_list:\n        new_cost_list = []\n        for cost, day in cost_list:\n            if cost == g:\n                return day\n            for i in range(4):\n                x, y = -1, -1\n                if i == 0:\n                    x, y = 0, -1\n                elif i == 1:\n                    x, y = 0, 1\n                elif i == 2:\n                    x, y = -1, 0\n                else:\n                    x, y = 1, 0\n                new_x, new_y = x + cost, y + cost\n                if 0 <= new_x < size and 0 <= new_y < size and (new_x, new_y) not in checked and grid[new_y][new_x]!= '#':\n                    next_day.add((new_x, new_y))\n                    new_cost_list.append((new_x, new_y))\n        cost_list = new_cost_list\n        checked = next_day\n        next_day = set()\n        day += 1\n    return -1"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    n, m, k = list(map(int, input.split()))\n    grid = [list(line) for line in input.splitlines()]\n    x, y = grid.index('S'), grid.index('G')\n    matrix = [[i, j] for i in range(n) for j in range(m) if grid[i][j] == 'S']\n\n    def get_neighbors(cell):\n        i, j = cell[0], cell[1]\n        return [matrix[(i - 1) % n][(j - 1) % m],\n                matrix[(i - 1) % n][(j + 1) % m],\n                matrix[(i + 1) % n][(j - 1) % m],\n                matrix[(i + 1) % n][(j + 1) % m]]\n\n    if k < 1:\n        return -1\n    steps = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'G':\n                matrix.append([i, j])\n    while True:\n        if len(matrix) == 1:\n            return steps\n        temp = []\n        for cell in matrix:\n            if grid[cell[0]][cell[1]] == 'S':\n                temp.append(cell)\n            elif grid[cell[0]][cell[1]] == '.':\n                temp.append([cell[0] - 1, cell[1]])\n                temp.append([cell[0] + 1, cell[1]])\n                temp.append([cell[0], cell[1] - 1])\n                temp.append([cell[0], cell[1] + 1])\n            elif grid[cell[0]][cell[1]] == 'M':\n                temp.append([cell[0] - 1, cell[1]])\n                temp.append([cell[0] + 1, cell[1]])\n                temp.append([cell[0], cell[1] - 1])\n                temp.append([cell[0], cell[1] + 1])\n        matrix = temp\n        steps += 1\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = [int(x) for x in stdin.split(' ')]\n    if n == 0 or m == 0 or k == 0:\n        return '-1'\n    if n == 1 or m == 1:\n        return '1'\n    if k < n + m - 3:\n        return '-1'\n    if k == n + m - 3:\n        return '1'\n\n    # next we should make a map\n    # we should also make a dictionary with all the possible\n    # paths and their dists\n    def helper(stdin: str) -> dict:\n        d = {}\n        n, m = [int(x) for x in stdin.split(' ')]\n        for i in range(n):\n            line = stdin[i * m:(i + 1) * m]\n            for j, x in enumerate(line):\n                if x == 'S':\n                    sx, sy = i, j\n                elif x == 'G':\n                    gx, gy = i, j\n                else:\n                    pass\n            # print(line)\n            # print(d)\n        return d\n\n    def make_map(stdin: str) -> dict:\n        d = {}\n        n, m = [int(x) for x in stdin.split(' ')]\n        for i in range(n):\n            line = stdin[i * m:(i + 1) * m]\n            for j, x in enumerate(line):\n                if x == 'S':\n                    sx, sy = i, j\n                elif x == 'G':\n                    gx, gy = i, j\n                else:\n                    pass\n            # print(line)\n            # print(d)\n        d[(sx, sy)] = (gx, gy)\n        return d\n\n    def make_paths(d: dict, stdin: str) -> dict:\n        n, m = [int(x) for x in stdin.split(' ')]\n        for i in range(n):\n            line = stdin[i * m:(i + 1) * m]\n            for j, x in enumerate(line):\n                if x == 'F':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': (i, j - 1),\n                                 'right': (i, j + 1)}\n                elif x == 'M':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': None,\n                                 'right': None}\n                elif x == '#':\n                    d[(i, j)] = {'up': None,\n                                 'down': None,\n                                 'left': None,\n                                 'right': None}\n                elif x == 'S':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': (i, j - 1),\n                                 'right': (i, j + 1)}\n                elif x == 'G':\n                    d[(i, j)] = {'up': None,\n                                 'down': None,\n                                 'left': None,\n                                 'right': None}\n        return d\n\n    # now that we have the maps, make the paths\n    def make_paths(d: dict, stdin: str) -> dict:\n        n, m = [int(x) for x in stdin.split(' ')]\n        for i in range(n):\n            line = stdin[i * m:(i + 1) * m]\n            for j, x in enumerate(line):\n                if x == 'F':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': (i, j - 1),\n                                 'right': (i, j + 1)}\n                elif x == 'M':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': None,\n                                 'right': None}\n                elif x == '#':\n                    d[(i, j)] = {'up': None,\n                                 'down': None,\n                                 'left': None,\n                                 'right': None}\n                elif x == 'S':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': (i, j - 1),\n                                 'right': (i, j + 1)}\n                elif x == 'G':\n                    d[(i, j)] = {'up': None,\n                                 'down': None,\n                                 'left': None,\n                                 'right': None}\n        return d\n\n    def path(d: dict, stdin: str) -> dict:\n        n, m = [int(x) for x in stdin.split(' ')]\n        for i in range(n):\n            line = stdin[i * m:(i + 1) * m]\n            for j, x in enumerate(line):\n                if x == 'F':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': (i, j - 1),\n                                 'right': (i, j + 1)}\n                elif x == 'M':\n                    d[(i, j)] = {'up': (i - 1, j),\n                                 'down': (i + 1, j),\n                                 'left': None,\n                                 'right': None}\n                elif x == '#':\n                    d[(i, j)] = {'up': None,\n                                 'down': None,\n                                 'left': None,\n                                 'right': None}\n                elif x =="
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    g = []\n    for _ in range(n):\n        g.append(list(stdin.split()[0]))\n\n    r = {}\n    for i in range(n):\n        for j in range(m):\n            if g[i][j] == 'S':\n                r[(i, j)] = [[i, j]]\n            elif g[i][j] == 'G':\n                r[(i, j)] = [[i, j]]\n            elif g[i][j] == '#':\n                r[(i, j)] = [[i, j]]\n\n    for i in range(n):\n        for j in range(m):\n            if g[i][j] == 'F':\n                r[(i, j)].append([i + 1, j])\n                r[(i, j)].append([i - 1, j])\n                r[(i, j)].append([i, j - 1])\n                r[(i, j)].append([i, j + 1])\n            elif g[i][j] == 'M':\n                r[(i, j)].append([i + 1, j])\n                r[(i, j)].append([i - 1, j])\n                r[(i, j)].append([i, j - 1])\n                r[(i, j)].append([i, j + 1])\n                r[(i, j)].append([i - 1, j - 1])\n                r[(i, j)].append([i + 1, j + 1])\n                r[(i, j)].append([i + 1, j - 1])\n                r[(i, j)].append([i - 1, j + 1])\n            elif g[i][j] == '#':\n                r[(i, j)].append([i + 1, j])\n                r[(i, j)].append([i - 1, j])\n                r[(i, j)].append([i, j - 1])\n                r[(i, j)].append([i, j + 1])\n                r[(i, j)].append([i - 1, j - 1])\n                r[(i, j)].append([i + 1, j + 1])\n                r[(i, j)].append([i + 1, j - 1])\n                r[(i, j)].append([i - 1, j + 1])\n    r = {k: v for k, v in r.items() if len(v) > 0}\n\n    q = deque([(0, 0, k)])\n    seen = set()\n    while q:\n        d, i, k = q.popleft()\n        if (i, k) not in r:\n            continue\n        for j in r[(i, k)]:\n            if (i, k, j[0], j[1]) in seen:\n                continue\n            if j[0] < 0 or j[0] >= n or j[1] < 0 or j[1] >= m:\n                continue\n            if g[j[0]][j[1]] == '#':\n                continue\n            if g[j[0]][j[1]] == 'G':\n                return d + 1\n            q.append((d + 1, j[0], k - 1))\n            seen.add((i, k, j[0], j[1]))\n\n    return -1\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    stdin = list(stdin)\n    n, m = int(stdin[0].split()[0]), int(stdin[0].split()[1])\n    \n    grid = []\n    \n    for i in range(1, n+1):\n        grid.append(stdin[i])\n        \n    start_x, start_y = 0, 0\n    goal_x, goal_y = 0, 0\n    \n    for y in range(m):\n        for x in range(n):\n            if grid[y][x] == 'S':\n                start_x, start_y = x, y\n            elif grid[y][x] == 'G':\n                goal_x, goal_y = x, y\n                \n    queue = [start_x, start_y]\n    distances = [[float('inf') for _ in range(n)] for _ in range(m)]\n    distances[start_y][start_x] = 0\n    path = [['#' for _ in range(n)] for _ in range(m)]\n    path[start_y][start_x] = 'S'\n    \n    while queue:\n        x, y = queue.pop(0)\n        \n        if grid[y][x] == '#':\n            continue\n        \n        for x_dir, y_dir in ((0, -1), (0, 1), (-1, 0), (1, 0)):\n            x_new, y_new = x + x_dir, y + y_dir\n            \n            if x_new < 0 or x_new >= n or y_new < 0 or y_new >= m:\n                continue\n            \n            if grid[y_new][x_new] == '.' and distances[y_new][x_new] == float('inf'):\n                distances[y_new][x_new] = distances[y][x] + 1\n                queue.append((x_new, y_new))\n                \n                if distances[y_new][x_new] < 3:\n                    path[y_new][x_new] = 'R'\n                    \n    if path[goal_y][goal_x] == '#':\n        return 'IMPOSSIBLE'\n    \n    return str(distances[goal_y][goal_x])\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    h, w = int(lines[0].split()[0]), int(lines[0].split()[1])\n    grid = lines[1:]\n\n    def ok(loc):\n        return 0 <= loc[0] < h and 0 <= loc[1] < w\n\n    def next(loc, d):\n        nloc = loc[0] + d[0], loc[1] + d[1]\n        if not ok(nloc):\n            return False\n        c = grid[nloc[0]][nloc[1]]\n        if c == '#':\n            return False\n        if c == 'G':\n            return True\n        return ok(nloc) and next(nloc, d)\n\n    def visited(loc):\n        return any(next((loc[0], loc[1] + i), (loc[0], -i)) for i in range(1, w))\n\n    def next_(loc, d):\n        nloc = loc[0] + d[0], loc[1] + d[1]\n        if not ok(nloc):\n            return False\n        c = grid[nloc[0]][nloc[1]]\n        if c == '#':\n            return False\n        if c == 'G':\n            return True\n        if not ok(nloc) or visited(nloc):\n            return False\n        return next_((nloc[0], nloc[1] + i) for i in range(1, w))\n\n    def insert(loc, d):\n        nloc = loc[0] + d[0], loc[1] + d[1]\n        if not ok(nloc):\n            return False\n        c = grid[nloc[0]][nloc[1]]\n        if c == '#':\n            return False\n        if c == 'G':\n            return True\n        if not ok(nloc) or visited(nloc):\n            return False\n        return insert((nloc[0], nloc[1] + i) for i in range(1, w))\n\n    dist = {(loc := (0, 0), next((loc[0], loc[1] + i) for i in range(1, w))): 1}\n    for r in grid:\n        for i in range(w):\n            if grid[0][i] == 'S':\n                start = (0, i)\n            if grid[0][i] == 'G':\n                goal = (0, i)\n    if next(start, goal):\n        return dist\n    queue = [start]\n    while queue:\n        loc = queue.pop()\n        for d in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            if next_(loc, d):\n                if (next_loc := next(loc, d)) and (next_loc not in dist):\n                    queue.append(next_loc)\n                    dist[next_loc] = dist[loc] + 1\n                if insert((loc[0], loc[1] + i) for i in range(1, w)):\n                    return dist\n    return 'Impossible'\n\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    h, w = [int(x) for x in stdin.split(' ')]\n    r = []\n    for i in range(h):\n        r.append(stdin.split('\\n')[i])\n    for i in range(len(r)):\n        for j in range(len(r[i])):\n            if r[i][j] == 'S':\n                s = [i, j]\n            elif r[i][j] == 'G':\n                g = [i, j]\n    r.insert(0, ['.' for _ in range(w)])\n    r.append(['.' for _ in range(w)])\n    for i in range(len(r)):\n        r[i] = ['.' for _ in range(w)] + list(r[i]) + ['.' for _ in range(w)]\n    r[s[0]][s[1]] = '#'\n    r[g[0]][g[1]] = '.'\n    r = list(map(list, zip(*r)))\n    r = [''.join(r[i]) for i in range(len(r))]\n    r = list(filter(lambda x: x.count('#') > 1, r))\n    count = 0\n    for i in range(len(r)):\n        s = r[i].split('#')\n        for j in range(len(s)):\n            if s[j] == 'S' or s[j] == 'G':\n                continue\n            if s[j][0] == 'D':\n                if s[j][1] == 'D':\n                    count += 1\n            elif s[j][0] == 'L':\n                if s[j][1] == 'L':\n                    count += 1\n            elif s[j][0] == 'R':\n                if s[j][1] == 'R':\n                    count += 1\n            if s[j][0] == 'U':\n                if s[j][1] == 'U':\n                    count += 1\n    return count\nprint(solution(stdin))\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w = [int(x) for x in stdin.split(' ')]\n    grid = [[x for x in stdin[i * w : (i + 1) * w]] for i in range(h)]\n    string = stdin[(h + 1) * w :]\n    visited = [False] * (h * w)\n    def neighbors(x, y):\n        return [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n    def is_valid(x, y):\n        return 0 <= x < h and 0 <= y < w\n    def visited_neighbor(x, y):\n        return visited[x * w + y]\n    def set_visited_neighbor(x, y):\n        visited[x * w + y] = True\n    def is_goal(x, y):\n        return grid[x][y] == 'G'\n    def is_obstacle(x, y):\n        return grid[x][y] == '#'\n    def is_empty(x, y):\n        return not is_goal(x, y) and not is_obstacle(x, y)\n    def is_valid_command(x, y, c):\n        if c == 'R':\n            return is_valid(x, y) and is_empty(x, y - 1)\n        elif c == 'L':\n            return is_valid(x, y) and is_empty(x, y + 1)\n        elif c == 'U':\n            return is_valid(x - 1, y) and is_empty(x, y)\n        else:\n            return is_valid(x + 1, y) and is_empty(x, y)\n    def remove_string(s):\n        return s.replace('DRRDD', '')\n    def insert_string(s, i):\n        return s[:i] + 'DRRDD' + s[i:]\n    def move(x, y, c):\n        if c == 'R':\n            return x, y + 1\n        elif c == 'L':\n            return x, y - 1\n        elif c == 'U':\n            return x - 1, y\n        else:\n            return x + 1, y\n    def get_string_cost(s):\n        cost = 0\n        for i in range(len(s)):\n            if s[i] == 'DRRDD':\n                cost += len(s) - i\n                break\n            if i < len(s) - 1 and s[i:i + 2] == 'UU':\n                cost += 2\n                i += 1\n            else:\n                cost += 1\n        return cost\n    queue = [string]\n    min_cost = float('inf')\n    while queue:\n        string = queue.pop(0)\n        cost = get_string_cost(string)\n        if cost < min_cost:\n            min_cost = cost\n        for i in range(len(string)):\n            if string[i] == 'DRRDD':\n                break\n            if i < len(string) - 1 and string[i:i + 2] == 'UU':\n                continue\n            for c in 'DRRUDLR':\n                if not is_valid_command(x, y, c):\n                    continue\n                new_string = string\n                new_string = insert_string(new_string, i)\n                new_string = insert_string(new_string, i + 1)\n                new_string = insert_string(new_string, i + 2)\n                set_visited_neighbor(x, y)\n                set_visited_neighbor(*move(x, y, c))\n                set_visited_neighbor(*move(*move(x, y, c), c))\n                new_string = insert_string(new_string, i + 2)\n                if new_string in visited:\n                    continue\n                visited.append(new_string)\n                queue.append(new_string)\n    return min_cost\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    board = [list(stdin) for _ in range(m)]\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    def is_valid(i, j):\n        return 0 <= i < m and 0 <= j < n\n\n    def is_goal(i, j):\n        return board[i][j] == 'G'\n\n    def is_obstacle(i, j):\n        return board[i][j] == '#'\n\n    def get_directions(i, j, visited):\n        directions = []\n        if is_valid(i - 1, j):\n            if not visited[i - 1][j]:\n                directions.append([-1, 0])\n        if is_valid(i + 1, j):\n            if not visited[i + 1][j]:\n                directions.append([1, 0])\n        if is_valid(i, j - 1):\n            if not visited[i][j - 1]:\n                directions.append([0, -1])\n        if is_valid(i, j + 1):\n            if not visited[i][j + 1]:\n                directions.append([0, 1])\n        return directions\n\n    def search(i, j, visited):\n        queue = collections.deque([[i, j]])\n        visited[i][j] = True\n        while queue:\n            curr = queue.popleft()\n            for direction in get_directions(curr[0], curr[1], visited):\n                new_i, new_j = curr[0] + direction[0], curr[1] + direction[1]\n                if is_goal(new_i, new_j):\n                    return True\n                if not visited[new_i][new_j] and not is_obstacle(new_i, new_j):\n                    visited[new_i][new_j] = True\n                    queue.append([new_i, new_j])\n        return False\n\n    def solve():\n        visited[0][0] = True\n        if search(0, 0, visited):\n            return 0\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'D':\n                    board[i][j] = '.'\n                    if search(i, j, visited):\n                        return 1\n                    board[i][j] = 'D'\n        return 2\n\n    return solve()"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[:2])\n    grid = [[char for char in stdin[i:i+w]] for i in range(0, w*h, w)]\n    command_length, command = map(int, stdin[-1].split())\n    counter = 0\n\n    while True:\n        counter += 1\n        new_grid = copy.deepcopy(grid)\n        for i in range(h):\n            for j in range(w):\n                current_command = command[i*w + j]\n                if current_command == '.':\n                    continue\n                elif current_command == 'G':\n                    if grid[i][j] == 'S':\n                        new_grid[i][j] = 'G'\n                    else:\n                        new_grid[i][j] = '.'\n                elif current_command == 'S':\n                    if grid[i][j] == '#':\n                        new_grid[i][j] = '#'\n                    else:\n                        new_grid[i][j] = 'S'\n                elif current_command == '#':\n                    new_grid[i][j] = '#'\n                elif current_command == 'R':\n                    if j == w - 1:\n                        new_grid[i][j] = '#'\n                    else:\n                        new_grid[i][j + 1] = '.'\n                elif current_command == 'L':\n                    if j == 0:\n                        new_grid[i][j] = '#'\n                    else:\n                        new_grid[i][j - 1] = '.'\n\n        if new_grid == grid:\n            break\n\n        grid = new_grid\n        stdin = ''.join([''.join(i) for i in grid])\n        command_length, command = map(int, stdin[-1].split())\n\n    return counter\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your friend has given you a program to help with his mission. You are looking at a 2-dimensional grid containing 'S' for starting position, 'G' for goal, and '#' for obstacles. You are also given a string of commands that your friend has constructed, which will move the robot from its starting position 'S' to the goal position 'G'.\n\n    The problem is that the robot is not a very good programmer, and so it may not follow your instructions perfectly. Also, your friend thinks that he can solve the problem in a shorter way, so you are curious to see if you can do better.\n\n    Using the instructions given, can you change the program so that the robot will always reach the goal, never running into an obstacle?\n    \"\"\"\n    # create the grid from the input\n    grid = stdin.split('\\n')\n\n    # find starting position\n    start = [i for i, s in enumerate(grid) if s[0] == 'S'][0]\n    start = (start, grid[start].index('S'))\n\n    # find goal position\n    goal = [i for i, s in enumerate(grid) if s[0] == 'G'][0]\n    goal = (goal, grid[goal].index('G'))\n\n    # create a list of possible actions\n    actions = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}\n\n    # create a queue for BFS\n    q = [start]\n\n    # if at the goal, return 0\n    if start == goal:\n        return 0\n\n    # while queue is not empty\n    while q:\n        # pop the current position\n        cur = q.pop(0)\n\n        # if current position is the goal, return the number of moves needed\n        if cur == goal:\n            return len(q)\n\n        # create a list of all possible moves\n        for a in actions.values():\n            # check if the new position is an obstacle\n            if (0 <= cur[0] + a[0] < len(grid)) and (0 <= cur[1] + a[1] < len(grid[cur[0] + a[0]])) and (grid[cur[0] + a[0]][cur[1] + a[1]]!= '#'):\n                # create the new position\n                new = (cur[0] + a[0], cur[1] + a[1])\n                # if the new position is the goal, return the number of moves needed\n                if new == goal:\n                    return len(q) + 1\n                # add the new position to the queue\n                q.append(new)\n    return 0\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    grid = [list(stdin.splitlines()[0]) for _ in range(h)]\n    start_pos, goal_pos = None, None\n    for r in range(h):\n        for c in range(w):\n            if grid[r][c] == 'S':\n                start_pos = (r, c)\n            elif grid[r][c] == 'G':\n                goal_pos = (r, c)\n    # YOUR CODE HERE\n    \n    return ''.join(\n        ('DR'[c == 'R'] for c in stdin)\n        + ('DL'[c == 'L'] for c in stdin)\n    )\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'a'\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    maze = [list(line) for line in stdin.split('\\n')]\n\n    visited = set()\n    queue = [(0, 0, 0, 'L')]\n    count = 0\n\n    while queue:\n        h, w, count, command = queue.pop(0)\n        if (h, w) == (H - 1, W - 1):\n            break\n\n        visited.add((h, w))\n\n        for offset in (-1, 1):\n            if command == 'L' or command == 'R':\n                new_h = h + offset\n                new_w = w\n            elif command == 'U' or command == 'D':\n                new_h = h\n                new_w = w + offset\n\n            if new_h < 0 or new_h >= H or new_w < 0 or new_w >= W:\n                continue\n            if maze[new_h][new_w] == '#':\n                continue\n\n            if (new_h, new_w) not in visited:\n                queue.append((new_h, new_w, count + 1, command))\n\n        if command == 'L' or command == 'R':\n            new_h = h + 1\n            new_w = w\n        elif command == 'U' or command == 'D':\n            new_h = h\n            new_w = w + 1\n\n        if new_h < 0 or new_h >= H or new_w < 0 or new_w >= W:\n            continue\n\n        if (new_h, new_w) not in visited:\n            queue.append((new_h, new_w, count + 1, command))\n\n    return count\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: input in string format\n    :return: solution in string format\n    \"\"\"\n    # your code goes here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    pass\n\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    beacons = []\n    for i in range(N):\n        X, Y, D = map(int, stdin.readline().split())\n        beacons.append((X, Y, D))\n    XR, YR, RD = min(beacons, key=lambda beacon: beacon[2])\n    if RD < 1:\n        return 'impossible'\n    beacons = sorted(beacons, key=lambda beacon: abs(beacon[0] - XR) + abs(beacon[1] - YR))\n    for XB, YB, DB in beacons:\n        if DB < abs(XR - XB) + abs(YR - YB):\n            return 'impossible'\n    if len(set([XB for XB, YB, DB in beacons])) > 1:\n        return 'uncertain'\n    return '{} {}'.format(XR + beacons[0][0], YR + beacons[0][1])"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"3\\n999999 0 1000\\n999900 950 451\\n987654 123 13222\")\n    '1000200 799'\n    >>> solution(\"2\\n100 0 101\\n0 200 199\")\n    'uncertain'\n    >>> solution(\"2\\n100 0 100\\n0 200 199\")\n    'impossible'\n    '''\n    pass\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 99999 0 1000\n   ... 99999 0 1000\n   ... 987654 123 13222''')\n    '1000200 799'\n    >>> solution('''2\n   ... 100 0 100\n   ... 0 200 199''')\n    'uncertain'\n    >>> solution('''2\n   ... 100 0 100\n   ... 0 200 199''')\n    'impossible'\n    \"\"\"\n   ...\n    n = int(stdin.readline())\n    beacons = list(map(int, stdin.readline().split()))\n    beacons.sort()\n    beacons.append(float('inf'))\n\n    # dictionary of X,Y coordinates and distances\n    distances = dict()\n    for i in range(1, n + 1):\n        for j in range(i):\n            x1, y1 = beacons[i - 1], beacons[j]\n            x2, y2 = beacons[i], beacons[j]\n            distance = abs(x2 - x1) + abs(y2 - y1)\n            distances[(x1, y1, x2, y2)] = distance\n    # search for all distances\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            x1, y1 = beacons[i - 1], beacons[j - 1]\n            x2, y2 = beacons[i], beacons[j]\n            distance = abs(x2 - x1) + abs(y2 - y1)\n            if distance!= distances[(x1, y1, x2, y2)]:\n                return 'impossible'\n    # distance of the receiver to the beacon with the minimum distance\n    x1, y1 = beacons[0], beacons[0]\n    distances = distances.values()\n    distance = min(distances)\n    for i in range(1, n + 1):\n        x2, y2 = beacons[i], beacons[i]\n        if abs(x2 - x1) + abs(y2 - y1) == distance:\n            return f'{x1} {y1}'\n    return 'impossible'\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    beacons = []\n    for line in lines[1:]:\n        x, y, d = list(map(int, line.split(\" \")))\n        beacons.append((x, y, d))\n    sorted_beacons = sorted(beacons, key=lambda beacon: beacon[1])\n    X_R = 0\n    Y_R = 0\n    for x, y, d in sorted_beacons:\n        if X_R == 0 and Y_R == 0:\n            X_R = x\n            Y_R = y\n            continue\n        distance = abs(x - X_R) + abs(y - Y_R)\n        if distance <= d:\n            X_R = x\n            Y_R = y\n        else:\n            return \"impossible\"\n    return \"{} {}\".format(X_R, Y_R)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    beacons = [\n        [int(x) for x in stdin.split('\\n')[1].split()]\n        for i in range(N)\n    ]\n    receiver_positions = {\n        (x, y)\n        for x, y, _ in beacons\n    }\n    impossible_positions = set()\n    for x_r, y_r in receiver_positions:\n        for x_b, y_b, _ in beacons:\n            if x_b == x_r:\n                m = (y_b - y_r) // abs(y_b - y_r)\n                y_r += m * abs(y_b - y_r)\n            elif y_b == y_r:\n                m = (x_b - x_r) // abs(x_b - x_r)\n                x_r += m * abs(x_b - x_r)\n            else:\n                continue\n            if (x_r, y_r) not in receiver_positions:\n                impossible_positions.add((x_r, y_r))\n    if impossible_positions:\n        return 'impossible'\n    return str(x_r) +'' + str(y_r)"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1:\n    # N = int(stdin.readline())\n    # X, Y = 0, 0\n    # for _ in range(N):\n    #     x, y, distance = [int(x) for x in stdin.readline().split()]\n    #     X, Y = max(X, x), max(Y, y)\n    #     if abs(x-X) + abs(y-Y) > distance:\n    #         return \"impossible\"\n    # return f\"{X} {Y}\"\n\n    # Solution 2:\n    mps = MPS()\n    for i in range(int(stdin)):\n        mps.add_beacon(int(stdin[2*i]), int(stdin[2*i+1]))\n    mps.solve()\n    return mps.output()\n\n\nclass MPS:\n    def __init__(self):\n        self.beacons = []\n\n    def add_beacon(self, x, y):\n        self.beacons.append((x, y))\n\n    def solve(self):\n        print(self.beacons)\n        # \u8fd9\u91cc\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u8fc7\u9ad8\uff0c\u4f46\u662f\u901a\u8fc7\u6d4b\u8bd5\uff0c\u6ca1\u6709\u8d85\u65f6\n        for x, y in self.beacons:\n            for i in self.beacons:\n                if x!= i[0] or y!= i[1]:\n                    if self.distance(x, y, i[0], i[1]) < 1000:\n                        return \"Impossible\"\n        print(self.beacons)\n        print(len(self.beacons))\n        # print(self.distance(x, y, i[0], i[1]))\n        # print(self.distance(0, 0, x, y))\n        # print(self.beacons)\n        # if len(self.beacons) < 2:\n        #     return \"Impossible\"\n        # for x, y in self.beacons:\n        #     print(self.distance(x, y, 0, 0))\n        #     if self.distance(x, y, 0, 0) < 1000:\n        #         return \"Impossible\"\n        #     if self.distance(0, 0, x, y) < 1000:\n        #         return \"Impossible\"\n        # return \"Impossible\"\n\n    def distance(self, x1, y1, x2, y2):\n        return abs(x1-x2) + abs(y1-y2)\n\n    def output(self):\n        # print(self.beacons)\n        return f\"{self.beacons[0][0]} {self.beacons[0][1]}\"\n\n\nsolution(\"6 7 6 7 7 5 8\")\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n999999 0 1000\\n999900 950 451\\n987654 123 13222\")\n    '1000200 799'\n    \"\"\"\n    beacons = {(int(line.split()[0]), int(line.split()[1]), int(line.split()[2])) for line in stdin.strip().split('\\n')}\n    beacons = list(beacons)\n    for beacon in beacons:\n        if beacon[0] * beacon[1]!= beacon[2]:\n            return 'impossible'\n    x, y = beacons[0]\n    mps = [(x, y)]\n    for beacon in beacons[1:]:\n        x, y = beacon[0], beacon[1]\n        dist = abs(x - mps[-1][0]) + abs(y - mps[-1][1])\n        mps.append((x, y))\n        if dist!= beacon[2]:\n            return 'impossible'\n    return f\"{mps[0][0]} {mps[0][1]}\"\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Get input\n    n: int = int(stdin.readline().strip())\n    beacons: [tuple[int, int, int]] = []\n    for _ in range(n):\n        x, y, d = [int(x) for x in stdin.readline().strip().split(' ')]\n        beacons.append((x, y, d))\n\n    # Solve problem\n    receiver: tuple[int, int] = find_receiver(beacons)\n    if receiver is None:\n        print('impossible')\n    else:\n        print('{} {}'.format(receiver[0], receiver[1]))\n\n    return ''\n\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution of challenge in input.\"\"\"\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    matrix = [[int(j) for j in i.split()] for i in stdin.splitlines()[1:]]\n    return '\\n'.join([str(matrix.index(i) + 1) for i in sorted(matrix) if (i[0] == i[1] or matrix.index(i) + 1 == 1 or matrix[matrix.index(i) - 1][1] == i[1]) and matrix.index(i) + 1!= n])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\"\"\"\nimport sys\nfrom typing import Dict, List, Tuple, Set\n\nclass Solution:\n    def main(self, input: str, output: str) -> None:\n        stdout = sys.stdout\n        sys.stdout = open(output, \"w\")\n        n = int(input())\n        matrix = []\n        for _ in range(n):\n            line = input()\n            matrix.append(list(map(int, line.split())))\n        matrix.sort(key=lambda x: x[0])\n        border_dict: Dict[Tuple[int, int], Set[int]] = {}\n        for row, column in matrix:\n            border_dict[(row, column)] = set()\n        for row, column in matrix:\n            border_dict[(row, column)].add(row)\n            border_dict[(row, column)].add(column)\n        used_dict: Dict[int, int] = {}\n        for row, column in matrix:\n            for i in range(1, n+1):\n                if i in used_dict:\n                    continue\n                if (i, row) in border_dict:\n                    if not (i, column) in border_dict:\n                        break\n                    if row!= border_dict[(i, row)]:\n                        break\n                if (row, i) in border_dict:\n                    if not (column, i) in border_dict:\n                        break\n                    if column!= border_dict[(column, i)]:\n                        break\n                used_dict[i] = i\n            else:\n                break\n        for i in range(1, n+1):\n            if i not in used_dict:\n                print(\"syntax error\")\n                return\n        for i in range(1, n+1):\n            print(used_dict[i])\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def validate_location(index: int, ranges: Tuple[int, int]) -> bool:\n        row, col = index\n        return (\n            row in range(ranges[0], ranges[1] + 1)\n            and col in range(ranges[2], ranges[3] + 1)\n        )\n\n    rectangles: List[List[int]] = []\n    for i in range(int(stdin.readline())):\n        rectangles.append(list(map(int, stdin.readline().split())))\n    output: List[str] = [\"syntax error\"]\n    for i, range_i in enumerate(rectangles):\n        for j, range_j in enumerate(rectangles):\n            if validate_location(i, range_i) and validate_location(j, range_j):\n                output.append(f\"{i + 1 if i < j else j + 1}\")\n                break\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n = int(stdin.readline())\n    pairs = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    count = {i: 0 for i in range(1, n + 1)}\n    for i, pair in enumerate(pairs, 1):\n        count[pair[0]] = i\n        count[pair[1]] = i\n\n    left = [i for i in count.values() if i <= n // 2]\n    right = [i for i in count.values() if i > n // 2]\n    if len(left) > 0 and len(right) > 0:\n        left.sort()\n        right.sort()\n        print(count[left[0]], count[right[0]])\n    else:\n        print(\"syntax error\")\n    return \"\"\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds a permutation of numbers from 1 to n in which the matching numbers\n    form a nested or disjoint set of rectangles.\n\n    Args:\n        stdin: String representation of the input to the function.\n\n    Returns:\n        String representation of the solution to the problem.\n    \"\"\"\n    n = int(stdin.split()[0])\n    corners = []\n    for i in range(n):\n        r, c = [int(x) for x in stdin.split()[i * 2 + 1 : i * 2 + 3]]\n        corners.append((r, c))\n    corners.sort()\n    verticals = []\n    for i in range(n - 1):\n        if corners[i][0] == corners[i + 1][0] and corners[i][1]!= corners[i + 1][1]:\n            verticals.append((corners[i][0], corners[i][1]))\n    matched_corners = []\n    for vertical in verticals:\n        for r, c in corners:\n            if r == vertical[0] and c!= vertical[1]:\n                matched_corners.append((r, c))\n    corners_to_match = [\n        (r, c) for (r, c) in corners if r!= corners[0][0] and c!= corners[0][1]\n    ]\n    for corner in matched_corners:\n        corners_to_match.append(corner)\n    corners_to_match.sort()\n    assert len(set(corners_to_match)) == len(corners_to_match)\n    corners_to_match = [str(x[0] * 10 + x[1]) for x in corners_to_match]\n    if len(corners_to_match) > 0:\n        return \" \".join(corners_to_match)\n    return \"syntax error\"\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    max_value = 200\n    total_stds = 2\n    max_std_length = 2\n    std_per_line = 10\n    std_length = std_per_line * total_stds\n    std_grid = [[] for i in range(std_length)]\n    for std_index, std_string in enumerate(stdin.split('\\n')):\n        for std_index_2, std_value in enumerate(std_string.split()):\n            std_value = int(std_value) if std_value!= '_' else 0\n            std_grid[std_index * std_per_line + std_index_2].append(std_value)\n    if std_grid[0][0]!= 0 or std_grid[0][std_length - 1]!= 0 or std_grid[std_length - 1][0]!= 0 or std_grid[std_length - 1][std_length - 1]!= 0:\n        raise ValueError('first line is not empty')\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                std_grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n        for grid_index_2, grid_value in enumerate(grid_row):\n            if grid_value!= 0:\n                grid[grid_index][grid_index_2] = max_value\n    grid = std_grid\n    for grid_index, grid_row in enumerate(grid):\n        if grid_index == std_length - 1:\n            break\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    total_burgers, total_sushi, total_drumstick, total_salamander = 0, 0, 0, 0\n\n    for i in stdin.split(\" \"):\n        if i!= \"_\":\n            total_burgers += int(i)\n        else:\n            total_salamander += int(i)\n\n    for i in stdin.split(\" \"):\n        if i!= \"_\":\n            total_drumstick += int(i)\n        else:\n            total_sushi += int(i)\n\n    for i in stdin.split(\" \"):\n        if i!= \"_\":\n            total_salamander += int(i)\n        else:\n            total_drumstick += int(i)\n\n    total_sushi += total_burgers * 2\n    total_drumstick += total_sushi * 2\n\n    return \"many\" if total_salamander!= total_drumstick else \"1\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Get input\n    arr = [list(map(int, line.split())) for line in stdin.splitlines()]\n    # Solve the problem\n    # The problem is to find a permutation of the \"unfilled\" elements of the rows that \n    # is consistent with the values of the other rows. That is, the sums of the values of \n    # each row must equal the sum of the values of the other rows, which is equal to the \n    # total of the rows. \n    # If we sort the rows, then the first row will always have the largest values, and the \n    # last row will always have the smallest values. \n    # We can consider the values of each row to be the elements of the list. \n    # We then create a list, and add the values of each row to it, one by one. \n    # Then we sort that list, and we can iterate through it. \n    # For each value, we find its index and subtract one. \n    # Then we compare that index to the rest of the list, where we subtract one for the \n    # index of the value we found in the previous loop. If they are equal, we have found a \n    # permutation, and we increment the counter. \n    counter = 0\n    for row in arr:\n        vals = sorted(row)\n        total = sum(row)\n        for i in vals:\n            try:\n                if vals.index(i) - 1 == vals.index(total - i):\n                    counter += 1\n            except ValueError:\n                continue\n    # If there are more than one possible solution, print \"many\"\n    return \"many\" if counter > 1 else str(counter)\nprint(solution(input()))"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the number of distinct solutions\n    for the puzzle given by stdin.\n    \"\"\"\n\n    # take in the stdin puzzle\n    plate = []\n    for line in stdin.split('\\n'):\n        if line:\n            plate.append(line.split(' '))\n    plate = list(map(lambda l: list(map(int, l)), plate))\n\n    # solve the puzzle for each row\n    total_solutions = []\n    for row in plate:\n        # initialize the number of solutions\n        solutions = 1\n        # initialize the slots\n        slots = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, 10: 0}\n        # count the number of solutions\n        for i in range(1, 11):\n            # the ith slot must have i units of burgers\n            if row[0][i - 1] == 1:\n                slots[i] += 1\n            # the ith slot must have (i - 1) units of slop\n            if row[1][i - 1] == 1:\n                slots[i] -= 1\n            # the ith slot must have (i - 1) units of sushi\n            if slots[i] < 0:\n                solutions *= (i - 1)\n        total_solutions.append(solutions)\n\n    # find the minimum number of solutions\n    total_solutions = min(total_solutions)\n\n    # check if there are infinite solutions\n    if total_solutions == 1:\n        return'many'\n\n    return total_solutions\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"_ 90 22 _ 6 _ _ _ _ 81\\n_ 40 _ _ _ 12 60 _ 90 _\\n\")\n    1\n    >>> solution(\"85 55 _ 99 51 _ _ _ _ _\\n_ _ _ _ _ _ _ 85 63 153\\n\")\n    1\n    >>> solution(\"160 _ _ 136 _ _ _ _ _ 170\\n_ _ _ _ 120 _ _ 144 _ _\\n\")\n    8640\n    \"\"\"\n    return \"many\"\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\"\"\"\n    burgers, slop, sushi, drumstick = stdin.splitlines()\n    burgers, slop, sushi, drumstick = burgers.split(), slop.split(), sushi.split(), drumstick.split()\n\n    # Calculate the number of burgers to serve per monster (1+1+3+4+6+9+12+16+...),\n    # and how many burgers to serve per monster (4+3+2+1+0+0+0+0+...).\n    #\n    # Note: we use math.ceil() instead of int() here. That's because\n    # if we use int(burgers[0] / m + 0.5), we'll get \"ValueError: math domain error\"\n    # as the negative value we're trying to convert is not a valid integer.\n    burger_count = 0\n    sushi_count = 0\n    for i in range(len(burgers)):\n        burger_count += burgers[i]\n        sushi_count += int(math.ceil(burgers[i] / m))\n\n    # Calculate the number of slop to serve per monster (2+1+0+0+0+0+0+0+0+...),\n    # and how many slop to serve per monster (12+10+8+6+4+2+0+0+0+...).\n    #\n    # Note: we use math.ceil() instead of int() here. That's because\n    # if we use int(slop[0] / m + 0.5), we'll get \"ValueError: math domain error\"\n    # as the negative value we're trying to convert is not a valid integer.\n    slop_count = 0\n    drumstick_count = 0\n    for i in range(len(slop)):\n        slop_count += slop[i]\n        drumstick_count += int(math.ceil(slop[i] / m))\n\n    # Calculate the number of sushi to serve per monster (1+0+0+0+0+0+0+0+0+...),\n    # and how many sushi to serve per monster (4+0+0+0+0+0+0+0+0+...).\n    sushi_count += sushi[0]\n    drumstick_count += sushi[1]\n\n    # Calculate the number of drumstick to serve per monster (1+0+0+0+0+0+0+0+0+...),\n    # and how many drumstick to serve per monster (4+0+0+0+0+0+0+0+0+...).\n    drumstick_count += drumstick[0]\n    sushi_count += drumstick[1]\n\n    # Calculate the number of monsters.\n    n = math.gcd(burger_count, m)\n    m = burger_count // n\n\n    # Calculate the number of solutions.\n    total = 0\n    for i in range(burger_count + 1):\n        for j in range(sushi_count + 1):\n            if j * m == burger_count and i * m == slop_count:\n                total += 1\n\n    if total > 1e6:\n        return \"many\"\n\n    return total\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    n = 8 #n: number of total foods\n    m = 2 #m: number of total types\n    foods = [1,1,2,2,3,3,4,4] #foods[i]: amount of food i\n    types = [0,2,1,0,0,2,1,0] #types[i]: type of food i\n    \"\"\"\n    n = 8 #n: number of total foods\n    m = 2 #m: number of total types\n    foods = [1,1,2,2,3,3,4,4] #foods[i]: amount of food i\n    types = [0,2,1,0,0,2,1,0] #types[i]: type of food i\n    foods_num = []\n    foods_type = []\n    for food_i in range(len(foods)):\n        for food_j in range(food_i+1, len(foods)):\n            if foods[food_i]!= foods[food_j]:\n                foods_num.append(foods[food_i]/foods[food_j])\n                foods_type.append(types[food_i]/types[food_j])\n    foods_num.sort()\n    foods_type.sort()\n    return foods_num.index(foods_num[-1]), foods_type.index(foods_type[-1]) + 1"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_salamander = int(stdin[0].split()[0])\n    num_yeti = int(stdin[0].split()[1])\n    num_golem = int(stdin[0].split()[2])\n    num_imp = int(stdin[0].split()[3])\n    num_kraken = int(stdin[0].split()[4])\n\n    salamander_burgers = int(stdin[1].split()[0])\n    salamander_slop = int(stdin[1].split()[1])\n    salamander_sushi = int(stdin[1].split()[2])\n    salamander_drumstick = int(stdin[1].split()[3])\n\n    yeti_burger = int(stdin[1].split()[4])\n    yeti_slop = int(stdin[1].split()[5])\n    yeti_sushi = int(stdin[1].split()[6])\n    yeti_drumstick = int(stdin[1].split()[7])\n\n    golem_burger = int(stdin[1].split()[8])\n    golem_slop = int(stdin[1].split()[9])\n    golem_sushi = int(stdin[1].split()[10])\n    golem_drumstick = int(stdin[1].split()[11])\n\n    imp_burger = int(stdin[1].split()[12])\n    imp_slop = int(stdin[1].split()[13])\n    imp_sushi = int(stdin[1].split()[14])\n    imp_drumstick = int(stdin[1].split()[15])\n\n    kraken_burger = int(stdin[1].split()[16])\n    kraken_slop = int(stdin[1].split()[17])\n    kraken_sushi = int(stdin[1].split()[18])\n    kraken_drumstick = int(stdin[1].split()[19])\n\n    total_salamander_burgers = num_salamander * salamander_burgers\n    total_salamander_slop = num_salamander * salamander_slop\n    total_salamander_sushi = num_salamander * salamander_sushi\n    total_salamander_drumstick = num_salamander * salamander_drumstick\n\n    total_yeti_burger = num_yeti * yeti_burger\n    total_yeti_slop = num_yeti * yeti_slop\n    total_yeti_sushi = num_yeti * yeti_sushi\n    total_yeti_drumstick = num_yeti * yeti_drumstick\n\n    total_golem_burger = num_golem * golem_burger\n    total_golem_slop = num_golem * golem_slop\n    total_golem_sushi = num_golem * golem_sushi\n    total_golem_drumstick = num_golem * golem_drumstick\n\n    total_imp_burger = num_imp * imp_burger\n    total_imp_slop = num_imp * imp_slop\n    total_imp_sushi = num_imp * imp_sushi\n    total_imp_drumstick = num_imp * imp_drumstick\n\n    total_kraken_burger = num_kraken * kraken_burger\n    total_kraken_slop = num_kraken * kraken_slop\n    total_kraken_sushi = num_kraken * kraken_sushi\n    total_kraken_drumstick = num_kraken * kraken_drumstick\n\n    total_salamander_sushi_left = total_salamander_sushi - (total_salamander_burger + total_salamander_slop)\n    total_salamander_sushi_right = total_salamander_sushi - total_salamander_burger\n\n    total_yeti_sushi_left = total_yeti_sushi - (total_yeti_burger + total_yeti_slop)\n    total_yeti_sushi_right = total_yeti_sushi - total_yeti_burger\n\n    total_golem_sushi_left = total_golem_sushi - (total_golem_burger + total_golem_slop)\n    total_golem_sushi_right = total_golem_sushi - total_golem_burger\n\n    total_imp_sushi_left = total_imp_sushi - (total_imp_burger + total_imp_slop)\n    total_imp_sushi_right = total_imp_sushi - total_imp_burger\n\n    total_kraken_sushi_left = total_kraken_sushi - (total_kraken_burger + total_kraken_slop)\n    total_kraken_sushi_right = total_kraken_sushi - total_kraken_burger\n\n    total_burger = total_salamander_burgers + total_yeti_burger + total_golem_burger + total_imp_burger + total_kraken_burger\n    total_slop = total_sal"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(next(stdin.readline()))\n    a = []\n    b = []\n    for _ in range(n - 1):\n        u, v = map(int, next(stdin).split())\n        a.append(u)\n        b.append(v)\n    a.sort()\n    b.sort()\n    if a[0]!= 1 or b[0]!= 1:\n        return str(0)\n    j = 1\n    r = 0\n    while j < n:\n        if a[j] - a[j - 1] == 2 and b[j] - b[j - 1] == 2:\n            r += 1\n        j += 1\n    return str(r)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The number of valid paths is the sum of the number of paths from 1 to N - 1\n    \"\"\"\n    N = int(stdin.split()[0])\n    dist = {(u, v): None for u, v in [tuple(map(int, row.split())) for row in stdin.strip().splitlines()[1:]]}\n    dist[(1, 1)] = 0\n    q = collections.deque([(1, 1)])\n    visited = set([(1, 1)])\n    while q:\n        u, v = q.popleft()\n        for w in [u - 2, u + 2]:\n            if 1 <= w <= N and (w, v) not in visited and dist[(w, v)] is None:\n                dist[(w, v)] = dist[(u, v)] + 1\n                if w!= v:\n                    q.append((w, v))\n                    visited.add((w, v))\n    return str(len(visited) - 1)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    junctions = list(range(1, N + 1))\n    paths = [[] for _ in range(N)]\n    for u, v in [tuple(map(int, line.strip().split())) for line in stdin.readlines()[1:]]:\n        paths[u - 1].append(v)\n        paths[v - 1].append(u)\n\n    def bfs(node: int, roads: List[int]) -> bool:\n        visited = [False for _ in range(N)]\n        visited[node - 1] = True\n        queue = deque([(node, 0)])\n        while queue:\n            node, distance = queue.popleft()\n            for road in roads[node - 1]:\n                if not visited[road - 1]:\n                    queue.append((road, distance + 1))\n                    visited[road - 1] = True\n        return distance == 2\n\n    return sum(bfs(node, roads) for node in junctions)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get the input\n    n: int = int(stdin.readline())\n    edges: list[tuple[int]] = []\n    for _ in range(n - 1):\n        x, y = list(map(int, stdin.readline().split()))\n        edges.append((x, y))\n        edges.append((y, x))\n\n    # build the graph\n    graph = {}\n    for node_1, node_2 in edges:\n        graph.setdefault(node_1, set()).add(node_2)\n        graph.setdefault(node_2, set()).add(node_1)\n\n    # find the paths\n    res = 0\n    for node_1, connections in graph.items():\n        for node_2 in connections:\n            if node_1!= node_2 and len(connections) == 2:\n                res += 1\n    return res\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get the first line input\n    n_junctions = int(stdin.readline())\n    # create a list of list of pairs of integers that represent the roads\n    roads = list(map(lambda road_pair: [int(road_pair.split(' ')[0]), int(road_pair.split(' ')[1])], stdin.readlines()[:-1]))\n    # create a list of lists of integers that represent the distances\n    distances = list(map(lambda road_pair: [int(road_pair.split(' ')[0]), int(road_pair.split(' ')[1])], stdin.readlines()[:-1]))\n    # create a dictionary of dictionaries that represent the graph\n    graph = dict(zip(range(1, n_junctions+1), [{} for _ in range(0, n_junctions)]))\n    # set the graph edges\n    for road in roads:\n        if road[0] in graph[road[1]].keys():\n            graph[road[0]][road[1]].append(road[1])\n        else:\n            graph[road[0]][road[1]] = [road[1]]\n    # create a list of dictionaries that represent the distances dictionary\n    distances_dict = list(map(lambda road_pair: {road_pair[1]: road_pair[0]}, distances))\n    # set the distances dictionary\n    for road_pair in distances:\n        graph[road_pair[0]][road_pair[1]].append(road_pair[0] + road_pair[1])\n        graph[road_pair[0]][road_pair[1]].append(road_pair[1] + road_pair[0])\n    # set the distances dictionary\n    for road_pair in distances:\n        graph[road_pair[0]][road_pair[1]].append(road_pair[0] + road_pair[1])\n        graph[road_pair[0]][road_pair[1]].append(road_pair[1] + road_pair[0])\n    # set a dictionary that will store the optimal paths count\n    optimal_paths_count = {}\n    # set the result variable\n    result = 0\n    # loop over all nodes in the graph\n    for start_node in graph:\n        # if the start node is not in the dictionary of optimal paths count\n        if start_node not in optimal_paths_count.keys():\n            # if the start node is in the dictionary of distances\n            if start_node in distances_dict[0].keys():\n                # set the result variable to 1\n                result = 1\n            # else if the start node is not in the dictionary of distances\n            else:\n                # loop over all nodes in the graph\n                for end_node in graph[start_node].keys():\n                    # if the end node is in the dictionary of distances\n                    if end_node in distances_dict[0].keys():\n                        # loop over all the edges of the end node\n                        for edge in graph[end_node].keys():\n                            # if the end node is not the start node\n                            if edge!= start_node:\n                                # and if the edge is not in the graph of optimal paths count\n                                if edge not in optimal_paths_count.keys():\n                                    # if the edge is in the dictionary of distances\n                                    if edge in distances_dict[0].keys():\n                                        # set the result variable to 1\n                                        result = 1\n                                    # else if the edge is not in the dictionary of distances\n                                    else:\n                                        # loop over all the edges of the start node\n                                        for edge in graph[start_node].keys():\n                                            # if the edge is in the graph of optimal paths count\n                                            if edge in optimal_paths_count.keys():\n                                                # get the count of the optimal paths between the start node and the end node\n                                                path_count = optimal_paths_count[edge]\n                                                # if the start node is not the end node\n                                                if start_node!= end_node:\n                                                    # and if the count of the optimal paths between the start node and the end node is greater than or equal to 2\n                                                    if path_count >= 2:\n                                                        # increase the count of the optimal paths between the start node and the end node by 1\n                                                        optimal_paths_count[edge] = path_count + 1\n                                                        # increase the count of the optimal paths between the start node and the end node by 1\n                                                        optimal_paths_count[start_node][end_node] = path_count + 1\n                                                # else if the start node is the end node\n                                                else:\n                                                    # and if the count of the optimal paths between the start node and the end node is greater than or equal to 2\n                                                    if path_count >= 2:\n                                                        # increase the count of the optimal paths between the start node and the end node by 1\n                                                        optimal_paths_count[edge] = path_count + 1\n                                                        # increase the count of the optimal paths between the start node and the end node by 1\n                                                        optimal_paths_count[start_node][start_node] = path_count + 1\n                                            # else if the edge is not in the graph of optimal paths count\n                                            else:\n                                                # loop over all the edges of the start node"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    num_junction = int(stdin.split('\\n')[0])\n    junction_array = []\n    for i in range(num_junction):\n        junction_array.append(list(map(int, stdin.split('\\n')[i + 1].split())))\n    for i in range(num_junction):\n        for j in range(i + 1, num_junction):\n            if not ((junction_array[i][0] == junction_array[j][0] or junction_array[i][0] == junction_array[j][1]) and (\n                    junction_array[i][1] == junction_array[j][0] or junction_array[i][1] == junction_array[j][1])):\n                if junction_array[i][0] < junction_array[i][1] and junction_array[j][0] < junction_array[j][1]:\n                    if junction_array[i][1] == junction_array[j][0] and junction_array[i][0] == junction_array[j][1]:\n                        count += 1\n                if junction_array[i][0] > junction_array[i][1] and junction_array[j][0] > junction_array[j][1]:\n                    if junction_array[i][1] == junction_array[j][0] and junction_array[i][0] == junction_array[j][1]:\n                        count += 1\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of Pokenom's paths of length 2.\n    :param stdin: input of the form :\n    \"\"\"\n    return 0"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    graph = []\n    for i in range(n - 1):\n        u, v = [int(x) for x in stdin.readline().split()]\n        graph.append((u, v))\n    # \u8fb9\u96c6\u8f6c\u56fe\n    g = [[] for _ in range(n)]\n    for u, v in graph:\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    # print(graph)\n    # print(g)\n    ans = 0\n    # \u5165\u5ea6\u4e3a\u96f6\u7684\u70b9\n    s = [i for i in range(n) if not graph[i]]\n    for u in s:\n        for v in g[u]:\n            if u < v:\n                ans += 1\n    return ans\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    N = int(stdin.readline())\n    G = [[int(u) for u in line.strip().split(' ')] for line in stdin]\n\n    M = N - 1\n    E = [[] for _ in range(M + 1)]\n\n    for u, v in G:\n        E[u - 1].append(v - 1)\n        E[v - 1].append(u - 1)\n\n    def dfs(v, visited, path):\n        if v in visited:\n            return path\n        visited.add(v)\n        for e in E[v]:\n            if e not in visited:\n                path.append(e)\n                path = dfs(e, visited, path)\n                if len(path) == 2:\n                    return path\n                path.pop()\n        return []\n\n    pokemon = 0\n    for u in range(N):\n        if u!= 0:\n            path = dfs(u, set(), [u])\n            if len(path) == 2:\n                pokemon += 1\n    return str(pokemon)\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin.split('\\n')[0]\n    message_fragment = stdin.split('\\n')[1]\n    decrypted_fragment = ''\n    for letter in message_fragment:\n        decrypted_fragment += message[letter]\n    return decrypted_fragment if decrypted_fragment in message else str(len(message))\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    message = stdin[0]\n    fragment = stdin[1]\n    \n    encrypted = set()\n    decrypted = set()\n    \n    for i in range(len(message)):\n        encrypted.add(message[i])\n        decrypted.add(fragment[i])\n    \n    decrypted = decrypted - encrypted\n    \n    if len(decrypted) == 0:\n        return str(len(encrypted))\n    else:\n        return \"\".join(encrypted - decrypted)\n\nprint(solution(input().split(\"\\n\")))"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    first = stdin.split(\"\\n\")[0]\n    second = stdin.split(\"\\n\")[1]\n    answer = 0\n    for i in range(len(first)):\n        if (first[i] == second[i]):\n            answer += 1\n    print(answer)\n    return answer"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"returns the secret message\"\"\"\n    enc_msg = stdin[0]\n    dec_msg = stdin[1]\n    # print(enc_msg)\n    # print(dec_msg)\n    d = dict()\n    for i in range(ord(\"a\"), ord(\"z\") + 1):\n        d[chr(i)] = chr(i + 1)\n\n    dec = \"\"\n    for i in range(len(enc_msg)):\n        # print(enc_msg[i], dec_msg[i])\n        dec += d[enc_msg[i]]\n    # print(dec)\n    # print(dec_msg)\n    pos = 0\n    for i in range(len(dec_msg)):\n        if dec[i] == dec_msg[i]:\n            pos += 1\n    # print(pos)\n    # print(dec)\n    # print(enc_msg)\n    if pos!= 0:\n        print(dec[:pos])\n    else:\n        print(pos)\n\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    len_m = int(stdin.split()[0])\n    dec = stdin.split()[1]\n\n    sub_m = ''\n    for l in range(len_m):\n        if dec[l] not in sub_m:\n            sub_m += dec[l]\n    sub_m = sub_m[0]\n\n    if sub_m in dec:\n        return sub_m\n\n    return len(dec.split(sub_m))\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    message = stdin[0]\n    fragment = stdin[1]\n    # position = 0\n    # count = 0\n    count = 0\n    for i in range(len(message)):\n        if message[i] == fragment[0]:\n            count += 1\n            if count == len(fragment):\n                break\n    # for c in fragment:\n    #     if message[position]!= c:\n    #         count += 1\n    #     position += 1\n    #     if count > len(fragment):\n    #         break\n    #     if position == len(message):\n    #         position = 0\n    #         count = 0\n    #     if position > len(message):\n    #         break\n    #     if c == message[position]:\n    #         count += 1\n    #     position += 1\n    # if count == len(fragment):\n    #     print(count)\n    # else:\n    #     print(count)\n    print(count)\n    return fragment\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin[0]\n    decrypted = stdin[1]\n    results = []\n    \n    for x in range(1, len(message)):\n        chars = [chr(i) for i in range(97, 123)]\n        for y in chars:\n            if message[x] == y:\n                continue\n            decrypted_text = decrypted + y\n            if decrypted_text in message:\n                results.append((message[x], message.index(decrypted_text), decrypted_text))\n    \n    if len(results) == 0:\n        return str(len(message))\n    else:\n        return str(results[0][2])\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the substring of encrypted message which could correspond to the\n    decrypted fragment\n    '''\n    # First line of the input string\n    encrypted_message = stdin[0]\n    # Second line of the input string\n    decrypted_fragment = stdin[1]\n    \n    # Initializing a dictionary to store all the possible keys\n    keys = {}\n    # Initializing a list to store all the possible keys in a form of a string\n    keys_string = []\n    # Initializing a list to store all the possible keys in a form of a string\n    # with all the capital letters being converted to lowercase\n    keys_string_lowercase = []\n    \n    # Converts the encrypted message into a dictionary with all the letters\n    # being the keys and the occurrences of each letter being the values\n    for letter in encrypted_message:\n        keys[letter] = keys.get(letter, 0) + 1\n        \n    # Converts the encrypted message into a string\n    encrypted_message_str = ''.join(map(str, encrypted_message))\n    \n    # Iterate through all the letters of the encrypted message\n    for letter in encrypted_message:\n        # Iterate through all the letters of the decrypted fragment\n        for i in decrypted_fragment:\n            # Convert the encrypted message to a dictionary\n            # with all the letters being the keys and the occurrences\n            # of each letter being the values\n            keys_new = dict(keys)\n            # Convert the decrypted fragment to a string\n            decrypted_fragment_str = ''.join(map(str, decrypted_fragment))\n            # Check if the letter of the encrypted message can be changed\n            # in such a way that the decrypted fragment can be obtained\n            # if the letter of the encrypted message is changed to the\n            # same letter of the decrypted fragment\n            if letter.lower() == i.lower():\n                keys_new[letter] = keys_new[letter] - 1\n                \n                if keys_new[letter] == 0:\n                    keys_new.pop(letter)\n                \n                decrypted_fragment_str = ''.join(map(str, decrypted_fragment))\n                \n                if decrypted_fragment_str == encrypted_message_str:\n                    # print(keys_string)\n                    # Append the string with all the letters converted to\n                    # lowercase into the list\n                    keys_string_lowercase.append(\n                        encrypted_message_str.lower()\n                        )\n                \n    # Check if the decrypted fragment is present in any of the strings\n    # of all the lowercase letters of the encrypted message\n    for i in keys_string_lowercase:\n        if decrypted_fragment in i:\n            return i[decrypted_fragment]\n    return len(keys_string_lowercase)\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the given problem\n    \"\"\"\n    # Your code here\n    # return \"\"\n\n    msg = stdin.split('\\n')[0]\n    frag = stdin.split('\\n')[1]\n    code = {'a':'k', 'b':'o', 'c':'u', 'd':'e', 'e':'a', 'f':'t', 'g':'s', 'h':'r', 'i':'w', 'j':'d', 'k':'c', 'l':'b','m':'f', 'n':'g', 'o':'h', 'p':'j', 'q':'m', 'r':'n','s':'p', 't':'q', 'u':'i', 'v':'l', 'w':'k', 'x':'v', 'y':'s', 'z':'x'}\n    decoded = ''\n    for i in msg:\n        decoded += code[i]\n    print(decoded)\n    count = 0\n    for i in range(len(frag)):\n        if frag[i]!= decoded[i]:\n            count += 1\n    print(count)\n\nsolution(input())\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the unique encrypted message substring containing a given decrypted message.\n    \"\"\"\n\n    # Get encrypted message and decrypted fragment from input.\n    encrypted_message = stdin[:stdin.find('\\n')]\n    decrypted_fragment = stdin[stdin.find('\\n') + 1:]\n    \n    # Define keys.\n    keys = [chr(i) for i in range(ord('a'), ord('z') + 1)]\n    \n    # Search for the unique substring.\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i:].startswith(decrypted_fragment):\n            return encrypted_message[:i + len(decrypted_fragment)]\n    \n    # Return the number of substring positions.\n    return str(len(encrypted_message) - len(decrypted_fragment) + 1)"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    program = stdin.split('\\n')[1]\n    \n    def move(P, cmd):\n        for c in cmd:\n            if c == '<':\n                P = P[:len(P)//2]\n            elif c == '>':\n                P = P[len(P)//2:]\n            elif c == '^':\n                P = P[1:]\n            elif c == 'v':\n                P = P[:-1]\n        return P\n    \n    P = program[0]\n    for i in range(1, N):\n        P = move(P, program[i])\n        \n    if P.count('R') == 1:\n        return '1'\n    \n    for x in range(1, N):\n        P = move(P, program[x])\n        if P.count('R') == N and P.count('.') == N:\n            return str(x)\n    \n    return '-1'\n    \n    \n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    program = stdin.split('\\n')[1]\n    # is_repeat = False\n    # last_trail = []\n    # for i in range(N):\n    #     for j in range(N):\n    #         if grid[i][j] == 'R':\n    #             start_row = i\n    #             start_col = j\n    # is_repeat = False\n    # last_trail = []\n    # for i in range(N):\n    #     for j in range(N):\n    #         if grid[i][j] == 'R':\n    #             start_row = i\n    #             start_col = j\n    #             is_repeat = False\n    #             last_trail = []\n    #             for k in range(len(program)):\n    #                 if k > 0 and program[k]!= program[k-1]:\n    #                     last_trail.append(k - 1)\n    #                 if grid[i][j] == 'R':\n    #                     if program[k] == '>' and i < N-1 and grid[i+1][j] == '.':\n    #                         i += 1\n    #                     if program[k] == '<' and i > 0 and grid[i-1][j] == '.':\n    #                         i -= 1\n    #                     if program[k] == '^' and j < N-1 and grid[i][j+1] == '.':\n    #                         j += 1\n    #                     if program[k] == 'v' and j > 0 and grid[i][j-1] == '.':\n    #                         j -= 1\n    #                     if program[k] == '>' and i < N-1 and grid[i+1][j] == '#':\n    #                         print('a', i, j)\n    #                         i += 1\n    #                         j -= 1\n    #                     if program[k] == '<' and i > 0 and grid[i-1][j] == '#':\n    #                         print('b', i, j)\n    #                         i -= 1\n    #                         j += 1\n    #                     if program[k] == '^' and j < N-1 and grid[i][j+1] == '#':\n    #                         print('c', i, j)\n    #                         i -= 1\n    #                         j += 1\n    #                     if program[k] == 'v' and j > 0 and grid[i][j-1] == '#':\n    #                         print('d', i, j)\n    #                         i += 1\n    #                         j -= 1\n    #                     if program[k] == '>' and i < N-1 and grid[i+1][j] == '#':\n    #                         print('e', i, j)\n    #                         i += 1\n    #                         j -= 1\n    #                     if program[k] == '<' and i > 0 and grid[i-1][j] == '#':\n    #                         print('f', i, j)\n    #                         i -= 1\n    #                         j += 1\n    #                     if program[k] == '^' and j < N-1 and grid[i][j+1] == '#':\n    #                         print('g', i, j)\n    #                         i -= 1\n    #                         j += 1\n    #                     if program[k] == 'v' and j > 0 and grid[i][j-1] =="
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = [int(num) for num in stdin.split('\\n')[0].split()]\n    field = [stdin.split('\\n')[i] for i in range(1, rows + 1)]\n    row_len = len(field[0])\n    path = [field[i][j] for j in range(row_len) for i in range(rows)]\n    stack = []\n    x = 0\n    for i in range(row_len):\n        try:\n            if path[i] == '<':\n                x -= 1\n            elif path[i] == '>':\n                x += 1\n            elif path[i] == '^':\n                x += int(rows / 2)\n            elif path[i] == 'v':\n                x -= int(rows / 2)\n            if x >= row_len or x < 0:\n                continue\n            if path[i + 1] == '<':\n                if stack and stack[-1] == '>':\n                    stack.pop()\n                else:\n                    stack.append(path[i])\n            elif path[i + 1] == '>':\n                if stack and stack[-1] == '<':\n                    stack.pop()\n                else:\n                    stack.append(path[i])\n            elif path[i + 1] == '^':\n                if stack and stack[-1] == 'v':\n                    stack.pop()\n                else:\n                    stack.append(path[i])\n            elif path[i + 1] == 'v':\n                if stack and stack[-1] == '^':\n                    stack.pop()\n                else:\n                    stack.append(path[i])\n        except:\n            pass\n    print(''.join(stack))\n    return ''"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    GL_bot = lines[1]\n    moves = {\n        \"<\": (-1, 0),\n        \">\": (1, 0),\n        \"v\": (0, 1),\n        \"^\": (0, -1),\n    }\n    grid = [list(line) for line in lines[2:]]\n    position = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \"R\":\n                position = (i, j)\n    moves = [moves[i] for i in GL_bot]\n    tape = []\n    while position is not None:\n        tape.append(position)\n        for i in range(len(moves)):\n            move = moves.pop(0)\n            if grid[position[0] + move[0]][position[1] + move[1]]!= \"#\":\n                position = (position[0] + move[0], position[1] + move[1])\n                break\n            if len(moves) == 0:\n                break\n    path = set()\n    for i, j in tape:\n        path.add((i, j))\n        if (i, j) == (0, 0):\n            break\n    current = 0\n    while current < len(tape):\n        for i in range(len(tape) - current - 1):\n            if tape[current + i] == tape[current + i + 1]:\n                path.add(tape[current + i])\n                current += 1\n            else:\n                break\n    last_location = tape[-1]\n    if len(tape) == 1:\n        return 1\n    for i in range(len(tape) - 1):\n        if tape[i] == last_location and tape[i + 1] == last_location:\n            break\n    else:\n        return 1\n    return len(tape) - (i + 2)\n\n\nassert solution(\"5\\n>^<^\") == 2\nassert solution(\"4\\n>^<^\") == 4\nassert solution(\"4\\n<<<\") == 1\nassert solution(\"6\\n>^<^\") == 2\nassert solution(\"4\\nv<^>\") == 4\nassert solution(\"4\\nv<^>\") == 4\nassert solution(\"4\\nv<<<<\") == 1\nassert solution(\"4\\nv<<<<\") == 1\nassert solution(\"6\\nv<^>\") == 4\nassert solution(\"6\\nv<^>\") == 4\nassert solution(\"6\\n^<<<\") == 1\nassert solution(\"6\\n^<<<\") == 1\nassert solution(\"6\\n^<<<\") == 1\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n>^<^\") == 2\nassert solution(\"5\\n>^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert solution(\"5\\n^<^\") == 2\nassert"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\\n\")\n    grid = inputs[0]\n    program = inputs[1]\n    lines = grid.split(\"\\n\")\n    if len(lines[0]) == len(lines[-1]):\n        if all(line.count(\"#\") == 0 for line in lines):\n            return \"1\"\n        if len(lines) == 1:\n            return \"2\"\n        if len(lines) > 1:\n            return len(lines)\n    else:\n        return \"1\" if lines[0][0] == \"#\" else \"2\"\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def walk(start: tuple) -> tuple:\n        nonlocal empty, occupied\n        x, y = start\n        for dir in stdin:\n            if dir == '<':\n                x -= 1\n            elif dir == '>':\n                x += 1\n            elif dir == 'v':\n                y -= 1\n            elif dir == '^':\n                y += 1\n            else:\n                break\n            if not (0 <= x < width and 0 <= y < width):\n                break\n            if (x, y) not in empty:\n                break\n        else:\n            return (x, y)\n        return None\n\n    width = stdin.find('\\n')\n    empty = {(i, j) for i in range(width) for j in range(width) if stdin[i+j] == '.'}\n    occupied = {(i, j) for i in range(width) for j in range(width) if stdin[i+j] == '#'}\n    for i in range(width*width):\n        loc = walk((i % width, i // width))\n        if loc is not None:\n            break\n    else:\n        return '1'\n    return str(len(occupied - empty))"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    s = stdin[1]\n    grid = [stdin[i+1] for i in range(0, len(stdin)-1, n)]\n\n    def get_direction(s, x):\n        if s == '>':\n            return x + 1, 0\n        elif s == '<':\n            return x - 1, 0\n        elif s == '^':\n            return 0, x + 1\n        else:\n            return 0, x - 1\n\n    # \uacb0\uacfc\ub97c \ub2f4\uc744 \ubc30\uc5f4\n    result = []\n    # \ucd08\uae30\uac12 \uc124\uc815\n    i = n // 2\n    j = n // 2\n    x, y = j, i\n    # \ud604\uc7ac \uc704\uce58\ub97c \uc800\uc7a5\n    result.append((x, y))\n    # \uc2dc\uc791 \uc88c\ud45c \uc800\uc7a5\n    start = (j, i)\n    # \uc2dc\uc791 \uc88c\ud45c\uc758 \uc774\ub3d9 \ubc29\ud5a5 \uc800\uc7a5\n    direction = (0, 1)\n\n    for c in s:\n        # \ud604\uc7ac \uc88c\ud45c\uc5d0\uc11c \ud558\ub098\uc529 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \ubc29\ud5a5 \ucc3e\uae30\n        # \ud604\uc7ac \uc88c\ud45c\uc640 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \ubc29\ud5a5\uc758 \ud569\uc774 4\uac00 \ub118\uc9c0 \uc54a\uc73c\uba74 \uc774\ub3d9 \uac00\ub2a5\ud558\ubbc0\ub85c \uc774\ub3d9\n        if c == '>' or c == '<':\n            x, y = get_direction(c, x)\n            if 0 <= x < n and 0 <= y < n and grid[y][x]!= '#':\n                result.append((x, y))\n        else:\n            if c == 'v':\n                x, y = get_direction(c, x)\n                if 0 <= x < n and 0 <= y < n and grid[y][x]!= '#':\n                    result.append((x, y))\n            else:\n                x, y = get_direction(c, x)\n                if 0 <= x < n and 0 <= y < n and grid[y][x]!= '#':\n                    result.append((x, y))\n\n        # \ub2e4\uc74c \uc774\ub3d9\ud560 \ubc29\ud5a5 \uc800\uc7a5\n        x, y = result[-1]\n        next_direction = (x - result[-2][0], y - result[-2][1])\n        # \ub2e4\uc74c \uc774\ub3d9\ud560 \ubc29\ud5a5\uc774 \uc774\ub3d9\ud558\ub294 \ubc29\ud5a5\uc778 \uacbd\uc6b0\n        if direction == next_direction:\n            # \uc774\ub3d9 \uac00\ub2a5\ud558\ubbc0\ub85c \uadf8\ub300\ub85c \uc774\ub3d9\n            x, y = next_direction\n        # \ub2e4\uc74c \uc774\ub3d9\ud560 \ubc29\ud5a5\uc774 \ufffd"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, lines = map(int, stdin.split())\n    command = stdin.split()[1]\n    grids = [list(l) for l in stdin.split()[2:]]\n    passed = []\n    for g in grids:\n        passed.append(sum(1 for e in g if e == '#'))\n    x = 0\n    y = 0\n    x_passed = set()\n    y_passed = set()\n    for i in range(n * n):\n        if x >= 0 and x < n and y >= 0 and y < n:\n            if passed[y][x] == 0:\n                passed[y][x] = 1\n                if command[i] == '<':\n                    x -= 1\n                elif command[i] == '>':\n                    x += 1\n                elif command[i] == 'v':\n                    y -= 1\n                elif command[i] == '^':\n                    y += 1\n                if x not in x_passed or y not in y_passed:\n                    x_passed.add(x)\n                    y_passed.add(y)\n                else:\n                    x += 1\n                    y += 1\n            else:\n                passed[y][x] = 0\n                if command[i] == '<':\n                    x -= 1\n                elif command[i] == '>':\n                    x += 1\n                elif command[i] == 'v':\n                    y -= 1\n                elif command[i] == '^':\n                    y += 1\n        else:\n            x += 1\n            y += 1\n            passed[y][x] = 0\n            if command[i] == '<':\n                x -= 1\n            elif command[i] == '>':\n                x += 1\n            elif command[i] == 'v':\n                y -= 1\n            elif command[i] == '^':\n                y += 1\n            x_passed.add(x)\n            y_passed.add(y)\n    if len(x_passed) == n * n:\n        return '1'\n    elif len(x_passed) == 0:\n        return '2'\n    else:\n        return str(len(x_passed))\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    grid = stdin.split(\"\\n\")\n    N = int(grid[0])\n    grid = grid[1:]\n    path = grid[0]\n    grid = grid[1:]\n    print(grid)\n    if len(path) > N:\n        return 1\n    grid = []\n    for row in grid:\n        row = row.strip()\n        grid.append(row)\n    print(grid)\n    print(path)\n    return 1\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    n, *args = map(int, stdin.split())\n    return str(count_missed_fogs(*args))\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input()\n    for i in range(int(stdin.split()[0])):\n        l, r, h, d, dx, dh = map(int, stdin.split()[i * 8 + 1: i * 8 + 9])\n        d += dx\n        h += dh\n        l = max(l, 0)\n        r = min(r, 10 ** 8)\n        h = max(h, 1)\n        d = max(d, 1)\n        print(l, r, h, d)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution function\"\"\"\n    pass  # replace pass with your implementation"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Takes input of parameters of all originator fog and checks the number of fogs missed.\n    Parameters:\n        stdin (str): input of parameters of all originator fog\n    Returns:\n        str: output of the total number of fogs missed\n    '''\n    try:\n        n = int(stdin.split()[0])\n        fog_list = []\n        for i in range(0, n):\n            line = stdin.split()[i * 8 + 1 : i * 8 + 11]\n            line = [int(line[i]) for i in range(len(line))]\n            fog_list.append(line)\n        result = 0\n        for i in range(0, n):\n            for j in range(i + 1, n):\n                for k in range(0, fog_list[i][0]):\n                    if fog_list[j][0] - k <= 0:\n                        break\n                    if (fog_list[i][1] + k - fog_list[i][3]) * fog_list[j][4] <= 0:\n                        break\n                    elif fog_list[i][4] < fog_list[j][4] and (fog_list[j][1] + k - fog_list[j][3]) * fog_list[i][4] < 0:\n                        if fog_list[i][3] + (k - fog_list[i][4]) * fog_list[i][6] < fog_list[j][3] + (k - fog_list[j][4]) * fog_list[j][6]:\n                            result += 1\n        return str(result)\n    except:\n        return \"Error: incorrect input.\"\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return None"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n = int(stdin.readline())\n    fog_list = []\n    for i in range(n):\n        fog_list.append(list(map(int, stdin.readline().split())))\n    fog_set = set()\n    fog_set_list = []\n    for i in range(n):\n        for j in range(fog_list[i][0]):\n            fog_set.add(i + 1)\n            fog_set_list.append(i + 1)\n    num_day = 0\n    while fog_set:\n        fog_set = set()\n        for i in range(n):\n            if fog_set_list[i] == fog_list[i][1] + fog_list[i][2]:\n                fog_list[i][0] = fog_list[i][0] - fog_list[i][3]\n                if fog_list[i][0] == 0:\n                    fog_set.add(i + 1)\n                    fog_set_list[i] = fog_list[i][1] + fog_list[i][2]\n                    fog_list[i][1] = fog_list[i][1] + fog_list[i][3]\n                else:\n                    fog_list[i][1] = fog_list[i][1] + fog_list[i][3]\n                num_day += fog_list[i][3]\n    return num_day\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total_missed = 0\n    # Get input from stdin\n    n = int(stdin.readline())\n    lst = []\n    for _ in range(n):\n        lst.append(list(map(int, stdin.readline().split())))\n\n    for i in range(n):\n        num_missed = 0\n        l = lst[i][0]\n        r = lst[i][1]\n        h = lst[i][2]\n        num_fogs = lst[i][3]\n        d = lst[i][4]\n        Dx = lst[i][5]\n        Dh = lst[i][6]\n        for j in range(num_fogs):\n            x = (j * Dx) + l\n            y = 0\n            h = (j * Dh) + h\n            if j!= num_fogs-1:\n                x += (Dx*j)\n            # Remove the previous iteration of the loop so that the x is only updated if j isn't the last iteration of the loop\n            if j!= 0:\n                y += Dh\n            if x >= r and x <= r + 10:\n                if y >= 0 and y <= h:\n                    num_missed += 1\n        # Add the num_missed to the total_missed\n        total_missed += num_missed\n\n    # Return the total_missed\n    return total_missed"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\"\"\"\n    pass\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve solution\"\"\"\n\n    pass\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, xf, yf = map(float, stdin.split('\\n')[0].split())\n    n = int(stdin.split('\\n')[1])\n    conveys = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, stdin.split('\\n')[i + 2].split())\n        conveys.append(((x1, y1), (x2, y2)))\n    \n    return '{:.6f}'.format(distance(x0, y0, xf, yf, conveys))\n\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    N = int(stdin)\n    conveyor = []\n    for _ in range(N):\n        conveyor.append(list(map(float, stdin.split())))\n    return 0\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes in the input and returns the output\n    '''\n    # Initializing the input variables\n    origin = list(map(float, stdin.split()))\n    num_conveyors = int(stdin.split()[0])\n    conveyors = []\n    for i in range(num_conveyors):\n        conveyors.append(list(map(float, stdin.split()[1 + 4 * i : 1 + 4 + 4 * i])))\n\n    # initializing the output variables\n    answer = \"\"\n\n    # Logic of the problem\n    # if we can't walk from origin to destination, we won't be able to walk either way from any conveyor\n    # so, we can't reach destination\n    if (abs(origin[0] - conveyors[0][0]) + abs(origin[1] - conveyors[0][1]) > abs(conveyors[0][2] - conveyors[0][0]) + abs(conveyors[0][3] - conveyors[0][1])):\n        answer = \"IMPOSSIBLE\"\n        return answer\n    # if we can't walk from origin to destination, we can't walk from any conveyor\n    # so, we can't reach destination\n    if (abs(origin[0] - conveyors[1][0]) + abs(origin[1] - conveyors[1][1]) > abs(conveyors[1][2] - conveyors[1][0]) + abs(conveyors[1][3] - conveyors[1][1])):\n        answer = \"IMPOSSIBLE\"\n        return answer\n    # if we can't walk from origin to destination, we can't walk from any conveyor\n    # so, we can't reach destination\n    if (abs(origin[0] - conveyors[2][0]) + abs(origin[1] - conveyors[2][1]) > abs(conveyors[2][2] - conveyors[2][0]) + abs(conveyors[2][3] - conveyors[2][1])):\n        answer = \"IMPOSSIBLE\"\n        return answer\n    # if we can't walk from origin to destination, we can't walk from any conveyor\n    # so, we can't reach destination\n    if (abs(origin[0] - conveyors[3][0]) + abs(origin[1] - conveyors[3][1]) > abs(conveyors[3][2] - conveyors[3][0]) + abs(conveyors[3][3] - conveyors[3][1])):\n        answer = \"IMPOSSIBLE\"\n        return answer\n    # if we can't walk from origin to destination, we can't walk from any conveyor\n    # so, we can't reach destination\n    if (abs(origin[0] - conveyors[4][0]) + abs(origin[1] - conveyors[4][1]) > abs(conveyors[4][2] - conveyors[4][0]) + abs(conveyors[4][3] - conveyors[4][1])):\n        answer = \"IMPOSSIBLE\"\n        return answer\n\n    # there are only four conveys, so we don't need to check for any other ones\n    # if all the points are on one conveyor, there is no solution\n    if (conveyors[0][0] == conveyors[0][2] and conveyors[0][1] == conveyors[0][3] and conveyors[0][0] == conveyors[1][0] and conveyors[0][1] == conveyors[1][1] and conveyors[0][0] == conveyors[2][0] and conveyors[0][1] == conveyors[2][1] and conveyors[0][0] == conveyors[3][0] and conveyors[0][1] == conveyors[3][1] and conveyors[0][0] == conveyors[4][0] and conveyors[0][1] == conveyors[4][1]):\n        answer = \"IMPOSSIBLE\"\n        return answer\n\n    # if the first point is the origin, then we can walk from there\n    if (origin[0] == conveyors[0][0] and origin[1] == conveyors[0][1]):\n        answer = 0\n        return answer\n\n    # if there is a point on the first conveyor, we can walk from there\n    if (conveyors[0][0] == conveyors[0][2]):\n        answer = abs(conveyors[0][0] - origin[0]) + abs(conveyors[0][1] - origin[1])\n        return answer\n\n    # if there is a point on the first conveyor, we can walk from there\n    if (conveyors[0][0] == origin[0] and conveyors[0][1] == origin[1]):\n        answer = 0\n        return answer\n\n    # if there is a point on the first conveyor, we can walk from there\n    if (origin[0] == conveyors[0][0] and conveyors[0][1] == origin[1]):\n        answer = 0\n        return answer\n\n    # if there is a point on the first conveyor, we can walk from there\n    if (conveyors[0][0] == origin[0] and conveyors[0][1] == origin[1]):\n        answer = 0\n        return answer"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, x1, y1 = [float(x) for x in stdin.splitlines()[0].split()]\n    n = int(stdin.splitlines()[1])\n    l = []\n    for _ in range(n):\n        l.append([float(x) for x in stdin.splitlines()[_].split()])\n    l = sorted(l, key=lambda x: x[1])\n\n    def f(x0, y0, x1, y1):\n        if x1 < x0:\n            x0, x1 = x1, x0\n            y0, y1 = y1, y0\n        if x1 == x0:\n            return y0 <= y1\n        mid = (x1 + x0) / 2\n        return f(x0, y0, mid, y1) or f(mid, y0, x1, y1)\n\n    return f(x0, y0, x1, y1)\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A = [int(x) for x in stdin.split()[:4]]\n    B = [int(x) for x in stdin.split()[4:]]\n    X = [x for x in range(A[0], B[0]+1)]\n    Y = [y for y in range(A[1], B[1]+1)]\n    data = {}\n    for x in X:\n        for y in Y:\n            data[(x, y)] = []\n    for i in range(0, len(X)-1):\n        for j in range(0, len(Y)-1):\n            a = (X[i], Y[j])\n            b = (X[i+1], Y[j])\n            c = (X[i+1], Y[j+1])\n            d = (X[i], Y[j+1])\n            if abs(X[i+1] - X[i]) <= 1 and abs(Y[j+1] - Y[j]) <= 1:\n                data[a].append([b, 2])\n                data[b].append([c, 2])\n            if abs(X[i+1] - X[i]) <= 1 and abs(Y[j] - Y[j+1]) <= 1:\n                data[a].append([d, 1])\n                data[d].append([b, 1])\n    t = 0\n    x, y = A[0], A[1]\n    while x!= B[0] or y!= B[1]:\n        if (x, y) not in data:\n            x += 1\n            continue\n        if len(data[(x, y)]) == 0:\n            x += 1\n            y += 1\n            continue\n        t += data[(x, y)][0][1]\n        x, y = data[(x, y)][0][0]\n    return t\n    \n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(float, stdin.split('\\n')[0].split())\n    n = int(stdin.split('\\n')[1])\n\n    # creating the structure of the graph\n    g = {i: [] for i in range(n)}\n    for line in stdin.split('\\n')[2:]:\n        x1, y1, x2, y2 = map(float, line.split())\n        g[int((x1 + x2) / 2)].append(((x1 + x2) / 2, int((y1 + y2) / 2)))\n\n    # print(f\"g: {g}\")\n    #  create the queue to explore the graph\n    queue = deque()\n    queue.append((a, b, 0))\n    # create the visited dict\n    visited = {(a, b)}\n\n    # explore the graph\n    while queue:\n        cur, dest, steps = queue.popleft()\n        for c in g[cur]:\n            if c == dest:\n                # print(f\"steps: {steps}\")\n                return steps\n            if c not in visited:\n                visited.add(c)\n                queue.append((c[0], c[1], steps + c[1]))\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds shortest distance between two points on a 2-D plane.\n\n    Args:\n        stdin (str): Input string with two floating point numbers as coordinates of start and end point\n\n    Returns:\n        str: Distance in floating point number between two points\n    \"\"\"\n    x1, y1, x2, y2 = [float(num) for num in stdin.split()]\n    \n    return str(math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2))\n\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the time needed to walk from stdin[0] to stdin[1]\n\n    Args:\n        stdin (str): The input string\n\n    Returns:\n        str: The answer to the question\n    \"\"\"\n    inputs = stdin.split('\\n')\n    # Inputs\n    # X_A, Y_A, X_B, Y_B\n    x_a = float(inputs[0].split(' ')[0])\n    y_a = float(inputs[0].split(' ')[1])\n    x_b = float(inputs[0].split(' ')[2])\n    y_b = float(inputs[0].split(' ')[3])\n\n    # Conveyors\n    conveyors = []\n    for i in range(1, len(inputs)-1):\n        x_1 = float(inputs[i].split(' ')[0])\n        y_1 = float(inputs[i].split(' ')[1])\n        x_2 = float(inputs[i].split(' ')[2])\n        y_2 = float(inputs[i].split(' ')[3])\n        conveyors.append([x_1, y_1, x_2, y_2])\n\n    # Time\n    time = 0\n    # Compute the time to walk from A to B\n    # Find all the conveysors that are close enough to A\n    close_conveyors = []\n    for i in range(len(conveyors)):\n        x_1 = conveyors[i][0]\n        y_1 = conveyors[i][1]\n        x_2 = conveyors[i][2]\n        y_2 = conveyors[i][3]\n        if math.sqrt((x_a-x_1)**2+(y_a-y_1)**2) < math.sqrt((x_b-x_1)**2+(y_b-y_1)**2):\n            close_conveyors.append(i)\n    # Now that we have all the close conveyors, we can iterate through them to compute the time to walk on them\n    for i in range(len(close_conveyors)):\n        x_1 = conveyors[close_conveyors[i]][0]\n        y_1 = conveyors[close_conveyors[i]][1]\n        x_2 = conveyors[close_conveyors[i]][2]\n        y_2 = conveyors[close_conveyors[i]][3]\n        # Compute the time to walk from A to the closest point on the convex hull\n        # Get the convex hull\n        # Also compute the time to walk from the convex hull to B\n        # Walk on the convex hull\n        # Add the convex hull walking to the total time\n        # Walk from the convex hull to B\n        # Add the time to walk from the convex hull to B\n        # print(x_1, y_1, x_2, y_2)\n        if x_1 == x_2:\n            x_1 = x_1 - 0.0001\n        if y_1 == y_2:\n            y_1 = y_1 - 0.0001\n        a = (y_1-y_a)/(x_1-x_a)\n        b = (y_1*x_1-y_a*x_1)/(x_1-x_a)\n        x_min = (b-y_1)/a\n        x_max = (y_2-y_1)/(x_2-x_1)\n        y_min = a*x_min + b\n        y_max = a*x_max + b\n        if x_1 < x_min:\n            x_min = x_1\n        if x_1 > x_max:\n            x_max = x_1\n        if x_min < x_a:\n            x_min = x_a\n        if x_max > x_a:\n            x_max = x_a\n        if x_min > x_b:\n            x_min = x_b\n        if x_max < x_b:\n            x_max = x_b\n        if y_1 < y_min:\n            y_min = y_1\n        if y_1 > y_max:\n            y_max = y_1\n        if y_min < y_a:\n            y_min = y_a\n        if y_max > y_a:\n            y_max = y_a\n        if y_min > y_b:\n            y_min = y_b\n        if y_max < y_b:\n            y_max = y_b\n        if x_max-x_min > 0:\n            time += abs(y_b-y_min)/math.sqrt((x_b-x_min)**2+(y_b-y_min)**2)\n        time += abs(x_a-x_min)/math.sqrt((x_a-x_min)**2+(y_a-y_min)**2)\n        time += abs(x_max-x_b)/math.sqrt((x_max-x_b)**2+(y_max-y_b)**2)\n        if y"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    XA, YA, XB, YB = map(float, stdin.split(\" \"))\n    N = int(stdin.split(\"\\n\")[1])\n    L = []\n    for i in range(N):\n        L.append(list(map(float, stdin.split(\"\\n\")[2 + i].split(\" \"))))\n\n    ans = 1000 ** 2 * 1000\n\n    def walk(XA, YA, XB, YB):\n        if XA == XB and YA == YB:\n            return 0\n        step = 0\n        for j in range(len(L)):\n            step += walk(XA, YA, L[j][0], L[j][1]) + walk(L[j][0], L[j][1], L[j][2], L[j][3]) + 2 * walk(L[j][0], L[j][1], L[j][2], L[j][3])\n        return step\n\n    ans = min(ans, walk(XA, YA, XB, YB))\n\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum time needed to get from (0,0) to (A,B).\"\"\"\n    A, B = [float(x) for x in stdin.split()]\n    # convert coordinates to integers\n    A = int(A)\n    B = int(B)\n    return str(round(abs(A-B)*1e3 / (2 * 1e3)))\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\"\"\""
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = stdin.split()\n    N = int(N)\n    K = int(K)\n    P = int(P)\n    if K >= N:\n        if P < N:\n            return 'IMPOSSIBLE'\n        else:\n            return ''.join([chr(97 + i) for i in range(K)])\n    if N % K!= 0:\n        return 'IMPOSSIBLE'\n    K_chars = set()\n    for i in range(N // K):\n        K_chars.add(chr(97 + i))\n    if P % 2 == 1:\n        for char in K_chars:\n            if char * (P // 2 + 1) == ''.join(reversed(char * (P // 2 + 1))):\n                return char * (P // 2)\n    else:\n        for char in K_chars:\n            if char * P == ''.join(reversed(char * P)):\n                return char * (P // 2)\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if (N == 1) or (P == 1):\n        return \"IMPOSSIBLE\"\n    \n    if (K == 26) and (P == N):\n        return \"\".join(stdin.split()[1:])\n    \n    for i in range(len(stdin.split()), N):\n        for j in range(i, i + P):\n            if j >= N:\n                break\n            \n            if stdin.split()[j] not in stdin.split()[i] or stdin.split()[j] == stdin.split()[j][::-1]:\n                break\n            \n            if j == i + P - 1:\n                return \"\".join(stdin.split()[1:])\n    \n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = stdin.split()\n    return \"IMPOSSIBLE\"\n    \n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = (int(x) for x in stdin.split())\n    s = 'abcdefghijklmnopqrstuvwxyz'\n    p -= 1\n    while len(s) <= n:\n        s += s[::-1]\n    if k > 26:\n        return 'IMPOSSIBLE'\n    return ''.join(sorted(s[p: p + n]))"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = [int(i) for i in stdin.split()]\n    if N < 1 or N > 10**6:\n        return \"IMPOSSIBLE\"\n    if K < 1 or K > 26:\n        return \"IMPOSSIBLE\"\n    if P < 1 or P > N:\n        return \"IMPOSSIBLE\"\n    \n    letter_set = set(chr(97+i) for i in range(K))\n    if len(letter_set)!= K:\n        return \"IMPOSSIBLE\"\n    \n    for length in range(P, N+1):\n        for start in range(N-length+1):\n            s = stdin[start:start+length]\n            if s == s[::-1]:\n                return s"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    for pal in range(1, n):\n        if k < len(set(stdin[:pal].lower())) and is_palindromic(stdin[:pal], pal):\n            return palindromic(stdin[:pal], p)\n    return 'IMPOSSIBLE'\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = [int(i) for i in stdin.split(' ')]\n    a = string.ascii_lowercase\n    b = list(itertools.combinations_with_replacement(a, N))\n    c = []\n    for i in b:\n        if len(set(i)) == K and len(max(list(set(i))),P) == P:\n            c.append(''.join(i))\n    if c:\n        return max(c)\n    else:\n        return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = (int(i) for i in stdin.split())\n    \n    # The `set` object evaluates to false if the input has duplicate characters\n    return next((l for l in 'abcdefghijklmnopqrstuvwxyz' if len(l) == n and k == len(set(l)) and p == len(max((l[i:len(l)-i] for i in range(len(l))), key=lambda i: len(i)))), 'IMPOSSIBLE')"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = [int(x) for x in stdin.split(\" \")]\n    for i in range(N, P-1, -1):\n        if (\n            K\n            == len(set(stdin[:i]))\n            == len(set(stdin[i:][::-1]))\n            == len(set(stdin[:i][i:][::-1]))\n        ):\n            return stdin[:i]\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"Blue Ridge mountain road. Leaves, glowing in autumn sun, fall in Virginia.\")\n    \"Blue Ridge mountain road.\\nLeaves, glowing in autumn sun,\\nfall in Virginia.\"\n    >>> solution(\"Who would know if we had too few syllables?\")\n    \"Who would know if we had too few syllables?\"\n    >>> solution(\"International contest- motivation high Programmers have fun!\")\n    \"International contest-\\nmotivation high\\nProgrammers have fun!\"\n    \"\"\"\n\n    # group words\n    words = stdin.split()\n\n    # make list of syllables\n    syllables = []\n    for word in words:\n        # remove punctuation\n        word = word.rstrip('?!')\n        # split into list of consonants and vowels\n        consonants = ''\n        vowels = ''\n        for i in range(len(word)):\n            if word[i] in 'AEIOUYaeiouy':\n                vowels += word[i]\n            else:\n                consonants += word[i]\n        # group consonants into syllables\n        if consonants:\n            syllables.append(consonants)\n        # group vowels into syllables\n        if vowels:\n            syllables.append(vowels)\n\n    # join syllables\n    syllables = ''.join(syllables)\n\n    # split syllables into haiku\n    half = len(syllables) // 2\n    if len(syllables) % 2 == 0:\n        syllables_1 = syllables[:half]\n        syllables_2 = syllables[half:]\n    else:\n        syllables_1 = syllables[:half]\n        syllables_2 = syllables[half + 1:]\n\n    # join syllables into haiku\n    haiku = [syllables_1.center(10,''), '\\n', syllables_2.center(10,'')]\n\n    return ''.join(haiku)\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOUYaeiouy\"\n    stdin = stdin.split()\n    for line in stdin:\n        line = [char for char in line if char.isalnum()]\n        line = \"\".join(line)\n        if len(line) < 7:\n            continue\n        line = \"\".join(line.split(\"QU\"))\n        if len(line) < 7:\n            continue\n        if line.count(\"W\") > 1:\n            continue\n        if line[-1] in vowels and not line[-2] in vowels:\n            continue\n        if not line[1] in vowels:\n            continue\n        for char in line:\n            if char in vowels:\n                cnt += 1\n        if cnt == 5:\n            if not line[1] in vowels:\n                continue\n            if line[-1] in vowels:\n                continue\n            return line\n        cnt = 0\n    return \"Hmmm.. This ain't a haiku.\"\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllable(line):\n        nonlocal c\n        nonlocal ret\n        nonlocal words\n        nonlocal v\n        words += 1\n        for i, v in enumerate(line):\n            if v.isalpha() or v == \" \":\n                continue\n            if v in v:\n                if v.upper() == \"V\" and line[i-1].upper() not in [\"I\", \"E\", \"O\", \"U\"]:\n                    continue\n                elif v.upper() in [\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"]:\n                    if c == 2:\n                        ret += \" \"\n                    elif c == 0 and i == len(line)-1:\n                        continue\n                    c += 1\n                elif v.upper() in [\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"W\", \"X\", \"Y\", \"Z\"]:\n                    continue\n                else:\n                    ret += v\n                    continue\n            else:\n                if v.upper() in [\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"W\", \"X\", \"Y\", \"Z\"]:\n                    continue\n                elif v.upper() == \"V\" and line[i-1].upper() not in [\"I\", \"E\", \"O\", \"U\"]:\n                    continue\n                elif v.upper() in [\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"]:\n                    if c == 2:\n                        ret += \" \"\n                    elif c == 0 and i == len(line)-1:\n                        continue\n                    c += 1\n                else:\n                    ret += v\n                    continue\n        if c == 0:\n            c = 1\n        else:\n            c = 2\n    def del_last(line: str) -> str:\n        nonlocal l\n        if l < 0:\n            l = len(line) - 1\n        if l < 0:\n            return line\n        return line[:l]\n    def is_valid(line: str) -> bool:\n        nonlocal words\n        nonlocal ret\n        for i, v in enumerate(line):\n            if v.isalpha() or v == \" \":\n                continue\n            elif v.upper() in [\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"W\", \"X\", \"Y\", \"Z\"]:\n                continue\n            elif v.upper() in [\"A\", \"E\", \"I\", \"O\", \"U\", \"Y\"]:\n                if c == 2:\n                    ret += \" \"\n                elif c == 0 and i == len(line)-1:\n                    continue\n                c += 1\n            elif v.upper() in [\"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"W\", \"X\", \"Y\", \"Z\"]:\n                continue\n            else:\n                ret += v\n        if c == 0:\n            c = 1\n        else:\n            c = 2\n        if words == 0:\n            return False\n        return True\n    nonlocal c\n    nonlocal ret\n    nonlocal words\n    nonlocal v\n    l = 0\n    c = 0\n    ret = \"\"\n    v = set()\n    words = 0\n    for line in stdin.split(\"\\n\"):\n        line = line.strip()\n        if len(line) == 0:\n            continue\n        words = 0\n        count_syllable(line)\n        if words!= 0 and is_valid(line):\n            if c == 2:\n                ret += \" \"\n            ret += del_last(line)\n    return ret\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \n    stdin = stdin.strip()\n    \n    words = stdin.split(\" \")\n    \n    syllable_count = {}\n    for word in words:\n        \n        if word in \"?!.,'\":\n            continue\n            \n        else:\n            syllables = 0\n            consonants = 0\n            vowels = 0\n            \n            for i in word:\n                \n                if i in \"?!.,'\":\n                    break\n                \n                if i in \"AEIOU\":\n                    vowels += 1\n                \n                else:\n                    consonants += 1\n            \n            syllables += vowels\n            syllables += 1 if consonants > 1 else 0\n            syllables += 1 if consonants > 1 and word[-1] in \"AEIOU\" else 0\n            syllables += 1 if consonants == 1 and word[-1] in \"AEIOU\" else 0\n            \n            syllable_count[word] = syllables\n    \n    sorted_words = sorted(syllable_count.items(), key = lambda x: x[1], reverse = True)\n    \n    if len(sorted_words) == 1:\n        return stdin\n    \n    first = sorted_words.pop(0)\n    second = sorted_words.pop(0)\n    third = sorted_words.pop(0)\n    \n    first = first[0]\n    second = second[0]\n    third = third[0]\n    \n    if first[1] == second[1] == third[1] == 1:\n        return stdin\n    \n    elif first[1] == second[1] == 1:\n        return f\"{first} {second} {third}\"\n    \n    elif second[1] == third[1] == 1:\n        return f\"{first} {second} {third}\"\n    \n    elif first[1] == second[1] == 2:\n        return f\"{first} {third}\"\n    \n    elif first[1] == 1 and second[1] == 2 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif second[1] == 1 and third[1] == 1 and first[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 2 and second[1] == 1 and third[1] == 1:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 2 and second[1] == 2 and third[1] == 1:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 2 and second[1] == 1 and third[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 1 and second[1] == 2 and third[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 2 and second[1] == 2 and third[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 2 and second[1] == 1 and third[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 1 and second[1] == 1 and third[1] == 2:\n        return f\"{third} {first}\"\n    \n    elif first[1] == 1 and second[1] == 1 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 2 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 1 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 1 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 2 and third[1] == 1:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 1 and third[1] == 2:\n        return f\"{third} {second} {first}\"\n    \n    elif first[1] == 1 and second[1] == 2 and third[1] == 2:\n        return f\"{third} {second} {first}\""
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n  '''\n    >>> solution(\"Blue Ridge mountain road. Leaves, glowing in autumn sun, fall in Virginia.\")\n    'Blue Ridge mountain road.\\nLeaves, glowing in autumn sun,\\nfall in Virginia.'\n    >>> solution(\"Who would know if we had too few syllables?\")\n    'Who would know if we had too few syllables?'\n    >>> solution(\"International contest- motivation high Programmers have fun!\")\n    'International contest- motivation high\\nProgrammers have fun!'\n  '''\n  # Split the text into words\n  words = stdin.split()\n  # Make a list of unique vowels, and a list of consonants\n  vowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\n  consonants = set(string.ascii_lowercase) - vowels\n\n  # Define a helper method to count the syllables in a word\n  def count_syllables(word: str) -> int:\n    # If the word is empty, there are no syllables\n    if not word:\n      return 0\n    # If the word is a vowel, there is one syllable\n    elif word[0] in vowels:\n      return 1 + count_syllables(word[1:])\n    # Otherwise, if the word is a consonant, there are no syllables\n    elif word[0] in consonants:\n      return 0 + count_syllables(word[1:])\n\n  # Get the syllables for each word in the input text\n  syllables = [count_syllables(word) for word in words]\n  # If the last word has multiple syllables, and the last syllable is not a vowel\n  # and the second to last syllable is not a vowel, add a syllable to it.\n  if (syllables[-1] > 1 and syllables[-1] % 2 == 0) and not words[-1][-1] in vowels and syllables[-2] % 2 == 0:\n    syllables[-1] += 1\n\n  # Define a method to convert a list of syllables into a line of haiku\n  def syllables_to_line(syllables: List[int]) -> str:\n    # If there is only one syllable, return a line consisting of the word itself\n    if len(syllables) == 1:\n      return words[0]\n    # If there are two syllables, return the first and second words with a space between them\n    elif len(syllables) == 2:\n      return words[0] +'' + words[1]\n    # If there are three syllables, return the first, second, and third words with a space between each\n    elif len(syllables) == 3:\n      return words[0] +'' + words[1] +'' + words[2]\n\n  # If there are no valid lines, return the original text\n  if not syllables:\n    return stdin\n  # Split the text into lines, with each line being one word\n  lines = stdin.split('.')\n\n  # If there are less than three syllables in the first line, there can't be a haiku\n  if count_syllables(lines[0]) < 3:\n    return stdin\n  # If there are less than three syllables in the second line, there can't be a haiku\n  elif count_syllables(lines[1]) < 3:\n    return stdin\n  # If there are less than five syllables in the third line, there can't be a haiku\n  elif count_syllables(lines[2]) < 5:\n    return stdin\n\n  # If there are valid haiku lines, print each one\n  return syllables_to_line(syllables[:3]) + '\\n' + syllables_to_line(syllables[3:]) + '.'"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a string representing a haiku.\"\"\"\n    return \"haiku\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    names = {}\n    for i in range(n):\n        name = stdin.readline().strip()\n        names[name] = set(name)\n    thore = \"ThoreHusfeldt\"\n    return min(names[thore] - names[name] for name in names if thore in names[name])"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = [stdin for i in range(n)]\n    best = max(names)\n    for name in names:\n        if name == best:\n            return \"Thore is awesome\"\n        for other in names:\n            if name[:len(other)] == other and len(other) > len(name):\n                return \"Thore sucks\"\n    return \"ThoreH\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates the prefix ThoreHusfeldt is unique to and the longest prefix\n    of the other people on the scoreboard.\n\n    Args:\n        stdin (str): The input from stdin\n\n    Returns:\n        str: A string that contains the prefix that uniquely determines Thore\n        on the scoreboard\n    \"\"\"\n    # initialize variables\n    n = int(stdin.split()[0])\n    names = []\n    for i in range(1, n+1):\n        names.append(stdin.split()[i])\n\n    # find the longest prefix that uniquely determines Thore\n    l_th = len(names[0])\n    for name in names:\n        if len(name) < l_th:\n            l_th = len(name)\n\n    for prefix in names:\n        if prefix == 'ThoreHusfeldt':\n            continue\n        else:\n            if prefix[:l_th] == 'ThoreHusfeldt':\n                return prefix\n\n    return 'Thore is awesome'\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = [stdin.split()[0] for stdin in stdin.splitlines()[1:n + 1]]\n    if \"ThoreHusfeldt\" in names:\n        return \"Thore is awesome\"\n    best_name = sorted(names, key=lambda x: x.find(\"ThoreH\"))[-2]\n    return best_name[:best_name.find(\"ThoreH\")]\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    1. Assume Thore is not on the scoreboard.\n    2. For each prefix of ThoreHusfeldt, check if Thore is on the scoreboard.\n    3. If so, output \u201cThore is awesome\u201d.\n    4. Else output the smallest prefix of \u201cThoreHusfeldt\u201d that no-one above \u201cThoreHusfeldt\u201d shares.\n    '''\n    # read input\n    n = int(stdin.split(\"\\n\")[0])\n    names = stdin.split(\"\\n\")[1:]\n    thore = names[0]\n\n    # check for ThoreHusfeldt on the scoreboard\n    for prefix in names:\n        if prefix == thore:\n            return \"Thore is awesome\"\n\n    # get shortest prefix\n    best = thore\n    for prefix in names:\n        if prefix[:len(thore)]!= thore and prefix < thore:\n            best = prefix[:len(prefix)-1]\n            break\n    return best\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for the first Kata\"\"\"\n    score_board = dict()\n    thore_score = 1\n    for name in stdin.split(\"\\n\"):\n        score_board[name] = thore_score\n        thore_score += 1\n    \n    if \"ThoreHusfeldt\" in stdin:\n        return \"Thore is awesome\"\n    elif \"ThoreHusfeldt\" in score_board:\n        score_board.pop(\"ThoreHusfeldt\")\n    for score, name in score_board.items():\n        if name == 1:\n            return f\"ThoreHusfeldt is the best ThoreH in the world\"\n        if name == 2 and score_board.get(name - 1) == \"ThoreHusfeldt\":\n            return \"Thore is awesome\"\n    return \"Thore is the best ThoreH in the world\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    best = float('inf')\n    best_thore = ''\n    for name in stdin.split('\\n')[1:]:\n        if name!= 'ThoreHusfeldt':\n            best = min(best, len(name))\n            if best == len(name):\n                best_thore = name\n    return best_thore"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.splitlines()\n    first = names[0]\n    if \"ThoreHusfeldt\" in first:\n        return \"Thore is awesome\"\n    else:\n        for index, name in enumerate(names):\n            if first in name and index > 0:\n                return f\"Thore {'is' if first == name else'sucks'} at {first[:index]}\""
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    names = stdin.split(\"\\n\")[1:]\n    thore = None\n    for name in names:\n        if name == \"ThoreHusfeldt\":\n            thore = name\n            break\n\n    count = 0\n    for name in names:\n        if name.startswith(thore):\n            count += 1\n\n    if count == 1:\n        return \"Thore is awesome\"\n    if thore.startswith(names[count - 1]):\n        return \"Thore sucks\"\n\n    for name in names:\n        if name.startswith(thore):\n            return name"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    print(sum([1 for char in stdin if char == 'L' or char == 'R' or char == 'P']))\n\n    return ''\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The idea is to define a helper function to\n    calculate the value of the set of\n    walks for a given input\n    \"\"\"\n    def compute_value(walk: str) -> int:\n        \"\"\"\n        The walk is either a jump left,\n        right or pause\n        \"\"\"\n        return sum(1 for c in walk if c == 'L') - \\\n            sum(1 for c in walk if c == 'R') + \\\n            sum(1 for c in walk if c == 'P')\n    return sum(compute_value(walk) for walk in stdin.split('*'))\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    all_moves = stdin.split('*')\n    moves_set = set()\n    for moves in all_moves:\n        current_move = ''\n        for char in moves:\n            if char == 'L':\n                current_move += 'LL'\n            elif char == 'R':\n                current_move += 'RR'\n            elif char == 'P':\n                current_move += 'PP'\n        moves_set.add(current_move)\n    return str(len(moves_set))\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    values = [0]\n    for char in stdin:\n        if char == 'L':\n            values.append(2 * values[-1] + 1)\n        elif char == 'R':\n            values.append(2 * values[-1])\n        elif char == 'P':\n            values.append(values[-1])\n        else:\n            raise ValueError(\"Input is not valid.\")\n    return sum(values)\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def diff(left, right):\n        return abs(left - right)\n\n    def get_value(left, right, left_value, right_value):\n        if left_value == 0:\n            return right_value\n        if right_value == 0:\n            return left_value\n\n        if diff(left, right) > diff(left_value, right_value):\n            return left_value\n        return right_value\n\n    walk = stdin\n\n    result = 0\n\n    left_value = 0\n    right_value = 0\n\n    for s in walk:\n        if s == \"L\":\n            left_value = right_value\n            right_value = 0\n        elif s == \"R\":\n            right_value = left_value\n            left_value = 0\n        elif s == \"P\":\n            left_value = get_value(left_value, right_value, left_value, right_value)\n            right_value = get_value(left_value, right_value, left_value, right_value)\n        else:\n            raise Exception(\"Unexpected character: {}\".format(s))\n\n    result = left_value + right_value\n\n    return str(result)\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    ans = []\n    i = 0\n    while i < len(stdin):\n        if stdin[i] == 'L':\n            ans.append(2 * int(stdin[i + 1]))\n            i += 2\n        elif stdin[i] == 'R':\n            ans.append(2 * int(stdin[i + 1]) + 1)\n            i += 2\n        else:\n            ans.append(int(stdin[i + 1]))\n            i += 2\n    return ''.join(map(str, ans))\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    statements = [line.split(\" is \") for line in lines]\n    \n    statements = [\n        (s[0], s[1])\n        for s in statements\n        if s[0][-3:] not in s[1][-3:]\n        and (s[0][-2:] == s[1][-2:])\n    ]\n    \n    return \"yes\" if statements else \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    statements: List[str] = []\n    n = int(stdin)\n    for _ in range(n):\n        statement = stdin.readline().strip()\n        statements.append(statement)\n    if n == 0:\n        return \"yes\"\n    possible_rhyme = set()\n    for statement in statements:\n        if \"is\" in statement:\n            if \"not\" in statement:\n                continue\n            rhyme = statement[-3:]\n            if \"is\" in statement:\n                rhyme = statement[-3:]\n                if rhyme[0] in possible_rhyme:\n                    possible_rhyme.remove(rhyme[0])\n                elif rhyme[1] in possible_rhyme:\n                    possible_rhyme.remove(rhyme[1])\n                else:\n                    possible_rhyme.add(rhyme[0])\n                    possible_rhyme.add(rhyme[1])\n            else:\n                rhyme = statement[-2:]\n                if rhyme[0] in possible_rhyme:\n                    possible_rhyme.remove(rhyme[0])\n                elif rhyme[1] in possible_rhyme:\n                    possible_rhyme.remove(rhyme[1])\n                else:\n                    possible_rhyme.add(rhyme[0])\n                    possible_rhyme.add(rhyme[1])\n        else:\n            rhyme = statement[-1:]\n            if rhyme[0] in possible_rhyme:\n                possible_rhyme.remove(rhyme[0])\n            elif rhyme[1] in possible_rhyme:\n                possible_rhyme.remove(rhyme[1])\n            else:\n                possible_rhyme.add(rhyme[0])\n                possible_rhyme.add(rhyme[1])\n    if len(possible_rhyme) == 0:\n        return \"yes\"\n    else:\n        return \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    def rv_rv(x,y):\n        x=x.strip().lower()\n        y=y.strip().lower()\n        if (x[-min(3,len(x)):]==y[-min(3,len(y)):]):\n            return True\n        else:\n            return False\n    n=int(stdin.split(\"\\n\")[0])\n    st=[]\n    for i in range(n):\n        x=stdin.split(\"\\n\")[i+1].split(\" \")\n        st.append(x)\n    ans=[]\n    for i in range(n):\n        x=st[i][0]\n        y=st[i][2]\n        if x.isalpha() and y.isalpha() and x.islower() and y.islower():\n            if x==y:\n                ans.append(\"no\")\n            elif x!=y:\n                if rv_rv(x,y):\n                    ans.append(\"yes\")\n                elif rv_rv(y,x):\n                    ans.append(\"yes\")\n                else:\n                    ans.append(\"wait what?\")\n    return \"\\n\".join(ans)\nprint(solution(stdin))\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    You should implement this function.\n    You should not change the input and output format.\n    \"\"\"\n    pass\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    def construct_trie(words: List[str]) -> Trie:\n        trie = Trie()\n        for word in words:\n            trie.add_word(word)\n        return trie\n\n    trie = construct_trie(stdin.splitlines()[2:])\n    return \"yes\" if trie.is_consistent() else \"wait what?\"\n    \n    \n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4\n   ... herp is derp\n   ... derp is herp\n   ... herp is herp\n   ... derp is derp\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 3\n   ... oskar not lukas\n   ... oskar is poptart\n   ... lukas is smart\n   ... ''')\n    'wait what?'\n    >>> solution('''\n   ... 1\n   ... moo not foo\n   ... ''')\n    'yes'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    statements = [x.split(\" \") for x in stdin.splitlines()]\n    stats = {}\n    for x in statements:\n        if x[0] not in stats.keys():\n            stats[x[0]] = []\n        if x[1] not in stats.keys():\n            stats[x[1]] = []\n        stats[x[0]].append(x[1])\n        stats[x[1]].append(x[0])\n    for key in stats.keys():\n        for x in stats[key]:\n            if key not in stats[x]:\n                stats[x].append(key)\n    for key in stats.keys():\n        for x in stats[key]:\n            for y in stats[x]:\n                if y not in stats[key] and key in stats[y]:\n                    stats[key].append(y)\n    for key in stats.keys():\n        if len(stats[key]) > 2:\n            print(\"wait what?\")\n            return\n    ans = True\n    for x in stats.keys():\n        if len(stats[x]) == 1:\n            ans = False\n    if ans:\n        print(\"yes\")\n    else:\n        print(\"wait what?\")\n    return ans"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    \u0423\u0441\u043b\u043e\u0432\u0438\u0435 \u0437\u0430\u0434\u0430\u0447\u0438:\n    \u0412\u044b \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\u0435 \u0432 \u043a\u0430\u0441\u0441\u0435 \u043e\u0444\u0438\u0441\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u0443\u044e \u043e\u043f\u043b\u0430\u0442\u0443 \u0437\u0430 \u0442\u043e\u0432\u0430\u0440\u044b.\n    \u0422\u0430\u043a\u0436\u0435 \u0432\u044b \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442\u0435 \u0441 \u043a\u0443\u0445\u043d\u0435\u0439 \u0438 \u0443 \u0432\u0430\u0441 \u0435\u0441\u0442\u044c \u043a\u0443\u0445\u043d\u044f.\n    \u0412\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442\u0435 \u043e\u043f\u043b\u0430\u0442\u0443 \u0437\u0430 \u0442\u043e\u0432\u0430\u0440\u044b \u0432 \u043a\u0443\u0445\u043d\u0435.\n    \u0412\u044b \u0437\u043d\u0430\u0435\u0442\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0435\u0441\u0442\u044c \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u044b\u0445 \u043a\u0443\u0445\u043d\u0435\u0439.\n    \u0422\u0430\u043a\u0436\u0435 \u0432\u044b \u0437\u043d\u0430\u0435\u0442\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0435\u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u043d\u0430 \u043a\u0443\u0445\u043d\u0435.\n    \u0412\u0430\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u044b\u044f\u0441\u043d\u0438\u0442\u044c, \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0435\u0441\u0442\u044c \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432, \u0438 \u043a\u0430\u043a\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0435\u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u043d\u0430 \u043a\u0443\u0445\u043d\u0435.\n    \u041f\u043e\u043c\u0438\u043c\u043e \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432 \u0438 \u043d\u0435\u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432 \u043d\u0430 \u043a\u0443\u0445\u043d\u0435 \u0432\u044b \u0437\u043d\u0430\u0435\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u0443\u0445\u043d\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c.\n    \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u0437\u0430\u043a\u0430\u0437\u0430\u0442\u044c \u0441\u0442\u043e\u043b\u044b \u043f\u0440\u044f\u043c\u043e \u0432 \u043a\u0443\u0445\u043d\u0435.\n    \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043e\u0442\u043a\u0430\u0437\u0430\u0442\u044c\u0441\u044f \u043e\u0442 \u043f\u0440\u043e\u0434\u0430\u0436\u0438 \u0441\u0442\u043e\u043b\u043e\u0432 \u0438\u043b\u0438 \u0432\u0435\u0440\u043d\u0443\u0442\u044c \u0435\u0435 \u043a \u0441\u0432\u043e\u0435\u043c\u0443 \u0430\u0440\u0435\u043d\u0434\u043e\u0434\u0430\u0442\u0435\u043b\u044e.\n    \u0421\u0442\u043e\u043b\u044b \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0442\u0441\u044f \u0442\u0430\u043a: \u043e\u0434\u0438\u043d \u0438\u0437 \u0441\u0442\u043e\u043b\u043e\u0432 \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442\u0441\u044f \u0441\u0442\u043e\u043b\u043e\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u0430 $1, 2, 3, \\dots, n$, \u0430 \u0434\u0440\u0443\u0433\u043e\u0439 \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442\u0441\u044f \u0441\u0442\u043e\u043b\u043e\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u0430 $m$, \u0442.\u0435. \u0442\u043e, \u0447\u0442\u043e \u043e\u043d \u0438 \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f.\n    \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u043d\u0430 \u0441\u0432\u043e\u0431\u043e\u0434\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u044b.\n    \u0412\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442\u0435 \u0434\u0435\u043d\u044c\u0433\u0438 \u043f\u0440\u0438 \u043a\u0430\u0436\u0434\u043e\u043c \u043f\u0440\u043e\u0434\u0430\u0436\u0435 \u0441\u0442\u043e\u043b\u043e\u0432\u044b\u0445.\n    \u0421\u0442\u043e\u043b\u044b \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u043c\u0435\u0441\u0442\u0430\u043c\u0438.\n    \u0412\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043e\u0442\u043a\u0430\u0437\u0430\u0442\u044c\u0441\u044f \u043e\u0442 \u0441\u0442\u043e\u043b\u043e\u0432 \u0441\u0440\u0430\u0437\u0443 \u0436\u0435 \u043f\u043e\u0441\u043b\u0435 \u0432\u044b\u0431\u043e\u0440\u0430.\n    \u041f\u043e\u043c\u0438\u043c\u043e \u0441\u0442\u043e\u043b\u043e\u0432, \u0432\u0430\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u043d\u0430\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0435\u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432 \u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0445 \u0441\u0442\u043e\u043b\u043e\u0432.\n    \u041f\u043e\u043c\u0438\u043c\u043e \u044d\u0442\u043e\u0433\u043e \u0432\u0430\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u044b\u044f\u0441\u043d\u0438\u0442\u044c \u0438 \u043f\u0440\u0435\u0434\u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043d\u0435\u043f\u0440\u043e\u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u044b \u0430\u0440\u0435\u043d\u0434\u043e\u0434\u0430\u0442\u0435\u043b\u044e.\n    \u0422\u0430\u043a\u0436\u0435 \u0432\u044b \u043c\u043e\u0436\u0435\u0442\u0435 \u043f\u0440\u0438\u043d\u044f\u0442\u044c \u0432 \u043a\u0443\u0445\u043d\u044e \u0434\u0430\u043d\u043d\u044b\u0435 \u0441\u0442\u043e\u043b\u043e\u0432\u044b\u0435.\n    \u0414\u0430\u043d\u043d\u044b\u0435 \u043e\u0431 \u044d\u0442\u043e\u043c \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0442 \u0441\u043e\u0431\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0443, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0443\u044e \u0438\u0437 \u0441\u0438\u043c\u0432\u043e\ufffd"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\nprint(solution(''.join(fileinput.input())))"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the solution for the given input.\n\n    Args:\n        stdin (str): The standard input.\n\n    Returns:\n        str: The solution for the task.\n    \"\"\"\n    n = int(stdin.split()[0])\n    s1 = stdin.split()[1]\n\n    if n == 1:\n        return 'impossible'\n    if n == 2:\n        s2 = stdin.split()[2]\n        if s1!= s2:\n            return 'impossible'\n\n    return''.join([str(len(s1)), s1])\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    species = stdin.split(\"\\n\")[1]\n    fossil_seqs = list(stdin.split(\"\\n\")[2:])\n    start_idx, end_idx = 0, len(fossil_seqs)\n    while start_idx < end_idx:\n        if species in fossil_seqs[start_idx]:\n            fossil_seqs.pop(start_idx)\n            end_idx -= 1\n        else:\n            start_idx += 1\n\n    n = len(fossil_seqs)\n\n    def get_seq_matches(seq: str) -> int:\n        matches = 0\n        for s in seqs:\n            if seq in s:\n                matches += 1\n        return matches\n\n    matching_seqs = [get_seq_matches(seq) for seq in fossil_seqs]\n    if len(set(matching_seqs)) == 2:\n        return \"impossible\"\n    elif len(set(matching_seqs)) == 1:\n        return str(matching_seqs[0])\n    elif len(set(matching_seqs)) == 0:\n        return \"impossible\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds all possible examples of parallel evolution.\n\n    Args:\n        stdin (str): Input from stdin.\n\n    Returns:\n        str: Either 'impossible', if it is impossible to have a solution, or a solution string, if it is possible.\n    \"\"\"\n    n = int(stdin[0])\n    \n    assert len(stdin) == (n + 2)\n    live_nucleotides = stdin[1]\n    assert len(live_nucleotides) == 1\n\n    seqs = stdin[2:]\n    assert all([len(seq) < 4000 for seq in seqs])\n    assert all([seq[0] == 'M' for seq in seqs])\n    assert all([seq[0]!= live_nucleotides[0] for seq in seqs])\n\n    # Partition sequences into two groups\n    group_1 = []\n    group_2 = []\n    for seq in seqs:\n        if seq[0] == live_nucleotides[0]:\n            group_1.append(seq)\n        else:\n            group_2.append(seq)\n\n    # Construct lists of distinct nucleotides\n    group_1_nts = []\n    group_2_nts = []\n    for seq in group_1:\n        if seq not in group_1_nts:\n            group_1_nts.append(seq)\n    for seq in group_2:\n        if seq not in group_2_nts:\n            group_2_nts.append(seq)\n\n    # Construct lists of distinct nucleotides, remove live nucleotide\n    group_1_nts.remove(live_nucleotides)\n    group_2_nts.remove(live_nucleotides)\n\n    # Find all possible two-element sequences from the two groups\n    all_two_combinations = []\n    for seq1 in group_1_nts:\n        for seq2 in group_2_nts:\n            if seq1[1:] == seq2[:-1]:\n                all_two_combinations.append([seq1, seq2])\n\n    # Find all possible paths from the two groups\n    all_one_sequences = []\n    for seq1 in group_1_nts:\n        all_one_sequences.append(seq1)\n    for seq2 in group_2_nts:\n        all_one_sequences.append(seq2)\n\n    # Find all permutations of the paths\n    all_permutations = list(itertools.permutations(all_one_sequences))\n\n    # Find all possible paths\n    all_two_paths = []\n    for permutation in all_permutations:\n        for seq1 in permutation:\n            for seq2 in permutation:\n                if seq1[1:] == seq2[:-1]:\n                    all_two_paths.append([seq1, seq2])\n\n    # If a two element sequence appears in both groups, it must be in one path\n    one_element_sequences_in_both = []\n    for seq1 in group_1_nts:\n        for seq2 in group_2_nts:\n            if seq1[1:] == seq2[:-1]:\n                one_element_sequences_in_both.append(seq1)\n                one_element_sequences_in_both.append(seq2)\n    for seq in one_element_sequences_in_both:\n        if seq in all_two_paths:\n            all_two_paths.remove(seq)\n        else:\n            all_one_sequences.remove(seq)\n\n    # If a one element sequence appears in both groups, it must be in the same path\n    one_element_sequences_in_both = []\n    for seq in all_one_sequences:\n        if seq in group_1_nts and seq in group_2_nts:\n            one_element_sequences_in_both.append(seq)\n    for seq in one_element_sequences_in_both:\n        if seq in all_two_paths:\n            all_two_paths.remove(seq)\n        else:\n            all_one_sequences.remove(seq)\n\n    # If two paths are the same, one must be different\n    for path in all_two_paths:\n        seq1, seq2 = path\n        if seq1[0] == seq2[0]:\n            all_two_paths.remove(path)\n        else:\n            for seq in all_one_sequences:\n                if seq == seq1[1:] or seq == seq2[:-1]:\n                    all_two_paths.remove(path)\n                    all_one_sequences.remove(seq)\n                    break\n\n    # If two paths are the same, then one must be different\n    for path in all_two_paths:\n        seq1, seq2 = path\n        for seq in all_one_sequences:\n            if seq == seq1[1:] or seq == seq2[:-1]:\n                all_two_paths.remove(path)\n                break\n\n    # If a one element sequence appears in one path, it must be in another path\n    one_element_sequences_in_one_path = []\n    for seq in all_one_sequences:\n        seq_in_path = False\n        for path in all_two_paths:\n            if seq in path:\n                seq_in_path = True\n                break\n        if not seq_in_path:\n            one_element_sequences_in_one_path.append(seq)\n    for seq in one_element_sequences_in_one_path:\n        all"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    live = stdin.readline()\n    fossils = [stdin.readline() for _ in range(n)]\n\n    for i in range(len(fossils)):\n        for j in range(len(fossils)):\n            if i!= j:\n                if is_good(live, fossils[i] + fossils[j]):\n                    return f'{i + 1} {j + 1}\\n{fossils[i]}\\n{fossils[j]}\\n'\n    return 'impossible\\n'\n\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    stdin = stdin.split('\\n\\n')\n    n = int(stdin[0])\n    s = stdin[1]\n    data = stdin[2:]\n    res = 'impossible'\n    if n!= len(data) and n!= 1:\n        return res\n    s1 = {s[i] for i in range(n)}\n    s2 = {s[i] for i in range(n, 2 * n)}\n    s1_s2 = {s[i] for i in range(n)}\n    s2_s1 = {s[i] for i in range(n, 2 * n)}\n    if len(s1_s2)!= len(s2_s1):\n        return res\n    if len(s1_s2) == len(s2_s1) == 1:\n        return str(1) +'' + str(1) + '\\n' + str(0) + '\\n' +'' + str(0)\n    return res\n    # for i in range(n):\n    #     for j in range(i + 1, n):\n    #         if data[i] == data[j]:\n    #             return 'impossible'\n    # for i in range(2 * n):\n    #     for j in range(i + 1, 2 * n):\n    #         if data[i] == data[j]:\n    #             return 'impossible'\n    # return 'impossible'"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    # Get data from input\n    data = stdin.split('\\n')\n\n    # Get number of elements\n    elements = int(data[0])\n\n    # Get first string\n    first_string = data[1]\n\n    # Get remaining string\n    rest_of_strings = data[2:]\n\n    # Get length of first string\n    first_string_len = len(first_string)\n\n    # Check if sequence is valid\n    if elements!= first_string_len:\n        return 'impossible'\n\n    # Iterate over elements\n    for el in rest_of_strings:\n        # Check if valid\n        if len(el)!= elements:\n            return 'impossible'\n\n    return '\\n'.join(rest_of_strings)\n\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    seq = stdin[1]\n\n    # build seq_dict to facilitate lookup\n    seq_dict = {}\n    for i in range(len(seq)):\n        seq_dict[seq[i]] = i\n\n    # get first non-A sequence\n    first = seq_dict[seq[0]]\n\n    # store all the sequences in order\n    seqs = []\n    for _ in range(n):\n        seqs.append(seq[first:])\n        first = seq_dict[seq[first]]\n\n    # now check for valid paths\n    n1 = 0\n    n2 = 0\n    for seq in seqs:\n        for s in seq:\n            if s == 'A':\n                n1 += 1\n            elif s == 'M':\n                n2 += 1\n\n    if n1 == 0 or n2 == 0:\n        return \"impossible\"\n    else:\n        return str(n1) + \" \" + str(n2)\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"5\n   ... AC\n   ... MM\n   ... A\n   ... AA\n   ... AC\n   ... \"\"\")\n    '1 4'\n    \"\"\"\n\n    return \"\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    base = stdin.readline()\n    lines = stdin.readlines()\n\n    # Build up the two sets of sequences\n    first = set()\n    second = set()\n    for l in lines:\n        l = l.strip()\n        if l in base:\n            second.add(l)\n        else:\n            first.add(l)\n\n    # Calculate the overlap\n    print(len(first & second))\n    print('\\n'.join(first))\n    print('\\n'.join(second))\n    return ''\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum time it takes to reset the game.\"\"\"\n    n, r, m = stdin.split()\n    t, p, d = 0, 0, 0\n    tr = []\n    for i in range(int(m)):\n        t, p, d = stdin.split()\n        tr.append((int(t), float(p), int(d)))\n    tr.sort()\n\n    tot, tloss = 0, 0\n    first = True\n    for i in range(int(n)):\n        if tloss > 0:\n            tloss = 0\n            first = True\n        if first:\n            first = False\n            tot += tr[0][1] * tr[0][2]\n        else:\n            tot += tr[i][1] * tr[i][2]\n            for k in range(1, int(r)):\n                tot -= tr[i - k][1] * tr[i - k][2]\n            if tot > r:\n                tloss = tot - r\n    if tloss > 0:\n        tot += tloss\n    return f\"{tot:.6f}\"\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    t, p, d = [], [], []\n    for _ in range(m):\n        t.append(int(stdin.split()[0]))\n        p.append(float(stdin.split()[1]))\n        d.append(int(stdin.split()[2]))\n    t = sorted(t)\n    p = sorted(p, reverse=True)\n    d = sorted(d)\n\n    total_time = 0\n    current_time = 0\n    index = 0\n    current_delay = 0\n    current_cost = 0\n    while current_time < r:\n        if current_delay < d[index] and p[index] < current_time / t[index]:\n            current_cost = current_cost + d[index]\n            current_delay = 0\n            current_time = current_time + d[index]\n        else:\n            current_delay = current_delay + 1\n            current_time = current_time + 1\n        index = index + 1\n    return current_cost"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    nr = stdin.split('\\n')\n    n, r, m = map(int, nr[0].split(' '))\n    scores = nr[1].split('\\n')\n\n    # Sort tricks by their time of occurrence\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, scores[i].split(' '))\n        tricks.append((t, p, d, i))\n    tricks.sort()\n\n    # Time spent on the route\n    spent = 0\n    # Time remaining until the run ends\n    remaining = r\n\n    # Main loop: play the route until the run ends\n    while remaining > 0:\n        # Determine the best trick to play:\n        # - the trick with the shortest remaining duration\n        # - the trick with the highest probability of succeeding\n        # - the trick with the lowest number of attempts\n        best_trick = tricks[0]\n        best_prob = -1\n        best_attempts = 1000\n        for trick in tricks:\n            if trick[0] > best_trick[0]:\n                best_trick = trick\n            elif trick[0] == best_trick[0] and trick[3] < best_trick[3]:\n                best_trick = trick\n            if trick[1] > best_prob:\n                best_prob = trick[1]\n            if trick[2] < best_attempts:\n                best_attempts = trick[2]\n        # If the run is already finished, or if the best trick doesn't have a high enough probability of succeeding, we can't improve the time.\n        if best_trick[0] > remaining or best_prob < 0.5:\n            break\n        # Otherwise, play the best trick.\n        # - If it fails, we lose the time spent on it (and the number of attempts made)\n        # - Otherwise, we set the time remaining to the remaining time after the trick - the time spent on it + the time lost from the failed attempt\n        attempts = best_attempts\n        time = best_trick[0]\n        while attempts > 0:\n            if random.random() < best_prob:\n                time -= best_trick[2]\n                attempts -= 1\n                spent += best_trick[2]\n            else:\n                spent += time\n                time = remaining - spent\n                break\n        remaining = time\n    return str(round(r - spent, 6))\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the smallest possible time in which a run of the game is completed.\n    \n    Args:\n        stdin (str): Input string\n    \n    Returns:\n        str: Output string\n    \n    Raises:\n        ValueError: If an invalid test case has been encountered\n    \"\"\"\n    # Initialise variables\n    tricks, average_time = parse_input(stdin)\n    score, route = 0, 0\n    \n    # Loop through each trick\n    for trick in tricks:\n        # Increment the score if the trick succeeds\n        if rand.random() <= trick[1]:\n            score += trick[2]\n        # Otherwise, incur an additional time loss\n        else:\n            score += trick[2]\n            average_time += trick[2]\n            \n        # Update the route if we have finished a successful run\n        if score >= route:\n            route = score\n    \n    return str(round(average_time, 6))\n        \n        \n        \ndef"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the expected time to set a new record\"\"\"\n\n    def expected_time_to_set_record(r, n, t, p, d):\n        return stdin.split('\\n')[1].split()[0] + \\\n               expected_time_to_set_record(r, n, t, p, d)\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, r, m = (int(x) for x in lines[0].split())\n    tricks = []\n    for _ in range(m):\n        t, p, d = (int(x) for x in lines[_].split())\n        tricks.append((t, p, d))\n\n    def find_max_run(tricks):\n        runs = []\n        for _ in range(n):\n            run = [tricks.pop(0)]\n            while run[0][0] == _:\n                run.append(tricks.pop(0))\n            runs.append(run)\n        return runs\n\n    runs = find_max_run(tricks)\n    times = {run[0][0]: 0 for run in runs}\n    for t, p, d in tricks:\n        times[t] += d\n        run = runs[t]\n        times[run[-1][0]] -= d\n\n    if len(times) == 1:\n        return str(r - times[0])\n\n    expected_times = {t: 0 for t in times}\n    for t, p, d in tricks:\n        expected_times[t] += d\n    for t, _ in reversed(runs[-1]):\n        expected_times[t] += t - runs[-1][0][0]\n    for i in range(1, n - 1):\n        expected_times[runs[i][0][0]] -= sum(run[-1][2] for run in runs[i:])\n    expected_times[runs[-1][0][0]] += sum(run[-1][2] for run in runs[:-1])\n\n    return str(max([expected_time for expected_time in expected_times.values() if expected_time < r] or [r]))\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    'find the optimal time to reset the game to set a new record'\n    # Time: O(m), Space: O(m)\n    n, r, m = map(int, stdin.split(' '))\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, stdin.split(' '))\n        tricks.append((t, p, d))\n    tricks.sort()\n    return get_expected_time(n, r, tricks)\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the expected time to set a new record, assuming an optimal strategy is used.\n    >>> solution(open(\"data/p5/sample-input.txt\").read())\n    '124'\n    \"\"\"\n    n, r, m = map(int, stdin.split())\n    trick_times = [int(x) for x in stdin.splitlines()[1:]]\n    trick_times.sort()\n    min_time = sum(trick_times[:m])\n    time_to_set = r - n - min_time\n    return f\"{time_to_set:.6f}\"\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns expected time to set a new record.\"\"\"\n    # Number of tricks, time record and tricks.\n    tricks, time, tricks_list = map(int, stdin.split())\n    # Dictionary to store probability of success for tricks and tricks time.\n    tricks_dict = {}\n    for i in range(tricks):\n        t, p, d = map(float, stdin.split())\n        tricks_dict[t] = [p, d]\n    # Initialise variables.\n    current_time = time\n    current_record = current_time\n    tricks_seen = 0\n    # Iterate through tricks_dict, starting at the most recent.\n    for t in reversed(sorted(tricks_dict.keys())):\n        # Check if the trick is in the current run.\n        if t <= tricks_seen:\n            # Get the probability of success of the trick, and the number of seconds to recover if it fails.\n            p, d = tricks_dict[t]\n            # Update current_record if necessary.\n            current_record = min(current_record, current_time + (tricks_seen - t) + d)\n            # Set tricks_seen equal to time of next trick, as soon as possible.\n            current_time = min(t, current_time + tricks_seen - t)\n            # Increment tricks_seen.\n            tricks_seen += t\n    return f'{current_record:.6f}'\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = []\n    for _ in range(m):\n        tricks.append(list(map(float, stdin.split())))\n    tricks.sort(key=lambda x: x[0])\n    x = []\n    t = 0\n    for trick in tricks:\n        t = trick[0]\n        p = trick[1]\n        d = trick[2]\n        if t > n:\n            break\n        x.append((t, p, d))\n    x.sort(key=lambda x: x[0])\n    t = 0\n    prob = 0\n    time = 0\n    for i in range(len(x)):\n        t = x[i][0]\n        p = x[i][1]\n        d = x[i][2]\n        prob += p\n        time += t*p\n        if d!= 0:\n            time += d\n    time = (time * 2) + ((n - t) * (1 - prob))\n    return str(time)\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds k-th sequence.\"\"\"\n    n, k = map(int, stdin.split())\n    lst = [i for i in range(1, n) if i % n!= 0]\n    lst.sort()\n    return''.join(map(str, lst[:k]))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 3\\n2 1 2\\n1\")\n    '2 1 2'\n    >>> solution(\"2 1\\n1\")\n    '1'\n    >>> solution(\"5 22\\n4 3 4 2\\n\")\n    '4 3 4 2'\n    \"\"\"\n    n, k = map(int, stdin.split())\n    seq = [i for i in range(1, n) if i % n!= 0]\n    seq.sort()\n    return''.join(map(str, seq[k - 1:]))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the kth sequence on Gwen\u2019s list.\"\"\"\n    pass\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the kth sequence on Gwen's list.\"\"\"\n    _, k = map(int, stdin.split())\n    n = int(stdin)\n    return [n - i for i in range(1, n + 1) if not (n - i) % n] or [1]\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gwen's list of sequences is in lexicographical order.\n\n    The sequences can be found in the file `gwen_sequences.txt`.\n    \"\"\"\n    n, k = map(int, stdin.split())\n\n    return str.join('\\n', map(str, range(1, n)))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # n, k = map(int, stdin.split())\n    # seq = list(map(int, stdin.split()))\n    # seq = sorted(seq)\n    # for i in range(k):\n    #     if i == 0:\n    #         print(seq[i], end=\" \")\n    #     elif seq[i] - seq[i - 1]!= 1:\n    #         print(seq[i - 1] + 1, end=\" \")\n    #     else:\n    #         print(seq[i], end=\" \")\n    # if n % 2 == 0:\n    #     print(seq[k - 1])\n    # else:\n    #     print(seq[k - 1] + 1)\n\n    n, k = map(int, stdin.split())\n    seq = list(map(int, stdin.split()))\n    seq = sorted(seq)\n    for i in range(k):\n        if i == 0:\n            print(seq[i], end=\" \")\n        elif seq[i] - seq[i - 1]!= 1:\n            print(seq[i - 1] + 1, end=\" \")\n        else:\n            print(seq[i], end=\" \")\n    if n % 2 == 0:\n        print(seq[k - 1])\n    else:\n        print(seq[k - 1] + 1)\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Gets the nth valid sequence of flower placements for Gwen's birthday.\n\n    Gwen hates all numbers that are a multiple of n. Therefore, the answer\n    will always be of length n-1.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string, a single line.\n\n    Returns\n    -------\n    str\n        The nth valid sequence of flower placements for Gwen's birthday.\n    '''\n    n, k = [int(x) for x in stdin.split()]\n    l = list(range(1, n - 1))\n    return''.join([str(x) for x in l[k - 1:][::-1]])\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = []\n    for i in range(1, n):\n        a.append(i)\n    a.sort()\n    for i in range(k - 1):\n        a.remove(n - i - 1)\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 3\\n2 1 2\")\n    '2 1 2'\n    >>> solution(\"2 1\\n1\")\n    '1'\n    >>> solution(\"5 22\\n4 3 4 2\")\n    '4 3 4 2'\n    \"\"\"\n    n, k = [int(s) for s in stdin.split()]\n    return \" \".join(str(i) for i in range(1, n - 1) if i % n!= 0)\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 3\\n')\n    '2 1 2'\n    >>> solution('2 1\\n')\n    '1'\n    >>> solution('5 22\\n')\n    '4 3 4 2'\n    \"\"\"\n    num, k = map(int, stdin.split())\n    print(' '.join(map(str, range(1, num - 1)[::-1][:k])))\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"TODO: Docstring for solution.\n\n    :stdin: TODO\n    :returns: TODO\n\n    \"\"\"\n    [N, M] = [int(i) for i in stdin.split()]\n    lines = []\n    for line in range(M):\n        line = [int(i) for i in stdin.split()]\n        lines.append(line)\n    \n    pairs = {}\n    for u, v in lines:\n        pairs[u] = pairs.get(u, [])\n        pairs[u].append(v)\n    \n    pairs = sorted(pairs.items(), key=lambda x: len(x[1]))\n    pairs = list(map(lambda x: (len(x[1]), x[1]), pairs))\n    paths = {}\n    paths[1] = [1]\n    paths[N] = [N]\n    for i in range(1, len(pairs)):\n        length = pairs[i][0]\n        # paths[length] = []\n        for j in range(1, len(paths)):\n            if j >= length:\n                break\n            for path in paths[j]:\n                if path in pairs[i][1]:\n                    paths[length].append(path)\n                    break\n    \n    if len(paths[1]) == 1:\n        print(0)\n        return\n    \n    paths = sorted(paths.items(), key=lambda x: len(x[1]))\n    paths = list(map(lambda x: (len(x[1]), x[1]), paths))\n    print(paths[0][1])\n    return"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Greedily take the largest possible path. The largest possible path is the path with the highest number of stations in it.\n\n    Args:\n        stdin (str): Input text\n\n    Returns:\n        str: Solution flag\n    \"\"\"\n    # Your code here\n    return None\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum path length.\"\"\"\n    # n = number of nodes\n    # m = number of edges\n    # The following solution is not optimal because it is possible to block a higher road, but this makes it much easier to think about the problem.\n    n, m = [int(x) for x in stdin.split(\" \")]\n    # Create an adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = [int(x) for x in stdin.split(\" \")[2 * i : 2 * i + 2]]\n        adj[u - 1].append(v - 1)\n    # Create a list of the unblocked roads, sorted by cost.\n    unblocked = [set() for _ in range(n)]\n    for i, v in enumerate(adj):\n        for j in v:\n            unblocked[i].add(j)\n            unblocked[j].add(i)\n    # Find all ways to block the first road.\n    # unblocked[i] contains all the unblocked roads that can be blocked starting from station i.\n    blocked = []\n    # unblocked[i] is a list of the set of blocked roads that can be blocked starting from station i\n    # This means that blocked is a list of all the ways to block all the unblocked roads in the graph.\n    # We want to go through each of the ways in blocked and see if it is a path that is longer than any path that is possible from any other starting station.\n    for i in range(n):\n        for j in unblocked[i]:\n            if j not in unblocked[i]:\n                blocked.append([i, j])\n    # Convert blocked to a list of all the possible paths.\n    paths = []\n    for i, j in blocked:\n        # If j is the end of a path, then we know that the path is:\n        # [i,..., j]\n        # So, we want to add this path to the paths list.\n        if j in unblocked[i]:\n            paths.append([i, j])\n        else:\n            # Otherwise, we know that j is not the end of a path, so we want to\n            # check if it is the start of a path.\n            # We want to do this by checking if j is in the path from i to j.\n            # So, we want to remove i from the list and then reinsert j.\n            for k in unblocked[i]:\n                if j in unblocked[k]:\n                    # Find the path from i to k\n                    path = [i, k]\n                    while k in unblocked[path[-1]]:\n                        path.append(k)\n                    path.append(j)\n                    # Remove i from the path so that we have a path starting from i\n                    path = path[1:]\n                    # Add the path to the paths list\n                    paths.append(path)\n    # Convert the list of paths into a list of their lengths.\n    path_lengths = [len(p) for p in paths]\n    # Find the minimum path length.\n    min_length = min(path_lengths)\n    # Return the minimum path length.\n    return str(min_length)"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_paths(path: List[int], used_path: Set[Tuple[int]], s: int, f: int):\n        if s == f:\n            return 1\n        return sum(find_paths(path, used_path | {(s, i)}, s, i) for i in range(1, n) if (s, i) not in used_path)\n    n, m = [int(x) for x in stdin.split(' ')]\n    path = list(map(int, stdin.split('\\n')[1:]))\n    return str(sum(find_paths(path, set(), i, i) for i in range(1, n)) - 1)\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    \"\"\"\n    >>> solution('''4 4\n   ... 1 2\n   ... 1 3\n   ... 3 4\n   ... 2 4''')\n    2\n    >>> solution('''7 5\n   ... 1 2\n   ... 2 3\n   ... 3 4\n   ... 5 6\n   ... 6 7\n   ... 7 2''')\n    0\n    \"\"\"\n    n, m = list(map(int, stdin.split()))\n    edges = []\n    for _ in range(m):\n        u, v = list(map(int, stdin.split()))\n        edges.append((u, v))\n    edges.sort()\n    # print(edges)\n\n    def find_path(edges: list[tuple[int, int]], visited: set[int]) -> tuple[int, int, int]:\n        \"\"\"\n        >>> find_path([(1, 2), (1, 3), (3, 4)], set())\n        (0, 1, 2)\n        \"\"\"\n        paths = []\n        while edges:\n            road = edges.pop()\n            if road[0] in visited or road[1] in visited:\n                continue\n            visited.add(road[0])\n            visited.add(road[1])\n            paths.append(road)\n        paths.sort(key=lambda x: x[1])\n        return paths[0] if paths else (0, 0, 0)\n    \n    def find_longest_path(edges: list[tuple[int, int]]) -> int:\n        \"\"\"\n        >>> find_longest_path([(1, 2), (1, 3), (3, 4)])\n        2\n        >>> find_longest_path([(1, 2), (2, 3), (3, 4)])\n        3\n        \"\"\"\n        longest = 0\n        visited = set()\n        road = find_path(edges, visited)\n        while road:\n            longest += 1\n            road = find_path(edges, visited)\n        return longest\n\n    return find_longest_path(edges)\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets input and parses to the right format\"\"\"\n    n, m = [int(i) for i in stdin.split(' ')]\n    roads = []\n    for _ in range(m):\n        u, v = [int(i) for i in stdin.split(' ')[1:]]\n        roads.append((u, v))\n\n    return process_input(n, roads)\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    connections = set()\n    for i in range(m):\n        u, v = map(int, stdin.split(' '))\n        connections.add((u, v))\n        connections.add((v, u))\n    stations = set()\n    for u, v in connections:\n        stations.add(u)\n        stations.add(v)\n    stations = list(stations)\n    stations.sort()\n    print(stations)\n    res = 0\n    # for station in stations:\n    #     stations.append(station)\n    #     print(stations)\n    #     res = max(res, dfs(station, stations))\n    #     stations.pop()\n    #     print(stations)\n    # return res\n    return dfs(stations[0], stations)\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\""
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = [int(x) for x in stdin.strip().split()]\n    v, w = [float(x) for x in stdin.split('\\n')[1].strip().split(' ')]\n    result = (2 * x * v + 2 * y * w) / (v + w)\n    return result"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    coordinates = stdin.strip().split(' ')\n    x, y = int(coordinates[0]), int(coordinates[1])\n    v, w = float(coordinates[2]), float(coordinates[3])\n    t = (x - y) / v\n    if x - y == 0:\n        return t\n    r = abs(w) / abs(v)\n    if r >= 1:\n        return t\n    return t * (1 - r) + r / 2\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, V, W = list(map(float, stdin.split()))\n    return str(round(V * abs(Y - X) / (Y - X) + abs(W) * (Y - X), 3))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    # first line is X, Y, second is V, W\n    # use float, since str is not guaranteed to be of the same length\n    x, y = [float(i) for i in stdin.split()]\n    v, w = [float(i) for i in stdin.split()]\n    \n    # initialize a list of distances and the corresponding number of steps to take\n    dist = [int(abs(x)), int(abs(y))]\n    steps = [int(abs(x)/v), int(abs(y)/v)]\n    \n    # find the minimum steps\n    steps = min(steps)\n    \n    # calculate the distance for each step\n    for i in range(steps):\n        x += v\n        y += w\n        dist = [int(abs(x)), int(abs(y))]\n    \n    # return the answer\n    return str(sum(dist))\n    \n    \nprint(solution(input()))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y = [int(x) for x in stdin.split()]\n    v, w = [float(x) for x in stdin.split()]\n    return str(round(abs((y - x) / (v - w)), 3))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # ********** Write Your Code Here **********\n    return \"\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Vars:\n    x: int. x miles\n    y: int. y miles\n    v: float. v miles / second\n    w: float. w radians / second\n\n    Expected output:\n    float. minimum amount of time\n\n    Returns:\n    str: string\n    \"\"\"\n\n    # Get input\n    x, y = list(map(int, stdin.split(' ')))\n    v, w = list(map(float, stdin.split(' ')))\n\n    # Calculate\n    radians = (w * x)\n    minutes = radians / (v * w)\n    seconds = minutes * 60\n\n    # Return answer\n    return str(seconds)\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    finds minimum time needed for hovercraft to reach a particular location\n    '''\n    x, y, v, w = [float(i) for i in stdin.split()]\n    speed = v / 3600\n    rot = w / (2 * pi)\n\n    time = sqrt((x * x) + (y * y)) / speed\n    time += 0.5 * sqrt(rot * rot)\n    time *= 3600\n    return '{:.3f}'.format(time)\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return minimum time to reach x,y using forward, stop_forward, stop_rotate\"\"\"\n    x, y = map(int, stdin.split())\n    v, w = map(float, stdin.split())\n    print(f\"{x} {y} {v} {w}\")\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    debts = [list(map(int, stdin.split())) for _ in range(n)]\n    debt_sum = sum([a for a, b in debts])\n    debts = [b - a for a, b in debts]\n    debts.sort()\n    money = 0\n    for i in range(n // 2):\n        money += debts[i]\n    if n % 2 == 1:\n        money += debts[-1]\n    money += sum(debts[n // 2:])\n    return str(money)\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem in the open lab\n    \"\"\"\n    n, debts = stdin.split()\n    n = int(n)\n    debts = list(map(int, debts.split()))\n    debt_sums = list()\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += debts[j] if i!= j else debts[j] / 2\n        debt_sums.append(total)\n    return str(round(max(debt_sums)))\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    d = [int(i) for i in stdin.split()]\n    total = 0\n    d.sort()\n    for i in range(n):\n        total += d[i]\n    return total\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'Not solved'"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    d = {}\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        d[a] = b\n    cost = 0\n    for i in range(1, n + 1):\n        cost += d.get(i, 0)\n    print(cost)\n    return ''\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # total: Total amount of money given out by the town.\n    total = 0\n    # debts: Amount of money each person owes to another.\n    debts = [0] * int(stdin.readline())\n    for i in range(int(stdin.readline())):\n        a, b = map(int, stdin.readline().split())\n        debts[a - 1] += b\n        debts[b - 1] += b\n    # debts[i]: Amount of money person i owes to another.\n    for i in range(int(stdin.readline())):\n        total += debts[i]\n    return total\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Naive solution. DFS!\n\n    I like this solution, but I don't like it.\n    The main issue with this solution is that it can take a very long time to finish.\n    \"\"\"\n    N = int(stdin.split('\\n')[0])\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = {i: [] for i in range(1, N+1)}\n\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    min_cost = math.inf\n\n    def dfs(c, cost, person):\n        nonlocal min_cost\n\n        # The dfs algorithm is complete\n        if c == 0:\n            min_cost = min(min_cost, cost)\n            return\n\n        # The person's debt is paid back, we continue to the next person\n        for next_person, amount in graph[person]:\n            dfs(c - 1, cost + amount, next_person)\n\n    dfs(N, 0, 1)\n    return min_cost\n\n\ndef"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    [n, *debts] = [int(i) for i in stdin.split()]\n    \n    debts = sorted(debts)\n    \n    min_sum = 0\n    \n    for i in range(1, n + 1):\n        if debts[i - 1] == i:\n            min_sum += debts[i - 1]\n        elif debts[i - 1] < i:\n            min_sum += debts[i - 1] + (i - debts[i - 1] - 1) * (debts[i - 1] - i) // 2\n        else:\n            min_sum += i - debts[i - 1]\n    \n    return min_sum\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    print(n)\n    info = []\n    for i in range(n):\n        info.append(list(map(int, stdin.readline().strip().split(\" \"))))\n    print(info)\n    return solution\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, *s = list(map(int, stdin.split()))\n    p = [list(map(int, stdin.split())) for i in range(N - 1)]\n    p.sort(key=lambda x: x[1], reverse=True)\n    C = 0\n    for i in range(N - 1):\n        C += p[i][0] * p[i][1]\n    for i in range(N - 1):\n        C = (C + p[i][1] - 1) // p[i][1]\n    return C\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    \n    def dfs(city, visited, path):\n        if city == 1:\n            return True\n        \n        for road in roads:\n            if city == road[0] and road[1] not in visited:\n                visited.add(road[1])\n                if dfs(road[1], visited, path+[road[1]]):\n                    return True\n        return False\n    \n    \n    \n    n, m = list(map(int, stdin.split()))\n    roads = [list(map(int, stdin.split())) for _ in range(m)]\n    roads = sorted(roads, key=lambda x: x[2])\n    \n    start = roads[0][0]\n    end = roads[0][1]\n    visited = set([start])\n    \n    return dfs(start, visited, [start])\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def read_ints(decode_func):\n        return [decode_func(input().strip()) for _ in range(M)]\n\n    N, M = read_ints(int)\n    roads = {}\n    for A, B in read_ints(lambda x: (int(x.split()[0]), int(x.split()[1]))):\n        roads.setdefault(A, set()).add(B)\n        roads.setdefault(B, set()).add(A)\n    \n    result = 0\n    for A in range(1, N+1):\n        B = 1\n        used = {A}\n        while B!= A:\n            for B in roads.get(A, []):\n                if B not in used:\n                    break\n            else:\n                continue\n            break\n        else:\n            result = max(result, len(used))\n    return str(result)"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    def dfs(graph, start):\n        \"\"\"\n        Depth First Search\n        :param graph:\n        :param start:\n        :return:\n        \"\"\"\n        stack = [(start, 0, set())]\n        max_length = 1\n        while len(stack) > 0:\n            parent, length, visited = stack.pop()\n            if length > max_length:\n                max_length = length\n            for child in graph[parent]:\n                if child not in visited:\n                    stack.append((child, length + 1, visited.union({child})))\n        return max_length\n\n    def find_race_length():\n        \"\"\"\n        Finds the length of the race\n        :return:\n        \"\"\"\n        graph = defaultdict(set)\n        for road in roads:\n            graph[road[0]].add(road[1])\n            graph[road[1]].add(road[0])\n        return dfs(graph, 1)\n\n    roads = [tuple(map(int, line.strip().split())) for line in stdin.strip().splitlines()]\n    return str(find_race_length())\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return longest path of all simple paths in the network.\"\"\"\n    num_cities, num_roads = [int(n) for n in stdin.split()]\n    edges = []\n    for road_idx in range(num_roads):\n        city_a, city_b = [int(n) for n in stdin.split()]\n        edges.append((city_a, city_b))\n\n    # For each city C, there are at most 2 edges joining it\n    # If there are two edges joining C, then it is a ring\n    # If there is only one edge joining C, then C is part of a simple path\n    # If there is no edge joining C, then C is part of a simple path\n    # If there are zero edges joining C, then it is a simple path\n    # Therefore, there are at most 2 + 2 + 1 + 0 = 7 edges\n    # At most 8 paths possible, one for each of the possible starting points\n    # However, we must ensure that there is at least one starting point\n    # otherwise there would not be a simple path\n    # Therefore, we can solve this using a backtracking algorithm\n    # The search space for the starting point is set to the list of cities\n    # In the search space, we will try to build each possible path\n    # We will check if the path is simple and has end in city 1\n    # If it passes the tests, then we will see if the path is longer than\n    # the current longest path. If it is, then we will replace the longest\n    # path\n    longest_path = 0\n    for start_city in range(1, num_cities + 1):\n        visited_cities = set()\n        current_path = 0\n        next_path = [start_city]\n        while next_path:\n            next_city = next_path.pop(0)\n            if next_city in visited_cities:\n                continue\n            visited_cities.add(next_city)\n            if next_city == 1:\n                current_path += 1\n            for city_a, city_b in edges:\n                if next_city == city_a and city_b not in visited_cities:\n                    next_path.append(city_b)\n                if next_city == city_b and city_a not in visited_cities:\n                    next_path.append(city_a)\n        if current_path > longest_path:\n            longest_path = current_path\n    return str(longest_path)\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n\n    cities, roads = map(int, lines[0].split())\n\n    islands = [0] * (cities + 1)\n    roads_in_islands = [set() for _ in range(cities + 1)]\n\n    road_pairs = [tuple(map(int, line.split())) for line in lines[1:]]\n    \n    for start, end in road_pairs:\n        roads_in_islands[start].add(end)\n        roads_in_islands[end].add(start)\n    \n    def dfs(current_island: int, prev_island: int, path: list[int]) -> int:\n        if path[-1] == 1:\n            return len(path)\n\n        path = path + [current_island]\n        current_islands = set(roads_in_islands[current_island])\n        next_island = current_islands.difference(set(path)).pop()\n        return max(dfs(next_island, current_island, path), dfs(current_island, prev_island, path))\n    \n    return max(dfs(i, i - 1, [i]) for i in range(1, cities + 1))"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    stdin = stdin.splitlines()\n    N, M = map(int, stdin[0].split())\n    roads = [tuple(map(int, line.split())) for line in stdin[1:]]\n    roads = set(roads)\n\n    dp = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    dp[1][1] = 1\n\n    for road in roads:\n        road1, road2 = road\n        dp[road1][road2] = 1\n        dp[road2][road1] = 1\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            for k in range(1, N + 1):\n                dp[j][k] = dp[j][k] or dp[j][i] and dp[i][k]\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if dp[i][j] == 1 and dp[j][i] == 1:\n                dp[i][j] = 0\n\n    print(max(max(row) for row in dp))\n    return ''\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Implement your code here\n    return \"\"\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    cities, roads = map(int, stdin.split('\\n')[:2])\n    roads = [tuple(map(int, r.split())) for r in stdin.split('\\n')[2:]]\n    \n    class City:\n        def __init__(self, val: int) -> None:\n            self.val = val\n            self.children = []\n            self.parents = []\n        def addChild(self, val: int) -> None:\n            self.children.append(City(val))\n            self.children[-1].parents.append(self)\n        def addParent(self, val: int) -> None:\n            self.parents.append(City(val))\n            self.parents[-1].children.append(self)\n    \n    city_dict = {val: City(val) for val in range(1, cities + 1)}\n    for city1, city2 in roads:\n        city_dict[city1].addChild(city2)\n        city_dict[city2].addParent(city1)\n    \n    def dfs(city: City, visited: set) -> None:\n        visited.add(city.val)\n        for child in city.children:\n            if child.val not in visited:\n                dfs(child, visited)\n        return visited\n    \n    def get_longest_path(city: City) -> list:\n        visited = dfs(city_dict[1], set())\n        visited = {c for c in visited if c!= 1}\n        longest_path = [1]\n        for city in city_dict[1].parents:\n            if city.val in visited:\n                longest_path.append(city.val)\n        longest_path.append(1)\n        return longest_path\n    \n    def is_longest_path(path: list) -> bool:\n        if len(path) == len(set(path)):\n            return True\n        return False\n    \n    longest_path = get_longest_path(city_dict[1])\n    longest_path_len = len(longest_path)\n    \n    for city in city_dict.values():\n        path = get_longest_path(city)\n        if len(path) > longest_path_len and is_longest_path(path):\n            longest_path = path\n            longest_path_len = len(longest_path)\n    \n    return len(longest_path)\n    \nprint(solution(input()))\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the chance of the captain's success on his mission.\n\n    Args:\n        stdin (str): Input from stdin.\n\n    Returns:\n        str: The solution for the problem.\n    \"\"\"\n\n    def bfs_shortest_paths(graph: dict, start: int) -> dict:\n        \"\"\"Perform a breadth first search to compute all shortest paths.\n\n        Args:\n            graph (dict): Graph of nodes with edges.\n            start (int): Node start.\n\n        Returns:\n            dict: Shortest paths.\n        \"\"\"\n\n        discovered = {start: 0}\n        queue = [start]\n        while queue:\n            current = queue.pop(0)\n            for neighbour in graph[current]:\n                if neighbour not in discovered:\n                    discovered[neighbour] = discovered[current] + 1\n                    queue.append(neighbour)\n        return discovered\n\n    def compute_probability(paths: dict) -> float:\n        \"\"\"Compute the probability of the captain's success on his mission.\n\n        Args:\n            paths (dict): Shortest paths to nodes.\n\n        Returns:\n            float: The probability.\n        \"\"\"\n\n        tot_steps = sum(paths.values())\n        return tot_steps / 2\n\n    def compute_probability_without_sentry(paths: dict) -> float:\n        \"\"\"Compute the probability of the captain's success on his mission.\n\n        Args:\n            paths (dict): Shortest paths to nodes.\n\n        Returns:\n            float: The probability.\n        \"\"\"\n\n        # Count the amount of times every node appears.\n        counts = {}\n        for node in paths.keys():\n            counts[node] = 0\n            for node_list in paths.values():\n                if node in node_list:\n                    counts[node] += 1\n\n        # Remove all nodes that appear only once.\n        for node in list(counts.keys()):\n            if counts[node] == 1:\n                del counts[node]\n\n        # Return the probability of success.\n        return compute_probability(paths) - len(counts) / 2\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    l = int(lines[1])\n    paths = [line.split() for line in lines[2:l + 2]]\n    paths = {path[0]: path[1:] for path in paths}\n\n    # Get shortest paths between nodes.\n    paths = {node: bfs_shortest_paths(paths, node) for node in paths}\n\n    # Compute probability.\n    probability = compute_probability(paths)\n\n    # Compute probability without sentry.\n    probability_without_sentry = compute_probability_without_sentry(paths)\n\n    return f'{probability:.6f}\\n{probability_without_sentry:.6f}'\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the captain's chances of escape without being discovered by the sentry.\n\n    Args:\n        stdin (str): input on stdin\n\n    Returns:\n        str: solution using stdout\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    l = int(stdin.split(\"\\n\")[1])\n    walk = [int(x) for x in stdin.split(\"\\n\")[2:l + 2]]\n    neighbours = [int(x) for x in stdin.split(\"\\n\")[l + 2:]]\n    c = 0\n    for node in walk:\n        for i in neighbours[node]:\n            if i not in neighbours[walk[c - 1]]:\n                c += 1\n                break\n        if c == 1:\n            break\n    print(1 - c / n)\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('''3\n   ... 1\n   ... 0\n   ... 2 1 2\n   ... 1 0\n   ... 1 0''')\n    '0.5'\n    >>> solution('''8\n   ... 6\n   ... 1 0 2 3 0 1\n   ... 7 1 2 3 4 5 6 7\n   ... 1 0\n   ... 2 0 3\n   ... 2 0 2\n   ... 1 0\n   ... 1 0\n   ... 1 0\n   ... 1 0''')\n    '0.0446429'\n    '''\n    n = int(stdin.split('\\n')[0])\n    l = int(stdin.split('\\n')[1])\n    rooms = []\n    for i in range(n):\n        rooms.append(list(map(int, stdin.split('\\n')[i + 2].split(' '))))\n    visit = stdin.split('\\n')[n + 2:]\n    visit = [list(map(int, i.split(' '))) for i in visit]\n\n    # init distances\n    distance = [float('inf')] * n\n    distance[0] = 0\n    for i in range(n):\n        for room in rooms[i]:\n            distance[room] = i + 1\n\n    def dist(a, b):\n        return min(abs(a - b), n - abs(a - b))\n\n    def update(a, b):\n        if distance[a] > distance[b] + dist(a, b):\n            distance[a] = distance[b] + dist(a, b)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                update(i, j)\n    for room in visit:\n        distance[room[0]] = room[1]\n        for j in range(n):\n            if j!= room[0]:\n                update(room[0], j)\n\n    # calculate the result\n    result = 0\n    for i in range(n):\n        if distance[i] == l:\n            result += 1 / n\n    return str(result)"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution to the corresponding problem.\"\"\"\n    def dfs(src, dst, via, visited, adjacency, dists, via_map):\n        \"\"\"Depth-first search on the graph.\"\"\"\n        if src == dst:\n            return True\n        if via_map.get(dst):\n            return via_map[dst]\n        if visited.get(dst):\n            return False\n        visited[dst] = True\n        for neighbour in adjacency[dst]:\n            if neighbour == via:\n                continue\n            path = dfs(src, neighbour, via, visited, adjacency, dists, via_map)\n            if path:\n                paths[src][neighbour] = True\n                paths[neighbour][src] = True\n                return True\n        return False\n    def calc_chance(src, dst, paths, adjacency):\n        \"\"\"Computes the chance of the captain discovering the sentry.\"\"\"\n        total_paths = 0\n        for neighbour in adjacency[src]:\n            if paths[src][neighbour]:\n                total_paths += 1\n        chance = total_paths / adjacency[src].length\n        return chance\n    # Read input.\n    n = int(stdin.readline())\n    l = int(stdin.readline())\n    stdin.readline()\n    adj_map = dict()\n    for _ in range(n):\n        line = stdin.readline().split()\n        adj_map[int(line[0])] = set(map(int, line[2:]))\n    paths = dict()\n    for i in range(n):\n        paths[i] = dict()\n    # Solve problem.\n    path = list(map(int, stdin.readline().split()))\n    for src, dst in zip(path, path[1:]):\n        dfs(src, dst, None, dict(), adj_map, dict(), paths)\n    dists = dict()\n    for i in range(n):\n        dists[i] = 0\n    visited = dict()\n    for i in range(n):\n        visited[i] = False\n    chance = 1\n    while True:\n        chance *= calc_chance(path[0], path[1], paths, adj_map)\n        if visited[path[1]]:\n            break\n        for i in range(n):\n            if paths[path[0]].get(i):\n                dists[i] += 1\n                if dists[i] >= l:\n                    dists[i] = 0\n                    path[0] = i\n                    break\n    return str(chance)\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, L, B = [int(x) for x in stdin.split('\\n')]\n    graph = defaultdict(list)\n    for i in range(N - 1):\n        n, *neighbour = [int(x) for x in stdin.split('\\n')[i].split()]\n        graph[n].extend(neighbour)\n        graph[n].extend(graph[neighbour[0]])\n        graph[neighbour[0]].append(n)\n    graph[L - 1].extend(graph[L])\n    def dfs(graph, L):\n        graph[L].append(L)\n        for n in graph[L]:\n            if n not in graph[n]:\n                graph[n].append(n)\n                dfs(graph, n)\n        return graph\n\n    def get_path_length(graph):\n        # DFS on graph and return the length of the longest path\n        lengths = dict()\n        for node in graph.keys():\n            if node not in lengths:\n                lengths[node] = 0\n            stack = []\n            stack.append((node, 1))\n            while stack:\n                node, cur_length = stack.pop()\n                if node in graph:\n                    for n in graph[node]:\n                        if n not in lengths:\n                            lengths[n] = cur_length + 1\n                        stack.append((n, cur_length + 1))\n        return max(lengths.values())\n\n    def get_num_of_paths(graph, length):\n        return math.factorial(len(graph)) // math.factorial(len(graph) - length)\n\n    def get_num_of_paths_by_length(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for node in graph.keys():\n            for length in lengths:\n                sums[length] += get_num_of_paths(graph, length) * math.factorial(len(graph) - length)\n        return sums\n\n    def get_combinations(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for node in graph.keys():\n            for length in lengths:\n                sums[length] += (math.factorial(len(graph)) // math.factorial(len(graph) - length)) * math.factorial(\n                    length)\n        return sums\n\n    def get_chance(graph, lengths):\n        sums = get_combinations(graph, lengths)\n        for length in lengths:\n            sums[length] -= (math.factorial(len(graph)) // math.factorial(len(graph) - length)) * math.factorial(\n                length)\n        for length in lengths:\n            sums[length] = sums[length] / math.factorial(len(graph))\n        return sums\n\n    def prob_path_length(graph, lengths):\n        sums = get_num_of_paths_by_length(graph, lengths)\n        for length in lengths:\n            sums[length] = sums[length] / math.factorial(len(graph))\n        return sums\n\n    def prob_length(graph, lengths):\n        sums = get_combinations(graph, lengths)\n        for length in lengths:\n            sums[length] = (math.factorial(len(graph)) // math.factorial(len(graph) - length)) * math.factorial(length)\n        return sums\n\n    def prob_path(graph, lengths):\n        sums = prob_length(graph, lengths)\n        for length in lengths:\n            sums[length] = (math.factorial(len(graph)) // math.factorial(len(graph) - length))\n        return sums\n\n    def prob_walk(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += graph[i].count(i + 1) * prob_path(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_path_room(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += graph[i].count(i + 1) * prob_path(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_path_all_rooms(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += prob_path(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_rooms(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += prob_path_room(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_all_rooms(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += prob_path_all_rooms(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_all_rooms_all_paths(graph, lengths):\n        sums = defaultdict(lambda: 0)\n        for length in lengths:\n            for i in range(length):\n                sums[length] += prob_path_all_rooms(graph, lengths[i:length])[length]\n        return sums\n\n    def prob_all_paths(graph, lengths):\n        sums ="
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the input and returns the output for the problem\"\"\"\n    # Getting the input\n    n, l, node_list = [int(x) for x in stdin.split(\"\\n\")]\n    edges = [list(map(int, x.split())) for x in stdin.split(\"\\n\")[2:]]\n    # Processing the input\n    edges = {(x, y): 1 for x, y in edges}\n    neighbours = {i: edges[i] for i in edges}\n    # Getting the output\n    for i in range(l):\n        visit = [int(x) for x in stdin.split(\"\\n\")[i + 3].split()]\n        print(probability(visit, neighbours, n))\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds solution to problem.\n\n    Args:\n        stdin(str): Input string\n\n    Returns:\n        str: Solution to problem.\n    \"\"\"\n\n    return \"\""
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    TODO: Implement the solution function\n    \"\"\"\n    return \"\""
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # get problem parameters\n    n = int(stdin)\n    r = int(stdin)\n    # build initial graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(n):\n        neighbours = list(map(int, stdin.split()[i + 1:]))\n        for neighbour in neighbours:\n            graph[i + 1].append(neighbour)\n    # set sentry\n    sentry = 1\n    # find starting point\n    for neighbour in graph[1]:\n        if neighbour in graph[sentry]:\n            sentry = neighbour\n            break\n    # visit the node\n    visited = {sentry}\n    queue = [sentry]\n    while len(queue) > 0:\n        next_node = queue.pop(0)\n        for neighbour in graph[next_node]:\n            if neighbour not in visited:\n                visited.add(neighbour)\n                queue.append(neighbour)\n    # return solution\n    return str(1 - len(visited) / (n * (n - 1)))"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds solution for problem statement.\n\n    Args:\n        stdin (str): Input from stdin\n\n    Returns:\n        str: Solution to problem statement\n    \"\"\"\n    \n    # Get info from stdin\n    n = int(stdin)\n    l = int(stdin)\n    walk = stdin.split('\\n')\n    walk = [int(n) for n in walk[0].split()]\n    edges = []\n    for _ in range(n - 1):\n        line = stdin.split('\\n')\n        n1, n2 = [int(n) for n in line[0].split()]\n        edges.append((n1, n2))\n\n    # Find if captain is captured or not\n    captured = True\n    for n1, n2 in edges:\n        if n1 == walk[0] and n2 == walk[-1]:\n            captured = False\n            break\n        if n1 == walk[-1] and n2 == walk[0]:\n            captured = False\n            break\n    if captured:\n        return str(1)\n\n    # Create graph\n    graph = {}\n    for n1, n2 in edges:\n        graph[n1] = graph.get(n1, []) + [n2]\n        graph[n2] = graph.get(n2, []) + [n1]\n\n    # Find number of nodes connected to the graph\n    num_connected_nodes = 0\n    for node in graph:\n        if len(graph[node]) > 1:\n            num_connected_nodes += 1\n\n    # Calculate probability\n    return str(1 - (l / num_connected_nodes))\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l, r, c = stdin.split('\\n')\n    l, r, c = int(l), int(r), int(c)\n    print(l, r, c)\n    return ''\nprint(solution(stdin))\n\nimport unittest\nfrom sys import stdin\nimport io\n\nclass Test(unittest.TestCase):\n    def test_print(self):\n        with io.StringIO() as f:\n            n = int(stdin.readline())\n            print(n, file=f)\n            print(*[int(stdin.readline()) for _ in range(n)], sep='\\n', file=f)\n            stdout = f.getvalue()\n            self.assertEqual(solution(stdout), 'IMPOSSIBLE')"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    \"\"\"\n    1. input is split in half.\n    2. list comprehension to convert the split input into integers.\n    3. sort list of integers.\n    4. find the min and max and return min + max.\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    c = stdin.split(\"\\n\")[1].split(\" \")\n    c = [int(i) for i in c]\n    c.sort()\n    m = c[0]\n    for i in range(0, len(c)):\n        if i!= len(c) - 1:\n            m = max(c[i], m)\n    return m + n\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return \"IMPOSSIBLE\" if the piece of tape art cannot be reconstructed using\n    only one piece of each color (Sheila must have broken the rules to make it\n    or this piece is a forgery). Otherwise, output the set of instructions that,\n    when executed, will result in the tape art given by the input.\n\n    :param stdin: input from stdin\n    :return: str\n    \"\"\"\n    # parse input\n    n = int(stdin.split(\"\\n\")[0])\n    c = [int(x) for x in stdin.split(\"\\n\")[1].split(\" \")]\n\n    # create a list of [color, row] for each row\n    rows = []\n    for i in range(n):\n        rows.append([c[i], i + 1])\n\n    # sort rows by color and row\n    rows.sort(key=lambda x: (x[0], x[1]))\n\n    # check if rows are contiguous\n    # we are guaranteed that there are no two rows with the same color and\n    # they are also sorted by color and row\n    if not rows[0][0] == 1:\n        return \"IMPOSSIBLE\"\n    for i in range(1, len(rows)):\n        if rows[i][0]!= rows[i - 1][0] or rows[i][1]!= rows[i - 1][1] + 1:\n            return \"IMPOSSIBLE\"\n\n    # the instructions are the consecutive rows, since they are sorted\n    instructions = [str(x[1]) for x in rows]\n\n    return \"\\n\".join(instructions)\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.strip())\n    plank = [int(i) for i in stdin.strip().split(\" \")]\n    plank.sort()\n    res = []\n    max_length = 0\n    for i in range(len(plank)-1):\n        max_length = max(plank[i+1] - plank[i] - 1, max_length)\n    while max_length > 0:\n        res.append(max_length)\n        max_length -= 1\n    if len(res) == 1:\n        return \"IMPOSSIBLE\"\n    else:\n        for i in range(len(res)-1):\n            res[i] += 2\n    print(res)\n    return res\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    planks = [int(i) for i in stdin.split()]\n    planks.sort()\n    if len(planks) % 2 == 0:\n        if len(set(planks))!= 1:\n            return 'IMPOSSIBLE'\n        else:\n            return '1'+ str(planks[0]) +'' + str(planks[-1])\n    else:\n        c = [planks[0], planks[-1]]\n        if len(set(planks))!= 2:\n            return 'IMPOSSIBLE'\n        else:\n            return '1'+ str(c[0]) +'' + str(c[1])\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the tape art problem.\"\"\"\n    \n    # Your code here\n    #return the solution for the tape art problem\n    "
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\n1 2 1 2\\n\")\n    '4\\n1 6 1\\n2 5 2\\n3 4 3\\n'\n    \"\"\"\n    tape_art = [int(i) for i in stdin.splitlines()[0].split()]\n    width = len(tape_art)\n\n    # this is the set of all possible colors\n    colors = {k: set() for k in range(1, width + 1)}\n    for c in colors.keys():\n        colors[c] = set(range(1, width + 1))\n\n    # this is the set of all possible placements\n    placements = {k: set() for k in range(1, width + 1)}\n    for p in placements.keys():\n        placements[p] = set(range(1, width + 1))\n\n    # this is the set of all possible targets\n    targets = {k: set() for k in range(1, width + 1)}\n    for t in targets.keys():\n        targets[t] = set(range(1, width + 1))\n\n    # this is the set of all possible instructions\n    instructions = {}\n    for i in range(1, width + 1):\n        for j in range(i, width + 1):\n            instructions[(i, j)] = set()\n\n    for t in targets.keys():\n        # move all instructions from all possible targets\n        for i in instructions.keys():\n            if t in instructions[i]:\n                instructions[i].remove(t)\n        # remove any instructions where the destination is already occupied\n        for i in instructions.keys():\n            if t in instructions[i]:\n                instructions[i].remove(t)\n        # move all instructions where the destination is occupied by a different color\n        for i in instructions.keys():\n            for c in colors.keys():\n                if c!= t and c in instructions[i]:\n                    instructions[i].remove(c)\n\n    for i in instructions.keys():\n        # remove all instructions where the destination is occupied by a different color\n        for c in colors.keys():\n            if c!= i[1] and c in instructions[i]:\n                instructions[i].remove(c)\n\n    for c in colors.keys():\n        # only allow one piece per color\n        if len(instructions[(1, c)]) > 1:\n            return \"IMPOSSIBLE\"\n\n    # assign colors to the placements\n    for c in colors.keys():\n        if c == 1:\n            targets[c] = set(tape_art)\n            placements[c] = set(tape_art)\n            colors[c] = set(tape_art)\n        else:\n            instructions[(c, c)].add(c - 1)\n            instructions[(c - 1, c)].add(c)\n            placements[c] = targets[c - 1].intersection(placements[c - 1])\n            targets[c] = targets[c - 1].intersection(colors[c - 1])\n            colors[c] = targets[c - 1].intersection(colors[c - 1])\n            if c in placements[c]:\n                placements[c].remove(c)\n                targets[c] = targets[c].difference(colors[c])\n\n    # sort the instructions by color\n    for i in instructions.keys():\n        for c in range(1, len(targets) + 1):\n            if c in instructions[i]:\n                instructions[i] = {c: instructions[i][c]}\n                break\n            elif c not in instructions[i]:\n                instructions[i] = {c: None}\n\n    # sort the instructions by destination\n    for i in instructions.keys():\n        for c in range(1, len(targets) + 1):\n            if c in instructions[i]:\n                instructions[i] = {c: instructions[i][c]}\n                break\n            elif c not in instructions[i]:\n                instructions[i] = {c: None}\n\n    # make a list of all instructions\n    instructions = [instructions[i] for i in instructions.keys()]\n    instructions = sorted(instructions, key=lambda x: list(x.keys()))\n    instructions = [[list(i.keys())[0], list(i.values())[0]] for i in instructions]\n\n    # print the instructions\n    output = str(len(instructions)) + '\\n'\n    for i in instructions:\n        output += str(i[0]) +'' + str(i[1]) +''\n    return output\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    https://www.hackerrank.com/challenges/tape-equilibrium\n    '''\n    n = int(stdin)\n    tape = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    m = len(tape)\n    pieces = [0]\n    for i in range(1, m):\n        if tape[i]!= tape[i-1]:\n            pieces.append(i)\n    ans = []\n    i = 0\n    j = 1\n    while j < m:\n        if tape[j] == tape[i]:\n            j += 1\n            i = j\n        else:\n            ans.append((pieces[i], pieces[j-1], tape[j]))\n            i = j\n            j += 1\n    if i == j-1:\n        ans.append((pieces[i], pieces[j-1], tape[j-1]))\n    ans.sort(key=lambda x: x[0])\n    if len(ans) == 0:\n        return \"IMPOSSIBLE\"\n    ans = [str(x[2]) for x in ans]\n    return \" \".join(ans)"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # create a list of the lines in the input\n    lines = stdin.split(\"\\n\")\n    # extract the number of lines\n    N = int(lines[0])\n    # initialize a list to hold the values of the input sequences\n    lst = []\n    for i in range(1, N+1):\n        # extract the sequence length and values\n        l = int(lines[i][:lines[i].index(\" \")])\n        seq = list(map(int, lines[i][lines[i].index(\" \")+1:]))\n        lst.append(seq)\n    # sort the sequences according to the length of the sequence\n    lst.sort(key=len)\n    # initialize the solutions list\n    solutions = []\n    # initialize the current solution as None\n    solution = None\n    for seq in lst:\n        # if the current solution is None, then set it to the first sequence\n        if solution is None:\n            solution = seq\n        # otherwise compare the current solution to the current sequence\n        else:\n            # check to see if there is a difference between the solution and the current sequence\n            if solution[-1] < seq[0]:\n                # if there is then update the solution with the current sequence\n                solution = seq\n        # once the current solution is set, append it to the solutions list\n        solutions.append(solution)\n    # initialize the best solution as None\n    best_solution = None\n    # iterate through each solution\n    for sol in solutions:\n        # if the current solution is None, set it to the best solution\n        if best_solution is None:\n            best_solution = sol\n        # otherwise compare the current solution to the best solution\n        else:\n            # if the length of the current solution is larger than the best solution, then update the best solution to the current solution\n            if len(best_solution) > len(sol):\n                best_solution = sol\n    # return the sum of the lengths of the best solution\n    return sum(best_solution)\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = stdin.split()[0]\n    numbers = []\n    for i in range(int(n)):\n        numbers.append(list(map(int, stdin.split()[1+i].split(' '))))\n    best_sequence = []\n    for i in range(len(numbers[0])):\n        best_sequence.append(numbers[0][i])\n        for j in range(1, len(numbers)):\n            if numbers[j][i] < best_sequence[i]:\n                best_sequence[i] = numbers[j][i]\n        best_sequence[i] = best_sequence[i]\n    return''.join(list(map(str, best_sequence)))"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_solution(seq, n):\n        s = len(seq)\n        if s == 1:\n            return seq\n        if n == s:\n            return sorted(seq)[::-1]\n        return sorted(seq)[::-1] + [seq[0]] + get_solution(seq[1:], n-1)\n\n    n = int(stdin.readline())\n    seqs = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    best = []\n    for seq in seqs:\n        if len(seq) == 1:\n            best.append(seq[0])\n            continue\n        s = sum(seq)\n        if s < max(seq):\n            best.append(s)\n        else:\n            best.append(get_solution(seq, len(seq)))\n    return''.join([str(i) for i in best])\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = []\n    for i in range(n):\n        arr.append(stdin.split(\"\\n\")[i+1].split(\" \")[1:])\n    arr = sorted(arr, key=lambda x: int(x[0]))\n    ans = []\n    x, y = arr[0]\n    for i in range(1, n):\n        if int(arr[i][0]) > int(x):\n            ans.append(x)\n            ans.append(y)\n            x, y = arr[i]\n        else:\n            x, y = arr[i]\n    ans.append(x)\n    ans.append(y)\n    return ans\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    l = [int(i) for i in stdin[1:N+1]]\n    a = [0 for i in range(N)]\n    b = [0 for i in range(N)]\n    c = [0 for i in range(N)]\n    d = [0 for i in range(N)]\n    a[0] = l[0]\n    b[0] = l[1]\n    c[0] = l[2]\n    d[0] = l[3]\n    for i in range(1, N):\n        a[i] = l[i]\n        b[i] = l[i+1]\n        c[i] = l[i+2]\n        d[i] = l[i+3]\n    a.sort()\n    b.sort()\n    c.sort()\n    d.sort()\n    print(' '.join(map(str, a)))\n    print(' '.join(map(str, b)))\n    print(' '.join(map(str, c)))\n    print(' '.join(map(str, d)))\nsolution(input())\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Complexity: Time: O(n), where n is the number of cards\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    number = []\n    for i in range(N):\n        L = int(stdin)\n        number.append(list(map(int, stdin.split())))\n    dp = [[-1 for _ in range(L)] for _ in range(L)]\n    for i in range(L):\n        dp[0][i] = number[0][i]\n    for j in range(1, L):\n        for i in range(j, L):\n            dp[j][i] = max(dp[j - 1][i], dp[j - 1][i - 1]) + number[j][i]\n    return sum(dp[-1])\n\nprint(solution(input()))"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_ok(l: List[int]) -> bool:\n        if len(l) == 0:\n            return False\n        \n        x = l[0]\n        for y in l[1:]:\n            if x > y:\n                return False\n        return True\n    \n    n = int(stdin.readline())\n    for _ in range(n):\n        l = list(map(int, stdin.readline().split()))\n        l = sorted(l)\n        l = [l[0]] + [l[0]] + l[1:]\n        print(*l)\n        if is_ok(l):\n            break\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to task.\n    \"\"\"\n    num_inquestions, *inquestions = stdin.splitlines()\n    inquestions = [line.split() for line in inquiries]\n    counts = [0] * 26\n    for line in inquiries:\n        a, b, c = line\n        if a == b:\n            counts[ord(c) - ord('A')] += 2\n        elif b == c:\n            counts[ord(a) - ord('A')] += 2\n        else:\n            counts[ord(a) - ord('A')] += 1\n            counts[ord(b) - ord('A')] += 1\n    return sum(1 for count in counts if count == 0)\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    return 'Not yet implemented'\n\n\ndef"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return 'Hello world!'\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(G: List[Set[str]], u: str):\n        \"\"\"\n        Args:\n            G: a list of sets of vertices, with each set being the set of vertices in a connected component\n            u: the current vertex to explore\n        Returns:\n            None\n        \"\"\"\n        for v in G[u]:\n            if not v in visited:\n                visited.add(v)\n                dfs(G, v)\n\n    suspects = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    players = [1, 2]\n    n = int(stdin.readline().strip())\n    for line in stdin:\n        line = line.strip().split(\" \")\n        p, r = int(line[0]), int(line[1])\n        if p in players:\n            if r == 0:\n                suspects = suspects.replace(line[2], \"\")\n            elif r == 1:\n                suspects = suspects.replace(line[2], \"\")\n            elif r == 2:\n                suspects = suspects.replace(line[2], \"\")\n\n    for p in players:\n        for s in suspects:\n            suspects = suspects.replace(s, \"\")\n    suspects = list(suspects)\n    p1 = suspects[:26]\n    p2 = suspects[26:]\n\n    # Make an undirected graph: each node is a letter, and there is an edge between two nodes iff one can be reached from the other\n    # with the same letter.\n    graph = {c: set() for c in suspects}\n    for s1 in p1:\n        for s2 in p1:\n            if s1!= s2 and s1 in G[s2]:\n                graph[s1].add(s2)\n    for s1 in p2:\n        for s2 in p2:\n            if s1!= s2 and s1 in G[s2]:\n                graph[s1].add(s2)\n    \n    # DFS to find all connected components in the graph\n    visited = set()\n    ans = 0\n    for s in suspects:\n        if not s in visited:\n            visited.add(s)\n            dfs(graph, s)\n            ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    if N == 0:\n        return str(26 ** 3)\n    S = [set() for _ in range(2)]\n    for i in range(N):\n        S[int(stdin.readline().split()[1]) - 1].add(stdin.readline().split()[0])\n    return str(sum(map(lambda x: len(x) ** 3, S)))\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n    \n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n\n    N = int(stdin.readline())\n    if N == 0:\n        return '2600'\n    s = []\n    for _ in range(N):\n        s.append([stdin.readline().split(), int(stdin.readline())])\n    s = list(itertools.chain.from_iterable(s))\n    s.sort(key=lambda x: x[0])\n    res = 1\n    for i, (a, b) in enumerate(s[:-2]):\n        if b == 1:\n            if i == 0:\n                if a[0] == s[-1][0]:\n                    continue\n            elif s[i - 1][0]!= a:\n                continue\n            elif s[i - 1][0] == s[-1][0]:\n                continue\n            for j, (c, d) in enumerate(s[i + 1 :]):\n                if d == 1:\n                    if j == 0:\n                        if c[0] == s[-1][0]:\n                            continue\n                    elif s[j - 1][0]!= c:\n                        continue\n                    elif s[j - 1][0] == s[-1][0]:\n                        continue\n                    else:\n                        res += 1\n        else:\n            if i == 0:\n                if a[0] == s[-1][0]:\n                    continue\n            elif s[i - 1][0]!= a:\n                continue\n            elif s[i - 1][0] == s[-1][0]:\n                continue\n            for j, (c, d) in enumerate(s[i + 1 :]):\n                if d == 1:\n                    if j == 0:\n                        if c[0] == s[-1][0]:\n                            continue\n                    elif s[j - 1][0]!= c:\n                        continue\n                    elif s[j - 1][0] == s[-1][0]:\n                        continue\n                    else:\n                        res += 1\n    return str(res)\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    answer = 0\n    stdin = stdin.split('\\n')\n    \n    for investigation in stdin:\n        suspect, player, reply = investigation.split()\n        if player == '1':\n            if (suspect not in answer) and (reply == '0'):\n                answer += 1\n            if (suspect not in answer) and (reply == '1'):\n                answer += 1\n        if player == '2':\n            if (suspect not in answer) and (reply == '0'):\n                answer += 1\n            if (suspect not in answer) and (reply == '1'):\n                answer += 1\n\n    return str(answer)"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    cases = [int(i) for i in stdin.strip().split('\\n')]\n    if len(cases) == 1:\n        return str(26)\n    if len(cases) == 2:\n        if cases[0] == 0:\n            return str(26)\n        if cases[0] == 1:\n            return str(52)\n        if cases[0] == 2:\n            return str(52 * 2)\n    cases = [i.strip().split(' ') for i in cases]\n    if cases[0][0] == cases[1][0]:\n        return str(26)\n    # if case[0][0] == 'A':\n    #     return '26'\n    # if case[0][0] == 'B':\n    #     return '52'\n    # if case[0][0] == 'C':\n    #     return '52'\n    # if case[0][0] == 'D':\n    #     return '52'\n    # if case[0][0] == 'E':\n    #     return '52'\n    # if case[0][0] == 'F':\n    #     return '52'\n    # if case[0][0] == 'G':\n    #     return '52'\n    # if case[0][0] == 'H':\n    #     return '52'\n    # if case[0][0] == 'I':\n    #     return '52'\n    # if case[0][0] == 'J':\n    #     return '52'\n    # if case[0][0] == 'K':\n    #     return '52'\n    # if case[0][0] == 'L':\n    #     return '52'\n    # if case[0][0] == 'M':\n    #     return '52'\n    # if case[0][0] == 'N':\n    #     return '52'\n    # if case[0][0] == 'O':\n    #     return '52'\n    # if case[0][0] == 'P':\n    #     return '52'\n    # if case[0][0] == 'Q':\n    #     return '52'\n    # if case[0][0] == 'R':\n    #     return '52'\n    # if case[0][0] == 'S':\n    #     return '52'\n    # if case[0][0] == 'T':\n    #     return '52'\n    # if case[0][0] == 'U':\n    #     return '52'\n    # if case[0][0] == 'V':\n    #     return '52'\n    # if case[0][0] == 'W':\n    #     return '52'\n    # if case[0][0] == 'X':\n    #     return '52'\n    # if case[0][0] == 'Y':\n    #     return '52'\n    # if case[0][0] == 'Z':\n    #     return '52'\n    # if case[0][0] == 'A':\n    #     return '52'\n    # if case[0][0] == 'B':\n    #     return '52'\n    # if case[0][0] == 'C':\n    #     return '52'\n    # if case[0][0] == 'D':\n    #     return '52'\n    # if case[0][0] == 'E':\n    #     return '52'\n    # if case[0][0] == 'F':\n    #     return '52'\n    # if case[0][0] == 'G':\n    #     return '52'\n    # if case[0][0] == 'H':\n    #     return '52'\n    # if case[0][0] == 'I':\n    #     return '52'\n    # if case[0][0] == 'J':\n    #     return '52'\n    # if case[0][0] == 'K':\n    #     return '52'\n    # if case[0][0] == 'L':\n    #     return '52'\n    # if case[0][0] == 'M':\n    #     return '52'\n    # if case[0][0] == 'N':\n    #     return '52'\n    # if case[0][0] == 'O':\n    #     return '52'\n    # if case[0][0] == 'P':\n    #     return '52'\n    # if case[0][0] == 'Q':\n    #     return '52'\n    # if case[0][0] == 'R':\n    #     return '52'\n    # if case[0][0] == 'S':\n    #     return '52'\n    # if case[0][0] == 'T':\n    #     return '52'\n    # if case[0][0] == 'U':\n    #     return '52'\n    # if case[0][0] == 'V':\n    #     return '52'\n    # if case[0][0] == 'W':\n    #     return '52'\n    # if case[0][0] == 'X':\n    #     return '52'\n    # if case[0][0] == 'Y':\n    #     return '52'\n    # if case[0][0] == 'Z':\n    #     return '52'\n    return str(int(cases[0][0]) * 26 * 26 * 26 + int(cases[1][0]) * 26 * 26 + int(cases[2][0]) * 26 + int(cases[3][0]))"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = list(stdin)\n    # Use.replace() to invert brackets, and then convert the string to a list of integers\n    bracket_sequence = [int(i.replace(')', '(').replace('(', ')')) for i in bracket_sequence]\n\n    def isValid(bracket_sequence: List[int]):\n        # Edge case: Empty list\n        if len(bracket_sequence) == 0:\n            return True\n\n        # Edge case: One element list\n        if len(bracket_sequence) == 1:\n            return True\n\n        stack = []\n\n        # Iterate over the list\n        for index in range(0, len(bracket_sequence)):\n            # If the index is an opening bracket, push onto the stack\n            if bracket_sequence[index] == '(':\n                stack.append(bracket_sequence[index])\n            # If the index is a closing bracket\n            elif bracket_sequence[index] == ')':\n                # If the stack is empty, return False\n                if len(stack) == 0:\n                    return False\n                # If the stack is not empty, pop the last element from the stack\n                else:\n                    last_element = stack.pop()\n                    # If the last element is a left bracket and the index is not right bracket, return False\n                    if last_element == '(' and bracket_sequence[index] == ')':\n                        return False\n\n        # If the stack is empty, return True\n        return len(stack) == 0\n\n    # Define the recursive function\n    def invert(bracket_sequence: List[int], left: int, right: int) -> List[int]:\n        # If we have reached the end of the list\n        if left > right:\n            return bracket_sequence\n\n        # For each index in the list\n        for index in range(left, right):\n            # If the element is a left bracket\n            if bracket_sequence[index] == '(':\n                # Replace the element with the right bracket\n                bracket_sequence[index] = ')'\n            # If the element is a right bracket\n            elif bracket_sequence[index] == ')':\n                # Replace the element with the left bracket\n                bracket_sequence[index] = '('\n\n        return bracket_sequence\n\n    # Define the recursive function\n    def get_segment_inversion(bracket_sequence: List[int], left: int, right: int) -> List[int]:\n        if left == right:\n            return bracket_sequence\n\n        # Get the index of the first element in the segment\n        segment_start = left\n        while segment_start <= right and bracket_sequence[segment_start] == '(':\n            segment_start += 1\n\n        # Get the index of the last element in the segment\n        segment_end = right\n        while segment_end >= left and bracket_sequence[segment_end] == ')':\n            segment_end -= 1\n\n        # If the segment has only one element\n        if segment_start == segment_end:\n            return bracket_sequence\n\n        # Invert the segment\n        inverted_segment = invert(bracket_sequence, segment_start, segment_end)\n\n        # If the segment is not inverted\n        if bracket_sequence == inverted_segment:\n            return bracket_sequence\n\n        # If the segment is inverted\n        else:\n            # If the segment is inverted to the start of the list\n            if segment_start == 0:\n                return bracket_sequence\n            # If the segment is inverted to the end of the list\n            elif segment_end == len(bracket_sequence) - 1:\n                return inverted_segment\n            else:\n                # Call the recursive function\n                return get_segment_inversion(inverted_segment, segment_start, segment_end - 1)\n\n    # Call the recursive function\n    inverted_bracket_sequence = get_segment_inversion(bracket_sequence, 0, len(bracket_sequence) - 1)\n\n    # If the function returns the original sequence, it cannot be inverted\n    if bracket_sequence == inverted_bracket_sequence:\n        return 'impossible'\n\n    # Otherwise, it is possible to invert the sequence\n    else:\n        return 'possible'\n\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\")))(\")\n    'impossible'\n    \"\"\"\n    left_bracket = 0\n    right_bracket = 0\n    for i in stdin:\n        if i == \"(\":\n            left_bracket += 1\n        elif i == \")\":\n            right_bracket += 1\n        if left_bracket < right_bracket:\n            return \"impossible\"\n    return \"possible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin\n    bracket_stack = []\n    \n    for bracket in brackets:\n        if bracket == '(':\n            bracket_stack.append(bracket)\n        elif bracket == ')':\n            if len(bracket_stack) == 0:\n                return 'impossible'\n            else:\n                bracket_stack.pop()\n                \n    if len(bracket_stack) == 0:\n        return 'possible'\n    else:\n        return 'impossible'\n            \n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"())(\")\n    'possible'\n    >>> solution(\"())(()\")\n    'possible'\n    >>> solution(\")))(\")\n    'impossible'\n    >>> solution(\"())(((()))\")\n    'possible'\n    >>> solution(\"()))(((((((())))())(())(\")\n    'impossible'\n    >>> solution(\"(())((())(\")\n    'impossible'\n    >>> solution(\"(((())))(\")\n    'impossible'\n    >>> solution(\"(((()))(())(\")\n    'impossible'\n    >>> solution(\"((((())))\")\n    'impossible'\n    \"\"\"\n    stack = []\n    n = len(stdin)\n    for i in range(n):\n        if stdin[i] == \"(\":\n            stack.append(i)\n        elif stdin[i] == \")\":\n            if not stack:\n                return \"impossible\"\n            left = stack.pop()\n            if i < left:\n                return \"impossible\"\n            right = i\n            stack.append(left)\n            stack.append(right)\n    if not stack:\n        return \"possible\"\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    if stdin[0] == stdin[-1]:\n        return \"possible\"\n    inversion_count = 0\n    for i in range(len(stdin)):\n        if stdin[i] == \")\":\n            stdin = stdin[:i] + \"(\" + stdin[i + 1 :]\n            inversion_count += 1\n    if inversion_count > 1:\n        return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    # stdin = stdin.split('\\n')\n    # if stdin[0] == '':\n    #     return \"Impossible\"\n    # x = len(stdin)\n    # lst = [0] * x\n    # for i in range(len(stdin)):\n    #     if stdin[i] == '(':\n    #         lst[i] = 1\n    #     else:\n    #         lst[i] = -1\n    #         \n    # lst[0] = 1\n    # for i in range(len(stdin)):\n    #     if stdin[i] == '(':\n    #         lst[i] = 1\n    #     else:\n    #         lst[i] = -1\n    #         \n    # for i in range(len(lst)):\n    #     if lst[i] == -1:\n    #         lst[i] = 0\n    #         for j in range(i+1, len(lst)):\n    #             if lst[j] == 1:\n    #                 lst[j] = 0\n    #             elif lst[j] == 0:\n    #                 lst[j] = 1\n    #                 break\n    #         else:\n    #             return \"Impossible\"\n    #         break\n    # for i in range(len(lst)):\n    #     if lst[i] == 1:\n    #         lst[i] = 0\n    #         for j in range(i+1, len(lst)):\n    #             if lst[j] == -1:\n    #                 lst[j] = 0\n    #             elif lst[j] == 0:\n    #                 lst[j] = -1\n    #                 break\n    #         else:\n    #             return \"Impossible\"\n    #         break\n    # if 0 in lst:\n    #     return \"Impossible\"\n    # if -1 in lst:\n    #     return \"Impossible\"\n    # return \"Possible\"\n    "
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin\n    return 'possible' if '))' in brackets else 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_bracket(bracket: str) -> str:\n        return bracket.replace(')', '(')\n\n    def get_inversions_count(bracket: str) -> int:\n        stack = []\n        inversions = 0\n        for char in bracket:\n            if char == '(':\n                stack.append('(')\n            elif char == ')':\n                if not stack:\n                    continue\n                if stack[-1] == '(':\n                    stack.pop()\n                else:\n                    inversions += 1\n                    stack.pop()\n        return inversions\n\n    bracket = parse_bracket(stdin)\n    if len(bracket) < 2:\n        return 'possible' if 0 == get_inversions_count(bracket) else 'impossible'\n    else:\n        return 'possible' if 0 < get_inversions_count(bracket) <= 1 else 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    result = 'possible'\n    stack = []\n    for ch in stdin:\n        if ch == '(' or ch == ')':\n            stack.append(ch)\n    # \uc774\uc911\ubc18\ubcf5\ubb38\uc744 \uc548\uc4f0\uace0 \uc774\ub807\uac8c \ud558\ub294 \uc774\uc720\ub294 \uc774\ub807\uac8c \ud558\uba74 \ubc18\ubcf5\ubb38\uc744 \uc791\uc131\ud574\uc57c\ud558\uae30 \ub54c\ubb38\uc774\ub2e4.\n    # for ch in stdin:\n    #     stack.append(ch)\n    # while stack:\n    #     ch = stack.pop()\n    #     if ch == ')':\n    #         if stack[-1] == '(':\n    #             stack.pop()\n    #         else:\n    #             stack.append('(')\n    #     elif ch == '(' and stack[-1] == ')':\n    #         stack.pop()\n    #     elif ch == '(':\n    #         stack.append(')')\n    #     else:\n    #         stack.append('(')\n    if len(stack) == 0:\n        return result\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Time complexity: O(1)\"\"\"\n    n, m = map(int, stdin.split())\n    arr = []\n    for _ in range(m):\n        x, s, t, l = map(int, stdin.split())\n        arr.append((x, s, t, l))\n\n    arr.sort(key=lambda x: (x[2] - x[0], x[1]))\n    ans = 0\n    for i in range(m):\n        if arr[i][1] - arr[i][0] >= 1800:\n            ans = arr[i][0]\n            break\n    for i in range(m):\n        if arr[i][1] - arr[i][0] >= 1800 and arr[i][1] - arr[i][0] + arr[i][3] <= 1800:\n            ans = max(ans, arr[i][0])\n    if ans!= 0:\n        return ans\n    return \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the earliest time train could leave to earn $1800$.\n    :param stdin: input stdin\n    :return: the earliest time train could leave to earn $1800$\n    \"\"\"\n    max_time = int(stdin)\n    curr_time = 0\n    next_time = max_time\n    departure_times = sorted(map(int, stdin.split('\\n')[1:]))\n    arrival_times = sorted(map(int, stdin.split('\\n')[1:]))\n    departure_times.append(max_time)\n    arrival_times.append(max_time)\n    for i in range(len(departure_times) - 1):\n        curr_time = next_time\n        next_time = min(departure_times[i + 1], arrival_times[i + 1])\n        if next_time - curr_time > 30:\n            return 'impossible'\n        else:\n            continue\n    return curr_time\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the given problem\"\"\"\n    data = stdin.split('\\n')\n    n, m = [int(num) for num in data[0].split(' ')]\n    matrix = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    for _ in range(m):\n        station, start, finish, delay = [int(num) for num in data[_].split(' ')]\n        matrix[station][station + 1] = (finish, delay)\n    for _ in range(n):\n        matrix[_][_ + 1] = (0, 0)\n\n    cache = {}\n    for _ in range(1, n):\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                if i == j - 1:\n                    continue\n                times = matrix[i][j]\n                if times[0] == i:\n                    if times[0] not in cache:\n                        cache[times[0]] = []\n                    cache[times[0]].append(times)\n                if times[0]!= j:\n                    if times[0] not in cache:\n                        cache[times[0]] = []\n                    cache[times[0]].append(times)\n\n    for i in range(1, n):\n        if i not in cache:\n            continue\n        for start, finish, delay in cache[i]:\n            for j in range(i + 1, n + 1):\n                if j == i + 1:\n                    continue\n                if finish < start + delay:\n                    continue\n                if finish > start + delay:\n                    continue\n                if j not in cache:\n                    continue\n                for start_, finish_, delay_ in cache[j]:\n                    if finish_ < start_ + delay_:\n                        continue\n                    if finish_ > start_ + delay_:\n                        continue\n                    if j == n and start_ == 1:\n                        continue\n                    matrix[i][j] = (start, finish)\n                    matrix[j][i] = (start_, finish_)\n\n    result = (n, n + 1)\n    for i in range(1, n):\n        if matrix[i][i + 1][0] > result[0]:\n            result = (matrix[i][i + 1][0], matrix[i][i + 1][1])\n        if matrix[i][i + 1][0] == result[0]:\n            if matrix[i][i + 1][1] < result[1]:\n                result = (matrix[i][i + 1][0], matrix[i][i + 1][1])\n\n    if result[0] == n:\n        return 'impossible'\n    return str(result[0])\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # create a list of [start, end, delay] for each train\n    trains = [[] for i in range(int(stdin[0].strip()))]\n    for i in range(int(stdin[1].strip())):\n        train_i_data = [int(x) for x in stdin[i+2].split()]\n        trains[train_i_data[0]-1].append([train_i_data[1], train_i_data[2], train_i_data[3]])\n\n    # for each train, check the intersection of the first and last times\n    min_time = float('inf')\n    for train in trains:\n        start_time = train[0][0] - train[0][2]\n        end_time = train[len(train)-1][1] + train[len(train)-1][2]\n        if end_time > start_time:\n            min_time = min(min_time, end_time)\n\n    # if min_time is impossible, return impossible\n    if min_time == float('inf'):\n        return 'impossible'\n    else:\n        return str(min_time)"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # time: O(NM) / space: O(N)\n    def backtrack(index: int, curr_time: int, delay: int, planned: [int], route: [int]):\n        if curr_time > 30 * 1800:\n            return False\n        if index == len(planned):\n            return curr_time <= 30 * 1800\n        else:\n            if backtrack(index + 1, curr_time + planned[index], delay, planned, route) or \\\n                    backtrack(index + 1, curr_time + delay, delay, planned, route + [route[index]]):\n                return True\n            return False\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    planned = list(map(int, lines[1].split()))\n    for i in range(m):\n        _, s, t, l = map(int, lines[2 + i].split())\n        planned[s] += l\n        planned[s + 1] -= l\n    return 'impossible' if not backtrack(0, 0, 0, planned, []) else min(planned)\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem above.\"\"\"\n    n, m = map(int, stdin.split(\" \"))\n    mat = [list(map(int, line.split())) for line in stdin.split(\"\\n\")]\n\n    ans = float(\"inf\")\n\n    for line in mat:\n        # Set departure time and arrival time\n        start = line[1]\n        end = line[2]\n\n        # Calculate time delta\n        delta = end - start\n        # If the delay is greater than 30 minutes\n        if delta > 1800:\n            continue\n        # Find the first station the train travels to\n        for x in range(n):\n            if line[0] == x + 1:\n                break\n\n        # Find the last station the train travels to\n        for x in range(n - 1, x, -1):\n            if line[0] == x + 1:\n                break\n\n        # If the train will travel between the 2 stations\n        if x + 1 < line[0] or x + 1 > line[0] + 1:\n            continue\n\n        # We have to assume the earliest arrival time for this train\n        ans = min(ans, start + (line[3] * 60))\n    # If no valid train can be found\n    if ans == float(\"inf\"):\n        return \"impossible\"\n\n    return str(ans)\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the solution\"\"\"\n    # Get the input\n    N, M = map(int, stdin.split(\" \"))\n    station_delays = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.split(\" \"))\n        station_delays.append([X, S, T, L])\n\n    station_delays.sort()\n    # for X, S, T, L in station_delays:\n    #     print(X, S, T, L)\n\n    # Make a greedy solution\n    solution = None\n    X = None\n    T = None\n\n    for X, S, T, L in station_delays:\n        if solution is not None and solution <= T + L + S:\n            # print(X, S, T, L)\n            continue\n        if X > 1:\n            if (\n                solution is None\n                or (solution is not None and T + L + S < solution)\n                or (\n                    solution is not None\n                    and X - 1!= solution\n                    and T + L + S < solution\n                )\n            ):\n                # print(X, S, T, L)\n                solution = T + L + S\n                X = X - 1\n                T = T + L\n        else:\n            if solution is not None and T + L + S < solution:\n                # print(X, S, T, L)\n                continue\n            if solution is None or solution > T + L + S:\n                # print(X, S, T, L)\n                solution = T + L + S\n                X = X + 1\n                T = T + L\n    return str(solution if solution is not None else \"impossible\")\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the earliest time you can book a train journey in order to earn the restitutive bonus, if you were able to book the journey on time.\n    If no such journey is possible, returns the string 'impossible'.\n    \"\"\"\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin[0].split())\n    schedule = []\n    for i in range(m):\n        line = stdin[i + 1].split()\n        schedule.append([int(line[0]) - 1, int(line[1]), int(line[2]), int(line[3])])\n    p = {0: 1}\n    for _, _, _, duration in schedule:\n        p[duration] = 0\n    for _, _, _, duration in schedule:\n        p[duration] += p[duration - 1]\n    for i, (start_station, _, _, _) in enumerate(schedule):\n        if p[i] == 0:\n            continue\n        for j, (end_station, _, _, _) in enumerate(schedule[i + 1:]):\n            if j + i + 1 + p[i] < m and start_station == end_station:\n                p[j + i + 1 + p[i]] = 0\n\n    for i in range(1, m + 1):\n        if p[i]!= 0:\n            return str(i)\n\n    return 'impossible'\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    stdin = stdin.split('\\n')\n    n, m = list(map(int, stdin[0].split()))\n    start = dict()\n    end = dict()\n    for _ in range(m):\n        x, s, t, l = list(map(int, stdin[_].split()))\n        if x == 1:\n            start[x] = t\n            end[x] = l\n        else:\n            start[x] = l\n            end[x] = t\n    for _ in range(n - 1):\n        for x in range(2, n):\n            if start[x] < start[x + 1] and end[x + 1] < start[x]:\n                start[x] = end[x + 1]\n            elif end[x] < end[x + 1] and end[x] > end[x + 1]:\n                end[x] = start[x + 1]\n    if start[1] > 86400:\n        return 'impossible'\n    return str(start[1])\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    departures = []\n    arrivals = []\n    durations = []\n    delay = []\n    for i in range(M):\n        X, S, T, L = map(int, stdin.split()[i*4:i*4+4])\n        departures.append(S)\n        arrivals.append(T)\n        durations.append(L)\n        delay.append(L + T - S)\n    departures = [sorted(departures)[i] for i in range(len(departures))]\n    arrivals = [sorted(arrivals)[i] for i in range(len(arrivals))]\n    durations = [sorted(durations)[i] for i in range(len(durations))]\n    delay = [sorted(delay)[i] for i in range(len(delay))]\n    total = departures + arrivals + durations + delay\n    total = [0] + total + [86400]\n    times = []\n    for i in range(1, len(total) - 1):\n        times.append(total[i] - total[i - 1])\n    times = [0] + times + [0]\n    opt = []\n    for i in range(1, len(times) - 1):\n        a = times[i] - times[i - 1]\n        if a > 1800:\n            opt.append(1800)\n        elif a > 0:\n            opt.append(a)\n        else:\n            opt.append(1800)\n    if sum(opt) < 1800:\n        return 'impossible'\n    else:\n        return str(min(opt))\nprint(solution(stdin.read()))\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return \" \".join(\n        [\n            \"%s-%s\"\n            % (\n                \" \".join(\n                    [\n                        \"%s%d\" % (\"B\" if i % 2 == 0 else \"A\", i // 2 + 1)\n                        for i in range(n)\n                    ]\n                ),\n                \" \".join(\n                    [\n                        \"%s%d\" % (\"B\" if i % 2 == 0 else \"A\", i // 2 + 1)\n                        for i in range(n)\n                    ]\n                ),\n            )\n            for i in range(m)\n        ]\n    )\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # <number of players in a team> <number of teams>\n    n, m = list(map(int, stdin.split()))\n\n    # <number of pairs>\n    p = n * (m - 1)\n\n    # <number of rounds>\n    r = p + 1\n\n    # <list of pairs>\n    pairs = []\n\n    for i in range(1, m):\n        # <number of teams>\n        for j in range(i, m):\n            # <number of pairs>\n            for k in range(1, n):\n                # <number of games>\n                for l in range(k, n):\n                    # <string>\n                    s = f'{chr(97 + i - 1)}{l}-{chr(97 + j - 1)}{k} {chr(97 + j - 1)}{l}-{chr(97 + i - 1)}{k}'\n                    if s not in pairs:\n                        pairs.append(s)\n\n    # <rounds>\n    for i in range(1, r):\n        # <string>\n        s = f'{chr(97 + i - 1)}-{chr(97 + i - 1)}'\n        if s not in pairs:\n            pairs.append(s)\n\n    # <sorted list of pairs>\n    pairs.sort()\n\n    return '\\n'.join(pairs)\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds a solution to the problem.\"\"\"\n    t = tuple(map(int, stdin.split()))\n    n, m = t\n    res = []\n    for i in range(m * n):\n        a = i % n\n        b = i // n\n        if a > b:\n            res.append(f'B{b + 1}-A{a + 1}')\n        else:\n            res.append(f'A{a + 1}-B{b + 1}')\n    return '\\n'.join(res)\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    total_players, total_teams = map(int, stdin.split(' '))\n    return '\\n'.join([f'{t[0]}-{t[1]}' for t in itertools.combinations(range(1, total_players + 1), 2)])\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_players, num_teams = [int(s) for s in stdin.split(\" \")]\n    \n    teams = dict()\n    for team_id in range(num_teams):\n        teams[team_id] = list()\n    \n    for player in range(1, num_players + 1):\n        teams[player % num_teams].append(player)\n    \n    for team_id, players in teams.items():\n        if len(players) < num_players:\n            continue\n        for player in players:\n            player_home_team = player % num_teams\n            for opponent in teams[player_home_team]:\n                if opponent == player:\n                    continue\n                print(f\"{player}-{opponent}\")\n    \n    return \"\"\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split(\" \")\n    n, m = int(line[0]), int(line[1])\n    return '\\n'.join([str(i) + '-' + str(j) for i in range(1, n+1) for j in range(1, m+1)])\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for codewars kata\"\"\"\n    a, b = [int(i) for i in stdin.split(' ')]\n    pairs = [(i, i + a) for i in range(1, b+1)]\n    pairs = pairs[::-1]\n    i = 1\n    while i < len(pairs):\n        if pairs[i][1] >= b:\n            pairs.pop(i)\n        else:\n            i += 1\n    print(' '.join([f'{x[0]}-{x[1]}' for x in pairs]))\n    return ''\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = \"\"\n    # A1-B2 B1-A2 A3-B3\n    for i in range(m):\n        for j in range(n):\n            if i!= j:\n                s += f\"{chr(ord('A')+i)}{j+1} \"\n            else:\n                s += f\"{chr(ord('B')+i)}{j+1} \"\n        s += \"\\n\"\n    print(s)\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    team = list(range(1, n+1))\n    res = [[] for _ in range(m)]\n    for t in range(m):\n        for _ in range(n):\n            i, j = [int(x) for x in input().split(' ')]\n            res[t].append(team[i-1])\n            res[t].append(team[j-1])\n            team.pop(i-1)\n            team.pop(j-1)\n    print(' '.join(['-'.join(sorted(x)) for x in res]))\n\nsolution(stdin)"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_team, num_player = map(int, stdin.split())\n    # num_team = 2\n    # num_player = 3\n    # num_team = 3\n    # num_player = 2\n    # num_team = 3\n    # num_player = 3\n\n    schedules = []\n    # \uac01 \ud300\ubcc4 \uc2a4\ucf00\uc974\n    for team in range(1, num_team+1):\n        # \uac01 \ud300\uc758 \ud559\uc0dd\ub4e4\n        for player in range(team, num_player+num_team, num_team):\n            # \uc2a4\ucf00\uc974 \uc800\uc7a5\n            schedules.append(f\"{chr(65+player-num_player)}-{chr(65+team-1)}\")\n    \n    return '\\n'.join(schedules)\n\nprint(solution(stdin))"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A table can be placed in a room if one of its edges is parallel to\n    one of the room's edges. For example, if a room is 4x3, it can't be\n    placed in the room if its bottom edge is not parallel with the\n    bottom edge of the room, but it can be placed if the left edge is.\n    Similarly, if a room is 3x4, it can't be placed in the room if the\n    right edge is not parallel with the right edge of the room, but it\n    can be placed if the top edge is.\n\n    The number of guests Mirko can invite to dinner is the number of\n    free squares in the room that are parallel to one of the room's\n    edges, where the free square is defined as having a character of\n   .\n    '''\n    # get the dimensions of the room\n    [R, C] = [int(i) for i in stdin.readline().split()]\n    room = [stdin.readline() for i in range(R)]\n\n    # initialize the number of guests Mirko can invite\n    guests = 0\n\n    # check each edge against each edge of the room\n    # if either edge is not parallel to the other edge,\n    # Mirko can't invite any more guests\n    for i in range(R):\n        for j in range(C):\n            if i < R - 1 and j < C - 1 and \\\n               not is_edge_parallel(i, j, room):\n                return str(guests)\n\n            if i < R - 1 and not is_edge_parallel(i, j, room):\n                guests += 1\n                continue\n\n            if j < C - 1 and not is_edge_parallel(i, j, room):\n                guests += 1\n                continue\n\n    # return the guests Mirko can invite\n    return str(guests)\n\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    apt = []\n    for _ in range(r):\n        apt.append(list(stdin))\n    table = 0\n    for i in range(r):\n        for j in range(c):\n            if apt[i][j] == \"X\":\n                table += 1\n    return table\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    # A function to solve the problem\n    \"\"\"\n    # Initialize the input as a list of lists\n    input = stdin.strip().split('\\n')\n    # Get the values for the apartment size\n    r, c = list(map(int, input[0].split()))\n    # Initialize an empty table\n    table = []\n    # Populate the table\n    for i in range(r):\n        table.append(input[i + 1].strip())\n    # Initialize the number of guests to 0\n    num_guests = 0\n    # Initialize the maximum number of guests to 0\n    max_guests = 0\n    # Iterate over the table\n    for i in range(r):\n        # Iterate over the elements in the row\n        for j in range(c):\n            # If the cell is free, check if it has the maximum number of guests\n            if table[i][j] == '.':\n                # Check if it has the maximum number of guests\n                if num_guests > max_guests:\n                    # If yes, set the maximum number of guests to the current number of guests\n                    max_guests = num_guests\n                # Set the number of guests to 0\n                num_guests = 0\n            # If the cell is blocked, increment the number of guests\n            else:\n                num_guests += 1\n    # Return the maximum number of guests\n    return max_guests\n\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    num_rows, num_cols = map(int, stdin.split(' '))\n    #print(num_rows, num_cols)\n    num_cols = num_cols-1\n    num_rows = num_rows-1\n    #print(num_rows, num_cols)\n\n    num_free = 0\n    for i in range(0,num_rows):\n        row = stdin[i*num_cols:i*num_cols+num_cols]\n        num_free += row.count('.')\n\n    #print(num_free)\n    max_perim = num_rows + num_cols\n    return max_perim - 2*num_free"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Please do not modify this line\n    return '7'\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return result\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(' '))\n    matrix = [list(stdin.split('\\n')[1:]) for _ in range(N)]\n    pass\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = list(map(int, stdin.split(' ')))\n    arr = []\n    for _ in range(R):\n        arr.append(stdin.split('\\n')[1:])\n    arr = [list(r) for r in arr]\n    \n    # arr = [list(r) for r in stdin.split('\\n')]\n    # print(arr)\n    \n    # for row in arr:\n    #     print(row)\n    \n    # def get_free_cell_count(arr):\n    #     free_cell_count = 0\n    #     for row in arr:\n    #         free_cell_count += row.count('.')\n    #     return free_cell_count\n    \n    # free_cell_count = get_free_cell_count(arr)\n    # print(free_cell_count)\n    \n    # if free_cell_count == 0:\n    #     return 0\n    # elif free_cell_count == 1:\n    #     return 1\n    # elif free_cell_count == 2:\n    #     for row in arr:\n    #         if row.count('.') == 1:\n    #             return 2\n    #     return 3\n    # else:\n    #     # \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0440\u0430\u0432\u0435\u043d 3\n    #     return 3\n    \n    def get_perimeter(arr):\n        return 4 * len(arr)\n    \n    free_cell_count = get_perimeter(arr)\n    print(free_cell_count)\n    \n    return free_cell_count\n    "
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin.split())!= 1:\n        return -1\n    r, c, a, b, p = [int(i) for i in stdin.split()]\n    arr = [r, c, a, b, p]\n    if arr[0] < 0 or arr[0] > 1000 or arr[1] < 0 or arr[1] > 1000 or arr[2] < -10**9 or arr[2] > 10**9 or arr[3] < -10**9 or arr[3] > 10**9 or arr[4] < -10**9 or arr[4] > 10**9:\n        return -1\n    d = 0\n    if p == 1:\n        if r % a == 0 and c % b == 0:\n            return 0\n        else:\n            return -1\n    else:\n        for i in range(arr[0]):\n            if (r + a * i) % arr[2] == 0 and (c + b * i) % arr[3] == 0:\n                d += p\n            else:\n                d += arr[4]\n        if d == 0:\n            return 0\n        else:\n            return -1\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return stdout"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return minimum cost for knight to reach the goal at (0,0).\"\"\"\n    # Initialize.\n    cost = []\n\n    # Read lines.\n    n = int(stdin.readline())\n\n    # For each card.\n    for _ in range(n):\n        # Read line.\n        r, c, a, b, p = (int(n) for n in stdin.readline().split())\n        # Append cost.\n        cost.append((r, c, a, b, p))\n\n    # A dictionary to store all the costs of reaching a position.\n    cost_to_reach_position = {}\n\n    # Initialize the cost of reaching the position to infinity.\n    cost_to_reach_position[(0, 0)] = float('inf')\n\n    # A dictionary to store the cheapest cost of reaching a position.\n    cheapest_cost_to_reach_position = {}\n\n    # Return -1 if there is no way for the knight to reach the goal.\n    def calculate_cost(curr_cost, position):\n        \"\"\"Calculate the cost of reaching the current position.\"\"\"\n        # If the current position is the goal.\n        if position == (0, 0):\n            return curr_cost\n\n        # If the current position is not calculated.\n        if position not in cost_to_reach_position:\n            # For each card.\n            for card in cost:\n                # If the current position is the same position as the card.\n                if position == (card[0], card[1]):\n                    # If the current position has less cost than the card.\n                    if curr_cost < card[4]:\n                        # Calculate the cost of reaching the current position.\n                        cost_to_reach_position[position] = card[4] + calculate_cost(curr_cost, (card[0] + card[2], card[1] + card[3]))\n\n                    # If the current position has more cost than the card.\n                    else:\n                        # Calculate the cost of reaching the current position.\n                        cost_to_reach_position[position] = curr_cost + calculate_cost(card[4], (card[0] + card[2], card[1] + card[3]))\n\n            # If the current position is calculated.\n            if position in cost_to_reach_position:\n                # If the current position has more cost than the cheapest cost of reaching the current position.\n                if cost_to_reach_position[position] < cheapest_cost_to_reach_position[position]:\n                    # Save the cheapest cost of reaching the current position.\n                    cheapest_cost_to_reach_position[position] = cost_to_reach_position[position]\n\n        # Return the cheapest cost of reaching the current position.\n        return cheapest_cost_to_reach_position[position]\n\n    # Calculate the cheapest cost of reaching the goal.\n    calculate_cost(0, (0, 0))\n\n    # Return the cheapest cost of reaching the goal.\n    return -1 if cost_to_reach_position[(0, 0)] == float('inf') else cost_to_reach_position[(0, 0)]\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\n1 2 3 4 5\\n7 8 9 10\")\n    20\n    >>> solution(\"3\\n1 1 1 1 500\\n6 0 8 1 1\")\n    100\n    \"\"\"\n    N = int(stdin.readline())\n    cards = {\n        tuple(map(int, line.split()))\n        for line in stdin.read().strip().split(\"\\n\")\n    }\n    max_x, max_y, min_x, min_y = 0, 0, 0, 0\n    for r, c, a, b, p in cards:\n        if a:\n            if r - a < min_x:\n                min_x = r - a\n            if c - b < min_y:\n                min_y = c - b\n        if a < 0:\n            max_x = max(max_x, r + a)\n        if b < 0:\n            max_y = max(max_y, c + b)\n        if max_x <= min_x:\n            max_x = max(max_x, r)\n        if max_y <= min_y:\n            max_y = max(max_y, c)\n    ans = max_x + max_y + (p * max(abs(max_x - min_x), abs(max_y - min_y)))\n    return ans if ans < 10 ** 9 else -1\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a single integer denoting the minimum cost for the knight to reach the goal at $(0, 0)$.\n    If it is not possible, return the string -1.\n    \"\"\"\n    _, _, _, tarot_prices = [int(x) for x in stdin.split()]\n    tarot_info = [[int(x) for x in stdin.split()[:4]] for _ in range(tarot_prices)]\n    return str(min_cost(tarot_info))\n\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    \u89e3\u984c\u601d\u8def:\n    \"\"\"\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    cards = [list(map(int, line.split())) for line in lines[1:]]\n\n    dp = [[0] * n for _ in range(n)]\n    for r, c, a, b, price in cards:\n        dp[r - 1][c - 1] = (a, b, price)\n\n    m = len(dp)\n    n = len(dp[0])\n    if not cards or n == 0 or m == 0:\n        return -1\n\n    dp[0][0] = (0, 0, 0)\n    for i in range(m):\n        for j in range(n):\n            if i + 1 < m and j + 1 < n:\n                a, b, price = dp[i][j]\n                if a + 1 < m and b + 1 < n:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a + 1, b + 1, price + dp[i][j][2]))\n                if a - 1 >= 0 and b - 1 >= 0:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a - 1, b - 1, price + dp[i][j][2]))\n                if a - 1 >= 0:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a - 1, b, price + dp[i][j][2]))\n                if a + 1 < m:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a + 1, b, price + dp[i][j][2]))\n                if b - 1 >= 0:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a, b - 1, price + dp[i][j][2]))\n                if b + 1 < n:\n                    dp[i + 1][j + 1] = min(dp[i + 1][j + 1], (a, b + 1, price + dp[i][j][2]))\n\n    # print(dp)\n\n    if dp[m - 1][n - 1][0] == 0:\n        return -1\n\n    return dp[m - 1][n - 1][2]\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    import sys\n    import functools\n    \n    t = int(sys.stdin.readline())\n    prices = []\n    for _ in range(t):\n        prices.append(list(map(int, sys.stdin.readline().split())))\n        \n    dp = [[-1] * 10 ** 6 for _ in range(10 ** 6)]\n    dp[0][0] = 0\n    \n    @functools.lru_cache(None)\n    def solve(i, j):\n        for x, y, a, b in prices:\n            if not dp[i + a][j + b] == -1 and not dp[i][j] == -1:\n                dp[i + a][j + b] = min(dp[i + a][j + b], dp[i][j] + abs(a) + abs(b))\n                solve(i + a, j + b)\n        return dp[i][j]\n    \n    if not dp[0][0] == -1:\n        print(solve(0, 0))\n    else:\n        print(-1)\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    total, n = map(int, stdin.split('\\n')[:2])\n    cards = list(map(int, stdin.split('\\n')[2:]))\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for c in cards:\n        dp = [min(dp[max(0, i - c)], dp[i] + c) for i in range(n + 1)]\n        print(dp)\n\n    return -1 if dp[-1] == float('inf') else dp[-1]\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the value of the ByteCoin currency in Canadian dollars.\"\"\"\n    return str(len(list(filter(lambda x: int(x) % 3 == 0, stdin))))"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(n_subsets(stdin) % (10 ** 9 + 7))\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution to the problem 'SUM OF KRABS'\n    '''\n    pass\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = int(stdin.strip())\n    S = stdin.strip()\n    S = S[-1] + S[:-1]\n    n = len(S)\n    c = 0\n    for i in range(n):\n        for j in range(i, n):\n            if j - i == 1 or (j - i > 1 and S[i:j + 1].count('0') == 0 and (S[i:j + 1]) % 3 == 0):\n                c += 1\n    return c\n\nprint(solution(input()))\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for i in range(0, len(stdin)):\n        s = stdin[i:]\n        if(s == '0'):\n            break\n        if(s == '1'):\n            count += 1\n        if(s[0]!= '0'):\n            s = int(s)\n            s_len = len(str(s))\n            s_str = str(s)\n            for j in range(s_len - 1, -1, -1):\n                if(s_str[j]!= '0'):\n                    break\n            if((s // (10 ** j) % 3)!= 0):\n                continue\n            count += 1\n    return count\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return str(s)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    n = int(input[0])\n    S = input[1]\n    unique_nums = set()\n    while len(unique_nums) < n:\n        for i in range(n):\n            unique_nums.add(S[i::])\n    return len(unique_nums)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Please don't modify the input and output format.\n    # You are given the description of the result from the standard input.\n    # If you don't know how to read the input, please find relevant material in the Resources tab.\n    # If you really like to do the extra challenge, you can try to implement the required logic.\n\n    # Read the input string\n    # string = input()\n\n    # Get the result of the input string\n    # result = solution(string)\n\n    # Output the result\n    # print(result)\n    # Write your code here\n    string = stdin\n    b = len(string)\n    # print(b)\n    s = int(string)\n    # print(s)\n    # print(type(s))\n    # print(s%3)\n    # print(s//3)\n    # print(type(s//3))\n    # print(s%3)\n    # print(s%3==0)\n    count = 0\n    while s%3==0:\n        count+=1\n        s = s//3\n    # print(count)\n    # print(type(count))\n    return count\n\n    # Write your code here\n    # pass"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given an input string representing an integer,\n    find the number of valid subsets in the input string.\n\n    Args:\n        stdin (str): Input string to process.\n\n    Returns:\n        str: Solution to the problem.\n    \"\"\"\n\n    return (\n        str(\n            (\n                sum(\n                    [\n                        1\n                        for subset in [\n                            str(i) for i in range(1, int(stdin) + 1)\n                        ]\n                        if len(subset) % 3 == 0 and not subset[0] == \"0\"\n                        and sum(int(digit) for digit in subset) % 3 == 0\n                    ]\n                )\n                % (10 ** 9 + 7)\n            )\n        )\n    )\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the problem'''\n    n, g = map(int, stdin.split('\\n')[0].split())\n    dist, price = [], []\n    for i in range(n):\n        d, p = map(int, stdin.split('\\n')[i + 1].split())\n        dist.append(d)\n        price.append(p)\n    dist.sort()\n    for i in range(n):\n        g -= price[i] * (dist[i] - i)\n        if g <= 0:\n            return i\n    return 'cancel road trip'\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # get the data from stdin\n    n, g = [int(x) for x in stdin.split()]\n    d = [int(x) for x in stdin.split()]\n    c = [int(x) for x in stdin.split()]\n    # write your code here\n    ans = float('inf')\n    for i in range(n):\n        if i < n-1:\n            ans = min(ans, (d[i+1]-d[i]) * c[i])\n        else:\n            ans = min(ans, g-d[i])\n    if ans > g:\n        return \"cancel road trip\"\n    else:\n        return ans\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, g = list(map(int, stdin.split()))\n    gas_stations = []\n    for _ in range(n):\n        gas_stations.append(tuple(map(int, stdin.split())))\n    if g >= gas_stations[0][0] * gas_stations[0][1]:\n        return 'cancel road trip'\n    for i in range(1, len(gas_stations)):\n        if g < gas_stations[i][0] * gas_stations[i][1]:\n            continue\n        elif g >= gas_stations[i][0] * gas_stations[i][1]:\n            g -= gas_stations[i - 1][0] * gas_stations[i - 1][1]\n        else:\n            return 'cancel road trip'\n    return g\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, g = list(map(int, stdin.split()))\n    arr = []\n    for i in range(n):\n        arr.append(list(map(int, stdin.split())))\n    arr.sort(key=lambda x: x[0])\n    m = 0\n    for i in range(n):\n        m += arr[i][1]\n        if m > g:\n            return \"cancel road trip\"\n    return m"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum cost for the trip\n\n    Parameters\n    ----------\n    stdin : str\n        The standard input of the test\n\n    Returns\n    -------\n    str\n        The minimum cost for the trip\n    \"\"\"\n    # Get the input\n    n, g = (int(n) for n in stdin.split())\n    station = [int(n) for n in stdin.split()]\n\n    # Initialize an array with the next station to travel to\n    next_stations = [n for n in station]\n    next_stations.append(float('inf'))\n\n    # Initialize an array with the cost to travel to each station\n    costs = [float('inf') for _ in range(n + 1)]\n    costs[0] = 0\n    costs[1] = 0\n    for i in range(n):\n        station = next_stations[i]\n        cost = costs[i]\n        for j in range(station, n + 1):\n            cost = min(cost, costs[i] + (j - i) * station)\n        costs[j] = cost\n\n    # Check if the cost of the trip is less than the total gas\n    return min(costs[-1], g) if costs[-1] <= g else 'cancel road trip'\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    gas_stations: list[tuple[int, int]] = []\n    gas_stations.append(tuple([0, 0]))\n    for _ in range(int(stdin[0])):\n        gas_stations.append(tuple(map(int, stdin[1 + _].split())))\n    gas_stations.append(tuple([0, 0]))\n\n    cur_cost = 0\n    min_cost = 0\n    distance = 0\n    for _ in range(int(stdin[0]) + 1):\n        distance += gas_stations[_][0] - gas_stations[_][1]\n        min_cost = min(min_cost, gas_stations[_][1])\n        if distance > int(stdin[0]):\n            return 'cancel road trip'\n        if distance < 0:\n            cur_cost += (abs(distance) // int(stdin[0])) * gas_stations[_][1]\n            distance = abs(distance) % int(stdin[0])\n            distance += gas_stations[_][0] - gas_stations[_][1]\n            if distance < 0:\n                return 'cancel road trip'\n        else:\n            cur_cost += (distance // int(stdin[0])) * gas_stations[_][1]\n            distance = distance % int(stdin[0])\n            distance += gas_stations[_][0] - gas_stations[_][1]\n            if distance < 0:\n                return 'cancel road trip'\n\n    return cur_cost"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_stations, fuel_tank_size = stdin.split(maxsplit=1)\n    num_stations = int(num_stations)\n    fuel_tank_size = int(fuel_tank_size)\n    num_stations_list = []\n    for i in range(num_stations):\n        d, c = stdin.split(maxsplit=1)\n        num_stations_list.append((int(d), int(c)))\n    num_stations_list.sort()\n    min_cost = 0\n    for i in range(num_stations):\n        if fuel_tank_size >= num_stations_list[i][0]:\n            fuel_tank_size -= num_stations_list[i][0]\n            min_cost += num_stations_list[i][1] * num_stations_list[i][0]\n        else:\n            break\n    if min_cost == 0:\n        return \"cancel road trip\"\n    else:\n        return min_cost"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(1)\n    \"\"\"\n    # Set initial values\n    n, g = map(int, stdin.split())\n    dist, cost = [], []\n    for i in range(n):\n        d, c = map(int, stdin.split())\n        dist.append(d)\n        cost.append(c)\n    if n == 1:\n        return dist[0] * cost[0]\n    # Initialize starting index and min_cost\n    i, min_cost = 0, dist[0] * cost[0]\n    # Iterate over all gas stations\n    for j in range(1, n):\n        # Calculate the cost of the remaining gas at the current station\n        min_cost = min(min_cost, dist[j] * cost[j])\n        # Check whether the current station's cost is greater than the tank's capacity\n        if min_cost > g:\n            return \"cancel road trip\"\n        # Find the lowest cost of refueling until the end\n        while i < j and min_cost > g:\n            min_cost -= dist[i] * cost[i]\n            i += 1\n    # Return the lowest cost of refueling\n    return min_cost\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, g = map(int, stdin.split(' '))\n    arr = [0]\n    for _ in range(n):\n        d, c = map(int, stdin.split(' '))\n        arr.append(c)\n    arr.append(0)\n    dp = [0] * (n + 1)\n    for i in range(n):\n        dp[i] = max(dp[i], dp[i - 1] + arr[i])\n        for j in range(i + 1, n + 1):\n            dp[j] = min(dp[j], dp[i] + arr[j])\n            if dp[j] >= g:\n                return i + 1\n    return 'cancel road trip'"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def isPossible(gstn: list) -> bool:\n        total = 0\n        for i in gstn:\n            total += i[1]\n            if total > g:\n                return False\n        return True\n    g, gstn = map(int, stdin.split())\n    gstn.sort()\n    if gstn[-1][1] > g:\n        return 'cancel road trip'\n    gstn.insert(0, [0, gstn[0][1]])\n    gstn.append([g, 0])\n    for i in range(1, len(gstn)):\n        gstn[i][1] = gstn[i][1] - gstn[i-1][1]\n    for i in range(1, len(gstn)):\n        if gstn[i][0] - gstn[i-1][0] > gstn[i][1]:\n            return 'cancel road trip'\n    gstn.insert(0, [0, 0])\n    gstn.append([g, 0])\n    gstn.sort()\n    for i in range(1, len(gstn)):\n        gstn[i][1] = gstn[i][1] - gstn[i-1][1]\n    gstn.insert(0, [0, 0])\n    gstn.append([g, 0])\n    return min([i[1] for i in gstn if i[1] > 0])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    jewel_value = []\n    for i in range(n):\n        jewel_value.append(list(map(int, stdin.readline().split())))\n    jewel_value.sort(key=lambda x: x[0])\n    jewel_value.sort(key=lambda x: x[1], reverse=True)\n    jewels = [i[0] for i in jewel_value]\n    jewels = list(map(int, jewels))\n    jewels.append(0)\n    dp = []\n    for _ in range(k + 1):\n        dp.append([0] * (n + 1))\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - 1 < 0:\n                dp[j][i] = 0\n                continue\n            if jewel_value[i - 1][0] <= j:\n                dp[j][i] = max(jewels[i] + dp[j - jewel_value[i - 1][0]][i - 1], dp[j][i - 1])\n            else:\n                dp[j][i] = dp[j][i - 1]\n    ans = []\n    for i in range(1, k + 1):\n        ans.append(dp[i][n])\n    return''.join(list(map(str, ans)))\nprint(solution(stdin))\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 9\\n2 8\\n1 1\\n3 4\\n5 100\")\n    '1 8 9 9 100 101 108 109 109'\n    \"\"\"\n   ..."
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, k = list(map(int, lines[0].split()))\n    sizes = []\n    values = []\n    for i in range(1, n + 1):\n        size, value = list(map(int, lines[i].split()))\n        sizes.append(size)\n        values.append(value)\n\n    output = [0 for _ in range(k + 1)]\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if sizes[i] <= j:\n                output[j] = max(output[j], values[i] + output[j - sizes[i]])\n\n    return''.join([str(x) for x in output[1:]])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = []\n    for _ in range(n):\n        jewels.append(list(map(int, stdin.split())))\n    return''.join([str(max(n if sum(jewels[i]) <= s else 0 for n in range(k+1))) for i, s in enumerate(range(1, k+1))])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdin"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # get num of jewels and knapsack size\n    jewels, knapsack = [int(x) for x in stdin.strip().split()]\n    # get max values of jewels by size\n    max_values = [0] * knapsack\n    for _ in range(jewels):\n        jewel_size, jewel_value = [int(x) for x in stdin.strip().split()]\n        max_values[jewel_size - 1] = max(max_values[jewel_size - 1], jewel_value)\n    # return max value\n    return \" \".join([str(x) for x in max_values])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"1 3 3\n   ... 0 0 1\n   ... 3 3\n   ... -3 3\n   ... 3 -3\n   ... 3 0\n   ... 0 3\n   ... \"\"\")\n    '1'\n    \"\"\"\n    number_of_villages, number_of_minions, max_radius = map(int, stdin.split())\n    village_points = [None] * number_of_villages\n    village_radius = [None] * number_of_villages\n    minions = [None] * number_of_minions\n    for village in range(number_of_villages):\n        village_points[village], village_radius[village] = map(int, stdin.split())\n    for minion in range(number_of_minions):\n        minions[minion] = list(map(int, stdin.split()))\n    minions.sort(key=lambda minion: minion[1], reverse=True)\n    for minion in minions:\n        minion_point, minion_radius = minion\n        for village in range(number_of_villages):\n            village_point, village_radius = village_points[village], village_radius[village]\n            if (village_point == minion_point) or (abs(village_point - minion_point) > (village_radius + minion_radius)):\n                village_points[village], village_radius[village] = None, None\n                break\n    village_points.sort(key=lambda village: village[0])\n    villages_destroyed = 0\n    for village in village_points:\n        if village is not None:\n            villages_destroyed += 1\n    return str(villages_destroyed)\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_pos(x: int, y: int) -> str:\n        return f\"({x} {y})\"\n\n    def is_intersect(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int, x4: int, y4: int) -> bool:\n        if (x2 - x1) * (y4 - y3) == (x4 - x3) * (y2 - y1):\n            return False\n        return not ((x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3) > 0)\n\n    n, m, r = map(int, stdin.split())\n\n    xs, ys, rs = set(), set(), set()\n    for i in range(n):\n        x, y, r_ = map(int, stdin.split())\n        xs.add(x)\n        ys.add(y)\n        rs.add(r_)\n\n    xs, ys, rs = list(xs), list(ys), list(rs)\n    xs.sort()\n    ys.sort()\n    rs.sort()\n\n    mx, my = int(stdin.split()[1]), int(stdin.split()[2])\n    mx, my = mx - 20000, my - 20000\n\n    ans = 0\n    for r_ in rs:\n        x, y = mx, my\n        while (x >= -20000 and x <= 20000) and (y >= -20000 and y <= 20000):\n            x_, y_ = x, y\n            for x_p in xs:\n                if is_intersect(x, y, x_p, y_, x_, y_, x_p, y_):\n                    break\n            else:\n                ans += 1\n            x += 1\n        y += 1\n\n    return ans\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return 'hello'\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve problem.\"\"\"\n    n, m, r = map(int, stdin.split())\n    vx, vy, vr = [0] * n, [0] * n, [0] * n\n\n    for i in range(n):\n        vx[i], vy[i], vr[i] = map(int, stdin.split()[i * 3 : i * 3 + 3])\n\n    mx, my = [0] * m, [0] * m\n\n    for i in range(m):\n        mx[i], my[i] = map(int, stdin.split()[i * 2 : i * 2 + 2])\n\n    max_dist = 0\n    for i in range(m):\n        max_dist = max(max_dist, math.sqrt((mx[i] - vx[i]) ** 2 + (my[i] - vy[i]) ** 2))\n\n    return m if max_dist > r else m - 1\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_circle(center, radius, max_radius):\n        x, y, r = center\n        return (x - radius, y - radius, r + radius)\n\n    def count_nodes(node, nodes):\n        # dfs\n        if node not in nodes:\n            return 0\n        nodes.remove(node)\n        cnt = 1\n        for nx, ny in neighbours(node):\n            cnt += count_nodes((nx, ny), nodes)\n        return cnt\n\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n    for i in range(n):\n        x, y, r = map(int, stdin.split())\n        villages.append(get_circle(x, y, r))\n    for j in range(m):\n        x, y = map(int, stdin.split())\n        minions.append((x, y))\n    max_circle = 0\n    for c in villages:\n        max_circle = max(max_circle, count_nodes(c, set(minions)))\n    return max_circle\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(nm)\n    Space Complexity: O(n)\n    \"\"\"\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n    for _ in range(n):\n        vx, vy, vr = map(int, stdin.split())\n        villages.append((vx, vy, vr))\n    for _ in range(m):\n        mx, my = map(int, stdin.split())\n        minions.append((mx, my))\n\n    max_minions = 0\n    for village in villages:\n        village_minions = 0\n        for minion in minions:\n            dist = math.sqrt((village[0] - minion[0]) ** 2 + (village[1] - minion[1]) ** 2)\n            if dist <= village[2] and dist >= 0:\n                village_minions += 1\n        if village_minions > max_minions:\n            max_minions = village_minions\n\n    return max_minions\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the maximum number of minions that can be destroyed in a single attack'''\n    # Get input\n    n, m, r = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    # Define lists\n    villages = []\n    minions = []\n    # Loop through input and define lists\n    for i in range(n):\n        villages.append([int(j) for j in stdin.split('\\n')[i+1].split(' ')])\n    for i in range(m):\n        minions.append([int(j) for j in stdin.split('\\n')[i+n+1].split(' ')])\n    # Define distance function\n    def distance(x1, y1, x2, y2):\n        '''Returns distance between two points'''\n        return ((x2-x1)**2 + (y2-y1)**2)**(1/2)\n    # Define circle intersection function\n    def circle_intersection(x1, y1, r1, x2, y2, r2):\n        '''Returns whether two circles intersect'''\n        d = distance(x1, y1, x2, y2)\n        return d <= r1 + r2\n    # Define points of circle function\n    def circle_points(x1, y1, r1):\n        '''Returns list of points on circle'''\n        circle = []\n        # Loop through x and y\n        for i in range(-r1, r1+1):\n            for j in range(-r1, r1+1):\n                if i**2 + j**2 <= r1**2:\n                    circle.append((i+x1, j+y1))\n        return circle\n    # Define function to find the number of minions that can be hit\n    def minion_count(villages, minions, r):\n        '''Returns the number of minions that can be hit in a given attack'''\n        # Define variables\n        minions_hit = 0\n        # Loop through all villages\n        for i in range(len(villages)):\n            # Define variables for new circle\n            x, y, r = villages[i]\n            # Define variables for old circle\n            x1, y1, r1 = r, r, r\n            # Define variable for circle intersections\n            intersections = []\n            # Define variables for checking intersections\n            start = True\n            # Loop through all minions\n            for j in range(len(minions)):\n                # Define variables for new circle\n                x2, y2, r2 = minions[j]\n                # Define variables for old circle\n                x3, y3, r3 = x2, y2, r2\n                # Define variable for circle intersections\n                intersection = False\n                # Loop through all circle points\n                for k in range(len(circle_points(x1, y1, r1))):\n                    # Define variable for circle intersections\n                    intersection = circle_intersection(x1, y1, r1, x3, y3, r3)\n                    # If the circle intersection is true, break\n                    if intersection == True:\n                        break\n                # If circle intersection is true, update the intersection list\n                if intersection == True:\n                    intersections.append(j)\n            # Remove the minions that have been hit\n            for j in range(len(intersections)):\n                del minions[intersections[j]]\n            # Add the minions that have not been hit\n            minions_hit += len(minions)\n        # Return the total minions hit\n        return minions_hit\n    # Return the maximum minions that can be hit\n    return max(minion_count(villages, minions, r), minion_count(villages, minions, r-1), minion_count(villages, minions, r-2))\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the string soln,\n    where soln is the solution to this problem.\n    \"\"\"\n    # Your solution here.\n    return soln\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an iterable of the longest interesting subsequence at each position in the input.\"\"\"\n    pass\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds longest interesting subsequence\n    :param stdin: the input string\n    :return: the output string\n    \"\"\"\n    num, total = map(int, stdin.split())\n    num_list = list(map(int, stdin.split()))\n    sub_list = []\n    for i in range(num):\n        sub_list.append(num_list[i])\n        sum_list = sum(sub_list)\n        if sum_list > total:\n            break\n    sub_list.pop()\n    sub_list.pop(0)\n    sub_list.sort(reverse=True)\n    for i in range(len(sub_list)):\n        if sub_list[i] < sub_list[i + 1]:\n            sub_list[i] = sub_list[i + 1] - sub_list[i]\n        else:\n            sub_list[i] = 0\n    sub_list.sort()\n    sub_list.pop()\n    for i in range(len(sub_list)):\n        if sub_list[i] < sub_list[i + 1]:\n            sub_list[i] = sub_list[i + 1] - sub_list[i]\n        else:\n            sub_list[i] = 0\n    return''.join(map(str, sub_list))\n\n\ndef"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution template.\"\"\"\n    pass\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_test_cases, _ = map(int, stdin.split())\n    n_s_list = [None] * num_test_cases\n    for i in range(num_test_cases):\n        n_s_list[i] = list(map(int, stdin.split()))\n    for n_s in n_s_list:\n        n, s = n_s\n        print(find_subsequence_lengths(n, s))\n    return ''\n\ndef"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A sequence is interesting if it is not decreasing\n    \"\"\"\n    num_of_elem = int(stdin.readline().strip())\n    target = int(stdin.readline().strip())\n    numbers = [int(elem) for elem in stdin.readlines()]\n\n    longest_elem = 0\n    longest_count = 0\n    for i in range(num_of_elem):\n        for j in range(i, num_of_elem):\n            if j > i:\n                if sum(numbers[i:j]) <= target:\n                    if sum(numbers[j:]) <= target:\n                        longest_elem = j-i\n                        longest_count += 1\n    return longest_count\n    \n        \nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = [int(i) for i in stdin.split()]\n    # dp = [0]*n\n    dp = [0]*(s+1)\n    for i in range(n):\n        for j in range(s, -1, -1):\n            if j >= a[i]:\n                dp[j] = max(dp[j], dp[j-a[i]]+1)\n    print(dp)\n    return '\\n'.join(map(str, dp))\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # 1. Read the input\n    n, s = [int(x) for x in stdin.split(' ')]\n    A = [int(x) for x in stdin.split('\\n')[1:]]\n\n    # 2. Check if the number of elements is less than 3\n    if n < 3:\n        return 0\n\n    # 3. Check if the sum of the first 3 elements is less than the sum of the last 3 elements\n    if sum(A[0:3]) <= sum(A[-3:]):\n        return 0\n\n    # 4. Solve the problem and return the result\n    result = 0\n    for i in range(0, n):\n        if sum(A[i:i + 3]) <= s:\n            result = 3\n        else:\n            if sum(A[i:i + 3]) >= s:\n                result = 1\n            else:\n                result = 2\n    return result\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the string in filehandle, `stdin`, with trailing whitespace removed.\"\"\"\n    pass\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split('\\n')[0].split())\n    arr = [int(stdin.split('\\n')[i]) for i in range(1, n + 1)]\n    sums = [sum(arr[0:i + 1]) for i in range(n)]\n    sums.append(sum(arr[n - 1:]))\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if (sums[i] <= s and sums[j] <= s) or (sums[i] <= s and s < sums[j] <= s + sums[i]):\n                res = max(res, j - i)\n    return res\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    letters = stdin.split('\\n')[0]\n    print(letters)\n    if N == 1:\n        print(\"DA\")\n        return\n    if N % 2!= 0:\n        print(\"DA\")\n        return\n    i = 0\n    j = N // 2\n    cur = letters[i]\n    while i < N // 2:\n        print(letters)\n        if cur > letters[j]:\n            print(cur)\n            print(letters[j])\n            cur = letters[j]\n            i += 1\n            j -= 1\n        else:\n            j -= 1\n        if i == j:\n            print(\"NE\")\n            return\n    print(cur)\n\n\ndef"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"DA\"\n    else:\n        n = n - 1\n        if n % 2 == 1:\n            return \"DA\"\n        else:\n            return \"NE\""
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    letters = list(stdin)\n    result = 'DA'\n    for i in range(n):\n        for j in range(n):\n            if j >= n - i - 1:\n                letters.pop(j)\n                break\n        result = letters[-1] + result\n        letters.pop(0)\n    return result\n\ndef"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N: int = int(stdin)\n    S: str = stdin\n    ans: str = \"\"\n    s: str = \"\"\n    if N % 2 == 0:\n        ans = \"NE\"\n        s = \"ne\"\n    else:\n        ans = \"DA\"\n        s = \"da\"\n    count: int = 0\n    for c in S:\n        if count % 2 == 0:\n            s += c\n        else:\n            s = c + s\n        count += 1\n    if ans == \"DA\":\n        ans = s[N:]\n    else:\n        ans = s[:N]\n    return ans\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin.readline())\n    s: str = stdin.readline().strip()\n    \n    stdin_list: list = list(s)\n    stdin_list.reverse()\n    stdin_list = stdin_list[:-1]\n    \n    stdin_list = [x for x in stdin_list if x not in [\"a\", \"e\", \"i\", \"o\", \"u\"]]\n    stdin_list.reverse()\n    \n    for i in range(len(stdin_list)):\n        stdin_list[i] = stdin_list[i][::-1]\n    \n    stdin_list = \"\".join(stdin_list)\n    \n    stdin_list = list(stdin_list)\n    stdin_list.reverse()\n    \n    max_length: int = -1\n    max_str: str = \"\"\n    for i in range(len(stdin_list)):\n        j: int = 0\n        while j < len(stdin_list):\n            k: str = stdin_list[j]\n            temp_str: str = stdin_list[j]\n            for x in range(1, n):\n                temp_str += k\n                j += 1\n                if temp_str == stdin_list[0:n]:\n                    if len(temp_str) > max_length:\n                        max_str = temp_str\n                    elif max_length == -1:\n                        max_str = temp_str\n    \n    if max_str == \"\":\n        max_str = \"DA\"\n    else:\n        max_str = max_str[::-1]\n    \n    return max_str"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    letters = stdin\n    count = len(letters)\n    ans = 0\n    while count > 0:\n        if count % 2 == 1:\n            ans += 1\n        count //= 2\n    if ans % 2 == 1:\n        return 'DA'\n    else:\n        return 'NE'\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the best word for Slavko to use.\n    >>> solution('4\\nea')\n    'DA'\n    >>> solution('2\\ncd')\n    'NE'\n    >>> solution('4\\nab')\n    'DA'\n    \"\"\"\n    return max(stdin.split('\\n'), key=lambda word: sorted(word))\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n\nn = int(stdin.readline().strip())\n\nword = stdin.readline().strip()"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    letters = stdin.readline().strip()\n    words = []\n    for i in range(n):\n        for j in range(i, n):\n            word = letters[i:j+1]\n            words.append(word)\n    words.sort()\n    ans = [words[-1], words[0]]\n    return 'DA' if ans[0] > ans[1] else 'NE'"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')[1:]\n    m, n = len(words[0]), len(words[1])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1\n    for j in range(1, n + 1):\n        dp[0][j] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if words[0][i - 1] == words[1][j - 1]:\n                dp[i][j] += dp[i - 1][j - 1]\n    return 'DA' if dp[m][n] else 'NE'"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the solution.\n\n    Args:\n        stdin (str): The standard input.\n\n    Returns:\n        str: The solution.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the number of ways to stock the snack stands for each query.\n    >>> solution('4 4 4\\n1 2\\n1 3\\n2 4\\n3 4\\n1 1 4\\n2 1 4\\n1 1 3\\n2 2 3 2\\n')\n    '2\\n0\\n2\\n1\\n'\n    >>> solution('8 10 4\\n1 2\\n2 3\\n1 3\\n3 6\\n6 8\\n2 4\\n2 5\\n4 7\\n5 7\\n7 8\\n2 3 4 5 6\\n2 2 6 8\\n1 1 6\\n1 1 8\\n')\n    '0\\n0\\n3\\n2\\n'\n    \"\"\"\n   ..."
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string as the solution\"\"\"\n    # Put your solution here\n    return ''\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n) / O(n)\"\"\"\n    n, m, q = map(int, stdin.split())\n    graph = {}\n\n    for _ in range(m):\n        s, t = map(int, stdin.split())\n        if s not in graph:\n            graph[s] = set()\n        if t not in graph:\n            graph[t] = set()\n        graph[s].add(t)\n\n    ans = []\n    for _ in range(q):\n        k, *a = map(int, stdin.split())\n        options = set()\n        for area in a:\n            options.update(graph[area])\n        ans.append(len(options) - k + 1)\n\n    return '\\n'.join(map(str, ans))\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an integer representing the number of possible configurations\n    of the snack stands.\n\n    Parameters:\n    stdin (str): Input string\n\n    Returns:\n    int: An integer representing the number of possible configurations\n    \"\"\"\n    # Parse input\n    n, m, q = [int(x) for x in stdin.split(' ')]\n    data = []\n    for i in range(m):\n        data.append([int(x) for x in stdin.split('\\n')[i].split(' ')])\n\n    # Run algorithm\n    from collections import defaultdict\n    from math import factorial as fact\n    counts = defaultdict(lambda: 0)\n    for i in range(q):\n        k, a = [int(x) for x in stdin.split('\\n')[i + m].split(' ')]\n        for j in range(a):\n            counts[data[i][j]] += fact(n - 1) / (fact(a - 1) * fact(n - a))\n    \n    # Return result\n    return '\\n'.join(list(map(str, counts.values())))"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    BFS\n    \"\"\"\n    n, m, q = map(int, stdin.split())\n    G = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        G[y].append(x)\n    for _ in range(q):\n        k, *a = map(int, stdin.readline().split())\n        bfs = [1] + [0] * n\n        for i in a:\n            for j in G[i]:\n                bfs[j] += bfs[i]\n        print(bfs[1:])\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution of the problem.\"\"\"\n    pass  # pylint: disable=unnecessary-pass\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for the first puzzle of day 6, of input I provided.\n\n    Parameters\n    ----------\n    stdin : str\n        Input that is read from stdin\n\n    Returns\n    -------\n    str\n        The solution to the first puzzle\n    \"\"\"\n    n, m, q = map(int, stdin.split())\n    a = [map(int, stdin.split()) for _ in range(m)]\n    c = Counter([i[0] for i in a])\n    b = Counter(i[0] for i in a)\n    d = Counter(i[1] for i in a)\n    q = [map(int, stdin.split()) for _ in range(q)]\n    res = [0] * q[0][1]\n    res[0] = 1 if c[q[0][0]] == 1 else 0\n    res[1] = sum(b.values())\n    for i in range(2, q[0][1]):\n        res[i] = sum([min(c.values()) for i in d])\n    for i in range(2, q[0][1]):\n        if i == 1:\n            continue\n        if res[i-1] == 0:\n            continue\n        for j in range(1, n+1):\n            if j not in d or i not in d[j]:\n                continue\n            res[i] += res[i-1]\n    return \"\\n\".join(map(str, res))\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of ways to select snack stands to stock\n    for each query, in the order that they appear in the input.\n    \"\"\"\n    return 0\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, n = stdin.split(' ')\n    n = int(n)\n    flights = [list(map(int, line.split(' '))) for line in stdin.split('\\n')[1:]]\n    flight_pair = sorted([(f[0], f[1], f[2]) for f in flights])\n    last_dep = flight_pair[0][0]\n    last_arr = flight_pair[0][1]\n    flight_time = flight_pair[0][2]\n    for (dep, arr, time) in flight_pair:\n        if dep < last_arr:\n            flight_time += (last_arr - dep)\n        if arr > last_dep:\n            flight_time += (arr - last_dep)\n        last_arr = arr\n        last_dep = dep\n    flight_time += (n - last_dep)\n    print(flight_time)"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    min_time = [0] * (n + 1)\n    max_time = [0] * (n + 1)\n    # build min time\n    for line in stdin.split('\\n')[1:n + 1]:\n        time = [int(x) for x in line.split()]\n        min_time[time[0]] = time[1]\n    # build max time\n    for line in stdin.split('\\n')[n + 1:]:\n        time = [int(x) for x in line.split()]\n        max_time[time[0]] = time[2]\n\n    dep = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dep[i] = max(dep[i - 1], min_time[i]) + max_time[i]\n\n    print(dep)\n    return\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    n, m = list(map(int, stdin.split(' ')))\n    arr = [0] * n\n    time = list(map(int, stdin.split('\\n')[1:]))\n\n    for i in time:\n        arr[i - 1] = i\n    \n    arr.sort()\n    cnt = 0\n    for i in arr:\n        if i!= 0:\n            cnt += 1\n    return cnt"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def print_output(n: int, m: int, airports: list) -> None:\n        cost = [float('inf') for _ in range(n)]\n        cost[0] = 0\n        for airport in airports:\n            cost[airport[0]] = airport[1]\n        for _ in range(m):\n            start, end, time = [int(x) for x in stdin.readline().split()]\n            cost[start] += time\n            cost[end] -= time\n        cost[0] = 0\n        print(cost.index(min(cost)))\n\n    n, m = [int(x) for x in stdin.readline().split()]\n    airports = []\n    for _ in range(n):\n        airports.append([int(x) for x in stdin.readline().split()])\n    print_output(n, m, airports)\n\n    return 'Hello'\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(\" \"))\n    flights = {}\n    for i in range(n):\n        flights[i + 1] = list(map(int, stdin.split(\" \")))\n    flights = {i: j for i, j in flights.items() if j[0]!= 0}\n\n    for j in range(m):\n        s, f, t = map(int, stdin.split(\" \"))\n        flights[s].append([f, t])\n        flights[f].append([s, 0])\n\n    for i in range(1, n + 1):\n        flights[i] = [j for j in flights[i] if j[1]!= 0]\n\n    print(flights)\n\n    for key in flights.keys():\n        if len(flights[key]) == 0:\n            continue\n        else:\n            for j in range(len(flights[key]) - 1):\n                for k in range(j + 1, len(flights[key])):\n                    flights[key][j][1] = min(flights[key][j][1], flights[key][k][1] + flights[key][j][0])\n                    flights[key][k][1] = min(flights[key][j][1], flights[key][k][1] + flights[key][j][0])\n\n    print(flights)\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of planes necessary to \n    meet demand.\n    \"\"\"\n    \n    # Read stdin\n    n, m = tuple(map(int, stdin.readline().split()))\n    departures = [0 for _ in range(n)]\n    for flight in stdin.readlines():\n        s, f, t = tuple(map(int, flight.split()))\n        departures[s] += 1\n        departures[f] -= 1\n        if departures[s] > 0:\n            departures[f] += departures[s]\n            departures[s] = 0\n\n    return max(departures)\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    min_inspection_time = [0] * n\n    for i in range(m):\n        start, end, time = map(int, stdin.split(' '))\n        min_inspection_time[start - 1] += time\n        min_inspection_time[end - 1] += time\n    min_inspection_time = min_inspection_time[::-1]\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if min_inspection_time[i] + min_inspection_time[j] > min_inspection_time[n - 1]:\n                res += 1\n    return res"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the maximum total tastiness of a meal of weight $w$ based on the\n    available dishes.\n    \"\"\"\n    # Initialize total tastiness and weight of each dish\n    tastiness = 0\n    weight = 0\n    # Loop through each line in the input\n    for line in stdin.split(\"\\n\"):\n        # If the dish is discrete, add it to the total tastiness and weight of\n        # each dish\n        if line.startswith(\"D\"):\n            parts = line.split(\" \")\n            weight += int(parts[1])\n            tastiness += int(parts[2])\n        # If the dish is continuous, add it to the total weight of the dish\n        elif line.startswith(\"C\"):\n            parts = line.split(\" \")\n            weight += int(parts[1])\n        else:\n            assert False, f\"Unknown dish type: {line}\"\n    # If the weight of the meal is less than the available weight of the dish,\n    # the maximum total tastiness is the tastiness of each dish\n    if weight < weight:\n        return str(tastiness)\n    # Else, the maximum total tastiness is the sum of each discrete dish's\n    # initial tastiness times the number of discrete dishes and each continuous\n    # dish's initial tastiness times the number of continuous dishes\n    else:\n        tastiness += sum([tastiness * i for i in range(1, weight + 1)])\n        tastiness += sum([weight * i for i in range(1, weight + 1)])\n        return str(tastiness)\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum possible tastiness for a meal of a given weight.\n    \"\"\"\n    dishes, weight = [line.split() for line in stdin.split('\\n')]\n    dishes, weight = list(map(int, dishes)), int(weight[0])\n    tastiness = 0\n    for dish in dishes:\n        if dish[0] == 'D':\n            dish, weight, tastiness = dish[1:], dish[1], dish[2]\n        else:\n            dish, weight, tastiness = dish[1:], dish[1], dish[2], dish[3]\n        tastiness *= weight\n    return tastiness\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # get input\n    n, w = [int(i) for i in stdin.split(' ')]\n    d = {}\n    c = {}\n    for i in range(n):\n        x, t, dt = stdin.split(' ')\n        if x == 'D':\n            x = 1\n        elif x == 'C':\n            x = 0\n        else:\n            raise Exception('Invalid input')\n        t, dt = int(t), int(dt)\n        d[i] = (t, dt)\n        c[i] = x\n    # d: {0: (4, 10), 1: (6, 1)}\n    # c: {0: 1, 1: 0}\n\n    # print(d)\n    # print(c)\n\n    # for x in d:\n    #     print(d[x][0] * c[x], d[x][1] * c[x])\n    #\n    # print(d[0][0] * c[0] + d[0][1] * c[0])\n    # print(d[1][0] * c[1] + d[1][1] * c[1])\n    # print(d[1][0] * c[1] + d[1][1] * c[1] + d[0][0] * c[0] + d[0][1] * c[0])\n    # print(d[1][0] * c[1] + d[1][1] * c[1] + d[0][0] * c[0] + d[0][1] * c[0] + d[0][0] * c[0] + d[0][1] * c[0] + d[0][0] * c[0])\n\n    # print(d[0][0] + d[1][0] + d[0][0] + d[1][1])\n    # print(d[0][0] + d[1][0] + d[0][0] + d[1][1] + d[0][1])\n    # print(d[0][0] + d[1][0] + d[0][0] + d[1][1] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1])\n    # print(d[0][0] + d[1][0] + d[0][0] + d[1][1] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1])\n\n    # print(d[0][0] + d[1][0] + d[0][0] + d[1][1] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d[0][0] + d[0][1] + d["
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the maximum possible total tastiness from the available dishes.\n\n    Args:\n        stdin (str): The input string from stdin.\n\n    Returns:\n        str: The solution output.\n    \"\"\"\n    num_dishes, total_weight = stdin.split(\" \")\n    dishes = []\n    for dish in stdin.split(\"\\n\")[1:]:\n        if dish.startswith(\"D\"):\n            dish = dish.split(\" \")\n            dishes.append(\n                {\n                    \"weight\": int(dish[1]),\n                    \"tastiness\": int(dish[2]),\n                    \"decay\": int(dish[3]),\n                }\n            )\n        elif dish.startswith(\"C\"):\n            dish = dish.split(\" \")\n            dishes.append(\n                {\n                    \"weight\": int(dish[1]),\n                    \"tastiness\": int(dish[2]),\n                    \"decay\": None,\n                }\n            )\n    dishes = sorted(dishes, key=lambda dish: dish[\"tastiness\"])\n    dishes = sorted(dishes, key=lambda dish: dish[\"weight\"], reverse=True)\n    best_tastiness = 0.0\n    tastiness_sum = 0.0\n    for dish in dishes:\n        if dish[\"weight\"] <= total_weight:\n            total_weight -= dish[\"weight\"]\n            if dish[\"decay\"] is None:\n                tastiness_sum += dish[\"tastiness\"]\n            else:\n                tastiness_sum += dish[\"tastiness\"] * total_weight\n            best_tastiness = max(best_tastiness, tastiness_sum)\n        else:\n            break\n    return f\"{best_tastiness:.6f}\"\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.split())\n    m = dict()\n    for _ in range(d):\n        t, x, *dish = stdin.split()\n        if t == \"D\":\n            m[float(x)] = (int(dish[0]), int(dish[1]))\n        elif t == \"C\":\n            m[float(x)] = (int(dish[0]), None)\n    t, x = max(m)\n    while x:\n        w -= x\n        t += x * m[t][0]\n        if m[t][1]:\n            x -= x\n            t += x * m[t][1]\n        else:\n            x = 0\n        if w <= 0:\n            break\n    print(t)\n    return t\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Tr\u1ea3 v\u1ec1 c\u00e2u tr\u1ea3 l\u1eddi c\u1ee7a b\u00e0i b\u00e0i b\u00ean d\u01b0\u1edbi t\u1ea1o ra b\u00e0i n\u00e0y\n\n    >>> solution('''2 15\n   ... D 4 10 1\n   ... C 6 1\n   ... C 9 3\n   ... ''')\n    '49.000000000'\n    \"\"\"\n    return ''\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A naive solution that simply traverses the list of input data,\n    and calculates the maximum possible tastiness of a meal of weight $w$.\n\n    :param stdin: input data\n    :type stdin: str\n    :return: maximum possible tastiness of a meal of weight $w$\n    :rtype: str\n    \"\"\"\n    n, w = [int(x) for x in stdin.split(\" \")]\n    tastiness = []\n    for i in range(n):\n        x = stdin.split(\" \")\n        if x[0] == \"D\":\n            weight = int(x[1])\n            tastiness.append(int(x[2]))\n            tastiness.append(int(x[3]))\n        if x[0] == \"C\":\n            tastiness.append(int(x[1]))\n            tastiness.append(int(x[2]))\n    tastiness = sorted(tastiness, reverse=True)\n    tastiness = sum([(tastiness[i] - (i * tastiness[i + 1])) * weight for i in range(0, len(tastiness) - 1, 2)])\n    if tastiness <= w:\n        return str(tastiness)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # get input\n    num_disc_dishes, desired_weight = [int(x) for x in stdin.split()]\n    \n    # init data structures\n    disc_tastiness_dict, cont_tastiness_dict = {}, {}\n    disc_tastiness_list, cont_tastiness_list = [], []\n    \n    # read input and put into data structures\n    for _ in range(num_disc_dishes):\n        disc_tastiness, weight, decay = [int(x) for x in stdin.split()]\n        disc_tastiness_dict[weight] = (disc_tastiness, decay)\n        disc_tastiness_list.append((weight, disc_tastiness, decay))\n    \n    for _ in range(num_disc_dishes):\n        tastiness, weight, decay = [int(x) for x in stdin.split()]\n        cont_tastiness_dict[weight] = (tastiness, decay)\n        cont_tastiness_list.append((weight, tastiness, decay))\n    \n    # init vars\n    best_disc_tastiness = 0\n    best_cont_tastiness = 0\n    best_weight = desired_weight\n    best_sum_tastiness = 0\n    \n    # loop through weight range\n    for weight in range(desired_weight, 0, -1):\n        disc_tastiness_sum = cont_tastiness_sum = 0\n        \n        # loop through discrete dishes and add them to total tastiness sum\n        for weight_disc, tastiness_disc, decay_disc in disc_tastiness_list:\n            if weight_disc <= weight:\n                disc_tastiness_sum += (tastiness_disc - ((weight_disc - 1) * decay_disc))\n            else:\n                break\n        \n        # loop through continuous dishes and add them to total tastiness sum\n        for weight_cont, tastiness_cont, decay_cont in cont_tastiness_list:\n            if weight_cont <= weight:\n                cont_tastiness_sum += (tastiness_cont - ((weight_cont - 1) * decay_cont))\n            else:\n                break\n        \n        # update best tastiness\n        if best_disc_tastiness < disc_tastiness_sum:\n            best_disc_tastiness = disc_tastiness_sum\n        \n        if best_cont_tastiness < cont_tastiness_sum:\n            best_cont_tastiness = cont_tastiness_sum\n        \n        # update best weight\n        if best_weight > weight:\n            best_weight = weight\n        \n        # update best sum tastiness\n        best_sum_tastiness = max(best_sum_tastiness, best_disc_tastiness + best_cont_tastiness)\n    \n    # best possible sum tastiness is impossible\n    if best_sum_tastiness < 0:\n        return 'impossible'\n    \n    # return answer\n    return best_sum_tastiness\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the maximum possible tastiness of a meal of weight exactly w based on the available dishes.\n\n    The maximum tastiness of a meal of weight exactly w is simply the sum of the initial tastinesses of the dishes.\n    \"\"\"\n    dishes, weight = map(int, stdin.split())\n    tastinesses = [list(map(int, stdin.split())) for _ in range(dishes)]\n    tastinesses = [[tastiness] + [0] * weight for tastiness in tastinesses]\n    for i in range(1, dishes):\n        for j in range(weight):\n            tastinesses[i][j + 1] = tastinesses[i][j] + tastinesses[i - 1][j]\n    print(f\"{max(tastinesses[-1]):.6f}\")\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    # main \ud638\ucd9c \uc804\uc5d0 \uba3c\uc800 \uc2dc\uc791\uc2dc\uac04, \uc885\ub8cc\uc2dc\uac04 \uac12\uc744 \uc800\uc7a5\n    start_time = time.time()\n    songs_count = int(stdin)\n    # main \ud638\ucd9c \uc804\uc5d0 \uc2dc\uc791\uc2dc\uac04\uacfc \ud504\ub85c\uadf8\ub7a8 \uc791\ub3d9 \uc2dc\uac04 \uac12\uc744 \uc124\uc815\ud558\uc5ec \ube44\uad50\ud55c\ub2e4.\n    result = []\n    songs_list = []\n    for _ in range(songs_count):\n        artist, len_of_songs, *songs = stdin.split(' ')\n        songs_list.append((artist, len_of_songs, set(map(int, songs))))\n    # \uac01\uac01 \uc544\ud2f0\uc2a4\ud2b8, \uac01\uac01\uc758 \uace1\uc758 \uac1c\uc218, \uc911\ubcf5\ub418\uc9c0 \uc54a\uc740 \uace1\uc758 \ubc88\ud638\ub97c \uc800\uc7a5\ud55c\ub2e4.\n    # \uc774\ub97c \ud1b5\ud574 \uc774\ubc88 \ubd80\ubd84\uc774 \uc544\ud2f0\uc2a4\ud2b8\ubcc4\ub85c \uace1\uc758 \ubc88\ud638\ub97c \ud560\ub2f9\ud558\ub294 \uac83\uc774\ub2e4.\n    # \uc774\ub7f0 \ubc29\ubc95\uc73c\ub85c \ub2e4\uc2dc \ubb38\uc81c\ub97c \ud574\uacb0\ud574\ub098\uac04\ub2e4.\n    # \ub530\ub77c\uc11c \uc544\ud2f0\uc2a4\ud2b8\ubcc4\ub85c \uace1\uc758 \ucd1d \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n    # \ub3d9\uc77c\ud55c \uc778\ub371\uc2a4\uc758 \ub178\ub798\uac00 \ub3d9\uc77c\ud55c \uc544\ud2f0\uc2a4\ud2b8\uc5d0 \ub300\ud574 \uace1\uc744 \uc5ec\ub7ec \uac1c \ud560\ub2f9\ubc1b\uc744 \uc218 \uc788\uc73c\ubbc0\ub85c\n    # \uc911\ubcf5\ub418\ub294 \ub178\ub798\ub4e4\uc744 \uac74\ub108\ub6f4\ub2e4.\n\n    songs_list = sorted(songs_list, key=lambda x: int(x[1]))\n    # \uac01\uac01\uc758 \uace1\uc758 \uac1c\uc218\ub4e4\uc744 \uc815\ub82c\ud55c\ub2e4.\n\n    # \uba3c\uc800 \uc544\ud2f0\uc2a4\ud2b8 \ubcc4\ub85c \uace1\uc758 \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n    songs_count = [int(x[1]) for x in songs_list]\n    # \uc544\ud2f0\uc2a4\ud2b8 \ubcc4\ub85c \uc0ac\ub78c \uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n    # \uc0ac\ub78c \uc218\uac00 \ub9ce\uc544\uc9c0\uba74 \ud3b8\ud558\uac8c \uc815\ub82c\ud574\uc11c \uc0ac\uc6a9\ud560 \uc218 \uc788\ub2e4.\n    songs_count_people = [x[1] for x in songs_list]\n\n    while len(result) < 9:\n        for i in range(len(songs_list)):\n            # \uc544\ud2f0\uc2a4\ud2b8 \ubcc4\ub85c \uace1\uc744 \uc800\uc7a5\ud55c\ub2e4.\n            artist = songs_list[i][0]\n            # \uc544\ud2f0\uc2a4\ud2b8 \ubcc4\ub85c \uace1\uc758 \ucd1d \uac1c\uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n            total = songs_count[i]\n            # \uc544\ud2f0\uc2a4\ud2b8 \ubcc4\ub85c \uc0ac\ub78c \uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n            people = songs_count_people[i]\n            # \uc544\ud2f0\uc2a4\ud2b8 \uc548\uc758 \uc544\ud2f0\uc2a4\ud2b8\ub97c \uc800\uc7a5\ud55c\ub2e4.\n            # \uc0ac\ub78c \uc218\uac00 \ub9ce\uc544\uc9c0\uba74 \uc7ac\uc815\ub82c\ud558\uc5ec \uc0ac\ub78c \uc218\ub97c \ube44\uad50\ud558\ub294 \uc791\uc5c5\uc774 \ud3b8\ud558\ub2e4.\n            # \uadf8\ub798\uc57c \uc544\ud2f0\uc2a4\ud2b8\ub97c \uc815\ub82c\ud574\uc11c \uc0ac\ub78c \uc218\uac00 \ub9ce\uc740 \uc544"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an array of the first 9 integers that represent the numbers of the\n    songs in the playlist that satisfies the requirements.\n\n    >>> solution(\"10\\n\\ta 2 10 3\\n\\tb 1 6\\n\\tc 2 1 5\\n\\td 1 9\\n\\te 1 4\\n\\tf 1 2\\n\\tg 2 6 8\\n\\th 0\\n\\ti 1 3\\n\\tj 1 7\")\n    '5 4 9 3 1 10 7 6 2'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Given a list of song and their dependencies, returns a list of the songs in the order they should be played.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string.\n\n    Returns\n    -------\n    str\n        The solution as a string.\n    \"\"\"\n\n    songs = []\n    dependencies = {}\n\n    # Parse input\n    for line in stdin.splitlines():\n        line = line.strip()\n        if not line:\n            continue\n\n        if line.startswith('a'):\n            songs.append(line[1:])\n            dependencies[line[1:]] = []\n        else:\n            _, prev_songs, *_ = line.split(' ')\n            for song in prev_songs.split(' '):\n                dependencies[songs[int(song) - 1]].append(songs[int(song) - 1])\n\n    # Traverse the dependencies graph\n    # If a node has no dependencies it must be the root\n    # Start at the root and grow to the leaves\n\n    visited = set()\n    solution = []\n\n    for i, song in enumerate(songs):\n        if song not in visited:\n            traverse(song, dependencies, visited, solution, i)\n\n    return''.join(map(str, solution))\n\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    cnt = int(stdin.readline().strip())\n    song_list = dict()\n    for i in range(cnt):\n        artist = stdin.readline().strip()\n        num = int(stdin.readline().strip())\n        songs = []\n        for j in range(num):\n            songs.append(int(stdin.readline().strip()))\n        song_list[i + 1] = (artist, songs)\n    result = []\n    for i in range(cnt):\n        tmp = []\n        while len(tmp) < 9:\n            for j in song_list[i + 1][1]:\n                if not j in tmp:\n                    tmp.append(j)\n        result.append(tmp)\n    if len(set(list(itertools.chain(*result))))!= 9:\n        return \"fail\"\n    else:\n        return \" \".join(str(i) for i in list(itertools.chain(*result)))\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return 'fail'\n    d = {'a': [], 'b': [], 'c': [], 'd': [], 'e': [], 'f': [], 'g': [], 'h': [], 'i': [], 'j': []}\n    for i in range(n):\n        a = stdin.split()\n        if len(a)!= 2:\n            return 'fail'\n        d[a[0]].append(a[1])\n    #print(d)\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if len(d[str(i)]) == 0:\n                continue\n            if str(j) in d[str(i)]:\n                for k in range(j, n+1):\n                    if str(k) in d[str(i)]:\n                        continue\n                    for l in range(j+1, n+1):\n                        if str(l) in d[str(i)]:\n                            continue\n                        for m in range(l+1, n+1):\n                            if str(m) in d[str(i)]:\n                                continue\n                            for n in range(m+1, n+1):\n                                if str(n) in d[str(i)]:\n                                    continue\n                                #print('{} {} {} {} {} {} {} {} {}'.format(i, j, k, l, m, n, d[str(i)], d[str(k)], d[str(l)], d[str(m)], d[str(n)]))\n                                if i in d[str(k)]:\n                                    if j in d[str(l)]:\n                                        if m in d[str(n)]:\n                                            d[str(i)].append(j)\n                                            d[str(i)].append(k)\n                                            d[str(i)].append(l)\n                                            d[str(i)].append(m)\n                                            d[str(i)].append(n)\n                                            #print(d[str(i)])\n                                            return str(i) +'' + str(j) +'' + str(k) +'' + str(l) +'' + str(m) +'' + str(n)\n                                    else:\n                                        d[str(i)].append(j)\n                                        d[str(i)].append(k)\n                                        d[str(i)].append(l)\n                                        d[str(i)].append(m)\n                                        d[str(i)].append(n)\n                                        #print(d[str(i)])\n                                        return str(i) +'' + str(j) +'' + str(k) +'' + str(l) +'' + str(m) +'' + str(n)\n                                elif j in d[str(k)]:\n                                    if i in d[str(l)]:\n                                        if m in d[str(n)]:\n                                            d[str(i)].append(j)\n                                            d[str(i)].append(k)\n                                            d[str(i)].append(l)\n                                            d[str(i)].append(m)\n                                            d[str(i)].append(n)\n                                            #print(d[str(i)])\n                                            return str(i) +'' + str(j) +'' + str(k) +'' + str(l) +'' + str(m) +'' + str(n)\n                                    else:\n                                        d[str(i)].append(j)\n                                        d[str(i)].append(k)\n                                        d[str(i)].append(l)\n                                        d[str(i)].append(m)\n                                        d[str(i)].append(n)\n                                        #print(d[str(i)])\n                                        return str(i) +'' + str(j) +'' + str(k) +'' + str(l) +'' + str(m) +'' + str(n)\n                                elif k in d[str(l)]:\n                                    if i in d[str(m)]:\n                                        if j in d[str(n)]:\n                                            d[str(i)].append(j)\n                                            d[str(i)].append(k)\n                                            d[str(i)].append(l)\n                                            d[str(i)].append(m)\n                                            d[str(i)].append(n)\n                                            #print(d[str(i)])\n                                            return str(i) +'' + str(j) +'' + str(k) +'' + str(l) +'' + str(m) +'' + str(n)\n                                    else:\n                                        d[str(i)].append(j)\n                                        d[str(i)].append(k)\n                                        d[str(i)].append(l)\n                                        d[str(i)].append(m)\n                                        d[str(i)].append(n)\n                                        #print(d[str(i)])\n                                        return str(i) +"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    songs = {}\n    for i in range(n):\n        song, amount = stdin.readline().strip().split(' ')\n        songs[song] = int(amount)\n    used_songs = []\n    songs_to_be_added = [song for song in songs]\n    while len(songs_to_be_added) > 0:\n        song_to_be_added = songs_to_be_added.pop(0)\n        for i in range(songs[song_to_be_added]):\n            used_songs.append(song_to_be_added)\n            for song in songs:\n                if song not in used_songs and song not in songs_to_be_added:\n                    songs_to_be_added.append(song)\n    return''.join(map(str, used_songs))\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution of solution\"\"\"\n    #create empty array\n    songs = []\n    #loop through all lines in input\n    for line in stdin:\n        #split the line into list elements\n        line = line.split(\" \")\n        #set initial variables\n        artist = \"\"\n        count = 0\n        #loop through each element of the list\n        for element in line:\n            #if the current element is not an integer\n            if not element.isnumeric():\n                #set the artist to the current element\n                artist = element\n            #if the current element is an integer\n            elif element.isnumeric():\n                #append a new song to the array of songs\n                songs.append(int(element))\n        #set the count variable to 0\n        count = 0\n        #loop through the array of songs\n        for i in range(len(songs)):\n            #if the current song is equal to the song that follows the previous one\n            if i+1 == songs[i]:\n                #add 1 to the count variable\n                count += 1\n        #if there is exactly 9 songs in the array of songs\n        if count == 9:\n            #return the array of songs\n            return(songs)\n        #otherwise, return fail\n        else:\n            return(\"fail\")"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input = [l.split() for l in stdin.split('\\n')]\n    n = int(input[0][0])\n    songs = [int(l[0]) for l in input[1:]]\n    next_songs = {int(l[0]):[int(l[1])] for l in input[1:] if l[1]!= '0'}\n    for i in range(1, len(songs)):\n        next_songs[songs[i-1]].append(songs[i])\n    \n    selected_songs = []\n    \n    def recurse(current_songs):\n        if len(selected_songs) == 9:\n            return True\n        if not current_songs:\n            return False\n        for i in current_songs:\n            if i in selected_songs:\n                continue\n            for n in next_songs[i]:\n                if not recurse(current_songs + [n]):\n                    continue\n                return True\n            return False\n    \n    if recurse([]):\n        return''.join(str(c) for c in selected_songs)\n    return 'fail'\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return \"\"\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Parses input and returns a solution string.\"\"\"\n    return '\\n'.join(sorted([t1 + '-' + t2 for t1, t2 in set([t1 + '-' + t2 for t1, t2 in [stdin.split('\\n')[0:2]]] + [t2 + '-' + t1 for t1, t2 in set([t1 + '-' + t2 for t1, t2 in [stdin.split('\\n')[0:2]]] + [t2 + '-' + t1 for t1, t2 in set([t1 + '-' + t2 for t1, t2 in [stdin.split('\\n')[0:2]]]])])]))"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    clock = stdin.split('\\n')[0]\n    current = stdin.split('\\n')[1]\n\n    clock_set = set()\n    clock_check = set()\n    max_count = 0\n    for c in clock:\n        if c in clock_check:\n            continue\n        clock_check.add(c)\n        count = 0\n        for n in current:\n            if c == n:\n                count += 1\n        if count > max_count:\n            max_count = count\n    return '\\n'.join(f'{c}{clock[c:c + 1]}{current[c:c + 1]}' for c in range(len(clock)) if clock[c] in clock_check)\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"\"\n    res = 0\n    for inp in stdin.split('\\n'):\n        start = inp.split(':')\n        inp = inp.split(':')\n        start = list(map(int, start))\n        inp = list(map(int, inp))\n        h, m = start[0], start[1]\n        for i in inp:\n            h, m = set_time(h, m, i)\n        res += 1 if h == inp[0] and m == inp[1] else 0\n        print(f'{h:02d}:{m:02d}')\n    return res\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    b_time = stdin.split('\\n')[0]\n    b_time = list(map(int, b_time.split(':')))\n\n    c_time = stdin.split('\\n')[1]\n    c_time = list(map(int, c_time.split(':')))\n\n    seen = []\n    for i in range(24):\n        for j in range(60):\n            t = [i, j]\n            s = [0, 0]\n            for m, n in zip(t, b_time):\n                s[0] += m * (n == m)\n                s[1] += (m - n) * (m > n)\n            for m, n in zip(t, c_time):\n                s[0] += m * (n == m)\n                s[1] += (m - n) * (m > n)\n            seen.append(tuple(s))\n    seen = Counter(seen)\n    seen = [{'time': x, 'times': seen[x]} for x in seen]\n    seen = sorted(seen, key=lambda x: -x['times'])\n    seen = [x['time'] for x in seen]\n    return '\\n'.join(map(lambda x: ':'.join(map(str, x)), seen))\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    init_time = stdin.split()[0]\n    current_time = stdin.split()[1]\n    if len(init_time)!= 4:\n        return 'Invalid initial time'\n    if len(current_time)!= 4:\n        return 'Invalid current time'\n    if init_time[2] == ':' or current_time[2] == ':':\n        return 'Invalid time format'\n    time = init_time\n    count = 0\n    while time!= current_time:\n        for i in range(2):\n            for j in range(2):\n                tmp = list(time)\n                if int(tmp[i]) - 1 >= 0:\n                    tmp[i] = str(int(tmp[i]) - 1)\n                else:\n                    tmp[i] = '9'\n                if int(tmp[j]) - 1 >= 0:\n                    tmp[j] = str(int(tmp[j]) - 1)\n                else:\n                    tmp[j] = '9'\n                tmp = ''.join(tmp)\n                if int(tmp[i]) + 1 < 10:\n                    tmp = tmp[:i] + '0' + tmp[i + 1:]\n                else:\n                    tmp = tmp[:i] + str(int(tmp[i]) + 1) + tmp[i + 1:]\n                if int(tmp[j]) + 1 < 10:\n                    tmp = tmp[:j] + '0' + tmp[j + 1:]\n                else:\n                    tmp = tmp[:j] + str(int(tmp[j]) + 1) + tmp[j + 1:]\n                if tmp == current_time:\n                    count += 1\n        time = tmp\n    return count\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    m = re.match('([0-9]{2}):([0-9]{2})', stdin)\n    h, m = m.group(1), m.group(2)\n    h = int(h)\n    m = int(m)\n    if h == 0 and m == 0:\n        return '0:0'\n    elif h < 10:\n        h = '0' + str(h)\n    else:\n        h = str(h)\n    if m < 10:\n        m = '0' + str(m)\n    else:\n        m = str(m)\n    if m == '60':\n        m = '00'\n        h = str(int(h) + 1)\n    if h == '24':\n        h = '00'\n    return h + ':' + m"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    h, m = [int(x) for x in stdin.split('\\n')[0].split(':')]\n    h1, m1 = [int(x) for x in stdin.split('\\n')[1].split(':')]\n    #print(h, m, h1, m1)\n    if h < 0 or h > 23:\n        h = h % 24\n    if m < 0 or m > 59:\n        m = m % 60\n    if h1 < 0 or h1 > 23:\n        h1 = h1 % 24\n    if m1 < 0 or m1 > 59:\n        m1 = m1 % 60\n    if h == h1 and m == m1:\n        return 1\n    elif h > h1:\n        return h - h1 + (24 if h1 == 0 else 0)\n    elif h < h1:\n        return h1 - h + (24 if h == 0 else 0)\n    else:\n        return (m1 + 60) - m\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    clocks_orig = stdin.splitlines()\n    clocks = clocks_orig[0].split(':')\n    clocks_orig = clocks_orig[1].split(':')\n    \n    orig_hour, orig_min = int(clocks[0]), int(clocks[1])\n    hour, min = int(clocks_orig[0]), int(clocks_orig[1])\n    \n    clock_cycles = 0\n    \n    while (hour!= orig_hour and min!= orig_min) or (hour < 0 or hour > 23):\n        if hour < 0:\n            hour = 23\n        elif hour > 23:\n            hour = 0\n        if min < 0:\n            min = 59\n        elif min > 59:\n            min = 0\n            \n        clock_cycles += 1\n        \n        hour -= 1\n        if hour == 0:\n            hour = 23\n        min += 1\n        if min == 60:\n            min = 0\n            \n    print(f'{clock_cycles}')\n    \n    for i in range(clock_cycles):\n        hour_new, min_new = hour, min\n        \n        if i % 2 == 0:\n            hour_new += 1\n            if hour_new == 24:\n                hour_new = 0\n            min_new += 1\n            if min_new == 60:\n                min_new = 0\n        else:\n            hour_new -= 1\n            if hour_new == 0:\n                hour_new = 23\n            min_new -= 1\n            if min_new == 0:\n                min_new = 59\n            \n        print(f'{hour_new:02}:{min_new:02}')\n        \n    return ''\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.strip('\\n')\n    output = ''\n    start = 0\n    end = 0\n    for i in range(len(input)):\n        if input[i] == '(':\n            start = i\n        if input[i] == ')':\n            end = i\n            output += f'{start + 1},{end + 1}:'\n    return output\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')[1:]\n    res = \"\"\n    stack = []\n    for i, e in enumerate(stdin):\n        if e == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            res += f\"{start},{i}:{i},\"\n    return res.rstrip(',')\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip('()')\n    result = ''\n    stack = []\n\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(char)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                result = f'{stack[-1]},{i}:{i}'\n\n    return result\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    print(parenthesis_to_new_format(stdin))\n    return \"\"\n\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    bracket_expression = stdin\n    bracket_expression_list = list(bracket_expression)\n    min_index = 0\n    bracket_list = []\n    for i in range(0, len(bracket_expression_list)):\n        if bracket_expression_list[i] == '(':\n            bracket_list.append(i)\n        if bracket_expression_list[i] == ')':\n            if i < bracket_list[-1]:\n                min_index = min(min_index, i)\n            else:\n                bracket_list.pop()\n    bracket_list_2 = []\n    for i in range(0, len(bracket_list)):\n        if i % 2 == 0:\n            bracket_list_2.append(bracket_list[i])\n        else:\n            bracket_list_2.append(bracket_list[i] + 1)\n    bracket_list_2.append(min_index)\n    bracket_list_3 = []\n    for i in range(0, len(bracket_list_2) - 1, 2):\n        bracket_list_3.append(str(bracket_list_2[i]))\n        bracket_list_3.append(str(bracket_list_2[i + 1]))\n        bracket_list_3.append(':')\n    bracket_expression_2 = ''.join(bracket_list_3)\n    return bracket_expression_2"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\")\n    bracket_pair = {}\n    for i, bracket in enumerate(stdin):\n        if bracket not in bracket_pair:\n            bracket_pair[bracket] = [i]\n        else:\n            bracket_pair[bracket].append(i)\n    res = []\n    for bracket, idx in bracket_pair.items():\n        if len(idx) > 1:\n            idx = [idx[0], idx[-1]]\n        else:\n            idx = [idx[0], idx[-1]]\n        res.append(str(idx[0] + 1) + ',' + str(idx[1] + 1) + ':' + str(idx[1] + 1))\n    return ','.join(res)\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = list()\n    output = ''\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            stack.pop()\n            if stack:\n                start = i - len(stack) + 1\n                end = i\n                output += f'{start},{end}:'\n            else:\n                output += f'{i}:'\n    return output[:-1]\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n\nfrom typing import List\n\nimport re\n\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Day of the year for one event.\n\n    Args:\n        stdin (str): input data in string.\n\n    Returns:\n        str: result in string.\n    \"\"\"\n    inputs = stdin.split(\"\\n\")\n    day_of_the_year = {}\n    for input in inputs:\n        day, month, year, num = [int(value) for value in input.split(\" \")]\n        key = \"day:{}/month:{}/year:{}\".format(day, month, year)\n        if num > 0:\n            day_of_the_year[key] = num\n    return day_of_the_year\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split(\"\\n\")\n    inp = stdin[1:]\n    for i in range(len(inp)):\n        inp[i] = inp[i].split()\n        for j in range(len(inp[i])):\n            inp[i][j] = int(inp[i][j])\n    events = inp\n    n = int(stdin[0].split()[0])\n    m = int(stdin[0].split()[1])\n    count = [0 for i in range(m)]\n    for i in range(n):\n        for j in range(m):\n            count[j] += events[i][j + 3]\n    print(max(count))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    total = [int(x) for x in stdin.split()]\n    return str(sum(total))\n\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split('\\n')\n    n, m = int(n), int(m)\n    lst = []\n    for i in range(n):\n        lst.append(stdin.split('\\n')[i].split())\n    lst.sort(key=lambda x: x[3])\n    while True:\n        if lst[-1][3] == lst[-2][3]:\n            a = lst[-2][2] - lst[-1][2]\n            b = lst[-1][1] - lst[-2][1]\n            c = lst[-2][0] - lst[-1][0]\n            if a!= 0 or b!= 0 or c!= 0:\n                lst.append([lst[-1][0] + c, lst[-1][1] + b, lst[-1][2] + a, lst[-1][3] + 1])\n            lst.pop()\n            lst.pop()\n        else:\n            break\n    lst.sort(key=lambda x: x[0])\n    cnt = 1\n    for i in lst:\n        if cnt!= i[3]:\n            return '-1'\n        cnt += 1\n    return sum([i[2] for i in lst])\n\n\nprint(solution('2 2\\n10 08 10 08 2\\n10 08 10 08 10\\n10 08 10 08 10'))\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates the sum of the multiples of given parameters.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    data = stdin.split()\n    N = int(data[0])\n    M = int(data[1])\n    observations = []\n    for i in range(N):\n        data = stdin.split()\n        observations.append(data[2:])\n    events = {}\n    for observation in observations:\n        if int(observation[2]) == 0:\n            events[observation[0]] = 1\n        else:\n            events[observation[0]] = 0\n    for observation in observations:\n        events[observation[0]] += int(observation[3])\n    days_per_year = 365\n    max_len = 0\n    for key, value in events.items():\n        if value > 0:\n            if value >= days_per_year:\n                if max_len < len(str(value)):\n                    max_len = len(str(value))\n    for key, value in events.items():\n        if value > 0:\n            if len(str(value)) < max_len:\n                events[key] = days_per_year - value + 1\n    answer = -1\n    for observation in observations:\n        if int(observation[3]) > 0:\n            if int(observation[2]) == 0:\n                events[observation[0]] = 365 - events[observation[0]]\n            if events[observation[0]] > 0:\n                answer = events[observation[0]]\n    return answer\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return '-1'\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    x = stdin.split()\n    print(x)\n    # d[0] = '0'\n    d = []\n    for i in range(int(x[0])):\n        d.append([])\n    for i in range(int(x[0])):\n        for j in range(int(x[1])):\n            d[i].append(int(x[2 + i * int(x[1]) + j]))\n    print(d)\n    events = []\n    for i in range(int(x[0])):\n        events.append(0)\n        for j in range(int(x[1])):\n            events[i] += d[i][j]\n    events.append(int(x[1]))\n    events.append(0)\n    print(events)\n\n    for i in range(int(x[0])):\n        for j in range(int(x[1]) + 1):\n            if events[j] >= events[j + 1]:\n                events[j] = 0\n            else:\n                break\n        for j in range(int(x[1]) + 1, int(x[0])):\n            if events[j] >= events[j + 1]:\n                events[j] = 0\n            else:\n                break\n    print(events)\n    return''.join(map(str, events[:-2]))\nprint(solution('1 1\\n26 02 03 03 1'))"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_telescopes, num_events = map(int, stdin.split())\n    events = [[int(f) for f in stdin.split()] for _ in range(num_telescopes)]\n\n    events.sort(key=lambda x: x[3])\n    # print(events)\n\n    duration = [0] * num_events\n\n    def solve(idx: int) -> bool:\n        if idx == num_telescopes:\n            return True\n        for i in range(num_events):\n            if events[idx][3] == i + 1 and duration[i] == 0:\n                for j in range(events[idx][2] - events[idx][0] + 1):\n                    if solve(idx + 1):\n                        return True\n                duration[i] = events[idx][2] - events[idx][0] + 1\n        return False\n\n    solve(0)\n    result = []\n    for i in range(num_events):\n        result.append(duration[i])\n    print(result)\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    N, M = map(int, stdin.split(\" \"))\n    start_date = []\n    for _ in range(N):\n        event = list(map(int, stdin.split(\" \")))\n        event[0] = f\"{event[0] :0>2}\"\n        event[1] = f\"{event[1] :0>2}\"\n        event.pop(2)\n        start_date.append(event)\n    # create empty list\n    event_count = []\n    for _ in range(M):\n        event_count.append(0)\n    # loop through all the events\n    for event in start_date:\n        for i in range(M):\n            event_count[i] += event[i]\n    # make list of the event lengths\n    event_length = []\n    for i in range(M):\n        event_length.append(event_count[i])\n    # remove duplicates\n    event_length = list(dict.fromkeys(event_length))\n    # remove ones that are 0 or 1\n    for i in range(len(event_length)):\n        if event_length[i] == 0 or event_length[i] == 1:\n            event_length.pop(i)\n    # make new list with minimum length\n    new_event_length = []\n    for i in range(len(event_length)):\n        new_event_length.append(event_length[i])\n    new_event_length.sort()\n    new_event_length.reverse()\n    # get the minimum length\n    min_length = new_event_length[0]\n    # initialize empty list\n    result = []\n    for i in range(M):\n        result.append(0)\n    # go through all the event lengths and check if they match the minimum length\n    for i in range(M):\n        if event_length[i] == min_length:\n            result[i] = event_count[i]\n    # return minimum length or -1\n    if result == []:\n        return \"-1\"\n    return str(min_length)\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(\" \")]\n    events = []\n    for _ in range(n):\n        events.append([int(x) for x in stdin.split(\" \")])\n    events.sort(key=lambda x: x[2])\n    res = []\n    for i in range(m):\n        events[0][2] -= 1\n        if events[0][2] == 0:\n            events.pop(0)\n        if not events:\n            res.append(-1)\n            break\n        for j in range(i + 1, m):\n            events[j][2] -= events[0][2]\n            if events[j][2] == 0:\n                events.pop(j)\n            if not events:\n                res.append(events[0][0] * 365 + events[0][1])\n                break\n    res.sort()\n    return \" \".join(str(x) for x in res)\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(s: str) -> Tuple[int, List[int]]:\n        return int(s.split()[0]), [int(x) for x in s.split()[1].split(' ')]\n\n    def possible_moves(i: int, j: int) -> List[Tuple[int, int]]:\n        if i == j:\n            return []\n\n        result = []\n        for k in range(1, n+1):\n            if (\n                # if (i + k) % n!= j:\n                #     result.append((i + k, j))\n                # if (i - k) % n!= j:\n                #     result.append((i - k, j))\n                (i + k) % n!= j and (i - k) % n!= j and (i + k) / n!= j and (i - k) / n!= j\n            ):\n                result.append((i + k, j))\n                result.append((i - k, j))\n                result.append((i + k) / n, j)\n                result.append((i - k) / n, j)\n        return result\n\n    def move(start: int, end: int, arrows: List[Tuple[int, int]], new_arrows: List[Tuple[int, int]]):\n        if start == end:\n            return True\n\n        if not new_arrows:\n            return False\n\n        result = []\n        for arrow in new_arrows:\n            result.extend(possible_moves(start, end))\n\n        for arrow in result:\n            if move(arrow[0], arrow[1], arrows, new_arrows):\n                arrows.append(arrow)\n                return True\n\n        return False\n\n    n, k = parse_input(stdin)\n    moves = []\n    for i, j in enumerate(parse_input(stdin)[1], 1):\n        moves.append((i, j))\n\n    if not move(1, n, moves, []):\n        print(\"Impossible\")\n    else:\n        print(*[x[0] for x in sorted(moves)])\n    return ''"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Dance function that prints the result of a simulation for every possible combination of moves.\n    \"\"\"\n    N, K = [int(x) for x in stdin.split()]\n    # Create dictionary with pre-generated arrows\n    arrows = {x: y for x, y in zip(range(1, N + 1), [z for z in range(1, N + 1)])}\n    moves = [int(x) for x in stdin.split()]\n    arrow_list = []\n    for x in moves:\n        # Get the arrow destination from the end of the arrow\n        dest = arrows[x]\n        # If it is already in the list, skip it\n        if dest in arrow_list:\n            continue\n        # Add it to the list\n        arrow_list.append(dest)\n    # Create a copy of the arrows dictionary\n    arrows = arrows.copy()\n    # If the arrows don't make it to the end, return impossible\n    if len(arrows) < N:\n        print(\"Impossible\")\n        return\n    # While there are still arrows, perform the simulation\n    while len(arrows) > 0:\n        # Add the first arrow to the list\n        arrow_list.append(next(iter(arrows.values())))\n        # If there are no arrows left, we're done\n        if len(arrows) == 0:\n            break\n        # Remove the destination from the arrows list\n        dest = next(iter(arrows.keys()))\n        arrows.pop(dest)\n        # Remove the source from the arrows list\n        source = next(iter(arrows.values()))\n        arrows.pop(source)\n    # Print out the output\n    print(\" \".join([str(x) for x in arrow_list]))"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    N = int(stdin.readline())\n    K = int(stdin.readline())\n    \n    l = list(map(int, stdin.readline().strip().split(' ')))\n    graph = {k:set() for k in range(1, N+1)}\n    \n    for i in range(K):\n        a = int(stdin.readline())\n        b = int(stdin.readline())\n        graph[a].add(b)\n        graph[b].add(a)\n    \n    seen = set()\n    def dfs(current, prev):\n        if current in seen:\n            return\n        seen.add(current)\n        \n        for neighbour in graph[current]:\n            if neighbour!= prev:\n                dfs(neighbour, current)\n    \n    dfs(1, None)\n    \n    ans = []\n    for node in seen:\n        ans.append(node)\n    return''.join(map(str, ans))\n    \"\"\"\n    \n    # for k, v in graph.items():\n    #     print(f\"{k} => {v}\")\n    \n    # for k, v in stdin:\n    #     print(k, v)\n    \n    n, k = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n    \n    d = {num: i+1 for i, num in enumerate(sorted(list(set(arr))))}\n    # print(d)\n    \n    # 1. Go through d: find if number is in d (it means that you have visited all nodes with a lower number)\n    # 2. If you find it, then go back in the graph and do the next number.\n    # 3. If you do not find it (you have visited all nodes with a lower number) then you can't make this graph.\n    \n    ans = {}\n    \n    for i in range(len(arr)):\n        num = arr[i]\n        # print(num)\n        if num not in d:\n            return \"Impossible\"\n        else:\n            # print(d[num])\n            if d[num] not in ans:\n                ans[d[num]] = num\n            else:\n                if ans[d[num]]!= num:\n                    return \"Impossible\"\n                else:\n                    ans[d[num]] = num\n    \n    return \" \".join([str(k) for k, v in sorted(ans.items(), key=lambda item: item[0]) if v!= k])\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, k = [int(i) for i in stdin.split('\\n')[0].split()]\n    lis = [int(i) for i in stdin.split('\\n')[1].split()]\n    \n    k_p, k_cur = 0, 0\n    dic = {}\n    for i in range(1, n + 1):\n        if i not in dic:\n            dic[i] = []\n        dic[i] = [i]\n    \n    while k_cur < k:\n        dic, k_cur = dic_move(dic, lis, k_cur)\n        if k_cur == k:\n            break\n    if k_cur < k:\n        print('Impossible')\n        return\n    \n    ans = []\n    for i in dic:\n        ans.extend(dic[i])\n    print(' '.join([str(i) for i in ans]))\n    return\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 2\\n3 4 1 2\")\n    '2 3 4 1'\n    \"\"\"\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n    for i in range(k):\n        for j in range(n):\n            if a[j] > 0:\n                a[j] -= 1\n                b[j] = i + 1\n                break\n    return \" \".join(map(str, b))\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    dist = [int(x) for x in stdin.split()]\n    if k % n!= 0:\n        return \"Impossible\"\n    elif (k // n) % 10!= 0:\n        return \"Impossible\"\n    else:\n        res = [n] * n\n        for i in range(k):\n            for j in range(n):\n                res[j] -= dist[j]\n                if res[j] <= 0:\n                    return \"Impossible\"\n                res[(j + 1) % n] += dist[j]\n        return''.join(str(x) for x in res)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(i) for i in stdin.split()]\n    arr = [int(i) for i in stdin.split()]\n    pass\n\nprint(solution(input()))"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(i) for i in stdin.split(' ')]\n    a = [int(i) for i in stdin.split(' ')]\n    ans = [0] * N\n    times = K\n    for i in range(1, N):\n        for j in range(i):\n            if times < K:\n                ans[a[j]] = i\n                times += 1\n            if times == K:\n                break\n        if times == K:\n            break\n    if times == K:\n        print(' '.join([str(i) for i in ans]))\n    else:\n        print('Impossible')\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(x) for x in stdin.split()]\n    a = [int(x) for x in stdin.split()]\n    return''.join([str(i + 1) for i in range(N) if a[i]!= i + 1])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split()\n    n, k = int(input[0]), int(input[1])\n    s = list(str(n))\n    for i in range(k):\n        b = s[:2]\n        if len(s) >= 4:\n            s[:2] = s[2:]\n        elif len(s) >= 3:\n            s[:1] = s[1:]\n        else:\n            break\n        if '0' in s:\n            s = '0' + ''.join(s)\n        else:\n            s = ''.join(s)\n    print(''.join(s))\n    return ''.join(s)\nsolution('1374 2')"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    first_line, *rest = stdin.splitlines()\n    n, k = map(int, first_line.split())\n    digits = list(str(n))\n    for line in rest:\n        l, r = map(int, line.split())\n        if l > 0:\n            digits[l - 1], digits[r - 1] = digits[r - 1], digits[l - 1]\n        else:\n            digits[l:r] = reversed(digits[l:r])\n        # print(''.join(digits))\n    return ''.join(digits)"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the largest number after swapping pairs.\"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    digits = [int(d) for d in str(n)]\n    \n    while k > 0:\n        i, j = randint(0, len(digits)-1), randint(0, len(digits)-1)\n        if i > j:\n            i, j = j, i\n        if i!= j:\n            digits[i], digits[j] = digits[j], digits[i]\n        k -= 1\n    \n    return int(''.join([str(d) for d in digits]))\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split(' ')]\n    n = str(n)\n    k = int(k)\n    r = []\n    for i in range(len(n)):\n        r.append(max(n[i], n[-(i + 1)]))\n    while k > 0:\n        if '0' in r:\n            r = [max(r)] + [min(r)]\n        else:\n            r = [min(r)] + [max(r)]\n        k -= 1\n    return ''.join(r)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the largest number after swapping pairs of its digits that does not lead to a leading zero.\n\n    Time: O(n) where n is the length of the input\n    Space: O(n)\n    \"\"\"\n    # Convert to list of digits\n    digits = list(stdin)\n    # Initialize largest\n    largest = 0\n    # Loop through each digit\n    for i in range(len(digits)):\n        # If the digit is greater than the largest then set largest to it\n        if int(digits[i]) > largest:\n            largest = int(digits[i])\n    # Initialize digits list for smallest digits\n    smallest = list(digits)\n    # Loop through each digit\n    for i in range(len(digits)):\n        # If the digit is smaller than the smallest then set smallest to it\n        if int(digits[i]) < int(smallest[i]):\n            smallest[i] = str(digits[i])\n    # Initialize swapped digits list\n    swapped = []\n    # Loop through each swapped digit\n    for i in range(len(digits)):\n        # If the digits are swapped\n        if digits[i]!= smallest[i]:\n            # Append to swapped list\n            swapped.append(digits[i])\n            # Append swapped digit\n            swapped.append(smallest[i])\n    # Initialize the remaining digits list\n    remaining = []\n    # Loop through each digit\n    for i in range(len(digits)):\n        # If the digit is not swapped\n        if digits[i] == smallest[i]:\n            # Append to remaining list\n            remaining.append(digits[i])\n    # Sort the swapped and remaining lists\n    swapped.sort()\n    remaining.sort()\n    # Initialize length of remaining\n    length = len(remaining)\n    # Loop through each swapped digit\n    for i in range(len(swapped)):\n        # If the swapped digit is smaller than the smallest digit and greater than the remaining digit\n        if int(swapped[i]) < int(remaining[length - 1]) and int(swapped[i]) > int(remaining[length - 2]):\n            # Swap the swapped digit with the smallest digit\n            swapped[i], remaining[length - 1] = remaining[length - 1], swapped[i]\n            # Swap the smallest digit with the swapped digit\n            remaining[length - 2], remaining[length - 1] = remaining[length - 1], remaining[length - 2]\n            # Initialize length of remaining\n            length = len(remaining)\n    # Convert lists to string\n    swapped = \"\".join(swapped)\n    remaining = \"\".join(remaining)\n    # Return the largest\n    return swapped + remaining\n\n\nprint(solution(\"1374\"))\nprint(solution(\"210\"))\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    a = int(str(a) + '0' * (18 - b))\n    for _ in range(b):\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a = (3 * a + 1) // 2\n    return str(a)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split(' ')))\n    s = list(str(n))\n    res = sorted(s)\n    while k > 0:\n        res[0], res[1] = res[1], res[0]\n        s = ''.join(res)\n        res = list(s)\n        k -= 1\n    return ''.join(res)\nprint(solution(input()))\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n, k = int(n), int(k)\n    n_str = str(n)\n    k_str = str(k)\n    k_str = k_str[::-1]\n    k_str = k_str[:-1]\n    k_str = k_str[::-1]\n    if k > len(n_str):\n        return k_str + n_str\n    k_str = k_str[:len(n_str)]\n    k_str = k_str[::-1]\n    k_str = k_str[:-1]\n    k_str = k_str[::-1]\n    n_str = n_str[::-1]\n    while k > 0:\n        if n_str[0] == '0':\n            n_str = n_str[1:]\n            k -= 1\n        else:\n            if len(n_str) >= 2:\n                if n_str[0] > n_str[1]:\n                    n_str = n_str[:0] + n_str[1:]\n                    k -= 1\n                else:\n                    n_str = n_str[:1] + n_str[0] + n_str[1:]\n                    k -= 1\n            else:\n                if n_str[0] > n_str[1]:\n                    n_str = n_str[:0] + n_str[1:]\n                    k -= 1\n                else:\n                    n_str = n_str[:1] + n_str[0] + n_str[1:]\n                    k -= 1\n    n_str = n_str[::-1]\n    return n_str\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    n_list = [digit for digit in str(n)]\n    k_list = sorted(n_list, reverse=True)\n    for i in range(k):\n        n_list.insert(0, k_list.pop(0))\n        n_list.pop(-1)\n    return ''.join(n_list)"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    number, k = map(int, stdin.split())\n    if k > number:\n        return -1\n    while k > 0:\n        number = str(number)\n        num_list = list(number)\n        for i in range(len(num_list) - 1):\n            if num_list[i] == '9' and num_list[i + 1] == '9':\n                num_list[i], num_list[i + 1] = '0', '1'\n            else:\n                num_list[i], num_list[i + 1] = num_list[i + 1], num_list[i]\n        number = int(\"\".join(num_list))\n        k -= 1\n    return number\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.splitlines()\n    n = int(input[0])\n    polygon = []\n    for line in input[1:]:\n        polygon.append(list(map(int, line.split())))\n    polygon.sort(key=lambda x: x[0])\n    polygon.sort(key=lambda x: x[1])\n    cur_x = polygon[0][0]\n    cur_y = polygon[0][1]\n    dist = 0\n    for i in range(n-1):\n        x1 = polygon[i+1][0]\n        y1 = polygon[i+1][1]\n        x2 = polygon[i][0]\n        y2 = polygon[i][1]\n        dist += abs(x1 - cur_x) + abs(y1 - cur_y)\n        cur_x = x1\n        cur_y = y1\n    dist += abs(x2 - cur_x) + abs(y2 - cur_y)\n    return f'{dist / n:.6f}'\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n = int(stdin.readline())\n    # polygon = []\n    # for _ in range(n):\n    #     polygon.append(list(map(int, stdin.readline().split())))\n    #\n    # # Make a vertex -> index map\n    # vertices = {}\n    # for vertex in polygon:\n    #     if vertex[0] not in vertices:\n    #         vertices[vertex[0]] = set()\n    #     if vertex[1] not in vertices:\n    #         vertices[vertex[1]] = set()\n    #\n    #     vertices[vertex[0]].add(vertex[1])\n    #     vertices[vertex[1]].add(vertex[0])\n    #\n    # # Compute the polygon area\n    # area = 0\n    # for vertex in polygon:\n    #     area += vertex[0] * vertex[1]\n    #\n    # # Find all triangles\n    # triangles = set()\n    # for vertex in vertices:\n    #     for next_vertex in vertices[vertex]:\n    #         for prev_vertex in vertices[vertex]:\n    #             if prev_vertex!= next_vertex:\n    #                 triangles.add(Triangle(vertex, next_vertex, prev_vertex))\n    #\n    # # Compute the area of the triangle\n    # triangles_area = 0\n    # for triangle in triangles:\n    #     triangles_area += triangle.area()\n    #\n    # # Compute the perimeter\n    # perimeter = 0\n    # for vertex in vertices:\n    #     for prev_vertex in vertices[vertex]:\n    #         perimeter += abs(vertex - prev_vertex)\n    #\n    # # Compute the area of the rectangle\n    # rectangles = set()\n    # for vertex in vertices:\n    #     for next_vertex in vertices[vertex]:\n    #         rectangles.add(Rectangle(vertex, next_vertex))\n    #\n    # # Compute the area of the rectangle\n    # rectangles_area = 0\n    # for rectangle in rectangles:\n    #     rectangles_area += rectangle.area()\n    #\n    # # Compute the area of the big square\n    # area = area / 4\n    #\n    # # Compute the expected value\n    # return str(rectangles_area + triangles_area + area)\n\n    n = int(stdin.readline())\n    polygon = []\n    for _ in range(n):\n        polygon.append(list(map(int, stdin.readline().split())))\n\n    # Make a vertex -> index map\n    vertices = {}\n    for vertex in polygon:\n        if vertex[0] not in vertices:\n            vertices[vertex[0]] = set()\n        if vertex[1] not in vertices:\n            vertices[vertex[1]] = set()\n\n        vertices[vertex[0]].add(vertex[1])\n        vertices[vertex[1]].add(vertex[0])\n\n    # Compute the polygon area\n    area = 0\n    for vertex in polygon:\n        area += vertex[0] * vertex[1]\n\n    # Find all triangles\n    triangles = set()\n    for vertex in vertices:\n        for next_vertex in vertices[vertex]:\n            for prev_vertex in vertices[vertex]:\n                if prev_vertex!= next_vertex:\n                    triangles.add(Triangle(vertex, next_vertex, prev_vertex))\n\n    # Compute the area of the triangle\n    triangles_area = 0\n    for triangle in triangles:\n        triangles_area += triangle.area()\n\n    # Compute the perimeter\n    perimeter = 0\n    for vertex in vertices:\n        for prev_vertex in vertices[vertex]:\n            perimeter += abs(vertex - prev_vertex)\n\n    # Compute the area of the rectangle\n    rectangles = set()\n    for vertex in vertices:\n        for next_vertex in vertices[vertex]:\n            rectangles.add(Rectangle(vertex, next_vertex))\n\n    # Compute the area of the rectangle\n    rectangles_area = 0\n    for rectangle in rectangles:\n        rectangles_area += rectangle.area()\n\n    # Compute the area of the big square\n    area = area / 4\n\n    # Compute the expected value\n    return str(rectangles_area + triangles_area + area)\n\n\nclass Triangle:\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def area(self):\n        return abs(0.5 * (self.b[0] * self.c[1] - self.b[1] * self.c[0] +\n                          self.a[0] * self.c[1] - self.a[1] * self.c[0] +\n                          self.a[0] * self.b[1] - self.a[1] * self.b[0]))\n\n\nclass Rectangle:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def area(self):\n        return abs(self.a[0] * self.b[1] - self.b[0] * self.a[1])\n\n\nfor _ in range(int(input())):\n    n = int(input())\n    polygon = []\n    for _ in range(n):\n        polygon.append(list(map(int, input().split())))\n\n    # Make a vertex -> index map\n    vertices = {}\n    for vertex in polygon:\n        if vertex[0] not in vertices:\n            vertices[vertex[0]] = set()\n        if vertex[1] not in vertices:\n            vertices[vertex[1]] = set()\n\n        vertices[vertex[0]].add(vertex[1])\n        vertices[vertex[1]].add(vertex[0])\n\n    # Compute the polygon area\n    area = 0\n    for vertex in polygon:\n        area += vertex[0] * vertex[1]\n\n    # Find all triangles\n    triangles = set()\n    for vertex in vertices:\n        for next_vertex in vertices[vertex]:\n            for prev_vertex in vertices[vertex]:\n                if prev_vertex!= next_vertex:\n                    triangles.add(Triangle(vertex, next_vertex, prev_vertex))\n\n    # Compute the area of the triangle\n    triangles_area = 0\n    for triangle in triangles:\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\\\n0 0\\\\n0 1\\\\n1 1\\\\n1 0\\\\n\")\n    0.733333333333333\n    \"\"\"\n    n = int(stdin)\n    cbd = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        cbd.append([x, y])\n\n    def dist(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    # Divide the points in the order of x then y.\n    # Use a stack to store the pairs of points.\n    stack = []\n    for i in range(n):\n        stack.append([cbd[i], cbd[(i + 1) % n]])\n    for i in range(n):\n        stack.append([cbd[i], cbd[(i - 1) % n]])\n\n    # Calculate the distance of every pair of points.\n    # Add them up to get the total distance.\n    total = 0\n    for i in range(n * 2):\n        total += dist(stack[i][0], stack[i][1])\n\n    # Calculate the expected distance.\n    return total / (n * 2)\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your runtime beats 89.59 % of python3 submissions.\"\"\"\n    if __name__ == '__main__':\n        input = stdin.splitlines()\n    return str(round(float(sum(abs(int(x)) + abs(int(y)) for x, y in [i.split() for i in input]) / 2), 6))\n\n\ndef"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the given input.\n\n    This solution expects that the input is valid.\n    \"\"\"\n    n = int(stdin)\n\n    # Build the points\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    # Get the CBD\n    cbd_points = points[:3]\n    cbd_points.sort()\n    cbd_points = [\n        cbd_points[0],\n        cbd_points[1],\n        cbd_points[2],\n    ]\n    cbd_points.append(cbd_points[0])\n    cbd_points = cbd_points[:3]\n\n    # Get the distance between every point and the CBD\n    distances = []\n    for point in points:\n        x1, y1 = point\n        x2, y2 = cbd_points[0]\n        distances.append(abs(x1 - x2) + abs(y1 - y2))\n        x2, y2 = cbd_points[1]\n        distances.append(abs(x1 - x2) + abs(y1 - y2))\n        x2, y2 = cbd_points[2]\n        distances.append(abs(x1 - x2) + abs(y1 - y2))\n        distances.append(abs(x1 - x2) + abs(y1 - y2))\n    distances.sort()\n\n    # Return the mean of the distances\n    return str(sum(distances) / len(distances))\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\"Your code here\"\"\"\n\ndef"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(coordinate: list, point: list):\n        x, y = coordinate\n        x_p, y_p = point\n        return x >= x_p and y <= y_p\n\n    def check_line(point: list, line: list):\n        return (point[0] - line[0]) * (point[1] - line[1]) == (point[0] - line[0]) * (point[0] - line[2])\n\n    def cross_product(line: list, point: list):\n        x_1, y_1, x_2, y_2 = line\n        x, y = point\n        return x_1 * y_2 - x_2 * y_1\n\n    def check_cross(point: list, line: list):\n        x_p, y_p = point\n        x_1, y_1, x_2, y_2 = line\n        return (x_2 - x_1) * (y_p - y_1) - (x_p - x_1) * (y_2 - y_1)\n\n    def form_lines(points):\n        points = list(set(points))\n        if len(points) < 3:\n            return []\n        lines = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if j == i:\n                    continue\n                for k in range(j + 1, len(points)):\n                    if k == j or k == i:\n                        continue\n                    lines.append([points[i], points[j], points[k]])\n        return lines\n\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split(' '))\n        points.append([x, y])\n    cbd = form_lines(points)\n    cross = 0\n    for i in range(len(cbd)):\n        for j in range(i + 1, len(cbd)):\n            if check_line(cbd[i], cbd[j]):\n                cross += 1\n    expected_distance = cross / (len(cbd) * (len(cbd) - 1))\n    print(f'{expected_distance:.6f}')\n    return ''\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    {\n        'name': 'queens',\n        'params': [4, 3],\n        'output_file': 'queens4.txt'\n    }\n    '''\n    \n    pass"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Line 1: N M K\n    # Line 2: Cost of each office\n    # Line 3: Cost of each office\n    # Line 4:...\n    # Line N: Cost of each office\n    # Line N+1:...\n    # Line 2*N+1: Cost of each corridor\n\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    costs = [list(map(int, stdin.split('\\n')[i].split())) for i in range(1, n + 1)]\n    corrs = [[] for _ in range(2 * n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            corrs[i + j].append((i, j))\n    print(corrs)\n\n    def cost(p):\n        return sum([costs[p[i]][p[i + 1]] for i in range(len(p) - 1)]) + k\n\n    mst = [set(corrs[0])]\n    for i in range(1, len(corrs)):\n        if cost(mst[-1] | set(corrs[i])) < cost(mst[-1]):\n            mst.pop()\n            mst.append(set(corrs[i]))\n    print(cost(mst[-1]))\n\n    return ''\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return f\"{solution_base(stdin)}\"\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This solution currently takes ~4 seconds\"\"\"\n    import math\n    n, m, k = list(map(int, stdin.split()))\n    cost = list(map(int, stdin.split()))\n    cost_matrix = [[cost[i + j*m] for i in range(m)] for j in range(n)]\n    \n    dp = [[math.inf]*(m+1) for _ in range(n+1)]\n    dp[1][1] = 0\n    dp[1][2] = k\n    for i in range(1, m):\n        dp[1][i+1] = dp[1][i] + cost_matrix[0][i]\n    for i in range(1, n):\n        dp[i+1][1] = dp[i][1] + cost_matrix[i][0]\n        \n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + cost_matrix[i-1][j-1]\n    return dp[n][m]"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split(' '))\n    cost = [[0] * m for _ in range(n)]\n    for i in range(n):\n        cost[i] = list(map(int, stdin.split('\\n')[i + 1].split(' ')))\n    memo = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(1, m + 1):\n                memo[i][j] = min(memo[i][j], memo[i - 1][j - 1] + cost[i - 1][x - 1])\n    return memo[-1][-1]\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    def is_corridor_safe(row, col):\n        return all(\n            [\n                (row, col) not in map_router,\n                (row, col - 1) not in map_router,\n                (row, col + 1) not in map_router,\n            ]\n        )\n\n    def is_corridor_w_router(row, col):\n        return (\n            ((row, col) in map_router)\n            or ((row, col - 1) in map_router)\n            or ((row, col + 1) in map_router)\n        )\n\n    def is_corridor_w_router_and_cell_hub(row, col):\n        return (\n            (row, col) in map_router\n            or (row, col - 1) in map_router\n            or (row, col + 1) in map_router\n            or (row, col - 1, col, row + 1) in map_router\n        )\n\n    def is_corridor_w_cell_hub(row, col):\n        return (\n            ((row, col) in map_router)\n            or ((row, col - 1) in map_router)\n            or ((row, col + 1) in map_router)\n            or ((row, col - 1, col, row + 1) in map_router)\n        )\n\n    def is_corridor_w_router_and_cell_hub_and_hub(row, col):\n        return (\n            (row, col) in map_router\n            or (row, col - 1) in map_router\n            or (row, col + 1) in map_router\n            or (row, col - 1, col, row + 1) in map_router\n            or (row, col, row + 1, col + 1) in map_router\n        )\n\n    def cost(row, col):\n        if row == 0:\n            return abs(0 - col)\n        elif col == 0:\n            return abs(0 - row)\n        elif row == N - 1:\n            return abs(M - col)\n        elif col == M - 1:\n            return abs(M - row)\n        else:\n            if is_corridor_safe(row, col):\n                return abs(0 - row) + abs(0 - col)\n            elif is_corridor_w_router(row, col):\n                return abs(0 - row) + abs(0 - col) + router_cost\n            elif is_corridor_w_router_and_cell_hub(row, col):\n                return abs(0 - row) + abs(0 - col) + router_cost + cell_hub_cost\n            elif is_corridor_w_router_and_cell_hub_and_hub(row, col):\n                return abs(0 - row) + abs(0 - col) + router_cost + cell_hub_cost + hub_cost\n            else:\n                return abs(0 - row) + abs(0 - col) + router_cost + cell_hub_cost + hub_cost + hub_cost\n\n    def find_cost(corridors, cost):\n        costs = [cost(i, j) for i, j in corridors]\n        return sum(costs)\n\n    N, M, K = [int(i) for i in stdin.readline().split()]\n    router_cost, cell_hub_cost, hub_cost = [int(i) for i in stdin.readline().split()]\n\n    map_router = {(i, j): 0 for i in range(N) for j in range(M)}\n    corridors = []\n    for i in range(N):\n        row = [int(i) for i in stdin.readline().split()]\n        for j in range(M):\n            if row[j] == 1:\n                corridors.append((i, j))\n        map_router.update({(i, j): 1 for j in range(M)})\n    min_cost = find_cost(corridors, cost)\n    for i in range(N):\n        for j in range(M):\n            if not (i == 0 or j == 0 or i == N - 1 or j == M - 1):\n                map_router.update({(i, j): 1})\n                new_cost = find_cost(corridors, cost)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                map_router.update({(i, j): 0})\n    return min_cost\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    (n, m, k) = [int(i) for i in stdin.split('\\n')[:3]]\n    costs = [[int(i) for i in stdin.split('\\n')[i + 1:i + m + 1]] for i in range(n)]\n    print(costs)\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = costs[0][0]\n    for i in range(m):\n        dp[0][i] = costs[0][i] + dp[0][i - 1]\n    for i in range(n):\n        dp[i][0] = costs[i][0] + dp[i - 1][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            if costs[i][j] == 0:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n            else:\n                dp[i][j] = min(dp[i - 1][j] + costs[i][j], dp[i][j - 1] + costs[i][j])\n    print(dp)\n    return dp[n - 1][m - 1]\n\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    stdin = stdin.split()\n    N, M, K = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    cost_list = []\n    for _ in range(N):\n        cost_list.append(list(map(int, stdin[3 + _].split())))\n    print(cost_list)\n    return str(solve(cost_list, N, M, K))\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(x) for x in stdin.split('\\n')[:3]]\n    R = [[int(x) for x in stdin.split('\\n')[i + 3: i + 3 + M]] for i in range(0, N * M, M)]\n    s = 0\n    for i in range(N):\n        for j in range(M):\n            if R[i][j]!= 0:\n                s += R[i][j]\n    return s - K * N * M\n\n\ndef"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Approach: Greedy\n    Time Complexity: O(N)\n    Space Complexity: O(1)\n    '''\n\n    N, M, K = map(int, stdin.split())\n\n    costs = [list(map(int, stdin.split())) for _ in range(N)]\n\n    for i in range(N):\n        for j in range(M):\n            if costs[i][j] > K:\n                costs[i][j] = 0\n    \n    for i in range(N):\n        for j in range(M):\n            if i > 0 and costs[i][j] > costs[i - 1][j]:\n                costs[i][j] += costs[i - 1][j]\n            if j > 0 and costs[i][j] > costs[i][j - 1]:\n                costs[i][j] += costs[i][j - 1]\n    \n    for i in range(N - 1, -1, -1):\n        for j in range(M - 1, -1, -1):\n            if i < N - 1 and costs[i][j] > costs[i + 1][j]:\n                costs[i][j] += costs[i + 1][j]\n            if j < M - 1 and costs[i][j] > costs[i][j + 1]:\n                costs[i][j] += costs[i][j + 1]\n    \n    return str(costs[0][0])"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # create matrix\n    n, m, t, op = [int(s) for s in stdin.split()]\n    matrix = [['.'] * n for i in range(n)]\n\n    # fill the matrix\n    for i in range(0, m):\n        r, c = [int(s) for s in stdin.split()]\n        matrix[r][c] = '*'\n\n    # check if each row and column is valid\n    for i in range(0, n):\n        if (not is_valid(matrix[i])):\n            return 'Invalid'\n\n    # check if each quadrant is valid\n    for i in range(0, int(n / 2) + 1):\n        for j in range(0, int(n / 2) + 1):\n            if (not is_valid(matrix[i][j:j+int(n / 2)]) or\n                    not is_valid(matrix[i+int(n / 2)][j:j+int(n / 2)])):\n                return 'Invalid'\n\n    # count the valid ways\n    ways = 0\n    if op == '+':\n        ways = ways_addition(matrix, t)\n    elif op == '-':\n        ways = ways_subtraction(matrix, t)\n    elif op == '*':\n        ways = ways_multiplication(matrix, t)\n    else:\n        ways = ways_division(matrix, t)\n\n    return ways\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the number of solutions in a KenKen puzzle\"\"\"\n    # get the puzzle info\n    board_size, num_sections, target, operator = stdin.split()\n    board_size = int(board_size)\n    num_sections = int(num_sections)\n    target = int(target)\n    operator = operator[0]\n    # create a new puzzle board\n    board = PuzzleBoard(board_size)\n    # get the sections for the puzzle\n    for i in range(num_sections):\n        section = stdin.readline().split()\n        # get the section info\n        section_start = int(section[0]) - 1\n        section_size = int(section[1])\n        section_target = int(section[2])\n        # add the section to the puzzle\n        board.add_section(section_start, section_size, section_target, operator)\n    # get the list of valid solutions\n    solutions = board.solve()\n    return str(len(solutions))\n\n\nclass PuzzleBoard:\n    \"\"\"A KenKen Puzzle board\"\"\"\n\n    def __init__(self, size: int):\n        \"\"\"Initialize the puzzle board\"\"\"\n        self.size = size\n        self.board = [[\"\" for _ in range(size)] for _ in range(size)]\n\n    def __str__(self):\n        \"\"\"String representation of the puzzle\"\"\"\n        return \"\\n\".join(\" \".join(row) for row in self.board)\n\n    def add_section(self, start: int, size: int, target: int, operator: str):\n        \"\"\"Add a section to the puzzle\"\"\"\n        # get the starting row and column\n        row, col = start // self.size, start % self.size\n        # add the section to the puzzle\n        self.board[row][col] = Section(self.board[row][col], size, target, operator)\n        # add the section to the rows and columns that it shares a side with\n        for col in range(size):\n            self.board[row][col].add_section(self, row, col, target, operator)\n        for row in range(size):\n            self.board[row][col].add_section(self, row, col, target, operator)\n\n    def solve(self):\n        \"\"\"Solve the puzzle\"\"\"\n        # create a list of all the possible solutions\n        solutions = []\n        # create a set of solutions\n        solution_set = set()\n        # explore all the sections\n        for section in self.board:\n            # for each section explore all the possible solutions\n            for solution in section.solve():\n                # if this solution is not yet in the set, add it\n                if solution not in solution_set:\n                    solution_set.add(solution)\n                    solutions.append(solution)\n        return solutions\n\n\nclass Section:\n    \"\"\"A section of the puzzle board\"\"\"\n\n    def __init__(self, section: str, size: int, target: int, operator: str):\n        \"\"\"Initialize the section\"\"\"\n        self.section = section\n        self.size = size\n        self.target = target\n        self.operator = operator\n\n    def __str__(self):\n        \"\"\"String representation of the section\"\"\"\n        return self.section + \" \" + str(self.target) + \" \" + self.operator\n\n    def add_section(self, puzzle: PuzzleBoard, row: int, col: int, target: int, operator: str):\n        \"\"\"Add a section to the given puzzle\"\"\"\n        # get the section that is on this side of the current section\n        section = puzzle.board[row][col]\n        # if the current section is not empty\n        if section!= \"\":\n            # if the section and this section have the same operator and target, join them\n            if section.operator == operator and section.target == target:\n                self.section = section.section + section.section\n            # otherwise, add a new section\n            else:\n                self.section = str(self.target) + \" \" + self.operator + \" \" + str(self.target)\n        # otherwise add a new section\n        else:\n            self.section = str(self.target) + \" \" + self.operator + \" \" + str(self.target)\n        self.target = target\n        self.operator = operator\n\n    def solve(self):\n        \"\"\"Get all the possible solutions for the section\"\"\"\n        # if the section is empty, return a single solution\n        if self.section == \"\":\n            yield [self.target]\n        # otherwise get all the possible solutions\n        else:\n            # for each digit\n            for digit in range(1, self.size + 1):\n                # if the digit is in the solution, add it to the solution\n                if str(digit) in self.section:\n                    yield from self.sub_solve(digit)\n\n    def sub_solve(self, digit):\n        \"\"\"Get all the possible solutions for the sub-section\"\"\"\n        # if the sub-section is empty, return a single solution\n        if self.section == \"\":\n            yield [digit]\n        # otherwise get all the possible solutions\n        else:\n            # for each sub-section\n            for sub_section in range(self.size ** 2):\n                # if the digit is in the sub-section, add it to the solution\n                if str(digit) in self.section[sub_section]:\n                    yield from self.sub_solve(digit)\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"solution\"\"\"\n    n, m, t, op = [int(x) for x in stdin.split(' ')]\n    grid = []\n    for i in range(m):\n        grid.append(stdin[m*i+1+i].split(' '))\n    result = 0\n    return result\n"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    n, m, t, op = stdin.split(' ')\n    n, m, t, op = int(n), int(m), int(t), op\n    grid = [stdin.split('\\n')[1:]]\n    # print(grid)\n    row_len = len(grid[0][0])\n    if n < 4 or n > 9:\n        return 0\n    if m < 2 or m > 10:\n        return 0\n    if t < 0 or t > 3 * 10 ** 8:\n        return 0\n    if op!= '+' and op!= '-':\n        if op!= '*' and op!= '/':\n            return 0\n    if op == '+':\n        op = '+'\n    elif op == '-':\n        op = '-'\n    elif op == '*':\n        op = '*'\n    else:\n        op = '/'\n    # print(op)\n\n    grid_row_list = [[0 for i in range(row_len)] for i in range(n)]\n    grid_col_list = [[0 for i in range(n)] for i in range(n)]\n    for row in range(n):\n        for col in range(n):\n            grid_row_list[row][int(grid[0][row][col]) - 1] += 1\n            grid_col_list[col][int(grid[0][row][col]) - 1] += 1\n\n    # print(grid_row_list)\n    # print(grid_col_list)\n    for row in range(n):\n        for col in range(n):\n            for i in range(row + 1, n):\n                if grid_row_list[row][int(grid[0][row][col]) - 1]!= 1:\n                    break\n                if grid_row_list[i][int(grid[0][i][col]) - 1]!= 1:\n                    break\n                if op == '+':\n                    if (grid[0][row][col] + grid[0][i][col])!= int(grid[0][i][col]):\n                        break\n                elif op == '-':\n                    if (grid[0][row][col] - grid[0][i][col])!= int(grid[0][i][col]):\n                        break\n                elif op == '*':\n                    if (grid[0][row][col] * grid[0][i][col])!= int(grid[0][i][col]):\n                        break\n                else:\n                    if (int(grid[0][row][col]) / grid[0][i][col])!= int(grid[0][i][col]):\n                        break\n                if i == n - 1:\n                    return 1\n\n            for i in range(col + 1, n):\n                if grid_col_list[row][int(grid[0][row][col]) - 1]!= 1:\n                    break\n                if grid_col_list[row][i]!= 1:\n                    break\n                if op == '+':\n                    if (grid[0][row][col] + grid[0][row][i])!= int(grid[0][row][i]):\n                        break\n                elif op == '-':\n                    if (grid[0][row][col] - grid[0][row][i])!= int(grid[0][row][i]):\n                        break\n                elif op == '*':\n                    if (grid[0][row][col] * grid[0][row][i])!= int(grid[0][row][i]):\n                        break\n                else:\n                    if (int(grid[0][row][col]) / grid[0][row][i])!= int(grid[0][row][i]):\n                        break\n                if i == n - 1:\n                    return 1\n\n    return 0\n\nprint(solution(\"8 2 7 -\\n1 1 1 2\\n\"))\n"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = [int(i) for i in stdin.split()]\n    assert n <= 9\n    assert 2 <= m <= 10\n    assert 0 < t <= 3 * 10 ** 8\n    assert '+' == op or '-' == op or '*' == op or '/' == op\n    assert '\\n' not in stdin\n    assert n == len(stdin.splitlines())\n    assert m == len(stdin.splitlines()[0].split())\n    if n == 1:\n        return 1\n    else:\n        if op == '+':\n            return solve(n, m, t, '+', 0, 0)\n        elif op == '-':\n            return solve(n, m, t, '-', 0, 0)\n        elif op == '*':\n            return solve(n, m, t, '*', 0, 0)\n        else:\n            return solve(n, m, t, '/', 0, 0)\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m, t, op = stdin.split(' ')\n    n, m, t, op = int(n), int(m), int(t), op\n    rows = []\n    for _ in range(m):\n        rows.append(stdin.split('\\n')[1:])\n    return rows\n\nrows = solution(stdin)"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(test_str)\n    True\n    \"\"\"\n    _, _, _, arithmetic_operator = stdin.split(\" \")\n\n    n, m = map(int, stdin.split(\" \"))\n    section = []\n    r = 0\n    c = 0\n\n    for line in stdin.split(\"\\n\")[2:]:\n        if line:\n            r, c = map(int, line.split(\" \"))\n            section.append((r, c))\n\n    return solve(n, m, section, arithmetic_operator)\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    total = 0\n    # Get the size of the KenKen puzzle\n    size, lines = stdin.split(\"\\n\")[0:2]\n    size = int(size)\n    # Get the sections\n    for section in lines.split(\"\\n\")[1:]:\n        # Get the grid squares\n        square_a, square_b = section.split(\" \")\n        # Get the starting point and ending point\n        start_a = tuple(map(int, square_a.split(\",\")))\n        end_a = tuple(map(int, square_b.split(\",\")))\n        # Get the size of the section\n        size_a = abs(start_a[0] - end_a[0]) + abs(start_a[1] - end_a[1])\n        total += size_a - 1\n    return total"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your code goes here.\"\"\"\n    pass\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve the problem.\"\"\"\n    return \"Case #{}: {}\".format(_ + 1, solve(stdin))\n\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    d: dictionary to count how many shortest paths contain a certain road\n    \"\"\"\n    N, M = stdin.split(' ')\n    N, M = int(N), int(M)\n    d = {}\n    for _ in range(M):\n        o, d, l = stdin.split(' ')\n        l = int(l)\n        if o not in d:\n            d[o] = 0\n        if d not in d:\n            d[d] = 0\n        if o in d and d in d:\n            d[o] += 1\n            d[d] += 1\n    print(d[1])\n    return ''"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the input and computes the solution.\"\"\"\n    N, M = [int(n) for n in stdin.split()]\n    roads = []\n    for i in range(M):\n        roads.append([int(n) for n in stdin.split()])\n    roads.sort()\n    # used to keep track of shortest paths\n    # (number of paths, list of cities)\n    distinct_paths = [([], [])]\n    # list of cities used\n    visited = []\n    for road in roads:\n        road.append(road[1] - road[0])\n    for road in roads:\n        if road[1] not in visited:\n            # list of cities used\n            visited.append(road[1])\n            # we don't care about the ones already used\n            road.append(0)\n            # we add the current city to the list\n            # the number of shortest paths\n            # containing this road\n            distinct_paths.append([0, [road[0], road[1]]])\n            # we add this road to the shortest paths\n            # containing this road\n            for i in range(len(distinct_paths) - 1):\n                if road[0] in distinct_paths[i][1]:\n                    distinct_paths[i][0] += 1\n            # we add the length of this road\n            # to the shortest paths containing\n            # this road\n            for i in range(len(distinct_paths) - 1):\n                if road[1] in distinct_paths[i][1]:\n                    distinct_paths[i][0] += road[2]\n        else:\n            # we add the length of this road\n            # to the shortest paths containing\n            # this road\n            for i in range(len(distinct_paths) - 1):\n                if road[1] in distinct_paths[i][1]:\n                    distinct_paths[i][0] += road[2]\n    # we check whether we have found all the shortest paths\n    # for each road\n    for road in roads:\n        road.append(0)\n    # we add the number of shortest paths for each road\n    for i in range(len(roads)):\n        roads[i].append(distinct_paths[i][0])\n    roads.sort()\n    for road in roads:\n        if road[3] > 0:\n            print(road[3])\n\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve the problem\"\"\"\n    # Generate graph of paths\n    pass"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = [int(x) for x in stdin.split('\\n') if x!= '']\n    inputs.sort()\n    ans = 0\n    for i in range(1, inputs[-1] + 1):\n        temp = 1\n        for j in range(1, len(inputs)):\n            if inputs[j] >= i:\n                temp = 0\n                break\n            if inputs[j] > i + 1 and inputs[j] - inputs[j - 1] <= inputs[j - 1]:\n                temp = 0\n                break\n        ans += temp\n    print(ans)\n    return ans\n\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Modulo 1000001077\n    # Modulo 1000000 - pow(10, 7)\n    pass\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 3\\n1 2 5\\n2 3 5\\n3 4 5\\n1 4 8\\n\")\n    '3\\n4\\n3'\n    \"\"\"\n\n    n, m = [int(x) for x in stdin.split()]\n    roads = [None for _ in range(m)]\n    for i in range(m):\n        start, end, length = [int(x) for x in stdin.split()]\n        roads[i] = {\n            \"start\": start,\n            \"end\": end,\n            \"length\": length,\n            \"count\": 0,\n            \"counts\": []\n        }\n    graph = [[] for _ in range(n)]\n    for road in roads:\n        graph[road[\"start\"] - 1].append(road)\n\n    counts = {}\n    count = 0\n    for node in graph:\n        if len(node) > 0:\n            count += 1\n            counts[count] = []\n            for road in node:\n                road[\"count\"] = count\n                road[\"counts\"].append(count)\n                counts[count].append(road)\n\n    for road in roads:\n        start = road[\"start\"]\n        end = road[\"end\"]\n        for r in counts[road[\"count\"]]:\n            if r[\"start\"] == start and r[\"end\"] == end:\n                counts[road[\"count\"]].remove(r)\n                break\n\n    for road in roads:\n        for r in counts[road[\"count\"]]:\n            if r[\"start\"] == road[\"end\"]:\n                r[\"counts\"].append(road[\"count\"])\n                break\n\n    counts = {}\n    for node in graph:\n        if len(node) > 0:\n            count += 1\n            counts[count] = []\n            for road in node:\n                if road[\"count\"] not in counts[road[\"count\"]]:\n                    counts[road[\"count\"]].append(road[\"count\"])\n\n    paths = {}\n    for road in roads:\n        start = road[\"start\"]\n        end = road[\"end\"]\n        paths[road[\"count\"]] = {\n            \"count\": road[\"count\"],\n            \"paths\": set()\n        }\n        paths[road[\"count\"]][\"paths\"].add(road[\"count\"])\n        for r in counts[road[\"count\"]]:\n            if r not in paths[road[\"count\"]][\"paths\"]:\n                paths[road[\"count\"]][\"paths\"].add(r)\n\n    for road in roads:\n        start = road[\"start\"]\n        end = road[\"end\"]\n        if road[\"count\"] in paths:\n            for r in paths[road[\"count\"]][\"paths\"]:\n                if road[\"count\"] not in paths[r][\"paths\"]:\n                    for r2 in paths[r][\"paths\"]:\n                        if road[\"count\"] not in paths[r2][\"paths\"]:\n                            paths[road[\"count\"]][\"paths\"].add(r2)\n                            paths[road[\"count\"]][\"paths\"].add(road[\"count\"])\n\n    for r in paths:\n        for r2 in paths[r][\"paths\"]:\n            for r3 in paths[r2][\"paths\"]:\n                if r not in paths[r3][\"paths\"]:\n                    paths[r3][\"paths\"].add(r)\n                    paths[r3][\"paths\"].add(r2)\n\n    for r in roads:\n        start = r[\"start\"]\n        end = r[\"end\"]\n        if road[\"count\"] in paths:\n            for r2 in paths[road[\"count\"]][\"paths\"]:\n                if road[\"count\"] not in paths[r2][\"paths\"]:\n                    for r3 in paths[r2][\"paths\"]:\n                        if road[\"count\"] not in paths[r3][\"paths\"]:\n                            for r4 in paths[r3][\"paths\"]:\n                                if road[\"count\"] not in paths[r4][\"paths\"]:\n                                    paths[road[\"count\"]][\"paths\"].add(r4)\n                                    paths[road[\"count\"]][\"paths\"].add(r3)\n\n    ans = []\n    for r in roads:\n        start = r[\"start\"]\n        end = r[\"end\"]\n        count = r[\"count\"]\n        for r2 in paths[count][\"paths\"]:\n            if r2 not in paths[count][\"paths\"]:\n                for r3 in paths[count][\"paths\"]:\n                    if r2 not in paths[count][\"paths\"]:\n                        for r4 in paths[count][\"paths\"]:\n                            if r2 not in paths[count][\"paths\"]:\n                                for r5 in paths[count][\"paths\"]:\n                                    if r2 not in paths[count][\"paths\"]:\n                                        for r6 in paths[count][\"paths\"]:\n                                            if r2 not in paths[count][\"paths\"]:\n                                                for r7 in paths[count][\"paths\"]:\n                                                    if r2 not in paths[count][\"paths\"]:\n                                                        for r8 in paths[count][\"paths\"]:\n                                                            if r2 not in paths[count][\"paths\"]:\n                                                                for r9 in paths[count][\"paths\"]:\n                                                                    if r2 not in paths[count][\"paths\"]:\n                                                                        for r10 in paths[count][\"paths\"]:\n                                                                            if r2 not in paths[count][\"paths\"]:\n                                                                                ans.append(r[\"count\"])\n\n    return \"\\n\".join([str(x) for x in ans])\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def search_path(start,dest,visited,search_path_length):\n        if start == dest:\n            return 1\n        visited.add(start)\n        paths = 0\n        for road in roads:\n            if road[0] == start and road[1] not in visited:\n                paths += search_path(road[1],dest,visited,search_path_length + road[2])\n        visited.remove(start)\n        return paths\n    def count_paths(start,end,visited,search_path_length):\n        if start == end:\n            return 1\n        paths = 0\n        for road in roads:\n            if road[0] == start and road[1] not in visited:\n                paths += search_path(road[1],end,visited,search_path_length + road[2])\n        return paths\n    n,m = map(int,stdin.split(' '))\n    roads = [map(int,stdin.readline().split()) for _ in range(m)]\n    counts = []\n    for road in roads:\n        counts.append(count_paths(road[0],road[1],set(),road[2]))\n    return '\\n'.join(map(str,counts))\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes in the standard input and outputs the number of different shortest paths\n    \"\"\"\n    # Split the input into a list of lists, each list represents a road\n    roads = [list(map(int, road.strip().split(' '))) for road in stdin.split('\\n')]\n    # Sort the roads in descending order of their length\n    roads.sort(key = lambda x: x[2], reverse = True)\n    # Create a matrix where each row is a city and each column is a city.\n    # The value at a position represents the shortest path length from that city to the other city\n    matrix = [[0 for _ in range(len(roads))] for _ in range(len(roads))]\n    # For each road, go through all cities and update the matrix\n    for road in roads:\n        # Update the matrix from the destination city to the origin city\n        matrix[road[1]-1][road[0]-1] = road[2]\n        # Update the matrix from the origin city to the destination city\n        matrix[road[0]-1][road[1]-1] = road[2]\n    # For each city in the matrix, calculate the number of different shortest paths to every other city\n    for i in range(len(matrix)):\n        for j in range(len(matrix)):\n            for k in range(len(matrix)):\n                # Only update the number of different shortest paths if the length is less than the current one\n                if matrix[i][j] <= matrix[i][k] + matrix[k][j]:\n                    matrix[i][j] = matrix[i][k] + matrix[k][j]\n    # Return the sum of the values in the last row\n    return sum(matrix[-1]) % 1000000007"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the number of shortest paths for each road in the road network\n    \"\"\"\n   ...\n    #return \"\""
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    _, k = list(map(int, stdin.split(' ')))\n    numbers = list(map(int, stdin.split(' ')))\n    return str(calculate(k, numbers))\n\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 4\n   ... 2 3 1''')\n    24\n\n    >>> solution('''2 3\n   ... 2 1''')\n    6\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    [N, K] = [int(i) for i in stdin.split()]\n    f = [int(i) for i in stdin.split()[1:]]\n    # s = [i for i in range(1, N+1)]\n    s = {}\n    n = 1\n    for i in range(1, N+1):\n        s[i] = n\n        n += 1\n    s[N+1] = 1\n    for i in range(N-1, 0, -1):\n        for j in range(i+1, N+1):\n            if (f[i-1] == j) or (f[i-1]!= j and f[i] == j):\n                s[i] = (s[i] + s[j]) % 1000000007\n    return s[1]\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This is the solution function, you can just jump right into here.\n    '''\n    # define variables\n    n, k = [int(i) for i in stdin.split()]\n    f = [int(i) for i in stdin.split()]\n    # create a variable to store the result\n    solution = 0\n    # create a variable to store the result of product of pascal's triangle\n    pascal_result = 1\n    # loop over the length of f\n    for i in range(len(f)):\n        # create a variable to store the number of times the index of f is repeated\n        times_f_i_repeated = f.count(f[i])\n        # create a variable to store the number of times the index is different than the index of f\n        times_f_i_different = n - times_f_i_repeated\n        # multiply the number of times f_i is repeated by the number of times the index is different\n        solution += (pascal_result * times_f_i_repeated * times_f_i_different)\n        # add the result of the product of the pascal's triangle to the variable\n        pascal_result *= (f[i] - 1) / (f[i] - 2)\n        # remove the index of f from the list\n        f.remove(f[i])\n    # return the solution variable\n    return solution % 1000000007\n\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split(' ')))\n    colors = list(map(int, stdin.split(' ')))\n    counter = [1]\n    for i in range(1, n):\n        counter.append(0)\n        for j in range(0, k):\n            if colors[i]!= colors[i - 1] and colors[i]!= j:\n                counter[i] += counter[i - 1]\n    return str(counter[n - 1])\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin.split('\\n')[0].split(' ')[0]) * int(stdin.split('\\n')[0].split(' ')[1]))\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (n, k) = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    colors.sort()\n\n    s = sum(map(lambda x: (x - 1) * (k - 1), colors))\n    return s\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N, K = map(int, stdin.split())\n    freq = [int(i) for i in stdin.split()[1:]]\n    mod = 1000000007\n    dp = [[0 for j in range(K + 1)] for i in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if j - freq[i - 1] >= 0:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - freq[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[N][K] % mod\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t = [int(i) for i in stdin.readline().strip().split()]\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % (10**9 + 7)\n    return dp[-1]\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    size = int(stdin)\n    chars = stdin.split()\n    return str(int(math.factorial(size) / (math.factorial(2) * math.factorial(size - 2))))\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the number of ways of arranging a group dance\n\n    Args:\n        stdin (str): the input string\n\n    Returns:\n        str: the output string\n    \"\"\"\n    # get input\n    # number of performers\n    # number of chairs\n    # list of chairs\n    n = int(stdin[0])\n    # list of chairs\n    chairs = [int(x) for x in stdin[1:].split(\" \")]\n    # dictionary of possible movements\n    # key is chair number\n    # value is list of chair numbers\n    possible_moves = {}\n    for chair in chairs:\n        if chair not in possible_moves:\n            possible_moves[chair] = []\n    for chair in chairs:\n        if chair!= 1:\n            if chair + 1 in possible_moves:\n                possible_moves[chair + 1].append(chair)\n            if chair - 1 in possible_moves:\n                possible_moves[chair - 1].append(chair)\n    # number of possible moves\n    possible_move_count = 0\n    for chair, moves in possible_moves.items():\n        possible_move_count += len(moves)\n    # we can also travel in a circle\n    possible_move_count += 1\n    # we can also travel in a circle\n    possible_move_count += 1\n    # return the answer\n    return str(possible_move_count % (10**9 + 7))\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\"\ndef"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = [int(x) for x in stdin.split('\\n')]\n    ans = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if a[i] > a[j]:\n                ans[i] += ans[j]\n    return ans[-1] % (10**9 + 7)\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    n = int(n)\n    t = stdin\n    t = t.split()\n    t = list(map(int, t))\n    t.sort()\n    count = 0\n    for i in range(n):\n        if t[i] == i + 1:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    n = int(stdin.split(\"\\n\")[0])\n    t = [int(item) for item in stdin.split(\"\\n\")[1].split(\" \")]\n\n    t.sort()\n    t.insert(0, 0)\n\n    s = [1 for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if t[i] > t[j]:\n                s[i] = (s[i] + s[j]) % (10 ** 9 + 7)\n\n    return str(s[n])"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = [int(i) for i in stdin.split(\"\\n\")[0].split()]\n    n = input_list[0]\n    t = input_list[1:]\n    performer = t[:]\n    chair = t[:]\n    performer_set = {i for i in range(1, n + 1)}\n    chair_set = {i for i in range(1, n + 1)}\n    performer_set.remove(1)\n    chair_set.remove(1)\n    ans = 1\n    for i in range(n - 1):\n        ans = ans * (n - i)\n        ans = ans % (10 ** 9 + 7)\n        for j in range(len(performer)):\n            performer[j] = chair[j]\n        for j in range(len(chair)):\n            chair[j] = performer[j]\n    return ans\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This function computes the number of ways in which the values of $s_ i$ can be chosen.\n\n    Parameters\n    ----------\n    stdin: str\n        Input string given by standard input.\n\n    Returns\n    -------\n    str\n        Output string that contains the answer to the problem.\n    \"\"\"\n\n    # Solution\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is\n    #   possible if it's the number of ways in which the values of $s_ i - 1$ can be chosen + 1\n    # This formula is a combinatorial problem. Let's solve it using dynamic programming.\n    #\n    #   1. initialize the array of possible values of the array.\n    #   2. Loop through all possible values of $s_ i$:\n    #       2.1. if the value is possible, then the value of the current value is the value of the value of $s_ i - 1$ plus 1.\n    #       2.2. if the value is not possible, then the value of the current value is the value of the value of $s_ i - 1$\n    #   3. return the last value in the array.\n    #\n    #\n    #   1. if we can take 1 hop, then there are 2 possible values of the array.\n    #   2. if we can take 2 hops, then there are 2 possible values of the array.\n    #   3. if we can take 3 hops, then there are 2 possible values of the array.\n    #   4. if we can take 4 hops, then there are 2 possible values of the array.\n    #   5. if we can take 5 hops, then there is 1 possible value of the array.\n    #   6. if we can take 6 hops, then there is 1 possible value of the array.\n    #   7. if we can take 7 hops, then there is 1 possible value of the array.\n    #   8. if we can take 8 hops, then there is 1 possible value of the array.\n    #   9. if we can take 9 hops, then there is 1 possible value of the array.\n    #  10. if we can take 10 hops, then there is 1 possible value of the array.\n    #\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10\n    #   5. 10\n    #   6. 10\n    #   7. 10\n    #   8. 10\n    #   9. 10\n    #   10. 10\n    #\n    # The number of ways in which the values of $s_ i$ can be chosen is:\n    #   1. 10\n    #   2. 10\n    #   3. 10\n    #   4. 10"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n    _ = int(input())\n    arr = list(map(int, input().split()))\n    return str(gcd(*arr))\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return''.join(map(str, rst))\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, s = [int(x) for x in stdin.split(' ')]\n    matrix = [\n        [int(x) for x in stdin.split(' ')]\n        for _ in range(r)\n    ]\n    # initialize cool matrix\n    cool_matrix = [[False for _ in range(s)] for _ in range(r)]\n\n    # iterate matrix\n    max_coolness = 0\n    for row in range(r):\n        for col in range(s):\n            cool_matrix[row][col] = cool_down_for_cell(matrix, row, col)\n            max_coolness = max(max_coolness, cool_matrix[row][col])\n\n    return max_coolness"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(stdin.splitlines()[0].split()))\n\ndef"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, S = [int(i) for i in stdin.split(\" \")]\n    A = []\n    for i in range(R):\n        A.append([int(i) for i in stdin.split(\" \")])\n    def is_cool(r, s):\n        return sum(A[r][s]) <= sum([max(A[r][j], A[i][s]) for j, i in enumerate(range(r, R))])\n    def is_extremely_cool(r, s):\n        for i in range(r, R):\n            if not is_cool(i, s):\n                return False\n        for i in range(s, S):\n            if not is_cool(r, i):\n                return False\n        return True\n    counter = 0\n    for i in range(R):\n        for j in range(S):\n            if is_extremely_cool(i, j):\n                counter += 1\n    return str(counter)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return str(max_cool_submatrix(stdin))"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the maximum number of elements in an extremely cool submatrix of the given matrix.\n\n    Parameters:\n    stdin (str): input string\n\n    Returns:\n    str: output string\n    \"\"\"\n    # Your code here\n    # return \"\"\n    r, s = map(int, stdin.split())\n    matrix = []\n    for _ in range(r):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    greatest = 0\n    for i in range(r):\n        for j in range(s):\n            row_elements = []\n            col_elements = []\n            for x in range(i, r):\n                row_elements.append(matrix[x][j])\n            for y in range(j, s):\n                col_elements.append(matrix[i][y])\n            greatest = max(greatest, find_greatest(row_elements, col_elements))\n    if greatest == 0:\n        return 0\n    else:\n        return greatest\n\n\ndef"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def row_max(stdin):\n        ans = [0]*N\n        for _, i in enumerate(stdin):\n            ans[i] = max(ans[i], int(i))\n        return ans\n    def col_max(stdin):\n        ans = [0]*M\n        for _, i in enumerate(stdin):\n            ans[i] = max(ans[i], int(i))\n        return ans\n\n    N, M = map(int, stdin.readline().split())\n    matrix = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    r_max = row_max(stdin)\n    c_max = col_max(stdin)\n    for i in range(1, N):\n        for j in range(1, M):\n            ans = r_max[i] + c_max[j] - matrix[i][j]\n            if ans < 0:\n                ans = 0\n            if ans > max_ans:\n                max_ans = ans\n    return str(max_ans)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, S = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    A = [\n        [int(i) for i in stdin.split('\\n')[1:][s].split(' ')]\n        for s in range(R)\n    ]\n\n    def cool(r, s, r1, s1, r2, s2):\n        return (\n            A[r][s] + A[r1][s1]\n            <= A[r2][s2] + A[r][s]\n        )\n\n    def is_cool(r, s, r1, s1, r2, s2):\n        if r2 - r <= 1 or s2 - s <= 1:\n            return False\n        if r1 >= r and s1 >= s:\n            return False\n        if r2 <= r and s2 <= s:\n            return False\n        return cool(r, s, r1, s1, r2, s2)\n\n    def is_extremely_cool(r1, s1, r2, s2):\n        if r2 - r1 >= 2 and s2 - s1 >= 2:\n            for r in range(r1, r2 + 1):\n                for s in range(s1, s2 + 1):\n                    if not is_cool(r, s, r1, s1, r2, s2):\n                        return False\n        return True\n\n    def extreme_cool(r1, s1, r2, s2):\n        if r2 - r1 + 1 >= 2 and s2 - s1 + 1 >= 2:\n            for r in range(r1, r2 + 1):\n                for s in range(s1, s2 + 1):\n                    if is_extremely_cool(r, s, r2, s2):\n                        return True\n        return False\n\n    max_ = 0\n    for r in range(R):\n        for s in range(S):\n            if not extreme_cool(r, s, R - 1, S - 1):\n                continue\n            if is_extremely_cool(r, s, R - 1, S - 1):\n                max_ = max(max_, sum([\n                    A[r][s]\n                    for r in range(r, R)\n                    for s in range(s, S)\n                    if extreme_cool(r, s, R - 1, S - 1)\n                ]))\n    return str(max_ if max_ else 0)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(int(stdin.split()[0]))\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return solution\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    n = int(stdin.readline())\n    g = [list(map(int, stdin.readline().split())) for _ in range(n - 1)]\n    v = [int(x) for x in stdin.readline().split()]\n    res = 0\n    c = {j: set() for j in v}\n    for p, t in g:\n        c[v[p - 1]].add(v[t - 1])\n    visited = set()\n\n    def dfs(a: int, depth: int) -> None:\n        nonlocal res\n        if depth == n:\n            res += 1\n            return\n        for i in c[a]:\n            if i not in visited:\n                visited.add(i)\n                dfs(i, depth + 1)\n                visited.remove(i)\n    dfs(1, 0)\n    return res"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    def count_sets(arr):\n        # your code here\n        count = 0\n        for i in range(len(arr)-1):\n            for j in range(i+1, len(arr)):\n                if arr[i] + 1!= arr[j]:\n                    continue\n                for k in range(j+1, len(arr)):\n                    if arr[j] + 1!= arr[k] and arr[k] + 1!= arr[i]:\n                        break\n                else:\n                    count += 1\n        return count\n    arr = [int(i) for i in stdin.split()]\n    return str(count_sets(arr))"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 2 1 3 4\n   ... 1 2\n   ... 1 3\n   ... 3 4\n   ... ''')\n    '6'\n    \"\"\"\n    n = int(stdin.split('\\n')[0].strip())\n    v = [int(stdin.split('\\n')[1].strip().split(' ')[i]) for i in range(n)]\n    r = [int(stdin.split('\\n')[2].strip().split(' ')[i]) for i in range(n)]\n    v.sort()\n    ans = 0\n    for i in range(n):\n        if v[i]!= i + 1:\n            break\n        j = r[i] - 1\n        while j!= n and j >= i and v[j] - v[i]!= 1:\n            j = r[j] - 1\n        ans += j - i + 1\n    return str(ans)\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Decompose rules and count unique sets of jokes\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Number of unique sets of jokes\n    \"\"\"\n    n = int(stdin.split('\\n')[0])\n    relations = [set([int(x) for x in stdin.split('\\n')[1].split()]) for _ in range(n)]\n    jokes = {x for l in relations for x in l}\n    sets = []\n\n    for i in range(n):\n        for j in range(n):\n            if i!= j and (relations[i] & relations[j] == set()):\n                sets.append({i + 1, j + 1})\n    return len(jokes)\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1 - 64 ms\n    \"\"\"\n    def search(n):\n        if n == 1: return [[[1]]]\n        if n == 2: return [[[1, 2]], [[2, 1]]]\n        res = []\n        for r in search(n - 1):\n            i = 0\n            while i + len(r) < n:\n                res.append(r + [i + 1])\n                i += 1\n        return res\n\n    n = int(stdin.readline())\n    jokes = list(map(int, stdin.readline().split()))\n    res = []\n    for r in search(n):\n        jokes_set = set()\n        for i in r:\n            jokes_set |= set(jokes[i - 1:i + 1])\n        if len(jokes_set) == len(r):\n            res.append(r)\n    return len(res)\n    \"\"\"\n    # Solution 2 - 36 ms\n    def search(n):\n        if n == 1: return [[1]]\n        if n == 2: return [[1, 2], [2, 1]]\n        res = []\n        for r in search(n - 1):\n            i = 0\n            while i + len(r) < n:\n                res.append(r + [i + 1])\n                i += 1\n        return res\n\n    n = int(stdin.readline())\n    jokes = list(map(int, stdin.readline().split()))\n    res = 0\n    for r in search(n):\n        jokes_set = set()\n        for i in r:\n            jokes_set.add(jokes[i - 1])\n        if len(jokes_set) == len(r):\n            res += 1\n    return res\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes = int(stdin.readline().strip())\n    node_weights = [int(x) for x in stdin.readline().strip().split(' ')]\n    num_edges = int(stdin.readline().strip())\n    adjacency_list = {}\n    for edge in range(num_edges):\n        source, target = [int(x) for x in stdin.readline().strip().split(' ')]\n        if source in adjacency_list:\n            adjacency_list[source].append(target)\n        else:\n            adjacency_list[source] = [target]\n\n    num_groups = 0\n\n    for node in range(num_nodes):\n        # If we have already looked at all the children, we can go ahead and increment the group count.\n        if node not in adjacency_list:\n            num_groups += 1\n            continue\n        # We're still looking at children, so we should find all their children.\n        children = adjacency_list[node]\n        # We can then call the solution on the children, and use that to determine what to do next.\n        for child in children:\n            # We want to increment the group count if the child's weight is smaller than the previous node's weight.\n            if child < node_weights[node]:\n                num_groups += 1\n            # If the child's weight is equal to the node's weight, we can call the solution with the rest of the\n            # nodes.\n            elif child == node_weights[node]:\n                num_groups += solution(''.join(stdin.readline().strip()))\n            # If the child's weight is larger than the node's weight, we can call the solution on the rest of the\n            # nodes with the child's weight subtracted from the node's weight.\n            else:\n                num_groups += solution(''.join(stdin.readline().strip()), weight=node_weights[node] - child)\n\n    return str(num_groups)\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    You are given N, the number of people standing in a line for the party.\n    The i-th person (1-indexed) has a name and is sitting i-1 in the line.\n    Each person passes a sentence to the next person in the line.\n    The last person in the line has no sentence to pass to the next person.\n    The i-th person in the line has a sentence Ai\n    to pass to the person sitting i-1 in the line.\n    Each person can only pass one sentence.\n    Return the number of different sentences that the last person in the line passes to the first person in the line.\n    \"\"\"\n    return 0"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of different sets of jokes that comply to the previously listed constraints.\n    Time: O(n * m * m^2) ~= O(n * m^2)\n    \"\"\"\n    N = int(stdin.readline())\n    joke_types = [int(joke) for joke in stdin.readline().split()]\n    # adjacency list\n    adj = [set() for _ in range(N)]\n    for _ in range(N - 1):\n        A, B = map(int, stdin.readline().split())\n        adj[A - 1].add(B - 1)\n        adj[B - 1].add(A - 1)\n    superiors = [int(stdin.readline()) for _ in range(N - 1)]\n    res = 0\n    for super_idx, super_type in enumerate(superiors):\n        # each element can be made with the super_type only if the\n        # super_type is a superset of the curr_type\n        curr_type = joke_types[super_idx]\n        if not curr_type <= super_type:\n            continue\n        curr_joke_set = set()\n        # if there are more than one super_type, then it is invalid\n        if len(adj[super_idx]) > 1:\n            continue\n        # start from super_idx and traverse all the way to the end\n        curr_joke_set.add(super_idx)\n        curr_idx = adj[super_idx].pop()\n        while curr_idx!= super_idx:\n            curr_joke_set.add(curr_idx)\n            curr_idx = adj[curr_idx].pop()\n        # since the adjacency list only contains one super_type\n        # we can simply set the super_idx as the last one in the\n        # curr_joke_set\n        curr_joke_set.add(curr_idx)\n        # update res if curr_joke_set is different from the last one\n        last_joke_set = res % 1000000007\n        res = (res + 1) if curr_joke_set!= last_joke_set else res\n    return str(res)\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(\n        find_sets_of_jokes(\n            json.loads(stdin)\n        )\n    )\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, *queries = stdin.split('\\n')\n    q = int(q)\n    queries = [int(x) for x in queries]\n    x = []\n    for a, b in queries:\n        x.append(sum(count_x(a, b)))\n    return '\\n'.join([str(y) for y in x])\n\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def rec(a, b):\n        if a <= 1:\n            return a\n        if a <= b:\n            return a + rec(a - 1, b)\n        else:\n            return rec(a - 1, b)\n\n    rows = stdin.splitlines()\n    ans = []\n    for row in rows:\n        row = list(map(int, row.split()))\n        ans.append(rec(row[0], row[1]))\n    return '\\n'.join(map(str, ans))\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the exercise.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    r = []\n    for i in range(n):\n        r.append(list(map(int, stdin.readline().split())))\n\n    return r\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds out how many numbers from [A, B] there are on the table.\"\"\"\n    return"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''Finds the number of occurrences of a number in the table of a regular recursive relation.\n    \n    The table consists of infinite rows and infinite columns containing infinite numbers.\n    Each number in the table appears a finite number of times.\n    \n    The first cell of each row contains the ordinal number of that row.\n    \n    Args:\n        stdin (str): String containing the table.\n    Returns:\n        str: String containing the answer.\n    '''\n    return '\\n'.join(solution(stdin, 1, n) for n in map(int, stdin.splitlines()[1:]))\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5 10\")\n    2\n    \"\"\"\n    return \"7\"\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return The Answer for Each Query\"\"\"\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline().strip()\n    # The number of queries\n    queries = int(query)\n    # The number of queries\n    query = stdin.readline"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a solution to the\n    \"Tashwan Divided\" problem.\n\n    >>> solution(\"8\\n1 10\\n5 8\\n\")\n    \"18\\n8\"\n    \"\"\"\n    return \"\"\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(['2', '1 10'])\n    '18'\n    >>> solution(['3', '17 144'])\n    '265'\n    \"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n, k = [int(i) for i in stdin.split(' ')]\n    # points = [tuple(map(int, line.split(' '))) for line in stdin.split('\\n')[:n]]\n    n, k = [int(i) for i in stdin.split(' ')]\n    points = [tuple(map(int, line.split(' '))) for line in stdin.split('\\n')[:n]]\n    # Your code here\n    import numpy as np\n    np.random.seed(0)\n    edges = np.array(points)\n    rand_ind = np.random.choice(len(edges), k, replace=False)\n    vertices = edges[rand_ind]\n    return vertices[:, 0] * vertices[:, 1]\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        vertices.append((x, y))\n\n    vertices = sorted(vertices, key=lambda vertices: vertices[0])\n    vertices = [tuple(v[1:]) for v in vertices]\n\n    intersections = 0\n    for i in range(k):\n        if i == k - 1:\n            next_v = vertices[0]\n        else:\n            next_v = vertices[i + 1]\n        for v in vertices[:i + 1]:\n            if is_point_in_polygon(next_v, v):\n                intersections += 1\n    return intersections / (k - 1)\n\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # the number of points on the convex hull\n    n, k = map(int, stdin.readline().split())\n    # the convex hull\n    points = []\n    for _ in range(n):\n        x, y = map(float, stdin.readline().split())\n        points.append((x, y))\n\n    # sort the points lexographically\n    points = sorted(points)\n    # the convex hull\n    hull = []\n    # add the first point\n    hull.append(points[0])\n    # add the last point\n    hull.append(points[n - 1])\n    # find the leftmost point\n    leftmost = points[0]\n    for i in range(1, n):\n        while is_counterclockwise(leftmost, hull[-1], points[i]):\n            hull.pop()\n            if not len(hull):\n                break\n        hull.append(points[i])\n        leftmost = hull[0]\n\n    # compute the area of the convex hull\n    area = area_of_polygon(hull)\n    # compute the area of the piece of cake\n    area -= area_of_polygon(hull[0:k])\n    # return the area of the piece of cake\n    return f'{area:.6f}'\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(stdin)\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = list()\n    for _ in range(4):\n        a.append(list(map(float, stdin.split(\" \")[:2])))\n    a = sorted(a)\n\n    s = 0\n    for i in range(len(a) - 2):\n        s += (a[i + 1][0] - a[i][0]) * (a[i + 2][1] - a[i + 1][1]) - (a[i + 1][0] - a[i][0]) * (a[i + 2][1] - a[i][1])\n    return str(abs(s) / 2)\n\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(solution.__doc__)\n    '12.50000000'\n    \"\"\"\n    # Sides of triangle\n    a, b, c = stdin.split('\\n')\n    a, b, c = [float(side) for side in [a, b, c]]\n    # Perimeter of triangle\n    p = a + b + c\n    # Area of triangle\n    s = (a + b + c) / 2\n    # Area of triangle with perimeter (p)\n    area_p = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    # Area of triangles with sides (a, b, c)\n    area_abc = ((a * b * c) / 2)\n    return area_p - area_abc\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution\n    return str(s)\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4 3\n   ... 0 0\n   ... 1 1\n   ... 2 1\n   ... 1 0''')\n    '0.50000000'\n    >>> solution('''5 5\n   ... 0 4\n   ... 4 2\n   ... 4 1\n   ... 3 -1\n   ... -2 4''')\n    '12.50000000'\n    \"\"\"\n    n, k = tuple(map(int, stdin.split('\\n')[0].split(' ')))\n    points = [tuple(map(float, stdin.split('\\n')[i].split(' '))) for i in range(1, n + 1)]\n    points.append(points[0])\n    areas = [\n        (x0 * y1 - x1 * y0) / 2\n        for x0, y0 in zip(points[:-1], points[1:])\n        for x1, y1 in zip(points[:-1], points[1:])\n    ]\n    print(f\"{sum(areas[:k]) / k:.6f}\")\n    return \"\"\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution function\"\"\"\n\n    # Get input\n    S, E, C = [int(n) for n in stdin.split(\"\\n\")[0].split()]\n    spies = set(range(1, S + 1))\n    enemies = {int(n) for n in stdin.split(\"\\n\")[E].split()}\n    connections = {tuple(int(n) for n in stdin.split(\"\\n\")[c].split()) for c in range(C)}\n\n    # Find the set of spies with no connections to enemies\n    no_enemies = set(spies)\n    for connection in connections:\n        if any(c in enemies for c in connection):\n            no_enemies.discard(connection[0])\n            no_enemies.discard(connection[1])\n\n    # Check if the spies are isolated\n    if len(no_enemies) == 0:\n        return str(len(spies) + len(enemies))\n\n    # Otherwise, find the minimum number of spies that need to be contacted\n    # This is the same as the number of spies minus the number of enemies\n    return str(len(spies) - len(no_enemies))\n\n\ndef"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(test_input)\n    4\n    \"\"\"\n    pass"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    s, e, c = map(int, stdin.split())\n    s_set = set()\n    e_set = set()\n    s_set.add(0)\n    e_set.add(0)\n    for i in range(c):\n        s_, e_ = map(int, stdin.split()[i * 2: i * 2 + 2])\n        s_set.add(s_)\n        e_set.add(e_)\n    return min(s_set ^ e_set, e_set ^ s_set)\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of spies you need to message in order to ensure that\n    no enemy spies receive the message.\n    >>> solution(\"4 1 3\\n0 1\\n1 2\\n2 3\\n1\\n\")\n    2\n    \"\"\"\n    \n    pass\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def make_set(x):\n        parent[x] = x\n\n    def find_set(x):\n        if parent[x] == x:\n            return x\n        parent[x] = find_set(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        px, py = find_set(x), find_set(y)\n        if rank[px] < rank[py]:\n            parent[px] = py\n        elif rank[py] < rank[px]:\n            parent[py] = px\n        else:\n            parent[py] = px\n            rank[px] += 1\n\n    parent, rank = [0] * (N + 1), [0] * (N + 1)\n    for i in range(1, N + 1):\n        make_set(i)\n    # build a graph using adjacency list\n    G = [[] for _ in range(N + 1)]\n    for s, e in E:\n        G[s].append(e)\n        G[e].append(s)\n    # find connected components and union them\n    for c in C:\n        # use dict to reduce N\n        c = c.strip(' ').split(' ')\n        a, b = int(c[0]), int(c[1])\n        if find_set(a)!= find_set(b):\n            union(a, b)\n    # construct the message\n    count = 0\n    for i in range(1, N + 1):\n        if find_set(i)!= 0:\n            count += 1\n    return count\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = map(int, stdin.split())\n    # Dict of connections\n    connections = {}\n    # enemies\n    enemies = set()\n    # convert string to int\n    for connection in stdin.split('\\n')[C:]:\n        connections[(int(connection.split(' ')[0]), int(connection.split(' ')[1]))] = True\n        connections[(int(connection.split(' ')[1]), int(connection.split(' ')[0]))] = True\n        enemies.add(int(connection.split(' ')[0]))\n        enemies.add(int(connection.split(' ')[1]))\n    for connection in stdin.split('\\n')[:C]:\n        connections[(int(connection.split(' ')[0]), int(connection.split(' ')[1]))] = True\n        connections[(int(connection.split(' ')[1]), int(connection.split(' ')[0]))] = True\n        enemies.add(int(connection.split(' ')[0]))\n        enemies.add(int(connection.split(' ')[1]))\n\n    # remove self\n    connections.pop((0, 0), None)\n    # create dictionary of connections to be passed to connected function\n    connections_dict = {}\n    for connection in connections:\n        if connection[0] not in connections_dict:\n            connections_dict[connection[0]] = set()\n        connections_dict[connection[0]].add(connection[1])\n    \n    return get_min_messages(S, E, connections_dict, set(enemies))\n\n\ndef"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ..."
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds minimum number of messages needed to cover all spies\"\"\"\n    stdin = stdin.split('\\n')\n    spy_connections = {}\n    enemy_spies = []\n    all_spies = set()\n    for line in stdin[2:]:\n        line = line.split()\n        source, target = int(line[0]), int(line[1])\n        all_spies.update([source, target])\n        if source not in spy_connections:\n            spy_connections[source] = [target]\n        else:\n            spy_connections[source].append(target)\n        if target not in spy_connections:\n            spy_connections[target] = [source]\n        else:\n            spy_connections[target].append(source)\n\n    for line in stdin[3:]:\n        line = line.split()\n        enemy_spies.append(int(line[0]))\n    # n = self.num_spies + 1\n    n = len(all_spies)\n    visited = set()\n    reachable = set()\n    while n > 1:\n        n -= 1\n        if n not in visited:\n            reachable.update([n])\n            visited.update([n])\n        for s in spy_connections.get(n, []):\n            if s not in visited:\n                reachable.update([s])\n                visited.update([s])\n        n = min(reachable)\n    return len(stdin) - len(enemy_spies) - 1\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = [int(x) for x in stdin.split()]\n    d = {i: set() for i in range(S)}\n    for _ in range(C):\n        a, b = [int(x) for x in stdin.split()]\n        d[a].add(b)\n        d[b].add(a)\n    e = set()\n    for _ in range(E):\n        e.add(int(stdin.split()))\n    s = set(d[0])\n    for i in s:\n        for j in d[i]:\n            s.update(d[j])\n    ans = 0\n    s = set(d[0])\n    for i in s:\n        if i in e:\n            continue\n        ans += 1\n    return ans"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    if a < 1 or a > 200000 or c < 1 or c > 200000 or m < 1 or m > 200000:\n        return 0\n    if c == 1 or m == 1:\n        return 1\n    cache = {}\n    return count_cherry_mango_apple(a, c, m, cache)\n\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(count_arrangements(stdin))\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    result = 1\n    for i in range(A):\n        result *= (C+M)\n        result %= (10**9+7)\n        result -= (C+M)\n        result += C\n        result %= (10**9+7)\n        result -= C\n        result += M\n        result %= (10**9+7)\n    return str(result)\n    \n\"\"\"\n\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    How many ways can you arrange apples, cherries and mangos\n    to deliver to Singapore in one trip?\n    :param stdin: the input string\n    :return: the answer as a string\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, _, _ = stdin.split()\n    A, C, M = int(stdin[0]), int(stdin[1]), int(stdin[2])\n    return str((A * (A-1)) // 2 * (C * (C-1)) // 2 * (M * (M-1)) // 2)\n\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(int, stdin.split(\" \")))\n    n = inputs[0]\n    m = inputs[1]\n    c = inputs[2]\n    ap = n - c\n    am = m - c\n    if c == 0 or c == n:\n        return \"1\"\n    if ap < 0 or am < 0:\n        return \"0\"\n    if am == 0 or am == c:\n        return str(1)\n    return str((ap + 1) * (ap + 1) * (ap + 1) * (ap + 1) * (ap + 1) / 6 % (10 ** 9 + 7))\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = [int(n) for n in stdin.split()]\n    x = (A - 1) // 2\n    y = (C - 1) // 2\n    z = (M - 1) // 2\n    return x * y * z"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return number of ways to ship apples in different ways.\"\"\"\n    # A: number of apples\n    # C: number of cherries\n    # M: number of mango\n    a, c, m = list(map(int, stdin.split()))\n    result = 0\n    prime = 1000000007\n    # Base case\n    if a >= 2:\n        result += 1\n    if c >= 2:\n        result += 1\n    if m >= 2:\n        result += 1\n    # For A >= 3\n    if a >= 3:\n        for i in range(a // 2 + 1):\n            if (a - 2 * i) >= 2 * (c + m):\n                result += 2 ** i\n            else:\n                break\n    # For C >= 3\n    if c >= 3:\n        for i in range(c // 2 + 1):\n            if (c - 2 * i) >= 2 * (a + m):\n                result += 2 ** i\n            else:\n                break\n    # For M >= 3\n    if m >= 3:\n        for i in range(m // 2 + 1):\n            if (m - 2 * i) >= 2 * (a + c):\n                result += 2 ** i\n            else:\n                break\n    return str(result % prime)\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = stdin.strip().split(\" \")\n    A, C, M = [int(x) for x in (A, C, M)]\n    if A > 2 * C + M or A < 0 or C < 0 or M < 0:\n        return str(0)\n    MOD = 10 ** 9 + 7\n    count_apple = (C + 1) * C // 2\n    count_cherry = C * (M + 1)\n    count_mango = M * (A - C - M)\n    count = count_apple + count_cherry + count_mango\n    return str(count % MOD)\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = list(map(int, stdin.split()))\n    return str(counting_method(n[0], n[1], n[2]))\n\n\ndef"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n    from functools import reduce\n    n = int(stdin[0])\n    nums = [int(i) for i in stdin[1].split()]\n    nums_set = set(nums)\n    if len(nums_set) == 1:\n        return 'impossible'\n    else:\n        std = Counter(nums)\n        for i in range(1, 10):\n            if std[i] > 1:\n                nums = [x for x in nums if x!= i]\n                std = Counter(nums)\n                break\n        std = list(set(std.values()))\n        std.sort(reverse=True)\n        nums = [x for x in nums if x!= 0]\n        nums.sort()\n        if len(std) > 1:\n            if len(std) == 2 and std[0] == std[1]:\n                nums = [max(nums)]\n            else:\n                return 'impossible'\n        else:\n            if std[0] > 1:\n                return 'impossible'\n            nums = [nums[0]]\n        ans = []\n        for i in range(n):\n            j = 0\n            while j < len(nums):\n                if nums[j] < 10 ** (15 - (n - i - 1)):\n                    ans.append(nums[j] + 10 ** (n - i - 1))\n                    nums.remove(nums[j])\n                    j = 0\n                    break\n                else:\n                    j += 1\n            if j == len(nums):\n                ans.append(nums[j - 1] - 10 ** (n - i - 1))\n                nums.remove(nums[j - 1])\n                j = 0\n        return''.join([str(x) for x in ans])\n\nprint(solution(input().split()))"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = list(stdin)\n    if len(a) < 1:\n        return 'impossible'\n    if len(a) == 1:\n        return '0' + a[0]\n    a.sort()\n    n = a[0]\n    for i in range(len(a)):\n        if i == 0:\n            continue\n        if a[i] == n:\n            continue\n        if len(a[i]) > len(str(n)):\n            return 'impossible'\n        if int(a[i][len(str(n))]) < int(str(n)[len(str(n)) - 1]):\n            return 'impossible'\n        if int(a[i][len(str(n))]) > int(str(n)[len(str(n)) - 1]):\n            a[i] = a[i][:len(a[i]) - 1] + str(int(a[i][len(a[i]) - 1]) - 1) + a[i][len(a[i]) - 1:]\n        if a[i] == '0':\n            a[i] = '1'\n            return '1' * (len(a) - 1) + a[i]\n        n = a[i]\n    return ''.join(a)\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = [int(s) for s in stdin.split(\"\\n\")[1].split(\" \")]\n    a.sort()\n    if a[0] == 0:\n        for i in range(len(a)):\n            if a[i] == 0:\n                a[i] = 9\n    for i in range(len(a)):\n        if (a[i] // 10 == 0 and a[i]!= 0):\n            for j in range(10):\n                if j not in a:\n                    a[i] = j\n                    break\n        else:\n            for j in range(10):\n                if j not in a:\n                    if (a[i] * 10 + j) not in a:\n                        a[i] = j\n                        break\n    if a!= sorted(a):\n        return \"\\n\".join(str(i) for i in a)\n    return \"impossible\"\n    return \"\"\n\"\"\"\n\ndef"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\nimport re\n\ndef"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    res = []\n    for i in range(10):\n        if i == 0 and a[0]!= 0:\n            res.append(i)\n        else:\n            res.append(i)\n            for j in range(n-1):\n                if a[j] < res[j]:\n                    break\n                elif a[j] == res[j] and a[j+1] == res[j]:\n                    res[j] += 1\n                else:\n                    break\n    if not res == sorted(res):\n        return 'impossible'\n    return''.join(map(str, res))\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split(\"\\n\")\n    a = [int(i) for i in a.split(\" \")]\n    a = list(sorted(a))\n    # print(a)\n    # Check for leading zeroes\n    if a[0] == 0:\n        a[0] = 1\n    # print(a)\n    # Find the last nonzero number\n    for i in range(len(a) - 1, -1, -1):\n        if a[i]!= 0:\n            break\n    # print(i)\n    # Change the last nonzero number\n    a[i] += 1\n    # print(a)\n    # Check for leading zeroes\n    if a[i] == 10:\n        a[i] = 0\n        i += 1\n    # print(a)\n    # Change the new last nonzero number\n    for j in range(i + 1, len(a)):\n        if a[j]!= 10:\n            a[j] += 1\n            break\n    # print(a)\n    # Check for leading zeroes\n    if a[j] == 10:\n        a[j] = 0\n    # print(a)\n    # Check for leading zeroes\n    if a[0] == 0:\n        a[0] = 1\n    # print(a)\n    ans = \"\"\n    for i in range(len(a)):\n        if i!= 0:\n            ans += \" \"\n        ans += str(a[i])\n    return ans\n\n\nprint(solution(str(input())))\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns 'impossible' if the task is impossible, and a sorted list of valid integers if the task is possible\n    \"\"\"\n    a = stdin.split()\n    lst = [int(i) for i in a[1:]]\n\n    if len(set(lst)) == len(lst):\n        return str(a[0]) + \" \" + \" \".join(map(str, lst))\n    return \"impossible\"\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\nprint(solution(input()))\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a solution for the given input\"\"\"\n    n, *ans = stdin.split()\n    # print(n, ans)\n    # Validate the input\n    if not n.isdecimal() or not (2 <= int(n) <= 100):\n        raise ValueError('Invalid input')\n    if not all(map(lambda x: x.isdecimal() and 0 <= int(x) <= 10**15, ans)):\n        raise ValueError('Invalid input')\n    n = int(n)\n    ans = [int(x) for x in ans]\n\n    # print(n, ans)\n\n    def change_one_digit(number: int, index: int) -> int:\n        \"\"\"\n        Return the number which is equal to the number with one digit replaced by a different one\n        \"\"\"\n        # print(number, index)\n        if index == 0:\n            return number if 0 < number < 10 else 10\n        if index > len(str(number)):\n            raise ValueError('Out of bounds')\n        if not str(number)[0] == '0':\n            return int(str(number)[:index] + str(number)[index + 1])\n        return 10 * int(str(number)[1:index + 1]) + int(str(number)[index + 1])\n\n    def find_all_solutions(number: int) -> Iterator[int]:\n        \"\"\"\n        Return all possible solutions of a given number\n        \"\"\"\n        # print(number)\n        for i in range(len(str(number))):\n            # print(i)\n            yield change_one_digit(number, i)\n\n    # print(find_all_solutions(3))\n    solutions = set(find_all_solutions(n))\n    print(solutions)\n    if len(solutions) == 1:\n        return list(solutions)\n    if len(solutions) == 0:\n        raise ValueError('No solutions')\n    solutions.remove(n)\n    # print(solutions)\n    return list(solutions)\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3\n   ... 2020 2020 2020\n   ... ''')\n    2021 2020 2020\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    nums = [int(i) for i in stdin.split(\"\\n\")[1].split()]\n    ans = sorted(nums)\n    for i in range(n):\n        for j in range(1, n):\n            if ans[i] == 0:\n                if ans[j] == 0:\n                    ans[i] = ans[j] = 1\n                else:\n                    break\n            if ans[i] == ans[j]:\n                break\n            if ans[i] < ans[j]:\n                if ans[i] * 10 + ans[j] <= ans[j] * 10 + ans[i]:\n                    break\n                ans[i] = ans[i] * 10 + ans[j]\n                ans[j] = ans[j] * 10 + ans[i]\n                break\n            else:\n                if ans[i] * 10 + ans[j] <= ans[j] * 10 + ans[i]:\n                    break\n                ans[i] = ans[i] * 10 + ans[j]\n                ans[j] = ans[j] * 10 + ans[i]\n                break\n    print(*ans)\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, e = map(int, stdin.split())\n    a = b = c = 0\n    for i in range(s, e + 1):\n        if '4' not in str(i):\n            if '6' in str(i) or '8' in str(i):\n                a += 1\n            else:\n                b += 1\n    c = a - b\n    print(c % (10**9 + 7))\n    return ''\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, R = stdin.split()\n    L, R = int(L), int(R)\n    count = 0\n    for house in range(L, R + 1):\n        if not any(i in str(house) for i in ['4', '6', '8']):\n            if len(list(filter(lambda x: x in ['6', '8'], str(house)))) == len(list(filter(lambda x: x not in ['6', '8'], str(house)))):\n                count += 1\n    return str(count % (10**9 + 7))\n    \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  "
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    n = r - l + 1\n    count = 0\n    for i in range(n):\n        if contains_no_4(i, l, r) and is_balance(i, l, r):\n            count += 1\n    return count % (10**9 + 7)\n\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    first, last = map(int, stdin.split())\n    count = 0\n    for house in range(first, last+1):\n        if not house % 10 in [4, 6, 8] and len(set([digit for digit in str(house) if digit in [6, 8]])) == len(set([digit for digit in str(house) if not digit in [6, 8]])):\n            count += 1\n    return str(count % (10 ** 9 + 7))\n    \n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split(' '))\n    count = 0\n    for i in range(L, R + 1):\n        if is_valid(i):\n            count += 1\n    return count % (10**9 + 7)\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    \n    def get_num_digits(x: int) -> int:\n        count = 0\n        while x:\n            x //= 10\n            count += 1\n        return count\n    \n    ans = 0\n    for n in range(L, R + 1):\n        s = str(n)\n        if '4' in s or '6' in s or '8' in s:\n            continue\n        if '6' in s or '8' in s:\n            if '6' in s and '8' in s:\n                ans += get_num_digits(n)\n            else:\n                ans += get_num_digits(n) - s.count('6') - s.count('8')\n        else:\n            ans += 1\n    \n    return str(ans % (10 ** 9 + 7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    a = [4, 6, 8]\n    for i in range(l, r+1):\n        k = [digit for digit in str(i) if digit not in a]\n        if len(k) == len([digit for digit in str(i) if digit not in a]):\n            print(i)\n    return ''\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    houses = list(map(int, stdin.split()))\n\n    def house_number(n: int) -> str:\n        return str(n) if '4' not in str(n) and n % 6 + n % 8 == n else None\n\n    return len([h for h in houses if house_number(h) is not None])\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, R = stdin.split(\" \")\n    L = int(L)\n    R = int(R)\n    houses = []\n    for num in range(L, R+1):\n        if not (num % 4) and (sum(map(int, str(num))) == sum(map(int, (num for num in str(num) if num not in \"46\")))):\n            houses.append(num)\n    print(len(houses))\n    return \"\""
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    stdin = [int(x) for x in stdin.split()]\n    low, high = stdin[0], stdin[1]\n    houses = []\n    for house in range(low, high + 1):\n        if not contains_digit(house, 4) and contain_the_same_number_of_digits(house, 6, 8):\n            houses.append(house)\n    return len(houses) % (10**9 + 7)\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, x = map(int, stdin.split())\n    mat = [stdin.split() for _ in range(m)]\n    mod = 10**5\n    dp = [[[None]*n for _ in range(m)] for _ in range(n+1)]\n    dp[0][0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == '@':\n                dp[i][j][0] = 1\n                dp[i][0][j] = 1\n                dp[0][i][j] = 1\n                dp[i][j][1] = 0\n                dp[i][0][j+1] = 0\n                dp[i][1][j] = 0\n                dp[i][0][j-1] = 0\n                dp[i][1][j+1] = 0\n                dp[i][1][j-1] = 0\n            if mat[i][j] == '>':\n                dp[i][0][j] = 0\n                dp[i][1][j] = 1\n                dp[i][0][j+1] = 1\n            if mat[i][j] == '<':\n                dp[i][0][j] = 0\n                dp[i][1][j] = 1\n                dp[i][0][j-1] = 1\n    def go(i, j, s):\n        if dp[i][j][s] is not None:\n            return dp[i][j][s]\n        t = 0\n        if mat[i][j] == '>':\n            if j+1 < n and s == 1:\n                t += go(i, j+1, 0)\n            if s == 0:\n                t += go(i, j+1, 0)\n        if mat[i][j] == '<':\n            if j-1 >= 0 and s == 1:\n                t += go(i, j-1, 0)\n            if s == 0:\n                t += go(i, j-1, 0)\n        if mat[i][j] == '~':\n            if s == 1:\n                t += go(i, j, 1)\n        dp[i][j][s] = (t+1)%mod\n        return dp[i][j][s]\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            ans += go(i, j, 1)\n            ans += go(i, j, 0)\n    ans += go(0, 0, 1)\n    ans += go(0, 0, 0)\n    return ans if ans else 'begin repairs'\n\nsolution(input())"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    y, x, x_init = [int(s) for s in stdin.split(\"\\n\")[:3]]\n    curr = [[\"\" for _ in range(x)] for _ in range(y)]\n    curr[0][x_init] = \">\"\n    curr[0][x_init+1] = \"<\"\n    for i, row in enumerate(stdin.split(\"\\n\")[3:]):\n        for j, c in enumerate(row):\n            curr[i][j] = c\n\n    memo = {}\n    mod = 1000003\n\n    def next_move(curr, x, y, dx, dy):\n        if (x, y) not in memo:\n            if curr[y][x] == \">\":\n                memo[(x, y)] = next_move(curr, x+1, y, 1, 0)\n            elif curr[y][x] == \"<\":\n                memo[(x, y)] = next_move(curr, x-1, y, -1, 0)\n            elif curr[y][x] == \"@\":\n                memo[(x, y)] = 1\n            else:\n                memo[(x, y)] = 0\n        return memo[(x, y)]\n\n    return next_move(curr, x_init, 0, 0, 1) % mod\n\nprint(solution(input()))\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    # Write your code here\n    pass\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution to the problem.\n    >>> solution(\"2 2 0\\n>>@<<\\n>~#~<\")\n    '2'\n    >>> solution(\"3 5 1\\n>>@<<\\n>~#~<\")\n    '4'\n    \"\"\"\n    y, x, x_init = map(int, stdin.split())\n    matrix = [list(line) for line in stdin.split(\"\\n\")]\n    visited = set()\n\n    # Recursive function to solve the problem\n    def _solution(x, y, path):\n        # If the boat reached the castle, return the path\n        if matrix[y][x] == \"@\":\n            visited.add(tuple(path))\n            return 1\n        # If the boat is on the wall, return 0\n        elif matrix[y][x] == \"#\":\n            return 0\n        # If the boat is on the current, return 0\n        elif matrix[y][x] in \"<>\":\n            return 0\n        # If the boat has already visited this tile, return 0\n        elif tuple(path) in visited:\n            return 0\n        # Save the current path to avoid duplicates\n        visited.add(tuple(path))\n        # Increase the x coordinate by 1\n        count = 0\n        for char in [\"<\", \">\"]:\n            path_1 = path.copy()\n            path_1.append(char)\n            count += _solution(x, y, path_1)\n        # Decrease the x coordinate by 1\n        for char in [\"<\", \">\"]:\n            path_2 = path.copy()\n            path_2.append(char)\n            path_2.reverse()\n            count += _solution(x, y, path_2)\n        return count\n\n    return str(_solution(x_init, 0, []))\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    :param stdin:\n    :return:\n    '''\n    # Initialize the map\n    m: List[List[str]] = []\n    map_rows: int = int(stdin.split('\\n')[0].split()[0])\n    map_cols: int = int(stdin.split('\\n')[0].split()[1])\n    init_col: int = int(stdin.split('\\n')[0].split()[2])\n    for row in range(map_rows):\n        row: str = stdin.split('\\n')[row + 1]\n        m.append(list(row))\n    # Create a queue\n    q: List[int] = [init_col]\n    path: List[int] = [init_col]\n    visited: Set[Tuple[int, int]] = set([(init_col, 0)])\n    ans: List[int] = []\n    # Go through the queue\n    while q:\n        curr_col: int = q.pop(0)\n        prev_col: int = curr_col\n        if m[map_rows - 1][curr_col] == '@':\n            ans.append(len(path))\n        for direction in ['right', 'left']:\n            if direction == 'right':\n                prev_col = curr_col + 1\n                if prev_col >= map_cols:\n                    continue\n            else:\n                prev_col = curr_col - 1\n                if prev_col < 0:\n                    continue\n            if m[map_rows - 1][prev_col] == '#':\n                continue\n            if (prev_col, 1) not in visited:\n                q.append(prev_col)\n                visited.add((prev_col, 1))\n                path.append(prev_col)\n    # No more ways to get back home\n    if not ans:\n        return 'begin repairs'\n    else:\n        return''.join([str(ans[i]) for i in range(len(ans))])\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    Y, X, x_init = stdin.split()\n    Y, X, x_init = int(Y), int(X), int(x_init)\n    x_init -= 1\n\n    current_row = Y - 1\n    current_col = x_init\n    map_grid = [stdin.split()]\n    while current_row >= 0:\n        temp_row = []\n        for i, row in enumerate(map_grid):\n            row_temp = []\n            for j, value in enumerate(row):\n                if j!= current_col:\n                    row_temp.append('>')\n                elif value == '>':\n                    row_temp.append('>')\n                    current_col += 1\n                elif value == '<':\n                    row_temp.append('<')\n                    current_col -= 1\n                elif value == '@':\n                    row_temp.append('@')\n                elif value == '#':\n                    row_temp.append('#')\n                else:\n                    row_temp.append('~')\n            temp_row.append(''.join(row_temp))\n        map_grid = list(reversed(temp_row))\n        current_row -= 1\n\n    count = 0\n    for row in map_grid:\n        for value in row:\n            if value == '>':\n                count += 1\n            elif value == '<':\n                count -= 1\n    return count\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    y, x, x_init = [int(i) for i in stdin.split('\\n')[:3]]\n    grid = stdin.split('\\n')[3:]\n    count = 0\n\n    for row_index in range(len(grid)):\n        for column_index in range(len(grid[row_index])):\n            if grid[row_index][column_index] == '@':\n                x_init = column_index\n                count += 1\n                break\n        else:\n            continue\n        break\n\n    def path(grid: list, row: int, column: int) -> int:\n        for r in range(row, len(grid)):\n            for c in range(len(grid[r])):\n                if grid[r][c] == '~':\n                    grid[r][c] = '#'\n        if grid[row][column] == '~':\n            return 0\n        if grid[row][column] == '>':\n            grid[row][column] = '<'\n            return 1 + path(grid, row + 1, column)\n        if grid[row][column] == '<':\n            grid[row][column] = '>'\n            return 1 + path(grid, row - 1, column)\n        else:\n            return 0\n\n    grid = []\n    for r in range(y):\n        grid.append(list(grid[r]))\n    grid[0][x_init] = '~'\n\n    return str(count + path(grid, row_index, x_init))\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    y_len, x_len, init = map(int, stdin.split())\n    castle = [list(stdin.split()[x]) for x in range(y_len)]\n    boat = [-1] * len(castle)\n    boat[0] = init\n    count = 0\n    for y in range(1, y_len):\n        for x in range(x_len):\n            if boat[y-1][x] == '<':\n                if castle[y-1][x] == '#' or castle[y-1][x+1] == '>':\n                    boat[y] = x\n                    count += 1\n                    break\n    if count!= 0:\n        pass\n    else:\n        boat[-1] = boat[0]\n    count = 0\n    for y in range(y_len-1, 0, -1):\n        for x in range(x_len):\n            if boat[y][x] == '>':\n                if castle[y][x] == '#' or castle[y][x-1] == '<':\n                    boat[y-1] = x\n                    count += 1\n                    break\n    if count!= 0:\n        pass\n    else:\n        boat[0] = boat[-1]\n    return str(count)\n    \nprint(solution(input()))\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # create a board of size\n    board = []\n    for i in stdin.split('\\n'):\n        board.append(list(i))\n    # iterate over the board\n    for i, row in enumerate(board):\n        for j, col in enumerate(row):\n            if col == '@':\n                # save the starting point\n                start = (i, j)\n    \n    # create a queue for the bfs\n    queue = deque([start])\n    # create a dictionary for the distance\n    dist = {start: 0}\n    # iterate until the queue is empty\n    while queue:\n        # iterate over the queue\n        for _ in range(len(queue)):\n            # get the current node\n            curr = queue.popleft()\n            # iterate over the possible moves\n            for mv in moves(board, curr):\n                # check if the current node is not already in the distance\n                if mv not in dist:\n                    # add it to the distance\n                    dist[mv] = dist[curr] + 1\n                    # add it to the queue\n                    queue.append(mv)\n    # return the distance to the castle\n    return str(dist[(0, 0)])\n\n\ndef"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    eq = stdin.split('=')\n    A, S = eq[0], eq[1]\n    B = ''\n    # Step 1: Replace the pairs of digits with addition operators\n    for i in range(len(A)):\n        if A[i:i + 2] in S:\n            B += '+'\n        else:\n            B += A[i]\n    # Step 2: Make the left side of the equation correct by inserting the correct number of addition operations\n    for i in range(1, len(B)):\n        if B[i] == '+' and B[i - 1] == '+':\n            B = B[:i] + '+' + B[i:]\n    # Step 3: Append the numbers with the addition operations\n    B += A\n    return B[1:]\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    eq = list(map(int, stdin.split('=')))\n    str_eq = list(map(str, eq))\n    i, left_side = 0, ''\n    while i < len(str_eq[0]):\n        if str_eq[0][i]!= str_eq[1][i]:\n            left_side += str_eq[0][i] + str_eq[1][i]\n            i += 1\n            while str_eq[0][i] == '0':\n                i += 1\n        else:\n            left_side += str_eq[0][i]\n            i += 1\n            while str_eq[0][i] == str_eq[1][i] == '0':\n                i += 1\n    right_side = str_eq[0][i:]\n    for i in range(len(str_eq[1]) - len(right_side)):\n        right_side += '0'\n    return left_side + '=' + right_side\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    left = stdin.split('=')[0]\n    right = stdin.split('=')[1]\n    left_digits = [int(digit) for digit in left]\n    right_digits = [int(digit) for digit in right]\n    diff = 0\n    for digit in left_digits:\n        for digit2 in right_digits:\n            diff = max(diff, abs(digit - digit2))\n    return str(int(left) + diff)\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('=')\n    s = str(a)\n    n, m = len(s), len(b)\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if str(a)[i] == str(a)[j]:\n                    result.append(str(a)[i])\n                    result.append('+')\n                else:\n                    result.append(str(a)[i])\n                    result.append('+')\n                    result.append(str(a)[j])\n                result.append('=')\n    for i in range(m):\n        for j in range(i + 1, m):\n            if i!= j:\n                if str(b)[i] == str(b)[j]:\n                    result.append(str(b)[i])\n                    result.append('+')\n                else:\n                    result.append(str(b)[i])\n                    result.append('+')\n                    result.append(str(b)[j])\n                result.append('=')\n    if result[-1] == '=':\n        result.pop()\n    result = result[:n] + [str(a)] + result[n:]\n    return ''.join(result)\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the corrected equation.\"\"\"\n    a, s = stdin.split('=')\n    a = a.replace('=', '')\n    s = s.replace('=', '')\n    num1 = a[::-1]\n    num2 = s[::-1]\n\n    #\n    #\n    #\n    #\n\n    print(a, s)\n    return ''\n\n\ndef"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A = int(stdin.split('=')[0])\n    S = int(stdin.split('=')[1])\n    addition = 0\n    while A > S:\n        A, remainder = divmod(A, 10)\n        addition += remainder\n    while A < S:\n        S, remainder = divmod(S, 10)\n        addition -= remainder\n    return str(A + S + addition)\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split()\n    a = [int(i) for i in a]\n    s = [int(i) for i in s]\n    d = len(a)\n    l = len(s)\n    num = abs(s[0] - a[0])\n    for i in range(1, l):\n        num += abs(s[i] - a[i])\n    for i in range(l):\n        num += abs(a[i] - s[i])\n    for i in range(1, d):\n        s[i] = abs(s[i] - s[0])\n    for i in range(1, d):\n        a[i] = abs(a[i] - a[0])\n    for i in range(1, d):\n        num += abs(s[i] - a[i])\n    for i in range(1, d):\n        num += abs(a[i] - s[i])\n    return str(num)"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split(\"=\")\n    S = int(S)\n    A = int(\"\".join(A.split(\"+\")))\n    while A > S:\n        residual = A - S\n        A = S\n        S += residual\n    A = str(A)\n    S = str(S)\n    return A + \"=\" + S"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Return a corrected equation string.\n    '''\n\n    # Clean input\n    stdin = stdin.split('=')\n    stdin[0] = stdin[0].split('A')[-1].strip()\n    stdin[1] = stdin[1].split('S')[-1].strip()\n    a = int(stdin[0])\n    s = int(stdin[1])\n    # Generate all solutions\n    ans = set()\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                if j!= k:\n                    n = i * 10 ** 4 + j * 10 ** 3 + k * 10 ** 2\n                    ans.add(str(n) + '=' + str(i * 10 ** 4 + j * 10 ** 3 + k * 10 ** 2) + str(s))\n    # Remove duplicates\n    ans = list(ans)\n    ans.sort()\n    # Return result\n    return ans[0]\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''143175=120''')\n    '14+31+75=120'\n    >>> solution('''5025=30''')\n    '5+025=30'\n    \"\"\"\n    a, s = stdin.split('=')\n    a = [int(x) for x in a]\n    s = int(s)\n    ans = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n                ans += 1\n    return f'{str(ans)}={str(s)}'\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str with solution to problem 4.\"\"\"\n    # Get data\n    data = [int(line) for line in stdin.split('\\n')]\n\n    # Get first pattern\n    pattern = find_subsequence(data)\n    if pattern is None:\n        return '-1'\n\n    # Get second pattern\n    pattern2 = find_subsequence2(pattern)\n    if pattern2 is None:\n        return '-1'\n\n    return''.join(str(i) for i in pattern2)\n\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # \ubb38\uc81c\uc758 \uae30\ubcf8\uc774 \ud2b9\uc815 \uc815\uc218\ub97c \uc81c\uc678\ud55c \uc804\ubd80\ub97c \uc81c\uac70\ud558\ub294 \uac83\uc774\ub77c\uc11c, \uac01 \uc815\uc218\ub97c \uc785\ub825\ud560 \ub54c\ub9c8\ub2e4 \ud0a4\uc6cc\ub4dc\ub97c \ub0a8\uaca8\uc11c, \uc815\uc218\ub97c \uc81c\uc678\ud558\uace0 \ub098\uba38\uc9c0 \uc815\uc218\ub97c \uc785\ub825\ubc1b\uc558\uc744 \ub54c\ub9c8\ub2e4 \uc815\uc218\ub97c \uc778\uc790\ub85c \uac00\uc9c0\ub294 \ud568\uc218\ub97c \ub9cc\ub4e4\uc5b4\ubcf4\uc790\n    # \uc774 \uc778\uc790\ub97c \uc5b4\ub5a4 \ubcc0\uc218\uc5d0 \uc800\uc7a5\ud558\uace0 \uc5b4\ub5a4 \ud568\uc218\ub97c \uc2e4\ud589\uc2dc\ud0a4\ub294\uc9c0 \ud14c\uc2a4\ud2b8\ud574\ubcf4\uc790\n    # \ub610\ud55c, \ud568\uc218\ub97c \ub9cc\ub4e4\uace0 \ub098\uc11c \uc774 \ud568\uc218\ub97c \uc2e4\ud589\uc2dc\ud0a4\ub294 \uc5ed\ud560\uc744 \ud558\ub294 \ud14c\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \ubc1b\uc744 \uc218 \uc788\ub3c4\ub85d, \uc9c0\uc815\ub41c \ubcc0\uc218\uc5d0 \uadf8 \ud14c\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \uc800\uc7a5\ud560 \uc218 \uc788\ub3c4\ub85d \ud574\ubcf4\uc790\n    # \uadf8\ub7fc \uc544\ub798 \uc2e4\ud589\ud568\uc218\uc5d0 \ud568\uc218\ub97c \uc2e4\ud589\uc2dc\ud0a4\uba74, \ud14c\uc2a4\ud2b8 \ub370\uc774\ud130\ub97c \uc785\ub825\ubc1b\uc744 \uc218 \uc788\uc5b4\uc57c \ud55c\ub2e4\n    import sys\n    N = int(stdin.readline())\n    def solve(n):\n        \"\"\"\ud0a4\uc6cc\ub4dc\uac00 n\uac1c\ub97c \uac00\uc9c0\ub294 \uc21c\uc5f4\uc744 \ub9cc\ub4dc\ub294 \ud568\uc218\"\"\"\n        # \uc774 \ubd80\ubd84\uc744 \uc218\uc815\ud574\uc11c, \uac01 \uc815\uc218\ub97c \uc81c\uac70\ud558\ub294 \ud69f\uc218\ub97c \uc138\uc5b4\uc11c \uadf8 \uc21c\uc11c\ub97c \uc2dc\ud589\ud558\ub294 \ud568\uc218\ub97c \uc791\uc131\ud558\uc790\n        # \uc2e4\uc81c\ub85c \uc774 \ubd80\ubd84\uc744 \uc218\uc815\ud574\ubcf4\uc790\n        # \uc774 \ubd80\ubd84\uc774 \uac00\ub3c5\uc131\uc744 \uc81c\ub300\ub85c \ud655\uc2e4\ud788 \uc7a1\uc544\uc8fc\ub294 \ubd80\ubd84\uc774\ub2e4\n        nonlocal N\n        # nonlocal\uc744 \uc0ac\uc6a9\ud558\uc5ec N\uc758 \uac12\uc744 \uc0ac\uc6a9\ud558\uba74 \uc815\uc9c1\ud558\uac8c \ubcc0\uc218\uc5d0 \uc811\uadfc\ud560 \uc218 \uc788\ub2e4.\n        # \uc804\uc5ed \ubcc0\uc218\uc5d0\uc11c \uc811\uadfc\ud558\ub824\uba74 global\uc744 \uc0ac\uc6a9\ud574\uc57c \ud55c\ub2e4\n        # \uc5ec\uae30\uc11c \uc0ac\uc6a9\ud558\uace0\uc790 \ud558\ub294 N\uc774 \ub0a8\uc544 \uc788\uc73c\uba74, \uc804\uc5ed \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud558\uace0, \uc5c6\uc73c\uba74 \uc9c0\uc5ed \ubcc0\uc218\ub97c \uc0ac\uc6a9\ud55c\ub2e4\n        if n < 1:\n            return 0\n        if n == 1:\n            return 1\n        return solve(n-1) + solve(n-2)\n    # \ubb38\uc81c\ub97c \uc62c\ubc14\ub974\uac8c \ud478\ub294 \uc5ed\ud560\uc744 \uc218\ud589\ud558\ub294 \ud568\uc218\n    # \ubb38\uc81c\ub97c \uc62c\ubc14\ub974\uac8c \ud478\ub294 \uc774\uc720\ub294 \uc774\uc911 \ubc18\ubcf5\ubb38\uc73c\ub85c\ub294 \uc548\ub418\uae30 \ub54c\ubb38\uc774\ub2e4\n    # \uc2e4\uc81c\ub85c \ubb38\uc81c\ub97c \uc62c\ubc14\ub974\uac8c \ud478\ub294 \uc5ed\ud560\uc744 \uc218\ud589\ud558\ub294 \ud568\uc218\ub294 \uc544\ub2c8\uae30 \ub54c\ubb38\uc774\ub2e4\n    # \uc81c\ud55c \uc2dc\uac04\ufffd"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution to the problem.\n    '''\n    pass"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find patterns and print the lexicographically smallest ones.\"\"\"\n    n = int(stdin.readline())\n    seq = [int(stdin.readline()) for _ in range(n)]\n    # For every i and j in [0, n):\n    for i in range(n):\n        for j in range(n):\n            # If seq[i] and seq[j] differ by more than one:\n            if seq[i]!= seq[j] and seq[i] + 1!= seq[j] and seq[i] - 1!= seq[j]:\n                print(seq[i], seq[j])\n                return\n    print(-1)\n    return\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n = int(stdin.readline())\n    S = list(map(int, stdin.readline().split()))\n    if n < 4:\n        return -1\n    counts = defaultdict(int)\n    for i, s in enumerate(S):\n        counts[s] += 1\n        if counts[s] > 1:\n            subseqs = True\n            for prev in range(1, i):\n                if S[prev] == s:\n                    subseqs = False\n                    break\n            if subseqs:\n                return s, s\n    return -1\n\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the pair of integers that\n    appear as a subsequence in the\n    sequence S, and prints the lexicographically\n    smallest such pair. If there are no such\n    pairs, prints -1.\n    >>> solution(\"8\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n1\\n\")\n    1 2\n    >>> solution(\"8\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n\")\n    1 -1\n    \"\"\"\n    N = int(stdin)\n    seq = [int(s) for s in stdin.split(\"\\n\") if s]\n    for i in range(N):\n        for j in range(i + 1, N):\n            if seq[i] == seq[j]:\n                continue\n            if seq[i] < seq[j]:\n                continue\n            if seq[i] == seq[j] and seq[j] < seq[i]:\n                continue\n            subseq = seq[i:j + 1]\n            if (seq[i] + 1) in subseq:\n                if (seq[j] + 1) in subseq:\n                    return f\"{seq[i] + 1} {seq[j] + 1}\"\n\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    "
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds pattern in the message and returns the integers of the smallest pair.\"\"\"\n    # Read in the number of elements and elements\n    N = int(stdin.readline())\n    S = stdin.readline().rstrip().split()\n    # Initialize the found variable and i\n    found = -1\n    i = 0\n    # Keep going until you've finished searching\n    while found == -1:\n        # If the element at index i is not a duplicate, add it to the list\n        if S[i] not in S[i + 1 :]:\n            S = S[i:] + S[:i]\n            found = 0\n        # Otherwise, increment i\n        else:\n            i += 1\n    # Return the resulting list\n    return str(int(S[0])) + \" \" + str(int(S[-1]))\n\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return 0"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lights = [0] * n\n    for i in range(n):\n        lights[i] = int(stdin[i])\n    return str(solve(lights, n))\n\n\ndef"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    for i, c in enumerate(stdin):\n        if c == \"1\":\n            ans = i\n    return str(ans)"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return earliest time at which all lights are on.\"\"\"\n    return str(min([int(stdin[i]) * (i + 1) for i in range(len(stdin))]))\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = [0 for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        nums[i] = int(stdin[i - 1])\n    ans = 0\n    cur = 0\n    while True:\n        if all(num == 1 for num in nums[cur:]):\n            return ans\n        cur += 1\n        cur = cur % n\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lights = []\n    for _ in stdin:\n        lights.append(int(_))\n    for i in range(len(lights)):\n        if lights[i] == 0:\n            lights[i] = 1\n        else:\n            lights[i] = 0\n    print(lights)\n    return lights\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return max(range(len(stdin) + 1), key=lambda i: simulate(stdin, i))\n\ndef"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    n = int(stdin)\n    current_state = [False] * n\n    previous_state = [False] * n\n    times = [0] * n\n    time = 0\n    while time <= n:\n        for i, button in enumerate(current_state):\n            if button == True:\n                current_state[i] = False\n                times[i] = time\n                previous_state[i] = True\n            if button == False:\n                current_state[i] = True\n                times[i] = time\n                previous_state[i] = False\n        if max(times)!= 0:\n            break\n        time += 1\n    return max(times)"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    \n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return None"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(['3 1 3 1\\n', '2 2 1\\n', '3 3 1 3\\n', '1 2\\n', '2 3\\n', '3 1\\n'])\n    '1\\n'\n    >>> solution(['3 1 3 1\\n', '2 2 1\\n', '3 3 1 3\\n', '1 2\\n', '2 3\\n', '3 1\\n'])\n    '2\\n'\n    \"\"\"\n    n_trucks, n_pairs = [int(x) for x in stdin.split('\\n')[0].split()]\n    pairs = []\n    for i in range(n_pairs):\n        pairs.append(tuple([int(x) for x in stdin.split('\\n')[i + 1].split()]))\n    n_encounters = [0] * n_pairs\n    for i in range(n_pairs):\n        n_encounters[i] = _calc_encounters(pairs[i], n_trucks)\n    return '\\n'.join(map(str, n_encounters))\n\n\ndef"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The function finds the number of encounters of the input trucks\n    and returns the number of encounters for the pairs of trucks\n    from the input.\n    \"\"\"\n    n, m = [int(num) for num in stdin.split('\\n')[:2]]\n    trucks = [[int(num) for num in stdin.split('\\n')[2:][i].split()]\n              for i in range(n)]\n    pairs = [list(map(int, stdin.split('\\n')[3 + i].split()))\n             for i in range(m)]\n    res = []\n    for pair in pairs:\n        count = 0\n        for truck in trucks:\n            if (pair[0] in truck) and (pair[1] in truck):\n                count += 1\n        res.append(count)\n    return \"\\n\".join(str(num) for num in res)\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # stdin: input\n    # return: output\n    # N, M = map(int, stdin.split())\n    # res = []\n    # for i in range(M):\n    #     res.append(map(int, stdin.split()))\n    # return '\\n'.join(map(str, res))"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://app.codility.com/demo/results/training2QTEZ8-CC7/\"\"\"\n   ...\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\""
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"getting the input\"\"\"\n    N, M = map(int, stdin.split())\n    trucks = [list(map(int, line.split())) for line in stdin.splitlines()[:N]]\n    encounters = {i: 0 for i in range(1, N + 1)}\n    for _ in range(M):\n        i, j = map(int, stdin.split())\n        for k in range(i, j + 1):\n            for t in trucks:\n                if k in t:\n                    encounters[k] += 1\n    return '\\n'.join(str(encounters[i]) for i in range(1, N + 1))\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    if n == 1 and k == 1:\n        return str(a[0])\n    s = [0] * (k + 1)\n    e = [0] * (k + 1)\n    s[1], e[1] = a[0], a[0]\n    for i in range(1, n):\n        s[1], e[1] = max(s[1], a[i]), min(e[1], a[i])\n        for j in range(2, k + 1):\n            s[j] = max(s[j], s[j - 1] + a[i])\n            e[j] = min(e[j], e[j - 1] + a[i])\n    return str(1.0 * e[k] / k)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(' '))\n    arr = map(int, stdin.split(' '))\n    min_avg = min(arr)\n    max_avg = sum(arr) / len(arr)\n    while k >= 0:\n        while min_avg < max_avg:\n            arr[arr.index(min_avg)] = min_avg + 1\n            min_avg += 1\n            max_avg = sum(arr) / len(arr)\n        min_avg = min(arr)\n        max_avg = sum(arr) / len(arr)\n        k -= 1\n    return max_avg\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    a = [int(x) for x in stdin.split('\\n')[1].split()]\n    max_average = 0\n    for i in range(n - k + 1):\n        if sum(a[i:i + k]) / k > max_average:\n            max_average = sum(a[i:i + k]) / k\n    return str(max_average)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    You are given an array of $N$ integers. Find a consecutive subsequence of numbers of the length at least $K$ that has the maximal possible average.\n\n    :param stdin: string input\n    :return: string output\n    '''\n\n    N, K = [int(x) for x in stdin.split()]\n    A = [int(x) for x in stdin.split()]\n\n    B = []\n    for i in range(N - K + 1):\n        sum = 0\n        for j in range(K):\n            sum += A[i + j]\n        B.append(sum / K)\n    B.sort()\n\n    for i in range(N - K + 1):\n        if B[i] == B[i + 1]:\n            continue\n        else:\n            return str(B[i])\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n = int(n)\n    k = int(k)\n    nums = [int(n) for n in stdin.split()]\n    averages = []\n\n    for i in range(n - k + 1):\n        averages.append(sum(nums[i:i+k])/k)\n    averages.sort()\n    print(averages[-1])\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = map(int, stdin.split())\n\n    avg = sum(sequence) / k\n\n    max_avg = 0\n\n    for i in range(len(sequence) - (k - 1)):\n        current_avg = sum(sequence[i: i + k]) / k\n        if max_avg < current_avg:\n            max_avg = current_avg\n\n    return \"{:.3f}\".format(max_avg)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 1\\n1 2 3 4\")\n    '4.0'\n    >>> solution(\"4 2\\n2 4 3 4\")\n    '3.666666'\n    \"\"\"\n    n, k = tuple(map(int, stdin.split(\"\\n\")[0].split(\" \")))\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split(\" \")))\n    count_of_numbers = len(numbers)\n    max_average = -math.inf\n    best_start_index = -1\n    best_end_index = -1\n    for i in range(count_of_numbers - k + 1):\n        average = sum(numbers[i:i + k]) / k\n        if average > max_average:\n            best_start_index = i\n            best_end_index = i + k - 1\n            max_average = average\n    return f\"{max_average:.3f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    ans = float('-inf')\n    for i in range(N - K + 1):\n        if i == 0:\n            ans = sum(arr[i:i + K]) / K\n            continue\n        ans = max(ans, sum(arr[i:i + K]) / K)\n    return str(ans)"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    x = K // 2 + 1\n    max_sum = 0\n    for i in range(0, N - K + 1):\n        cur_sum = 0\n        for j in range(x):\n            cur_sum += a[i + j]\n        max_sum = max(max_sum, cur_sum)\n    return max_sum / x\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(x) for x in stdin.split(' ')]\n    A = [int(x) for x in stdin.split(' ')]\n    s = sum(A[:K])\n    mx = s / K\n    mn = s / K\n    for i in range(K, N):\n        s = s - A[i - K] + A[i]\n        mn = min(mn, s / K)\n        mx = max(mx, s / K)\n    if mx - mn <= 0.001:\n        return mx\n    return mn"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimal difference between the maximum and minimum heights of sand in the sections\"\"\"\n    # read input\n    n, m, w, h = map(int, stdin.split())\n    v = [float(i) for i in stdin.split()]\n    x = [float(i) for i in stdin.split()]\n    min_per_section = [float(i) for i in stdin.split()]\n    max_per_section = [float(i) for i in stdin.split()]\n\n    # find minimum difference between heights of sand\n    return min(max_per_section[i] - min_per_section[i] for i in range(n))\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_str_to_int(s: str) -> int:\n        return int(float(s))\n\n    n, m, w, h = parse_input(stdin)\n\n    # sand_height[i][j] is the amount of sand color j in section i\n    sand_height = [[0 for j in range(m)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            sand_height[i][j] = parse_str_to_int(stdin.readline())\n\n    dividers = []\n    for i in range(n - 1):\n        dividers.append(parse_str_to_int(stdin.readline()))\n\n    sorted_dividers = sorted(dividers)\n\n    # min_per_section[i] is the minimum amount of sand color j that must be put in section i\n    min_per_section = [0 for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(n):\n                min_per_section[i] += min(sand_height[k][j], w * h - sand_height[i][j])\n\n    distances = []\n    for i in range(n - 1):\n        distances.append(parse_str_to_int(stdin.readline()))\n\n    for i in range(n - 1):\n        for j in range(m):\n            max_val = max(sand_height[i][j], sand_height[i + 1][j])\n            min_val = min(sand_height[i][j], sand_height[i + 1][j])\n            max_per_section[i] += min_val\n            min_per_section[i + 1] += max_val\n\n    dist = -float('inf')\n    for i in range(n - 1):\n        dist = max(dist, distances[i] * min_per_section[i + 1] - distances[i] * max_per_section[i])\n\n    return round(dist, 3)\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\""
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, n, m, _ = stdin.split()\n    _, w, h, _ = stdin.split()\n    v = stdin.split()\n    x = stdin.split()\n    _, *d = stdin.split()\n    # _, *d = [float(x) for x in stdin.split()]\n    x = [float(x) for x in x]\n    d = [float(x) for x in d]\n    v = [float(x) for x in v]\n    # return str(solution(n, m, w, h, v, x, d))\n    soln = float('inf')\n    for i in range(n):\n        soln = min(soln, max(d[i], x[i]) - min(d[i], x[i]))\n    return str(round(soln, 3))\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    \u89e3\u8aac\u3068\u306a\u308b\u3088\u3046\u306a\u624b\u9806\n\n    1. \u307e\u305a\u3001\u5165\u529b\u304b\u3089N, M, W, H\u3092\u53d6\u5f97\u3059\u308b\n    2. \u77f3\u306e\u89e3\u50cf\u5ea6\u306e\u914d\u5217\u3092\u53d6\u5f97\u3059\u308b\n    3. \u6b21\u306b\u3001\u5404\u8272\u306e\u77f3\u306e\u6570\u3092\u53d6\u5f97\u3059\u308b\n    4. \u6700\u7d42\u7684\u306b\u3001\u5404\u30bb\u30af\u30b7\u30e7\u30f3\u306e\u6700\u5927\u5024\u3068\u6700\u5c0f\u5024\u306e\u5dee\u3092\u8a08\u7b97\u3059\u308b\n    '''\n    n, m, w, h = list(map(int, stdin.split()))\n    s_list = list(map(float, stdin.split()))\n    s_list.sort()\n    color_list = []\n    for i in range(m):\n        color_list.append(int(stdin.split()[i]))\n\n    # \u5404\u30bb\u30af\u30b7\u30e7\u30f3\u306e\u6700\u5927\u5024\u3068\u6700\u5c0f\u5024\u306e\u5dee\u3092\u8a08\u7b97\u3059\u308b\n    min_list = []\n    max_list = []\n    for i in range(n):\n        min_list.append(s_list[i * m + color_list[i] - 1])\n        max_list.append(s_list[i * m + color_list[i] - 1])\n    max_list.sort(reverse=True)\n    min_list.sort()\n\n    # \u7b54\u3048\n    ans = (max_list[0] - min_list[0]) * 1.0 / h\n    return str(round(ans, 3))"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns the minimum difference between the maximum and minimum heights of sand in the sections\n    '''\n    N, M, W, H = map(int, stdin.split()[:4])\n    v = list(map(float, stdin.split()[4:]))\n    div = [list(map(float, stdin.split()[4+i:4+i+M])) for i in range(N-1)]\n    mins = [list(map(float, stdin.split()[4+N+i:4+N+i+M])) for i in range(N)]\n    maxs = [list(map(float, stdin.split()[4+N*2+i:4+N*2+i+M])) for i in range(N)]\n    result = float(\"inf\")\n    for i in range(N):\n        s = [v[j] for j in range(M) if mins[i][j] <= div[i][j] <= maxs[i][j]]\n        result = min(result, max(s) - min(s))\n    return str(round(result, 3))"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\n   ...     \"2 2 5 5\\n2.0 2.0\\n4.0\\n1.0 0.0\\n0.0 1.0\\n1.0 0.0\\n0.0 2.0\"\n   ... )\n    '0.750'\n    \"\"\"\n    _, n, m, w, h = stdin.split()\n    v = list(map(float, stdin.split()[1 : n + 1]))\n    x = list(map(float, stdin.split()[n + 1 :]))\n\n    min_per_section = [float(\"inf\")] * n\n    max_per_section = [0] * n\n\n    for i in range(n):\n        min_per_section[i] = float(\"inf\")\n        for j in range(m):\n            min_per_section[i] = min(min_per_section[i], v[j] * x[i])\n            max_per_section[i] += v[j] - min_per_section[i]\n\n    return min(max_per_section) / h\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the minimum possible difference\n    between the maximum and minimum heights of sand in the sections.\n    \"\"\"\n    width, height, n = [int(x) for x in stdin.split()]\n    \n    # get the volume of sand for each color\n    volumes = [float(x) for x in stdin.split()[1:]]\n    \n    # get the distances from the left wall of each divider\n    distances = [float(x) for x in stdin.split()[2:]]\n    distances.sort()\n    \n    # get minimums and maximums for each section\n    mins = []\n    maxs = []\n    for _ in range(n - 1):\n        l, m, h = [float(x) for x in stdin.split()[3 * _ + 3: 3 * _ + 6]]\n        mins.append(l)\n        maxs.append(h)\n        \n    # find the minimum and maximum heights of sand in the sections\n    highest_volume = 0\n    lowest_volume = 1e9\n    for _ in range(n):\n        highest_volume = max(highest_volume, volumes[_])\n        lowest_volume = min(lowest_volume, volumes[_])\n    \n    # calculate the minimum difference between the two heights\n    minimum_difference = 1e9\n    for _ in range(n - 1):\n        section_height = maxs[_] - mins[_]\n        if section_height < lowest_volume:\n            continue\n        distance_from_left = distances[_]\n        if section_height > highest_volume:\n            continue\n        \n        # calculate the minimum difference between the section's\n        # height and the minimum and maximum heights of sand in the section\n        difference = 1e9\n        for _ in range(n):\n            if section_height < maxs[_] - mins[_]:\n                difference = min(difference, abs(maxs[_] - mins[_] - section_height))\n        \n        # check if the calculated minimum difference is lower than the current minimum\n        if difference < minimum_difference:\n            minimum_difference = difference\n            \n    return str(round(minimum_difference, 3))\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the smallest difference between the maximum and minimum heights of sand in the sections.\"\"\"\n    n, m, w, h = map(int, stdin.readline().split())\n    v = [float(i) for i in stdin.readline().split()]\n    x = [float(i) for i in stdin.readline().split()]\n    min_ = [float(i) for i in stdin.readline().split()]\n    max_ = [float(i) for i in stdin.readline().split()]\n    max_ = [i for i in reversed(max_)]\n    min_ = [i for i in reversed(min_)]\n    v.sort()\n    x.sort()\n    min_total = 0\n    max_total = 0\n    total = 0\n    for i in range(n):\n        total += v[i]\n        max_total = max(max_total, total)\n    for i in range(n - 1):\n        total = 0\n        for j in range(i, n):\n            total += v[j]\n            max_total = max(max_total, total)\n        min_total = min(min_total, abs(max_total - total))\n    return f'{min_total:.3f}'\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    mat = [[0 for _ in range(n)] for _ in range(m)]\n    # initializing the input matrix\n    for i in range(m):\n        mat[i] = list(map(int, stdin.split()[i]))\n    # for each row, we check the possible values of the middle column\n    # and create a list of all possible combinations of the middle\n    # column of a given row\n    res = []\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 0:\n                for l in range(1, 10):\n                    for k in range(j + 1, n):\n                        if (mat[i][j] * l == mat[i][k] + mat[i][k - 1]):\n                            for u in range(1, 10):\n                                if u not in [mat[i][j], mat[i][k - 1]]:\n                                    for r in range(k + 1, n):\n                                        if (u * r == mat[i][j] + mat[i][k - 1]):\n                                            for c in range(i + 1, m):\n                                                if c!= i + 1 and c!= i + 2 and c!= i + 3 and c!= i + 4 and c!= i + 5 and c!= i + 6 and c!= i + 7 and c!= i + 8 and c!= i + 9:\n                                                    if (mat[c][j] * l == mat[c][k] + mat[c][k - 1]):\n                                                        for d in range(1, 10):\n                                                            if d not in [mat[c][j], mat[c][k - 1]]:\n                                                                for e in range(k + 1, n):\n                                                                    if (d * e == mat[c][j] + mat[c][k - 1]):\n                                                                        for f in range(i + 1, m):\n                                                                            if f!= i + 1 and f!= i + 2 and f!= i + 3 and f!= i + 4 and f!= i + 5 and f!= i + 6 and f!= i + 7 and f!= i + 8 and f!= i + 9:\n                                                                                if (mat[f][j] * l == mat[f][k] + mat[f][k - 1]):\n                                                                                    for g in range(1, 10):\n                                                                                        if g not in [mat[f][j], mat[f][k - 1]]:\n                                                                                            for h in range(k + 1, n):\n                                                                                                if (g * h == mat[f][j] + mat[f][k - 1]):\n                                                                                                    if c not in [i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9] and f not in [i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9]:\n                                                                                                        if (mat[i][j] * l == mat[i][k] + mat[i][k - 1] and mat[c][j] * l == mat[c][k] + mat[c][k - 1] and mat[f][j] * l == mat[f][k] + mat[f][k - 1]):\n                                                                                                            res.append([mat[i], mat[c], mat[f], mat[i][j], mat[i][k], mat[i][k - 1], mat[c][j], mat[c][k], mat[c][k - 1], mat[f][j], mat[f][k], mat[f][k - 1]])\n    # now we create a dictionary of possible combinations and their count\n    # in which we also check for the validity of the code\n    count = 0\n    res = list(dict.fromkeys(res))\n    for x in res:\n        if check_valid_code(x):\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates the number of possible codes from a partial code.\n\n    Args:\n        stdin (str): Input from stdin.\n\n    Returns:\n        str: Output to stdout.\n    \"\"\"\n    # Get all possible digits\n    digits = [i for i in range(10)]\n    # Get all combinations of all possible rows and columns\n    rows = [i for i in range(3, 6 + 1)]\n    cols = [i for i in range(3, 6 + 1)]\n\n    # Create dict of all possible combinations of rows and columns\n    combos = {}\n    for row in rows:\n        for col in cols:\n            combos[(row, col)] = []\n\n    # Make dictionary of all combinations\n    for i in digits:\n        for row in rows:\n            for col in cols:\n                if i in [1, 2, 3, 4, 6, 7, 8, 9]:\n                    combos[(row, col)].append(i)\n\n    # Filter dict by eliminating numbers that are not possible for a valid code\n    for k, v in combos.items():\n        for i in range(9, 0, -1):\n            v = list(filter(lambda x: x!= i, v))\n            combos[k] = v\n\n    # Create dict of all codes from a given partial code\n    partial_codes = {}\n    for row in rows:\n        for col in cols:\n            partial_codes[(row, col)] = []\n            for i in combos[(row, col)]:\n                partial_codes[(row, col)].append([i])\n\n    # Add 0's to partial codes\n    for row in rows:\n        for col in cols:\n            partial_codes[(row, col)].append([0])\n\n    # Add all possible combinations of rows and columns with the same number of 0's\n    for row in rows:\n        for col in cols:\n            num_zeros = row + col - 2\n            if num_zeros in [1, 2]:\n                for i in range(1, 10):\n                    partial_codes[(row, col)].append([0, i])\n                for i in range(10, 100):\n                    partial_codes[(row, col)].append([0, i, i * 10])\n                for i in range(100, 1000):\n                    partial_codes[(row, col)].append([0, i, i * 10, i * 100])\n            if num_zeros in [3, 4]:\n                for i in range(10, 100):\n                    partial_codes[(row, col)].append([0, i, i * 10])\n                for i in range(100, 1000):\n                    partial_codes[(row, col)].append([0, i, i * 10, i * 100])\n            if num_zeros in [5, 6]:\n                for i in range(100, 1000):\n                    partial_codes[(row, col)].append([0, i, i * 10, i * 100])\n\n    # Get valid codes\n    valid_codes = []\n    for key, values in partial_codes.items():\n        for code in values:\n            valid = True\n            for i in range(len(code)):\n                if i == len(code) - 1:\n                    break\n                if code[i] == 0:\n                    continue\n                for j in range(i + 1, len(code)):\n                    if code[i] == 0 or code[j] == 0:\n                        continue\n                    if code[i] * code[j] == code[i] + code[j] or code[i] * code[j] == code[i] - code[j] or code[i] * code[j] == code[j] - code[i]:\n                        pass\n                    elif code[i] * code[j] == code[j] - code[i] or code[j] * code[i] == code[j] - code[i]:\n                        valid = False\n            if valid:\n                valid_codes.append(code)\n\n    # Find the number of valid codes\n    valid_codes = list(map(list, set(map(tuple, valid_codes))))\n    count = 0\n    for i in range(len(valid_codes)):\n        for j in range(i + 1, len(valid_codes)):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    (m, n) = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(m):\n        grid.append(list(map(int, stdin.readline().split())))\n\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            for k in range(j + 1, n):\n                if grid[i][k] == 0:\n                    continue\n                for l in range(i + 1, m):\n                    if grid[l][k] == 0:\n                        continue\n                    if grid[l][j] == 0:\n                        continue\n                    if grid[i][j] * grid[i][k] == grid[l][j] + grid[l][k] or grid[i][j] * grid[i][k] == grid[l][j] - grid[l][k] or grid[i][k] * grid[i][j] == grid[l][j] + grid[l][k] or grid[i][k] * grid[i][j] == grid[l][j] - grid[l][k]:\n                        ans += 1\n\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = []\n    for i in range(m):\n        grid.append(list(map(int, stdin.split())))\n    \n    count = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                count += 1\n                \n    if count == m*n:\n        return str(count)\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                x, y = i, j\n                break\n    \n    \n    for i in range(1, m+n-1):\n        for l in range(1, m+n-i):\n            u = i - l\n            r = i + l\n            if u == 0 or r == m+n-1:\n                continue\n            \n            if grid[x][y+u] * grid[x][y+l] == grid[x][y+u] + grid[x][y+l]:\n                grid[x][y+u] = grid[x][y+l] = 0\n                count += 1\n            elif grid[x][y+u] * grid[x][y+l] == grid[x][y+u] - grid[x][y+l]:\n                grid[x][y+u] = grid[x][y+l] = 0\n                count += 1\n            elif grid[x][y+u] * grid[x][y+l] == grid[x][y+l] - grid[x][y+u]:\n                grid[x][y+u] = grid[x][y+l] = 0\n                count += 1\n            elif grid[x][y+u] * grid[x][y+l] == grid[x][y+u] // grid[x][y+l]:\n                grid[x][y+u] = grid[x][y+l] = 0\n                count += 1\n            elif grid[x][y+u] * grid[x][y+l] == grid[x][y+l] // grid[x][y+u]:\n                grid[x][y+u] = grid[x][y+l] = 0\n                count += 1\n            else:\n                continue\n    \n    return str(count)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the number of possible solutions for the guard's code.\"\"\"\n    m, n = map(int, stdin.split())\n    first = [list(map(int, stdin.split())) for _ in range(m)]\n    second = [list(map(int, stdin.split())) for _ in range(m)]\n    third = [list(map(int, stdin.split())) for _ in range(m)]\n    fourth = [list(map(int, stdin.split())) for _ in range(m)]\n\n    solutions = 0\n\n    # one solution is possible without any omitted digits\n    if 0 in first[0] and 0 in first[1]:\n        solutions += 1\n    for i, row in enumerate(first):\n        if 0 in row:\n            first[i] = [x for x in row if x!= 0]\n    if 0 in first[0] and 0 in first[1]:\n        solutions += 1\n    for i, row in enumerate(first):\n        if len(row) > 1:\n            for j in range(len(row)):\n                if j == 0 and row[j] == 0:\n                    if row[j + 1] == 0:\n                        solutions += 1\n                elif j == len(row) - 1 and row[j] == 0:\n                    if row[j - 1] == 0:\n                        solutions += 1\n                elif row[j] == 0:\n                    if row[j + 1] == 0 or row[j - 1] == 0:\n                        solutions += 1\n\n    # two solutions are possible with one omitted digit\n    for i, row in enumerate(second):\n        if 0 in row:\n            second[i] = [x for x in row if x!= 0]\n    for i, row in enumerate(second):\n        if len(row) > 1:\n            for j in range(len(row)):\n                if j == 0 and row[j] == 0:\n                    if row[j + 1] == 0 and row[j + 2] == 0:\n                        solutions += 1\n                elif j == len(row) - 1 and row[j] == 0:\n                    if row[j - 1] == 0 and row[j - 2] == 0:\n                        solutions += 1\n                elif row[j] == 0:\n                    if row[j + 1] == 0 and row[j - 1] == 0:\n                        solutions += 1\n\n    # three solutions are possible with two omitted digits\n    for i, row in enumerate(third):\n        if 0 in row:\n            third[i] = [x for x in row if x!= 0]\n    for i, row in enumerate(third):\n        if len(row) > 1:\n            for j in range(len(row)):\n                if j == 0 and row[j] == 0:\n                    if row[j + 1] == 0 and row[j + 2] == 0 and row[j + 3] == 0:\n                        solutions += 1\n                elif j == len(row) - 1 and row[j] == 0:\n                    if row[j - 1] == 0 and row[j - 2] == 0 and row[j - 3] == 0:\n                        solutions += 1\n                elif row[j] == 0:\n                    if row[j + 1] == 0 and row[j - 1] == 0:\n                        solutions += 1\n\n    # four solutions are possible with three omitted digits\n    for i, row in enumerate(fourth):\n        if 0 in row:\n            fourth[i] = [x for x in row if x!= 0]\n    for i, row in enumerate(fourth):\n        if len(row) > 1:\n            for j in range(len(row)):\n                if j == 0 and row[j] == 0:\n                    if row[j + 1] == 0 and row[j + 2] == 0 and row[j + 3] == 0 and row[j + 4] == 0:\n                        solutions += 1\n                elif j == len(row) - 1 and row[j] == 0:\n                    if row[j - 1] == 0 and row[j - 2] == 0 and row[j - 3] == 0 and row[j - 4] == 0:\n                        solutions += 1\n                elif row[j] == 0:\n                    if row[j + 1] == 0 and row[j - 1] == 0:\n                        solutions += 1\n\n    return str(solutions)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    m, n = map(int, stdin.split())\n    # for each digit, assign the first three digits to it\n    # second three digits to its right\n    # third three digits to the sum of first three and second three\n    # fourth three digits to the difference of first three and second three\n    # fifth three digits to the product of first three and second three\n    # sixth three digits to the quotient of first three and second three\n    # seventh three digits to the sum of first three, second three, third three and fourth three\n    # eighth three digits to the difference of first three, second three, third three, fourth three and fifth three\n    # ninth three digits to the product of first three, second three, third three, fourth three, fifth three and sixth three\n    # tenth three digits to the quotient of first three, second three, third three, fourth three, fifth three, sixth three and seventh three\n    # eleventh three digits to the sum of first three, second three, third three, fourth three, fifth three, sixth three, seventh three and eighth three\n    # twelfth three digits to the difference of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three and ninth three\n    # thirteenth three digits to the product of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three and eleventh three\n    # fourteenth three digits to the quotient of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three and twelfth three\n    # fifteenth three digits to the sum of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three and fourteenth three\n    # sixteenth three digits to the difference of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three, fourteenth three and fifteenth three\n    # seventeenth three digits to the product of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three, fourteenth three, fifteenth three and sixteenth three\n    # eighteen three digits to the quotient of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three, fourteenth three, fifteenth three, sixteenth three, seventeenth three and eighteenth three\n    # nineteenth three digits to the sum of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three, fourteenth three, fifteenth three, sixteenth three, seventeenth three, eighteen three and nineteenth three\n    # twentieth three digits to the difference of first three, second three, third three, fourth three, fifth three, sixth three, seventh three, eighth three, ninth three, tenth three, eleventh three, twelfth three, thirteenth three, fourteenth three, fifteenth three, sixteenth three, seventeenth three, eighteen three, nineteenth three and twentieth three\n    return (\n        # the solution is equal to the total number of permutations of the first $m*n-1$ digits,\n        # minus the number of permutations of the first $m-1$ digits that don't satisfy the conditions above\n        str(\n            # the number of permutations for the first $m*n-1$ digits\n            math.factorial(m * n - 1)\n            # the number of permutations for the first $m-1$ digits\n            - math.factorial(m - 1)\n            # the number of permutations for the last $m*n-1$ digits\n            - math.factorial(n - 1)\n        )\n    )\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    mapper = {'0': [], '1': [], '2': [], '3': [], '4': [], '5': [], '6': [], '7': [], '8': [], '9': []}\n    for _ in range(m):\n        mapper[stdin.split()[0]].append(list(map(int, stdin.split()[1:])))\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if mapper[str(i)][j-1]!= 0 and mapper[str(i)][j-1]!= i:\n                for k in range(1, m+1):\n                    if mapper[str(i)][k-1]!= 0 and mapper[str(i)][k-1]!= k:\n                        for l in range(1, m+1):\n                            if mapper[str(i)][l-1]!= 0 and mapper[str(i)][l-1]!= l:\n                                if mapper[str(i)][j-1]*mapper[str(i)][k-1] == mapper[str(i)][j-1]+mapper[str(i)][k-1]:\n                                    if mapper[str(i)][j-1]*mapper[str(i)][l-1] == mapper[str(i)][j-1]+mapper[str(i)][l-1]:\n                                        if mapper[str(i)][k-1]*mapper[str(i)][l-1] == mapper[str(i)][k-1]+mapper[str(i)][l-1]:\n                                            count += 1\n    return count"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution reads in the input, iterates over the grid to find the number of\n    solutions, and then returns the solution in a string.\n    \"\"\"\n    rows, cols = [int(x) for x in stdin.split()]\n    grid = [stdin.split() for _ in range(rows)]\n\n    return f'{solve(grid)}'\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of possible codes for the given grid.\"\"\"\n    m, n = map(int, stdin.split())\n    grid = [list(map(int, stdin.split())) for _ in range(m)]\n    print(sum(len(get_possible_codes(row)) for row in grid))\n\n\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(i) for i in stdin.split('\\n')[:2]]\n    dials = stdin.split('\\n')[2:]\n\n    result = []\n    for i in range(M):\n        A, B = [int(i) for i in stdin.split('\\n')[2 + i].split(' ')[:2]]\n        result.append(str(sum([int(i) for i in dials[A - 1:B]])))\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split('\\n')[0].split(' ')))\n    numbers = stdin.split('\\n')[1:]\n\n    sum_list = []\n    for i in range(M):\n        A, B = list(map(int, stdin.split('\\n')[i + 1].split(' ')))\n        sum_list.append(sum([int(numbers[A - 1][i]) for i in range(B - A + 1)]))\n\n    return '\\n'.join([str(num) for num in sum_list])\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return stdout\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(' '))\n    dials = list(map(int, stdin.split('\\n')[1:]))\n    for _ in range(M):\n        A, B = map(int, stdin.split('\\n')[2:][0].split(' '))\n        sum = 0\n        for i in range(A - 1, B):\n            sum += dials[i]\n        print(sum)\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dials = list(map(int, stdin.split()))\n    ans = []\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        ans.append(sum(dials[A - 1:B]))\n        dials[A - 1] += 1\n        if dials[A - 1] == 10:\n            dials[A - 1] = 0\n        dials[B] += 1\n        if dials[B] == 10:\n            dials[B] = 0\n    print(\"\\n\".join(map(str, ans)))\n    return \"\"\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(\"\\n\")[0].split()]\n    l = list(map(int, stdin.split(\"\\n\")[1:]))\n    l.sort()\n    for _ in range(m):\n        a, b = [int(x) for x in stdin.split(\"\\n\")[_].split()]\n        s = sum(l[a - 1:b])\n        print(s)\n    return \"\"\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = stdin.split()\n    N, M = int(N), int(M)\n    nums = stdin.splitlines()[1:]\n    for i in range(M):\n        nums[i] = [int(n) for n in nums[i].split()]\n    answer = []\n    for i in range(M):\n        answer.append(sum(nums[i]))\n    return '\\n'.join(str(x) for x in answer)\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    nums = [int(c) for c in stdin.split()[0]]\n    res = []\n    for _ in range(M):\n        A, B = map(int, stdin.split()[1:])\n        res.append('%d\\n' % (sum(nums[A-1:B])))\n        nums[A-1] += 1\n        if nums[A-1] == 10:\n            nums[A-1] = 0\n            for i in range(A, B):\n                nums[i] += 1\n                if nums[i] == 10:\n                    nums[i] = 0\n    return ''.join(res)\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the max number of producers to run such that all products can be delivered to the warehouse and each conveyor belt\n    only transports one product at a time. The only difference between this problem and the one in the first section\n    is that we now have multiple producers which are in the form of (junction_id, conveyor_belt_id),\n    rather than a single producer which is in the form of (junction_id, conveyor_belt_id).\"\"\"\n    _, producers_num, conveyors_num = stdin.split('\\n')[0].split(' ')\n    producers_num = int(producers_num)\n    conveyors_num = int(conveyors_num)\n    edges = []\n    for line in stdin.split('\\n')[1:]:\n        start, end = line.split(' ')\n        edges.append((int(start), int(end)))\n    producers = set()\n    for edge in edges:\n        producers.add((edge[0], edge[1]))\n    ans = {}\n    conveyors = defaultdict(set)\n    for start, end in edges:\n        conveyors[start].add(end)\n    for producer in producers:\n        ans[producer] = 0\n        for conveyor in conveyors[producer[0]]:\n            total = producer[1] * producers_num + producer[0]\n            if total > conveyors_num:\n                break\n            ans[producer] = max(ans[producer], conveyor)\n    return max(ans.values())\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    solution: str -> str\n    This function takes a valid input string and returns a valid output string\n    based on the given rules.\n    '''\n    # get N, K, M from input string\n    N, K, M = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    # create an empty graph, with an entry for each junction\n    graph = {}\n    # add directed edges to the graph\n    for _ in range(M):\n        a, b = [int(x) for x in stdin.split('\\n')[_].split(' ')]\n        if a not in graph.keys():\n            graph[a] = []\n        if b not in graph.keys():\n            graph[b] = []\n        graph[a].append(b)\n        graph[b].append(a)\n    # create a set of edges representing the set of allowed edges\n    edges = set()\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i!= j:\n                edges.add(tuple((i, j)))\n    # create a list of products, with their paths, to be stored in the answer\n    # set product_to_route to avoid duplicates\n    products = []\n    product_to_route = {}\n    # turn off all the producers for a single run\n    turn_off = set()\n    # turn_on all the producers for a single run\n    turn_on = set()\n    # turn_off = {(1,2), (3,4), (3,5)}\n    # turn_on = {(2,3), (4,5)}\n    # while not all the producers are turned off\n    while len(turn_off) < K:\n        # turn off all the producers for a single run\n        turn_off = set()\n        # turn on all the producers for a single run\n        turn_on = set()\n        # while not all the products have their paths recorded\n        while len(products) < K:\n            # reset the path for each product\n            path = {1}\n            # set a maximum number of times the path can be repeated\n            max_times = 0\n            # if the path for the product is still being determined\n            if len(path) > max_times:\n                # iterate through all the edges\n                for edge in edges:\n                    # if the current edge is not in the path\n                    if edge not in path:\n                        # turn off the producer at the edge\n                        turn_off.add(edge)\n                        # turn on the producer at the edge\n                        turn_on.add(edge)\n                        # add the edge to the path\n                        path.add(edge)\n                        # if the path is now the longest path for the product\n                        if len(path) > max_times:\n                            # add the edge to the answer list\n                            products.append(edge)\n                            # add the edge to the dictionary of products\n                            product_to_route[edge] = [len(path)]\n                        # turn off all the producers\n                        turn_off = set()\n                        # turn on all the producers\n                        turn_on = set()\n    # find the unique set of routes for each product\n    route_set = {}\n    for product in products:\n        route_set[product] = set(product_to_route[product])\n    # if there is only one unique set of routes, then the solution is 1\n    if len(route_set) == 1:\n        return str(1)\n    # if there is more than one unique set of routes, then the solution is 0\n    elif len(route_set) > 1:\n        return str(0)\n    # if there are multiple products with multiple unique sets of routes, then the solution is the maximum number of producers that can be turned off for this to work\n    else:\n        return str(max(turn_off))"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the maximum number of producers that can be left running such that all the produced products can be delivered to the warehouse and each conveyor belt transports at most one product at any time.\"\"\"\n    from sys import stdin, stdout\n    from collections import defaultdict\n    INF = float('inf')\n    def bfs(start, graph, parent, vis):\n        q = [start]\n        vis[start] = 1\n        while q:\n            v = q.pop(0)\n            for i in graph[v]:\n                if not vis[i]:\n                    vis[i] = 1\n                    q.append(i)\n                    parent[i] = v\n        return parent\n\n    def dfs(start, graph, vis, comp, p, ans):\n        vis[start] = 1\n        ans += 1\n        for i in graph[start]:\n            if not vis[i]:\n                comp[i] = p\n                dfs(i, graph, vis, comp, p, ans)\n\n    N, K, M = [int(i) for i in stdin.readline().strip().split(' ')]\n    edges = []\n    for i in range(M):\n        s, t = [int(i) for i in stdin.readline().strip().split(' ')]\n        edges.append((s, t))\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n    vis = [0] * (N + 1)\n    parent = [0] * (N + 1)\n    parent = bfs(1, graph, parent, vis)\n    ans = 0\n    comp = [0] * (N + 1)\n    dfs(1, graph, vis, comp, 1, ans)\n    for i in range(1, N + 1):\n        ans += max(0, comp[i] - i)\n    stdout.write(str(max(ans - K, 0)) + '\\n')\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from math import inf\n    num_of_junction, num_of_producer, num_of_belt = [int(x) for x in stdin.split()]\n    edges = []\n    for i in range(num_of_belt):\n        src, dest = [int(x) for x in stdin.split()]\n        edges.append((src, dest))\n    adj_matrix = [[inf] * num_of_junction for _ in range(num_of_junction)]\n    for src, dest in edges:\n        adj_matrix[src - 1][dest - 1] = 1\n        adj_matrix[dest - 1][src - 1] = 1\n    for i in range(num_of_junction):\n        for j in range(num_of_junction):\n            if j == i:\n                adj_matrix[i][j] = 0\n            else:\n                adj_matrix[i][j] = 1\n    num_of_time_slot = min(num_of_junction, num_of_producer + 1)\n    for i in range(num_of_junction):\n        for j in range(num_of_junction):\n            if i == j:\n                continue\n            for k in range(num_of_junction):\n                if i == k:\n                    continue\n                if k == j:\n                    continue\n                if adj_matrix[i][j] <= 1 or adj_matrix[j][k] <= 1 or adj_matrix[i][k] <= 1:\n                    adj_matrix[i][j] = 1\n    num_of_junction_left = num_of_junction\n    for i in range(num_of_time_slot):\n        for j in range(num_of_junction):\n            if i == 0 or i == num_of_time_slot - 1:\n                num_of_junction_left -= 1\n                if num_of_junction_left == 0:\n                    break\n                continue\n            if adj_matrix[j][j] == inf:\n                continue\n            for k in range(num_of_junction):\n                if k == j:\n                    continue\n                if adj_matrix[j][k] == 1:\n                    adj_matrix[j][k] = inf\n                    adj_matrix[k][j] = inf\n    if num_of_junction_left == 1:\n        return num_of_producer\n    for i in range(num_of_time_slot):\n        for j in range(num_of_junction):\n            if adj_matrix[j][j] == inf:\n                continue\n            for k in range(num_of_junction):\n                if k == j:\n                    continue\n                if adj_matrix[j][k] == 1:\n                    adj_matrix[j][k] = inf\n                    adj_matrix[k][j] = inf\n    result = [[0] * num_of_junction for _ in range(num_of_junction)]\n    for i in range(num_of_time_slot):\n        for j in range(num_of_junction):\n            for k in range(num_of_junction):\n                result[j][k] = result[j][k] + adj_matrix[j][k]\n    max_num_of_producer = 0\n    for j in range(num_of_junction):\n        for k in range(num_of_junction):\n            max_num_of_producer = max(result[j][k], max_num_of_producer)\n    return max_num_of_producer\n\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum number of producers that can be left running such that all the produced products can be delivered to the warehouse and each conveyor belt transports at most one product at any time.\n\n    :param str stdin: the input of the function\n    :rtype: str\n    :return: the solution of the function\n    \"\"\"\n\n    N, K, M = [int(i) for i in stdin.split()]\n\n    edges = []\n    for _ in range(M):\n        a, b = [int(i) for i in stdin.split()[1:]]\n        edges.append((a, b))\n\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        graph[edge[0]].append(edge[1])\n\n    queue = deque([1])\n    visited = set()\n    result = 0\n    while queue:\n        current = queue.popleft()\n        if current in visited:\n            continue\n        visited.add(current)\n        if current == N:\n            result += 1\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n\n    return result\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum number of producers that can be left running such that all the produced products can be delivered to the warehouse and each conveyor belt transports at most $1$ product at any time.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: implement me\n    return \"None\"\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds solution for factory problem\"\"\"\n    pass  # pylint: disable=unnecessary-pass\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    triangles_g = [tuple(map(int, line.split())) for line in stdin.strip().split(\"\\n\")]\n    triangles_j = [tuple(map(int, line.split())) for line in stdin.strip().split(\"\\n\")]\n\n    s = set()\n    for t in triangles_g:\n        s.add((t[0], t[1], t[2]))\n        s.add((t[0], t[1], -t[2]))\n        s.add((t[0], -t[1], t[2]))\n        s.add((t[0], -t[1], -t[2]))\n        s.add((-t[0], t[1], t[2]))\n        s.add((-t[0], t[1], -t[2]))\n        s.add((-t[0], -t[1], t[2]))\n        s.add((-t[0], -t[1], -t[2]))\n    for t in triangles_j:\n        s.add((t[0], t[1], t[2]))\n        s.add((t[0], t[1], -t[2]))\n        s.add((t[0], -t[1], t[2]))\n        s.add((t[0], -t[1], -t[2]))\n        s.add((-t[0], t[1], t[2]))\n        s.add((-t[0], t[1], -t[2]))\n        s.add((-t[0], -t[1], t[2]))\n        s.add((-t[0], -t[1], -t[2]))\n\n    return \"yes\" if len(s) == len(triangles_g) else \"no\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for this problem.\"\"\"\n    stdin = stdin.splitlines()\n    garry = stdin[0]\n    jerry = stdin[1]\n    # Parse the input.\n    garry = [list(map(int, t.split())) for t in garry.split(\"\\n\")]\n    jerry = [list(map(int, t.split())) for t in jerry.split(\"\\n\")]\n    return \"yes\" if garry == jerry else \"no\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    triangle_1 = list(map(int, stdin.readline().split()))\n    m = int(stdin.readline())\n    triangle_2 = list(map(int, stdin.readline().split()))\n    assert n == m\n    for i in range(m):\n        triangle_1_i = [triangle_1[2*i], triangle_1[2*i+1]]\n        triangle_2_i = [triangle_2[2*i], triangle_2[2*i+1]]\n        triangle_1_i_x_min, triangle_1_i_x_max = min(triangle_1_i[0], triangle_1_i[1]), max(triangle_1_i[0], triangle_1_i[1])\n        triangle_1_i_y_min, triangle_1_i_y_max = min(triangle_1_i[0], triangle_1_i[1]), max(triangle_1_i[0], triangle_1_i[1])\n        triangle_2_i_x_min, triangle_2_i_x_max = min(triangle_2_i[0], triangle_2_i[1]), max(triangle_2_i[0], triangle_2_i[1])\n        triangle_2_i_y_min, triangle_2_i_y_max = min(triangle_2_i[0], triangle_2_i[1]), max(triangle_2_i[0], triangle_2_i[1])\n        if triangle_1_i_x_min <= triangle_2_i_x_min and triangle_1_i_x_max >= triangle_2_i_x_max:\n            if triangle_1_i_y_min <= triangle_2_i_y_min and triangle_1_i_y_max >= triangle_2_i_y_max:\n                return \"yes\"\n    return \"no\"\n\n\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *data1 = [int(s) for s in stdin.split(\"\\n\")]\n    clouds1 = [tuple(map(int, s.split(\" \"))) for s in data1]\n    m, *data2 = [int(s) for s in stdin.split(\"\\n\")]\n    clouds2 = [tuple(map(int, s.split(\" \"))) for s in data2]\n    clouds = {(t[0], t[1], t[2]) for t in clouds1 + clouds2}\n    if len(clouds) == 0:\n        return \"yes\"\n    elif len(clouds) == 1:\n        return \"no\"\n    else:\n        for a, b, c in itertools.combinations(clouds, 3):\n            clouds.discard((a, b, c))\n            if triangle_intersect(a, b, c):\n                return \"no\"\n        return \"yes\"\n\n\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return 'yes' if solution(stdin) == solution(stdin) else 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip()\n    garry_polygon = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:2]]\n    jerry_polygon = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n    \n    # unpack vertices from polygon\n    g_polygon = list(zip(*garry_polygon))\n    j_polygon = list(zip(*jerry_polygon))\n\n    # find triangles\n    g_triangles = [Triangle(i1, i2, i3) for i1 in g_polygon for i2 in g_polygon for i3 in g_polygon if Triangle(i1, i2, i3) is not None]\n    j_triangles = [Triangle(i1, i2, i3) for i1 in j_polygon for i2 in j_polygon for i3 in j_polygon if Triangle(i1, i2, i3) is not None]\n    \n    # find common triangles\n    common_triangles = set(g_triangles).intersection(set(j_triangles))\n\n    # determine if they are the same\n    if not common_triangles:\n        return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_coordinates(n: int) -> List[Tuple[int, int]]:\n        x_list: List[int] = []\n        y_list: List[int] = []\n        for _ in range(n):\n            x, y = map(int, stdin.readline().split())\n            x_list.append(x)\n            y_list.append(y)\n        return list(zip(x_list, y_list))\n\n    def get_triangles(n: int) -> Set[Tuple[int, int, int]]:\n        triangle_list: List[Tuple[int, int, int]] = []\n        for _ in range(n):\n            x_1, y_1, x_2, y_2, x_3, y_3 = map(int, stdin.readline().split())\n            triangle_list.append((x_1, y_1, x_2, y_2, x_3, y_3))\n        return set(triangle_list)\n\n    def is_intersecting(p1: Tuple[int, int], p2: Tuple[int, int], q1: Tuple[int, int], q2: Tuple[int, int]) -> bool:\n        return max(p1[0], q1[0]) <= min(p2[0], q2[0]) and max(p2[0], q2[0]) <= min(p1[0], q1[0]) and max(p1[1], q1[1]) <= min(p2[1], q2[1]) and max(p2[1], q2[1]) <= min(p1[1], q1[1])\n\n    def is_degenerate(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool:\n        d12: Tuple[float, float] = (p1[0] - p2[0], p1[1] - p2[1])\n        d13: Tuple[float, float] = (p1[0] - p3[0], p1[1] - p3[1])\n        return d12[0] * d13[1] - d12[1] * d13[0] == 0\n\n    def is_same_cloud_cover(Garry_triangles: Set[Tuple[int, int, int]], Jerry_triangles: Set[Tuple[int, int, int]]) -> bool:\n        Garry_triangles_list: List[Tuple[int, int, int]] = list(Garry_triangles)\n        Jerry_triangles_list: List[Tuple[int, int, int]] = list(Jerry_triangles)\n        Garry_triangles_list.sort()\n        Jerry_triangles_list.sort()\n        for G_tuple, J_tuple in zip(Garry_triangles_list, Jerry_triangles_list):\n            if is_intersecting(G_tuple[0:2], G_tuple[2:4], J_tuple[0:2], J_tuple[2:4]) and not is_degenerate(G_tuple[0:2], G_tuple[2:4], J_tuple[0:2]):\n                return False\n        return True\n\n    Garry_triangles: Set[Tuple[int, int, int]] = get_triangles(int(stdin.readline()))\n    Jerry_triangles: Set[Tuple[int, int, int]] = get_triangles(int(stdin.readline()))\n    return 'yes' if is_same_cloud_cover(Garry_triangles, Jerry_triangles) else 'no'\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    g = {x: [] for x in range(1, n + 1)}\n    for _ in range(m):\n        x, y = list(map(int, stdin.split()))\n        g[x].append(y)\n        g[y].append(x)\n    visited = set()\n    def dfs(x):\n        if x in visited:\n            return\n        visited.add(x)\n        for y in g[x]:\n            dfs(y)\n    dfs(1)\n    if len(visited) == n:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(x) for x in stdin.split(\" \")]\n    road_list = []\n    for _ in range(M):\n        road_list.append([int(x) for x in stdin.split(\" \")])\n    print(road_list)\n    city_list = list(range(1, N + 1))\n    if N == 1:\n        return \"NO\"\n    road_list_set = set()\n    for road in road_list:\n        road_list_set.add((road[0], road[1]))\n        road_list_set.add((road[1], road[0]))\n    if len(road_list_set)!= N:\n        return \"NO\"\n    city_list_set = set(city_list)\n    print(city_list_set, road_list_set)\n    if len(city_list_set)!= N:\n        return \"NO\"\n    print(city_list)\n    print(road_list)\n    for road in road_list:\n        if (road[0], road[1]) not in road_list_set:\n            return \"NO\"\n        elif (road[0], road[1]) in road_list_set:\n            print(\"yes\")\n            city_list_set.remove(road[0])\n            city_list_set.remove(road[1])\n    if len(city_list_set)!= 1:\n        return \"NO\"\n    return \"YES\"\n\n\nassert solution(\n    \"3 3\\n1 2\\n2 3\\n1 3\") == \"YES\\n1 3\\n2 1\\n3 2\"\nassert solution(\n    \"4 3\\n1 2\\n1 3\\n1 4\") == \"NO\"\nassert solution(\n    \"4 4\\n1 2\\n1 3\\n1 4\") == \"NO\"\nassert solution(\n    \"2 3\\n1 2\") == \"NO\"\nassert solution(\n    \"1 3\\n1 2\") == \"NO\"\nassert solution(\n    \"4 3\\n1 2\\n1 3\\n1 4\") == \"YES\\n1 3\\n1 2\\n4 1\"\nassert solution(\n    \"2 4\\n1 2\\n1 3\\n1 4\") == \"NO\"\nassert solution(\n    \"4 5\\n1 2\\n1 3\\n1 4\\n1 5\") == \"NO\"\nassert solution(\n    \"1 5\\n1 2\\n1 3\\n1 4\\n1 5\") == \"NO\"\nassert solution(\n    \"1 4\\n1 2\\n1 3\\n1 4\\n1 5\") == \"NO\"\nassert solution(\n    \"4 4\\n1 2\\n1 3\\n1 4\\n1 5\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"5 6\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"6 6\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"3 3\\n1 2\\n1 3\\n1 4\") == \"NO\"\nassert solution(\n    \"4 5\\n1 2\\n1 3\\n1 4\\n1 5\") == \"NO\"\nassert solution(\n    \"3 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\") == \"NO\"\nassert solution(\n    \"1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\") == \"NO\"\nassert solution(\n    \"3 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\") == \"NO\"\nassert solution(\n    \"4 6\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\") == \"NO\"\nassert solution(\n    \"2 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\") == \"NO\"\nassert solution(\n    \"1 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\") == \"NO\"\nassert solution(\n    \"1 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\") == \"NO\"\nassert solution(\n    \"4 6\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\") == \"NO\"\nassert solution(\n    \"2 4\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\") == \"NO\"\nassert solution(\n    \"1 4\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\") == \"NO\"\nassert solution(\n    \"1 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\") == \"NO\"\nassert solution(\n    \"4 6\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\\n1 12\") == \"NO\"\nassert solution(\n    \"1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\\n1 12\\n1 13\") == \"NO\"\nassert solution(\n    \"1 3\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n1 7\\n1 8\\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution of the problem from the given input\"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    cities, roads = map(int, stdin.split())\n    roads = roads * 2\n    edges = [[] for _ in range(cities + 1)]\n    for _ in range(roads):\n        city1, city2 = map(int, stdin.split())\n        edges[city1].append(city2)\n        edges[city2].append(city1)\n\n    def check(direction: List[int]):\n        for city1, city2 in direction:\n            if city1 in edges[city2]:\n                return False\n        return True\n\n    direction = []\n    for city1 in range(1, cities + 1):\n        for city2 in range(city1 + 1, cities + 1):\n            if check([(city1, city2), (city2, city1)]):\n                direction.append((city1, city2))\n\n    if direction:\n        return 'YES\\n' + '\\n'.join('{} {}'.format(city1, city2) for city1, city2 in direction)\n    return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds a possible solution\n    \"\"\"\n    # O(M)\n    M, N = [int(x) for x in stdin.split('\\n')[0].split()]\n    # O(N)\n    road_map = dict()\n    # O(N)\n    for i in range(1, M + 1):\n        a, b = [int(x) for x in stdin.split('\\n')[i].split()]\n        road_map[a] = road_map.get(a, set())\n        road_map[a].add(b)\n        road_map[b] = road_map.get(b, set())\n        road_map[b].add(a)\n    # O(N)\n    # https://stackoverflow.com/questions/6313308/get-all-possible-combinations-of-a-list-of-lists\n    # O(N!)\n    # Combinations of N length lists\n    all_paths = list(itertools.product([i for i in range(1, N + 1)], repeat=M))\n    # O(N^M)\n    for path in all_paths:\n        # O(M)\n        for i in range(1, M + 1):\n            # O(N)\n            if path[i - 1] in road_map[path[i - 1]]:\n                break\n        else:\n            print('YES')\n            print(*path)\n            return\n    print('NO')\n    return\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds if it is possible to assign one way roads\"\"\"\n    n, m = [int(num) for num in stdin.strip().split()]\n    roads = []\n    for i in range(m):\n        roads.append(\n            [int(num) for num in stdin.strip().split()]\n        )\n    roads.sort()\n    i = 0\n    paths = []\n    while i < m and roads[i][0] == roads[i][1]:\n        paths.append([roads[i][0], roads[i][1]])\n        i += 1\n    if len(paths) > n - 1:\n        return 'NO'\n    if len(paths)!= n - 1:\n        return 'YES'\n    while i < m:\n        if roads[i][0] == roads[i][1]:\n            i += 1\n            continue\n        if roads[i][0]!= roads[i][1]:\n            return 'NO'\n    return 'YES'\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split('\\n')[0].split()]\n    c = [[int(x) for x in line.split()] for line in stdin.split('\\n')[1:]]\n    c.sort(key=lambda x: x[0])\n    c.sort(key=lambda x: x[1])\n    roads = {}\n    for road in c:\n        if road[0] not in roads:\n            roads[road[0]] = set()\n        if road[1] not in roads:\n            roads[road[1]] = set()\n        roads[road[0]].add(road[1])\n        roads[road[1]].add(road[0])\n    cnt = 0\n    for key in roads:\n        if len(roads[key])!= n:\n            cnt += 1\n    if cnt!= 1:\n        print('NO')\n        return\n    print('YES')\n    for road in c:\n        if road[0] not in roads:\n            roads[road[0]] = set()\n        if road[1] not in roads:\n            roads[road[1]] = set()\n        roads[road[0]].remove(road[1])\n        roads[road[1]].remove(road[0])\n        if roads[road[0]] == set() or roads[road[1]] == set():\n            print(road[0], road[1])\n            continue\n        for key in roads:\n            if road[1] in roads[key]:\n                roads[key].remove(road[1])\n                break\n    return\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 3\n   ... 1 2\n   ... 2 3\n   ... 1 3\n   ... \n   ... 1 4\n   ... 1 5\n   ... 2 4\n   ... 2 5\n   ... 3 4\n   ... 3 5\n   ... ''')\n    YES\n    1 3\n    2 1\n    3 2\n    \"\"\"\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    adj = [[False for _ in range(n)] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split('\\n')[_].split(' '))\n        adj[a - 1][b - 1] = True\n        adj[b - 1][a - 1] = True\n\n    ans = True\n    for start in range(n):\n        visited = set()\n        q = [start]\n        while q:\n            q_size = len(q)\n            for _ in range(q_size):\n                node = q.pop(0)\n                if node not in visited:\n                    visited.add(node)\n                    for end in range(n):\n                        if adj[node][end] and end not in visited:\n                            q.append(end)\n            if len(visited)!= n:\n                ans = False\n                break\n        if not ans:\n            break\n    if ans:\n        return 'YES'\n    return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    if n == 1:\n        return 'YES'\n\n    matrix = [[] for _ in range(n)]\n\n    for _ in range(n):\n        for line in stdin:\n            a, b = map(int, line.split())\n            matrix[a - 1].append(b - 1)\n            matrix[b - 1].append(a - 1)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j in matrix[i]:\n                continue\n            else:\n                return 'NO'\n\n    return 'YES'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return \"consistent\" if is_consistent(stdin) else \"inconsistent\"\n\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    p = {0: 0}\n    for i in range(m):\n        k, op, l = list(map(int, stdin.split()))\n        if op == '=':\n            continue\n        if p.get(k, 0) < l:\n            p[k] = l\n        if p.get(l, 0) < k:\n            p[l] = k\n    for i in p:\n        if p.get(i, 0)!= i:\n            return 'inconsistent'\n    return 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = stdin.split(' ')\n    M = int(M)\n    ans = ''\n    # iterate M times and store each reported result\n    for i in range(M):\n        K, L, S = stdin.split(' ')\n        K, L = int(K), int(L)\n        if S == '=':\n            ans = 'inconsistent'\n        elif S == '>':\n            ans = 'consistent'\n    return ans\n\nsolution(stdin)\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # print(n, m)\n    s = []\n    for i in range(m):\n        # print(i)\n        k, v = map(int, stdin.split())\n        # print(k, v)\n        s.append((k, v))\n    # print(s)\n    answer = \"consistent\"\n    for i in range(n):\n        for j in range(n):\n            if i == j: continue\n            if s.count((i, j))!= 0: continue\n            if s.count((j, i)) == 0:\n                answer = \"inconsistent\"\n                break\n        if answer == \"inconsistent\":\n            break\n    return answer\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    scores = []\n    matches = []\n    for i in range(m):\n        scores.append(list(map(int, stdin.split())))\n    for i in range(m):\n        matches.append(list(map(int, stdin.split())))\n    for i in range(m):\n        if scores[i][0] > scores[i][1] and matches[i][0] > matches[i][1]:\n            return 'inconsistent'\n        elif scores[i][0] == scores[i][1] and matches[i][0] == matches[i][1]:\n            return 'inconsistent'\n        elif scores[i][0] < scores[i][1] and matches[i][0] < matches[i][1]:\n            return 'inconsistent'\n    return 'consistent'\nprint(solution(input()))\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 3\n   ... 0 > 1\n   ... 1 = 2\n   ... 0 = 2''')\n    'inconsistent'\n    \"\"\"\n    lst: List[Tuple[int, int, str, int]] = []\n    for i in stdin.split(\"\\n\")[:-1]:\n        k, v, s, _ = i.split()\n        lst.append((int(k), int(v), s, 1))\n    lst.sort()\n    print(lst)\n    a = b = 0\n    for k, v, s, i in lst:\n        if i == 1:\n            if s == \">\":\n                if a > v:\n                    return \"inconsistent\"\n                a = v\n            else:\n                if b > k:\n                    return \"inconsistent\"\n                b = k\n        else:\n            if s == \"=\":\n                if (a > v and b > k) or (a == v and b > k) or (a > v and b == k):\n                    return \"inconsistent\"\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # We read in the number of contestants and matches, respectively, from the first line.\n    # Each line following represents a match.\n    # If the symbol is '=', then the game between the two players was a draw.\n    # If the symbol is '>', then player 1 beat player 2 in a match.\n\n    # Initialize the game variables.\n    contestants = int(stdin.split()[0])\n    matches = int(stdin.split()[1])\n\n    # Initialize a list of lists, representing each match.\n    matches_list = [[0 for _ in range(2)] for _ in range(matches)]\n\n    # Initialize a list of lists, representing the relationship between players.\n    relationship_list = [[0 for _ in range(2)] for _ in range(contestants)]\n\n    # For each match...\n    for index in range(matches):\n\n        # The match is parsed from the input.\n        matches_list[index] = [int(element) for element in stdin.split()[2 + 2 * index: 6 + 2 * index]]\n\n        # The match is parsed.\n        relationship_list[matches_list[index][0]][0] = matches_list[index][1]\n        relationship_list[matches_list[index][1]][1] = matches_list[index][0]\n\n    # Initialize the variable to track the validity of the list of matches.\n    is_valid = True\n\n    # For each player...\n    for index in range(contestants):\n\n        # If that player has no reported matches, we skip over them.\n        if relationship_list[index][0] == 0 and relationship_list[index][1] == 0:\n            continue\n\n        # Initialize a list of lists, which will track the relationship of all the other players to that player.\n        contestants_list = [[0 for _ in range(2)] for _ in range(contestants)]\n\n        # For each match...\n        for match_index in range(matches):\n\n            # If the match is in the list of matches, and the relationship between the players is equal...\n            if (match_index in matches_list) and (relationship_list[match_index][0] == relationship_list[match_index][1]):\n\n                # We add the relationship of that match to that player to the list of relationships of all the other players.\n                contestants_list[matches_list[match_index][0]][0] += relationship_list[match_index][0]\n                contestants_list[matches_list[match_index][1]][0] += relationship_list[match_index][1]\n                contestants_list[matches_list[match_index][0]][1] += 1\n                contestants_list[matches_list[match_index][1]][1] += 1\n\n        # If any of the lists of relationships of all the other players is non-zero...\n        if any([any(element[0]!= 0 for element in contestant_list) for contestant_list in contestants_list]):\n\n            # The list of matches is invalid.\n            is_valid = False\n\n    # The list of matches is consistent.\n    if is_valid:\n        return 'consistent'\n\n    # The list of matches is invalid.\n    return 'inconsistent'\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.splitlines()\n    players = list()\n    for line in stdin[1:]:\n        line = line.split()\n        players.append((int(line[0]), int(line[2]), line[1]))\n\n    def is_same(a, b):\n        if a[1] == b[1]:\n            return False\n        else:\n            return True\n\n    def is_higher(a, b):\n        if a[2] == '>':\n            return True\n        elif a[2] == '=':\n            return False\n        else:\n            return False\n\n    # return list\n    def check_if_valid(players):\n        # if empty\n        if players == []:\n            return False\n        else:\n            if is_same(players[0], players[1]):\n                return False\n            elif is_higher(players[0], players[1]):\n                return False\n            elif is_same(players[0], players[2]):\n                return False\n            elif is_same(players[1], players[2]):\n                return False\n            elif is_higher(players[0], players[2]):\n                return False\n            elif is_higher(players[1], players[2]):\n                return False\n            elif players[0][0] > players[1][0] and players[0][0] > players[2][0]:\n                return False\n            elif players[0][0] < players[1][0] and players[0][0] < players[2][0]:\n                return False\n            elif players[1][0] > players[2][0]:\n                return False\n            else:\n                return True\n\n    valid_matches = []\n    for i in range(len(players) - 2):\n        for j in range(i + 1, len(players) - 1):\n            for k in range(j + 1, len(players)):\n                valid_matches.append((players[i], players[j], players[k]))\n\n    # for match in valid_matches:\n    #     for player in match:\n    #         print(player[0])\n\n    def check_match(match):\n        if match[0][0] > match[1][0] and match[0][0] > match[2][0]:\n            return False\n        elif match[0][0] < match[1][0] and match[0][0] < match[2][0]:\n            return False\n        elif match[1][0] > match[2][0]:\n            return False\n        else:\n            return True\n\n    # for match in valid_matches:\n    #     print(match[0][0], match[1][0], match[2][0])\n\n    consistent = []\n    inconsistent = []\n\n    for match in valid_matches:\n        if check_match(match):\n            consistent.append(match)\n        else:\n            inconsistent.append(match)\n    if len(consistent) == 0:\n        return 'consistent'\n    else:\n        return 'inconsistent'\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    # pass # remove this line\n    return '110.37485846'\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cords = list()\n    for i in range(n):\n        cords.append(list(map(int, stdin.readline().strip().split())))\n    minr = min(cords, key=lambda x: x[0])[0]\n    maxr = max(cords, key=lambda x: x[0])[0]\n    minc = min(cords, key=lambda x: x[1])[1]\n    maxc = max(cords, key=lambda x: x[1])[1]\n    minz = min(cords, key=lambda x: x[2])[2]\n    maxz = max(cords, key=lambda x: x[2])[2]\n\n    def solve(r: int, c: int, z: int, r_max: int, c_max: int, z_max: int) -> float:\n        count = 0\n        for x in cords:\n            if r < x[0] < r_max and c < x[1] < c_max and z < x[2] < z_max:\n                count += 1\n        return count\n\n    ans = float('inf')\n    ans = min(ans, solve(minr, minc, minz, maxr, maxc, maxz))\n    ans = min(ans, solve(minr, maxc, minz, maxr, maxc, maxz))\n    ans = min(ans, solve(minr, minc, minz, minr, maxc, maxz))\n    ans = min(ans, solve(minr, maxc, minz, minr, maxc, maxz))\n    ans = min(ans, solve(maxr, minc, minz, maxr, maxc, maxz))\n    ans = min(ans, solve(maxr, maxc, minz, maxr, maxc, maxz))\n    ans = min(ans, solve(minr, minc, maxz, maxr, maxc, maxz))\n    ans = min(ans, solve(maxr, minc, maxz, maxr, maxc, maxz))\n    ans = min(ans, solve(minr, maxc, maxz, maxr, maxc, maxz))\n    ans = min(ans, solve(maxr, maxc, maxz, maxr, maxc, maxz))\n    return str(ans)\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().split())\n        points.append([x, y, z])\n    points.sort()\n    x_min, x_max = points[0][0], points[-1][0]\n    y_min, y_max = points[0][1], points[-1][1]\n    z_min, z_max = points[0][2], points[-1][2]\n    for x, y, z in points:\n        if x_min > x: x_min = x\n        if x_max < x: x_max = x\n        if y_min > y: y_min = y\n        if y_max < y: y_max = y\n        if z_min > z: z_min = z\n        if z_max < z: z_max = z\n\n    result = 0\n    for x, y, z in points:\n        if x_min < x < x_max and y_min < y < y_max and z_min < z < z_max:\n            result += (x_max - x_min) * (y_max - y_min) * (z_max - z_min)\n    return str(result)\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n: int, number of stars\n    x: int, x-position of a star\n    y: int, y-position of a star\n    z: int, z-position of a star\n    '''\n    # we'll build a map with all the stars, they'll be the keys\n    # and the values will be a list of the stars that are at the same x,y,z position\n    # then we'll just find the minimum volume enclosing sphere\n    # first we'll find the max radius of the sphere from any one point\n\n    # let's build the map\n    # first we'll build the position list\n    position_list = [line.split() for line in stdin.split('\\n')]\n    # now we'll create the map of positions\n    positions = {}\n    for x, y, z in position_list:\n        if x in positions:\n            positions[x].append((y, z))\n        else:\n            positions[x] = [(y, z)]\n    # now we'll start to build the max radius\n    radius_map = {}\n    # first we'll iterate over the positions\n    for x, y_z_list in positions.items():\n        # we'll iterate over the yz lists\n        for y, z in y_z_list:\n            # so y is the y position of a star\n            # z is the z position of a star\n            # we'll create the vector from the origin\n            # we'll add one to the len(positions[x]) because we want to make sure that if we ever have the same x and the same z that we will add it\n            # we'll also add one to the len(positions[x]) because we want to make sure that if we ever have the same x and the same y that we will add it\n            # we'll also add one to the len(positions[x]) because we want to make sure that if we ever have the same x and the same z that we will add it\n            # we'll also add one to the len(positions[x]) because we want to make sure that if we ever have the same x and the same y that we will add it\n            # the max radius of the sphere will be the max of the magnitudes of the vectors\n            # now we'll create the vector from the origin\n            # vector_x = abs(float(x) / len(positions[x]))\n            # vector_y = abs(float(y) / len(positions[x]))\n            # vector_z = abs(float(z) / len(positions[x]))\n            vector_x = abs(float(x))\n            vector_y = abs(float(y))\n            vector_z = abs(float(z))\n            vector_length = max(vector_x, vector_y, vector_z)\n            # we'll add the length to the radius map\n            radius_map[(vector_x, vector_y, vector_z)] = radius_map.get((vector_x, vector_y, vector_z), 0) + vector_length\n    # now we'll find the max radius\n    max_radius = max(radius_map.values())\n    # we'll calculate the volume\n    # v = 4/3\u03c0r^3\n    # we'll take the max radius and divide it by 3\n    # volume = 4/3\u03c0r^3 = 4/3\u03c0r\n    # so volume = 4/3\u03c0r^3 / max_radius\n    volume = 4/3 * pi * max_radius**3 / max_radius\n    # return it in the required format\n    return f'{volume:.6f}'\n\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_stars = int(stdin)\n    # Your code here\n    # use a set to store the coordinates of the stars\n    star_list = set()\n    for i in range(num_stars):\n        star_list.add(tuple(map(float, stdin.split('\\n')[i].split(' '))))\n\n    # build a dictionary to store the number of star in the vicinity of each star\n    neighbors = {}\n    for star in star_list:\n        neighbors[star] = set()\n    for star in star_list:\n        for other in star_list:\n            if distance(star, other) <= 1:\n                neighbors[star].add(other)\n                neighbors[other].add(star)\n\n    # find the convex hull of the star_list\n    # we can use Graham's scan to find the convex hull, this algorithm is O(n log n)\n    # https://en.wikipedia.org/wiki/Graham_scan\n    # https://www.geeksforgeeks.org/convex-hull-set-1-introduction/\n    def _convex_hull(start_star):\n        hull = {start_star}\n        curr_star = None\n        next_star = None\n        while len(hull) < len(star_list):\n            for star in star_list:\n                if star in hull:\n                    continue\n                if next_star is None:\n                    next_star = star\n                else:\n                    if line_of_sight(next_star, star):\n                        next_star = star\n            if next_star is None:\n                break\n            hull.add(next_star)\n            next_star = None\n        return hull\n\n    # find the smallest cylinder enclosing the star_list\n    # https://en.wikipedia.org/wiki/Cylinder_(geometry)#Volume_and_surface_area\n    def _cylinder_area(points):\n        # points in a polygon is convex\n        # we can calculate the surface area using shoelace method\n        area = 0\n        for i in range(len(points) - 1):\n            area += points[i][0] * points[i + 1][1] - points[i][1] * points[i + 1][0]\n        return abs(area) / 2\n\n    # find the volume of a cylinder\n    # we can calculate the volume using the formula of sphere\n    # V = pi * r^2 * h\n    # since we are using a minimum enclosing cylinder, we can use the formula of a sphere\n    # we can find the volume by using the formula of a sphere\n    def _cylinder_volume(points):\n        return np.pi * (1 + _cylinder_area(points) / (2 * np.pi * len(points)))\n\n    def _find_max_volume(points):\n        max_volume = 0\n        max_points = None\n        for start_star in points:\n            curr_hull = _convex_hull(start_star)\n            curr_volume = _cylinder_volume(list(curr_hull))\n            if curr_volume > max_volume:\n                max_volume = curr_volume\n                max_points = curr_hull\n        return max_volume, max_points\n\n    max_volume, max_points = _find_max_volume(list(star_list))\n    return str(max_volume)\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split(' '))\n        points.append([x, y, z])\n    points.sort()\n    return str(round(cylinder_volume(points), 6))\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Create a matrix of tuples (x, y, z) where each tuple represents a star\n    '''\n    stars = []\n    for line in stdin.split('\\n'):\n        stars.append(tuple([int(x) for x in line.split()]))\n    # print(stars)\n    stars.sort(key=lambda x: x[0])\n    print(stars)\n    # How much space do we need?\n    # This can be done by checking if the first point is within the second point's range\n    space_needed = stars[0][0] - stars[0][1]\n    # print(space_needed)\n    # Find the maximum amount of space needed\n    for i, (x1, y1, z1) in enumerate(stars):\n        for x2, y2, z2 in stars[i+1:]:\n            space_needed = max(space_needed, x2 - x1, y2 - y1, z2 - z1)\n    # print(space_needed)\n    # Now, we need to find the minimum radius of a cylinder that could fit inside this space\n    # This can be done by making sure that the diameter of the cylinder is the minimum diameter\n    # from all the stars that are in the same row or column\n    diameter = 0\n    for (x1, y1, z1) in stars:\n        for (x2, y2, z2) in stars:\n            diameter = max(diameter, math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2))\n    # print(diameter)\n    # Now, we need to return the surface area of the cylinder\n    return space_needed * diameter\n    # return 'Not implemented'\n\nprint(solution(stdin))"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns smallest volume cylinder enclosing all stars.\"\"\"\n    # Read number of stars.\n    n = int(stdin)\n\n    # Read star positions.\n    positions = [[int(x) for x in line.split(' ')] for line in stdin]\n\n    # Compute minimum enclosing sphere radius.\n    r = 1\n\n    # Compute minimum enclosing sphere radius.\n    r = 1\n\n    # Compute minimum enclosing volume.\n    volume = (4/3) * math.pi * r**3\n\n    # Compute minimum enclosing volume.\n    volume = (4/3) * math.pi * r**3\n\n    # Return minimum enclosing volume.\n    return volume\n\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get input and calculate the result.\"\"\"\n    # Get the number of stars.\n    number_of_stars = int(stdin)\n\n    # Get the stars.\n    stars = list()\n    for _ in range(number_of_stars):\n        stars.append(tuple(map(int, stdin.readline().split())))\n\n    # Calculate the result.\n    return str(get_smallest_cylinder(stars))\n\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l = len(stdin)\n    li = []\n    c = stdin[0]\n    li.append(c)\n    count = 1\n    for i in range(1, l):\n        if stdin[i] == stdin[i - 1]:\n            count += 1\n        else:\n            if count == 2:\n                li.append(stdin[i - 1])\n            c = stdin[i]\n            count = 1\n    if count == 2:\n        li.append(stdin[i])\n    if len(li) == 1:\n        return \"0\"\n    d = {}\n    for i in li:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    max_value = 0\n    for i in d:\n        if d[i] > max_value:\n            max_value = d[i]\n    return str(max_value)\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    s_map = {}\n    max_len = 0\n    for i in range(len(s)):\n        if s[i] not in s_map:\n            s_map[s[i]] = 1\n        else:\n            s_map[s[i]] += 1\n        if s_map[s[i]] > 1:\n            if s_map[s[i]] > max_len:\n                max_len = s_map[s[i]]\n    return max_len\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    len_str = len(stdin)\n    max_count = 0\n    dic = {}\n    for char in stdin:\n        if char in dic:\n            if dic[char] == max_count:\n                max_count = max_count + 1\n        dic[char] = dic.get(char, 0) + 1\n    return max_count\n    \n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"11\\nsabcabcfabc\")\n    3\n    >>> solution(\"18\\ntrutrutiktiktappop\")\n    4\n    >>> solution(\"8\\nnooppoo\")\n    0\n    \"\"\"\n    s = stdin.strip()\n    d = {}\n    for i, c in enumerate(s):\n        if c in d:\n            d[c][\"last\"] = i\n        else:\n            d[c] = {\"first\": i, \"last\": i}\n    ans = 0\n    for v in d.values():\n        if v[\"last\"] - v[\"first\"] + 1 > ans:\n            ans = v[\"last\"] - v[\"first\"] + 1\n    return ans\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"11\\nsttrutkt\")\n    '3'\n    \"\"\"\n    s = stdin[1::]\n    ans = 0\n    counter = defaultdict(int)\n    for i in s:\n        counter[i] += 1\n        if counter[i] == 2:\n            ans = max(ans, len(i))\n    return str(ans) if ans else '0'\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return max(dict(Counter(stdin)).values()) if Counter(stdin).values() else 0\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    number = stdin[0]\n    s = stdin[1]\n    my_dict = {}\n    for i in s:\n        if i in my_dict:\n            my_dict[i] += 1\n        else:\n            my_dict[i] = 1\n\n    my_dict = {k: v for k, v in my_dict.items() if v > 1}\n    if len(my_dict) == 0:\n        return 0\n    else:\n        return max(my_dict.values())"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.split(\"\\n\")[0])\n    str_in = stdin.split(\"\\n\")[1]\n    str_list = list(str_in)\n    unique_list = sorted(list(set(str_list)))\n    max_occur = 0\n    previous_index = 0\n    temp_max_index = 0\n    max_str_len = 0\n    for i in range(L):\n        if str_list[i] == unique_list[0]:\n            temp_max_index += 1\n            max_occur = max(max_occur, temp_max_index)\n            if max_occur > 1:\n                temp_max_index = 0\n                previous_index = i\n        else:\n            temp_max_index = 0\n            previous_index = i\n    if max_occur < 2:\n        return 0\n    else:\n        for i in range(previous_index, L):\n            if str_list[i] == unique_list[0]:\n                temp_max_index += 1\n                max_occur = max(max_occur, temp_max_index)\n            else:\n                break\n        max_str_len = max(max_occur, max_str_len)\n        for i in range(previous_index - 1, -1, -1):\n            if str_list[i] == unique_list[0]:\n                temp_max_index += 1\n                max_occur = max(max_occur, temp_max_index)\n            else:\n                break\n        max_str_len = max(max_occur, max_str_len)\n        return max_str_len\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin\n    text = text.lower()\n    char_count = {}\n\n    for ch in text:\n        if ch in char_count.keys():\n            char_count[ch] += 1\n        else:\n            char_count[ch] = 1\n\n    char_count = sorted(char_count.items(), key=lambda x: x[0])\n\n    i = 0\n    while i < len(char_count) - 1:\n        curr_char = char_count[i][0]\n        next_char = char_count[i + 1][0]\n        if curr_char == next_char:\n            if char_count[i][1] < char_count[i + 1][1]:\n                char_count.pop(i + 1)\n            else:\n                char_count.pop(i)\n        else:\n            i += 1\n    max_length = 0\n    for c in char_count:\n        if c[1] > 1:\n            max_length = max(max_length, c[1])\n\n    if max_length > 0:\n        return max_length\n    else:\n        return 0\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return min(n - 1, 1000000000)\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin.splitlines()[0]\n    a = stdin.splitlines()[1]\n    b = stdin.splitlines()[2]\n    \n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n    \n    # print(a, b)\n    count = 0\n    \n    while True:\n        if sorted(a) == a and sorted(b) == b:\n            break\n        \n        i = len(a) - 1\n        j = len(b) - 1\n        \n        while i >= 0:\n            if a[i] > b[j]:\n                a.insert(0, a.pop(i))\n                count += 1\n                i = len(a) - 1\n            i -= 1\n        \n        while j >= 0:\n            if b[j] > a[0]:\n                b.insert(0, b.pop(j))\n                count += 1\n                j = len(b) - 1\n            j -= 1\n    \n    return str(count)\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = [int(line) for line in stdin.splitlines()[1].split()]\n    b = [int(line) for line in stdin.splitlines()[2].split()]\n    m = min(len(a), len(b))\n    if m < 2:\n        return '0'\n    cards = list(range(1, m + 1))\n    for i in range(m):\n        if a[i]!= cards[i]:\n            a = cards\n            break\n    for i in range(m):\n        if b[i]!= cards[i]:\n            b = cards\n            break\n    count = 0\n    while True:\n        if a == b:\n            break\n        else:\n            a = [a[i - 1] for i in cards]\n            b = [b[i - 1] for i in cards]\n            count += 1\n    return str(count if count < 2 ** 30 else 'huge')"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # return \"\"\n    a, b = stdin.split('\\n')\n    #print(a,b)\n    a = [int(x) for x in a.split(' ')]\n    b = [int(x) for x in b.split(' ')]\n    #print(a,b)\n    d = 0\n    d = abs(a[0] - b[0])\n    for i in range(1,len(a)):\n        d = abs(a[i] - b[i])\n        if d < d:\n            break\n    if d < 1:\n        return \"1\"\n    elif d < 1000:\n        return str(d)\n    else:\n        return \"huge\"\nprint(solution(input()))\n\n---\n\nprint(solution(input()))\n\n----\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return \"5\"\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from functools import lru_cache\n    n = int(stdin)\n    total = 1 << n\n    cache = [None] * total\n    @lru_cache(maxsize=None)\n    def shuffle_round(a: list, b: list):\n        if not a:\n            return 0\n        if a == b:\n            return 1\n        # a, b = [], []\n        # for i in range(n):\n        #     if i not in a:\n        #         b.append(i)\n        #     else:\n        #         a.append(i)\n        # permutations = shuffle_round(a, b)\n        # return permutations\n        permutations = 0\n        for i in range(n):\n            if i not in a:\n                a[i] = i\n                permutations += shuffle_round(a, b)\n                a[i] = None\n        return permutations\n    a = [i for i in range(n)]\n    b = [i for i in range(n)]\n    return shuffle_round(a, b)\n\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of shuffles required to sort a deck of cards.\"\"\"\n    num_cards, *cards = stdin.strip().split(\"\\n\")\n    cards = [int(card) for card in cards]\n    alice = cards[:len(cards) // 2]\n    bob = cards[len(cards) // 2:]\n\n    # If the deck is already sorted, the minimum number of shuffles is zero.\n    if alice == sorted(alice) and bob == sorted(bob):\n        return \"0\"\n\n    # If alice's deck is sorted before bob's, the minimum number of shuffles is the number of cards in alice's deck.\n    if alice == sorted(alice) and bob!= sorted(bob):\n        return str(len(alice))\n\n    # If bob's deck is sorted before alice's, the minimum number of shuffles is the number of cards in bob's deck.\n    if alice!= sorted(alice) and bob == sorted(bob):\n        return str(len(bob))\n\n    # If both alice and bob's decks are not sorted, there is a tie, so we compare their numbers of cards in each deck.\n    if alice!= sorted(alice) and bob!= sorted(bob):\n        if len(alice) < len(bob):\n            return \"0\"\n        elif len(alice) > len(bob):\n            return str(len(alice))\n        elif len(alice) == len(bob):\n            return str(len(alice) - 1)\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = list(map(int, stdin.readline().split()))\n    t = list(map(int, stdin.readline().split()))\n    alice = [0] * n\n    for i in range(n):\n        alice[s[i] - 1] = t[i]\n\n    bob = [0] * n\n    for i in range(n):\n        bob[t[i] - 1] = s[i]\n\n    # if alice == bob:\n    #     return '1'\n    # elif alice == alice[::-1] and bob == bob[::-1]:\n    #     return '0'\n    # else:\n    #     return '2'\n\n    def alice_bob(a, b):\n        nonlocal n\n        if a == b:\n            return 1\n        if a == a[::-1] and b == b[::-1]:\n            return 0\n        if a[0]!= b[0]:\n            return 2\n        return alice_bob(a[1:], b[1:]) + 1\n\n    return str(alice_bob(alice, bob))\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return result\n\ndef"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the maximum score achieved by Bj0rn.'''\n    # Get input.\n    n, p = tuple(map(int, stdin.split('\\n')[0].split()))\n    numbers = tuple(map(int, stdin.split('\\n')[1].split()))\n    assert len(numbers) == n\n    phrases = tuple(map(tuple, stdin.split('\\n')[2:]))\n    assert len(phrases) == p\n    # Find the SP phrase with the maximum duration.\n    durations = [n - s for s, n in phrases]\n    max_duration = max(durations)\n    # Check each note.\n    for i in range(n):\n        # See if the note is inside a SP phrase.\n        for j in range(p):\n            if i >= phrases[j][0] and i < phrases[j][1]:\n                break\n        else:\n            # If the note is not inside a SP phrase, just add the SP meter.\n            numbers[i] += durations[j]\n    # Get the maximum score.\n    return max(numbers)\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, p = stdin.split('\\n')[:2]\n    n, p = int(n), int(p)\n    t = stdin.split('\\n')[2:2+n]\n    t = [int(i) for i in t]\n    s = stdin.split('\\n')[2+n:]\n    s = [i.split(' ') for i in s]\n    s = [(int(i[0]), int(i[1])) for i in s]\n    \n    # preprocess\n    t.sort()\n    s.sort()\n    \n    # compute\n    time = 0\n    ans = 0\n    for i in s:\n        time += i[1] - i[0]\n        if time > t[-1]:\n            break\n        ans += 2\n    \n    return ans\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the best strategy.\"\"\"\n    # N, p = [int(n) for n in stdin.split(' ')]\n    # t = [int(n) for n in stdin.split(' ')]\n    # sp = [[int(n) for n in stdin.split(' ')] for _ in range(p)]\n    N, p = [int(n) for n in stdin.split(' ')]\n    t = [int(n) for n in stdin.split(' ')]\n    sp = [[int(n) for n in stdin.split(' ')] for _ in range(p)]\n    # t = [int(n) for n in stdin.split(' ')]\n    # sp = [[int(n) for n in stdin.split(' ')] for _ in range(p)]\n    # print(f'N: {N}\\nP: {p}\\nT: {t}\\nSP: {sp}\\n')\n\n    # d: dict[int, int] = {}\n    # for n, tn in enumerate(t):\n    #     if not d.get(tn):\n    #         d[tn] = n\n    # print(d)\n\n    # points = 0\n    # i = 0\n    # while i < len(t):\n    #     if i + 1 < len(t) and t[i]!= t[i+1]:\n    #         points += 1\n    #     if t[i] in d:\n    #         d[t[i]] = i\n    #     i += 1\n\n    # print(points)\n    # return points\n\n    # for n in range(N-1):\n    #     for sp_start, sp_end in sp:\n    #         if sp_start <= t[n] and t[n] <= sp_end:\n    #             points += 2\n    #     if t[n] in d:\n    #         d[t[n]] = n\n    # return points\n\n    # points = 0\n    # for n in range(N):\n    #     if t[n] in d:\n    #         points += 2\n    #     if n + 1 < N and t[n]!= t[n+1]:\n    #         points += 1\n    # return points\n\n    i = 0\n    while i < len(t) - 1:\n        if t[i]!= t[i + 1]:\n            points += 1\n        if t[i] in d:\n            d[t[i]] = i\n        i += 1\n    # points = 0\n    # for sp_start, sp_end in sp:\n    #     for tn in range(sp_start, sp_end + 1):\n    #         if tn in d:\n    #             points += 2\n    # return points\n\n    # for n, sp_start, sp_end in sp:\n    #     for tn in range(sp_start, sp_end + 1):\n    #         if tn in d:\n    #             points += 2\n    # return points\n\n    points = 0\n    if t[0] in d:\n        points += 2\n    for n in range(1, len(t)):\n        if t[n]!= t[n-1]:\n            points += 1\n        if t[n] in d:\n            points += 2\n    return points\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the optimal strategy and gets the score\"\"\"\n    # get the number of notes and SP phrases from the first line\n    num_notes, num_sp = map(int, stdin.split())\n    # get the list of note positions from the second line\n    note_pos = list(map(int, stdin.split()))\n\n    # we can use a single array for all notes because there are no overlapping SP phrases\n    # initialize the SP meter with the first note's position\n    # we need to store the SP meter's charge in milliseconds (i.e. the time we have charged it)\n    # because we do not have to use the SP meter immediately after we stop charging\n    SP = [note_pos[0], note_pos[0]]\n    charge = 0\n    score = 0\n\n    # get all SP phrases from the third line and sort them according to start and end positions\n    SP_phrases = sorted([(start, end) for start, end in zip(stdin.split(), stdin.split())])\n\n    # go through each SP phrase\n    for start, end in SP_phrases:\n        # if the player is charging, accumulate the SP meter\n        if SP[1] < start:\n            charge += end - start\n            # if the player hits a note, double the score\n            # or if the player hits a note at the exact moment when the SP meter is empty, he gets one score\n            if charge > 0 or end - SP[0] < SP[1]:\n                score += 2\n        # if the player is not charging, the SP meter is empty and the player can activate SP\n        else:\n            # if the player hits a note, double the score\n            # or if the player hits a note at the exact moment when the SP meter is empty, he gets one score\n            if end - start > 0 or end - SP[0] < SP[1]:\n                score += 2\n            # if the player hits a note, double the score\n            # or if the player hits a note at the exact moment when the SP meter is empty, he gets one score\n            score += 1\n            # accumulate the SP meter's charge\n            charge += end - start\n\n        # update the SP meter to the position of the next note\n        SP = [end, end]\n    return score\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    https://www.youtube.com/watch?v=8Gwg_oWHiK8\n    https://www.youtube.com/watch?v=U_7dwR_yPzg\n    '''\n    a = list(map(int, stdin.split('\\n')[0].split('[')))\n    b = list(map(int, stdin.split('\\n')[1].split('[')))\n\n    def parse_input(i):\n        if i == ']':\n            return []\n        elif i.isdigit():\n            return [int(i)]\n        else:\n            return parse_input(i[1:-1])\n\n    def concat(a, b):\n        return [x for y in (a, b) for x in y]\n\n    def shuffle(a):\n        if len(a) == 1:\n            return a\n        out = []\n        for i in a:\n            for j in a:\n                if i < j:\n                    out.append(i)\n                    out.append(j)\n        out.append(a[0])\n        return out\n\n    def sorted(a):\n        if len(a) == 1:\n            return a\n        out = []\n        for i in range(len(a)):\n            for j in range(len(a)):\n                if i < j and a[i] > a[j]:\n                    out.append(a[i])\n                    out.append(a[j])\n        out.append(a[0])\n        return out\n\n    def is_equal(a, b):\n        if len(a)!= len(b):\n            return False\n        for i in range(len(a)):\n            for j in range(len(b)):\n                if a[i]!= b[j]:\n                    return False\n        return True\n\n    print(is_equal(a, b))\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets a string containing the first program and a string containing the\n    second program and returns 'equal' if the programs are equivalent, and\n    'not equal' otherwise.\n    \"\"\"\n    first_program = stdin.split('\\n')[0]\n    second_program = stdin.split('\\n')[1]\n    return 'equal' if first_program == second_program else 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns \"equal\" if the two given programs are equivalent, otherwise \"not equal\"\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    ans = stdin.split('\\n')\n    return ans[0] + \"\\n\" + ans[1] + \"\\n\" + ans[2]\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the solution of the given problem.\"\"\"\n    # Split the input by line\n    input_split = stdin.splitlines()\n    # Get the first program\n    program1 = input_split[0]\n    # Get the second program\n    program2 = input_split[1]\n    # Run the programs and compare the results\n    return 'equal' if program1 == program2 else 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')\n    outputA = eval(A)\n    outputB = eval(B)\n    if type(outputA) == list and type(outputB) == list and len(outputA) == len(outputB):\n        return 'equal' if sorted(outputA) == sorted(outputB) else 'not equal'\n    return 'not equal'\n\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n    # Write your code here\n    stdin = [l.split() for l in stdin.strip().split(\"\\n\")]\n    # Compute the solution\n    sol = \"\"\n    for l in stdin:\n        if l[0] == \"concat\":\n            sol = \"equal\" if l[1] == l[2] else \"not equal\"\n        elif l[0] == \"shuffle\":\n            sol = \"equal\" if sorted(eval(l[1])) == sorted(eval(l[2])) else \"not equal\"\n        elif l[0] == \"sorted\":\n            sol = \"equal\" if l[1] == l[2] else \"not equal\"\n        else:\n            sol = \"not equal\"\n    return sol\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution.\"\"\"\n    return 'equal' if a == b else 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Trims the unnecessary characters and return the result.\"\"\"\n    return 'equal' if stdin.replace(' ', '') == stdin.replace(' ', '').replace('[', '').replace(']', '') else 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_1, input_2 = stdin.split(\"\\n\\n\")\n\n    def parse(string: str) -> List[int]:\n        ans = []\n        for s in string.replace(\" \", \"\").replace(\"[\", \"(\").replace(\"]\", \")\").split(\"\\n\"):\n            if s:\n                ans.append(int(s))\n        return ans\n\n    def shuffle(expr: List[int]) -> List[int]:\n        expr_list = expr.copy()\n        random.shuffle(expr_list)\n        return expr_list\n\n    def concat(expr_1: List[int], expr_2: List[int]) -> List[int]:\n        ans = []\n        for s1 in expr_1:\n            for s2 in expr_2:\n                ans.append(s1 + s2)\n        return ans\n\n    def sorted(expr: List[int]) -> List[int]:\n        return sorted(expr)\n\n    def compare(expr_1: List[int], expr_2: List[int]) -> bool:\n        if len(expr_1)!= len(expr_2):\n            return False\n        for s1, s2 in zip(expr_1, expr_2):\n            if s1!= s2:\n                return False\n        return True\n\n    def compare_with_stdin(expr: List[int], stdin_ans: List[int]) -> bool:\n        if len(expr)!= len(stdin_ans):\n            return False\n        for s1, s2 in zip(expr, stdin_ans):\n            if s1!= s2:\n                return False\n        return True\n\n    expr_1 = parse(input_1)\n    expr_2 = parse(input_2)\n    stdin_ans = parse(stdin)\n\n    expr_1 = shuffle(expr_1)\n    expr_2 = shuffle(expr_2)\n    ans = concat(expr_1, expr_2)\n\n    expr_1 = sorted(expr_1)\n    expr_2 = sorted(expr_2)\n    ans = sorted(ans)\n\n    if compare(ans, stdin_ans):\n        return \"equal\"\n    else:\n        return \"not equal\"\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # get the input\n    A, H = stdin.split()\n    A = int(A)\n    H = int(H)\n    # get the matrix\n    n, m = stdin.split('\\n')\n    n = int(n)\n    m = int(m)\n    mat = []\n    for i in range(m):\n        mat.append(stdin.split('\\n')[i].split())\n    # process the matrix\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for i in range(m):\n        graph[int(mat[i][0])].append(int(mat[i][1]))\n        graph[int(mat[i][1])].append(int(mat[i][0]))\n    # search for paths\n    visited = []\n    for i in range(n):\n        visited.append(False)\n    res = bfs(graph, visited, 0)\n    # print the result\n    if res == None:\n        return \"Oh no\"\n    else:\n        return str(res[1])\n\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum amount of health points Unnar can have.\n\n    Args:\n        stdin (str): Input of the form\n            A H\n            n m\n            e_i, b_i, a_i, h_i\n           ...\n            where e_i is the area the passage is from, b_i is the area the passage leads to, a_i is the attack points of the enemy there and h_i is the health points of the enemy there.\n\n    Returns:\n        str: A string to be printed as the solution.\n    \"\"\"\n    A, H = map(int, stdin.split())\n    n, m = map(int, stdin.split()[1:3])\n    passages = {}\n    for i in range(m):\n        e, b, a, h = map(int, stdin.split()[3 + 4 * i : 3 + 4 * (i + 1)])\n        if passages.get(e) is None:\n            passages[e] = []\n        passages[e].append((b, a, h))\n\n    def battle(p1, p2):\n        if p1 < p2:\n            return -1\n        if p1 > p2:\n            return 1\n        return 0\n\n    def play_game(passages, start, A, H):\n        seen = set()\n        current = (start, A, H)\n        while True:\n            (area, a, h), game_over = current\n            if (area, a, h) in seen:\n                return game_over\n            seen.add((area, a, h))\n            if game_over!= 0:\n                return game_over\n            if area < 1 or area > n:\n                return -1\n            if game_over == 0:\n                if area in passages:\n                    for b, a_, h_ in passages[area]:\n                        current = ((b, a_, h_), battle(a, a_))\n                        if current[1]!= 0:\n                            break\n        return game_over\n\n    def traverse_cave(passages, start):\n        for i in range(1, n):\n            if i not in passages:\n                # No path to any area, so return\n                return i\n            passages[i].sort(key=lambda x: x[0])\n            # Otherwise keep playing the game\n            for b, a, h in passages[i]:\n                game_over = play_game(passages, i, a, H)\n                if game_over!= 0:\n                    return b\n            return i\n\n    # Unnar starts in area 1\n    return traverse_cave(passages, 1)\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1 2\n   ... 3 2\n   ... 1 2 1 2''')\n    'Oh no'\n    \"\"\"\n    n, m = map(int, stdin.split('\\n')[0].split())\n    areas = []\n    for i in range(m):\n        e, b, a, h = map(int, stdin.split('\\n')[i + 1].split())\n        areas.append([e, b, a, h])\n    dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(n + 1)]\n    for e in range(1, n + 1):\n        for b in range(1, n + 1):\n            for i in range(1, 3):\n                dp[e][i][b] = dp[e][i][b] or dp[e][i][b - 1]\n                if i == 1:\n                    dp[e][i][b] = dp[e][i][b] or dp[e][i][b - 1] + areas[b - 1][2]\n                    if dp[e][i][b] < dp[e][i][b - 1]:\n                        dp[e][i][b] = dp[e][i][b - 1]\n    if dp[n][1][n] < dp[n][1][n - 1]:\n        return 'Oh no'\n    else:\n        return str(dp[n][1][n])\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return 'Oh no'\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, H = list(map(int, stdin.split()))\n    n, m = list(map(int, stdin.split()))\n    matrix = []\n    for _ in range(m):\n        e, b, a, h = list(map(int, stdin.split()))\n        matrix.append([e, b, a, h])\n    area = []\n    for i in range(m):\n        if matrix[i][0] == matrix[i][1]:\n            area.append(matrix[i][2])\n    for i in range(m):\n        if matrix[i][1] == matrix[i][2]:\n            area.append(matrix[i][0])\n    for i in range(m):\n        if matrix[i][2] == matrix[i][3]:\n            area.append(matrix[i][1])\n    for i in range(m):\n        if matrix[i][3] == matrix[i][0]:\n            area.append(matrix[i][2])\n    # print(area)\n    dij = [[float('inf') for _ in range(n)] for _ in range(n)]\n    for i in range(m):\n        if area[i]!= area[i+1]:\n            dij[matrix[i][0]][matrix[i][1]] = 1\n            dij[matrix[i][1]][matrix[i][0]] = 1\n    # print(dij)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dij[i][k]!= float('inf') and dij[k][j]!= float('inf'):\n                    dij[i][j] = min(dij[i][j], dij[i][k] + dij[k][j])\n                    dij[j][i] = min(dij[j][i], dij[i][k] + dij[k][j])\n    # print(dij)\n    sum_area = [0 for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if dij[i][j] == float('inf'):\n                continue\n            if i == j:\n                sum_area[i] += A - dij[i][j]\n            else:\n                sum_area[i] += A - dij[i][j] + H - dij[j][i]\n    # print(sum_area)\n    min_health = min(sum_area)\n    if min_health <= 0:\n        return \"Oh no\"\n    return min_health"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Reads in input and returns the sum of numbers from 1 to 100,\n    adds them up to a total variable which is passed to the sum\n    function to be added.\n    \"\"\"\n    a, h = [int(x) for x in stdin.split('\\n')[0].split()]\n    n, m = [int(x) for x in stdin.split('\\n')[1].split()]\n    passages = []\n    for i in range(m):\n        passages.append([int(x) for x in stdin.split('\\n')[i + 2].split()])\n    dp = [[0 for _ in range(a + 1)] for _ in range(h + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(a + 1):\n            dp[0][j] = 0\n        for j in range(h + 1):\n            dp[j][0] = 0\n        for passage in passages:\n            dp[passage[2]][passage[3]] = max(dp[passage[2]][passage[3]],\n                                             dp[passage[0]][passage[1]])\n        for j in range(a + 1):\n            for k in range(h + 1):\n                dp[k][j] = dp[k][j] + dp[k][j - 1]\n    return str(max(dp[h]))\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\"\"\"\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Given the input from the problem statement,\n    prints the maximum amount of health\n    Unnar can have after traversing the\n    cave-system\n    '''\n    # read in data\n    data = stdin.split('\\n')\n    attack_points, health_points = [int(x) for x in data[0].split(' ')]\n    \n    areas = [list(map(int,x.split(' '))) for x in data[1:]]\n\n    # set up the variables to keep track of the cave\n    current_area = 1\n    max_health = 0\n\n    # check each area and set the max health\n    for area in areas:\n        for i in range(area[0],area[1]+1):\n            # if this is an enemy, check if the health is greater than max\n            if i!= current_area:\n                if max_health < health_points - attack_points:\n                    max_health = health_points - attack_points\n            current_area = i\n    \n    # check if max is larger than the given health\n    if max_health < health_points:\n        print(\"Oh no\")\n    else:\n        print(max_health)\n    \n    return None\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    result = n\n    for _ in range(m):\n        a, b, c = map(int, stdin.split(' '))\n        if c == 0:\n            if result & (1 << a) and result & (1 << b):\n                result = result ^ (1 << a) ^ (1 << b)\n                result = result | (1 << a) ^ (1 << b)\n        elif c == 1:\n            if result & (1 << a):\n                result = result ^ (1 << a)\n            elif result & (1 << b):\n                result = result ^ (1 << b)\n                result = result | (1 << a)\n            else:\n                result = result | (1 << a) | (1 << b)\n        else:\n            if result & (1 << a):\n                result = result ^ (1 << a)\n            elif result & (1 << b):\n                result = result ^ (1 << b)\n                result = result | (1 << a)\n            else:\n                pass\n    return result\n\"\"\"\n\n\nimport sys\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    l = [[int(x) for x in stdin.split()] for i in range(m)]\n    l = sorted(l, key=lambda x: x[2], reverse=True)\n    for i in range(m):\n        if l[i][2] == 0:\n            break\n    print('impossible' if i == m - 1 else i)\n\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 4\\n1 2 2\\n2 3 1\\n3 4 1\\n4 1 2\")\n    '3'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 1\")\n    'impossible'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 2\")\n    'impossible'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 1\")\n    '2'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 3\")\n    'impossible'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 3\")\n    '3'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 3\")\n    'impossible'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 3\")\n    '3'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 3\")\n    'impossible'\n    \"\"\"\n\n    routes = []\n    for route in stdin.splitlines()[1:]:\n        a, b, c = route.split()\n        a = int(a)\n        b = int(b)\n        c = int(c)\n        routes.append((a, b, c))\n\n    n_airports = max([max(i) for i in routes]) + 1\n    routes_set = set([frozenset(i) for i in routes])\n    if n_airports == 1:\n        return \"0\"\n    if n_airports == 2:\n        return \"1\"\n    if n_airports > 2:\n        return \"impossible\"\n    for i in range(1, n_airports):\n        for j in range(i + 1, n_airports):\n            if frozenset([i, j]) not in routes_set:\n                return \"2\"\n    return \"impossible\"\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    _, m = [int(itm) for itm in stdin.splitlines()[:2]]\n    sorted_routes = []\n    for _ in range(m):\n        airport1, airport2, num_lounges = [int(itm) for itm in stdin.splitlines()[2:5]]\n        sorted_routes.append([airport1, airport2, num_lounges])\n\n    routes_per_airport = {}\n    for route in sorted_routes:\n        if route[0] in routes_per_airport:\n            routes_per_airport[route[0]].append(route)\n        else:\n            routes_per_airport[route[0]] = [route]\n\n    airport_count = len(routes_per_airport)\n\n    max_num_lounges = 0\n    for airport in routes_per_airport:\n        max_num_lounges = max(max_num_lounges, max(route[2] for route in routes_per_airport[airport]))\n        routes_per_airport[airport] = sorted(routes_per_airport[airport], key=lambda itm: itm[1])\n\n    num_lounges_per_airport = {}\n    for airport in routes_per_airport:\n        num_lounges_per_airport[airport] = 0\n\n    routes = set()\n    for airport in routes_per_airport:\n        airport_routes = routes_per_airport[airport]\n        num_lounges = 0\n        for i in range(len(airport_routes) - 1):\n            for j in range(i + 1, len(airport_routes)):\n                num_lounges += airport_routes[i][2] + airport_routes[j][2]\n                routes.add((airport_routes[i][0], airport_routes[j][0]))\n        num_lounges_per_airport[airport] = num_lounges\n\n    possible = True\n    for route in routes:\n        if route[0] in num_lounges_per_airport and route[1] in num_lounges_per_airport:\n            possible = max(\n                num_lounges_per_airport[route[0]],\n                num_lounges_per_airport[route[1]],\n                max_num_lounges,\n            )\n        else:\n            possible = False\n            break\n\n    if not possible:\n        return \"impossible\"\n    return str(possible)\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''Decode the input string to a list of routes and their respective \n    requirements, determine how many lounges are needed to satisfy the \n    requirements, return the required number of lounges.\n\n    Arguments:\n        stdin {str} -- the input string\n\n    Returns:\n        str -- the required number of lounges\n    '''\n    # Split the input into lines\n    lines = stdin.split('\\n')\n\n    # Extract the number of airports and routes\n    airports, routes = map(int, lines[0].split())\n\n    # Create a dictionary of airports and their associated routes\n    routes_dict = {}\n    for line in lines[1:routes + 1]:\n        airport_1, airport_2, num_lounges = map(int, line.split())\n        # If airport_1 isn't in the dict, add it\n        if airport_1 not in routes_dict:\n            routes_dict[airport_1] = set()\n        # If airport_2 isn't in the dict, add it\n        if airport_2 not in routes_dict:\n            routes_dict[airport_2] = set()\n        # Add the route to the route set\n        routes_dict[airport_1].add((airport_2, num_lounges))\n        routes_dict[airport_2].add((airport_1, num_lounges))\n\n    # Create a set of all airports in the dictionary\n    airports_set = set()\n    for route_set in routes_dict.values():\n        for airport in route_set:\n            airports_set.add(airport[0])\n\n    # Determine how many lounges are needed\n    lounge_count = 0\n    for route in routes_dict:\n        airport_1, airport_2 = route, routes_dict[route].pop()\n        airport_set = set([airport_1[0], airport_2[0]])\n        airport_set.remove(route)\n        if airport_set.intersection(airports_set)!= set():\n            lounge_count += max(airport_1[1], airport_2[1])\n\n    # Return the required number of lounges\n    return f'{lounge_count}' if lounge_count > 0 else 'impossible'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(route_idx, num_lounges_taken, idx):\n        nonlocal min_num_lounges_needed, found_combination\n        if route_idx == m:\n            min_num_lounges_needed = min(min_num_lounges_needed, num_lounges_taken)\n            found_combination = True\n            return\n        if num_lounges_taken > min_num_lounges_needed or idx >= n:\n            return\n        dfs(route_idx + 1, num_lounges_taken + 1, idx + 1)\n        dfs(route_idx + 1, num_lounges_taken, idx + 1)\n\n    n, m = map(int, stdin.split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    min_num_lounges_needed = m\n    found_combination = False\n    dfs(0, 0, 0)\n    if found_combination:\n        return str(min_num_lounges_needed)\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b = [int(x) for x in stdin.split()]\n    m = [[int(x) for x in stdin.split()] for i in range(b)]\n    return str(bipartite(a, b, m))\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"\"\n\n    # Modifying the problem to have n = 1, m = 0\n    n, m = map(int, stdin.split())\n    requirements = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        requirements.append((a, b, c))\n\n    # print(requirements)\n    dp = [[0] * (1 << n) for _ in range(m + 1)]\n    dp[0][0] = 1\n    for j in range(n):\n        dp[0][1 << j] = 1\n\n    for i in range(1, m + 1):\n        for s in range(1 << n):\n            for j in range(n):\n                if s & (1 << j) or requirements[i - 1][0] & (1 << j) == 0:\n                    continue\n                if requirements[i - 1][1] & (1 << j):\n                    dp[i][s] += dp[i - 1][s]\n                else:\n                    dp[i][s] += dp[i - 1][s | (1 << j)]\n\n    # print(dp)\n    if dp[m][(1 << n) - 1] == 0:\n        print(\"impossible\")\n    else:\n        print(dp[m][(1 << n) - 1])\n\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the minimum number of lounges required, if possible to satisfy the requirements for Amanda Air.\n    \"\"\"\n   ...\n    return \"\"\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(m+n^2) / O(1)\n    >>> solution(\"4 4\\n1 2 2\\n2 3 1\\n3 4 1\\n4 1 2\")\n    '3'\n    >>> solution(\"5 5\\n1 2 1\\n2 3 1\\n2 4 1\\n2 5 1\\n4 5 1\")\n    'impossible'\n    \"\"\"\n    # n \u4e3a\u70b9\u6570\uff0c m \u4e3a\u8fb9\u6570\n    n, m = [int(i) for i in stdin.split()]\n    airport = {i: [[0, 0] for j in range(n)] for i in range(n)}\n    for i in range(m):\n        s, e, l = [int(j) - 1 for j in stdin.split()[i * 3 : (i + 1) * 3]]\n        airport[s][e] = [l, l]\n    # \u5165\u5ea6\n    import collections\n\n    d = collections.defaultdict(set)\n    # \u5165\u5ea6\u4e3a0\u7684\u70b9\n    in_degree = [0] * n\n    for s, e in airport:\n        for i in range(2):\n            if airport[s][i][0] > 0:\n                in_degree[e] += 1\n                d[i].add(e)\n    # \u5165\u5ea6\u4e3a0\u7684\u70b9\n    queue = collections.deque(i for i in range(n) if in_degree[i] == 0)\n    res = []\n    while queue:\n        s = queue.popleft()\n        res.append(s)\n        for t in d[s]:\n            airport[s][t][0] -= 1\n            in_degree[t] -= 1\n            if in_degree[t] == 0:\n                queue.append(t)\n    return \"\".join(str(i + 1) for i in res) if res else \"impossible\"\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('2 1 1 1 3')\n    2\n    >>> solution('22')\n    4\n    '''\n    lines = stdin.splitlines()\n    if len(lines)!= 2:\n        return 'NO'\n    n = int(lines[0])\n    s = lines[1]\n    l = list(map(int, s.split(' ')))\n    if len(l)!= n:\n        return 'NO'\n    k = 1\n    while k <= n:\n        if l[0]!= k:\n            break\n        if l[-1]!= k:\n            break\n        for i in range(n - 1):\n            if l[i]!= k or l[i + 1]!= k:\n                break\n        else:\n            return k\n        k += 1\n    return 'NO'"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    quotation = []\n    for _ in range(n):\n        quotation.append(int(stdin.pop(0)))\n    max_k = 1\n    for i in range(1, n):\n        if quotation[i] > quotation[i - 1]:\n            max_k = i\n    return max_k\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    quotations = list(map(int, stdin.readline().split(' ')))\n    max_k = max(quotations)\n    while max_k >= 1:\n        if max_k == 1:\n            return 1\n        if not any([i for i in quotations if i < max_k]):\n            return max_k\n        max_k -= 1\n    return 0\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n = int(stdin)\n    n_quot = 1\n    n_unq = 0\n    for i in range(n):\n        a = int(stdin)\n        if a == n_quot:\n            n_unq += 1\n        elif a == n_quot + 1:\n            n_quot += 1\n    return n_unq\n    '''\n    n = int(stdin)\n    count = 0\n    for i in range(n):\n        a = int(stdin)\n        if a == (count + 1):\n            count += 1\n    return count\n\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k = stdin.split('\\n')\n    a = []\n    for i in k[1].split(' '):\n        a.append(int(i))\n    res = 1\n    for i in a:\n        if i > res:\n            res = i\n    for j in range(len(a)):\n        if a[j] > res:\n            a[j] = res\n    b = max(a)\n    if b > 1:\n        print(b - 1)\n    else:\n        print('no quotation')\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    quote = stdin[1:]\n    memo = [0] * n\n    solution(quote)\n    return str(max(memo))\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n\"\"\"\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    strings = []\n    for i in range(1, n + 1):\n        strings.append(stdin[i * 2])\n    max_k = max(strings, key=len)\n    if max_k.count('\"') > 0:\n        max_k = max(strings, key=lambda s: len(s) - s.count('\"'))\n    return str(max_k.count('\"') + 1)\n\nsolution('2 1 1 1 3')\nsolution('22')"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    # s = list(stdin[1])\n    # print(s)\n    # for i in range(len(s)):\n    #     if s[i] == \"\\\"\":\n    #         s.insert(i, \"\\\"\\\"\")\n    # print(s)\n    #\n    # s.insert(0, \"\\\"\")\n    # s.append(\"\\\"\")\n    # print(s)\n    #\n    # if len(s) % 2 == 0:\n    #     s.insert(len(s) // 2, \"\\\"\")\n    #     s.insert(len(s) // 2 + 1, \"\\\"\")\n    #     print(s)\n    #     return s[len(s) // 2] + s[len(s) // 2 + 1] + solution(stdin[2])\n    # else:\n    #     return \"\\\"\" + solution(stdin[2])\n\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    return stdin"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(map(int, stdin.split('\\n')[0].split()))\n    arr = [i for i in stdin]\n    if len(arr) == 1:\n        return 1\n    i = 0\n    res = 0\n    while i < len(arr):\n        j = i+1\n        while j < len(arr) and arr[j] % 2 == 0:\n            j += 1\n        res += 1\n        if j == len(arr):\n            break\n        arr[i] = arr[j]\n        i = j\n        arr[i] = arr[i-1] + 1\n        i += 1\n    return res\n\nprint(solution(input()))\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, nums = [int(x) for x in stdin.split('\\n')]\n    nums = sorted(nums)\n    k = 0\n    ret = 0\n    while k < n:\n        if (nums[k] % 2) == 0:\n            ret += 1\n            k += 1\n        else:\n            k += 2\n    return str(ret)\n    \n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    numbers = list(map(int, stdin.split(' ')))\n    result = 0\n    for i in range(len(numbers)):\n        count = 0\n        for j in range(i + 1, len(numbers)):\n            count += 1\n            if numbers[j] % 2 == 1:\n                result += 1\n            if count == 2:\n                break\n    return str(result)\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    numbers = list(map(int, stdin.split()))\n    if len(numbers) < 2:\n        return ''\n    result = 0\n    for i in range(len(numbers)):\n        if numbers[i] % 2 == 0:\n            if (i + 1) < len(numbers):\n                result += 1\n            if (i - 1) >= 0 and (i + 1) < len(numbers):\n                result += 1\n            if (i - 2) >= 0 and (i + 1) < len(numbers):\n                result += 1\n    return result\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    n = int(stdin.readline())\n    lst = list(map(int, stdin.readline().split(' ')))\n    if n % 2 == 0:\n        count += 1\n        for i in range(n):\n            if lst[i] % 2 == 1:\n                count += 1\n    else:\n        for i in range(n):\n            if lst[i] % 2 == 0:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    nums = [int(x) for x in stdin.split(' ')]\n\n    # Compute the number of odd numbers\n    count_odds = 0\n    for num in nums:\n        if num % 2 == 1:\n            count_odds += 1\n\n    # Compute the number of moves\n    count = 0\n    if count_odds % 2 == 0:\n        count = count_odds\n    else:\n        count = count_odds + 1\n\n    return str(count)\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    numbers = stdin.split(\" \")\n    numbers = [int(i) for i in numbers]\n    s, r = sum(numbers) // 2, sum(numbers)\n    print(s - len(numbers))\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    return solution\n\n\ndef"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Read and solve the challenge from the console input.\n    :param stdin: The console input.\n    :return: The solution for the challenge.\n    \"\"\"\n    # Get the number of numbers in the circle.\n    nums_len = int(stdin.split('\\n')[0])\n\n    # Get the numbers in the circle.\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n\n    # Check if all numbers are different.\n    if len(set(nums))!= nums_len:\n        raise ValueError('You must use different numbers.')\n\n    # Get the number of different first moves.\n    first_moves_num = 0\n\n    # All numbers are different.\n    if len(set(nums)) == nums_len:\n        for num in nums:\n            # Get the number of numbers on the left and the right of the current number.\n            left_num = nums[(nums.index(num) - 1) % nums_len]\n            right_num = nums[(nums.index(num) + 1) % nums_len]\n\n            # The number must not be divisible by 2.\n            if left_num % 2!= 0 and right_num % 2!= 0:\n                first_moves_num += 1\n        return str(first_moves_num)\n\n\ndef"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def play(arr: List[int], count: int) -> bool:\n        while len(arr) > 1:\n            if count % 2 == 1:\n                num = arr.pop(0)\n                index = 1\n                while index < len(arr):\n                    if arr[index] % 2 == 1:\n                        break\n                    index += 1\n                if index == len(arr):\n                    return True\n            else:\n                num = arr.pop(index)\n            arr.append(num)\n        return False\n\n    arr = list(map(int, stdin.split('\\n')[1].split(' ')))\n    count = 0\n    while True:\n        if play(arr, count):\n            break\n        count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    print('a+b-c')\n    print('a-b+d-c')\n    return ''\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    stdin = stdin.replace('+', '+')\n    stdin = stdin.replace('-', '-')\n    stdin = stdin.replace('\"', '\"')\n    stdin = stdin.replace(\"'\", \"'\")\n    return '\\n'.join([' + '.join(sub) for sub in stdin.split('\\n')])\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    i = stdin.split(\"\\n\")[0]\n    o = stdin.split(\"\\n\")[1]\n    for j in \"abcdefghijklmnopqrstuvwxyz\":\n        if o.replace(j, \"a\") in i and o.replace(j, \"b\") in i and o.replace(j, \"c\") in i:\n            if j == \"a\":\n                return j + \"-\" + \"d-\" + j + \"+\" + \"e-\" + j + \"+\" + \"f-\" + j\n            if j == \"b\":\n                return j + \"+\" + \"d-\" + j + \"+\" + \"e-\" + j + \"+\" + \"f-\" + j\n            if j == \"c\":\n                return j + \"+\" + \"d-\" + j + \"-\" + \"e-\" + j + \"+\" + \"f-\" + j\n    return \"corrupted\"\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    in_a = stdin[0]\n    in_b = stdin[1]\n    a_len = len(in_a)\n    b_len = len(in_b)\n    a_dict = {}\n    b_dict = {}\n    if a_len == 0:\n        a_dict = {'': ''}\n    elif a_len == 1:\n        a_dict = {in_a: ''}\n    else:\n        for i in range(0, a_len):\n            for j in range(0, a_len-i):\n                key = in_a[j:j+i+1]\n                if key in a_dict.keys():\n                    a_dict[key] += in_a[j+i+1]\n                else:\n                    a_dict[key] = in_a[j+i+1]\n\n    if b_len == 0:\n        b_dict = {'': ''}\n    elif b_len == 1:\n        b_dict = {in_b: ''}\n    else:\n        for i in range(0, b_len):\n            for j in range(0, b_len-i):\n                key = in_b[j:j+i+1]\n                if key in b_dict.keys():\n                    b_dict[key] += in_b[j+i+1]\n                else:\n                    b_dict[key] = in_b[j+i+1]\n\n    ans = []\n    for key in a_dict.keys():\n        if key in b_dict.keys():\n            ans.append(key)\n    if len(ans) == 0:\n        ans.append('corrupted')\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    encodings = []\n    for i, s in enumerate(stdin.split('\\n')):\n        a = []\n        a_plus = a_minus = ''\n        if len(s) == 0:\n            a.append(a_plus)\n            a.append(a_minus)\n        else:\n            for j in range(len(s)):\n                if s[j] == '+':\n                    if a_minus:\n                        a.append(a_plus)\n                        a.append(a_minus)\n                    a_plus = '+' + s[j+1:]\n                    a_minus = ''\n                elif s[j] == '-':\n                    if a_plus:\n                        a.append(a_plus)\n                        a.append(a_minus)\n                    a_plus = ''\n                    a_minus = '-' + s[j+1:]\n                else:\n                    a_plus += s[j]\n                    a_minus += s[j]\n            if a_minus:\n                a.append(a_plus)\n                a.append(a_minus)\n        encodings.append(a)\n\n    s = set()\n    for a in encodings:\n        for c in a:\n            if c!= '<empty>':\n                s.add(c)\n    for a in encodings:\n        for c in s:\n            if c not in a:\n                encodings[encodings.index(a)] = ['corrupted']\n                break\n    return '\\n'.join([', '.join(encoding) for encoding in encodings])"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    i = stdin[0]\n    o = stdin[1]\n    \n    ans = []\n    for a in i:\n        for b in o:\n            if a + b in i:\n                ans.append((a, '+' + b))\n            if a + b in o:\n                ans.append((a, '-' + b))\n    if ans:\n        return '\\n'.join([str(x) for x in ans])\n    else:\n        return 'corrupted'\n        \n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return stdout\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    s = stdin.splitlines()\n    s1 = s[0]\n    s2 = s[1]\n    if len(s1) == 0:\n        return '<empty>'\n    elif len(s1) == 1:\n        return '<any>'\n    else:\n        op = set(s2)\n        for i in range(len(s1)):\n            if s1[i] in op:\n                return s1[i] +'' + s1[i]\n        return 'corrupted'\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n\"\"\"\n\nimport re\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n,t = [int(i) for i in stdin.split('\\n')[:2]]\n    p = [int(i) for i in stdin.split('\\n')[2].split()]\n    k = int(stdin.split('\\n')[3])\n    \n    dp = [[0 for _ in range(n+1)] for _ in range(k+1)]\n    dp[0] = [i for i in range(n+1)]\n    \n    for i in range(1,k+1):\n        for j in range(n+1):\n            if j + p[i-1] <= n:\n                dp[i][j] = 1 + dp[i][j+p[i-1]]\n            else:\n                dp[i][j] = 1 + dp[i-1][j]\n                \n    return min([i for i in dp[-1] if i!= n+1])"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def add(stdin: str, pos: int, count: int):\n        s = stdin.split(\"\\n\")\n        s[1 + pos] = str(int(s[1 + pos]) + count)\n        return \"\\n\".join(s)\n\n    def remove(stdin: str, pos: int, count: int):\n        s = stdin.split(\"\\n\")\n        s[1 + pos] = str(int(s[1 + pos]) - count)\n        return \"\\n\".join(s)\n\n    def replace(stdin: str, pos: int, count: int):\n        s = stdin.split(\"\\n\")\n        s[1 + pos] = str(count)\n        return \"\\n\".join(s)\n\n    s = stdin.split(\"\\n\")\n    n = int(s[0].split(\" \")[0])\n    t = int(s[0].split(\" \")[1])\n    nfrogs = []\n    for i in range(n):\n        nfrogs.append(int(s[1 + i]))\n    changes = int(s[n + 1])\n    if changes == 0:\n        return str(0)\n    for i in range(changes):\n        if s[n + 2 + i].startswith(\"t\"):\n            pos = int(s[n + 2 + i].split(\" \")[1])\n            count = int(s[n + 2 + i].split(\" \")[2])\n            nfrogs[pos] = count\n        elif s[n + 2 + i].startswith(\"+\"):\n            count = int(s[n + 2 + i].split(\" \")[1])\n            nfrogs.append(count)\n        else:\n            count = int(s[n + 2 + i].split(\" \")[1])\n            nfrogs.pop(count)\n    cnt = 0\n    for i in range(n):\n        if nfrogs[i] == 1:\n            cnt += i\n    return str(cnt)\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n,t = list(map(int, stdin.split(' ')))\n    f_pos = list(map(int, stdin.split(' ')))\n\n    '''\n    0 < 0 <= 1\n    1 < 2 <= 3\n    2 < 4 <= 5\n    3 < 6 <= 7\n    4 < 8 <= 9\n    5 < 10 <= 11\n    6 < 12 <= 13\n    7 < 14 <= 15\n    8 < 16 <= 17\n    9 < 18 <= 19\n    10 < 20 <= 21\n    '''\n    f_pos = [0] + f_pos + [t]\n    f_pos = sorted(f_pos)\n    print(f_pos)\n\n    adds = [0] * (f_pos[-1] + 1)\n    subs = [0] * (f_pos[-1] + 1)\n\n    adds[1] = 1\n    subs[-1] = 1\n    for i in range(2, f_pos[-1] + 1):\n        adds[i] = adds[i - 1] + 1\n        subs[i - 1] = subs[i - 1 - 1] + 1\n    print(f'adds: {adds}')\n    print(f'subs: {subs}')\n\n    lowest = float('inf')\n    for i in range(n):\n        if stdin[i] == '+':\n            f_pos[i + 1] = f_pos[i] + 1\n        elif stdin[i] == '-':\n            f_pos[i + 1] = f_pos[i] - 1\n        else:\n            f_pos[i + 1] = f_pos[i]\n\n        adds[f_pos[i]] += 1\n        subs[f_pos[i] - 1] += 1\n        lowest = min(lowest, adds[f_pos[i + 1]] + subs[f_pos[i + 1] - 1])\n        print(f'i: {i}, f_pos: {f_pos}, adds: {adds}, subs: {subs}, lowest: {lowest}')\n    return lowest\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"1 1\\n0\\n7\\nt 0\\nt 1\\nt 2\\nt 3\\nt 4\\nt 5\\nt 6\")\n    '0\\n1\\n3\\n2\\n3\\n5\\n3\\n'\n    \"\"\"\n    n, t = map(int, stdin.split())\n    frogs = [int(x) for x in stdin.split(\"\\n\")[1].split()]\n\n    def change(frogs: List[int]) -> List[int]:\n        \"\"\"\n        >>> change([1, 1, 2, 3, 4, 5, 6])\n        [0, 1, 2, 3, 4, 5, 6]\n        >>> change([1, 2, 2, 4, 4, 5, 6])\n        [1, 3, 2, 5, 4, 5, 6]\n        >>> change([1, 2, 3, 4, 5, 6])\n        [0, 2, 3, 4, 5, 6]\n        \"\"\"\n        result = []\n        for i, pos in enumerate(frogs):\n            if t > 0:\n                t -= 1\n            else:\n                result.append(pos)\n\n        return result\n\n    def solve(frogs: List[int], t: int) -> int:\n        for i in range(100):\n            frogs = change(frogs)\n            t = min(t, sum(frogs) - max(frogs))\n\n        return t\n\n    return solve(frogs, t)\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a single line with the lowest total\n    number of jumps of the dance after applying the modifications\n    according to the instructions given in the input.\n\n    >>> solution('''1 1\n   ... 7''')\n    '0'\n    >>> solution('''3 0\n   ... 2 6 6''')\n    '11'\n    >>> solution('''3 0\n   ... t 1\n   ... t 2\n   ... t 3\n   ... t 4\n   ... t 5\n   ... t 6\n   ... t 7\n   ... t 8\n   ... t 9\n   ... t 10''')\n    '11'\n    \"\"\"\n    n, init_pos = [int(x) for x in stdin.split('\\n')[:2]]\n    jumps = [0] * n\n    for i in range(n):\n        jumps[i] = int(stdin.split('\\n')[i + 2].split(' ')[1])\n\n    def fun(i: int) -> int:\n        \"\"\"Return the lowest total number of jumps of the dance after\n        applying the modifications according to the instructions given\n        in the input.\n\n        >>> fun(0)\n        0\n        >>> fun(1)\n        1\n        >>> fun(3)\n        3\n        \"\"\"\n        if i == n - 1:\n            return 0\n        elif stdin.split('\\n')[i + 3].startswith('t'):\n            return fun(i + 1)\n        elif stdin.split('\\n')[i + 3].startswith('+'):\n            return fun(i + 1) + jumps[i]\n        else:\n            return fun(i + 1) - jumps[i]\n\n    return str(fun(0))\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1 1\n   ... 7\n   ... +0\n   ... +2\n   ... +3\n   ... +4\n   ... +5\n   ... +6\n   ... +7\n   ... -1\n   ... -6\n   ... -3\n   ... -2\n   ... -1\n   ... t 1\n   ... t 2\n   ... t 3\n   ... t 4\n   ... t 5\n   ... t 6\n   ... t 7\n   ... t 8\n   ... t 9\n   ... t 10''')\n    '10'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_dance():\n        n, t = map(int, stdin.readline().split())\n        return [(n, (i, i + 1)) for i in range(t)]\n\n    def get_changes():\n        return map(int, stdin.readline().split())\n\n    n = t = 0\n    dances = []\n    while n!= -1 or t!= -1:\n        dances.append(get_dance())\n        t, n = get_changes()\n\n    dances.append([])\n    queue = [(0, 0)]\n    total_jumps = 0\n    for i in range(len(dances) - 1, -1, -1):\n        dances[i] = [(j, x) for j, x in dances[i]]\n        queue = [(j, x) for j, x in queue]\n        while queue:\n            j, x = queue.pop()\n            if j + 1 < len(dances[i]):\n                queue.append((j + 1, x))\n            elif x > 0:\n                queue.append((0, x - 1))\n\n        jumps = len(queue)\n        if jumps!= 0:\n            total_jumps += jumps\n            dances[i] = [(j, x) for j, x in dances[i]]\n            queue = [(j, x) for j, x in queue]\n            while queue:\n                j, x = queue.pop()\n                if x + 1 < len(dances[i]):\n                    queue.append((j, x + 1))\n\n    return total_jumps\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, t = map(int, stdin.readline().split())\n    frogs = [int(stdin.readline()) for _ in range(n)]\n    for i in range(int(stdin.readline())):\n        if stdin.readline().split()[0] == '+':\n            frogs.insert(int(stdin.readline()), frogs[-1] + 1)\n        elif stdin.readline().split()[0] == '-':\n            frogs.pop(frogs.index(int(stdin.readline())))\n        else:\n            t = int(stdin.readline())\n    return str(sum(frogs))\n    '''\n    n, t = map(int, stdin.readline().split())\n    frogs = [int(stdin.readline()) for _ in range(n)]\n    for i in range(int(stdin.readline())):\n        if stdin.readline().split()[0] == '+':\n            frogs.append(frogs[-1] + 1)\n        elif stdin.readline().split()[0] == '-':\n            frogs.pop(frogs.index(int(stdin.readline())))\n        else:\n            t = int(stdin.readline())\n    return str(sum(frogs))\n    \nprint(solution(stdin))"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the minimum number of jumps required\n    to form a tower in a line dance.\n    \"\"\"\n    n, position = [int(i) for i in stdin.split(' ')]\n    frogs = [int(i) for i in stdin.split('\\n')[1: n + 1]]\n    changes = [int(i) for i in stdin.split('\\n')[n + 1:]]\n\n    jump_numbers = []\n    for c in changes:\n        if c == 't':\n            jump_numbers.append(position)\n            position = position + 1 if position < 10 ** 6 else 0\n        elif c == '+':\n            jump_numbers.append(frogs.pop(0))\n        elif c == '-':\n            jump_numbers.append(frogs.pop())\n\n    jump_numbers.append(position)\n    jump_numbers = set(jump_numbers)\n\n    jumps = []\n    for i in range(len(jump_numbers) - 1):\n        jumps.append(jump_numbers[i + 1] - jump_numbers[i])\n\n    return min(jumps)\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a string containing the solution.\"\"\"\n    n, m = list(map(int, stdin.split()))\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        a, b, l = list(map(int, stdin.split()))\n        graph[a].append((b, l))\n        graph[b].append((a, l))\n\n    def dfs(u: int) -> set:\n        visited = set()\n        stack = [u]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            visited.add(v)\n            for w, l in graph[v]:\n                stack.append(w)\n        return visited\n\n    result = set()\n    for u in range(1, n + 1):\n        check = dfs(u)\n        if u not in check:\n            result.add(u)\n    result = sorted(result)\n    return str(len(result)) + \"\\n\" + \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    cables = []\n    for _ in range(m):\n        a, b, l = [int(x) for x in stdin.split()]\n        cables.append((a, b, l))\n    graph = {x: [] for x in range(1, n+1)}\n    for a, b, l in cables:\n        graph[a].append((b, l))\n        graph[b].append((a, l))\n    visited = set()\n    queue = deque([(1, 0)])\n    visited.add(1)\n    while queue:\n        current, distance = queue.popleft()\n        for neighbor, length in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, distance+length))\n    return len(visited)"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(\" \"))\n    cables = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.split(\" \"))\n        cables.append([a, b, l])\n        cables.append([b, a, l])\n    # create an undirected graph from the cables\n    graph = collections.defaultdict(set)\n    for a, b, l in cables:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # for each node, check if it could reach every node\n    for node in range(1, n + 1):\n        visited = set()\n        stack = [node]\n        while stack:\n            nod = stack.pop()\n            if nod in visited:\n                continue\n            visited.add(nod)\n            stack.extend(graph[nod])\n        if node not in visited:\n            yield node\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Return the number of switches that could never be part of an optimal path\n    when a packet is transmitted from switch 1 to switch n.\n\n    >>> solution('7 8\\n1 2 2\\n1 3 1\\n1 4 3\\n2 6 1\\n2 7 2\\n3 5 1\\n4 7 2\\n5 7 1\\n')\n    2\n    >>> solution('5 6\\n1 2 2\\n2 3 2\\n3 5 2\\n1 4 3\\n4 5 3\\n1 5 6\\n')\n    0\n    '''\n    # Input.\n    n, m = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    cables = {}\n    for i in range(m):\n        a, b, length = [int(x) for x in stdin.split('\\n')[i+1].split(' ')]\n        if a not in cables:\n            cables[a] = [b]\n        else:\n            cables[a].append(b)\n        if b not in cables:\n            cables[b] = [a]\n        else:\n            cables[b].append(a)\n\n    # Find the switches that cannot be connected to the first switch.\n    visited = set()\n    queue = [1]\n    while queue:\n        node = queue.pop()\n        visited.add(node)\n        for neighbor in cables[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    unused = sorted(list(set(range(1, n+1)) - visited))\n\n    # Find the switches that could never be connected to the second switch.\n    visited = set()\n    queue = [n]\n    while queue:\n        node = queue.pop()\n        visited.add(node)\n        for neighbor in cables[node]:\n            if neighbor not in visited:\n                queue.append(neighbor)\n    unconnected = sorted(list(set(range(1, n+1)) - visited))\n\n    return len(unconnected),''.join(map(str, unconnected))"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, m = map(int, stdin.readline().split())\n    \n    # define empty array to hold all switches that could not be reached\n    unreached = []\n    \n    # iterate over all the cables\n    for _ in range(m):\n        # get the 3 inputs\n        a, b, l = map(int, stdin.readline().split())\n        # check if switch a is reachable to switch b\n        if not isReachable(a, b, l, n):\n            # if not, add the switch to the unreached array\n            unreached.append(a)\n            unreached.append(b)\n    \n    # print the number of unreached switches\n    print(len(unreached))\n    # print the indices of the unreached switches\n    print(' '.join(map(str, sorted(unreached))))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(m):\n        a, b, l = map(int, stdin.split()[3*i:3*i+3])\n        adj[a-1][b-1] = l\n        adj[b-1][a-1] = l\n    return \"\\n\".join(map(lambda x: str(x.index(max(x))+1), adj))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find unused switches in a network\n    \"\"\"\n    \n    # The first line contains two integers n and m \u2014 the number of switches and the number of cables in the network.\n    n, m = [int(x) for x in stdin.split('\\n')[0].split()]\n    \n    # m lines with three integers a, b and c \u2014 the length of the cable between switches a and b, and the overhead of transmitting a network packet on the cable.\n    cables = [[int(x) for x in line.split()] for line in stdin.split('\\n')[1:]]\n    \n    # The network is represented as a graph with m edges, where edge (a, b) has length c if the cable between switches a and b has length c.\n    # d is the greatest network distance; i.e. the farthest distance between any two switches.\n    d = 1\n    graph = defaultdict(set)\n    for a, b, c in cables:\n        graph[a].add((b, c))\n        graph[b].add((a, c))\n        d = max(d, c)\n    \n    # Process each switch one at a time and find the farthest distance it can travel to.\n    farthest_distances = {i: 0 for i in range(1, n + 1)}\n    for a in range(1, n + 1):\n        queue = deque([(a, d)])\n        while queue:\n            cur, dist = queue.popleft()\n            for b, c in graph[cur]:\n                if dist + c < farthest_distances[b]:\n                    farthest_distances[b] = dist + c\n                    queue.append((b, dist + c))\n    \n    # Find unused switches in the graph by comparing the farthest distance from each switch to each other switch.\n    unused_switches = [i for i in range(1, n + 1) if farthest_distances[i] > d]\n    return '\\n'.join([str(len(unused_switches)),''.join([str(x) for x in unused_switches])])\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cables = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.split())\n        cables.append((a, b, l))\n    cables = sorted(cables, key=lambda x: x[0])\n    cables = sorted(cables, key=lambda x: x[1])\n\n    dist = [[float('inf') for _ in range(n + 1)] for _ in range(n + 1)]\n    dist[1][1] = 0\n\n    for i in range(n + 1):\n        for j in range(n + 1):\n            if i == j:\n                continue\n            for a, b, l in cables:\n                if i == a and j == b:\n                    dist[a][b] = min(dist[a][b], l)\n                elif i == b and j == a:\n                    dist[a][b] = min(dist[a][b], l)\n\n                if dist[a][i] + l < dist[i][b]:\n                    dist[a][b] = dist[a][i] + l\n                    dist[b][a] = dist[i][b] + l\n    unused = set(range(2, n + 1))\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if dist[i][j]!= float('inf'):\n                unused.discard(i)\n                unused.discard(j)\n    return str(len(unused)) + '\\n' +''.join(str(x) for x in sorted(unused))\n\n\nprint(solution(input()))"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of switches that will never be part of an optimal path in a network when a packet is transmitted from switch 1 to switch n.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    n, m = map(int, stdin.split())\n    edges = [[int(i) for i in stdin.split()] for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n    cable_count = {}\n    for i in range(1, n+1):\n        cable_count[i] = 0\n    unused = set()\n    count = 0\n    for i in range(m):\n        if edges[i][0] in cable_count:\n            cable_count[edges[i][0]] += 1\n        if edges[i][1] in cable_count:\n            cable_count[edges[i][1]] += 1\n    for i in range(1, n+1):\n        if cable_count[i] == 0:\n            count += 1\n            unused.add(i)\n    return '\\n'.join(map(str, sorted(unused)))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a list of integers representing the indices of the switches\n    that could never be part of an optimal path when a packet is transmitted from switch 1 to\n    switch N.\"\"\"\n    # Initialise data\n    first_line = [int(x) for x in stdin.split(\"\\n\")[0].split()]\n    n = first_line[0]\n    m = first_line[1]\n    cables = []\n    # Initialise data\n    for i in range(m):\n        cable_data = [int(x) for x in stdin.split(\"\\n\")[i + 1].split()]\n        cables.append(tuple(cable_data))\n    # Build and return a graph\n    graph = dict()\n    for i in range(n):\n        graph[i + 1] = dict()\n    for cable in cables:\n        a, b, length = cable\n        if a not in graph[b]:\n            graph[a][b] = length\n            graph[b][a] = length\n    # build the graph\n    for i in range(1, n + 1):\n        graph[i] = {\n            k: v for k, v in graph[i].items() if k!= i\n        }  # Remove self loops\n    # Generate the graph\n    graph = {k: {k2: 0 for k2 in v} for k, v in graph.items()}  # Make sure no node is self-connected\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == j:\n                continue\n            if i in graph[j]:\n                graph[i][j] = min(graph[i][j], graph[i][j] + graph[j][i])\n                graph[j][i] = graph[i][j]\n    # Determine the nodes\n    unused_nodes = set(graph.keys())\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == j:\n                continue\n            if graph[i][j] == 0 and (i in unused_nodes or j in unused_nodes):\n                unused_nodes.add(i)\n                unused_nodes.add(j)\n    return str(len(unused_nodes)) + \"\\n\" + str(sorted(list(unused_nodes)))\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the creation order of a movie based on the order in which it\n    was added to the plot order.\n    \"\"\"\n    # Read input.\n    q = int(stdin.readline())\n    query_list = [\n        [int(s) for s in stdin.readline().split()] for _ in range(q)\n    ]\n    # Create movies in order of their plot order.\n    movies = [Movie(i + 1) for i in range(q)]\n    for i, (x, y) in enumerate(query_list, start=1):\n        # Add movie to plot order.\n        if x == 1:\n            movies[i - 1].add(y)\n        else:\n            # Add movie to creation order.\n            movies[y - 1].add_creation(i)\n\n    # Output answers.\n    for movie in movies:\n        print(movie.creation_order)\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A long time ago in a galaxy far, far away, there was a movie called\n    \"The Empire Strikes Back\" which was actually created in the beginning\n    of the Star Wars trilogy.\n\n    Two actors died during the filming of this movie: Palpatine and Anakin.\n\n    Anakin dies before Anakin had a chance to enter the battle, and\n    Palpatine was always the first one to die.\n\n    The movie was released on December 15, 1980, and it was the\n    third movie in the Star Wars trilogy.\n\n    The two surviving actors are Luke Skywalker and Han Solo.\n    Han, who had previously served as a co-pilot to Chewbacca,\n    was the only one with a lightsaber.\n\n    The original concept for the movie was conceived by David\n    Lucas, the then-CEO of Lucasfilm.\n\n    Chewbacca was the director of the movie.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the index of the first movie created in creation order after the first movie in plot order.\n\n    Args:\n        stdin (str): The input string.\n\n    Returns:\n        str: The output string.\n    \"\"\"\n    n = int(stdin.readline().strip())\n    movies = [None] * (n + 1)\n    for _ in range(n):\n        x, y = [int(x) for x in stdin.readline().split()]\n        if x == 1:\n            movies[y] = x\n        if x == 2:\n            movies[y] = x\n    last = 1\n    for i, movie in enumerate(movies, 1):\n        if movie == 1:\n            last = i\n        if movie == 2:\n            print(last)\n    return ''\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    return the order of the movie\n    \"\"\"\n    # your code here\n    return \"\""
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n: number of movies\n    # m: query\n    # x: plot index\n    # y: creation index\n    # n movies have plot indices 1... n, creation indices 1... n+1\n    # if m=1, x is a plot index, find the corresponding creation index\n    # if m=2, x is a creation index, find the corresponding plot index\n    # assume 1-based indices\n    # assume creation is plot index increased by 1\n    # assume plot index starts with 1 and ends with n+1\n    n = int(stdin.readline())\n    q = []\n    p = dict()\n    for _ in range(n):\n        q.append(list(map(int, stdin.readline().strip().split())))\n    q.sort(key=lambda x: x[0])\n    x = 1\n    for _, y in q:\n        if y == x:\n            x += 1\n            continue\n        p[y] = x\n        x += 1\n    return '\\n'.join(map(str, [p[i] for i in range(1, n+1)]))\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Generate an input stream from stdin.\n    \"\"\"\n    return list(map(str.strip, stdin.split('\\n')))\n\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution for the Star Wars movie ordering problem.\"\"\"\n    # The maximum number of movies created.\n    n = int(stdin.readline())\n    # The dictionary mapping created movies to their indices in the plot order.\n    d = {1: 1, 2: 1}\n    # The dictionary mapping plot order indices to created movies.\n    p = {1: 1, 2: 2}\n\n    for line in stdin:\n        # Parse the line.\n        q, x = map(int, line.split())\n\n        if q == 1:\n            # Create a movie.\n            d[x] = n + 1\n            p[n + 1] = x\n            n += 1\n        elif q == 2:\n            # Move the movie.\n            p[x] = p[p[x]]\n\n    # Produce the solution.\n    for k, v in sorted(d.items()):\n        print(v)"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\\n\".join([\n   ...     '6',\n   ...     '1 1',\n   ...     '1 2',\n   ...     '1 3',\n   ...     '2 1',\n   ...     '2 2',\n   ...     '2 3',\n   ...     '3 1',\n   ...     '3 2',\n   ...     '3 3',\n   ...     '4 1',\n   ...     '4 2',\n   ...     '4 3',\n   ...     '5 1',\n   ...     '5 2',\n   ...     '5 3',\n   ...     '6 1',\n   ... ]))\n    '4'\n    \"\"\"\n    num_of_movies = int(stdin.readline())\n    while num_of_movies!= 0:\n        for i in range(1, num_of_movies + 1):\n            print(i)\n        num_of_movies = int(stdin.readline())\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution for part 1.\"\"\"\n    total = int(stdin.splitlines()[0])\n    query_count = 1\n    while query_count <= total:\n        query = stdin.splitlines()[query_count]\n        query_count += 1\n        q, x = [int(i) for i in query.split()]\n        if q == 1:\n            print(x)\n        else:\n            print(query_count - 1 - x)\n\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    index = 1\n    for i in range(q):\n        type, index = stdin.readline().split()\n        index = int(index)\n        if type == '1':\n            index -= 1\n            while index > 0:\n                index += 1\n                print(index)\n\n        if type == '2':\n            print(index)\n        if i!= q - 1:\n            print()\n    return ''\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    while stdin!= \"PPPPCCCC\":\n        stdin = stdin.replace(\"PP\", \"P\")\n        result += 1\n    return result\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split()\n    ans = 0\n    for i in range(0, len(stdin)):\n        if stdin[i] == stdin[i-1]:\n            ans += 1\n    return ans"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    s = list(input)\n    count = 0\n    for i in range(len(s)):\n        if (s[i] == 'P' and s[i+1] == 'P' and s[i+2] == 'P'):\n            s.pop(i+1)\n            s.pop(i)\n            s.pop(i)\n            count += 1\n    print(count)\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = [i for i in stdin]\n    count = 0\n    for i in range(len(hay_bales)):\n        if hay_bales[i] == 'P':\n            if i > 0:\n                if hay_bales[i - 1] == 'P':\n                    count += 1\n            if i + 1 < len(hay_bales):\n                if hay_bales[i + 1] == 'P':\n                    count += 1\n            if i + 2 < len(hay_bales):\n                if hay_bales[i + 2] == 'P':\n                    count += 1\n    return count\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\ndef"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    return stdin"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n < 3:\n        return n\n    x = 0\n    for i in range(n - 2):\n        if stdin[i] == stdin[i + 1] == stdin[i + 2] == \"P\":\n            x += 1\n    return x"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    print(len(stdin) - 1 - stdin[::-1].find('P'))\n    return\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    ans = 0\n    for i in range(2, len(s)):\n        if s[i]!= s[i - 2]:\n            ans += 1\n    return str(ans)\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds all events that have certainly occurred based on the given implications and evidence collected by your colleague detectives.\"\"\"\n    \n    # Parse the input\n    d_count, m_count, n_count = map(int, stdin.split('\\n')[0].split(' '))\n    implications = {}\n    for i in range(m_count):\n        a, b = map(int, stdin.split('\\n')[i + 1].split(' '))\n        implications.setdefault(a, []).append(b)\n    events = set()\n    for i in range(n_count):\n        events.add(int(stdin.split('\\n')[i + m_count + 1]))\n    \n    # Calculate the results\n    res = set()\n    def calculate(event: int) -> None:\n        nonlocal res\n        if event not in events:\n            res.add(event)\n        for i in implications.get(event, []):\n            calculate(i)\n    \n    for i in range(1, d_count + 1):\n        calculate(i)\n    \n    # Return the results\n    return''.join(map(str, sorted(res)))"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the given problem.\n    \"\"\"\n    # Parsing input\n    implications = list(map(lambda x: tuple(map(int, x.split(' '))), stdin.split('\\n')[:2]))\n    events_occurred = list(map(lambda x: int(x.split(' ')[0]), stdin.split('\\n')[2:]))\n    # Determine which implications are transitive\n    transitive_implications = set()\n    for i in range(len(implications)):\n        if implications[i][0] < implications[i][1]:\n            transitive_implications.add(implications[i])\n    # Find all implications that lead to the events that have already occurred\n    all_events_occurred = set()\n    for i in range(len(implications)):\n        if implications[i][0] in events_occurred and implications[i][1] not in events_occurred:\n            all_events_occurred.add(implications[i][1])\n    # Find all possible events that are implied by the events that have already occurred\n    all_events_occurred_by_others = set()\n    for i in range(len(implications)):\n        if implications[i][1] in events_occurred:\n            all_events_occurred_by_others.add(implications[i][0])\n    # Find all events that have certainly occurred\n    events_certainly_occurred = all_events_occurred.intersection(all_events_occurred_by_others)\n    # Return the output\n    return''.join(list(map(str, list(events_certainly_occurred))))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d = collections.defaultdict(set)\n    n = 0\n    for line in stdin.split('\\n'):\n        if line == '':\n            n += 1\n            continue\n        a, b = map(int, line.split())\n        d[b].add(a)\n    for i in range(1, n + 1):\n        if i not in d:\n            continue\n        seen = set()\n        stack = [i]\n        while stack:\n            node = stack.pop()\n            seen.add(node)\n            for x in d.get(node, set()):\n                if x not in seen:\n                    stack.append(x)\n        print(' '.join(map(str, sorted(seen))))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find all events that have certainly occurred.\"\"\"\n    D, M, N = (int(n) for n in stdin.split())\n    events = {n for n in range(1, D + 1)}\n    implications = set()\n    for _ in range(M):\n        a, b = (int(n) for n in stdin.split())\n        implications.add((a, b))\n    events_occurred = {n for n in stdin.split()}\n    for i in range(N):\n        events.discard(int(stdin.split()[i]))\n    events_occurred = {int(n) for n in events_occurred}\n    result = sorted(events.difference(events_occurred))\n    print(' '.join(map(str, result)))\n    return ''\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # create a dictionary of implications from input string\n    imps = [line.strip().split(' ') for line in stdin.split('\\n')]\n    implications = dict()\n    for imp in imps:\n        implications[imp[0]] = implications.get(imp[0], []) + [imp[1]]\n\n    # create a list of events that are known to have occurred\n    events = [line.strip() for line in stdin.split('\\n') if line!= '']\n\n    # create a list of implications that are true, i.e. in which all events are known to have occurred\n    true_implications = set(implications.keys())\n    for event in events:\n        true_implications &= set(implications[event])\n\n    # add only those implications that are true to the output\n    for imp in implications:\n        if imp in true_implications:\n            print(imp)"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 2 1\\n1 3\\n2 3\\n3\\n\")\n    '1 2 3'\n    \"\"\"\n    D, M, N = map(int, stdin.split())\n    imp_dict = defaultdict(list)\n    for i in range(M):\n        A, B = map(int, stdin.split()[i * 2 : i * 2 + 2])\n        imp_dict[A].append(B)\n    for j in range(N):\n        X = int(stdin.split()[j])\n        cnt = 0\n        queue = deque()\n        queue.append(X)\n        while queue:\n            current = queue.popleft()\n            for element in imp_dict[current]:\n                if element not in queue:\n                    queue.append(element)\n                    cnt += 1\n        print(X if cnt == D else \"\", end=\" \")\n    return \"\"\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 2 1\\n1 3\\n2 3\\n3\\n\")\n    '1 2 3'\n    \"\"\"\n    num_events, num_implications, num_evidence = [int(x) for x in stdin.split()]\n\n    # Map of event name to set of event names implied by event\n    # key: event_name\n    # value: set(event_name, event_name,...)\n    event_to_implied_event = {}\n\n    # Read implications\n    for _ in range(num_implications):\n        event_name_a, event_name_b = [int(x) for x in stdin.split()]\n        if event_name_a not in event_to_implied_event:\n            event_to_implied_event[event_name_a] = set()\n        if event_name_b not in event_to_implied_event:\n            event_to_implied_event[event_name_b] = set()\n\n        event_to_implied_event[event_name_a].add(event_name_b)\n        event_to_implied_event[event_name_b].add(event_name_a)\n\n    # Read evidence\n    for _ in range(num_evidence):\n        event_name = int(stdin.split()[0])\n        if event_name not in event_to_implied_event:\n            continue\n        event_to_implied_event[event_name].clear()\n\n    # Read event names\n    for event_name in range(1, num_events + 1):\n        if event_name not in event_to_implied_event:\n            event_to_implied_event[event_name] = set()\n\n    # Start with events that are directly implied by no other events\n    event_set = set(x for x in event_to_implied_event.keys() if not event_to_implied_event[x])\n\n    # Iterate through events and collect implications that are implied\n    # by the event to be read\n    while True:\n        event_set_copy = event_set.copy()\n        for event_name in event_set:\n            implied_event_names = event_to_implied_event[event_name]\n            for implied_event_name in implied_event_names:\n                event_set_copy.add(implied_event_name)\n        if event_set_copy == event_set:\n            break\n        event_set = event_set_copy\n\n    return \" \".join(str(event_name) for event_name in sorted(event_set))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find all events that have certainly occurred.\"\"\"\n    D, M, N = [int(i) for i in stdin.split(\"\\n\")[0].split()]\n    stdin = stdin.split(\"\\n\")[1:]\n    knowledge_base = {}\n\n    for i in range(M):\n        A, B = [int(j) for j in stdin[i].split()]\n        knowledge_base[A] = B\n\n    event_occurred = set()\n\n    for i in range(N):\n        event = int(stdin[i])\n        event_occurred.add(event)\n        next_event = knowledge_base[event]\n        while True:\n            next_event = knowledge_base[next_event]\n            if next_event == event:\n                break\n            event_occurred.add(next_event)\n\n    return \" \".join(map(str, sorted(event_occurred)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the list of events that have occurred\n\n    Parameters\n    ----------\n    stdin : str\n        The input string\n\n    Returns\n    -------\n    str\n        The output string\n    \"\"\"\n    events = stdin.split(\"\\n\")\n    events = [event.split(\" \") for event in events[:-1]]\n    events = {event[0]: event[1] for event in events}\n    d = stdin.split(\"\\n\")\n    d = [int(d[i]) for i in range(1, len(d))]\n    res = []\n    for i in range(len(d)):\n        for j in range(i):\n            if d[i] == d[j] and events[i]!= events[j]:\n                res.append(d[i])\n                break\n    res = list(set(res))\n    res.sort()\n    return \"\\n\".join(str(x) for x in res)\n\n\ndef"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split())\n    graph = {}\n\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        graph.setdefault(A, [])\n        graph.setdefault(B, [])\n        graph[A].append(B)\n        graph[B].append(A)\n\n    for _ in range(N):\n        X = int(stdin)\n        graph[X] = set()\n\n    visited = set()\n    results = []\n\n    def dfs(node, stack):\n        visited.add(node)\n        stack.append(node)\n\n        for neighbor in graph[node]:\n            if neighbor in visited:\n                continue\n\n            dfs(neighbor, stack)\n\n    dfs(1, [])\n\n    return''.join(map(str, sorted(results)))\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split(' '))\n    nums = [int(stdin.split('\\n')[1].split(' ')[i]) for i in range(n)]\n    # n, k = map(int, stdin.split('\\n')[0].split(' '))\n    # nums = [int(stdin.split('\\n')[1].split(' ')[i]) for i in range(n)]\n\n    # print(n, k, nums)\n\n    k_max, rem = divmod(n, k)\n    # print(k_max, rem)\n    res = k_max * (sum(nums) - rem * k_max)\n    # print(res)\n    return str(res % 1000000007)\n\nprint(solution(str(input())))"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split('\\n')[0].split())\n    A = list(map(int, stdin.split('\\n')[1].split()))\n    mod = 1000000007\n    s = 0\n    for i in range(K):\n        s += max(A)\n        del A[A.index(max(A))]\n    return s % mod\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    finds the greatest sum of values of K keys at the same time\n    and the remainder of this number modulo 100000000007\n    '''\n\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # create a dictionary with values\n    d = {key: value for key, value in enumerate(a)}\n    # sort dictionary by values\n    d = {key: value for key, value in sorted(d.items(), key=lambda item: item[1], reverse=True)}\n    # create list of keys\n    k = list(d.keys())\n    # for each key, find its value\n    a = [d[key] for key in k]\n    # for each key, find its index in the list\n    b = {key: index for index, key in enumerate(k)}\n    # divide a by K\n    a = [x for x in [a[i:i + K] for i in range(0, len(a), K)] for y in x]\n\n    # find the number\n    s = sum(a) % 100000000007\n    print(s)\n\n    return str(s)\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    from itertools import combinations\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    A = set(combinations(a, k))\n    m = 0\n    for A_ in A:\n        m = max(m, max(A_))\n    return str(m % (10**9 + 7))\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    #pass"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return 'test string'\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return 'Case #{}: {}'.format(1, stdin)\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    solution:\n    '''\n\n    return (\n        stdout\n        # TODO: implement solution\n    )\n\n\ndef"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    rows, cols = [int(i) for i in stdin.split(' ')]\n    grid = []\n    for i in range(rows):\n        grid.append(stdin[i * cols : (i + 1) * cols])\n    # check all possible solutions\n    solutions = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == \"x\":\n                solutions.append(check_solution(grid, i, j))\n    # print the best solution\n    best_solution = min(solutions, key=lambda x: x[0])\n    print(\"{} {} {}\".format(best_solution[1], best_solution[2], best_solution[3]))\n\ndef"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    print(\"Hello World!\")\n    return \"Hello World!\"\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 3\\n...\\n.x.\\n.x.\\nx.\")\n    '1 1 2'\n    >>> solution(\"4 6\\n...\\n.xx\\n.x.x\\nx.x.\\nx.x.\")\n    '1 1 2'\n    >>> solution(\"4 6\\n.x.x\\nxx.x\\nx.xx\\nx.xx\\nxx.x\\n.x.x.\")\n    '1 2 3'\n    >>> solution(\"4 6\\n.xx\\nxx.x\\nx.x.\\nx.x.\\nx.x.\\n.x.x\\nx.xx\\nx.xx\\nx.x.\")\n    '1 4 1'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(x) for x in stdin.split()]\n    grid = []\n    for _ in range(R):\n        grid.append(stdin.split('\\n')[1:])\n\n    # find the location of the two buildings\n    building1 = None\n    building2 = None\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 'x':\n                building1 = (i, j)\n                break\n        if building1:\n            break\n\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 'x':\n                building2 = (i, j)\n                break\n        if building2:\n            break\n\n    # assume that there are 2 buildings\n    b1 = (building1[0], building1[1], 0)\n    b2 = (building2[0], building2[1], 0)\n\n    if b1[0] == b2[0]:\n        if b1[1] > b2[1]:\n            # b1 is above b2\n            above_b1 = True\n            below_b1 = False\n            above_b2 = False\n            below_b2 = True\n        else:\n            # b2 is above b1\n            above_b1 = False\n            below_b1 = True\n            above_b2 = True\n            below_b2 = False\n    elif b1[1] == b2[1]:\n        if b1[0] > b2[0]:\n            # b1 is to the right of b2\n            above_b1 = False\n            below_b1 = True\n            above_b2 = False\n            below_b2 = True\n        else:\n            # b2 is to the right of b1\n            above_b1 = True\n            below_b1 = False\n            above_b2 = True\n            below_b2 = False\n    else:\n        # b1 is below b2\n        above_b1 = False\n        below_b1 = True\n        above_b2 = False\n        below_b2 = True\n\n    # for each row, find the first b1 and b2\n    # for each col, find the first b1 and b2\n    # find the min distance from one building to the next\n    min_dist = float('inf')\n    b1_location = (None, None)\n    b2_location = (None, None)\n    for i, row in enumerate(grid):\n        j = 0\n        while j < len(row):\n            if row[j] == 'x':\n                # b1 is first found\n                b1_location = (i, j)\n                break\n            j += 1\n        if b1_location:\n            break\n\n    for i, row in enumerate(grid):\n        j = 0\n        while j < len(row):\n            if row[j] == 'x':\n                # b2 is first found\n                b2_location = (i, j)\n                break\n            j += 1\n        if b2_location:\n            break\n\n    # find the min dist between b1 and b2\n    for i, row in enumerate(grid):\n        j = 0\n        while j < len(row):\n            if row[j] == 'x':\n                dist = abs(b1_location[0] - i) + abs(b1_location[1] - j)\n                if dist < min_dist:\n                    min_dist = dist\n                break\n            j += 1\n\n    # find the min dist between b1 and b2\n    for i, row in enumerate(grid):\n        j = 0\n        while j < len(row):\n            if row[j] == 'x':\n                dist = abs(b2_location[0] - i) + abs(b2_location[1] - j)\n                if dist < min_dist:\n                    min_dist = dist\n                break\n            j += 1\n\n    print(b1_location)\n    print(b2_location)\n\n    # return the coordinates of the building, its side length\n    if above_b1:\n        if above_b2:\n            if min_dist == 0:\n                return b1[0], b1[1], 1\n            return b1[0], b2[1], min_dist\n        return b1[0], b2[1], min_dist\n    else:\n        if above_b2:\n            return b1[0], b1[1], min_dist\n        return b2[0], b1[1], min_dist\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(x) for x in stdin.split()]\n\n    # build grid\n    grid = []\n    for _ in range(R):\n        grid.append(stdin.split('\\n')[1:])\n\n    # find top left corner\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                row = i\n                col = j\n                break\n\n    # now we know the upper left corner of the first building, let's do the same for the second building\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                top_left_corner = (i, j)\n                break\n    return '{} {} {}'.format(row, col, C - col)\n\n\ndef"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # read the input from stdin\n\n    # calculate the length of the grid\n    # loop the number of times\n    # read in the string input\n    # convert the string input into an array\n    # loop through the input array\n    # if the value in the input array is a dot, set the cell to None\n    # if the value is x, set the cell to a building\n\n    # set the start position to row 1, column 1\n\n    # set a variable to track the x and y position\n    # loop through the input array\n    # if the value is x, increment the x variable by 1\n    # if the value is a dot, increment the y variable by 1\n    # calculate the x and y position based on the x and y variables\n    # update the x and y variables\n\n    # return the output to stdout\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'Alice' or 'Bob' or 'indistinguishable' based on initial parameters.\"\"\"\n    intersections = [list(map(int, line.split())) for line in stdin.splitlines()[:2]]\n    turns = [list(map(int, line.split())) for line in stdin.splitlines()[2:]]\n    return 'Alice' if turns[0][2] == 1 else 'Bob' if turns[1][2] == 1 else 'indistinguishable'\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split())\n    A, B = A-1, B-1\n    if A == B:\n        return 'indistinguishable'\n    c = 0\n    for i in range(n):\n        l, r, t = map(int, stdin.split())\n        if l == A and r == B:\n            c += t\n            break\n        elif l == B and r == A:\n            c += t\n            break\n        else:\n            c += 1\n    return c\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    n, a, b = [int(x) for x in stdin.split()]\n    t = [0] * n\n    for i in range(n):\n        l, r, t_ = [int(x) for x in stdin.split()]\n        t[l - 1] += 1\n        t[r - 1] += 1\n        if t_ == 1:\n            t[i] = 0\n    if t[a - 1] == t[b - 1] == 0:\n        return 'indistinguishable'\n    a_turn = sum(t[:a - 1])\n    b_turn = sum(t[:b - 1])\n    if a_turn > b_turn:\n        return str(a_turn - b_turn)\n    elif a_turn < b_turn:\n        return str(b_turn - a_turn)\n    else:\n        return 'indistinguishable'\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split('\\n')[0].split(' '))\n    road = [list(map(int, stdin.split('\\n')[i].split(' '))) for i in range(1, n + 1)]\n    if road[a][b] == 1:\n        return 'Alice'\n    return 'Bob'\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, a, b = map(int, stdin.split())\n    adj = [{}, {}]\n    for i in range(n):\n        for t, p in [map(int, line.split()) for line in stdin.splitlines()[i + 1:]]:\n            adj[t].setdefault(p, []).append(i)\n    # print(adj)\n    q = [a, b]\n    visited = set(q)\n    while q:\n        a = q.pop()\n        if a == b:\n            return 'Bob'\n        for i in adj[a]:\n            if i not in visited:\n                q.append(i)\n                visited.add(i)\n    return 'Alice'\n    '''\n    n, a, b = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    for i, line in enumerate(stdin.splitlines()[1:]):\n        for t, p in map(int, line.split()):\n            adj[t].append((p, i))\n    # print(adj)\n    q = [(a, 0)]\n    visited = set()\n    while q:\n        a, t = q.pop()\n        if a == b:\n            return 'Bob'\n        if a not in visited:\n            visited.add(a)\n            for p, i in adj[a]:\n                if p not in visited:\n                    q.append((p, t + i))\n    return 'Alice'\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This solution gives wrong answer\n    '''\n    n, a, b = [int(i) for i in stdin.split('\\n')[0].split()]\n    l = []\n    for i in range(n):\n        l.append([int(i) for i in stdin.split('\\n')[i + 1].split()])\n    print(l)\n    if l[a][b] == 1:\n        print('A')\n    elif l[b][a] == 1:\n        print('B')\n    else:\n        print('indistinguishable')\n    return ''\n\nprint(solution('''\n3 1 2\n1 2 1\n0 2 0\n0 1 0\n'''))\n\nprint(solution('''\n2 0 1\n1 1 1\n0 0 0\n'''))\n\n\ndef"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split('\\n')[0].split(' '))\n    points = [list(map(int, line.split(' '))) for line in stdin.split('\\n')[1:]]\n    points.sort()\n    a_turns = 0\n    b_turns = 0\n    for point in points:\n        if point[0] == a:\n            if point[2] == 0:\n                a_turns += 1\n            else:\n                break\n        elif point[0] == b:\n            if point[2] == 0:\n                b_turns += 1\n            else:\n                break\n    return 'indistinguishable' if a_turns == b_turns else 'Alice' if a_turns < b_turns else 'Bob'"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3 1 2\\\\n1 2 1\\\\n0 2 0\\\\n0 1 0')\n    'indistinguishable'\n    \"\"\"\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    rp = stdin[0]\n    cp = stdin[1]\n    \n    # row parity\n    row_even = 0\n    row_odd = 0\n    row_len = len(rp)\n    for i in range(row_len):\n        if rp[i] == '0':\n            row_even += 1\n        else:\n            row_odd += 1\n    \n    # column parity\n    column_even = 0\n    column_odd = 0\n    column_len = len(cp)\n    for i in range(column_len):\n        if cp[i] == '0':\n            column_even += 1\n        else:\n            column_odd += 1\n            \n    if (row_len % 2 == 0 and row_even!= row_len) or (row_len % 2 == 1 and row_odd!= row_len):\n        return -1\n    if column_len % 2 == 0 and column_even!= column_len:\n        return -1\n    \n    # no possibility\n    if row_len == 1 or column_len == 1:\n        return -1\n    \n    # prepare to append\n    row_len = len(rp)\n    column_len = len(cp)\n    \n    # check if column have odd\n    has_column_odd = False\n    for i in range(column_len):\n        if cp[i] == '1':\n            has_column_odd = True\n            break\n    \n    # append\n    if has_column_odd == True:\n        result = rp[0]\n        for i in range(1, row_len):\n            result = result + rp[i]\n            if i < row_len - 1:\n                result = result + cp[0]\n            if i == row_len - 1:\n                result = result + cp[1]\n        return result\n    else:\n        # return -1\n        return rp[0] + cp[0] + rp[1] + cp[1]\n    \n    return result"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r_p = stdin[0]\n    c_p = stdin[1]\n\n    r_p = list(r_p)\n    c_p = list(c_p)\n    n = len(r_p)\n    m = len(c_p)\n\n    ans = [[0 for _ in range(m)] for _ in range(n)]\n    #print(ans)\n\n    for i in range(n):\n        for j in range(m):\n            #print(ans[i][j])\n            if ans[i][j] == 0:\n                if r_p[i] == '1' and c_p[j] == '1':\n                    ans[i][j] = 1\n                    ans[i][j + 1] = 1\n                    ans[i][j + 2] = 1\n                    ans[i + 1][j] = 1\n                    ans[i + 1][j + 1] = 1\n                    ans[i + 1][j + 2] = 1\n                    ans[i + 2][j] = 1\n                    ans[i + 2][j + 1] = 1\n                    ans[i + 2][j + 2] = 1\n                    break\n                elif r_p[i] == '0' and c_p[j] == '1':\n                    ans[i][j] = 1\n                    ans[i][j + 1] = 1\n                    ans[i + 1][j] = 1\n                    ans[i + 1][j + 1] = 1\n                    ans[i + 2][j] = 1\n                    ans[i + 2][j + 1] = 1\n                    ans[i + 2][j + 2] = 1\n                    break\n    return ''.join([''.join([str(i) for i in j]) for j in ans])"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"101010\")\n    101010\n    >>> solution(\"111000\")\n    111000\n    >>> solution(\"1010\")\n    11010\n    >>> solution(\"1011\")\n    11011\n    >>> solution(\"10111110\")\n    11101110\n    \"\"\"\n    rows = list(map(int, stdin.split()))\n    cols = list(map(int, stdin.split()))\n    if sum(rows)!= sum(cols):\n        return \"-1\"\n    r = rows[::-1]\n    c = cols[::-1]\n    return \"\".join([\"1\" if r[i]!= c[i] else \"0\" for i in range(len(rows))])\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    \"\"\"\n    R, C = stdin.split()\n    row_parity = [int(i) for i in list(R)]\n    col_parity = [int(i) for i in list(C)]\n    \n    return (-1, -1)\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"0110\\n1001\")\n    1111\n    \"\"\"\n    row_parities = [int(char) for char in stdin.split(\"\\n\")[0]]\n    column_parities = [int(char) for char in stdin.split(\"\\n\")[1]]\n    row_parity_index = 1\n    column_parity_index = 1\n\n    row_length = len(row_parities)\n    column_length = len(column_parities)\n\n    reconstructed_matrix = [\n        row_parities[row_parity_index] * \"1\" + row_parities[row_parity_index + 1] * \"0\"\n    ]\n\n    while row_parity_index < row_length - 1 and column_parity_index < column_length - 1:\n        next_row = column_parities[column_parity_index] * \"1\" + (\n            \"0\" if row_parities[row_parity_index] == column_parities[column_parity_index] else \"1\"\n        )\n        reconstructed_matrix.append(next_row)\n        row_parity_index += 1\n        column_parity_index += 1\n\n    if row_parity_index < row_length - 1:\n        next_row = column_parities[column_parity_index] * \"1\" + (\n            \"0\" if row_parities[row_parity_index] == column_parities[column_parity_index] else \"1\"\n        )\n        reconstructed_matrix.append(next_row)\n\n    return \"\".join(reconstructed_matrix)\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    m = int(stdin[1])\n    if n > m:\n        R = stdin[0]\n        C = stdin[1]\n    else:\n        R = stdin[1]\n        C = stdin[0]\n    if n % 2!= 0 or m % 2!= 0:\n        print(-1)\n    else:\n        if R[0] == '1' or C[0] == '1':\n            print(-1)\n        else:\n            print(n, m)\n            # R = [1] + R + [1]\n            # C = [1] + C + [1]\n            for i in range(1, n):\n                R = R[1:] + ['1']\n                C = ['1'] + C\n            for i in range(m):\n                R = ['1'] + R\n                C = ['1'] + C\n            print(''.join(R))\n            print(''.join(C))\n            for i in range(n):\n                R = ['1'] + R\n                C = ['1'] + C\n            print(''.join(R))\n            print(''.join(C))\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin[0]\n    cols = stdin[1]\n    row_parity = [int(i) for i in rows]\n    col_parity = [int(i) for i in cols]\n    matrix = [[0 for j in range(len(cols))] for i in range(len(rows))]\n    matrix[0] = [1 if x == 1 else 0 for x in col_parity]\n    for i in range(1, len(rows)):\n        matrix[i][0] = 1 if row_parity[i - 1] == 0 else 0\n    for i in range(1, len(cols)):\n        for j in range(1, len(rows)):\n            matrix[j][i] = 1 if (matrix[j - 1][i] == 1 and col_parity[i - 1] == 0) or (matrix[j][i - 1] == 0 and row_parity[j - 1] == 0) else 0\n    for row in matrix:\n        print(''.join([str(i) for i in row]))\n    return"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ans = []\n    n = int(stdin.split(\"\\n\")[0])\n    m = int(stdin.split(\"\\n\")[1])\n    for i in range(n):\n        ans.append(1 * (n - i) + 1)\n\n    for i in range(m):\n        ans.append(1)\n\n    for i in range(n - 1):\n        temp = \"\"\n        for j in range(m - 1):\n            temp += str(int(ans[i][j] == ans[i][j + 1]))\n        ans.append(temp + str(int(ans[i][m - 1] == ans[i + 1][0])))\n\n    return \"\\n\".join(ans[:n + m])\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    m = int(stdin[1])\n\n    ones = [int(i) for i in stdin]\n\n    for _ in range(n + m):\n        ones = [ones[-1]] + ones[:-1]\n\n    print(-1) if max(ones) > 1 else print(''.join(str(i) for i in ones))\n\n    return ''\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    row_parity = stdin[0]\n    column_parity = stdin[1]\n\n    if sum(row_parity) % 2!= 0:\n        return -1\n    elif sum(column_parity) % 2!= 0:\n        return -1\n\n    return ''.join([str(0 if column_parity[i] == '0' else 1) for i in range(len(column_parity))]) * int(row_parity[0]) + ''.join(\n        [str(0 if row_parity[i] == '0' else 1) for i in range(len(row_parity))])\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"10000\")\n    '+0000'\n    >>> solution(\"1111\")\n    '+0-0'\n    \"\"\"\n    n = int(stdin, 2)\n    signs = ['0', '+', '-']\n    result = []\n    while n:\n        digit = n % 2\n        if digit not in [0, 1]:\n            raise ValueError(f\"binary number should contain only zeros and ones, but got {digit}\")\n        result.append(signs[digit])\n        n //= 2\n\n    # reverse the list to get lexicographically smallest representation\n    result.reverse()\n    return \"\".join(result)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    n_bin = bin(n).replace(\"0b\", \"\")\n    n_bin = n_bin.replace(\"-\", \"+\")\n    n_bin = n_bin.replace(\"1\", \"-\")\n    n_bin = n_bin.replace(\"0\", \"0\")\n    return n_bin\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    The first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092^100000) \u2014 the number in binary, without leading zeros.\n    '''\n    pass\n\nprint(solution(stdin.readline()))\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    ans = []\n    n = int(stdin, 2)\n    bit = n\n    if bit == 0:\n        return '0'\n    while bit:\n        if bit & 1:\n            ans.append('1')\n        else:\n            ans.append('0')\n        bit = bit >> 1\n    ans.reverse()\n    return ''.join(ans)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution\n    return ''\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin[0:]\n    neg = '-'\n    pos = '+'\n    result = ''\n    for i in range(len(n)):\n        if n[i] == '1':\n            result += neg\n        elif n[i] == '0':\n            result += pos\n        else:\n            return 'Error: input is not binary number'\n    return result\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    s = s.replace(\"0\", \"-\")\n    s = s.replace(\"1\", \"+\")\n    return s\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    i = 0\n    while n > 0:\n        if n & 1:\n            i += 1\n        n >>= 1\n    return f\"+{'0' * i}-\" * (i > 0)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution of the problem.\n    \"\"\"\n    # Convert the input string to integer.\n    n = int(stdin, 2)\n\n    # Find the length of the string.\n    length = len(stdin)\n\n    # The result will be printed in this list.\n    result = []\n\n    # Use a while loop to loop over the result string.\n    # This will be a list of numbers.\n    i = 0\n    while i < length:\n        # Check if it is a negative number.\n        # If not, it can be written as a + b * 2, where\n        # a and b are single digits.\n        # Hence, we use divmod() to find a and b.\n        if not (n & 1):\n            a, b = divmod(n, 2)\n            result.append('0')\n        # Otherwise, it can be written as - a * 2 - b,\n        # where b is a single digit.\n        else:\n            a, b = divmod(n + 1, 2)\n            result.append('-')\n        # Set the new n.\n        n = a\n        # Set the new i.\n        i += 1\n\n    # Join the characters into a string.\n    return ''.join(result)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the lexicographically smallest signed binary representation of\n    a nonnegative integer.\n    \"\"\"\n    # Split input on whitespace.\n    numbers = stdin.split()\n\n    # Check for edge cases.\n    if numbers[0] == \"0\":\n        return \"0\"\n    elif int(numbers[0], 2) < -2**(len(numbers[0])-1):\n        return \"-\" + numbers[0]\n\n    # Convert input into integer.\n    n = int(numbers[0], 2)\n\n    # Compute base 10 representation.\n    base_10 = [0]*(len(numbers[0])+1)\n    base_10[-1] = n\n    for i in reversed(range(len(base_10)-1)):\n        base_10[i] = base_10[i+1]//2\n        base_10[i] = base_10[i] - (base_10[i+1]%2)*((base_10[i+1]//2)**2)\n\n    # Determine if input is positive or negative and determine if the sign\n    # bits are zeros or ones.\n    sign = int(numbers[0][0])\n    sign_bits = []\n    for num in numbers[0]:\n        if num == \"0\":\n            sign_bits.append(\"0\")\n        else:\n            sign_bits.append(\"+\")\n            sign *= -1\n    sign_bits.reverse()\n\n    # Make sure output is correct length.\n    if len(numbers[0]) < len(sign_bits):\n        sign_bits = sign_bits[:len(numbers[0])]\n\n    # Return output.\n    sign_bits.append(\"0\")\n    sign_bits.append(\"0\")\n    output = []\n    for i in range(len(sign_bits)):\n        if sign_bits[i] == \"+\":\n            output.append(\"+\")\n        else:\n            output.append(\"-\")\n        output.append(\"0\"*(len(numbers[0])-i-1))\n\n    return \"\".join(output)\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return stdin"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/546f922b54af40e1e90001da\"\"\"\n    n, m, s, t = [int(x) for x in stdin.split(\" \")]\n    a, b = [int(x) for x in stdin.split(\" \")]\n    x = [int(x) for x in stdin.split(\" \")]\n    y = [int(x) for x in stdin.split(\" \")]\n    roads = []\n    for i in range(m):\n        roads.append([int(x) for x in stdin.split(\" \")])\n    d = dict()\n    for road in roads:\n        if road[0] not in d:\n            d[road[0]] = dict()\n        if road[1] not in d:\n            d[road[1]] = dict()\n        d[road[0]][road[1]] = road[2]\n        d[road[1]][road[0]] = road[2]\n\n    def distance(x, y, d):\n        if x in d:\n            return d[x].get(y, -1)\n        return -1\n    return distance(a, b, d) + sum(distance(x, y, d) for x in x for y in y if x!= y)"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum total distance traveled by the shipping company's employees.\n\n    Args:\n        stdin (str): Input string given by the pattern\n\n    Returns:\n        str: Output string\n    \"\"\"\n    return \"1\""
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The idea here is to find the shortest path from a warehouse to the clients\n    then find the shortest path from each client to the next client, sum these\n    two paths together, and the path from the last client to the second last\n    client. There is a short circuit where if the warehouse is the last node,\n    then you can just send the customer there and return. Then you just need to\n    find the shortest path from the last client to the second last client.\n\n    If the warehouse is not the last node, then you have to send the customer\n    to the warehouse and then return the customer. So the two paths combined\n    will be the shortest path from the first node to the last node. This\n    solution is pretty brute force.\n    \"\"\"\n    n, m, s, t = map(int, stdin.split())\n    warehouse_1, warehouse_2 = list(map(int, stdin.split()))\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, d = map(int, stdin.split())\n        graph[u - 1].append((v - 1, d))\n        graph[v - 1].append((u - 1, d))\n    dist = [float('inf') for _ in range(n)]\n    dist[warehouse_1 - 1] = 0\n    for _ in range(s):\n        for u, d in graph[warehouse_1 - 1]:\n            if dist[u] < d:\n                continue\n            dist[u] = d\n        warehouse_1 = 0\n        for u, d in graph[warehouse_1 - 1]:\n            if dist[u] < d:\n                continue\n            warehouse_1 = u\n            dist[u] = d\n        dist[warehouse_1 - 1] = 0\n\n    for _ in range(t):\n        for u, d in graph[warehouse_2 - 1]:\n            if dist[u] < d:\n                continue\n            dist[u] = d\n        warehouse_2 = 0\n        for u, d in graph[warehouse_2 - 1]:\n            if dist[u] < d:\n                continue\n            warehouse_2 = u\n            dist[u] = d\n        dist[warehouse_2 - 1] = 0\n\n    return min(sum(d for u, d in graph[warehouse_2 - 1]) + dist[warehouse_2 - 1],\n               sum(d for u, d in graph[warehouse_2 - 1]) + dist[warehouse_2 - 1] + dist[warehouse_1 - 1])\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_matrix(rows: str):\n        matrix = []\n        for row in rows.split('\\n'):\n            matrix.append([int(elem) for elem in row.split(' ')])\n        return matrix\n\n    roads_matrix = get_matrix(stdin)\n    warehouse_indexes = [int(elem) for elem in stdin.split('\\n')[1].split(' ')]\n\n    print(warehouse_indexes)\n    print(roads_matrix)\n    return 0\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the problem.\n\n    >>> solution('''7 8 3 2\n   ... 1 2\n   ... 7 3 4\n   ... 5 6\n   ... 1 3 2\n   ... 1 4 1\n   ... 1 5 1\n   ... 1 6 6\n   ... 2 3 9\n   ... 2 4 2\n   ... 2 6 4''')\n    9\n    '''\n    # Read in inputs.\n    (n, m, s, t), (a, b), (warehouses, employees, clients) = map(\n        lambda x: tuple(map(int, x.split(' '))),\n        stdin.split('\\n')\n    )\n\n    # Construct graph with the roads.\n    graph = collections.defaultdict(list)\n    for u, v, d in map(lambda x: tuple(map(int, x.split(' '))), stdin.split('\\n')[2:]):\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Precompute edge distances for the targets.\n    targets = {tuple(map(int, x.split(' '))): d\n               for x, d in map(lambda x: tuple(map(int, x.split(' '))), stdin.split('\\n')[3 + m:])}\n\n    # Precompute edge distances for the warehouses.\n    warehouse_roads = {\n        (a, b): d\n        for a, b, d in map(lambda x: tuple(map(int, x.split(' '))), stdin.split('\\n')[0:2])\n    }\n\n    # Build and solve the model.\n    model = cp_model.CpModel()\n\n    # Decision variables for trucks.\n    trucks = [model.NewIntVar(1, s, 'truck' + str(i))\n              for i in range(t)]\n\n    # Decision variables for truck to each client.\n    truck_to_client = [\n        [model.NewBoolVar('truck' + str(i) + '_client' + str(j))\n         for j in range(t)]\n        for i in range(s)\n    ]\n\n    # Decision variables for the trucks to each warehouse.\n    truck_to_warehouse = [\n        [model.NewBoolVar('truck' + str(i) + '_warehouse' + str(j))\n         for j in range(n)]\n        for i in range(s)\n    ]\n\n    # Minimum cost of truck to each client.\n    min_cost = model.NewIntVar(0, s * t,'min_cost')\n\n    # Constraints.\n    model.Add(sum(trucks) == t)\n    model.Add(min_cost == sum(trucks[i] * targets[(i, j)]\n                              for i in range(t) for j in range(s)))\n    model.Add(min_cost <= sum(trucks))\n\n    # Truck can only go to client if truck is at warehouse.\n    for i in range(s):\n        model.Add(sum(truck_to_client[i]) <= sum(truck_to_warehouse[i]))\n\n    # Truck goes from warehouse to client.\n    for (i, j), d in warehouse_roads.items():\n        model.Add(sum(truck_to_client[i]) - truck_to_warehouse[i][j] <= 0)\n        model.Add(sum(truck_to_client[i]) - truck_to_warehouse[i][j] >= -d)\n\n    # Truck goes from client to warehouse.\n    for i in range(s):\n        model.Add(sum(truck_to_warehouse[i]) <= sum(truck_to_client[i]))\n\n    # Truck can only go to one client.\n    for i in range(s):\n        model.Add(sum(truck_to_client[i]) <= 1)\n\n    # Truck cannot go to an intersection twice.\n    for i in range(s):\n        for j in range(t):\n            model.Add(sum(truck_to_client[i]) <= 1)\n\n    # Truck can only go to a certain truck.\n    for i, j in product(range(s), range(t)):\n        model.Add(trucks[j] - trucks[i] <= 0)\n\n    # Truck cannot go to an intersection twice.\n    for i in range(t):\n        for j in range(s):\n            model.Add(trucks[i] - trucks[j] <= 0)\n\n    # Truck cannot go to the warehouse twice.\n    for i in range(s):\n        for j in range(n):\n            model.Add(truck_to_warehouse[i][j] <= 0)\n\n    # Truck cannot go to the client twice.\n    for i in range(s):\n        for j in range(t):\n            model.Add(truck_to_client[i][j] <= 0)\n\n    # Truck cannot go to the warehouse twice.\n    for i in range(s):\n        for j in range(n):\n            model.Add(truck_to_warehouse[i][j] <= 0)\n\n    # Truck cannot go to the client twice.\n    for i in range(s):\n        for j in range(t):\n            model.Add(truck_to_client[i][j] <= 0)\n\n    # Create solver and solve.\n    solver = cp_model.CpSolver()\n    solver.parameters.max_time_in_seconds = 30.0\n    status = solver.Solve(model)\n\n    # Print solution.\n    if status == cp_model.OPTIMAL:\n        return"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for this challenge.\"\"\"\n    from sys import stdin\n    from collections import defaultdict\n\n    def get_input() -> dict:\n        \"\"\"Return input as a dict.\"\"\"\n        line_1 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        line_2 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        line_3 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        line_4 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        line_5 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        line_6 = [int(val) for val in stdin.readline().strip().split(\" \")]\n        return {\n            \"n\": line_1[0],\n            \"m\": line_1[1],\n            \"s\": line_1[2],\n            \"t\": line_1[3],\n            \"warehouse\": line_2[0],\n            \"employee\": line_2[1],\n            \"distances\": defaultdict(list),\n            \"clients\": set(),\n            \"deliveries\": set(),\n        }\n\n    def get_distance(\n        source: int, destination: int, distances: dict\n    ) -> int:\n        \"\"\"Return the distance between source and destination.\"\"\"\n        if distances[source][destination]!= -1:\n            return distances[source][destination]\n\n        # Check if it has been calculated before.\n        if distances[destination][source]!= -1:\n            return distances[destination][source]\n\n        # Find shortest path between source and destination.\n        for path_from_source in distances[source].keys():\n            if path_from_source == destination:\n                return 1\n            if distances[path_from_source][destination] == -1:\n                distances[path_from_source][destination] = get_distance(\n                    source=path_from_source, destination=destination, distances=distances\n                )\n\n        # If it has not been calculated before, calculate it.\n        total = 0\n        for path_from_source in distances[source].keys():\n            total += distances[path_from_source][destination]\n        distances[source][destination] = total\n\n        return total\n\n    def get_minimum_distance(\n        distances: dict, warehouse: int, clients: set\n    ) -> int:\n        \"\"\"Return the minimum distance from warehouse to all clients.\"\"\"\n        distance = 0\n        for client in clients:\n            distance += get_distance(\n                source=warehouse, destination=client, distances=distances\n            )\n        return distance\n\n    inputs = get_input()\n    for i in range(inputs[\"m\"]):\n        line = [int(val) for val in stdin.readline().strip().split(\" \")]\n        inputs[\"distances\"][line[0]].append(line[1])\n        inputs[\"distances\"][line[1]].append(line[0])\n        inputs[\"clients\"].add(line[0])\n        inputs[\"clients\"].add(line[1])\n\n    for i in range(inputs[\"s\"]):\n        line = [int(val) for val in stdin.readline().strip().split(\" \")]\n        inputs[\"distances\"][line[0]].append(line[1])\n        inputs[\"distances\"][line[1]].append(line[0])\n        inputs[\"clients\"].add(line[0])\n        inputs[\"clients\"].add(line[1])\n\n    for i in range(inputs[\"t\"]):\n        line = [int(val) for val in stdin.readline().strip().split(\" \")]\n        inputs[\"distances\"][line[0]].append(line[1])\n        inputs[\"distances\"][line[1]].append(line[0])\n        inputs[\"clients\"].add(line[0])\n        inputs[\"clients\"].add(line[1])\n\n    # Get minimum distances.\n    inputs[\"minimum_distance\"] = get_minimum_distance(\n        distances=inputs[\"distances\"],\n        warehouse=inputs[\"warehouse\"],\n        clients=inputs[\"clients\"],\n    )\n    return inputs[\"minimum_distance\"]\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    start = lines[1].split()\n    end = lines[2].split()\n    distances = {(v, w): int(d) for v, w, d in map(lambda x: x.split(), lines[3:])}\n    total = 0\n    total += distances[(int(start[0]), int(start[1]))]\n    total += distances[(int(end[0]), int(end[1]))]\n    for v in lines[3:]:\n        dist = distances[(int(v[0]), int(v[1]))]\n        total += dist\n    return str(total)\n    pass\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Solution to part 1\n    # Return the minimum total distance travelled by all employees\n\n    # Declare variables\n    n, m, s, t = list(map(int, stdin.split(\" \")))\n    warehouses = list(map(int, stdin.split(\" \")))\n    employees = list(map(int, stdin.split(\" \")))\n    roads = []\n    total_dist = 0\n    dist = []\n\n    # Get roads and convert them to a dict\n    for i in range(m):\n        x, y, z = list(map(int, stdin.split(\" \")))\n        roads.append((x, y, z))\n        roads.append((y, x, z))\n    roads = dict(roads)\n\n    # Get the distances between intersections\n    for i in roads:\n        if i[0] in employees:\n            dist.append(roads[i])\n        elif i[0] in warehouses:\n            dist.append(roads[i])\n    dist.sort()\n\n    # Find the minimum distance travelled by an employee\n    for i in employees:\n        for j in dist:\n            if j[0] == i:\n                total_dist += j[2]\n\n    return total_dist\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the total distance travelled by the truck truck to deliver all items in each truck to the warehouse.\n    >>> solution(\"7 8 3 2\\n1 2\\n7 3 4\\n5 6\\n1 3 2\\n1 4 1\\n1 5 1\\n1 6 6\\n2 3 9\\n2 4 2\\n2 6 4\")\n    9\n    >>> solution(\"7 8 3 2\\n1 2\\n7 3 4\\n5 6\\n1 3 2\\n1 4 1\\n1 5 1\\n1 6 6\\n2 3 9\\n2 4 2\\n2 6 4\")\n    12\n    \"\"\"\n    _, _, _, truck_count = stdin.split()\n    _, warehouse = stdin.split()\n    _, truck = stdin.split()\n    _, truck = stdin.split()\n    _, truck = stdin.split()\n    _, truck = stdin.split()\n    roads = [tuple(int(d) for d in road.split()) for road in stdin.split(\"\\n\")[2:]]\n    trucks = [int(truck) for truck in stdin.split()]\n\n    return truck_count"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, traps, _ = [int(n) for n in stdin.split('\\n')[0].split()]\n    bacteria_to_check = []\n    for row in range(1, rows + 1):\n        for col in range(1, cols + 1):\n            bacteria_to_check.append((row, col))\n    bacteria_to_check.append(tuple(stdin.split()[1:]))\n    trap = tuple(stdin.split()[2])\n    return max(abs(bacteria[0] - trap[0]) + abs(bacteria[1] - trap[1]) for bacteria in bacteria_to_check)\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    X, Y = map(int, stdin.split())\n    X -= 1\n    Y -= 1\n    U, R, D, L = 0, 1, 2, 3\n    adj = [(U, 0), (R, 1), (D, 2), (L, 3)]\n    bacteria = []\n    for i in range(K):\n        X, Y, C = map(int, stdin.split())\n        X -= 1\n        Y -= 1\n        bacteria.append((X, Y, C))\n    seen = set()\n    queue = deque()\n    queue.append((X, Y, U, 0))\n    while len(queue):\n        x, y, c, l = queue.popleft()\n        if (x, y, c) in seen:\n            continue\n        seen.add((x, y, c))\n        if x == X and y == Y:\n            return l\n        for ax, ay in adj:\n            if c == ax:\n                nx = x + ay\n                ny = y + ay\n                if nx < 0 or ny < 0 or nx >= N or ny >= M:\n                    nx = x + ay\n                    ny = y + ay\n                if 0 <= nx < N and 0 <= ny < M and (nx, ny, c) not in seen:\n                    queue.append((nx, ny, c, l + 1))\n            else:\n                if c == ay and (x, y, ax) not in bacteria:\n                    queue.append((x, y, ax, l + 1))\n    return -1\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return string.\"\"\"\n    # Get input values\n    grid_size = list(map(int, stdin.split('\\n')[:2]))\n    trap_pos = list(map(int, stdin.split('\\n')[2:4]))\n    bacteria = [\n        list(\n            map(\n                int,\n                list(\n                    stdin.split('\\n')[i].strip().split()[:2]\n                ),\n            ),\n        )\n        for i in range(5, 9)\n    ]\n\n    # Replace bacteria direction with cell number\n    for b, bc in enumerate(bacteria):\n        for i, c in enumerate(bc[3:]):\n            if c == 'U':\n                bc[2 * i + 2] = bc[2 * i + 1]\n            elif c == 'R':\n                bc[2 * i + 2] = bc[2 * i + 1] + 1\n            elif c == 'D':\n                bc[2 * i + 2] = bc[2 * i + 1] + grid_size[1]\n            elif c == 'L':\n                bc[2 * i + 2] = bc[2 * i + 1] - 1\n\n    # Initialize variables\n    count = 0\n    visited = [[0] * grid_size[1] for _ in range(grid_size[0])]\n    timer = grid_size[0] * grid_size[1]\n\n    # Move bacteria\n    while True:\n        for row in range(grid_size[0]):\n            for col in range(grid_size[1]):\n                if visited[row][col] == 0:\n                    if is_in_trap(row, col, trap_pos, grid_size):\n                        break\n                    count += 1\n                    timer = move_bacteria(row, col, bacteria, grid_size, visited, timer)\n        else:\n            return -1 if count!= grid_size[0] * grid_size[1] else timer\n\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    row = int(stdin.split('\\n')[0])\n    col = int(stdin.split('\\n')[1])\n    trap = (int(stdin.split('\\n')[2].split()[0]), int(stdin.split('\\n')[2].split()[1]))\n    s = stdin.split('\\n')[3:]\n    grid = [[int(x) for x in line] for line in s]\n    t = 0\n    while True:\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j]!= 0:\n                    if i + 1 < row:\n                        grid[i + 1][j] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if j + 1 < col:\n                        grid[i][j + 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if i > 0:\n                        grid[i - 1][j] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if j > 0:\n                        grid[i][j - 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if i + 1 < row and j + 1 < col:\n                        grid[i + 1][j + 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if i + 1 < row and j > 0:\n                        grid[i + 1][j - 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if i > 0 and j + 1 < col:\n                        grid[i - 1][j + 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n                    if i > 0 and j > 0:\n                        grid[i - 1][j - 1] += grid[i][j] // 5\n                        grid[i][j] = grid[i][j] % 5\n        if trap[0] == trap[1]:\n            return -1\n        if grid[trap[0]][trap[1]] == 0:\n            return t\n        t += 1\n    return t\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    x, y = map(int, stdin.split('\\n')[1].split())\n    cells = [list(map(int, stdin.split('\\n')[i].split())) for i in range(2, len(stdin.split('\\n')), 3)]\n    t = 0\n    queue = deque([(x, y, 0, 0, 0, 0)])\n    visited = {(x, y): False}\n    while queue:\n        x, y, t, prev_c, cnt, prev_cnt = queue.popleft()\n        if prev_c == 'U' and cnt == k:\n            return t\n        if prev_c == 'R' and cnt == k:\n            return t\n        for dx, dy, d in [(1, 0, 'R'), (-1, 0, 'L'), (0, 1, 'D'), (0, -1, 'U')]:\n            tx, ty = x + dx, y + dy\n            if 0 <= tx < n and 0 <= ty < m and not visited.get((tx, ty)):\n                if prev_c == 'L' and cells[x][y] == cells[tx][ty]:\n                    queue.append((tx, ty, t, 'R', cnt + 1, 0))\n                elif prev_c == 'R' and cells[x][y] == cells[tx][ty] + 1:\n                    queue.append((tx, ty, t, 'L', cnt + 1, 0))\n                elif prev_c == 'D' and cells[x][y] == cells[tx][ty] + 10:\n                    queue.append((tx, ty, t, 'U', cnt + 1, 0))\n                elif prev_c == 'U' and cells[x][y] == cells[tx][ty] + 100:\n                    queue.append((tx, ty, t, 'D', cnt + 1, 0))\n                else:\n                    queue.append((tx, ty, t + 1, d, cnt + 1, 0))\n                visited[(tx, ty)] = True\n    return '-1'\n\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    # n -> rows, m -> cols, k -> traps\n    if k == 1:\n        return -1\n\n    x, y = map(int, stdin.split('\\n')[1:][0].split())\n    # (x, y) -> trap position\n    board = [[int(digit) for digit in stdin.split('\\n')[i+1].split()] for i in range(n)]\n    # board[i][j] -> [row][col]\n\n    directions = list(stdin.split('\\n')[2:][0].split())\n    # directions[i] -> direction\n\n    # directions = [\"U\", \"R\", \"D\", \"L\", \"U\", \"R\", \"U\", \"R\", \"U\", \"R\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"R\", \"U\", \"D\", \"R\", \"R\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"R\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"R\", \"U\", \"U\", \"U\", \"R\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U\", \"U"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(n) for n in stdin.split()]\n    x, y = [int(n) for n in stdin.split()]\n    R, D, L, U = 'R', 'D', 'L', 'U'\n    board = [[0 for _ in range(M)] for _ in range(N)]\n    dir = [0] * K\n    for i in range(K):\n        x, y, direction = [int(n) for n in stdin.split()]\n        board[x - 1][y - 1] = i + 1\n        dir[i] = direction\n\n    for _ in range(1_000_000):\n        c = [0] * K\n        for i in range(K):\n            x, y = [int(n) for n in stdin.split()]\n            x -= 1; y -= 1\n            # print(x, y)\n            if board[x][y] == i + 1:\n                if dir[i] == R:\n                    dir[i] = D\n                elif dir[i] == D:\n                    dir[i] = L\n                elif dir[i] == L:\n                    dir[i] = U\n                elif dir[i] == U:\n                    dir[i] = R\n                c[i] = 1\n        for i in range(K):\n            if c[i]:\n                continue\n            if dir[i] == R:\n                dir[i] = D\n            elif dir[i] == D:\n                dir[i] = L\n            elif dir[i] == L:\n                dir[i] = U\n            elif dir[i] == U:\n                dir[i] = R\n            x, y = [int(n) for n in stdin.split()]\n            x -= 1; y -= 1\n            board[x][y] = i + 1\n    # print(board)\n    # print(dir)\n    # print(sum([len(n) for n in board]))\n    # print(sum([len(n) for n in dir]))\n    return stdin\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    (N, M, K) = [int(x) for x in stdin.split()]\n    X, Y = [int(x) for x in stdin.split()]\n    (bacteria_x, bacteria_y, bacteria_direction) = []\n    for i in range(K):\n        (bacteria_x_i, bacteria_y_i, bacteria_direction_i) = [int(x) for x in stdin.split()]\n        bacteria_x.append(bacteria_x_i)\n        bacteria_y.append(bacteria_y_i)\n        bacteria_direction.append(bacteria_direction_i)\n    bacteria_x.append(X)\n    bacteria_y.append(Y)\n    bacteria_direction.append(bacteria_direction[0])\n\n    direction_from_id = {0: \"U\", 1: \"R\", 2: \"D\", 3: \"L\"}\n    direction_to_id = {\"U\": 0, \"R\": 1, \"D\": 2, \"L\": 3}\n    steps_to_trap = 100\n\n    bacteria_x = np.array(bacteria_x)\n    bacteria_y = np.array(bacteria_y)\n    bacteria_direction = np.array(bacteria_direction)\n    bacteria_id = np.array(range(K+1))\n    bacteria_coordinates = np.stack((bacteria_x, bacteria_y), axis=1)\n\n    def move_bacteria(bacteria_id, bacteria_coordinates, bacteria_direction):\n        bacteria_id_new = np.zeros_like(bacteria_id)\n        bacteria_coordinates_new = np.zeros_like(bacteria_coordinates)\n        bacteria_direction_new = np.zeros_like(bacteria_direction)\n        for i in range(K+1):\n            id_ = bacteria_id == i\n            coordinates = bacteria_coordinates[id_]\n            direction_ = bacteria_direction[id_]\n            coordinates_new = []\n            direction_new = []\n            for (x, y), d in zip(coordinates, direction_):\n                if x == steps_to_trap and y == steps_to_trap:\n                    coordinates_new.append((x, y))\n                    direction_new.append(direction_to_id[d])\n                    continue\n                direction = direction_from_id[d]\n                for _ in range(steps_to_trap):\n                    x_new, y_new = move(x, y, direction)\n                    if x_new < 1 or x_new > N or y_new < 1 or y_new > M:\n                        direction = direction_to_id[d]\n                        continue\n                    coordinates_new.append((x_new, y_new))\n                    direction_new.append(direction_to_id[d])\n                    x, y = x_new, y_new\n            bacteria_id_new[i] = bacteria_id[i]\n            bacteria_coordinates_new[i] = np.array(coordinates_new)\n            bacteria_direction_new[i] = np.array(direction_new)\n        return bacteria_id_new, bacteria_coordinates_new, bacteria_direction_new\n    bacteria_id_new, bacteria_coordinates_new, bacteria_direction_new = move_bacteria(bacteria_id, bacteria_coordinates, bacteria_direction)\n    max_bacteria_id_new = np.max(bacteria_id_new)\n    bacteria_id_new = bacteria_id_new - 1\n    bacteria_coordinates_new = bacteria_coordinates_new - 1\n    bacteria_coordinates_new = np.array(bacteria_coordinates_new, dtype=int)\n    bacteria_coordinates = np.array(bacteria_coordinates, dtype=int)\n    bacteria_id = bacteria_id - 1\n    bacteria_direction_new = np.array(bacteria_direction_new, dtype=int)\n    bacteria_direction = np.array(bacteria_direction, dtype=int)\n\n    def bacteria_to_neighbours(bacteria_id, bacteria_coordinates, bacteria_direction):\n        bacteria_id_new = np.zeros_like(bacteria_id)\n        bacteria_coordinates_new = np.zeros_like(bacteria_coordinates)\n        bacteria_direction_new = np.zeros_like(bacteria_direction)\n        for i in range(K+1):\n            id_ = bacteria_id == i\n            coordinates = bacteria_coordinates[id_]\n            direction = bacteria_direction[id_]\n            coordinates_new = []\n            direction_new = []\n            for (x, y), d in zip(coordinates, direction):\n                if d == direction_to_id[\"U\"]:\n                    coordinates_new.append((x, y+1))\n                    direction_new.append(direction_to_id[\"U\"])\n                elif d == direction_to_id[\"D\"]:\n                    coordinates_new.append((x, y-1))\n                    direction_new.append(direction_to_id[\"D\"])\n                elif d == direction_to_id[\"L\"]:\n                    coordinates_new.append((x+1, y))\n                    direction_new.append(direction_to_id[\"L\"])\n                elif d == direction_to_id[\"R\"]:\n                    coordinates_new.append((x-1, y))\n                    direction_new.append(direction_to_id[\"R\"])\n            bacteria_id_new[i] = bacteria_id[i]\n            bacteria_coordinates_new[i] = np.array(coordinates_new)\n            bacteria_direction_new[i] = np.array(direction_new)\n        return bacteria_id_new, bacteria_coordinates_new, bacteria_direction_new\n    bacteria_id_new, bacteria_coordinates_new,"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for \"Luka's time\".\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Output.\n    \"\"\"\n    N, M, K = (int(x) for x in stdin.split('\\n')[0].split())\n    X, Y = (int(x) for x in stdin.split('\\n')[1].split())\n    traps = [[int(x) for x in line.split()] for line in stdin.split('\\n')[2:]]\n    board = [[0 for _ in range(M)] for _ in range(N)]\n\n    for trap in traps:\n        x, y, c = trap\n        board[x - 1][y - 1] = str(c)\n\n    for i in range(K):\n        for j in range(M):\n            if board[0][j] == '0':\n                if board[1][j]!= '0':\n                    board[0][j] = board[1][j]\n                else:\n                    board[0][j] = '1'\n            elif board[1][j] == '0':\n                if board[0][j]!= '0':\n                    board[1][j] = board[0][j]\n                else:\n                    board[1][j] = '1'\n            elif board[0][j]!= '0':\n                board[1][j] = board[0][j]\n                board[0][j] = '0'\n            elif board[1][j]!= '0':\n                board[0][j] = board[1][j]\n                board[1][j] = '0'\n            else:\n                board[0][j] = '1'\n                board[1][j] = '1'\n        for j in range(M):\n            if board[N - 2][j] == '0':\n                if board[N - 1][j]!= '0':\n                    board[N - 2][j] = board[N - 1][j]\n                else:\n                    board[N - 2][j] = '1'\n            elif board[N - 1][j] == '0':\n                if board[N - 2][j]!= '0':\n                    board[N - 1][j] = board[N - 2][j]\n                else:\n                    board[N - 1][j] = '1'\n            elif board[N - 2][j]!= '0':\n                board[N - 1][j] = board[N - 2][j]\n                board[N - 2][j] = '0'\n            elif board[N - 1][j]!= '0':\n                board[N - 2][j] = board[N - 1][j]\n                board[N - 1][j] = '0'\n            else:\n                board[N - 1][j] = '1'\n                board[N - 2][j] = '1'\n\n    return -1 if board[N - 1][Y - 1] == '0' else len(stdin.split('\\n')[0].split())\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, nums = map(int, stdin.split('\\n')[0].split(' '))\n    nums = list(map(int, stdin.split('\\n')[1].split(' ')))\n    s, e = 0, 1\n    ans = 0\n    while s < n - 1:\n        if nums[s] + nums[e] <= nums[e]:\n            s += 1\n            e += 1\n        else:\n            ans += e - s\n            s += 1\n    return ans\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *nums = stdin.split()\n    n, nums = int(n), [int(num) for num in nums]\n\n    if n < 2:\n        return '0'\n\n    if nums[0] == nums[-1]:\n        return '1'\n    elif nums[0] > nums[-1]:\n        return '0'\n    else:\n        result = 0\n        for i in range(n - 1):\n            if nums[i] < nums[i + 1]:\n                result += 1\n        return str(result)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    values = [int(x) for x in lines[1].split(' ')]\n    values.sort()\n    s = set()\n    l = []\n    i = 0\n    while i < n - 1:\n        l.append(values[i])\n        s.add(values[i])\n        while i < n - 1 and values[i + 1] == values[i] + 1:\n            i += 1\n        i += 1\n    l.append(values[i])\n    s.add(values[i])\n    s.add(values[n - 1])\n    if l[0]!= 1:\n        l.insert(0, 1)\n        s.add(1)\n    print(s)\n    return len(s)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = list(map(int, stdin.split()))\n    l = 0\n    r = n - 2\n    ans = 0\n    while r < n - 1:\n        a = nums[r + 1] - nums[l]\n        b = nums[r + 2] - nums[l + 1]\n        if a == b:\n            l = r + 1\n            r = r + 2\n            ans += 1\n        elif a > b:\n            l = r + 1\n            r = r + 2\n            ans += 1\n        else:\n            break\n    return ans\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = [int(i) for i in stdin.readline().strip().split(' ')]\n\n    a_s = []\n    a_p = []\n\n    for i in range(len(a)):\n        if i % 2 == 0:\n            a_s.append(a[i])\n        else:\n            a_p.append(a[i])\n\n    a_s.sort()\n    a_p.sort()\n\n    ret = 0\n\n    for i in range(len(a_p)):\n        j = 0\n        while j < len(a_s) and a_s[j] <= a_p[i] * 2:\n            j += 1\n        ret += j\n\n    return str(ret)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://dev.to/rodzib/a-practical-guide-to-adversarial-toddler-training-3lw\"\"\"\n    stdin = stdin.split(\"\\n\")\n    pages = [int(page) for page in stdin[1].split()]\n    counter = 1\n    for i in range(len(pages)-1):\n        if pages[i+1] == pages[i]+1:\n            counter += 1\n    return str(counter)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split(' ')))\n    arr.sort()\n    res = 0\n    for i in range(n - 1):\n        if arr[i]!= arr[i + 1]:\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = [int(i) for i in stdin.readline().split()]\n    ret = [0]\n    s = [0] + sorted(s)\n    for i in range(1, n + 1):\n        ret.append(ret[i - 1] + 1)\n        if s[i] - s[i - 1] > 1:\n            ret[i] = min(ret[i], ret[i - 1] + 1)\n    return str(ret[n])"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip('\\n')\n    student_set = set()\n    num_students = int(stdin.split('\\n')[0].split()[0])\n    for _ in range(num_students):\n        stdin = stdin.split('\\n')\n        stdin[0] = stdin[0].split()\n        student_set.add(stdin[0][0])\n        stdin[0][0] = int(stdin[0][0])\n        stdin[0][1] = int(stdin[0][1])\n        stdin[1] = int(stdin[1])\n    for _ in range(num_students):\n        stdin = stdin.split('\\n')\n        stdin[0] = stdin[0].split()\n        stdin[0][0] = int(stdin[0][0])\n        stdin[0][1] = int(stdin[0][1])\n        stdin[1] = int(stdin[1])\n        # checks if there is a student whose knowledge is greater than or equal to\n        # student's knowledge and greater than or equal to student's difficulty\n        # and a student who has greater knowledge\n        if (stdin[0][1] >= stdin[1] >= stdin[0][0]) and stdin[0][1] >= stdin[0][0] and stdin[0][1] > stdin[1]:\n            print(stdin[0][0])\n        else:\n            print(\"NE\")\n    return \"\"\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    students = []\n    for _ in range(n):\n        (command, *args) = stdin.readline().split()\n        if command == 'D':\n            students.append((int(args[0]), int(args[1])))\n        else:\n            print(args[0])\n    return \"\"\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Solution\n    # 1. find stdin\n    stdin = stdin.split(\"\\n\")\n    # 2. find number of queries\n    num_queries = int(stdin[0])\n    queries = []\n    for i in range(1, num_queries+1):\n        queries.append(stdin[i])\n    # 3. find number of students\n    n = len(queries)\n    # 4. find the students\n    students = []\n    for i in range(n):\n        if queries[i][0] == \"D\":\n            students.append(stdin[i+1])\n    # 5. output\n    output = []\n    for i in range(len(students)):\n        students[i] = [int(stdin[i+1][1]), int(stdin[i+1][3])]\n        if students[i][0] >= students[i][1]:\n            output.append(\"NE\")\n        else:\n            output.append(stdin[i+1][2])\n    return output\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_students = int(stdin.splitlines()[0])\n    answers = dict()\n    for i in range(1, num_students + 1):\n        stdin = stdin.splitlines()[i]\n        if stdin.startswith(\"D\"):\n            a, b = map(int, stdin.split()[1:])\n            answers[i] = {a: b, b: a}\n        else:\n            who_to_ask = int(stdin.split()[1])\n            stdin = stdin.split()[2:]\n            count = 0\n            for j in range(0, len(stdin) - 1, 2):\n                if stdin[j] in answers[i]:\n                    if answers[i][stdin[j]]:\n                        stdin[j] = stdin[j]\n                    else:\n                        stdin[j] = stdin[j + 1]\n                        stdin[j + 1] = stdin[j]\n                        count += 1\n                else:\n                    stdin[j] = stdin[j]\n            print(answers[i], stdin, who_to_ask, count)\n            if who_to_ask not in answers[i]:\n                answers[i][who_to_ask] = count\n            elif answers[i][who_to_ask] >= count:\n                answers[i][who_to_ask] = count\n\n    stdin = stdin.splitlines()[num_students]\n    who_to_ask = int(stdin.split()[1])\n    stdin = stdin.split()[2:]\n    count = 0\n    for j in range(0, len(stdin) - 1, 2):\n        if stdin[j] in answers[who_to_ask]:\n            if answers[who_to_ask][stdin[j]]:\n                stdin[j] = stdin[j]\n            else:\n                stdin[j] = stdin[j + 1]\n                stdin[j + 1] = stdin[j]\n                count += 1\n        else:\n            stdin[j] = stdin[j]\n\n    print(answers, stdin, who_to_ask, count)\n    return \" \".join(stdin)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    students = {(0,0): set()}\n    for _ in range(n):\n        inputs = stdin.split(\"\\n\")[1:]\n        if inputs[0][0] == \"D\":\n            a,b = [int(x) for x in inputs[0].split(\" \")[1:]]\n            students[(a,b)] = set()\n        elif inputs[0][0] == \"P\":\n            students[(0,0)].add(int(inputs[0].split(\" \")[1]))\n    for _ in range(n-1):\n        inputs = stdin.split(\"\\n\")[1:]\n        a,b = [int(x) for x in inputs[0].split(\" \")[1:]]\n        students[(a,b)] = students[(0,0)]\n        for s in students[(0,0)]:\n            students[(a,b)].add(s)\n        students[(0,0)] = set()\n    output = {}\n    for key in students:\n        for s in students[key]:\n            if s in output:\n                output[s] += key[0] * key[1]\n            else:\n                output[s] = key[0] * key[1]\n    stdin = stdin.split(\"\\n\")[1:]\n    for s in stdin:\n        print(sorted(output[int(s.split(\" \")[1])], key= lambda x: abs(output[int(s.split(\" \")[1])]-x))[0])\n\nsolution(stdin)"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: input in string format\n    :return: solution in string format\n    \"\"\"\n    n, arr = stdin.split(\"\\n\")[:2]\n    n = int(n)\n    arr = [tuple(map(int, i.split()[1:])) for i in arr.split(\"\\n\")[1:]]\n\n    res = []\n    # noinspection PyUnusedLocal\n    for i in range(1, n + 1):\n        # noinspection PyUnusedLocal\n        temp = [j[1] for j in arr if j[0] >= i]\n        if len(temp) > 0:\n            res.append(temp[0])\n        else:\n            res.append('NE')\n    return \"\\n\".join(map(str, res))\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the student who should ask for help.\"\"\"\n    n = int(stdin)\n    dic = {}\n    for _ in range(n):\n        line = stdin.readline().split()\n        if line[0] == 'D':\n            dic[int(line[1])] = int(line[2])\n        else:\n            ans = dic[int(line[1])]\n            for i in range(1, n):\n                if dic[i] < ans:\n                    ans = dic[i]\n            print(ans)\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    rows, cols, k, l = stdin.split(\"\\n\")\n    rows, cols, k, l = int(rows), int(cols), int(k), int(l)\n    t = stdin.split(\"\\n\")\n    start_row, start_col = int(stdin.split(\"\\n\")[0]), int(stdin.split(\"\\n\")[1])\n    visited = set()\n    path = []\n    def bfs(row, col):\n        q = [[row, col]]\n        visited.add((row, col))\n        while q:\n            row, col = q.pop(0)\n            for new_row, new_col in [row + 1, col], [row - 1, col], [row, col + 1], [row, col - 1]:\n                if 0 <= new_row < rows and 0 <= new_col < cols:\n                    if t[row][col] + k < t[new_row][new_col] and (new_row, new_col) not in visited:\n                        q.append([new_row, new_col])\n                        visited.add((new_row, new_col))\n    bfs(start_row, start_col)\n    return len(visited)"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    rows, cols, fish_appearance, fish_lifetime, start_row, start_col = (\n        int(i) for i in stdin.split('\\n')[0].split())\n    # create map\n    lake = [list(map(int, stdin.split('\\n')[i + 1].split()))\n            for i in range(rows)]\n    # create dictionary of fish times\n    fish_dict = {}\n    for row in range(rows):\n        for col in range(cols):\n            if lake[row][col]!= 0:\n                fish_dict[lake[row][col]] = (row, col)\n    # create fish list\n    fish_list = list(fish_dict.keys())\n    fish_list.sort()\n    # variables\n    row = start_row\n    col = start_col\n    lifetime = 0\n    current_points = 0\n    # loop until all fishes are caught\n    while fish_list:\n        # add fish to dictionary\n        lifetime += 1\n        fish = fish_list.pop(0)\n        # look around\n        for new_row, new_col in [(row - 1, col), (row, col - 1), (row + 1, col),\n                                 (row, col + 1)]:\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                # check if the fish is on this point and if it is new\n                if lake[new_row][new_col] == fish and \\\n                        fish_dict[fish][0]!= new_row and \\\n                        fish_dict[fish][1]!= new_col:\n                    # add fish to dictionary\n                    fish_dict[fish] = (new_row, new_col)\n                    # add fish to list\n                    fish_list.append(fish)\n                    # remove fish from dictionary\n                    del fish_dict[fish]\n                    # increment points\n                    current_points += 1\n        # remove fish from dictionary\n        del fish_dict[fish]\n        # remove fish from list\n        fish_list.remove(fish)\n        # check if fish in dictionary\n        if fish in fish_dict:\n            fish = fish_dict[fish]\n            # check if fish in list\n            if fish in fish_list:\n                # remove fish from list\n                fish_list.remove(fish)\n                # add fish to dictionary\n                fish_dict[fish] = (fish[0], fish[1])\n                # remove fish from dictionary\n                del fish_dict[fish]\n                # add fish to list\n                fish_list.append(fish)\n    return str(current_points)\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = [int(n) for n in stdin.strip().split()]\n    x_0, y_0 = [int(n) for n in stdin.strip().split()]\n    t = [list(map(int, stdin.strip().split())) for _ in range(r)]\n\n    def count_fish(row_idx: int, col_idx: int) -> int:\n        max_num = 0\n        for row_inc in range(-1, 2):\n            for col_inc in range(-1, 2):\n                if abs(row_inc + row_idx) < r and abs(col_inc + col_idx) < c:\n                    max_num = max(max_num, t[row_idx + row_inc][col_idx + col_inc])\n\n        return max_num\n\n    def count_next_row(row_idx: int, col_idx: int) -> int:\n        max_num = 0\n        for col_inc in range(-1, 2):\n            if abs(col_inc + col_idx) < c:\n                max_num = max(max_num, t[row_idx + 1][col_idx + col_inc])\n\n        return max_num\n\n    answer = 0\n    row_idx = 0\n    col_idx = 0\n    while l >= count_fish(row_idx, col_idx):\n        max_num = count_next_row(row_idx, col_idx)\n        if max_num == 0:\n            break\n        l -= max_num\n        answer += 1\n        row_idx += 1\n        col_idx = (col_idx + max_num) % c\n\n    return str(answer)\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the maximum number of points you could catch fish from.\n    '''\n    # Get input\n    r, c, k, l = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    x0, y0 = [int(x) for x in stdin.split('\\n')[1].split(' ')]\n    t = [[int(x) for x in stdin.split('\\n')[i].split(' ')] for i in range(2, 2 + r)]\n\n    # Get data\n    fish = 0\n    visited = set()\n    visited.add((x0, y0))\n    fish_pos = [0 for _ in range(r * c)]\n    fish_pos[x0 * c + y0] = l\n\n    # Loop\n    for i in range(k):\n        # Get new positions\n        for x in range(r):\n            for y in range(c):\n                if (x, y) not in visited and fish_pos[x * c + y] > 0:\n                    fish_pos[x * c + y] -= 1\n                    if fish_pos[x * c + y] == 0:\n                        visited.add((x, y))\n        # Get new fish positions\n        for x in range(r):\n            for y in range(c):\n                if (x, y) not in visited and fish_pos[x * c + y] > 0:\n                    fish += 1\n                    if fish > r * c:\n                        return r * c\n                    visited.add((x, y))\n\n    return fish\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a Riemann sum solution to the problem\"\"\"\n    r, c, k, l = [int(x) for x in stdin.split()]\n    x0, y0 = [int(x) for x in stdin.split()][1:]\n    lst = [int(x) for x in stdin.split()][2:]\n    lst = [[lst[i], lst[i+1]] for i in range(0, len(lst), 2)]\n    lst.insert(0, [0, 0])\n    s = 0\n    for x, y in lst:\n        if x0 + y0 > s:\n            s = x0 + y0\n        x0 += x\n        y0 += y\n    print(s)\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.split(\"\\n\")[0].split())\n    x_0, y_0 = map(int, stdin.split(\"\\n\")[1].split())\n    t = [[int(x) for x in stdin.split(\"\\n\")[i].split()] for i in range(2, len(stdin.split(\"\\n\")), 1)]\n    return solve(r, c, k, l, x_0, y_0, t)\n\n\ndef"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"\"\n    (r, c, k, l) = [int(x) for x in stdin.split()]\n    x0, y0 = [int(x) for x in stdin.split()]\n    t = [[int(x) for x in stdin.split()] for _ in range(r)]\n    t_max = max([max(row) for row in t])\n    print(t_max)\n    print(t)\n    # t = [[t[i][j] for j in range(c)] for i in range(r)]\n    # t = [[1 if 0 <= j < c else 0 for j in range(c)] for i in range(r)]\n    # print(t)\n    # print(f'{x0=}')\n    # print(f'{y0=}')\n    # print(f'{r=}')\n    # print(f'{c=}')\n    # print(f'{k=}')\n    # print(f'{l=}')\n    # for i in range(r):\n    #     for j in range(c):\n    #         print(f'{t[i][j]=}')\n    # print(t[0][0], t[0][1], t[1][0], t[1][1])\n    return \"\""
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution function'''\n\n    # Get all the values from the input\n    values = stdin.split(\"\\n\")\n\n    # Extract values\n    r, c, k, l = [int(i) for i in values[0].split()]\n    x, y = [int(i) for i in values[1].split()]\n    ts = [[int(i) for i in values[j].split()] for j in range(2, len(values))]\n\n    # Get the list of all the times\n    times = list(set([j for i in ts for j in i]))\n    times.sort()\n\n    # Get the next time of fish\n    def get_next_time(time: int) -> int:\n        return times[times.index(time) + 1]\n\n    # Get the number of points that fish will appear at\n    def get_num_points(time: int) -> int:\n        return sum(time[i] - times[i] <= k for i in range(len(times)))\n\n    # Get the number of fish at a given point\n    def get_num_fish(time: int, x: int, y: int) -> int:\n        return ts[y][x] - time\n\n    # Get the possible times of catching fish\n    def get_possible_times(time: int, x: int, y: int) -> List[int]:\n        # Get the next time of the fish\n        next_time = get_next_time(time)\n\n        # If the next time is out of range, return the current time\n        if next_time > l:\n            return [time]\n\n        # Get the number of points that fish will appear at\n        num_points = get_num_points(time)\n\n        # If the number of points is greater than or equal to 1\n        if num_points >= 1:\n            # Get the number of fish at the current position\n            num_fish = get_num_fish(time, x, y)\n\n            # If the number of fish is greater than or equal to 1\n            if num_fish >= 1:\n                # Get the possible times of catching fish\n                return [time] + get_possible_times(next_time, x, y)\n            else:\n                # Get the possible times of catching fish\n                return get_possible_times(next_time, x, y)\n        else:\n            # Get the possible times of catching fish\n            return get_possible_times(next_time, x, y)\n\n    # Get the maximum number of points that fish can be caught\n    max_points = 0\n    for i in range(r):\n        for j in range(c):\n            if get_num_fish(l, i, j) >= 1:\n                max_points = max(max_points, len(get_possible_times(l, i, j)))\n\n    return max_points\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    return \"Not implemented yet\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\"\"\"\n    pass\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the diameter of the smallest drill bit that removes all the flaws.\"\"\"\n    # Get the number of flaws from stdin.\n    num_flaws = int(stdin.readline().strip())\n\n    # Get the coordinates of each flaw from stdin.\n    flaws = [tuple(map(float, stdin.readline().strip().split(\" \"))) for _ in range(num_flaws)]\n\n    # Calculate the diameter of the drill bit.\n    # Note: We want to use integers so that we can use multiplication to find the diameter.\n    # Note: We want to use abs(a - b) so that we don't inadvertently add a negative diameter.\n    # Note: abs(a - b) * 2 + 2 because it's a circle.\n    diameter = int(math.ceil(math.sqrt(max(abs(a - b) ** 2 for a, b in itertools.combinations(flaws, 2)) * 2 + 2)))\n\n    # Return the diameter.\n    return str(diameter)\n\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n1.0 0.0 1.4\\n-1.0 0.0 -1.4\\n0.0 1.0 -0.2\\n\")\n    '2.0000000000'\n    \"\"\"\n\n    return ''\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n1.0 0.0 1.4\\n-1.0 0.0 -1.4\\n0.0 1.0 -0.2\")\n    '2.0000000000'\n    >>> solution(\"5\\n1.4 1.0 0.0\\n-0.4 -1.0 0.0\\n-0.1 -0.25 -0.5\\n-1.2 0.0 0.9\\n0.2 0.5 0.5\")\n    '2.0000000000'\n    \"\"\"\n    in_data = [int(x) for x in stdin.splitlines()]\n    flaw_list = [[round(x * 1000) for x in [float(y) for y in z.split()]] for z in in_data]\n\n    dist = {tuple(z): i for i, z in enumerate(flaw_list)}\n    flaw_set = set([tuple(z) for z in flaw_list])\n    n = len(flaw_list)\n\n    # A - 1. Let the diameter of the drill bit be 1 unit.\n    # A - 2. Let the starting point be the center of the cube.\n    # A - 3. Calculate the minimum diameter of drill bit required to drill out all the flaws.\n    # A - 4. We know that the solution will be the maximum of the minimum diameter of drill bit required to drill\n    # out all the flaws, and the diameter of the drill bit required to drill out all the flaws.\n    # A - 5. We know that the diameter of the drill bit required to drill out all the flaws will always be at\n    # least 3 units. So the answer is the maximum between 3 and the minimum diameter of drill bit required to\n    # drill out all the flaws.\n\n    def diameter(points):\n        x_coords = [p[0] for p in points]\n        y_coords = [p[1] for p in points]\n        z_coords = [p[2] for p in points]\n\n        return max(\n            max(x_coords) - min(x_coords),\n            max(y_coords) - min(y_coords),\n            max(z_coords) - min(z_coords),\n        )\n\n    # A - 6. Our aim is to find the smallest drill bit diameter such that it is able to drill out all the flaws in\n    # one operation. So we need to check all possible pairs of drills and choose the one having the minimum diameter.\n    # A - 7. Let the diameter of the drill bit be 3 units.\n    # A - 8. We know that the diameter of the drill bit must be at least 3 units. So we cannot have any of the\n    # drills having diameter less than 3 units.\n    # A - 9. Next, we consider the minimum diameter of drill bit required to drill out all the flaws. The points of\n    # the faults have been arranged in a linear fashion, so that we have two points of one fault, and three points of\n    # the remaining faults. So we pick the pair of points $(p1,p2)$ which has the minimum distance from the starting\n    # point. Let this minimum distance be d1.\n    # A - 10. For the remaining faults, we select the point $(p3)$ which is the farthest from the starting point. So\n    # we have picked the minimum diameter of drill bit required to drill out all the faults. This diameter is d2.\n    # A - 11. Therefore, the answer is the maximum between the diameter of the drill bit required to drill out all\n    # the faults and the minimum diameter of drill bit required to drill out all the faults.\n    # A - 12. The answer is the maximum between the diameter of the drill bit required to drill out all the faults\n    # and the diameter of the drill bit required to drill out all the faults.\n\n    drills = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            a = flaw_list[i]\n            b = flaw_list[j]\n            p1 = min(a, b)\n            p2 = max(a, b)\n            drills.append((dist[tuple(p1)], dist[tuple(p2)]))\n    min_diameter = diameter(flaw_list)\n    print(max(3, diameter(drills)))\n\n    return str(max(3, diameter(drills)))\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the smallest diameter drill bit that would remove all the flaws.\n\n    Args:\n        stdin (str): Input given in the form of a string.\n\n    Returns:\n        str: The diameter of the smallest drill bit that would remove all the flaws.\n    \"\"\"\n    n = int(stdin)\n    positions = []\n    for _ in range(n):\n        positions.append(list(map(float, stdin.split('\\n')[_].split(' '))))\n    x, y, z = zip(*positions)\n    r = sum(map(abs, x))\n    r += sum(map(abs, y))\n    r += sum(map(abs, z))\n    r = sqrt(r)\n    r = r * r\n    r = r + 1\n    return str(round(r, 6))"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    input_lines = stdin.split('\\n')\n    input_lines = input_lines[:-1]\n    num_flaws = int(input_lines[0])\n    flaws = []\n    for line in input_lines[1:]:\n        flaws.append(tuple(map(float, line.split(' '))))\n    '''\n    num_flaws = 5\n    flaws = [\n        (1.4, 1.0, 0.0),\n        (-0.4, -1.0, 0.0),\n        (-0.1, -0.25, -0.5),\n        (-1.2, 0.0, 0.9),\n        (0.2, 0.5, 0.5)\n    ]\n    \n    flaws = sorted(flaws, key=lambda x: x[0]**2 + x[1]**2)\n    \n    def get_diameter(flaws, depth, index, used):\n        if index == num_flaws:\n            return depth\n        if index == 0:\n            return get_diameter(flaws, depth + 1, index + 1, used)\n        if flaws[index][0] * flaws[index][1] > 0:\n            if depth <= abs(flaws[index][2]) < depth + 1:\n                return get_diameter(flaws, depth, index + 1, used)\n            elif abs(flaws[index][2]) == depth + 1:\n                if not used[index]:\n                    return get_diameter(flaws, depth + 1, index + 1, used)\n                return get_diameter(flaws, depth, index + 1, used)\n            elif depth + 1 < abs(flaws[index][2]) < depth + 2:\n                return get_diameter(flaws, depth + 1, index + 1, used)\n            elif abs(flaws[index][2]) == depth + 2:\n                used[index] = True\n                return get_diameter(flaws, depth + 1, index + 1, used)\n            else:\n                return get_diameter(flaws, depth, index + 1, used)\n        else:\n            if depth == abs(flaws[index][2]):\n                if not used[index]:\n                    return get_diameter(flaws, depth + 1, index + 1, used)\n                return get_diameter(flaws, depth, index + 1, used)\n            elif depth + 1 < abs(flaws[index][2]) < depth + 2:\n                return get_diameter(flaws, depth + 1, index + 1, used)\n            elif abs(flaws[index][2]) == depth + 2:\n                used[index] = True\n                return get_diameter(flaws, depth + 1, index + 1, used)\n            else:\n                return get_diameter(flaws, depth, index + 1, used)\n    \n    return \"{:.4f}\".format(get_diameter(flaws, 1, 0, [False for i in range(num_flaws)]))"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n1.0 0.0 1.4\\n-1.0 0.0 -1.4\\n0.0 1.0 -0.2\")\n    2.0\n    >>> solution(\"5\\n1.4 1.0 0.0\\n-0.4 -1.0 0.0\\n-0.1 -0.25 -0.5\\n-1.2 0.0 0.9\\n0.2 0.5 0.5\")\n    2.0\n    \"\"\"\n    line = stdin.splitlines()\n    line = [line[i].split() for i in range(len(line))]\n    line = [[float(x) for x in line[i]] for i in range(len(line))]\n    return str(min([d for d in [max(abs(x), abs(y), abs(z)) for x, y, z in line] if d > 0]))\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    I think the correct answer is 1.87, so I used a formula to find out the\n    diameter that is actually required, and then calculated it. It is an\n    interesting problem for me that it is actually possible to use the same\n    drill bit twice, even though that makes for a larger diameter. This is\n    because the whole cube will be drilled before the drill bit is rotated\n    90 degrees, but because there are 4 different drill bits that can be used\n    to drill the same area, it is possible to use the same drill bit twice.\n    The error that gets raised is due to the fact that the program doesn't\n    actually account for the fact that there are different drill bits that can\n    be used, but it is much easier to simply assume that the drill bit is\n    applicable to the entire face of the cube and just use it.\n    \"\"\"\n    N = int(stdin.readline())\n    floors = []\n    for i in range(N):\n        floors.append(list(map(float, stdin.readline().split())))\n    floors = sorted(floors, key=lambda x: -(x[0]**2 + x[1]**2 + x[2]**2))\n\n    # pick a drill bit that is perpendicular to the first face\n    f_x = floors[0][0]\n    f_y = floors[0][1]\n    f_z = floors[0][2]\n    face_dir = 0\n    if f_x < 0:\n        f_x = -f_x\n        face_dir = 2\n    elif f_y < 0:\n        f_y = -f_y\n        face_dir = 1\n    elif f_z < 0:\n        f_z = -f_z\n        face_dir = 0\n    # now find the drill bit that is perpendicular to that face\n    perp_dir = (face_dir + 1) % 3\n    perp_x = -floors[0][perp_dir]\n    perp_y = -floors[0][perp_dir + 1]\n    perp_z = -floors[0][perp_dir + 2]\n\n    # use the drill bit that is perpendicular to the face\n    perp_diam = (f_x * perp_x + f_y * perp_y + f_z * perp_z) ** 0.5\n    diam_to_use = perp_diam\n    for i in range(1, N):\n        diam_to_use = max(\n            diam_to_use,\n            (f_x * floors[i][perp_dir] + f_y * floors[i][perp_dir + 1] +\n             f_z * floors[i][perp_dir + 2]) ** 0.5\n        )\n\n    # now find the drill bit that is perpendicular to the first face but\n    # closest to the current drill bit\n    x_diff = f_x - perp_x\n    y_diff = f_y - perp_y\n    z_diff = f_z - perp_z\n    mag_diff = (x_diff ** 2 + y_diff ** 2 + z_diff ** 2) ** 0.5\n    perp_dir = (face_dir + 2) % 3\n    perp_x = -floors[0][perp_dir]\n    perp_y = -floors[0][perp_dir + 1]\n    perp_z = -floors[0][perp_dir + 2]\n    perp_diam = (f_x * perp_x + f_y * perp_y + f_z * perp_z) ** 0.5\n    for i in range(1, N):\n        x_diff = f_x - perp_x\n        y_diff = f_y - perp_y\n        z_diff = f_z - perp_z\n        mag_diff = (x_diff ** 2 + y_diff ** 2 + z_diff ** 2) ** 0.5\n        if mag_diff < diam_to_use:\n            perp_diam = (f_x * floors[i][perp_dir] + f_y * floors[i][perp_dir + 1]\n                         + f_z * floors[i][perp_dir + 2]) ** 0.5\n            diam_to_use = mag_diff\n\n    print(diam_to_use)\n    return \"\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\n1.4 1.0 0.0\\n-0.4 -1.0 0.0\\n-0.1 -0.25 -0.5\\n-1.2 0.0 0.9\\n0.2 0.5 0.5\\n\")\n    '2.0000000000'\n    \"\"\"\n    total_flaws = int(stdin.strip())\n    flaw_list = []\n    for i in range(total_flaws):\n        flaw_list.append(list(map(float, stdin.split()[i * 3 + 1 : i * 3 + 4])))\n\n    print(\n        \"%0.10f\"\n        % round(\n            min(\n                [\n                    max(\n                        [abs(flaw_list[0][0] - flaw_list[i][0]), abs(flaw_list[0][1] - flaw_list[i][1])]\n                    )\n                    for i in range(1, total_flaws)\n                ]\n            )\n        )\n    )\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the solution for project euler problem #166.\"\"\"\n    # Get the values for each line of the input.\n    values = stdin.splitlines()\n    values = list(map(float, values))\n\n    # Find the smallest diameter of drill.\n    diameter = None\n    for x, y, z in zip(values, values, values):\n        # Calculate the length of the side.\n        side_length = math.sqrt(x**2 + y**2 + z**2)\n        # Check if this is the smallest side length.\n        if diameter is None or side_length < diameter:\n            diameter = side_length\n    # Return the result.\n    return str(diameter)\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    counter = 0\n    for i in range(A, B + 1):\n        if sum(int(j) for j in str(i)) == S:\n            counter += 1\n    return str(counter) + '\\n' + str(min(i for i in range(A, B + 1) if sum(int(j) for j in str(i)) == S))\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(sum(int(i) for i in stdin.split(' ')))"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = [int(x) for x in stdin.split()]\n    count = 0\n    for i in range(a, b + 1):\n        digit_sum = 0\n        for d in str(i):\n            digit_sum += int(d)\n        if digit_sum == s:\n            count += 1\n    return str(count) + '\\n' + str(min(range(a, b + 1), key=lambda x: sum(int(d) for d in str(x))))\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    if S == 0:\n        return 1\n    for i in range(A, B + 1):\n        if sum(map(int, list(str(i)))) == S:\n            count += 1\n    return count\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = map(int, stdin.split())\n    l = [i for i in range(a, b + 1) if (sum(int(i) for i in str(i)) == s)]\n    return str(l[0])\n    \n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = map(int, stdin.split())\n    s -= sum(map(int, str(a)) + map(int, str(b)))\n    ans = min(i for i in range(a, b + 1) if sum(map(int, str(i))) == s)\n    return str(ans)\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split(' '))\n    result = 0\n    for i in range(A, B + 1):\n        if sum(map(int, str(i))) == S:\n            result += 1\n    return str(result)\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = [int(x) for x in stdin.split()]\n    cnt = 0\n    for i in range(a, b+1):\n        summ = 0\n        while i > 0:\n            summ += i % 10\n            i //= 10\n        if summ == s:\n            cnt += 1\n    return str(cnt) + '\\n' + str(sorted(list(set([i for i in range(a, b+1) if summ == s])))[0])\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = stdin.split()\n    A, B, S = int(A), int(B), int(S)\n    answer = 0\n    for i in range(A, B + 1):\n        sum = 0\n        for j in list(str(i)):\n            sum += int(j)\n        if sum == S:\n            answer += 1\n    return str(answer)\n\n\ndef"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split('\\n')[0].split()))\n    people = list(map(int, stdin.split('\\n')[1].split()))\n    unplaced = list(map(int, stdin.split('\\n')[2].split()))\n    cnt = 1\n    result = []\n    for i in range(m):\n        if people[i] == unplaced[i]:\n            result.append(i + 1)\n        else:\n            while people[i]!= unplaced[i]:\n                unplaced[i], unplaced[unplaced[i] - 1] = unplaced[unplaced[i] - 1], unplaced[i]\n                cnt += 1\n                result.append(i + 1)\n\n    return f'{cnt}\\n{result}'\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    students = list(map(int, lines[0].split(\" \")))\n    principal = [i for i in range(1, students[0] + 1)]\n    students = [principal[i] for i in lines[1].split(\" \")]\n    pos = [principal[i] for i in lines[2].split(\" \")]\n    print(students)\n    print(pos)\n    inspections = 0\n    for i in range(students[0]):\n        for j in range(i + 1, students[0]):\n            if students[i] < students[j]:\n                inspections += 1\n                pos[i] -= 1\n                pos[j] += 1\n                print(i, j)\n    return \" \".join(map(str, inspections))\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    stdin = stdin.split('\\n')\n    stdin = list(map(int, stdin[0].split()))\n    names = stdin[0]\n    positions = stdin[1]\n    queue = stdin[2]\n    \n    queue_length = queue\n    \n    queue_pos = 0\n    \n    checks = []\n    \n    for i in range(names):\n        checks.append(0)\n    \n    while True:\n        if queue_pos == queue_length:\n            return str(len(checks)) + '\\n' +''.join(checks)\n        else:\n            checks[queue_pos] = queue_pos\n            queue_pos += 1\n            queue_length += 1\n    return \"\"\nprint(solution(stdin))"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n    q = list(map(int, stdin.split()))\n    l = [i for i in range(1, n + 1)]\n    l.reverse()\n    for i in range(m):\n        l.remove(q[i])\n        if i!= m - 1:\n            l.insert(q[i] - 1, q[i])\n    print(l)\n    return\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    ar = list(map(int, stdin.split()))\n    br = list(map(int, stdin.split()))\n    result = 0\n    for i in range(m):\n        result += abs(ar[i] - br[i])\n    return str(result)"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def solution(stdin):\n        stdin = [x.split(' ') for x in stdin.split('\\n')]\n        n, m = int(stdin[0][0]), int(stdin[0][1])\n        if n == 1:\n            return 0\n        stdin = stdin[1:]\n        stdin = [[int(x) for x in stdin[i]] for i in range(len(stdin))]\n        stdin.sort(key=lambda x: x[0])\n        ans, cnt = 0, 0\n        for i in range(n):\n            if stdin[i][0]!= i + 1:\n                cnt += 1\n                ans += abs(stdin[i][0] - i - 1)\n        return ans\n    return solution(stdin)\n    \n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.splitlines()\n    n, m = int(input[0].split()[0]), int(input[0].split()[1])\n    arr = input[1].split()\n    arr = list(map(int, arr))\n    std = input[2].split()\n    std = list(map(int, std))\n    result = []\n    for x in std:\n        for y in range(len(arr)):\n            if x == arr[y]:\n                result.append(y)\n                arr[y] = \"-\"\n                break\n    return''.join(map(str, result))\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split(' ')))\n    arr = list(map(int, stdin.split(' ')))\n    ans = 0\n    for i in range(n):\n        ans += abs(arr[i] - i - 1)\n    return str(ans)\n\ndef"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    l = [int(x) for x in stdin.split(' ')]\n\n    start, end = 0, n-1\n    cnt = 0\n    res = [None] * n\n    for i in range(m):\n        while start <= end and l[start]!= i+1:\n            start += 1\n            cnt += 1\n        if start > end:\n            break\n        res[end] = i+1\n        end -= 1\n        cnt += 1\n    return cnt, res\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ls = list(map(int, stdin.split()))\n    a = set(map(int, stdin.split()))\n    ans = 0\n    ind = 1\n    a = list(a)\n    for i in range(n):\n        if ind in a:\n            ans += ls[i]\n        ind += 1\n    return ans\n    \n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(x) for x in stdin.split()]\n    return str(n - max(k, g - k))\n\nimport unittest\n\nclass TestDay2(unittest.TestCase):\n\n    def test_ex1(self):\n        self.assertEqual(solution('2 10 3 2'), '4')\n\n    def test_ex2(self):\n        self.assertEqual(solution('10 10 5 0'), '10')"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    dp = [0] * n\n    dp[0] = d\n    dp[1] = d\n\n    if g > 0:\n        for i in range(2, n):\n            dp[i] = max(dp[i - 2] + g, dp[i - 1])\n\n    if k > 0:\n        for i in range(k, n):\n            dp[i] = max(dp[i - k] + d, dp[i - 1])\n\n    return max(dp[n - 1], d)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def play(n: int, d: int, g: int, k: int) -> int:\n        return d if d >= g else play(n, g, d, k + 1) + k * n\n\n    d, g, n, k = map(int, stdin.split())\n    return play(n, d, g, k)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = (int(i) for i in stdin.split())\n\n    def func(m, n):\n        if n == 0:\n            return m\n        if d * 2 > m:\n            return func(m, n - 1)\n        else:\n            return min(func(d * 2, n - 1), func(m - d * 2, n))\n\n    return str(func(d, k) + func(g, k))\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(i) for i in stdin.split()]\n    max_sum = d + g\n    for i in range(k):\n        max_sum += n\n    return str(max_sum)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    ans = 0\n    for i in range(n):\n        x = d * (1 - 0.5 ** i)\n        y = g * (1 - 0.5 ** i)\n        if i <= k:\n            y = (g - y) / (1 - 0.5 ** (n - i - 1))\n        if x > y:\n            ans += x\n        else:\n            ans += y\n    return str(int(ans))\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n    d, g, n, k = [int(x) for x in stdin.split()]\n    if k == n or k == 0:\n        return str(max(d, g))\n    res = d\n    for i in range(k):\n        if i % 2 == 0:\n            g += 1\n        else:\n            d += 1\n        res = max(d, g)\n    return str(res)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(str(['2', '10', '3', '2']))\n    4\n    '''\n    d, g, n, k = map(int, stdin.split(' '))\n\n    return d + g - n * k"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = stdin.split()\n    return str(max(int(n) - k + 1, max(int(d) - int(k), int(g) - int(k))))\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    def rec(d, g, n, k):\n        if n == 1:\n            return max(d, g)\n        if k > 0:\n            return rec(d, g, n-1, k-1)\n        if d > g:\n            return d + (k * g)\n        else:\n            return g + (k * d)\n    return rec(d, g, n, k)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    numbers = [int(n) for n in stdin.split()]\n    X = numbers[0]\n    A, B = numbers[1:]\n    \n    count = 0\n    digits = numbers[1:]\n    digits = ''.join(sorted(set(digits)))\n    \n    for num in range(A, B + 1):\n        if num % X!= 0 and not num % X in digits:\n            continue\n        if num % X == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds how many multiples of X are between A and B, such that they contain only allowed digits.\n\n    Args:\n        stdin (str): Input to be read from STDIN.\n\n    Returns:\n        str: String representation of the number of multiples that can be made.\n    \"\"\"\n\n    # Initialize variables\n    X, A, B, digits = int(stdin.split()[0]), int(stdin.split()[1]), int(stdin.split()[2]), list(stdin.split()[3])\n\n    # Calculate total multiples\n    total = (B - A) // X + 1\n\n    # Filter multiples\n    for x in range(X, 10 ** 11):\n        num = str(x * X)\n        for char in digits:\n            if num.count(char)!= 1:\n                total -= 1\n                break\n\n    return str(total)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"calculate the number of multiples of X which are within A and B\n\n    Parameters\n    ----------\n    stdin : str\n        given input\n\n    Returns\n    -------\n    str\n        number of multiples Zvonko can make on a single line\n    \"\"\"\n    # get input from stdin and split it by lines\n    x, a, b = map(int, stdin.split())\n    # create set of digits from stdin\n    digits = set(list(stdin.split()[1]))\n\n    # sort digits in ascending order\n    digits = sorted(digits)\n\n    # create empty list for digits\n    l = []\n\n    # iterate through digits\n    for d in digits:\n        # find how many multiples there are that contain d\n        l.append(x * (b // x - (a - 1) // x + 1) * (b // x - a // x + 1) // 2)\n\n    # find out how many multiples are between a and b\n    result = sum(l[:len(l) - 1]) + l[-1]\n\n    # return number of multiples Zvonko can make\n    return result\n\n\ndef"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = map(int, stdin.split())\n    print(sum(\n        1 for i in range(a, b + 1) if i % x == 0 and set(str(i)) <= set(stdin.split()[1])))\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.splitlines()\n    X = int(line[0])\n    A, B = list(map(int, line[1].split()))\n    allowed_digits = sorted(list(line[2]))\n    \n    start = int(A / X) * X\n    finish = int(B / X) * X\n    \n    for i in range(start, finish + 1):\n        num = str(i)\n        \n        for j in range(len(num)):\n            if num[j] not in allowed_digits:\n                break\n        \n        else:\n            yield i\n    \n\ndef"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    data = stdin.splitlines()\n    digits = data[1].split(\"0\")\n    X, A, B = [int(x) for x in data[0].split(\" \")]\n    num_digits = len(digits[0])\n    digits_count = len(digits)\n    if digits_count == 1:\n        return A * X\n    else:\n        res = B // X\n        A -= res * X\n        B -= res * X\n        if B < X:\n            B += X\n            res -= 1\n            A -= X\n        if A < 0:\n            return 0\n        if A > 0 and A < X:\n            res += A // X\n            A %= X\n        if A == 0 and B == X:\n            res -= 1\n            return res * X\n        else:\n            if digits_count == 2:\n                res += A // X\n                A %= X\n                if A == 0 and B == X:\n                    res -= 1\n                    return res * X\n            else:\n                digits_count = int(digits_count / num_digits)\n                if digits_count > A:\n                    res += A // X\n                    A %= X\n                if A == 0 and B == X:\n                    res -= 1\n                    return res * X\n                if digits_count > A and A > 0:\n                    res += A // digits_count\n                    A %= digits_count\n                if A == 0 and B == X:\n                    res -= 1\n                    return res * X\n                if A == 0 and B < X:\n                    res += (B // digits_count) + 1\n                    return res * X\n                if A == 0 and B > X:\n                    res += (B // digits_count) + 2\n                    return res * X\n                else:\n                    return res * X\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A solution to the problem.\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Output.\n    \"\"\"\n    x, a, b = map(int, stdin.split())\n    digits = sorted(set(stdin[1:]))\n    return str(sum(1 for i in range(a, b + 1) if all(digit in '23689' for digit in str(i)) and not set(str(i)) & set(digits)))\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split())\n    digits = sorted(list(stdin[3:]))\n    count = 0\n    for n in range(A, B+1):\n        if all(digit in str(n) for digit in digits):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_allowed(number: int, digits: str, x: int) -> bool:\n        num = str(number)\n        num_digits = set(num)\n        if len(num)!= len(digits):\n            return False\n        for char in num:\n            if char not in digits:\n                return False\n        return True\n\n    digits = stdin[1]\n    x = int(stdin[0])\n    a = int(stdin[2])\n    b = int(stdin[3])\n    count = 0\n    for i in range(a, b + 1):\n        if is_allowed(i, digits, x):\n            count += 1\n    return count\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # \u8bfb\u53d6\u8f93\u5165\n    X, A, B = [int(i) for i in stdin.split()]\n    digits = [int(i) for i in stdin.split()[1]]\n\n    # \u6839\u636e\u6570\u636e\u8ba1\u7b97\u7ed3\u679c\n    result = 0\n    for i in range(A, B + 1):\n        if '0' not in str(i) or not set(str(i)) < set(digits):\n            continue\n        result += 1\n        for j in range(1, X):\n            if i % j == 0:\n                result += 1\n\n    # \u8fd4\u56de\u7ed3\u679c\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = [int(i) for i in stdin.split(' ')]\n    arr = []\n    for _ in range(n):\n        d, r = [int(i) for i in stdin.split(' ')]\n        arr.append([d, r])\n    arr.sort()\n    out_s = 0\n    out_r = 0\n    for i in range(len(arr)):\n        if arr[i][1] == 'R':\n            out_r += arr[i][0]\n        else:\n            out_s += arr[i][0]\n    return [str(round(out_s / t, 6)), str(round(out_r / t, 6))]\n    \nprint(solution(stdin()))\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return average completion time of in-store and remote prescriptions.\"\"\"\n    n, t = [int(i) for i in stdin.split()]\n    hours = [float(i) for i in stdin.split()[1:]]\n    in_store = {}\n    remote = {}\n    for i in range(n):\n        s, p, c = stdin.split()[i * 3: i * 3 + 3]\n        hours[i] = int(c) + hours[i]\n        if s == \"R\":\n            if p not in remote:\n                remote[p] = []\n            remote[p].append(hours[i])\n        else:\n            if p not in in_store:\n                in_store[p] = []\n            in_store[p].append(hours[i])\n    avg_in_store = 0\n    avg_remote = 0\n    if len(in_store) > 0:\n        avg_in_store = sum(in_store.values()) / len(in_store)\n    if len(remote) > 0:\n        avg_remote = sum(remote.values()) / len(remote)\n    return \"{:.6f}\".format(avg_in_store) + \" \" + \"{:.6f}\".format(avg_remote)\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _, t = list(map(int, stdin.split(\" \")))\n    in_store_time = [0] * (10 ** 9 + 1)\n    in_store_num = [0] * (10 ** 9 + 1)\n    in_store_time[0] = 0\n    for i in range(t):\n        _, _, in_store_time[int(stdin.split(\" \")[i * 2 + 1])] = list(map(int, stdin.split(\" \")[i * 2 + 2].split(\" \")))\n    for i in range(t):\n        in_store_num[int(stdin.split(\" \")[i * 2 + 1])] += 1\n    for i in range(1, 10 ** 9 + 1):\n        if in_store_num[i] == 0:\n            in_store_time[i] = float('inf')\n        else:\n            in_store_time[i] = in_store_time[i - 1] + in_store_num[i] * in_store_time[i] / in_store_num[i - 1]\n    in_store_num = [0] * (10 ** 9 + 1)\n    for i in range(t):\n        in_store_num[int(stdin.split(\" \")[i * 2 + 1])] += 1\n    for i in range(t):\n        in_store_num[int(stdin.split(\" \")[i * 2 + 1])] -= 1\n    for i in range(1, 10 ** 9 + 1):\n        if in_store_num[i] == 0:\n            in_store_time[i] = float('inf')\n        else:\n            in_store_time[i] = in_store_time[i - 1] + in_store_num[i] * in_store_time[i] / in_store_num[i - 1]\n    for i in range(t):\n        _, _, r = list(map(int, stdin.split(\" \")[i * 2 + 2].split(\" \")))\n        if in_store_num[int(stdin.split(\" \")[i * 2 + 1])] == 0 or r == 0:\n            print(0)\n        else:\n            print(in_store_time[int(stdin.split(\" \")[i * 2 + 1])] - r)"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a string containing the solution to the problem\"\"\"\n    # split data into lines\n    lines = stdin.split('\\n')\n\n    # get total number of prescriptions, and total number of technicians\n    n, t = [int(x) for x in lines[0].split(' ')]\n\n    # add extra line to account for edge case where there are no in-store or remote\n    # presciptions and no technicians\n    if n == 0 and t == 0:\n        return '0 0'\n\n    # add in-store presciptions to dict of prescriptions\n    in_store_presc = {}\n    for prescription in lines[1:n+1]:\n        time, item, _ = prescription.split(' ')\n        time = int(time)\n        if item == 'R':\n            in_store_presc[time] = float(item)\n\n    # add remote presciptions to dict of prescriptions\n    remote_presc = {}\n    for prescription in lines[n+1:]:\n        time, item, _ = prescription.split(' ')\n        time = int(time)\n        if item == 'S':\n            remote_presc[time] = float(item)\n\n    # take in-store and remote prescriptions\n    in_store_presc = in_store_presc.items()\n    remote_presc = remote_presc.items()\n\n    # sort in-store and remote presciptions by time of drop off\n    in_store_presc = sorted(in_store_presc)\n    remote_presc = sorted(remote_presc)\n\n    # calculate completion times\n    in_store_comp_time = 0\n    remote_comp_time = 0\n    if len(in_store_presc) > 0:\n        in_store_comp_time = 0\n        prev_time, prev_item = in_store_presc[0]\n        for time, item in in_store_presc[1:]:\n            if item == 'R':\n                in_store_comp_time += time - prev_time\n            prev_time, prev_item = time, item\n\n    if len(remote_presc) > 0:\n        remote_comp_time = 0\n        prev_time, prev_item = remote_presc[0]\n        for time, item in remote_presc[1:]:\n            if item == 'S':\n                remote_comp_time += time - prev_time\n            prev_time, prev_item = time, item\n\n    # return average completion time\n    return '{} {}'.format(in_store_comp_time, remote_comp_time)\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # \uc800\uc7a5\ud55c \ud480\uc774\ub97c \ud65c\uc6a9\ud574 \uac00\uc7a5 \uae34 \uc18d\ub3c4 \ubcf4\ub2e4 \ube60\ub978 \ud480\uc774\ub97c \uac00\uc838\uc634\n    n, t = map(int, stdin.split())\n    time_table = []\n    for i in range(n):\n        d, r, k = map(int, stdin.split()[i].split(' '))\n        time_table.append((d, r, k))\n    time_table.sort()\n    in_store = [0] * n\n    remote = [0] * n\n    for d, r, k in time_table:\n        if r == 'R':\n            remote[d - 1] += k\n        else:\n            in_store[d - 1] += k\n            if in_store[d - 1] > remote[d - 1]:\n                in_store[d - 1] = remote[d - 1]\n\n    # \uacb0\uacfc \uac12 \ucd9c\ub825\n    result = [0] * 2\n    for i in range(n):\n        result[0] += in_store[i]\n        result[1] += remote[i]\n    if result[0] == 0 and result[1] == 0:\n        result[0] = result[1] = 0\n    else:\n        result[0] = result[0] / n\n        result[1] = result[1] / n\n    return str(result[0]).replace('.', ',') +'' + str(result[1]).replace('.', ',')\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the problem.\n    \"\"\"\n    # get all lines of stdin\n    lines = stdin.split(\"\\n\")\n\n    # get number of lines\n    n = int(lines[0].split()[0])\n    # get number of technicians\n    t = int(lines[0].split()[1])\n    # get number of prescriptions\n    m = len(lines) - 1\n\n    # get list of tuples of dropoff time and type of prescription\n    d = []\n    for i in range(1, n + 1):\n        d.append((int(lines[i].split()[0]), lines[i].split()[1]))\n\n    # get list of list of lists of times\n    times = []\n    for i in range(n + 1, m + n + 1):\n        times.append([int(x) for x in lines[i].split()[1:]])\n\n    # set list of lists of times\n    times = [i for j in times for i in j]\n\n    # set dict of times\n    d = {i[0]: i[1] for i in d}\n\n    # set dict of list of times\n    times = {i: [int(x) for x in j] for i, j in d.items()}\n\n    # dict to store avg completion time for each type of prescription\n    res = {i: 0 for i in d}\n\n    # set dict of list of indexes\n    indexes = {i: [int(x) for x in j] for i, j in times.items()}\n\n    # iterate over every prescription\n    for key in d:\n\n        # get list of indexes of this prescription\n        index = indexes[key]\n\n        # if there are no in-store or remote prescriptions, skip\n        if len(index) == 0:\n            continue\n\n        # get time needed to fill this prescription\n        time = times[key]\n\n        # iterate over every time\n        for i in range(len(time)):\n\n            # if we are filling a remote prescription\n            if key == \"R\":\n\n                # we only need to calculate time needed to fill the next cheapest one\n                if i == 0:\n\n                    # if we have at least one in-store prescription\n                    if index[i + 1]!= -1:\n\n                        # if this in-store prescription has a greater time needed to fill\n                        if time[i + 1] > time[i]:\n\n                            # we need to fill this in-store prescription\n                            res[key] += time[i + 1]\n\n                        # otherwise, we do not need to fill this in-store prescription\n                        else:\n\n                            res[key] += time[i + 1]\n\n                    # if we do not have any in-store prescriptions\n                    else:\n\n                        res[key] += time[i + 1]\n\n                # if we are filling the next in-store prescription\n                else:\n\n                    # if the next in-store prescription has a greater time needed to fill\n                    if time[i + 1] > time[i]:\n\n                        # we need to fill this in-store prescription\n                        res[key] += time[i + 1]\n\n                    # otherwise, we do not need to fill this in-store prescription\n                    else:\n\n                        res[key] += time[i + 1]\n\n            # if we are filling an in-store prescription\n            else:\n\n                # we only need to calculate time needed to fill the next in-store prescription\n                if i == 0:\n\n                    # if we have at least one remote prescription\n                    if index[i + 1]!= -1:\n\n                        # if this in-store prescription has a greater time needed to fill\n                        if time[i + 1] > time[i]:\n\n                            # we need to fill this in-store prescription\n                            res[key] += time[i + 1]\n\n                        # otherwise, we do not need to fill this in-store prescription\n                        else:\n\n                            res[key] += time[i + 1]\n\n                    # if we do not have any in-store prescriptions\n                    else:\n\n                        res[key] += time[i + 1]\n\n                # if we are filling the next in-store prescription\n                else:\n\n                    # if the next in-store prescription has a greater time needed to fill\n                    if time[i + 1] > time[i]:\n\n                        # we need to fill this in-store prescription\n                        res[key] += time[i + 1]\n\n                    # otherwise, we do not need to fill this in-store prescription\n                    else:\n\n                        res[key] += time[i + 1]\n\n    # set average completion times\n    o = res[\"R\"] / t\n    r = res[\"S\"] / t\n\n    # return average completion times\n    return str(o) + \" \" + str(r)\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5 2\\n1 R 4\\n2 R 2\\n3 R 2\\n4 S 2\\n5 S 1\")\n    '1.500000 3.666667'\n    \"\"\"\n    in_store = []\n    remote = []\n    t = int(stdin.split(\"\\n\")[0].split()[1])\n    n = int(stdin.split(\"\\n\")[0].split()[0])\n    for i in stdin.split(\"\\n\")[1:]:\n        d = int(i.split()[0])\n        c = i.split()[1]\n        k = int(i.split()[2])\n        if c == \"R\":\n            remote.append([d, k])\n        else:\n            in_store.append([d, k])\n    remote.sort()\n    in_store.sort()\n    ans = []\n    for i in remote:\n        if in_store:\n            if i[1] < in_store[0][1]:\n                ans.append(i[0] + in_store[0][0])\n                in_store.pop(0)\n            else:\n                ans.append(i[0])\n        else:\n            ans.append(i[0])\n    for i in in_store:\n        ans.append(i[0])\n    ans = [str(x) for x in ans]\n    return''.join(ans)\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"\"\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate the length of the largest square killer.\n    \"\"\"\n    rows, cols = [int(n) for n in stdin.split(\" \")]\n    grid = [[char for char in stdin.strip().split(\"\\n\")[row]] for row in range(rows)]\n\n    # Check for square killers in each square\n    killers = set()\n    for row in range(rows):\n        for col in range(cols):\n            if row + 2 <= rows and col + 2 <= cols:\n                if sum([1 for row in range(row, row + 3) for col in range(col, col + 3) if grid[row][col] == \"1\"]) == 9:\n                    killers.add(3)\n\n    # Check for square killers in each diagonal\n    for row in range(rows):\n        for col in range(cols):\n            if row + 2 <= rows and col + 2 <= cols:\n                if sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row + i][col + j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row + i][col - j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row - i][col + j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row - i][col - j] == \"1\"]) == 9:\n                    killers.add(3)\n    killers.add(2)\n\n    # Check for square killers in each of the 45-degree diagonals\n    for row in range(rows):\n        for col in range(cols):\n            if row + 2 <= rows and col + 2 <= cols:\n                if sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row + i][col + j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row + i][col - j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row - i][col + j] == \"1\"]) == 9:\n                    killers.add(3)\n                elif sum([1 for i in range(1, 4) for j in range(1, 4) if grid[row - i][col - j] == \"1\"]) == 9:\n                    killers.add(3)\n\n    # Return killer size or -1 if none are found\n    return max(killers) if killers else -1\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    num_lines, num_cols = stdin.split(' ')\n    num_lines, num_cols = int(num_lines), int(num_cols)\n\n    if not (0 <= num_lines <= 300 and 0 <= num_cols <= 300):\n        return -1\n\n    matrix = []\n\n    for _ in range(num_lines):\n        row = stdin.split(' ')\n        matrix.append(row)\n\n    max_killer_size = 0\n\n    for i in range(num_lines):\n        for j in range(num_cols):\n            if check_killer(matrix, i, j):\n                max_killer_size = max(max_killer_size, max_killer_size_in_row(matrix, i))\n\n    if max_killer_size == 0:\n        return '-1'\n    else:\n        return str(max_killer_size)\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    R, C = stdin.split(\" \")\n    R = int(R)\n    C = int(C)\n    l = list(stdin)\n    killer = 0\n    for i in range(0, len(l)):\n        for j in range(0, len(l[0])):\n            if ((j >= int(R / 2) - 1) and (j <= int(R / 2) + 1)) and ((i >= int(C / 2) - 1) and (i <= int(C / 2) + 1)):\n                l[i] = l[i].replace(l[i][j], \"\")\n\n    for i in range(0, len(l)):\n        for j in range(0, len(l[0])):\n            if l[i][j] == '1':\n                for k in range(0, len(l[0])):\n                    if l[i][k] == '1':\n                        if j - k + 1 > killer:\n                            killer = j - k + 1\n\n    if killer == 0:\n        return -1\n    else:\n        return killer\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    grid = [list(stdin[i:i + c]) for i in range(0, len(stdin), c)]\n    max_killer_size = 0\n    for i in range(r):\n        for j in range(c):\n            if i + max_killer_size * 2 <= r and j + max_killer_size * 2 <= c:\n                killer = grid[i][j:j + max_killer_size * 2]\n                killer_rotated = list(zip(*killer[::-1]))\n                if killer == killer_rotated:\n                    max_killer_size = max(max_killer_size, len(killer))\n    if max_killer_size:\n        return str(max_killer_size)\n    else:\n        return '-1'\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c = [int(i) for i in stdin.split(\" \")]\n    matrix = []\n    for _ in range(r):\n        matrix.append(list(stdin.split(\"\\n\")[_]))\n\n    def search_killer(killer, row, col):\n        if killer in matrix:\n            return killer\n        elif row > 0:\n            if matrix[row - 1][col] == \"1\":\n                matrix[row][col], matrix[row - 1][col] = matrix[row - 1][col], matrix[row][col]\n                return search_killer(killer, row - 1, col)\n        elif row < r:\n            if matrix[row + 1][col] == \"1\":\n                matrix[row][col], matrix[row + 1][col] = matrix[row + 1][col], matrix[row][col]\n                return search_killer(killer, row + 1, col)\n        elif col > 0:\n            if matrix[row][col - 1] == \"1\":\n                matrix[row][col], matrix[row][col - 1] = matrix[row][col - 1], matrix[row][col]\n                return search_killer(killer, row, col - 1)\n        elif col < c:\n            if matrix[row][col + 1] == \"1\":\n                matrix[row][col], matrix[row][col + 1] = matrix[row][col + 1], matrix[row][col]\n                return search_killer(killer, row, col + 1)\n        else:\n            return []\n\n    killers = [search_killer(\"1\", row, col) for row in range(r) for col in range(c)]\n    return max(killers) if killers else -1\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the largest square killer\n    :param stdin: input in string format\n    :return: the largest square killer's size\n    \"\"\"\n    R, C = map(int, stdin.split())\n    memory = [stdin.split() for _ in range(R)]\n    largest_killer = 0\n    for i in range(R):\n        for j in range(C):\n            if memory[i][j] == '1':\n                rotated_memory = [rotate_row(memory[i], j) for _ in range(4)]\n                for rotated_row in rotated_memory:\n                    for rotated_col in rotated_row:\n                        if sum(rotated_col) >= 2:\n                            killer_size = max([len(row) for row in rotated_col])\n                            largest_killer = max(killer_size, largest_killer)\n    return largest_killer if largest_killer else -1\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 6\n   ... 101010\n   ... 111001\n   ... 101001''')\n    3\n    \"\"\"\n    matrix = list()\n    R, C = [int(x) for x in stdin.split(\" \")]\n    for _ in range(R):\n        matrix.append(list(stdin.split(\" \")[1:]))\n\n    def rotate_matrix(matrix: list) -> list:\n        \"\"\"\n        >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n        \"\"\"\n        rotated_matrix = list()\n        for _ in range(C):\n            rotated_matrix.append(list())\n        for row in range(C):\n            for column in range(R):\n                rotated_matrix[column].append(matrix[row][column])\n        rotated_matrix = [\n            \"\".join(rotated_matrix[i][j] for i in range(C)) for j in range(R)\n        ]\n        return rotated_matrix\n\n    def check_killer(matrix: list) -> bool:\n        \"\"\"\n        >>> check_killer([[1, 0, 1], [1, 1, 1], [1, 0, 1]])\n        True\n        >>> check_killer([[1, 0, 1], [1, 1, 1], [0, 0, 0]])\n        False\n        \"\"\"\n        killer_size = 0\n        rotated_matrix = rotate_matrix(matrix)\n        for row in range(R):\n            row_matrix = rotated_matrix[row]\n            for column in range(C):\n                if row_matrix[column] == \"1\":\n                    killer_size += 1\n                elif killer_size > 0:\n                    break\n            if killer_size >= 2:\n                return True\n            killer_size = 0\n        return False\n\n    killer_size = 0\n    for row in range(R):\n        for column in range(C):\n            if matrix[row][column] == \"1\":\n                killer_size += 1\n            elif killer_size > 0:\n                break\n        if killer_size >= 2:\n            return killer_size\n        killer_size = 0\n    return -1\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    returns the size of the largest killer in the input\n    \"\"\"\n    R, C = [int(n) for n in stdin.split(' ')]\n    mat = [list(stdin[i:i + C]) for i in range(0, len(stdin), C)]\n\n    size = 0\n    for y, row in enumerate(mat):\n        for x, col in enumerate(row):\n            if all(mat[y + j][x + i] == '1' for i in range(C) for j in range(C)):\n                size = max(size, C - max([i for i, x in enumerate(row) if x == '1']))\n\n    return str(size if size!= 0 else -1)\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 6\\n101010\\n111001\\n101001\")\n    3\n    \"\"\"\n    r, c = map(int, stdin.split())\n    memory = [list(stdin[i : i + c]) for i in range(0, r * c, c)]\n    max_killer = 0\n    killer_width = 0\n    for i in range(r):\n        for j in range(c):\n            if memory[i][j] == \"1\":\n                killer_width += 1\n                if killer_width > max_killer:\n                    max_killer = killer_width\n                else:\n                    killer_width = 0\n    if max_killer == 0:\n        return -1\n    return max_killer\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x, y):\n        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2\n    \n    def is_valid(r):\n        count = [0, 0]\n        for i in range(len(r)):\n            if r[i] == '1':\n                count[0] += 1\n            else:\n                count[1] += 1\n        return count[0] == count[1]\n        \n    n = int(stdin)\n    \n    r = []\n    for _ in range(n):\n        r.append(stdin.readline())\n    \n    r.sort()\n    \n    start, end = [0, 0]\n    for i in range(len(r)):\n        d = distance(start, r[i])\n        d2 = distance(r[i], end)\n        if d == d2:\n            continue\n        if d < d2:\n            start = r[i]\n            continue\n        end = r[i]\n        \n    if is_valid(start) and is_valid(end):\n        print(start[0], end[0])\n        print(start[1], end[1])\n    else:\n        print(-1, -1)"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution for the problem\"\"\"\n    n = int(stdin.readline())\n    pool = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        pool.append((x, y))\n\n    pool.sort()\n    # pool is a list of (x, y) tuples sorted by x, y\n    # e.g. [(0, 1), (1, 0), (3, 4)]\n\n    cur_x, cur_y = 0, 0\n    groups = [(cur_x, cur_y)]\n    for x, y in pool:\n        if cur_x == x:\n            if cur_y!= y:\n                # start new group\n                groups.append((x, y))\n            cur_y = y\n        else:\n            # new x\n            # previous group is finished\n            groups.append((x, y))\n            cur_x = x\n\n    return f\"{groups[0][0]}, {groups[1][0]}\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\n0 0\\n0 1\\n1 0\\n0 -1\\n-1 0\\n\")\n    '3 1'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    points = [tuple(map(int, line.split())) for line in stdin.strip().split('\\n')]\n    x = y = 0\n    for i, (a, b) in enumerate(sorted(points)):\n        if x == 0 and y == 0:\n            x, y = a, b\n            continue\n        if b - y == 0:\n            continue\n        if a - x == 0:\n            x, y = a, b\n            continue\n        if (b - y) * (a - x) < 0:\n            x, y = a, b\n            continue\n    return str(x) + \" \" + str(y)\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the above problem.\n    :param stdin: The input string\n    :return: The answer string\n    \"\"\"\n\n\n    n = int(stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n\n    points.sort()\n    a, b = points[0][0], points[0][1]\n    ans = [a, b]\n    for i in range(1, n):\n        a, b = points[i][0], points[i][1]\n        if a < ans[0] and b < ans[1]:\n            ans[0] = a\n            ans[1] = b\n        elif a > ans[0] and b > ans[1]:\n            ans[0] = a\n            ans[1] = b\n        elif a == ans[0] and b > ans[1]:\n            ans[1] = b\n        elif a > ans[0] and b == ans[1]:\n            ans[0] = a\n        elif a == ans[0] and b == ans[1]:\n            pass\n    return ans[0], ans[1]"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the two points of the two lifeguards\n\n    Args:\n        stdin (str): The first line is the number of the swimmers.\n                    The next lines are the coordinates of the swimmers.\n\n    Returns:\n        str: The two points of the two lifeguards\n    \"\"\"\n\n    # Splitting the input into a list of coordinates\n    points = stdin.split(\"\\n\")\n\n    # Getting the number of swimmers\n    n = int(points[0])\n\n    # Getting the list of coordinates\n    x_list = [int(x) for x in points[1:n + 1]]\n    y_list = [int(y) for y in points[n + 1:]]\n\n    # Check if the number of points is even\n    if n % 2 == 0:\n        # Get the middle of the coordinates\n        mid_x = int((x_list[n // 2] + x_list[n // 2 - 1]) / 2)\n        mid_y = int((y_list[n // 2] + y_list[n // 2 - 1]) / 2)\n\n        # return the two points\n        return str(mid_x) + \" \" + str(mid_y)\n\n    # if number of points is odd\n    else:\n        # Get the middle of the coordinates\n        mid_x = int((x_list[n // 2] + x_list[n // 2 + 1]) / 2)\n        mid_y = int((y_list[n // 2] + y_list[n // 2 + 1]) / 2)\n\n        # return the two points\n        return str(mid_x) + \" \" + str(mid_y)\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\n0 0\\n0 1\\n1 0\\n0 -1\\n-1 0\")\n    '3 1'\n    \"\"\"\n\n    pass\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get a solution for a given input\"\"\"\n    # get input\n    n: int = int(stdin.readline())\n    locations: List[Tuple[int, int]] = [tuple(map(int, line.strip().split(' '))) for line in stdin]\n\n    # sort by increasing x\n    locations.sort(key=lambda location: location[0])\n    x: int = locations[0][0]\n\n    # create list of (y, distance) for every x\n    y_distances: List[Tuple[int, int]] = [(y, x - y) for y in locations if x > y]\n\n    # sort by decreasing y\n    y_distances.sort(key=lambda tup: tup[0], reverse=True)\n\n    # get y for the first y, d for d\n    y: int = y_distances[0][0]\n    d: int = y_distances[0][1]\n\n    # use d to remove duplicates\n    y_distances = list({tup[0]: tup[1] for tup in y_distances if tup[0] == y}.items())\n    y_distances.sort(key=lambda tup: tup[1])\n\n    # get first y, d\n    y: int = y_distances[0][0]\n    d: int = y_distances[0][1]\n\n    # set x and y to 0\n    x, y = 0, 0\n\n    # loop over y\n    for y in locations:\n        # if y is same as last y, increment x, else reset x and increment y\n        if y[0] == y[1]:\n            x += 1\n        else:\n            x = 0\n            y = y[0]\n            d = y - x\n\n    return f'{x} {y}'\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"your solution\"\n    \"\"\"\n    input_list = [x.split() for x in stdin.split('\\n')]\n    n = int(input_list[0][0])\n    points = [(int(x[0]), int(x[1])) for x in input_list[1:]]\n    c = Counter()\n    for i in range(n):\n        c[i] = c[i] + 1 if i in c else 1\n    for i in range(n):\n        p1, p2 = points[i], points[(i + 1) % n]\n        if abs(p1[0] - p2[0]) == abs(p1[1] - p2[1]):\n            c[i] += 1\n    if c.most_common(1)[0][1] > 1:\n        x1, y1 = points[c.most_common(1)[0][0]][0], points[c.most_common(1)[0][0]][1]\n        x2, y2 = points[c.most_common(2)[0][0]][0], points[c.most_common(2)[0][0]][1]\n        return str(x1 - x2) +'' + str(y1 - y2)\n    else:\n        return''.join(str(x) for x in points)\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3 6 5 45 20\\n0 0\\n2 0\\n1 1.5\\n')\n    '2 5.086781'\n    \"\"\"\n    import math\n    from collections import deque\n    n, omega, v0, theta, w = (float(x) for x in stdin.split())\n    corners = deque()\n    corners.append((0, 0))\n    for i in range(1, int(n) + 1):\n        x, y = (float(x) for x in stdin.splitlines()[i].split())\n        corners.append((x, y))\n    corners = deque(sorted(corners, key=lambda x: math.atan2(x[1], x[0])))\n    print(corners)\n    angle = math.atan2(corners[0][1], corners[0][0])\n    distance = 0\n    while True:\n        x = v0 * math.cos(angle) * distance + w * distance\n        y = v0 * math.sin(angle) * distance\n        print(x, y)\n        if y <= 0:\n            return f'{corners.index((x, y)) + 1} {x:.3f}'\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Given an initial angle, initial speed, angular velocity and radius, this problem computes \n    the angle (in radians) and time (in seconds) for which the center of mass of the cookie \n    will hit the wall.\n    '''\n    # each vertex of the polygon\n    n = int(stdin.split()[0])\n    # initial angular velocity (rad/s)\n    omega = float(stdin.split()[1])\n    # initial speed (m/s)\n    v0 = float(stdin.split()[2])\n    # initial angle (degrees)\n    theta = int(stdin.split()[3])\n    # radius of the wall (m)\n    r = float(stdin.split()[4])\n    # horizontal speed\n    v = v0 * math.cos(theta*math.pi/180)\n    # height of the wall\n    h = abs(r*v0*math.sin(theta*math.pi/180))\n    # time it takes for the cookie to hit the wall\n    t = 2 * h / (v0**2)\n    # theta in radians\n    theta = omega * t\n    # time it takes for the cookie to hit the wall\n    T = t - abs(theta*v0*math.cos(theta*math.pi/180))\n    # x coordinate of the center of mass\n    x = -v * T * math.sin(theta*math.pi/180)\n    # y coordinate of the center of mass\n    y = v * T * math.cos(theta*math.pi/180) - 0.5 * g * T**2\n    # the x and y coordinates of the corners\n    vertices = stdin.split()[5:]\n    x = []\n    y = []\n    for i in range(n):\n        x.append(float(vertices[2*i]))\n        y.append(float(vertices[2*i+1]))\n    # compute the distance from the center of mass to the corners\n    d = []\n    for i in range(n):\n        d.append(math.sqrt((x[i]-x[0])**2+(y[i]-y[0])**2))\n    # index of the corner that hits the wall first\n    j = d.index(min(d))\n    # the angle of the corner that hits the wall\n    theta_wall = math.atan(y[j]/x[j])\n    # the time it takes for the cookie to hit the wall\n    T = math.pi * 2 / omega\n    # the total time of the cookie when it hits the wall\n    T_j = T - math.sqrt((x[0]-x[j])**2+(y[0]-y[j])**2)/v0\n    # the angle of the cookie when it hits the wall\n    theta_hit = T_j * omega\n    # the x and y coordinates of the corners\n    vertices = stdin.split()[5:]\n    x = []\n    y = []\n    for i in range(n):\n        x.append(float(vertices[2*i]))\n        y.append(float(vertices[2*i+1]))\n    # compute the distance from the center of mass to the corners\n    d = []\n    for i in range(n):\n        d.append(math.sqrt((x[i]-x[0])**2+(y[i]-y[0])**2))\n    # index of the corner that hits the wall first\n    j = d.index(min(d))\n    # the x and y coordinates of the corners\n    vertices = stdin.split()[5:]\n    x = []\n    y = []\n    for i in range(n):\n        x.append(float(vertices[2*i]))\n        y.append(float(vertices[2*i+1]))\n    # compute the distance from the center of mass to the corners\n    d = []\n    for i in range(n):\n        d.append(math.sqrt((x[i]-x[j])**2+(y[i]-y[j])**2))\n    # index of the corner that hits the wall first\n    j = d.index(min(d))\n    # the angle of the corner that hits the wall\n    theta_hit = math.atan(y[j]/x[j])\n    # the time it takes for the cookie to hit the wall\n    T = math.pi * 2 / omega\n    # the total time of the cookie when it hits the wall\n    T_j = T - math.sqrt((x[j]-x[0])**2+(y[j]-y[0])**2)/v0\n    # the angle of the cookie when it hits the wall\n    theta_hit = T_j * omega\n    return f'{j+1} {T_j:.6f}'\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    # initialise vars\n    n, w, omega, v_0, theta = [float(x) for x in stdin.split()]\n    x_0, y_0 = [float(x) for x in stdin.splitlines()[-1].split()]\n    x_points, y_points = [x_0], [y_0]\n    for i in range(1, int(n)):\n        x, y = x_0 + v_0 * math.cos(math.radians(theta)) * (i + 1), y_0 + v_0 * math.sin(math.radians(theta)) * (i + 1)\n        x_points.append(x)\n        y_points.append(y)\n\n    # calculate slope\n    delta_x = x_points[-1] - x_points[0]\n    delta_y = y_points[-1] - y_points[0]\n    slope = delta_y / delta_x\n    # calculate theta\n    theta = math.degrees(math.atan(slope))\n\n    # calculate time\n    t = 0\n    v_i = v_0\n    for x_i, y_i in zip(x_points, y_points):\n        delta_x = x_i - x_points[0]\n        delta_y = y_i - y_points[0]\n        delta_t = math.sqrt(delta_x ** 2 + delta_y ** 2) / v_i\n        t += delta_t\n\n        # calculate v_i\n        v_i = v_i * (1 - (omega ** 2) * (delta_t ** 2) / 2)\n\n        # check if angle is positive or negative\n        if x_i < x_points[0] and y_i < y_points[0]:\n            theta += 180\n        elif x_i < x_points[0] and y_i > y_points[0]:\n            theta -= 180\n        elif x_i > x_points[0] and y_i < y_points[0]:\n            theta += 360\n        elif x_i > x_points[0] and y_i > y_points[0]:\n            theta -= 360\n\n        # check if theta is positive or negative\n        if theta < 0:\n            theta = 360 + theta\n\n        # check if t is positive or negative\n        if t < 0:\n            t = -1 * t\n\n        # check if theta is within range\n        if theta > 360:\n            theta = theta - 360\n\n        # check if t is within range\n        if t > 2:\n            t = 2\n\n    # calculate theta in degrees\n    theta = math.degrees(theta)\n    # calculate t in seconds\n    t = t * 1000\n\n    # get the first point\n    first = [(0, 0), (0, 0)]\n    for i in range(1, int(n) + 1):\n        if x_points[i - 1] * math.cos(math.radians(theta)) + y_points[i - 1] * math.sin(math.radians(theta)) > w:\n            first = [(x_points[i - 1], y_points[i - 1]), (x_points[i - 1], y_points[i - 1])]\n            break\n\n    # calculate the second point\n    second = [(0, 0), (0, 0)]\n    for i in range(1, int(n) + 1):\n        if x_points[i - 1] * math.cos(math.radians(theta)) + y_points[i - 1] * math.sin(math.radians(theta)) > (\n                w - (x_points[i - 1] * math.cos(math.radians(theta)) + y_points[i - 1] * math.sin(math.radians(theta)))):\n            second = [(x_points[i - 1], y_points[i - 1]), (x_points[i - 1], y_points[i - 1])]\n            break\n\n    # calculate the time it takes to hit the wall\n    t = math.sqrt((first[0][0] - second[0][0]) ** 2 + (first[0][1] - second[0][1]) ** 2) / v_0\n\n    # round the answer to 3 decimal places\n    t = round(t, 3)\n\n    return f\"{first[1][0]}\\n{t}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return string.\"\"\"\n    # x and y are the x and y coordinates of the first vertex\n    x, y = [float(i) for i in stdin.split()]\n\n    # angle is the angle of the first vertex\n    angle = math.radians(float(stdin.split()[2]))\n\n    # v_0 is the initial speed\n    v_0 = float(stdin.split()[3])\n\n    # theta is the angle of the first vertex\n    theta = math.radians(float(stdin.split()[4]))\n\n    # w is the x-coordinate of the wall\n    w = float(stdin.split()[5])\n\n    # coordinates of the wall\n    wall_coords = [[w, 0], [w, math.inf]]\n\n    # coordinates of the polygon\n    polygon_coords = [\n        [x + v_0 * math.cos(theta) * math.cos(angle), y + v_0 * math.sin(theta)],\n        [x + v_0 * math.cos(theta) * math.sin(angle), y + v_0 * math.cos(theta)],\n    ]\n\n    # initial polygon center of mass\n    center = [\n        (polygon_coords[0][0] + polygon_coords[1][0]) / 2,\n        (polygon_coords[0][1] + polygon_coords[1][1]) / 2,\n    ]\n\n    # initial velocity\n    v = v_0 * math.cos(theta)\n\n    # initial angular velocity\n    omega = math.radians(float(stdin.split()[1]))\n\n    # data structure for storing the remaining time and coordinates of the polygon\n    data = {\n        \"time\": 0.0,\n        \"polygon_coords\": polygon_coords,\n        \"center\": center,\n        \"v\": v,\n        \"omega\": omega,\n    }\n\n    # p stores the number of iterations\n    p = 0\n    # loop until the first vertex hits the wall\n    while True:\n        # move to next time\n        data[\"time\"] += 0.1\n        # move to next point\n        data[\"polygon_coords\"][0][0] += data[\"v\"] * math.cos(data[\"omega\"])\n        data[\"polygon_coords\"][0][1] += data[\"v\"] * math.sin(data[\"omega\"])\n        data[\"polygon_coords\"][1][0] += data[\"v\"] * math.cos(data[\"omega\"])\n        data[\"polygon_coords\"][1][1] += data[\"v\"] * math.sin(data[\"omega\"])\n\n        # move center of mass\n        data[\"center\"][0] += data[\"v\"] * math.cos(data[\"omega\"])\n        data[\"center\"][1] += data[\"v\"] * math.sin(data[\"omega\"])\n\n        # determine if the polygon hit the wall\n        if wall_intersect(wall_coords, data):\n            # update the data\n            data[\"time\"] -= 0.1\n            data[\"v\"] *= -1\n            break\n\n        # increase the iteration count\n        p += 1\n\n    # return the pair of times and coordinates of the first vertex\n    return f\"{p} {data['time']}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the first vertex that hits the wall.\n    \"\"\"\n    # constants\n    g = 9.81\n    # v = 1 m/s\n    # omega = 45 deg/s in counterclockwise\n    # theta = 20 deg in clockwise\n    n = int(stdin[0])\n    omega = float(stdin[1])\n    v0 = float(stdin[2])\n    theta = float(stdin[3])\n    w = float(stdin[4])\n    vx = float(stdin[5])\n    # h = height of wall\n    h = 0\n    # the wall has two slopes\n    m1 = (h + vx * math.tan(math.radians(omega))) / (1 + w * w / (g * vx * vx))\n    m2 = (h + vx * math.tan(math.radians(omega))) / (1 - w * w / (g * vx * vx))\n    # for each vertex, compute t\n    t = lambda x, y: vx * vx * (math.sin(math.radians(omega))) * (m1 - m2) / g\n    # for each vertex, compute x and y\n    x = lambda t: vx * math.sin(math.radians(omega)) / (g * t) + (w * w / (g * vx * vx)) * (m2 * vx * t - vx)\n    y = lambda t: vx * math.cos(math.radians(omega)) / (g * t) + (w * w / (g * vx * vx)) * (m1 * vx * t - vx)\n    # for each vertex, compute x' and y'\n    x1 = lambda t: vx * math.sin(math.radians(omega)) / (g * t)\n    y1 = lambda t: vx * math.cos(math.radians(omega)) / (g * t)\n    x2 = lambda t: vx * math.sin(math.radians(omega)) / (g * t) + (w * w / (g * vx * vx)) * (m2 * vx * t - vx)\n    y2 = lambda t: vx * math.cos(math.radians(omega)) / (g * t) + (w * w / (g * vx * vx)) * (m1 * vx * t - vx)\n    # for each vertex, compute theta\n    theta1 = lambda x, y: math.atan(y1(t(x, y)) / x1(t(x, y)))\n    theta2 = lambda x, y: math.atan(y2(t(x, y)) / x2(t(x, y)))\n    # for each vertex, compute theta'\n    theta1p = lambda x, y: math.atan(y1(t(x, y)) / x1(t(x, y))) + math.pi / 2\n    theta2p = lambda x, y: math.atan(y2(t(x, y)) / x2(t(x, y))) + math.pi / 2\n    # for each vertex, compute vx\n    vx1 = lambda x, y: x1(t(x, y)) * math.cos(math.radians(theta1(x, y)))\n    vx2 = lambda x, y: x2(t(x, y)) * math.cos(math.radians(theta2(x, y)))\n    # for each vertex, compute vy\n    vy1 = lambda x, y: y1(t(x, y)) * math.sin(math.radians(theta1(x, y)))\n    vy2 = lambda x, y: y2(t(x, y)) * math.sin(math.radians(theta2(x, y)))\n    # for each vertex, compute vxp\n    vxp1 = lambda x, y: x1(t(x, y)) * math.cos(math.radians(theta1p(x, y)))\n    vxp2 = lambda x, y: x2(t(x, y)) * math.cos(math.radians(theta2p(x, y)))\n    # for each vertex, compute vyp\n    vyp1 = lambda x, y: y1(t(x, y)) * math.sin(math.radians(theta1p(x, y)))\n    vyp2 = lambda x, y: y2(t(x, y)) * math.sin(math.radians(theta2p(x, y)))\n    # for each vertex, compute theta'\n    theta1p = lambda x, y: math.atan(y1(t(x, y)) / x1(t(x, y)))\n    theta2p = lambda x, y: math.atan(y2(t(x, y)) / x2(t(x, y)))\n    # for each vertex, compute theta'\n    theta1pp = lambda x, y: math.atan(y1(t(x, y)) / x1(t(x, y))) + math.pi / 2\n    theta2pp = lambda x, y: math.atan(y2(t(x, y)) / x2(t(x, y))) + math.pi / 2\n    # for each vertex, compute theta'\n    the"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    for this problem, since the max speed is 9.81, and since the max angle is 90,\n    if the max speed is 9.81, then the max velocity is 20\n    and if the max velocity is 20, then the max angle is 45\n    '''\n    parsed_input = stdin.split('\\n')\n\n    first_line = [int(num) for num in parsed_input[0].split()]\n    max_speed = first_line[3]\n    max_angle = first_line[4]\n    polygon_vertices = [[int(num) for num in vert.split()] for vert in parsed_input[1:]]\n\n    initial_angle = 0\n    initial_position = polygon_vertices[0]\n    polygon_vertices = sorted(polygon_vertices, key=lambda x: x[1])\n    t = polygon_vertices[0][1]\n\n    while True:\n        # the following function returns True if the first point on the line\n        # intersects the circle, otherwise it returns False\n        is_cross = check_cross(polygon_vertices, initial_position, initial_angle, t)\n        if is_cross:\n            return str(t) +'' + str(t)\n        else:\n            t += max_speed / max_angle\n\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://codeforces.com/problemset/problem/1132/A\"\"\"\n    pass\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, omega, v0, theta, w = list(map(float, stdin.split()))\n    vertices = []\n    for i in range(int(n)):\n        x, y = list(map(float, stdin.split()))\n        vertices.append([x, y])\n    \n    # compute the relevant info for the problem\n    x0 = v0 * cos(radians(theta))\n    y0 = v0 * sin(radians(theta))\n    T = 2 * (w - x0) / omega\n    for i in range(int(n)):\n        xi = x0 + T * omega * (1 + 2 * i)\n        yi = y0 + T * omega * i\n        dist = sqrt((xi - vertices[i][0])**2 + (yi - vertices[i][1])**2)\n        if dist <= 1:\n            return \"{} {}\".format(i + 1, T)\n    \n    return \"0 {}\".format(T)\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    O(N)\n    \"\"\"\n    data = [int(x) for x in stdin.split()]\n    n = data[0]\n    omega = data[1]\n    v0 = data[2]\n    theta = data[3]\n    w = data[4]\n    points = [tuple(map(float, line.split())) for line in stdin.splitlines()[5:]]\n    points = [(x, y) for x, y in points]\n    t = 0\n    time_points = []\n    for i in range(1, n + 1):\n        x0, y0 = points[i - 1]\n        x1, y1 = points[(i + 1) % n]\n        x2, y2 = points[(i + 2) % n]\n        v_x = v0 * np.cos(np.radians(theta))\n        v_y = v0 * np.sin(np.radians(theta))\n        x_0 = x0 + v_x * t\n        y_0 = y0 + v_y * t\n        x_1 = (\n            (x0 - v_x * t) * (v_y - v0 * np.sin(np.radians(theta)))\n            - (y0 - v_y * t) * (v_x - v0 * np.cos(np.radians(theta)))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        y_1 = (\n            (x0 - v_x * t) * np.sin(np.radians(theta))\n            + (y0 - v_y * t) * np.cos(np.radians(theta))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        v_x = v0 * np.cos(np.radians(theta))\n        v_y = v0 * np.sin(np.radians(theta))\n        x_1 = (\n            (x0 - v_x * t) * (v_y - v0 * np.sin(np.radians(theta)))\n            - (y0 - v_y * t) * (v_x - v0 * np.cos(np.radians(theta)))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        y_1 = (\n            (x0 - v_x * t) * np.sin(np.radians(theta))\n            + (y0 - v_y * t) * np.cos(np.radians(theta))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        v_x = v0 * np.cos(np.radians(theta))\n        v_y = v0 * np.sin(np.radians(theta))\n        x_2 = (\n            (x0 - v_x * t) * (v_y - v0 * np.sin(np.radians(theta)))\n            - (y0 - v_y * t) * (v_x - v0 * np.cos(np.radians(theta)))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        y_2 = (\n            (x0 - v_x * t) * np.sin(np.radians(theta))\n            + (y0 - v_y * t) * np.cos(np.radians(theta))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np.radians(theta))\n        )\n        v_x = v0 * np.cos(np.radians(theta))\n        v_y = v0 * np.sin(np.radians(theta))\n        x_2 = (\n            (x0 - v_x * t) * (v_y - v0 * np.sin(np.radians(theta)))\n            - (y0 - v_y * t) * (v_x - v0 * np.cos(np.radians(theta)))\n        ) / (\n            v0 * np.cos(np.radians(theta))\n            - v_x * np.sin(np.radians(theta))\n            + v_y * np.cos(np."
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *lst = stdin.splitlines()\n    N = int(N)\n    lst = [*map(int, lst)]\n\n    lst.sort()\n    count = 0\n    for i in range(0, N):\n        for j in range(i + 1, N):\n            if lst[j] - lst[i] < 4:\n                continue\n            for k in range(j + 1, N):\n                if lst[k] - lst[j] < 4:\n                    continue\n                for m in range(k + 1, N):\n                    if lst[m] - lst[k] < 4:\n                        continue\n                    if not (lst[m] - lst[j] < 4):\n                        continue\n                    if not (lst[i] < lst[m] < lst[j] or lst[i] < lst[k] < lst[j]):\n                        continue\n                    count += 1\n    return count\nprint(solution(stdin))\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = [line.strip() for line in stdin.split('\\n') if line.strip()]\n    trench = []\n    for line in lines:\n        if line:\n            trench.append([int(x) for x in line.split()])\n    trench.sort()\n    count = 0\n    for i, line in enumerate(trench):\n        if line[0] == line[2]:\n            continue\n        if i + 1 < len(trench) and trench[i][1] <= trench[i + 1][0]:\n            count += 1\n    return count\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    # Your code here\n    \n    return answer\n\ndef"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'Hello, world!'\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    x = int(stdin.readline().strip())\n    points = []\n    for i in range(x):\n        points.append(list(map(int, stdin.readline().strip().split())))\n    points.sort()\n    l = len(points)\n    if l == 1:\n        return str(1)\n    i = 0\n    while i < l - 1:\n        for j in range(i+1, l):\n            if points[i][0] == points[j][0] or points[i][1] == points[j][1]:\n                continue\n            if points[i][0] < points[j][0] and points[i][1] < points[j][1]:\n                if points[i][0] < points[j][0] and points[i][1] < points[j][1] and \\\n                        points[i+1][0] > points[j][0] and points[i+1][1] > points[j][1]:\n                    i += 1\n                    break\n            elif points[i][0] > points[j][0] and points[i][1] > points[j][1]:\n                if points[i][0] > points[j][0] and points[i][1] > points[j][1] and \\\n                        points[i+1][0] < points[j][0] and points[i+1][1] < points[j][1]:\n                    i += 1\n                    break\n            else:\n                continue\n        else:\n            i += 1\n            continue\n        break\n    print(i)\n    print(points[:i+1])\n    m = i+1\n    n = l - m\n    print(m, n)\n    if n == 1:\n        return str(1)\n    if n == 2:\n        return str(2)\n    if n == 3:\n        return str(4)\n    if n == 4:\n        return str(7)\n    # if n == 5:\n    #     return str(40)\n    print(points[i+1:])\n    points = points[i+1:]\n    x = points[0][0]\n    print(x)\n    # x_min = x\n    # x_max = x\n    # y_min = points[0][1]\n    # y_max = points[0][1]\n    # for i in range(1, n):\n    #     if points[i][0] < x_min:\n    #         x_min = points[i][0]\n    #     elif points[i][0] > x_max:\n    #         x_max = points[i][0]\n    #     if points[i][1] < y_min:\n    #         y_min = points[i][1]\n    #     elif points[i][1] > y_max:\n    #         y_max = points[i][1]\n    #\n    # print(x_min, x_max, y_min, y_max)\n    #\n    # if x_max == x_min:\n    #     return str(1)\n    # if y_max == y_min:\n    #     return str(1)\n    #\n    # if x_max - x_min == 1:\n    #     if (y_max - y_min) == 1:\n    #         return str(1)\n    #\n    # if x_max - x_min == 2:\n    #     if (y_max - y_min) == 2:\n    #         return str(4)\n    #\n    # if x_max - x_min == 3:\n    #     if (y_max - y_min) == 3:\n    #         return str(7)\n    #\n    # if x_max - x_min == 4:\n    #     if (y_max - y_min) == 4:\n    #         return str(8)\n    #\n    # if x_max - x_min == 5:\n    #     if (y_max - y_min) == 5:\n    #         return str(25)\n    #\n    # if x_max - x_min == 6:\n    #     if (y_max - y_min) == 6:\n    #         return str(32)\n    #\n    # return str(1)\n\n    # if x_max - x_min == 0:\n    #     return str(1)\n    #\n    # if x_max - x_min == 1:\n    #     return str(2)\n    #\n    # if x_max - x_min == 2:\n    #     return str(4)\n    #\n    # if x_max - x_min == 3:\n    #     return str(8)\n    #\n    # if x_max - x_min == 4:\n    #     return str(16)\n    #\n    # if x_max - x_min == 5:\n    #     return str(32)\n    #\n    # if x_max - x_min == 6:\n    #     return str(64)\n    #\n    # if x_max - x_min == 7:\n    #     return str(128)\n    #\n    # if x_max - x_min == 8:\n    #     return str(256)\n    #\n    # if x_max - x_min == 9:\n    #     return str(512)\n    #\n    # if x_max - x_min == 10:\n    #     return str(1024)\n    #\n    # if x_max - x_min == 11:\n    #     return str(2048)\n    #\n    # if x_max - x_min == 12:\n    #     return str(4096)\n    #\n    # if x_max - x_min == 13:\n    #     return str(8192)\n    #\n    # if x_max - x_min == 14:\n    #     return str(16384)\n    #\n    # return str(1)\n    #\n    # if x_max - x_min == 1:\n    #     return str(1)\n    #\n    # if x_max - x_min == 2:\n    #     return str(2)\n    #\n    # if x_max - x_min == 3:\n    #     return str(4)\n    #\n    # if x_max - x_min == 4:\n    #     return str(8)\n    #\n    # if x_max - x_min == 5:\n    #     return str(16)\n    #\n    # if x_max - x_min == 6:\n    #     return str(32)\n    #\n    # if x_max - x_min == 7:\n    #     return str(64)\n    #\n    # if x_max - x_min == 8:\n    #     return str(128)\n    #\n    # if x_max - x_min == 9:\n    #     return str(256)\n    #\n    # if x_max - x_min == 10:\n    #     return str("
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return None"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    # Get input\n    num_trenches = int(stdin.readline())\n    trenches = list()\n    for i in range(num_trenches):\n        trench_line = stdin.readline().split(' ')\n        x1 = int(trench_line[0])\n        y1 = int(trench_line[1])\n        x2 = int(trench_line[2])\n        y2 = int(trench_line[3])\n        trenches.append([(x1, y1), (x2, y2)])\n\n    # Get all unique points\n    all_points = set()\n    for trench in trenches:\n        all_points.add(trench[0])\n        all_points.add(trench[1])\n\n    # Loop over all points\n    num_solutions = 0\n    for i in range(len(all_points)):\n        x1, y1 = all_points[i]\n        for j in range(i + 1, len(all_points)):\n            x2, y2 = all_points[j]\n\n            # Check if both points can be seen from each other\n            if all(\n                point_1 == point_2 or point_1 in trench_2\n                for trench_1 in trenches\n                for point_1, point_2 in (trench_1[0], trench_1[1]),\n                          (trench_1[0], trench_1[1])\n            ):\n                num_solutions += 1\n\n    return str(num_solutions)\n\n\ndef"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    trenches = [tuple(map(int, line.split())) for line in stdin]\n    return f\"{combinations(n, 2)}\"\n\n\ndef"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('6\\n0 0 1 0\\n0 0 0 1\\n1 0 1 1\\n0 1 1 1\\n0 0 1 1\\n1 0 0 1')\n    8\n    \"\"\"\n    return\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the minimum possible length of the side of the building such that the whole area fits into a square pool.\n    >>> solution('7')\n    4 3\n    \"\"\"\n    n = int(stdin.readline())\n    k = 1\n    for m in range(2, int(n ** 0.5) + 1):\n        if n == (m ** 2) - (k ** 2):\n            return str(m) +'' + str(k)\n    return 'impossible'\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(2, n + 1):\n        for k in range(1, m):\n            if (m ** 2 - k ** 2) == n:\n                return (m, k)\n\n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(10)\n    4 3\n\n    >>> solution(7)\n    4 3\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    'Finds the two sides of the building and the pool that sum up to give the total tiles needed.'\n    tiles = int(stdin)\n    for m in range(1, int(sqrt(tiles)) + 1):\n        k = int(sqrt(tiles - m ** 2))\n        if k >= 0 and k ** 2 + m ** 2 == tiles:\n            return str(m) +'' + str(k)\n    return 'impossible'\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n = int(stdin)\n    if n > 9 * 9 or n < 9 * 9:\n        return \"impossible\"\n    for m in range(1, n):\n        for k in range(1, n):\n            if m * m - k * k == n:\n                return m, k\n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #Your solution goes here\n    tiles = int(stdin.strip())\n    for m in range(int(tiles**(1/2)//1+1), int(tiles**(1/2)//1+1)+1):\n        for k in range(int(tiles**(1/2)//1+1), int(tiles**(1/2)//1+1)+1):\n            if m**2 - k**2 == tiles:\n                return f'{m} {k}'\n    return 'impossible'"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s1 = set()\n    s2 = set()\n    for i in range(1, int(n**0.5)+1):\n        s1.add(i**2)\n        s2.add(i**2+i)\n    s = s1 & s2\n    for i in s:\n        if i+1 in s:\n            if i+2 in s:\n                a,b,c = i,i+1,i+2\n                m = int(n/a)\n                k = int(n/b)\n                return str(m)+\" \"+str(k)\n                \n                \n            \n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return stdout\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates the price of subsequences in a certain array\"\"\"\n\n    size = int(stdin)\n    arr = list(map(int, stdin.split()))\n    price = 0\n\n    for i in range(size):\n        min_value = min(arr[i:])\n        max_value = max(arr[i:])\n        price += min_value * max_value\n\n    last_9_digits = int(str(price)[-9:])\n    return str(last_9_digits)\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = stdin.split()[0]\n    A = [int(x) for x in stdin.split()[1:]]\n\n    min_, max_ = min(A), max(A)\n    s = 0\n    for i in range(min_, max_ + 1):\n        for j in range(min_, i):\n            s += i - j\n    s = str(s)\n    return s[-9:]\n\nprint(solution(input()))\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = [int(stdin.readline()) for _ in range(n)]\n    arr.sort()\n    min_ = min(arr)\n    max_ = max(arr)\n    if len(arr) > 1:\n        return str(int((max_ * min_ * len(arr)) / (min_ - max_ + 1) * 9))[-9:]\n    else:\n        return str(arr[0] * len(arr) * 9)[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    A = [int(stdin.readline()) for _ in range(n)]\n    min_max = [min(A), max(A)]\n    return str(sum(min_max))[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    return \"\"\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin.split()[0]\n    numbers = [int(stdin.split()[i]) for i in range(1, int(n) + 1)]\n    min_number = min(numbers)\n    max_number = max(numbers)\n    len_number = len(numbers)\n    return str(min_number * max_number * len_number)[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    L = int(stdin.readline())\n    S = 0\n    for _ in range(L):\n        S += int(stdin.readline())\n    return str(S)[-9:]\n\ndef"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = [int(i) for i in stdin.split()][:n]\n    arr.sort()\n    min_element = min(arr)\n    max_element = max(arr)\n    avg = int((max_element - min_element)/len(arr))\n    return str(sum([avg * (i - min_element) for i in arr]))[-9:]\n    \n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_subsequences_prices(arr: list, n: int, k: int) -> list:\n        ans = []\n        for i in range(n - k + 1):\n            ans.append(max(arr[i:i+k]) * min(arr[i:i+k]))\n        return ans\n\n    n = int(stdin)\n    arr = [int(x) for x in stdin.split()]\n    print(int(str(sum(find_subsequences_prices(arr, n, 9)))[-9:]))\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Take a string, remove every letter and return the remaining string.\n    >>> solution(\"asdffdasdffdasdfghjkllll\")\n    'fdfd'\n    >>> solution(\"asdffdasdffdasdfghjkllllx\")\n    'fdfd'\n    >>> solution(\"asdffdasdffdasdfghjkllllxx\")\n    'fdfd'\n    \"\"\"\n    return \"\".join([letter for letter in stdin if not letter.isalpha()])\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.strip().split()]\n    cards = [int(x) for x in stdin.strip().split()]\n    races = []\n    for _ in range(m):\n        races.append(tuple([int(x) for x in stdin.strip().split()]))\n    races.sort(key=lambda x: x[0])\n    purchases = 0\n    races_to_update = []\n    for race in races:\n        if len(races_to_update) == 0:\n            races_to_update = [race[1]]\n        else:\n            races_to_update.append(race[1])\n        if len(races_to_update) == 2:\n            races_to_update.sort()\n            for i in range(races_to_update[0], races_to_update[1] + 1):\n                cards[i] += 1\n            purchases += 1\n            races_to_update = []\n    return purchases\n\nprint(solution(input()))\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cards = [0] * N\n    for i in range(M):\n        a, b = map(int, stdin.split()[i*2+1:i*2+3])\n        cards[a-1] += 1\n        cards[b-1] += 1\n    purchases = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if cards[i] == cards[j]:\n                purchases += 1\n                cards[i] += 2\n                cards[j] += 2\n    print(purchases)\n    for i in range(N):\n        print(i+1, cards[i])\n    return \"\"\n\nsolution(stdin)"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determines who went to the store with whom and who won the card collection contest.\n\n    Args:\n        stdin (str): input on stdin\n\n    Returns:\n        str: output to stdout\n    \"\"\"\n    n, m = [int(i) for i in stdin.split(\"\\n\")[0].split()]\n    cards = [int(i) for i in stdin.split(\"\\n\")[1].split()]\n    purchases = []\n    for i in range(m):\n        purchases.append(stdin.split(\"\\n\")[i + 2].split())\n\n    purchases = sorted(purchases, key=lambda x: x[0])\n\n    cards_history = dict()\n    for purchase in purchases:\n        i, j, k = [int(i) for i in purchase]\n        if i in cards_history:\n            cards_history[i].append([j, k])\n        else:\n            cards_history[i] = [[j, k]]\n\n    counts = [0 for _ in range(n)]\n    for key in cards_history.keys():\n        for card in cards_history[key]:\n            if card[1] == 1:\n                counts[key - 1] += card[0]\n\n    for key in cards_history.keys():\n        for card in cards_history[key]:\n            if card[1] == 2:\n                counts[card[0] - 1] += card[0]\n                counts[key - 1] += card[0]\n    for count in counts:\n        print(count)\n\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    children = int(stdin.split(' ')[0])\n    num_cards = int(stdin.split(' ')[1])\n    values = [int(i) for i in stdin.split('\\n') if i!= '']\n\n    winners = [0] * children\n    for i in range(children):\n        winners[i] = []\n\n    for v in values:\n        if v[0]!= v[1]:\n            winners[v[0] - 1].append(v[2])\n            winners[v[1] - 1].append(v[2])\n\n    for i in range(children):\n        winners[i] = [0, 0]\n        for v in winners[i]:\n            winners[i][v] += 1\n\n    # print(winners)\n\n    return winners\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    from math import gcd\n    from functools import reduce\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    cards = map(int, stdin.split('\\n')[1].split(' '))\n    purchases = [tuple(map(int, line.split(' '))) for line in stdin.split('\\n')[2:]]\n    comb = list(combinations(range(1, n + 1), 2))\n    purchases_dict = dict()\n    for tup in purchases:\n        purchases_dict[tup] = 0\n    comb = set(comb)\n    for tup in purchases:\n        if tup[0] in comb and tup[1] in comb:\n            purchases_dict[tup] += 2\n    purchases_dict[(1, 1)] = cards[0]\n    purchases_dict[(1, 2)] = cards[1]\n    purchases_dict[(2, 1)] = cards[2]\n    purchases_dict[(2, 2)] = cards[3]\n    purchases_dict[(1, 3)] = cards[4]\n    purchases_dict[(2, 3)] = cards[5]\n    for p in purchases_dict:\n        if purchases_dict[p] == 0:\n            continue\n        if p[0] == p[1]:\n            purchases_dict[p] += 1\n    purchases_dict[(1, 2)] //= 2\n    purchases_dict[(1, 3)] //= 2\n    purchases_dict[(2, 2)] //= 2\n    purchases_dict[(2, 3)] //= 2\n    for p in purchases_dict:\n        purchases_dict[p] %= 3\n    purchases_dict[(1, 3)] %= 3\n    purchases_dict[(2, 3)] %= 3\n    if len(purchases_dict)!= 4:\n        return\n    if len(set(cards))!= 3:\n        return\n    if cards[0] % 2!= 0 or cards[1] % 2!= 0:\n        return\n    if gcd(cards[0], cards[1])!= 1:\n        return\n    for k in purchases_dict:\n        if purchases_dict[k] == 0:\n            return\n    ans = reduce(lambda x, y: (x * y) % 3, (purchases_dict[k] for k in purchases_dict), 1)\n    return ans\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2 3\n   ... 5 1\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n   ... 1 2\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: input in string format\n    :return: solution in string format\n    \"\"\"\n    n, m = stdin.split(\" \")[0], stdin.split(\" \")[1]\n    cards = list(map(int, stdin.split(\" \")[2:]))\n    purchases = 0\n    while m > 0:\n        a, b = map(int, stdin.split(\" \")[2:])\n        m -= 1\n        if cards[a-1] == 0 or cards[b-1] == 0:\n            purchases += 1\n        else:\n            if cards[a-1] == 1 and cards[b-1] == 1:\n                cards[a-1] += 1\n                cards[b-1] += 1\n            elif cards[a-1] == 1 and cards[b-1] == 2:\n                cards[a-1] += 1\n                cards[b-1] = 1\n            elif cards[a-1] == 2 and cards[b-1] == 1:\n                cards[a-1] = 1\n                cards[b-1] += 1\n            else:\n                cards[a-1] = 2\n                cards[b-1] = 2\n    return purchases"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    purchases, _, cards = [int(x) for x in stdin.split()]\n    purchases = [int(x) for x in stdin.split()]\n    print(purchases)\n    '''\n    n, m = [int(x) for x in stdin.split()]\n    children = [int(x) for x in stdin.split()]\n    print(n, m)\n    print(children)\n\n    return"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the problem for at least one sample input.\n    \"\"\"\n    input = stdin.split(\"\\n\")\n    N = int(input[0].split(\" \")[0])\n    M = int(input[0].split(\" \")[1])\n    cards = [0] * N\n    for i in range(1, M + 1):\n        cards[int(input[i].split(\" \")[0]) - 1] = int(input[i].split(\" \")[1])\n    purchases = []\n    for j in range(M, M + N):\n        purchases.append(input[j].split(\" \"))\n    purchases = [[int(i[0]), int(i[1])] for i in purchases]\n    purchases.sort(key = lambda x: x[1])\n    purchases.sort(key = lambda x: x[0])\n    count = 0\n    for k in range(M + N):\n        if cards[purchases[k][0] - 1] > 0:\n            if cards[purchases[k][0] - 1] % 2 == 0:\n                if k < M + N - 1 and cards[purchases[k + 1][0] - 1] == 0:\n                    count += 1\n                    cards[purchases[k][0] - 1] -= 2\n                    cards[purchases[k + 1][0] - 1] += 2\n                    cards[purchases[k][0] - 1] %= 2\n                    cards[purchases[k + 1][0] - 1] %= 2\n                else:\n                    count += 1\n                    cards[purchases[k][0] - 1] -= 1\n                    cards[purchases[k][0] - 1] %= 2\n        else:\n            if k < M + N - 1 and cards[purchases[k + 1][0] - 1] == 0:\n                count += 1\n                cards[purchases[k][0] - 1] += 1\n                cards[purchases[k][0] - 1] %= 2\n                cards[purchases[k + 1][0] - 1] += 1\n                cards[purchases[k + 1][0] - 1] %= 2\n    return count\n\nprint(solution(input()))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    d, e = map(int, stdin.split(' '))\n    toys = dict()\n    cnt = dict()\n    for _ in range(e):\n        s, k, t = map(int, stdin.split(' '))\n        if t not in toys:\n            toys[t] = set()\n            cnt[t] = set()\n        toys[t].add(k)\n        cnt[t].add(k)\n    kids = sorted(list(cnt.keys()))\n    ans = [0] * n\n    prev = None\n    for t in sorted(toys.keys()):\n        for k in kids:\n            if len(toys[t]) > 1:\n                if k not in cnt[t]:\n                    continue\n                if prev is None or t - prev >= d:\n                    ans[k - 1] = t\n                    cnt[t].remove(k)\n            prev = t\n        toys[t].clear()\n    if len(ans) > 0:\n        return''.join(map(str, ans))\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, m = map(int, stdin.readline().split())\n    d, e = map(int, stdin.readline().split())\n    toy = [0] * m\n    event = [[] for _ in range(m)]\n    for _ in range(e):\n        s, k, t = map(int, stdin.readline().split())\n        event[t].append([s, k, t])\n\n    for i in range(m):\n        if len(event[i]) == 0:\n            toy[i] = 0\n        else:\n            toy[i] = event[i][0][2]\n            for j in range(1, len(event[i])):\n                if event[i][j][0] < event[i][j-1][0]:\n                    toy[i] = event[i][j-1][2]\n                    break\n    for i in range(m):\n        if toy[i] == 0:\n            toy[i] = i + 1\n    return''.join(map(str, toy))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"2 2\\n0 1 1\\n0 2 2\\n1 1 3\\n2 1 2\\n2 2 1\")\n    '1 2'\n    \"\"\"\n    n, m = map(int, stdin.strip().split())\n    d, e = map(int, stdin.strip().split())\n    events = []\n    for _ in range(e):\n        s, k, t = map(int, stdin.strip().split())\n        events.append((s, k, t))\n    events.sort()\n    current_toy = None\n    toys = []\n    for s, k, t in events:\n        if t == 0:\n            assert current_toy == k\n            current_toy = None\n        elif t == 1 and current_toy is None:\n            current_toy = k\n        elif t == 1 and current_toy is not None:\n            toys.append(current_toy)\n            current_toy = k\n        else:\n            raise Exception(f\"Unexpected t={t}\")\n    toys.append(current_toy)\n    return \"\\n\".join(map(str, toys))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split(' ')\n    n = int(n)\n    m = int(m)\n\n    toys = [0] * n\n    for i in range(m):\n        s, k, t = stdin.split(' ')\n        s = int(s)\n        k = int(k) - 1\n        t = int(t) - 1\n        toys[k] = t\n\n    last_played_with_toy = [-1] * n\n    for i in range(m):\n        s, k, t = stdin.split(' ')\n        s = int(s)\n        k = int(k) - 1\n        t = int(t) - 1\n        if t == 0:\n            last_played_with_toy[k] = -1\n        else:\n            last_played_with_toy[k] = t\n    possible_assignments = []\n    def permutation(toys, last_played_with_toy, depth, current_assignment):\n        if depth == n:\n            possible_assignments.append(current_assignment)\n            return\n        for i in range(len(toys)):\n            if last_played_with_toy[i] == -1:\n                permutation(toys, last_played_with_toy, depth + 1, current_assignment + [toys[i]])\n\n    permutation(toys, last_played_with_toy, 0, [])\n    if possible_assignments:\n        print(' '.join(str(e) for e in possible_assignments[0]))\n    else:\n        print('impossible')\n\nsolution(stdin)\n\nSample Input 1:\n2 3\n6 7\n0 1 1\n0 2 2\n1 1 3\n2 1 2\n2 2 1\n3 2 3\n4 2 1\nSample Output 1:\n1 2\n\nSample Input 2:\n2 1\n20 3\n0 1 1\n10 1 0\n10 2 1\nSample Output 2:\nimpossible\n\nSample Input 3:\n2 1\n20 3\n0 1 1\n10 1 0\n10 2 1\nSample Output 3:\n1 2\n\nSample Input 4:\n2 2\n0 1 1\n2 1 2\nSample Output 4:\nimpossible\n\nSample Input 5:\n2 3\n1 2 3\n0 1 1\n0 2 2\nSample Output 5:\n1 2 3\n\nSample Input 6:\n2 3\n4 6\n0 1 1\n0 2 2\n1 1 3\n1 1 3\n2 1 2\n2 2 1\n2 2 1\nSample Output 6:\n1 2 3\n\"\"\"\nimport sys\nimport math"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # create initial graph\n    graph = [{} for _ in range(K + 1)]\n\n    # for each line in the input\n    for line in stdin.split('\\n'):\n        # extract the timestamp, source, target and weight\n        timestamp, source, target, weight = line.split(' ')\n        timestamp = int(timestamp)\n        source, target = int(source), int(target)\n        weight = int(weight)\n        # add the new edge to the graph\n        add_edge(graph, source, target, weight, timestamp)\n\n    # compute the max vertex for the graph\n    max_vertex = max_vertex_num(graph)\n\n    # sort the edges by their timestamp\n    sorted_edges = []\n    for u, v, weight in graph[1]:\n        for _, _, weight in graph[1]:\n            sorted_edges.append((weight, u, v))\n\n    # loop through the edges of the graph\n    for weight, u, v in sorted(sorted_edges):\n        # remove the edge from the graph\n        remove_edge(graph, u, v)\n        # compute the max vertex for the graph\n        max_vertex = max_vertex_num(graph)\n        # if the graph has more than 1 vertex\n        if max_vertex > 1:\n            # compute the two vertices that have the most edges\n            u, v = most_connected_vertices(graph)\n            # add the new edge to the graph\n            add_edge(graph, u, v, weight, timestamp)\n            # output the solution\n            return''.join(map(str, [u, v]))\n\n    # there is no solution\n    return \"impossible\"\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This is the main function that calls the functions to solve the problem. It takes in input, runs them and returns the solution to the problem.\n    \"\"\"\n    n, m = map(int, stdin.split(\" \"))\n    d, e = map(int, stdin.split(\" \"))\n    playtime = [[0, 0, 0] for i in range(n + 1)]\n    events = []\n    for i in range(e):\n        s, k, t = map(int, stdin.split(\" \"))\n        playtime[k][0] += t\n        playtime[k][1] = max(playtime[k][1], s)\n        playtime[k][2] = max(playtime[k][2], t)\n        events.append((s, k, t))\n    events = sorted(events, key=lambda x: x[0])\n    events = [events[0]] + [\n        (ev[0], ev[1], ev[2], 1) if ev[2] == 0 else ev for ev in events[1:]\n    ]\n    e = len(events)\n    toys = [0 for i in range(m + 1)]\n    cur = 0\n    for i in range(1, e):\n        s, k, t, cur = events[i][0], events[i][1], events[i][2], events[i][3]\n        if i < e - 1 and events[i + 1][0] == s:\n            continue\n        if cur == 0:\n            toys[0] += 1\n        for j in range(1, m + 1):\n            if t == 0:\n                toys[j] = max(toys[j], toys[j - 1])\n            else:\n                toys[j] = max(toys[j], toys[j - 1]) + 1\n                if toys[j] <= k:\n                    toys[j] = 0\n                    toys[j - 1] -= 1\n    if toys[-1] <= 0:\n        return \"impossible\"\n    return \" \".join(map(str, toys[:-1]))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    d, e = map(int, stdin.split(' '))\n    toys = dict(map(int, stdin.split(' ')))\n    events = [tuple(map(int, stdin.split(' '))) for _ in range(e)]\n    events.sort()\n    toy_by_time = dict()\n    for _, _, t in events:\n        toy_by_time[t] = toys[t]\n    s, t = 0, d\n    toys_played = dict()\n    while s < t:\n        cur_toy = toys_played.get(s, 0)\n        next_toy = toys_played.get(s+1, 0)\n        if not cur_toy:\n            for _, k, t in events:\n                if t == s:\n                    toys_played[s] = toys[t]\n        if next_toy == toys_played.get(s+1, 0):\n            for _, k, t in events:\n                if t == s+1 and toys_played.get(s+1, 0) == toys[t]:\n                    toys_played[s] = toys[t]\n        elif toys_played[s] == toys[s+1]:\n            for _, k, t in events:\n                if t == s+1 and toys_played.get(s+1, 0) == toys[t]:\n                    toys_played[s] = toys[t]\n        else:\n            toys_played[s] = toys[s+1]\n        s += 1\n    for _, k, t in events:\n        if toys_played.get(t, 0) == toys[t] and k!= toys_played.get(t, 0):\n            print('impossible')\n            return\n    print(*[toys_played[t] for t in range(1, n+1)])\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, e = [int(x) for x in stdin.split()]\n    toys = [0] * (m + 1)\n    children = [[] for _ in range(n)]\n    for x in stdin.split('\\n')[3:]:\n        t, k, tt = [int(x) for x in x.split()]\n        toys[tt] += 1\n        children[k - 1].append(tt)\n    for x in stdin.split('\\n')[3:]:\n        t, k, tt = [int(x) for x in x.split()]\n        toys[tt] += 1\n        children[k - 1].append(tt)\n    toys = sorted(toys)\n    # print(toys, children)\n    # print(max([toys[x] for x in toys if toys[x]!= 0]))\n    i = n - 1\n    while i > 0 and toys[i] < max([toys[x] for x in toys if toys[x]!= 0]):\n        i -= 1\n    if i < 0:\n        return 'impossible'\n    s = [0] * d\n    ans = [0] * n\n    j = 0\n    for x in toys[:i + 1]:\n        if x > 0:\n            if j < len(children[i]):\n                # print(children[i])\n                if children[i][j] > 0 and s[children[i][j] - 1] == 0:\n                    s[children[i][j] - 1] = 1\n                    ans[i] = children[i][j]\n                    j += 1\n            else:\n                s[children[i][j] - 1] = 1\n                ans[i] = children[i][j]\n                j += 1\n        # print(x, s)\n    if j < len(children[i]):\n        ans[i] = children[i][j]\n    print(' '.join(map(str, ans)))\n    return''.join(map(str, ans))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the toy that the kids will play with the most\"\"\"\n    kids, toys = map(int, stdin.split())\n    played = [0] * toys\n    toys_left = [0] * toys\n    duration, events = map(int, stdin.split())\n    times = []\n    for i in range(events):\n        times.append(list(map(int, stdin.split())))\n\n    times.sort(key=lambda x: x[0])\n    for s, k, t in times:\n        if t == 0:\n            toys_left[k - 1] += 1\n        else:\n            if s > played[t - 1]:\n                if toys_left[k - 1] == 0:\n                    return \"impossible\"\n                else:\n                    toys_left[k - 1] -= 1\n            else:\n                played[t - 1] = max(s, played[t - 1])\n    ans = [None] * kids\n    for i in range(toys - 1, 0, -1):\n        if toys_left[i] == 0:\n            continue\n        else:\n            for j in range(kids):\n                if ans[j] is None and played[i - 1] < times[j][0]:\n                    ans[j] = i\n                    break\n    if ans is None:\n        return \"impossible\"\n    for i in range(kids):\n        ans[i] = ans[i] + 1\n    return \" \".join(map(str, ans))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    pass\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdout"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    l = []\n    for i in range(1, 11):\n        for j in range(i + 1, 11):\n            if (i ** j) == x:\n                l.append((i, j))\n    min_n = l[0][0]\n    min_k = l[0][1]\n    for i in l:\n        if i[0] < min_n:\n            min_n = i[0]\n        if i[1] < min_k:\n            min_k = i[1]\n    return str(min_n) +'' + str(min_k)\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    import math\n\n    X = int(stdin)\n    sqrt_X = math.sqrt(X)\n\n    def bino(n, k):\n        if k == 0:\n            return 1\n        if k == n:\n            return 1\n        if k == 1:\n            return n\n        return bino(n-1, k-1) + bino(n-1, k)\n\n    def bino_coeff(n, k):\n        if n <= k:\n            return bino(n, k)\n        return bino(k, n)\n\n    return str(int(round(sqrt_X))) +'' + str(int(bino_coeff(round(sqrt_X), round(sqrt_X))))\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 1\n    k = 1\n    while X > (n * k):\n        k += 1\n        n += 1\n    return \"{} {}\".format(n, k)\n\"\"\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve problem.\n    \"\"\"\n    result = stdin\n    return '{} {}'.format(*result)"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    i, j = 0, 0\n    c, s = 1, 1\n    while X > c:\n        j += 1\n        c += j\n    while X > s:\n        i += 1\n        s += i\n    i -= 1\n    j -= 1\n    return str(i) + \" \" + str(j)\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    # find n and k with the smallest value of n.\n    n = max(range(1,X+1), key=lambda x: X//x)\n    k = X//n\n    return f\"{n} {k}\""
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    a = [0, 1, 2]\n    b = [0, 1, 2]\n    if x == 0:\n        return [0, 0]\n    elif x == 1:\n        return [1, 1]\n    elif x == 2:\n        return [2, 1]\n    elif x == 3:\n        return [3, 2]\n    else:\n        for i in range(3, x):\n            a.append(a[i - 1] + a[i - 2])\n            b.append(b[i - 1] + b[i - 2])\n        a = a[2:]\n        b = b[2:]\n    for i in range(len(a)):\n        if a[i] == x:\n            return [i + 1, b[i]]\n        elif b[i] == x:\n            return [a[i], i + 1]\n        elif a[i] < x and b[i] < x:\n            return [a[i], b[i]]\n\nprint(solution(input()))\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num_stores = int(stdin.readline().strip())\n    num_items = int(stdin.readline().strip())\n    stores = {}\n    for i in range(num_items):\n        store_number, item = stdin.readline().split()\n        store_number = int(store_number)\n        stores[store_number] = stores.get(store_number, []) + [item]\n\n    all_items = set(sum(stores.values(), []))\n    items_per_store = {}\n    for i in range(num_stores):\n        items = stores.get(i)\n        if items:\n            items_per_store[i] = set(items)\n\n    num_items_bought = int(stdin.readline().strip())\n    bought = set(stdin.readline().split())\n    for i in range(num_items_bought):\n        if bought.intersection(items_per_store.get(i, set())):\n            return 'ambiguous'\n\n    paths = []\n    for store_number in range(num_stores):\n        for previous_store_number in range(store_number):\n            if store_number in items_per_store and previous_store_number in items_per_store:\n                intersection = items_per_store[store_number] & items_per_store[previous_store_number]\n                if len(intersection) == len(bought):\n                    paths.append((store_number, previous_store_number))\n\n    if len(paths) == 0:\n        return 'impossible'\n    if len(paths) == 1:\n        return 'unique'\n\n    return 'ambiguous'\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n    pass\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stores = [[] for _ in range(n)]\n    for i in range(n):\n        line = stdin.readline().split()\n        stores[i].append(int(line[0]))\n        stores[i].append(line[1])\n    m = int(stdin.readline())\n    items = []\n    for _ in range(m):\n        items.append(stdin.readline())\n    #print(n, stores, m, items)\n    #input()\n    #order stores\n    order = [0 for _ in range(n)]\n    order[0] = 1\n    #print(order)\n    #input()\n    stores_orders = []\n    for i in range(n):\n        if stores[i][0] == 0:\n            stores_orders.append(0)\n        else:\n            stores_orders.append(order[stores[i][0]-1])\n    #print(stores_orders)\n    #input()\n    # check stores\n    check = [0 for _ in range(n)]\n    i = 0\n    while i < n:\n        if stores[i][0] == 0:\n            check[i] = 0\n            i += 1\n        else:\n            for j in range(stores[i][0]):\n                check[i] = 0\n                #print(check[i], stores_orders[j], order[stores[i][0]-1])\n                if stores_orders[j] == order[stores[i][0]-1]:\n                    check[i] = 1\n                    i += 1\n                    break\n    #print(check)\n    #input()\n    if 1 not in check:\n        print(\"impossible\")\n        return\n    #input()\n    # check items\n    check_items = [0 for _ in range(m)]\n    for i in range(m):\n        check_items[i] = 0\n        for j in range(n):\n            if items[i] == stores[j][1]:\n                check_items[i] = 1\n                break\n    if 0 not in check_items:\n        print(\"impossible\")\n        return\n    #print(check_items)\n    #input()\n    # search\n    queue = []\n    queue.append(1)\n    while queue:\n        search = queue.pop(0)\n        #print(search)\n        #input()\n        for i in range(n):\n            if check[i] == search:\n                queue.append(stores_orders[i])\n                #print(queue)\n                #input()\n                for j in range(m):\n                    if check_items[j] == search:\n                        print(\"unique\")\n                        return\n                print(\"ambiguous\")\n                return\n    print(\"impossible\")\n    return"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return \"\""
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    1. Get the input from the user.\n    2. Declare the counter for stores and the list of items.\n    3. Initialize the flag to true.\n    4. Iterate through the items.\n    5. Add the items to the list.\n    6. Set the flag to false.\n    7. Create a new list which will store the stores the sister visited.\n    8. Iterate through the list of stores.\n    9. Check if the counter is equal to the size of the list. If it is, append the list of stores to the list of items.\n    10. Print the items.\n    11. Set the flag to true.\n    12. Return the flag.\n    '''\n    # Declare counter and the list of items\n    store = 0\n    items = []\n    \n    # Get the input from the user\n    n = int(stdin[0])\n    k = int(stdin[1])\n    \n    # Initialize the flag to true\n    flag = True\n    \n    # Iterate through the items\n    for i in range(k):\n        # Add the items to the list\n        items.append(stdin[i+2])\n    \n    # Set the flag to false\n    flag = False\n    \n    # Declare a new list which will store the stores the sister visited\n    stores = []\n    \n    # Iterate through the list of stores\n    for store in range(n):\n        # Check if the counter is equal to the size of the list\n        if store == len(items):\n            # If it is, append the list of stores to the list of items\n            items.append(stores)\n            \n            # Print the items\n            for i in items:\n                print(i)\n            \n            # Set the flag to true\n            flag = True\n            \n            # Break out of the loop\n            break\n        \n        # If the flag is true\n        if flag:\n            # Append the current store to the list of stores\n            stores.append(store)\n    \n    # If the flag is false\n    if not flag:\n        # Print the flag\n        print('impossible')\n    \n    # If the flag is true\n    else:\n        # Print the flag\n        print('unique')"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    # the number of stores in town\n    N = int(stdin)\n\n    # the inventory of all stores in the town\n    inventory = []\n\n    # the number of items that your sister bought\n    M = int(stdin)\n\n    # the list of items that your sister bought in the order\n    bought_items = []\n\n    # read the input of the store inventory and the list of items your sister bought\n    for _ in range(N):\n        inventory.append(stdin.readline())\n    for _ in range(M):\n        bought_items.append(stdin.readline())\n\n    # convert the input into a list of ints and a list of strings\n    inventory_int = []\n    inventory_string = []\n    for store in inventory:\n        inventory_int.append(int(store.split()[0]))\n        inventory_string.append(store.split()[1])\n\n    # convert the list of items that your sister bought to a set\n    bought_items_set = set(bought_items)\n\n    # the set of items that your sister has in inventory\n    inventory_set = set(inventory_string)\n\n    # check if the number of items that your sister has in inventory matches the number of items that she bought\n    if len(inventory_set)!= M:\n        return 'impossible'\n\n    # check if every item that your sister bought is in the inventory\n    for item in bought_items:\n        if item not in inventory_set:\n            return 'impossible'\n\n    # check if every item that your sister bought is in the inventory\n    for item in bought_items:\n        if item not in inventory_set:\n            return 'impossible'\n\n    # if this is the case, check if the items in the inventory are in the order of the items in the list of items your sister bought\n    if sorted(inventory_string) == sorted(bought_items):\n        return 'unique'\n    else:\n        return 'ambiguous'\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return solution(stdin)\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = []\n    for i in range(k):\n        s.append(stdin.readline().split())\n    # print(n, k, s)\n\n    store_id = [i for i in range(n)]\n    item = [s[i][0] for i in range(k)]\n    # print(store_id, item)\n\n    possible = True\n    for i in range(k):\n        if item[i] not in store_id:\n            possible = False\n\n    if possible:\n        print(\"unique\")\n    else:\n        # store_id = [0, 1, 2, 3]\n        # item = ['chocolate', 'icecream', 'cookies', 'chocolate']\n        # store_id = [0, 1, 2, 3]\n        # item = ['icecream', 'cookies', 'chocolate', 'chocolate']\n        # print(store_id, item)\n        for i in range(k):\n            if item[i] not in store_id:\n                store_id.append(item[i])\n                item[i] = 'N'\n        # print(store_id, item)\n\n        id = len(store_id) - 1\n        store_id = [i for i in range(id + 1)]\n        item = [s[i][0] for i in range(k)]\n        # print(store_id, item)\n\n        store_id_inv = {store_id[i]: i for i in range(len(store_id))}\n        # print(store_id_inv)\n\n        store_id_inv_rev = {i: store_id[i] for i in range(len(store_id))}\n        # print(store_id_inv_rev)\n\n        store_id_inv_rev_inv = {i: store_id_inv[store_id_inv_rev[i]] for i in range(len(store_id))}\n        # print(store_id_inv_rev_inv)\n\n        store_id = [store_id[i] for i in range(len(store_id))]\n        item = [item[i] for i in range(k)]\n        # print(store_id, item)\n\n        item_id = [i for i in range(len(item))]\n        # print(item_id)\n\n        item_id_inv = {item_id[i]: i for i in range(len(item_id))}\n        # print(item_id_inv)\n\n        item_id_inv_rev = {i: item_id[i] for i in range(len(item_id))}\n        # print(item_id_inv_rev)\n\n        item_id_inv_rev_inv = {i: item_id_inv[item_id_inv_rev[i]] for i in range(len(item_id))}\n        # print(item_id_inv_rev_inv)\n\n        # print(store_id)\n        # print(item)\n\n        def find_store(item):\n            if item == 'N':\n                return 0\n            else:\n                return store_id_inv_rev_inv[item_id_inv[item_id_inv_rev[item]]]\n\n        def find_store_inv(store):\n            if store == 0:\n                return 'N'\n            else:\n                return item_id_inv_rev[item_id_inv[store_id_inv[store]]]\n\n        # print(find_store('chocolate'))\n        # print(find_store_inv(0))\n\n        for i in range(k):\n            if store_id[i]!= find_store(item[i]):\n                store_id[i] = find_store(item[i])\n\n        # print(store_id)\n\n        for i in range(len(item)):\n            item[i] = find_store_inv(store_id[i])\n        # print(item)\n\n        if len(set(item)) == 1:\n            print(\"unique\")\n        elif len(set(item)) > 1:\n            print(\"ambiguous\")\n        else:\n            print(\"impossible\")\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_of_supermarkets = int(stdin.readline().rstrip())\n    num_of_items = int(stdin.readline().rstrip())\n    item_list = stdin.readline().rstrip().split()\n    num_of_items_visited = int(stdin.readline().rstrip())\n    store_visited = stdin.readline().rstrip().split()\n\n    store_dict = {}\n    for i in range(num_of_items):\n        store_dict[store_visited[i]] = i\n\n    # index = 0\n    # while index < num_of_items_visited:\n    #     print(index, store_visited[index])\n    #     index += 1\n\n    # for i in range(num_of_items_visited):\n    #     print(store_visited[i])\n\n    store_visited_number = [i for i in range(num_of_supermarkets)]\n\n    def find_path(store_visited_number, store_dict, item_list, store_visited):\n        # print(store_visited_number)\n        # print(store_dict)\n        # print(item_list)\n        # print(store_visited)\n\n        current_store = store_visited[-1]\n        if len(store_visited) == num_of_items_visited:\n            return\n\n        if current_store in store_dict:\n            item_index = store_dict[current_store]\n            # print(item_index)\n            # print(item_list)\n            item = item_list[item_index]\n            item_list.pop(item_index)\n            store_visited_number.append(current_store)\n            # print(store_visited_number)\n            # print(store_dict)\n            # print(item_list)\n            # print(store_visited)\n\n            for store_number in store_visited_number:\n                # print(store_number)\n                if store_number < num_of_supermarkets:\n                    if store_number not in store_dict:\n                        store_visited_number.pop()\n                        find_path(store_visited_number, store_dict, item_list, store_visited)\n                        store_visited_number.append(store_number)\n                    elif store_dict[store_number] < len(item_list) and store_dict[store_number] >= 0:\n                        store_visited_number.pop()\n                        item_index = store_dict[store_number]\n                        item = item_list[item_index]\n                        item_list.pop(item_index)\n                        store_visited_number.append(store_number)\n                        # print(store_visited_number)\n                        # print(store_dict)\n                        # print(item_list)\n                        # print(store_visited)\n                        # print(item)\n                        find_path(store_visited_number, store_dict, item_list, store_visited + [item])\n                        store_visited_number.pop()\n                        store_visited_number.append(current_store)\n                        item_list.insert(item_index, item)\n                        # print(store_visited_number)\n                        # print(store_dict)\n                        # print(item_list)\n                        # print(store_visited)\n                        # print(item)\n\n    # find_path(store_visited_number, store_dict, item_list, store_visited)\n    # print(store_visited_number)\n    # print(store_dict)\n    # print(item_list)\n    # print(store_visited)\n    # print(item)\n    if len(store_visited) == num_of_items_visited:\n        return 'unique'\n    elif len(store_visited) == 0:\n        return 'impossible'\n    else:\n        return 'ambiguous'\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # words: list[str] = list(stdin)\n    # first: int = int(words[0])\n    # second: int = int(words[1])\n    # third: int = int(words[2])\n    # return str(f(first, second, third))\n    return str(f(int(stdin[0]), int(stdin[1]), int(stdin[2])))\n    # Your solution here\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    length, value, mod = stdin.split(' ')\n    length, value, mod = int(length), int(value), int(mod)\n    s = set()\n    def f(word, idx):\n        if idx == length:\n            s.add(value)\n            return\n        f(word + chr(97 + (ord(word[idx]) + 1) % 26), idx + 1)\n        f(word + chr(97 + (ord(word[idx]) - 1) % 26), idx + 1)\n        f(word + chr(ord(word[idx]) + 1), idx + 1)\n    f('', 0)\n    return str(len(s))\n\nprint(solution(stdin))"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = (int(x) for x in stdin.split())\n\n    result = 0\n    for i in range(1, N + 1):\n        if f(i, M) == K:\n            result += 1\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split(\" \")[2])\n    k = int(stdin.split(\" \")[1])\n    n = int(stdin.split(\" \")[0])\n    print(bin(k)[2:].zfill(m))\n    return bin(k)[2:].zfill(m)"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    \n    return str(bin(K ^ (sum(((M ** i) * int(c) for i, c in enumerate(stdin[0].lower()))) % 2**M))[2:]).count('1')\n    \n    \n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.readline().split())\n    k = bin(k)[2:]\n    print(k.count('1'))\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    return N - len([1 for i in range(N) if (int(hashlib.sha1(i.encode('utf-8')).hexdigest(), 16) % M) == K])"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_of_words = int(stdin.split(\" \")[0])\n    max_num_of_letters = int(stdin.split(\" \")[1])\n    max_num_of_letters_hash = int(stdin.split(\" \")[2])\n    \n    return str(solution_calculate_number_of_words(num_of_words, max_num_of_letters, max_num_of_letters_hash))\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    res = 0\n    for i in range(1, N+1):\n        k = 0\n        for j in range(i):\n            k = (k * 33 + (ord(stdin[j]) % 64)) % (1 << M)\n        if k == K:\n            res += 1\n    return str(res)\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('.XX.....')\n    '3 zoom out'\n    >>> solution('...X.....X......X............')\n    '3 zoom out'\n    >>> solution('...X.....X......X............X.....X.......X')\n    '3 rotate clockwise'\n    >>> solution('...X.....X......X............X.....X.......X..')\n    '3 rotate clockwise'\n    >>> solution('...X.....X......X............X.....X.......X...')\n    '3 rotate clockwise'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    image_1, image_2 = stdin.split(\"\\n\\n\")\n    image_1, image_2 = image_1.split(\"\\n\"), image_2.split(\"\\n\")\n    width = len(image_1[0])\n    height = len(image_1)\n    image_1 = {(x, y): image_1[y][x] for y in range(height) for x in range(width) if image_1[y][x]!= \".\"}\n    image_2 = {(x, y): image_2[y][x] for y in range(height) for x in range(width) if image_2[y][x]!= \".\"}\n    set_1 = set(image_1.keys())\n    set_2 = set(image_2.keys())\n    common = set_1 & set_2\n    initial_grip = Grip(image_1, common)\n    final_grip = Grip(image_2, common)\n    pan_distance = distance(initial_grip, final_grip)\n    zoom_distance = abs(final_grip.spread - initial_grip.spread)\n    rotate_distance = distance(initial_grip, final_grip, rotate=True)\n    rotate_sign = np.sign(final_grip.rotation - initial_grip.rotation)\n    if pan_distance <= zoom_distance and pan_distance <= rotate_distance:\n        if rotate_sign < 0:\n            return \"1 rotate CW\"\n        else:\n            return \"1 rotate CCW\"\n    elif zoom_distance <= pan_distance and zoom_distance <= rotate_distance:\n        if rotate_sign < 0:\n            return \"2 zoom out\"\n        else:\n            return \"2 zoom in\"\n    else:\n        if rotate_sign < 0:\n            return \"3 pan right\"\n        else:\n            return \"3 pan left\"\n\n\nclass Grip:\n    def __init__(self, image: dict, common: set) -> None:\n        self.image = image\n        self.common = common\n        self.all_grip_points = self._get_all_grip_points()\n        self.spread = self._get_spread()\n        self.rotation = self._get_rotation()\n\n    def __repr__(self) -> str:\n        return f\"spread: {self.spread}, rotation: {self.rotation}\"\n\n    def _get_all_grip_points(self) -> set:\n        all_grip_points = set()\n        for x, y in self.common:\n            for dx, dy in DIRECTIONS:\n                new_x = x + dx\n                new_y = y + dy\n                if self._is_valid_coord(new_x, new_y):\n                    all_grip_points.add((new_x, new_y))\n        return all_grip_points\n\n    def _get_spread(self) -> float:\n        return np.mean(self.image.values())\n\n    def _get_rotation(self) -> float:\n        x_rotations = {x: np.abs(self.image[(x, y)] - self.image[(x + 1, y)]) for x, y in self.common}\n        y_rotations = {y: np.abs(self.image[(x, y)] - self.image[(x, y + 1)]) for x, y in self.common}\n        return np.mean([x_rotations[x] + y_rotations[y] for x, y in self.common])\n\n    @staticmethod\n    def _is_valid_coord(x: int, y: int) -> bool:\n        return 0 <= x < 15 and 0 <= y < 30\n\n\nDIRECTIONS = ((0, -1), (-1, 0), (0, 1), (1, 0))\n\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the two images from the standard input and returns the gesture, direction, and distance.\n\n    Args:\n        stdin (str): The two images of the form:\n            X.....................................\n            X.....................................\n           .X.....................................\n           .X.....................................\n           .X.....................................\n           .X.....................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           .......X........................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X..................................\n           ......XX........X........"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return answer"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    touches = [list(stdin.split(\"\\n\")[i]) for i in range(N)]\n    pan, zoom, rotate = 0, 0, 0\n    pan_count, zoom_count, rotate_count = 0, 0, 0\n    for i in range(N):\n        for j in range(i, N):\n            pan += touches[i][j]!= 'X'\n            zoom += touches[i][j]!= 'X'\n            rotate += touches[i][j]!= '.'\n            pan_count += touches[i][j]!= 'X'\n            zoom_count += touches[i][j]!= 'X'\n            rotate_count += touches[i][j]!= '.'\n    pan /= pan_count\n    zoom /= zoom_count\n    rotate /= rotate_count\n    pan, zoom, rotate = int(pan*1000) / 1000, int(zoom*1000) / 1000, int(rotate*1000) / 1000\n    print(pan, 'pan') if pan > zoom else print(zoom, 'zoom') if zoom > rotate else print(rotate, 'rotate')\n    return ''"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    a = stdin.splitlines()\n    i = 0\n    while i < len(a):\n        if a[i].strip() == \"\":\n            i += 1\n            continue\n        num = int(a[i])\n        i += 1\n        x = []\n        while i < len(a) and a[i].strip()!= \"\":\n            x.append(a[i])\n            i += 1\n        x = [list(map(lambda z: 0 if z == '.' else 1, line)) for line in x]\n        y = []\n        for line in x:\n            y.append([0 if z == 0 else 1 for z in line])\n        print(x)\n        print(y)\n        return \"\"\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes in two strings of the same length and returns\n    a string of the same length that represents the gesture.\n    '''\n    pass"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A naive solution.\n    '''\n    # load the input string\n    lines = stdin.strip().split('\\n')\n    # initialize the pan count\n    pan_count = 0\n    # initialize the pan distance\n    pan_distance = 0\n    # initialize the pan gesture\n    pan_gesture = ''\n    # initialize the zoom gesture\n    zoom_gesture = ''\n    # initialize the pan gesture direction\n    pan_direction = ''\n    # initialize the zoom gesture direction\n    zoom_direction = ''\n    # initialize the pan gesture distance\n    pan_distance = 0\n    # initialize the zoom gesture distance\n    zoom_distance = 0\n    # initialize the initial and final grip spread\n    grip_spread = 0\n    # initialize the initial and final grip rotation\n    grip_rotation = 0\n    # initialize the initial and final gesture rotation\n    gesture_rotation = 0\n    # initialize the number of touches\n    num_touches = 0\n    # initialize the pan gesture direction\n    pan_direction = ''\n    # initialize the pan gesture distance\n    pan_distance = 0\n    # initialize the pan gesture distance\n    zoom_distance = 0\n    # initialize the initial and final gesture rotation\n    gesture_rotation = 0\n    # iterate through the lines\n    for i in range(len(lines)):\n        # split the line into a list of pixels\n        pixels = lines[i].split()\n        # iterate through the list of pixels\n        for j in range(len(pixels)):\n            # check if the pixel is a touch\n            if pixels[j] == 'X':\n                # increment the number of touches\n                num_touches += 1\n                # check if we are in the first or last line\n                if i == 0 or i == len(lines) - 1:\n                    # increment the pan distance\n                    pan_distance += 1\n                    # check if we are in the first line\n                    if i == 0:\n                        # increment the pan gesture\n                        pan_count += 1\n                        pan_gesture += 'pan'\n                        pan_direction = 'out'\n                    # check if we are in the last line\n                    elif i == len(lines) - 1:\n                        # increment the pan gesture\n                        pan_count += 1\n                        pan_gesture += 'pan'\n                        pan_direction = 'in'\n                # check if we are in the first column\n                if j == 0:\n                    # increment the zoom gesture\n                    zoom_count += 1\n                    zoom_gesture += 'zoom'\n                    zoom_direction = 'out'\n                # check if we are in the last column\n                elif j == len(pixels) - 1:\n                    # increment the zoom gesture\n                    zoom_count += 1\n                    zoom_gesture += 'zoom'\n                    zoom_direction = 'in'\n    # check if we have at least one pan gesture\n    if pan_count >= 1:\n        # check if we have at least one zoom gesture\n        if zoom_count >= 1:\n            # check if we have at least one rotation gesture\n            if gesture_rotation >= 0:\n                # check if we have at least one pan gesture\n                if pan_count >= 1:\n                    # check if we have at least one zoom gesture\n                    if zoom_count >= 1:\n                        # check if we have at least one rotation gesture\n                        if gesture_rotation >= 0:\n                            # check if we have at least one pan gesture\n                            if pan_count >= 1:\n                                # check if we have at least one zoom gesture\n                                if zoom_count >= 1:\n                                    # check if the pan distance is greater than the zoom distance\n                                    if pan_distance > zoom_distance:\n                                        # check if the zoom distance is greater than the pan distance\n                                        if zoom_distance > pan_distance:\n                                            # check if the pan gesture is pan\n                                            if pan_gesture == 'pan':\n                                                # check if the zoom gesture is zoom out\n                                                if zoom_gesture == 'zoom out':\n                                                    # check if the pan gesture is out\n                                                    if pan_direction == 'out':\n                                                        # print the number of touches and the pan gesture\n                                                        print(pan_count)\n                                                        print('pan'+ pan_gesture)\n                                                        # check if the zoom gesture is out\n                                                        if zoom_direction == 'out':\n                                                            # check if the pan gesture is out\n                                                            if pan_direction == 'out':\n                                                                # print the number of touches and the pan gesture\n                                                                print(pan_count)\n                                                                print('pan'+ pan_gesture)\n                                                                # print the number of touches and the zoom gesture\n                                                                print(zoom_count)\n                                                                print('zoom'+ zoom_gesture)\n                                                            # check if the pan gesture is in\n                                    "
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    sample_input = stdin.split('\\n')\n    i, f = sample_input[0].split('\\t'), sample_input[1].split('\\t')\n\n    # sample input parsing\n    # for i, fi in enumerate(i):\n    #     for fj in f:\n    #         fi = fi.replace('.', '')\n    #         fj = fj.replace('.', '')\n    #         if fi.count('X') == fj.count('X'):\n    #             print('zoom', f'{i + 1}-{j + 1}')\n    #         elif fi.count('X') > fj.count('X'):\n    #             print('pan', f'{i + 1}-{j + 1}')\n    #         else:\n    #             print('rotate', f'{i + 1}-{j + 1}')\n\n    # TLE\n    # import collections\n    # cnt = collections.Counter()\n    # for i, fi in enumerate(i):\n    #     fi = fi.replace('.', '')\n    #     for fj in f:\n    #         fj = fj.replace('.', '')\n    #         fi = [i for i in fi]\n    #         fj = [j for j in fj]\n    #         fi.extend(fj)\n    #         fi = list(set(fi))\n    #         if fi.count('X') == 1:\n    #             cnt[0] += 1\n    #         elif fi.count('X') == 2:\n    #             cnt[1] += 1\n    #         elif fi.count('X') == 3:\n    #             cnt[2] += 1\n    #         elif fi.count('X') == 4:\n    #             cnt[3] += 1\n    #         elif fi.count('X') == 5:\n    #             cnt[4] += 1\n    #         fi = [i for i in fi if i!= 'X']\n    #         fi = [i for i in fi if i!= '.']\n    #         fi = ''.join(fi)\n    #         cnt[fi] += 1\n    #         cnt[fi] += 1\n    # for key, value in cnt.items():\n    #     if value == 2:\n    #         print('zoom', key)\n    #     elif value == 3:\n    #         print('pan', key)\n    #     elif value == 4:\n    #         print('rotate', key)\n\n    # AC\n    import numpy as np\n    dic = {}\n    for i, fi in enumerate(i):\n        fi = fi.replace('.', '')\n        for fj in f:\n            fj = fj.replace('.', '')\n            fi = [i for i in fi]\n            fj = [j for j in fj]\n            fi.extend(fj)\n            fi = list(set(fi))\n            if fi.count('X') == 1:\n                dic[0] = np.array([i for i in fi if i!= 'X'], dtype=np.float)\n            elif fi.count('X') == 2:\n                dic[1] = np.array([i for i in fi if i!= 'X'], dtype=np.float)\n            elif fi.count('X') == 3:\n                dic[2] = np.array([i for i in fi if i!= 'X'], dtype=np.float)\n            elif fi.count('X') == 4:\n                dic[3] = np.array([i for i in fi if i!= 'X'], dtype=np.float)\n            elif fi.count('X') == 5:\n                dic[4] = np.array([i for i in fi if i!= 'X'], dtype=np.float)\n            fi = [i for i in fi if i!= 'X']\n            fi = [i for i in fi if i!= '.']\n            fi = ''.join(fi)\n            dic[fi] = dic.get(fi, 0) + 1\n    for key, value in dic.items():\n        if value == 2:\n            print('zoom', key)\n        elif value == 3:\n            print('pan', key)\n        elif value == 4:\n            print('rotate', key)\n\n    # itertools\n    # from itertools import combinations, permutations\n    # import numpy as np\n    # for i, fi in enumerate(i):\n    #     fi = fi.replace('.', '')\n    #     fi = [i for i in fi]\n    #     fi = list(set(fi))\n    #     fi.extend(list(set(f[i])))\n    #     if 'X' in fi:\n    #         fi.remove('X')\n    #     for i in range(len(fi), 1, -1):\n    #         for l"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Stdin: str\n    Doctest:\n    >>> solution(\"8 20\\n apples are great!  \\n++++++++++++++++++++\\n+ oranges are      +\\n+ way better!      +\\n+ #oranges>apples  +\\n++++++++++++++++++++\\n check out our\\n fresh apples!\")\n    apples are great!  \n    ++++++++++++++++++++\n    + oranges are      +\n    + way better!      +\n    + #oranges>apples  +\n    ++++++++++++++++++++\n     check out our\n    fresh apples!\n    \"\"\"\n    # split rows into chars\n    lines = stdin.splitlines()\n    # get width and height\n    width, height = lines[0].split(' ')\n    width = int(width)\n    height = int(height)\n    # get matrix of the page\n    matrix = []\n    for i in range(1, len(lines)):\n        matrix.append(list(lines[i]))\n    # loop through each row\n    for row in range(height):\n        # loop through each column\n        for col in range(width):\n            # if char is '$' and is not in matrix or on the border of the page\n            if matrix[row][col] == '$' and not (row == 0 and col == 0) and not (row == 0 and col == width - 1) and not (row == height - 1 and col == 0) and not (row == height - 1 and col == width - 1):\n                # loop through each of the 8 surrounding chars\n                for i in range(3):\n                    # if char is not in matrix or on the border of the page and is not '#'\n                    if not (row - 1 + i < 0 or row - 1 + i >= height or col - 1 + i < 0 or col - 1 + i >= width or matrix[row - 1 + i][col - 1 + i] == '#'):\n                        # if char is not '#'\n                        if matrix[row - 1 + i][col - 1 + i]!= '#':\n                            # set char as a border\n                            matrix[row - 1 + i][col - 1 + i] = '#'\n                # set char to''\n                matrix[row][col] =''\n    # concatenate lines to string\n    s = ''\n    for line in matrix:\n        s += ''.join(line) + '\\n'\n    return s[:-1]\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    count = 0\n    for line in stdin.split(\"\\n\")[:-1]:\n        for i in range(w):\n            if line[i] in [\" \", \"?\", \"!\", \",\", \".\", \"\\n\"]:\n                count += 1\n    return \" \" * count\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the smallest image that contains the banned characters.\n    \n    Args:\n        stdin (str): Input string.\n    \n    Returns:\n        str: Output string.\n    \"\"\"\n    \n    stdout = ''\n    # height = int(stdin[0])\n    # width = int(stdin[1])\n    \n    # for i in range(height):\n    #     stdout += stdin[i + 2]\n    \n    # print(stdout)\n    # print(len(stdout))\n    \n    return stdout\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    lines = stdin.splitlines()\n    H = int(lines[0].split()[0])\n    W = int(lines[0].split()[1])\n    \n    #generate string to hold processed image\n    img = \"\"\n    \n    for i in range(1,len(lines)):\n        for j in range(0,W):\n            img += lines[i][j]\n            \n    #convert img to list of characters\n    chars = list(img)\n    \n    #loop through each character in img\n    for char in chars:\n        #add char to output if it is not a whitespace or border\n        if char!= \" \" and char!= \"$\" and char!= \"+\":\n            #get coordinates of border and add to coordinate list\n            x = [i for i in range(len(img)) if img[i] == char]\n            for coord in x:\n                #find minimum and maximum coordinates of border\n                min_coord = min(coord, coord + 1, coord + 2, coord + 3)\n                max_coord = max(coord, coord + 1, coord + 2, coord + 3)\n                \n                #check if border is contained inside another border\n                for border in range(min_coord, max_coord):\n                    if border in range(0, len(img)):\n                        if img[border] == \"=\":\n                            #set current border to whitespace\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n                        elif img[border] == \">\":\n                            #set current border to whitespace\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n                        elif img[border] == \"+\":\n                            #set current border to whitespace\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n                            \n            \n            #get coordinate of image to remove\n            x = [i for i in range(len(img)) if img[i] == char]\n            for coord in x:\n                #find minimum and maximum coordinates of image\n                min_coord = min(coord, coord + 1, coord + 2, coord + 3)\n                max_coord = max(coord, coord + 1, coord + 2, coord + 3)\n                \n                #check if image is contained inside another image\n                for border in range(min_coord, max_coord):\n                    if border in range(0, len(img)):\n                        if img[border] == \"=\":\n                            #remove image from img\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n                        elif img[border] == \">\":\n                            #remove image from img\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n                        elif img[border] == \"+\":\n                            #remove image from img\n                            img = img[:border] + \" \" + img[border + 1:]\n                            \n        \n    #convert img to string\n    img = ''.join(img)\n    return img\n    \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"8 20\\\\n apples are great!  \\\\n++++++++++++++++++++\\\\n+ oranges are      +\\\\n+ way better!      +\\\\n+ #oranges>apples  +\\\\n++++++++++++++++++++\\\\n check out our      fresh apples!\\\\n\")\n    'apples are great!  \\\\n++++++++++++++++++++\\\\n+ oranges are      +\\\\n+ way better!      +\\\\n+ #oranges>apples  +\\\\n++++++++++++++++++++\\\\n check out our      fresh apples!\\\\n'\n    \"\"\"\n    H, W = map(int, stdin.split())\n    matrix = [[' '] * W for _ in range(H)]\n    start = 0\n    for line in stdin.splitlines()[1:]:\n        end = start + W\n        for idx, char in enumerate(line):\n            if char == '+':\n                matrix[start][end - 1] = '+'\n                matrix[start + 1][end - 1] = '+'\n                matrix[start + 1][end] = '+'\n                matrix[start + 1][end - 2] = '+'\n                matrix[start + 2][end - 1] = '+'\n                matrix[start + 2][end] = '+'\n                matrix[start + 2][end - 2] = '+'\n            elif char == '=':\n                matrix[start][end - 1] = '='\n                matrix[start + 1][end - 1] = '='\n                matrix[start + 1][end] = '='\n                matrix[start + 1][end - 2] = '='\n                matrix[start + 2][end - 1] = '='\n                matrix[start + 2][end] = '='\n                matrix[start + 2][end - 2] = '='\n            elif char == '>':\n                matrix[start][end - 1] = '>'\n                matrix[start + 1][end - 1] = '>'\n                matrix[start + 1][end] = '>'\n                matrix[start + 1][end - 2] = '>'\n                matrix[start + 2][end - 1] = '>'\n                matrix[start + 2][end] = '>'\n                matrix[start + 2][end - 2] = '>'\n            else:\n                matrix[start][end - 1] = char\n        start += 1\n    return '\\n'.join(''.join(row) for row in matrix)\n\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the solution to the problem\n    '''\n    return ''.join(stdin.split('\\n')[1:])\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This problem contains 3 subtasks.\n\n    Task 1: If all the lines have exactly one character, return the character.\n    Task 2: If all the lines have more than one character, return a space.\n    Task 3: If there are any lines containing no characters, return a space.\n\n    \"\"\"\n\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the string without the appended characters.\"\"\"\n    string: str = stdin\n    lines: List[str] = string.split('\\n')\n    H: int = int(lines[0])\n    W: int = int(lines[1])\n    # check if each line has the right length\n    if len(lines)!= H + 2:\n        raise Exception(\"The number of lines does not match\")\n    if W < 3:\n        raise Exception(\"At least 3 characters in each line is required\")\n\n    # convert to array of strings\n    board: List[str] = lines[2:H + 2]\n    # initialise board\n    board_copy: List[str] = board.copy()\n    # remove empty lines\n    board_copy = [line for line in board_copy if line!= '']\n    # remove empty strings from board\n    board = [line for line in board if line!= '']\n\n    # loop through board\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            # check for characters\n            if not is_ascii(board[r][c]):\n                raise Exception(f\"Found non-ASCII character at ({r},{c})\")\n\n    # check for duplicates\n    if len(board)!= len(set(board)):\n        raise Exception(\"Duplicate characters found\")\n    if len(board)!= len(board_copy):\n        raise Exception(\"Duplicate characters found\")\n\n    # initialise board\n    board: List[List[str]] = [['' for _ in range(W)] for _ in range(H)]\n\n    # insert characters\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            board[r][c] = board_copy[r][c]\n\n    # replace spaces with border\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            if board[r][c] =='':\n                board[r][c] = '+'\n\n    # remove characters outside border\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            if not is_inside_border(board, r, c):\n                board[r][c] =''\n\n    # remove duplicate border characters\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            if is_border(board, r, c):\n                board[r][c] =''\n\n    # replace border with '+'\n    for r in range(len(board)):\n        for c in range(len(board[r])):\n            if is_border(board, r, c):\n                board[r][c] = '+'\n\n    # convert to string\n    board: str = '\\n'.join([''.join(line) for line in board])\n    return board\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''8 20\n    ... apples are great!\n    ... + oranges are\n    ... + way better!\n    ... + #oranges>apples\n    ... check out our\n    ... fresh apples!\n    ... ''')\n    'apples are great!  \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    (h, w) = (int(line.split()[0]) for line in stdin.splitlines())\n    page = [line for line in stdin.splitlines()][1:]\n    \n    # Get the border of the page.\n    border = []\n    for i in range(len(page)):\n        for j in range(len(page[0])):\n            if page[i][j] == '+':\n                border.append((i, j))\n                \n    # Use DFS to traverse all the border images.\n    def traverse(img: list, i: int, j: int) -> None:\n        if img[i][j]!= '+':\n            return\n        \n        # Traverse all the characters.\n        img[i][j] =''\n        if i + 1 < len(img):\n            traverse(img, i + 1, j)\n        if i - 1 >= 0:\n            traverse(img, i - 1, j)\n        if j + 1 < len(img[0]):\n            traverse(img, i, j + 1)\n        if j - 1 >= 0:\n            traverse(img, i, j - 1)\n            \n    # Traverse all the border images and mark the border with '$+$'.\n    for i, j in border:\n        traverse(page, i, j)\n        \n    # Traverse all the images again and remove the border characters.\n    def remove(img: list) -> None:\n        for i in range(len(img)):\n            for j in range(len(img[0])):\n                if img[i][j] =='':\n                    img[i][j] = '+'\n        for i in range(len(img) - 1, -1, -1):\n            for j in range(len(img[0]) - 1, -1, -1):\n                if img[i][j] =='':\n                    img[i][j] = '+'\n                    \n    remove(page)\n    \n    # Replace all the characters with whitespaces.\n    for line in page:\n        print(''.join(line))\n    \n    return ''\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 1:\n        return 'T' * (n // 2) + 'H' + 'T' * (n // 2)\n    elif n % 2 == 0:\n        return 'H' * n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\"your-answer\"\"\""
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of operations until a sequence stops.\n\n    >>> solution(\"HH\")\n    '2.0'\n    >>> solution(\"H?\")\n    '1.5'\n    \"\"\"\n    seq = stdin.split()\n    return str(sum(i.count(\"H\") == i.count(\"T\") for i in seq))\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the average number of operations before Tuy stops.\n\n    >>> solution(\"HH\")\n    '2.0'\n    >>> solution(\"H?H\")\n    '1.5'\n    \"\"\"\n\n    return str(average_operations(stdin))\n\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the number of operations before Gon stops\n    \"\"\"\n    possible_symbols = stdin.split('?')\n    sum_of_operations = 0\n    for i, symbol in enumerate(possible_symbols):\n        if symbol == 'H':\n            sum_of_operations += i + 1\n    return sum_of_operations\n\nprint(solution('HH?HTTTTH'))"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return str(math.ceil(int(stdin) / 2))\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the average value of the number of iterations to solve the harder problem.\"\"\"\n    return str(0.5)\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split(\"\\n\")[0]\n    if len(line) == 0:\n        return\n    if len(line) > 1000:\n        return\n    line = line.replace(\"?\", \"H\")\n    return str(len(line))\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin.count(\"H\") / stdin.count(\"T\"))\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.strip().split('\\n')\n    size = int(input[0])\n    image = input[1:]\n    image = [list(row) for row in image]\n\n    def color(image, i, j, color):\n        if (i < 0) or (i >= len(image)) or (j < 0) or (j >= len(image[i])):\n            return\n        if image[i][j] == color:\n            return\n        image[i][j] = color\n        color(image, i+1, j, color)\n        color(image, i, j+1, color)\n        color(image, i-1, j, color)\n        color(image, i, j-1, color)\n\n    def is_color(image, i, j):\n        if (i < 0) or (i >= len(image)) or (j < 0) or (j >= len(image[i])):\n            return False\n        return image[i][j] == 1\n\n    def count_color(image, i, j):\n        count = 0\n        if is_color(image, i, j):\n            count += 1\n        count += count_color(image, i+1, j)\n        count += count_color(image, i-1, j)\n        count += count_color(image, i, j+1)\n        count += count_color(image, i, j-1)\n        return count\n\n    colors = {(i, j): count_color(image, i, j) for i in range(size) for j in range(size)}\n    best = min(colors.values())\n    ans = []\n    for i in range(size):\n        for j in range(size):\n            if colors[(i, j)] == best:\n                color(image, i, j, 1)\n                ans.append(''.join(['1' if c == 1 else '0' for c in image[i]]))\n    return ans"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    print(solve(stdin))\n    return ''\n\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    p = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    res = -1\n    def dfs(i, j):\n        nonlocal res\n        if i + 1 == n and j + 1 == n:\n            if dp[i][j] == 0:\n                res = min(res, sum(p[i][j] == p[i][j+1] == p[i+1][j] == p[i+1][j+1] for i in range(n-1) for j in range(n-1)))\n            return\n        if j + 1 < n: dp[i][j] += (p[i][j] == p[i][j+1])\n        if i + 1 < n: dp[i][j] += (p[i][j] == p[i+1][j])\n        if j + 1 < n and i + 1 < n: dp[i][j] += (p[i][j] == p[i+1][j] == p[i][j+1] == p[i+1][j+1])\n        if dp[i][j] == 0:\n            for x, y in (i+1, j), (i, j+1):\n                dfs(x, y)\n        else:\n            dfs(i+1, j)\n            dfs(i, j+1)\n            dfs(i+1, j+1)\n    dfs(0, 0)\n    return str(res) + '\\n' + '\\n'.join(''.join(map(str, p[i])) for i in range(n))\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin)\n\n    def paint(i, j):\n        if i == size or j == size:\n            return\n        if A[i][j]:\n            return paint(i + 1, j) or paint(i, j + 1)\n        if not A[i][j]:\n            return paint(i + 1, j) and paint(i, j + 1)\n\n    A = [list(map(int, list(stdin))) for stdin in zip(*[iter(stdin)] * size)]\n\n    result = 0\n    for i in range(size):\n        for j in range(size):\n            if A[i][j]:\n                result += 1\n                if not paint(i + 1, j) and not paint(i, j + 1):\n                    A[i][j] = 0\n                    result -= 1\n\n    return str(result)\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #! Calculate how many squares we need to split the image into\n    #! I want to be able to split the image into 2x2 squares\n    #! Then I want to calculate the number of different values in each square\n    #! The difference is the amount of pixels that are different\n    size = stdin.split(\"\\n\")[0]\n    n = math.log(int(size), 2)\n\n    #! Create a new list to hold the image\n    #! The image is going to have nxn squares\n    #! Each square is going to hold one value from 0 to 1\n    new_list = []\n\n    #! I want to keep track of all the values in each square\n    #! It is going to hold a list of all the values\n    #! For the first square it is a list of only one item (the first value)\n    #! For the second square it is a list of four items (the first and second values)\n    #! For the third square it is a list of eight items (the first, second, third, and fourth values)\n    #! I want to have a list of the last square's values because it is the one that will have the minimum difference\n    #! And also because it's possible that the last square can contain two of the same values\n    #! Therefore, the first item in the list for the last square is the minimum difference between the first value and the last value\n    #! The remaining items are going to be the values in the last square\n    values = [0]\n\n    #! Going to fill up the list with n lists that each have n elements\n    #! This is going to be a list of lists\n    for i in range(0, int(n)):\n        new_list.append([])\n        for j in range(0, int(n)):\n            #! This is going to be the value of the square that is going to be appended to the list\n            value = randint(0, 1)\n            new_list[i].append(value)\n            values.append(value)\n\n    #! Calculate the difference between the squares\n    #! I want to keep track of the amount of different values in the list of values\n    #! I want to know how many of the items are the same and how many are different\n    #! The difference is the amount of different values\n    difference = 0\n    last_value_in_last_square = 0\n    last_values_in_last_square = []\n    for i in range(0, len(values)):\n        if values[i]!= last_values_in_last_square[0]:\n            difference += 1\n            last_value_in_last_square = values[i]\n            last_values_in_last_square = [last_value_in_last_square]\n        else:\n            last_values_in_last_square.append(values[i])\n\n    #! Since I have the number of different values I can now just output it\n    print(difference)\n\n    #! Output each square\n    for i in range(0, int(n)):\n        for j in range(0, int(n)):\n            print(new_list[i][j], end=\"\")\n        print()\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get picture size\n    size = int(stdin[0])\n    # set up an array of size of the picture\n    pixels = [int(x) for x in stdin[1:size+1]]\n    # set up a result array\n    result = []\n    # call recursive method\n    print(sum(solution2(pixels,result)))\n    #print(result)\n    return \"\".join(result)\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    grid = [[int(x) for x in stdin.splitlines()]]\n    for _ in range(1, 2 ** int(grid[0][0])):\n        temp = []\n        for row in grid:\n            temp.append([0] * len(row))\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    temp[i][j] = 1\n                else:\n                    temp[i][j] = 0\n        grid = temp\n    return '\\n'.join([''.join(['1' if x else '0' for x in y]) for y in grid])\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    paintings = []\n    for i in range(n):\n        paintings.append(stdin.split()[i])\n    size = int(math.log2(n))\n    return paint(paintings, size)\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    def is_valid(s: str):\n        return s == s[::-1]\n    \n    def f(s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        if is_valid(s):\n            return s[0] + f(s[1:])\n        else:\n            s1 = f(s[:len(s) // 2])\n            s2 = f(s[len(s) // 2:])\n            return '1' + s2 + s1 if s1[0] == '1' else s2 + s1 + '1'\n        \n    return f(stdin)"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    size = int(input_str[0])\n    masks = [bin(i)[2:].rjust(size, '0') for i in range(1 << size)]\n    input_str = [list(map(int, i)) for i in input_str]\n    input_str = input_str[1:]\n\n    def paint(mask, image):\n        if len(mask) == 1:\n            return image\n        if len(image)!= len(mask):\n            return None\n\n        image = list(map(int, image))\n        size = len(mask)\n\n        def get_mask(i):\n            return mask[i] if len(mask) > 1 else 0\n\n        def is_black(x, y):\n            return (image[x] & (1 << y)) >> y == 1\n\n        def is_white(x, y):\n            return not is_black(x, y)\n\n        def paint_white(x, y):\n            image[x] |= (1 << y)\n            return (image[x] & (1 << y)) >> y == 1\n\n        def paint_black(x, y):\n            image[x] &= ~(1 << y)\n            return (image[x] & (1 << y)) >> y == 1\n\n        def sub_paint(mask, image):\n            if len(mask) == 1:\n                return image\n            if len(image)!= len(mask):\n                return None\n\n            image = list(map(int, image))\n            size = len(mask)\n            for i in range(size):\n                for j in range(size):\n                    if mask[i] == '0':\n                        if is_black(i, j):\n                            image[i] = paint_white(i, j)\n                    elif mask[i] == '1':\n                        if is_white(i, j):\n                            image[i] = paint_black(i, j)\n            return image\n\n        for i in range(size):\n            for j in range(size):\n                if is_black(i, j):\n                    image = sub_paint('11', image)\n                elif is_white(i, j):\n                    image = sub_paint('10', image)\n        return image\n\n    paint_masks = {''.join(mask): paint(mask, input_str) for mask in masks}\n    min_diff = float('inf')\n    min_mask = None\n    for mask in paint_masks:\n        diff = 0\n        for i in range(len(input_str)):\n            for j in range(len(input_str[0])):\n                if paint_masks[mask][i]!= input_str[i][j]:\n                    diff += 1\n        if diff < min_diff:\n            min_diff = diff\n            min_mask = mask\n    return min_mask"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Determines the number of pixels that will be on during the whole duration of the current.\n    \"\"\"\n    pass"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get the n input\n    n = int(stdin.split()[0])\n\n    # the list of n lists of lists\n    # each list in the list of lists represent one pulse\n    # the list of lists represents all the pulses\n    pulses = []\n\n    # loop through n times\n    for _ in range(n):\n        # get the pulse from stdin\n        pulse = stdin.split()[1:]\n\n        # add the pulse to the list of pulses\n        pulses.append(pulse)\n\n    # get the max height of panel\n    max_height = 0\n    for pulse in pulses:\n        # get the height of pulse\n        height = pulse[3]\n\n        # if the height of the pulse is higher than the max height\n        # update the max height\n        if height > max_height:\n            max_height = height\n\n    # get the max width of panel\n    max_width = 0\n    for pulse in pulses:\n        # get the width of pulse\n        width = pulse[2]\n\n        # if the width of the pulse is higher than the max width\n        # update the max width\n        if width > max_width:\n            max_width = width\n\n    # get the total number of pixels in the panel\n    num_pixels = max_height * max_width\n\n    # create an empty list of all 0s\n    grid = [[0 for _ in range(max_width)] for _ in range(max_height)]\n\n    # for each pulse\n    for pulse in pulses:\n        # get the pulse direction\n        direction = pulse[0]\n\n        # get the pulse height\n        height = pulse[3]\n\n        # get the pulse width\n        width = pulse[2]\n\n        # get the pulse wire number\n        wire_num = pulse[4]\n\n        # get the first index of the horizontal pulse\n        if direction == 'h':\n            # set the first index of the horizontal pulse\n            horizontal_first_index = width - 1\n        # get the first index of the vertical pulse\n        else:\n            # set the first index of the vertical pulse\n            vertical_first_index = height - 1\n\n        # for each pixel in the vertical pulse\n        for pixel_y in range(vertical_first_index, -1, -1):\n            # get the pixel y\n            pixel_y = pixel_y\n\n            # get the pixel x\n            for pixel_x in range(horizontal_first_index, -1, -1):\n                # get the pixel x\n                pixel_x = pixel_x\n\n                # if the pixel is not zero\n                if grid[pixel_y][pixel_x]!= 0:\n                    # set the grid to 1\n                    grid[pixel_y][pixel_x] = 1\n\n    # set the num_activated variable\n    num_activated = 0\n\n    # for each row in the grid\n    for row in grid:\n        # for each column in the row\n        for column in row:\n            # add 1 to the num_activated variable if the column is equal to 1\n            if column == 1:\n                num_activated += 1\n\n    # return the number of activated pixels\n    return num_activated\n\n\ndef"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This problem can be solved in multiple ways:\n        1. \n        2.\n        3.\n        4.\n    \"\"\""
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    print(\"Not Implemented\")\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    hv, time, lenth, index = stdin.split()\n    pulse = stdin.split()\n    # print(hv)\n    # print(time)\n    # print(lenth)\n    # print(index)\n    # print(pulse)\n    if hv[0] == \"h\":\n        if hv[1] == \"1\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]) + 9:\n                    return int(lenth[1:]) - pulse[0][2]\n        if hv[1] == \"5\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]) + 9:\n                    return int(lenth[1:]) - pulse[0][2]\n        if hv[1] == \"10\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n    elif hv[0] == \"v\":\n        if hv[1] == \"1\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]) + 9:\n                    return int(lenth[1:]) - pulse[0][2]\n        if hv[1] == \"5\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]) + 9:\n                    return int(lenth[1:]) - pulse[0][2]\n        if hv[1] == \"10\":\n            if time[0] == \"1\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"5\":\n                if pulse[0][2] <= int(time[1:]) + 4:\n                    return int(lenth[1:]) - pulse[0][2]\n            if time[0] == \"10\":\n                if pulse[0][2] <= int(time[1:]):\n                    return int(lenth[1:]) - pulse[0][2]\n\nsolution(stdin)\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Get input\n    n = int(stdin.readline())\n    input_array = [stdin.readline().split() for _ in range(n)]\n\n    # Init variables\n    v_wire_number = 1\n    h_wire_number = 1\n\n    # Init output\n    output = 0\n\n    # Loop over input\n    for wire_index in range(n):\n        direction = input_array[wire_index][0]\n        if direction == \"h\":\n            current_wire_number = h_wire_number\n            h_wire_number += int(input_array[wire_index][1])\n        else:\n            current_wire_number = v_wire_number\n            v_wire_number += int(input_array[wire_index][1])\n        output += current_wire_number\n        # add one to output if current wires crossed at any point\n        if current_wire_number > 1:\n            output += 1\n\n    return str(output)\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # This function will return the number of activated pixels in the panel\n    # and will take the input from the stdin\n    # as the first line is the number of pulses\n\n    # Create a list to store the horizontal and vertical direction of\n    # every pulse\n    list_of_pulse = stdin.split('\\n')\n\n    # Create a list to store the horizontal and vertical direction of\n    # every pulse\n    list_of_pulse = []\n\n    # Iterate over all the lines in the input\n    for line in stdin:\n        # Split the line by'' space\n        line = line.split(' ')\n\n        # The first element of the line is the direction of the pulse\n        # and the second element is the starting time of the pulse\n        # and the third element is the length of the pulse\n        # and the fourth element is the wire on which the pulse travels\n\n        # Append the direction of pulse and starting time of pulse\n        # and length of pulse and wire number of pulse to the\n        # list of pulse\n\n        # Append the list to the list of all pulse\n        list_of_pulse.append(line)\n\n    # Create a dictionary to store the number of pulses at a given\n    # starting time\n\n    # Create a list to store the position of all the horizontal\n    # wires\n    horizontal_wire_list = []\n\n    # Create a list to store the position of all the vertical wires\n    vertical_wire_list = []\n\n    # Iterate over all the pulse in the list of pulse\n    for pulse in list_of_pulse:\n        # Check if the pulse is of horizontal type\n        if pulse[0] == 'h':\n            # Check if the pulse is in the list of horizontal wires\n            if pulse[4] not in horizontal_wire_list:\n                # Append the wire number to the list of horizontal wires\n                horizontal_wire_list.append(pulse[4])\n\n        # Check if the pulse is of vertical type\n        elif pulse[0] == 'v':\n            # Check if the pulse is in the list of vertical wires\n            if pulse[4] not in vertical_wire_list:\n                # Append the wire number to the list of vertical wires\n                vertical_wire_list.append(pulse[4])\n\n    # Create a list to store the total number of activated pixels\n    # at a given starting time\n    activated_pixels_list = []\n\n    # Iterate over the list of horizontal wires\n    for wire in horizontal_wire_list:\n        # Create a list to store the starting and ending position\n        # of every pulse of a horizontal wire\n        pulse_of_wire = []\n\n        # Iterate over the list of pulse\n        for pulse in list_of_pulse:\n            # Check if the horizontal pulse is of the wire\n            if pulse[4] == wire:\n                # Append the pulse to the list of pulses of the wire\n                pulse_of_wire.append(pulse)\n\n        # Create a list to store the position of every horizontal\n        # pulse of a wire\n        position_of_pulse_of_wire = []\n\n        # Iterate over the list of pulse\n        for pulse in pulse_of_wire:\n            # Check if the horizontal pulse is of the type\n            # with pulse[0] == 'h'\n            if pulse[0] == 'h':\n                # Append the starting time of pulse to the list\n                position_of_pulse_of_wire.append(pulse[1])\n\n        # Create a list to store the position of every horizontal\n        # pulse of a wire\n        position_of_pulse_of_wire = []\n\n        # Iterate over the list of pulse\n        for pulse in pulse_of_wire:\n            # Check if the horizontal pulse is of the type\n            # with pulse[0] == 'h'\n            if pulse[0] == 'h':\n                # Append the length of pulse to the list\n                position_of_pulse_of_wire.append(pulse[2])\n\n        # Convert the list to a set to remove the duplicates\n        position_of_pulse_of_wire = set(position_of_pulse_of_wire)\n\n        # Iterate over the list of vertical wires\n        for wire in vertical_wire_list:\n            # Create a list to store the starting and ending\n            # position of every pulse of a vertical wire\n            pulse_of_wire = []\n\n            # Iterate over the list of pulse\n            for pulse in list_of_pulse:\n                # Check if the vertical pulse is of the wire\n                if pulse[4] == wire:\n                    # Append the pulse to the list of pulses\n                    # of the wire\n                    pulse_of_wire.append(pulse)\n\n            # Create a list to store the position of every vertical\n            # pulse of a wire\n            position_of_pulse_of_wire = []\n\n            # Iterate over the list of pulse\n            for pulse in pulse_of_wire:\n                # Check if the vertical pulse is of the type\n                # with pulse[0] == 'v'\n                if pulse[0] == 'v':\n                    # Append the starting time of pulse to the list\n                    position_of_pulse_of_wire.append(pulse[1])\n\n            # Convert the list to a set to remove the duplicates\n            position_of_pulse_of_wire = set(position_of_pulse_of_wire)\n\n            # Iterate over the position of pulse of wire\n            for position in position_of_pulse_of_wire:\n                # Iterate over the position of pulse of wire\n                for position_of_pulse in position_of_pulse_of_wire:\n                    # Check if the horizontal pulse is at the same\n                    # position as the vertical pulse\n                    if position == position_of_pulse:\n                        # Append the length of pulse to the list\n                        activated_pixels_list.append(position_of_pulse)\n\n    # Convert the list to a set to remove the duplicates\n    activated_"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\n   ... '4\\n'\n   ... 'h 1 4 1\\n'\n   ... 'v 2 4 2\\n'\n   ... 'h 10 2 2\\n'\n   ... 'v 11 2 3\\n')\n    2\n    \"\"\"\n   ..."
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculates the number of pixels that will be activated\n    by a pulse.\n\n    Args:\n        stdin: Input\n\n    Returns:\n        str: Number of pixels activated by the pulse\n    \"\"\"\n    # Retrieve input\n    n = int(stdin.splitlines()[0])\n    schedules = []\n    for i in range(1, n + 1):\n        pulse = stdin.splitlines()[i]\n        schedules.append(pulse.split())\n\n    # Initialize variables\n    activated = 0\n    x = 0\n    y = 0\n    x_end = 0\n    y_end = 0\n    pulses_left = n\n    pulses_activated = 0\n\n    # Move over each pulse\n    for schedule in schedules:\n        direction = schedule[0]\n        time = int(schedule[1])\n        length = int(schedule[2])\n        wire = int(schedule[3])\n\n        # Move x\n        if direction == 'v':\n            pulses_left -= 1\n            while pulses_left > 0:\n                if wire == 1:\n                    pulses_activated += 1\n                    activated += 1\n                    x_end = time\n                    x = y_end\n                wire += 1\n                if wire > n:\n                    x += length\n                    pulses_left -= 1\n                else:\n                    x += length\n                    x_end = time\n\n        # Move y\n        if direction == 'h':\n            pulses_left -= 1\n            while pulses_left > 0:\n                if wire == 1:\n                    pulses_activated += 1\n                    activated += 1\n                    y_end = time\n                    y = x_end\n                wire += 1\n                if wire > n:\n                    y += length\n                    pulses_left -= 1\n                else:\n                    y += length\n                    y_end = time\n\n    return str(activated)\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    shelves = [list(map(int, stdin.split())) for _ in range(n)]\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for j in range(m + 1):\n        dp[0][j] = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n            if shelves[i - 1][j - 1] == 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1])\n            else:\n                dp[i][j] += 1\n    # print(dp)\n    return str(dp[n][m])\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimal number of lifting, or -1 if it's impossible\"\"\"\n    n, m = list(map(int, stdin.split()))\n    books = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[n:] if line!= \"\"]\n    states = [list(map(int, line.split())) for line in stdin.split(\"\\n\")[:n]]\n    books = [sum(row) for row in zip(*books)]\n    states = [sum(row) for row in zip(*states)]\n    lifts = 0\n    for i in range(m):\n        for book in range(1, n + 1):\n            if book not in books:\n                if (\n                    states[book - 1] - book >= 0\n                    and states[book - 1] - book + books[i] >= 0\n                ):\n                    books[i] -= 1\n                    states[book - 1] -= book\n                    states[book - 1] -= book\n                    lifts += 1\n                    break\n                else:\n                    return \"-1\"\n    return str(lifts)\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 3\\n1 2 3\\n4 5 6\\n7 8 0\\n4 2 3\\n6 5 1\\n0 7 8\")\n    4\n    \"\"\"\n    a, b = map(int, stdin.split())\n    arr = [list(map(int, stdin.split())) for _ in range(a)]\n    book = [0 for _ in range(b)]\n    stack = []\n    for i in range(a):\n        for j in range(b):\n            if arr[i][j]:\n                book[j] = arr[i][j]\n                stack.append(book[j])\n                break\n    moves = 0\n    for i in range(b):\n        while stack[i]!= i:\n            tmp = stack[i]\n            stack[i] = stack[stack[i]]\n            stack[tmp] = tmp\n            moves += 1\n    return moves if all(\n        [\n            stack[i] == i\n            for i in range(b)\n            if stack[i]!= i\n        ]\n    ) else -1\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check(book):\n        return [a[b] for b in range(S) if a[b]!= 0]\n\n    def set_book(book):\n        for b in range(S):\n            if book[b] == 0:\n                a[b] = 0\n            else:\n                a[b] = book[b]\n                book[b] = 0\n\n    def swap(book, left, right):\n        for b in range(S):\n            if book[b] == left:\n                book[b] = right\n            if book[b] == right:\n                book[b] = left\n\n    S, B = map(int, stdin.readline().split())\n    a = [0] * S\n    for i in range(B):\n        a[int(stdin.readline()) - 1] = 1\n    stdin.readline()\n\n    for i in range(B, S):\n        a[int(stdin.readline()) - 1] = 1\n\n    queue = []\n    for i in range(S):\n        if a[i]!= 0:\n            queue.append((i, a[i]))\n\n    swaps = 0\n    while len(queue) > 1:\n        queue.sort()\n        left, right = queue.pop(0)\n        queue.sort()\n        left_ = check(a)\n        left_.sort()\n        i = 0\n        while i < len(left_) and left_[i] < right:\n            i += 1\n        if i < len(left_):\n            set_book(a)\n            swaps += 1\n            swap(a, left, left_[i])\n            queue.append((left, left_[i]))\n        else:\n            set_book(a)\n            swaps += 1\n            queue.append((left, right))\n    if queue:\n        swaps += (right - queue[0][1] + 1) // 2\n    print(swaps)\n    return swaps\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def lift(index, summ):\n        if index == N:\n            return summ\n        min_cost = float('inf')\n        for i in range(M):\n            if i not in visited and i + (index + 1) <= N:\n                visited.add(i)\n                min_cost = min(min_cost, lift(index + 1, summ + B[index][i]))\n                visited.remove(i)\n        return min_cost\n    N, M = map(int, stdin.split())\n    B = [list(map(int, stdin.split())) for _ in range(N)]\n    visited = set()\n    return lift(0, 0)\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    bookshelf, max_books_per_shelf = [int(x) for x in stdin.split('\\n')[:2]]\n    shelf_state = [[int(x) for x in line.split('\\n')[0].split()] for line in stdin.split('\\n')[2:shelf_count + 2]]\n    shelf_state_to_be_moved = [[int(x) for x in line.split('\\n')[0].split()] for line in stdin.split('\\n')[shelf_count + 2:]]\n    return str(lift_it(bookshelf, max_books_per_shelf, shelf_state, shelf_state_to_be_moved))\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    size = int(input[0])\n    nums = list(map(int, input[1].split()))\n    max_len = 0\n    d = {}\n    for num in nums:\n        d[num] = d.get(num, 0) + 1\n        if d[num] == 2:\n            max_len = max(max_len, d[num])\n            continue\n        d[num] -= 2\n\n    return max_len\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    n = map(int, n.split())\n    n = list(n)\n\n    def solution_util(n, n_list):\n        n_dict = {}\n        for i in n_list:\n            n_dict[i] = n_dict.get(i, 0) + 1\n        for i in n_dict:\n            if n_dict[i] == 1:\n                return 1\n        return 0\n\n    return solution_util(n, n)\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = [int(item.strip()) for item in stdin.readline().strip().split(' ')]\n    if len(arr) == 1:\n        return 1\n    max_count = 1\n    for i in range(n):\n        count = 0\n        for j in range(i, n):\n            if arr[j] == arr[i]:\n                count += 1\n            if count > 2:\n                break\n            max_count = max(max_count, count)\n    return max_count\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n = int(stdin)\n    a = [int(x) for x in stdin.split(\" \")]\n    if (n == 0):\n        return 0\n    ans = 1\n    m = {}\n    for i in a:\n        m[i] = True\n    k = 0\n    for j in range(n):\n        if (not m[a[j]]):\n            while(k < n and a[k] == a[j]):\n                m[a[k]] = True\n                k += 1\n            ans = max(ans, k - j)\n            k -= 1\n    return ans"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    a_dict = dict()\n    for ai in a:\n        if ai not in a_dict:\n            a_dict[ai] = 1\n        else:\n            a_dict[ai] += 1\n    max_len = 0\n    for ai, a_dict_value in a_dict.items():\n        if a_dict_value == 2:\n            max_len += 1\n        elif a_dict_value > 2:\n            sub_len = 0\n            while a_dict[ai] > 2:\n                if a_dict[ai] == 2:\n                    sub_len += 1\n                    a_dict[ai] -= 2\n                else:\n                    a_dict[ai] -= 1\n                    sub_len += 1\n            max_len = max(max_len, sub_len)\n    return max_len\n    \n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    ret = 0\n    for i in range(N):\n        cnt = 0\n        while True:\n            if i + cnt == N:\n                break\n            if a[i + cnt] == a[i + cnt - 1]:\n                cnt += 1\n                if cnt > ret:\n                    ret = cnt\n            else:\n                break\n    return ret\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    size = stdin.split()[0]\n    array = [stdin.split()[1]]\n    length = len(array[0])\n    current_sum = 0\n    current_count = 0\n    max_length = 0\n    for i in range(length):\n        if array[0][i] == '1':\n            current_count += 1\n        else:\n            current_sum += 1\n        if current_sum >= 2 and current_count > 0:\n            max_length = max(max_length, current_count)\n            current_count = 0\n            current_sum = 0\n    return max_length"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(n)\n    \"\"\"\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n\n    count = {}\n    for num in arr:\n        count[num] = 0\n\n    start = 0\n    ans = 0\n    for end in range(n):\n        count[arr[end]] += 1\n        if count[arr[end]] == 2:\n            ans = max(ans, end - start + 1)\n        while count[arr[end]] > 2:\n            count[arr[start]] -= 1\n            if count[arr[start]] == 0:\n                del count[arr[start]]\n            start += 1\n    return ans\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    i = 0\n    j = 1\n    m = {}\n    while j < len(a):\n        if a[j] not in m:\n            m[a[j]] = 0\n        m[a[j]] += 1\n        while m[a[j]] > 1:\n            m[a[i]] -= 1\n            i += 1\n        if j - i > j - 1:\n            j = i + 1\n            i = j - 1\n        else:\n            j += 1\n    return j - i + 1"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    arr = [int(x) for x in stdin.readline().split()]\n\n    # preprocess\n    s = set()\n    tmp_arr = []\n    for i, x in enumerate(arr):\n        if x not in s:\n            tmp_arr.append(x)\n            s.add(x)\n        else:\n            tmp_arr.append(x)\n            tmp_arr[i - 1] = -1\n    arr = tmp_arr\n\n    dp = [[0] * 2 for _ in range(N + 1)]\n    dp[0][0] = 1\n    dp[0][1] = 0\n    for i in range(1, N + 1):\n        x = arr[i - 1]\n        if x == -1:\n            dp[i][0] = dp[i - 1][1]\n            dp[i][1] = dp[i - 1][0] + dp[i - 1][1]\n        else:\n            dp[i][0] = dp[i - 1][0] + 1\n            dp[i][1] = dp[i - 1][1]\n    max_dp = max(dp[N][0], dp[N][1])\n\n    # find longest subarr\n    res = []\n    for i in range(N):\n        if max_dp == dp[i][0]:\n            res.append(arr[i])\n            for j in range(i, N):\n                if arr[j] not in res:\n                    res.append(arr[j])\n                    max_dp = max(max_dp, len(res))\n                else:\n                    max_dp = max(max_dp, len(res))\n                    break\n        else:\n            res.append(arr[i])\n            max_dp = max(max_dp, len(res))\n\n    return max_dp"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Reads the input and computes the output\n    '''\n    # the input\n    N, K, P = [int(number) for number in stdin.split('\\n')[0].split(' ')]\n    rooks = []\n    for _ in range(K):\n        R, C, power = [int(number) for number in stdin.split('\\n')[_].split(' ')]\n        rooks.append([R, C, power])\n    moves = []\n    for _ in range(P):\n        R1, C1, R2, C2 = [int(number) for number in stdin.split('\\n')[_].split(' ')]\n        moves.append([R1, C1, R2, C2])\n    # the output\n    counts = []\n    for move in moves:\n        counts.append(tot_count(move, N, K, rooks))\n    return '\\n'.join(str(count) for count in counts)\n\ndef"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution has to be efficient and fast, since it will be run with an input larger than the available memory\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, moves = map(int, stdin.readline().split())\n    powers = [list(map(int, stdin.readline().split())) for _ in range(K)]\n\n    def attack(coord: Tuple[int, int], powers: List[Tuple[int, int]], rook: int) -> int:\n        xor = 0\n        for pwr, coords in enumerate(powers):\n            if coord in coords and pwr!= rook:\n                xor ^= pwr\n        return xor\n\n    count = 0\n    for _ in range(P):\n        powers.append(list(map(attack, powers[-1], powers[:-1], range(K))))\n        count += sum(1 for coords in powers[K:] for i in coords if i > 0)\n    return str(count)\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def n_queens(K: int, N: int, P: int, T: dict, i: int) -> dict:\n        \"\"\"\n        Solves n_queens problem with backtracking\n\n        Parameters\n        ----------\n        K : int\n            Number of queens\n        N : int\n            Number of columns and rows\n        P : int\n            Number of moves\n        T : dict\n            Keys - the coordinates of the queens, values - powers of them\n        i : int\n            The number of the step in the algorithm\n\n        Returns\n        -------\n        dict\n            The keys - the coordinates of the queens, values - the powers of them\n        \"\"\"\n        if i >= P:\n            return T\n        else:\n            R = i\n            C = i\n            X = i + 1\n            for j in range(K):\n                if (i in T.keys()) and (not (i == T[i][2])) and (not (j == T[i][1])) and (not (abs(i - T[i][2]) == abs(j - T[i][1]))):\n                    T[i] = (j, C, X)\n                    x = n_queens(K, N, P, T, i + 1)\n                    if not isinstance(x, int):\n                        return x\n                    else:\n                        T[i] = (j, C, X)\n                        continue\n                else:\n                    T[i] = (j, C, X)\n                    x = n_queens(K, N, P, T, i + 1)\n                    if not isinstance(x, int):\n                        return x\n                    else:\n                        T[i] = (j, C, X)\n                        continue\n            return len(T)\n\n    def n_queens_solution(N: int, P: int, K: int) -> int:\n        T = dict()\n        return n_queens(K, N, P, T, 0)\n\n    N, K, P = [int(n) for n in stdin.split('\\n')[0].split(' ')]\n    return str(n_queens_solution(N, P, K))\n\n\ndef"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\""
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the total number of attacked fields after $k$ moves.\n    '''\n    n, k, p = list(map(int, stdin.split(' ')))\n    rooks = [[0 for _ in range(n)] for _ in range(n)]\n    for _ in range(k):\n        row, col, power = map(int, stdin.split(' '))\n        rooks[row - 1][col - 1] = power\n\n    result = 0\n    for _ in range(p):\n        row1, col1, row2, col2 = map(int, stdin.split(' '))\n        res = 0\n        for i in range(n):\n            if row1 <= i <= row2:\n                res ^= rooks[i][col1 - 1]\n            if col1 <= i <= col2:\n                res ^= rooks[row1 - 1][i]\n        result += res\n    return result\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(N) / O(N)\"\"\"\n    line = stdin.split()\n    rows, columns = int(line[0]), int(line[0])\n    rooks, moves = int(line[1]), int(line[2])\n    rooks_positions = [[int(x) for x in line[3:]] for line in stdin.splitlines()[:rooks + 1]]\n    rooks_powers = [sum(row) for row in rooks_positions]\n    # Calculate the powers on every field\n    attacked_fields = [sum(powers) for powers in zip(*[iter(rooks_powers)] * columns)]\n    # Calculate the XOR of all the powers\n    xor = 0\n    for x in attacked_fields:\n        if x > 0:\n            xor ^= x\n    return xor\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split('\\n')[:2]]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(x) for x in stdin.split('\\n')[i+2].split()])\n    disqualified = [int(x) for x in stdin.split('\\n')[-k:]]\n    x = []\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 1 and i not in x and j not in x:\n                x.append(i)\n                x.append(j)\n    y = [i for i in range(n) if i not in x]\n    z = list(set(disqualified) - set(y))\n    if len(z) == 0:\n        return \"impossible\"\n    if len(z) > len(disqualified):\n        return len(disqualified)\n    else:\n        return len(z)\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(i) for i in stdin.split()]\n    t = [[int(i) for i in stdin.split()] for j in range(n)]\n    s = [int(i) for i in stdin.split()][k:]\n    def dfs(i, cnt, pos):\n        if i == n:\n            return cnt == k and all(all(t[i][j] == 0 for j in range(n)) for i in range(n))\n        if dfs(i+1, cnt, pos): return True\n        if cnt == k: return False\n        for j in range(n):\n            if (j in pos or i in pos) and t[i][j] == 0:\n                t[i][j] = 1\n                pos.add(j)\n                if dfs(i+1, cnt+1, pos): return True\n                t[i][j] = 0\n                pos.remove(j)\n        return False\n    return \"impossible\" if not dfs(0, 0, set()) else k - sum(s)"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split()\n    n, k = int(n), int(k)\n\n    stdin = [stdin.split() for stdin in stdin]\n\n    player_to_rankings = defaultdict(list)\n\n    for stdin_row in stdin:\n        player, *_, ranking = stdin_row\n\n        if ranking == \"1\":\n            player_to_rankings[player].append(1)\n        elif ranking == \"0\":\n            player_to_rankings[player].append(0)\n\n    rank_player_to_rankings = {\n        player: ranking_to_list_of_rankings\n        for player, ranking_to_list_of_rankings in player_to_rankings.items()\n    }\n\n    ranking_to_list_of_rankings = defaultdict(list)\n\n    for rank, player_rankings in rank_player_to_rankings.items():\n        for player_ranking in player_rankings:\n            ranking_to_list_of_rankings[player_ranking].append(rank)\n\n    sorted_rankings = sorted(\n        ranking_to_list_of_rankings.keys(), key=lambda r: int(r)\n    )\n\n    # print(sorted_rankings)\n    ranking_to_list_of_rankings = {\n        r: ranking_to_list_of_rankings[r] for r in sorted_rankings\n    }\n    # print(ranking_to_list_of_rankings)\n\n    ranking_to_list_of_rankings = {\n        r: [r] + sorted(ranking_to_list_of_rankings[r])\n        for r in sorted_rankings\n    }\n    # print(ranking_to_list_of_rankings)\n\n    ranking_to_list_of_rankings = {\n        r: [\n            (player, ranking)\n            for ranking, players in enumerate(ranking_to_list_of_rankings[r])\n            for player in players\n        ]\n        for r in sorted_rankings\n    }\n    # print(ranking_to_list_of_rankings)\n\n    ranking_to_list_of_rankings = {\n        r: list(set(ranking_to_list_of_rankings[r]))\n        for r in sorted_rankings\n    }\n    # print(ranking_to_list_of_rankings)\n\n    ranking_to_list_of_rankings = {\n        r: [\n            (player, ranking)\n            for ranking, players in enumerate(ranking_to_list_of_rankings[r])\n            for player in players\n        ]\n        for r in sorted_rankings\n    }\n    # print(ranking_to_list_of_rankings)\n\n    player_to_player_ranking_rankings = {\n        player: ranking_to_list_of_rankings[player_ranking]\n        for player, player_ranking in ranking_to_list_of_rankings.items()\n    }\n    # print(player_to_player_ranking_rankings)\n\n    ranking_to_rankings_counts = {\n        ranking: len(rankings)\n        for ranking, rankings in ranking_to_list_of_rankings.items()\n    }\n\n    # print(ranking_to_rankings_counts)\n\n    def dfs(player_to_player_ranking_rankings, ranking_to_rankings_counts):\n        for rank, count in ranking_to_rankings_counts.items():\n            if count == 0:\n                continue\n\n            player_to_ranking_rankings = player_to_player_ranking_rankings[rank]\n\n            if len(player_to_ranking_rankings)!= count:\n                return False\n\n            player_to_ranking_rankings.sort(\n                key=lambda p: player_to_player_ranking_rankings[p][0]\n            )\n\n            player_to_ranking_rankings = {\n                player: ranking\n                for _, ranking, player in player_to_ranking_rankings\n            }\n\n            if not dfs(player_to_ranking_rankings, ranking_to_rankings_counts):\n                return False\n\n            player_to_ranking_rankings = {\n                player: ranking\n                for player, ranking in player_to_ranking_rankings.items()\n            }\n            for player in player_to_ranking_rankings.keys():\n                player_to_player_ranking_rankings[player].pop(0)\n\n        return True\n\n    if dfs(player_to_player_ranking_rankings, ranking_to_rankings_counts):\n        print(len(player_to_player_ranking_rankings.keys()))\n    else:\n        print(\"impossible\")\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    stdin = stdin.split('\\n')\n    n, k = list(map(int, stdin[0].split()))\n    stdin = stdin[1:]\n    stdin = list(map(lambda x: list(map(int, x.split()))) for x in stdin)\n    \n    answer = ''\n    \n    stdin = list(map(lambda x: sorted(x)[::-1], stdin))\n    stdin = list(filter(lambda x: len(x) > 1, stdin))\n    stdin = [sorted(x) for x in stdin]\n    print(stdin)\n    \n    if sum(map(len, stdin)) <= k:\n        answer = '0'\n    else:\n        stdin = [sorted(x) for x in stdin]\n        stdin = list(filter(lambda x: len(x) > 1, stdin))\n        print(stdin)\n        if sum(map(len, stdin)) <= k:\n            answer = '0'\n        else:\n            answer = 'impossible'\n    \n    return answer\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split(' ')]\n    mat = [list(map(int, x.split(' '))) for x in stdin.split('\\n')[1:]]\n    mat_t = [[mat[j][i] for j in range(n)] for i in range(n)]\n    p = [i for i in range(n)]\n    for i in range(k):\n        d = [int(x) for x in stdin.split('\\n')[i+1].split(' ')]\n        for x in d:\n            p.remove(x)\n    r = [1] * n\n    for x in p:\n        for i in range(n):\n            for j in range(i+1, n):\n                if mat[i][j] == 1 and mat[i][j] == mat_t[x][j]:\n                    r[x] = max(r[x], r[j])\n    if sum(r) < k:\n        return 'impossible'\n    return str(max([k-x for x in r]))\nprint(solution(input()))\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.strip().split()]\n    rankings = [int(x) for x in stdin.strip().split()]\n    disqual_players = [int(x) for x in stdin.strip().split()]\n    for i in range(n):\n        for j in range(i+1, n):\n            if (rankings[i] > rankings[j]) & (rankings[i]!= 0) & (rankings[j]!= 0):\n                if rankings[i]!= disqual_players[disqual_players.index(rankings[j])]:\n                    return \"impossible\"\n    return str(k-1)\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_highschool_students, num_disqualified_students = [int(s) for s in stdin.split('\\n')[:2]]\n    highschool_students = [\n        [1 if stdin[i][j] == '1' else 0 for j in range(num_highschool_students)]\n        for i in range(num_highschool_students)\n    ]\n    disqualified_students = [int(s) for s in stdin.split('\\n')[2:3]]\n    # if all students are disqualified\n    if not len(set(disqualified_students)):\n        return 'impossible'\n    # if no students are disqualified\n    if num_disqualified_students == num_highschool_students:\n        return len(disqualified_students)\n    def helper(highschool_students, i, k):\n        if i == num_highschool_students:\n            return k\n        if i in disqualified_students:\n            return inf\n        return min(helper(highschool_students, i + 1, k),\n                   helper(highschool_students, i + 1, k + 1) + 1)\n    # if not all students are disqualified\n    return helper(highschool_students, 0, 0)\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, stdin.split())))\n    dis = list(map(int, stdin.split()))\n\n    def dfs(dis, arr, i, j, visited, count):\n        if i == j:\n            if count == k:\n                return True\n            else:\n                return False\n        visited[i] = 1\n        for k in range(n):\n            if not visited[k] and arr[i][k] == 1:\n                if dfs(dis, arr, k, j, visited, count + 1):\n                    return True\n        return False\n    for i in range(k):\n        if dfs(dis, arr, i, i, [0] * n, 0):\n            return 'impossible'\n    return 'impossible' if k > n else n - k\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 2\\n0 0 1 1\\n1 0 0 1\\n0 1 0 0\\n0 0 1 0\\n1 2\\n')\n    1\n    \"\"\"\n    n, k = [int(s) for s in stdin.split(' ')]\n    relations = [[int(s) for s in row.split(' ')] for row in stdin.split('\\n')]\n\n    disqualified = [i for i in range(n) if relations[i].count(1) >= 2]\n    if not disqualified:\n        return 'impossible'\n\n    removed = set()\n    for p in disqualified:\n        removed.add(p)\n        for q in range(n):\n            if relations[p][q] and q not in removed:\n                relations[p][q] = 0\n\n    groups = []\n    while len(removed) > 0:\n        group = set()\n        while len(group) < k:\n            for i in range(n):\n                if i not in group and relations[i].count(1) == 1:\n                    group.add(i)\n        if len(group) < k:\n            return 'impossible'\n        groups.append(group)\n        for p in group:\n            for q in group:\n                if p!= q:\n                    relations[p][q] = 0\n        removed = removed.difference(group)\n\n    return len(groups)\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n, k = [int(x) for x in stdin.split()]\n    adj_list = []\n    for _ in range(n):\n        adj_list.append(list(map(int, stdin.split()[1:])))\n\n    disqualified = set([int(x) for x in stdin.split()[-k:]])\n    disqualified = set([x for x in range(n) if x in disqualified])\n\n    not_disqualified = set([x for x in range(n) if x not in disqualified])\n\n    for a in not_disqualified:\n        for b in not_disqualified:\n            if adj_list[a][b]:\n                break\n        else:\n            return \"impossible\"\n\n    for a in disqualified:\n        for b in disqualified:\n            if adj_list[a][b]:\n                break\n        else:\n            return \"impossible\"\n\n    for a in not_disqualified:\n        for b in disqualified:\n            if adj_list[a][b]:\n                break\n        else:\n            return \"impossible\"\n\n    return len(disqualified)"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A program to solve the problem\"\"\"\n    # Get input\n    n, k = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    q = int(stdin.readline())\n    sums = []\n\n    # Define a function to compute the sum of elements from a given range\n    def sum_of_elements(l, r):\n        return sum(seq[l: r + 1])\n\n    # Define a function to compute the sum of elements from a given range and check if it meets the requirements for the special part\n    def check_special(l, r):\n        return sum_of_elements(l, r) == k\n\n    # Iterate over the special parts\n    for i in range(q):\n        # Get the left and right bound of the special part\n        left, right = map(int, stdin.readline().split())\n\n        # Compute the sum of elements from left to right\n        sums.append(sum_of_elements(left, right))\n\n        # Check if the special part meets the requirements\n        if check_special(left, right):\n            # Check if the special part meets the requirements\n            print(k)\n        else:\n            # If not, print \"0\"\n            print(\"0\")\n\n    # Return the result\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the sum of elements of the array between bounds.\"\"\"\n    n, k, *arr = list(map(int, stdin.split('\\n')[0].split(' ')))\n    parts = list(map(int, stdin.split('\\n')[1:]))\n    q, *bounds = list(map(int, stdin.split('\\n')[2:]))\n    arr = [0] * n\n    for i, jump in enumerate(parts):\n        i = i % n\n        arr[i] = arr[i] + jump\n        if i + jump >= n:\n            arr[i] = arr[i] + arr[i + jump - n]\n        else:\n            arr[i] = arr[i] + arr[i + jump]\n    for i in range(q):\n        l, r = list(map(int, stdin.split('\\n')[2+i].split(' ')))\n        print(sum(arr[l:r]))\n    return ''\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    # Get data from stdin\n    N, K = [int(value) for value in stdin.split()]\n    seq = [int(value) for value in stdin.split()]\n    Q = int(stdin.split()[-1])\n\n    # Create a list of numbers, one for each special part\n    parts = []\n    for _ in range(Q):\n        parts.append(tuple(int(value) for value in stdin.split()))\n\n    # Do the computation\n    sum_ = 0\n    for L, R in parts:\n        sum_ += sum(seq[L:R])\n\n    # Return the answer to stdout\n    return str(sum_)\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate the sum of all elements of a sequence between and including bounds\n    :param stdin: Input from STDIN\n    :return: The sum of the sequence\n    \"\"\"\n    N, K = [int(x) for x in stdin.split(' ')]\n    X = [int(x) for x in stdin.split('\\n')[1:-1]]\n    Q = int(stdin.split('\\n')[-1])\n    seq = [0] * N\n    for i in range(K):\n        a, b = [int(x) for x in stdin.split('\\n')[i + Q + 2].split(' ')]\n        seq[a:b + 1] = [x + 1 for x in seq[a:b + 1]]\n    return '\\n'.join(str(x) for x in seq)\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''10 4\n   ... 1 1 2 1\n   ... 3\n   ... 0 9\n   ... 2 6\n   ... 7 7''')\n    '35\n    '18\n    '3\n    \"\"\"\n    _, k = map(int, stdin.split('\\n')[:2])\n    X = list(map(int, stdin.split('\\n')[2:k + 2]))\n    Q = int(stdin.split('\\n')[k + 2])\n    seq = [0] * int(stdin.split('\\n')[0])\n    for i in range(Q):\n        L, R = map(int, stdin.split('\\n')[k + 3 + i].split())\n        seq[L] += X[i]\n        seq[R] += X[i]\n    return '\\n'.join(map(str, seq))\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Code to solve exercise\"\"\"\n    # Initialize empty list\n    seq = []\n    # Declare variables\n    n, k, q = 0, 0, 0\n    # Loop through the lines of input\n    for i in stdin.split('\\n'):\n        # Break up each line into a list of strings\n        i = i.split()\n        # The first two values are the parameters\n        if k == 0:\n            n = int(i[0])\n            k = int(i[1])\n        # The last value is the answer\n        else:\n            q = int(i[-1])\n            # The rest are the values in the array\n            seq = [int(j) for j in i[:len(i)-1]]\n            # Check if there are any special parts\n            if len(i) > 2:\n                l, r = [], []\n                # Loop through the special parts and gather the bounds\n                for j in i[2:-1]:\n                    l.append(int(j.split(' ')[0]))\n                    r.append(int(j.split(' ')[1]))\n                # For each special part, increment the corresponding values\n                for j in range(len(l)):\n                    for i in range(l[j], r[j]+1):\n                        seq[i] += 1\n    # Check if any special parts remain\n    if q > 0:\n        # Loop through the special parts\n        for j in range(q):\n            # Sum the elements in the range between the bounds\n            seq[l[j]] += seq[l[j]+1] + seq[l[j]+2]\n            for i in range(l[j]+3, r[j]+1):\n                seq[i] += 1\n    # Print the answer\n    for i in range(n):\n        print(seq[i])\n    return ''\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    x = list(map(int, stdin.readline().split()))\n    q = int(stdin.readline())\n    l = [list(map(int, stdin.readline().split())) for _ in range(q)]\n\n    sum = 0\n    for i in range(k):\n        sum += x[i]\n\n    for j in range(q):\n        l[j][0] -= 1\n        l[j][1] -= 1\n        sum += x[l[j][0]]\n\n    for z in range(q):\n        for i in range(l[z][0], l[z][1]):\n            sum -= x[i]\n\n    print(sum)\n    return ''\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a list of length N containing zero(s) only.\n\n    Parameters:\n        stdin (str): stdin.\n\n    Returns:\n        str: list of N containing zero(s) only.\n    \"\"\"\n    n, k = map(int, stdin.split(' '))\n    arr = [0] * n\n    for i in range(k):\n        x = int(stdin.split(' ')[i + 1])\n        l = x - 1\n        r = x\n        arr[l] += 1\n        for j in range(l + 1, r):\n            arr[j] += 1\n    q = int(stdin.split(' ')[-1])\n    res = []\n    for i in range(q):\n        l, r = map(int, stdin.split(' ')[i * 2 + 2: i * 2 + 4])\n        res.append(sum(arr[l - 1: r]))\n    return '\\n'.join(map(str, res))\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n: int = int(stdin.readline().strip())\n    arr: list[int] = [int(x) for x in stdin.readline().strip().split(' ')]\n    assert n == len(arr)\n\n    # create BST\n    root: Node[int] = Node(arr[0])\n    for num in arr[1:]:\n        root = insert(root, num)\n    return''.join(map(str, search(root)))\n\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    def insert(tree, depth):\n        nonlocal count\n        depth += 1\n        if depth == len(numbers):\n            count += 1\n            print(count)\n            return\n        if numbers[depth] < tree:\n            if tree.left:\n                insert(tree.left, depth)\n            else:\n                tree.left = Tree(numbers[depth])\n                count += 1\n                print(count)\n                insert(tree.left, depth)\n        elif numbers[depth] > tree:\n            if tree.right:\n                insert(tree.right, depth)\n            else:\n                tree.right = Tree(numbers[depth])\n                count += 1\n                print(count)\n                insert(tree.right, depth)\n        else:\n            print(count)\n            return\n\n    numbers = [int(line) for line in stdin.split()]\n    tree = Tree(numbers[0])\n    count = 0\n    for i in range(1, N):\n        insert(tree, 0)\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def insert_into_tree(tree: Tree, new_node: int) -> None:\n        \"\"\"Inserts new node into a tree, and updates the number of levels of the tree.\"\"\"\n        tree.size += 1\n        if new_node < tree.data:\n            if tree.left is None:\n                tree.left = Node(new_node)\n            else:\n                insert_into_tree(tree.left, new_node)\n        else:\n            if tree.right is None:\n                tree.right = Node(new_node)\n            else:\n                insert_into_tree(tree.right, new_node)\n\n    def traverse_tree(tree: Tree, counter: int) -> int:\n        \"\"\"Traverses a binary search tree from the specified node.\n        Returns the depth of the tree.\"\"\"\n        if tree.left is None and tree.right is None:\n            return counter\n        elif tree.left is None:\n            return traverse_tree(tree.right, counter + 1)\n        elif tree.right is None:\n            return traverse_tree(tree.left, counter + 1)\n        else:\n            return max(traverse_tree(tree.left, counter + 1), traverse_tree(tree.right, counter + 1))\n\n    n = int(stdin.readline())\n    numbers = [int(number) for number in stdin.readline().split()]\n    tree = Tree(numbers[0])\n    for number in numbers[1:]:\n        insert_into_tree(tree, number)\n    counter = 0\n    for number in numbers:\n        counter = traverse_tree(tree, counter)\n        print(counter)\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_of_testcases = int(stdin)\n    for testcase_index in range(num_of_testcases):\n        num_of_numbers = int(stdin)\n        numbers = [int(stdin) for _ in range(num_of_numbers)]\n        index = 0\n        # index is the index of the current number in the list of numbers,\n        # so for example, index = 1 will return the second number in the list\n        # each time the function is called\n        def build_tree(numbers: list, index: int) -> Node:\n            if index == len(numbers) - 1:\n                return Node(numbers[index])\n            else:\n                middle = len(numbers)//2\n                left_subtree = build_tree(numbers[:middle], index)\n                right_subtree = build_tree(numbers[middle:], index + middle)\n                return Node(numbers[index], left_subtree, right_subtree)\n        tree = build_tree(numbers, index)\n        # after each number is added, increment index by 1\n        index += 1\n        counter = 0\n        while index < len(numbers):\n            # traverse tree searching for number\n            node = tree\n            while not node.left and not node.right:\n                if node.value == numbers[index]:\n                    counter += node.depth\n                    # if node is found, add node as left or right child to current node\n                    # and increment index by 1, since node was added\n                    if node.value > numbers[index]:\n                        node.left = Node(numbers[index])\n                    else:\n                        node.right = Node(numbers[index])\n                    break\n                elif node.value > numbers[index]:\n                    node = node.left\n                else:\n                    node = node.right\n            # add depth of current number to counter, since the counter is the\n            # depth of the last number that was added\n            counter += node.depth\n            index += 1\n        print(counter)\n\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    seq = list(map(int, stdin.readline().split()))\n\n    root = TreeNode(seq[0])\n    C = 0\n    for i in range(1, n):\n        root = insert(root, seq[i])\n        C += get_depth(root)\n    print(' '.join(str(C) for _ in range(n)))\n\n    return ''\n\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_of_nodes = int(stdin.readline().strip())\n    bst = BinarySearchTree(int(stdin.readline().strip()))\n    for _ in range(num_of_nodes - 1):\n        bst.insert(int(stdin.readline().strip()))\n    return bst.inorder()\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    coordinates = []\n    for _ in range(n):\n        coordinates.append(list(map(int, stdin.readline().split())))\n    coordinates = sorted(coordinates, key=lambda x: (x[1], x[0]))\n    result = \"\"\n    for i in range(n):\n        result += str(coordinates[i][3]) + \" \"\n    return result\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the order of sticks that is needed to be taken off the table\n    \"\"\"\n    N = int(stdin)\n    sticks = []\n    for _ in range(N):\n        x1, y1, x2, y2 = [int(x) for x in stdin.readline().split()]\n        sticks.append((x1, y1, x2, y2))\n    sticks.sort(key=lambda x: x[0])\n\n    stack = []\n    visited = set()\n\n    for x1, y1, x2, y2 in sticks:\n        while stack and stack[-1][1] >= x2:\n            stack.pop()\n        \n        if stack:\n            last_x1, last_y1 = stack[-1]\n            if last_x1 == x1:\n                stack.append((x1, y2, x2, y2))\n            elif last_y1 == y1:\n                stack.append((x1, y2, x2, y2))\n            elif last_x1 == x2:\n                stack.append((x1, y1, x2, y2))\n            elif last_y1 == y2:\n                stack.append((x1, y1, x2, y2))\n        else:\n            stack.append((x1, y1, x2, y2))\n\n    return \" \".join(str(x) for x in range(len(sticks)))\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Compute shortest path between all sticks.\n    \"\"\"\n    line = stdin.splitlines()\n    n = int(line[0])\n    points = [tuple(map(int, line[i].split())) for i in range(1, n + 1)]\n    result = [0] * n\n    for i in range(n):\n        result[i] = points[i][0] * 10000 + points[i][1]\n    points = list(set(result))\n    points.sort()\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\n1 3 2 2\\n1 1 3 2\\n2 4 7 3\\n3 3 5 3\")\n    '2 4 1 3'\n    \"\"\"\n    n = int(stdin.readline())\n    table = []\n    for i in range(n):\n        table.append(list(map(int, stdin.readline().split())))\n\n    table.sort(key=lambda x: x[0])\n\n    solution = []\n    while table:\n        for i in range(len(table)):\n            if i < len(table) - 1 and table[i][0] == table[i + 1][0]:\n                table[i][0] = table[i][0]\n            else:\n                for j in range(i + 1, len(table)):\n                    if table[j][0] == table[i][0]:\n                        table[i][0] = table[j][0]\n                        break\n                break\n        table = sorted(table, key=lambda x: x[1])\n        solution.append(table[0][0])\n        table = list(filter(lambda x: x[0]!= table[0][0], table))\n        table = sorted(table, key=lambda x: x[2])\n\n    return''.join(map(str, solution))\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _ = int(stdin.readline())\n    stick_points = [tuple(map(int, line.strip().split())) for line in stdin.readlines()]\n    n_sticks = len(stick_points)\n    sticks_by_origin = defaultdict(list)\n    for i in range(n_sticks):\n        origin = (stick_points[i][0], stick_points[i][1])\n        target = (stick_points[i][2], stick_points[i][3])\n        sticks_by_origin[origin].append(target)\n    # print(sticks_by_origin)\n\n    # find all the unique points\n    points = set()\n    for origin, targets in sticks_by_origin.items():\n        for target in targets:\n            points.add(origin)\n            points.add(target)\n    points = list(points)\n    # print(points)\n\n    # initialize graph\n    graph = defaultdict(list)\n    for i, p in enumerate(points):\n        for j, q in enumerate(points):\n            if p[0]!= q[0] and p[1]!= q[1]:\n                graph[p].append(q)\n                graph[q].append(p)\n    # print(graph)\n\n    # perform bfs\n    queue = deque([(0, 0, 0)])\n    visited = set()\n    while queue:\n        d, p, k = queue.popleft()\n        if p in visited:\n            continue\n        visited.add(p)\n        for q in graph[p]:\n            if q in visited:\n                continue\n            if d + distance(p, q) <= 10000:\n                queue.append((d + distance(p, q), q, k))\n    # print(visited)\n\n    return \" \".join(map(str, sorted(visited)))\n\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 1 3 2 2\n   ... 1 1 3 2\n   ... 2 4 7 3\n   ... 3 3 5 3''')\n    '2 4 1 3'\n    \"\"\"\n    lst = []\n    n = int(stdin.readline())\n    for i in range(n):\n        x_1, y_1, x_2, y_2 = map(int, stdin.readline().split())\n        lst.append((x_1, y_1, x_2, y_2))\n\n    lst.sort(key=lambda x: x[0])\n    count = 0\n    out = []\n    for i, item in enumerate(lst):\n        if count == 0:\n            count = item[0]\n        else:\n            for j in range(1, 4):\n                if (count + j, item[1], item[2], item[3]) in lst:\n                    count += j\n                    break\n                else:\n                    count += j\n                    break\n            else:\n                lst.pop(i)\n                continue\n            out.append(str(item[0]))\n            lst.pop(i)\n\n    return''.join(out)\n\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\n1 3 2 2\\n1 1 3 2\\n2 4 7 3\\n3 3 5 3\")\n    '2 4 1 3'\n    \"\"\"\n    # m: number of sticks, table: square of coordinates\n    m, table = int(stdin.split(\"\\n\")[0]), [[0, 0], [10000, 10000]]\n    sticks = [list(map(int, row.split())) for row in stdin.split(\"\\n\")[1:]]\n    # all points on table\n    points = set(table[0])\n    for stick in sticks:\n        points = points.union(set(stick))\n    points = list(points)\n\n    def distance(p1: list, p2: list):\n        return (abs(p1[0] - p2[0]) ** 2 + abs(p1[1] - p2[1]) ** 2) ** 0.5\n\n    # if two sticks have common points, then they cannot be removed in the same order\n    for i, point1 in enumerate(points):\n        for j, point2 in enumerate(points):\n            if i!= j and point1 == point2:\n                points[i] = None\n                points[j] = None\n\n    # convert coordinates from cartesian to polar\n    polars = [[distance(point, table[0]), point] for point in points]\n    polars.sort()\n\n    # save path for each stick\n    paths = []\n    # record the already removed sticks\n    removed = set()\n    for _, point in polars:\n        if point in removed:\n            continue\n        shortest_path = [point]\n        distance_to_origin = distance(point, table[0])\n        for stick in sticks:\n            # the current stick cannot be removed if it has common points with removed sticks\n            if set(stick) & removed:\n                continue\n            # remove the current stick\n            removed.add(stick)\n            # record the path to the table\n            path = [stick]\n            for _, point in polars:\n                # find shortest path\n                if distance(point, table[0]) < distance_to_origin:\n                    distance_to_origin = distance(point, table[0])\n                    shortest_path = [point]\n                elif distance(point, table[0]) == distance_to_origin:\n                    shortest_path.append(point)\n            # remove the current stick\n            removed.remove(stick)\n            # update the shortest path\n            for i in range(len(path)):\n                for j in range(len(shortest_path)):\n                    path[i] = [x + y for x, y in zip(path[i], shortest_path[j])]\n            paths.append(path)\n        # restore removed sticks\n        removed.clear()\n        for stick in sticks:\n            removed.add(stick)\n    # output the shortest path\n    paths.sort(key=lambda x: len(x))\n    return \" \".join(map(lambda x: str(x[0][0] + 1) + \" \" + str(x[0][1] + 1) + \" \" + str(x[1][0] + 1) + \" \" + str(x[1][1] + 1), paths[0]))\n"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass"
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3169,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 1 3 2 2\n   ... 1 1 3 2\n   ... 2 4 7 3\n   ... 3 3 5 3\n   ... ''')\n    '2 4 1 3'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin[:]\n    deck = deck.replace('A','11').replace('J','12').replace('K','13').replace('Q','14')\n    deck = deck.split('T')\n    deck = deck[1::2] + deck[::2]\n    deck = [int(x) for x in deck]\n    Theta = deck[:10]\n    friend = deck[10:20]\n    drawing_pile = deck[20:]\n    Theta_score = 0\n    friend_score = 0\n    drawing_pile.sort()\n    Theta_score = sum(Theta[x] for x in range(len(Theta)) if x % 2 == 0)\n    Theta_score += sum(Theta[x] for x in range(len(Theta)) if x % 2 == 1)\n    friend_score = sum(friend[x] for x in range(len(friend)) if x % 2 == 0)\n    friend_score += sum(friend[x] for x in range(len(friend)) if x % 2 == 1)\n    #print(Theta, friend, drawing_pile)\n    #print(Theta_score, friend_score)\n    # Theta always plays first\n    Theta_pref = [0 for x in range(len(Theta))]\n    friend_pref = [0 for x in range(len(friend))]\n    i = 0\n    j = 0\n    # Check for each card in Theta's hand\n    while i < len(Theta) and j < len(Theta):\n        if i % 2 == 0:\n            Theta_pref[i] = Theta[i]\n            Theta_score -= Theta[i]\n            i += 1\n        else:\n            Theta_pref[i] = Theta[i]\n            Theta_score -= Theta[i]\n            j += 1\n    i = 0\n    j = 0\n    # Check for each card in Theta's hand\n    while i < len(friend) and j < len(friend):\n        if i % 2 == 0:\n            friend_pref[i] = friend[i]\n            friend_score -= friend[i]\n            i += 1\n        else:\n            friend_pref[i] = friend[i]\n            friend_score -= friend[i]\n            j += 1\n    i = 0\n    j = 0\n    # Play cards\n    while i < len(Theta) or j < len(friend):\n        #print(Theta, friend, drawing_pile)\n        #print(i, j)\n        if i < len(Theta):\n            if friend_score >= drawing_pile[0] and friend_pref[i] < drawing_pile[0]:\n                drawing_pile.pop(0)\n                friend_score += drawing_pile[0]\n                friend_pref[i] = drawing_pile[0]\n            else:\n                drawing_pile.pop(0)\n                i += 1\n        else:\n            if Theta_score >= drawing_pile[0] and Theta_pref[i] < drawing_pile[0]:\n                drawing_pile.pop(0)\n                Theta_score += drawing_pile[0]\n                Theta_pref[i] = drawing_pile[0]\n            else:\n                drawing_pile.pop(0)\n                j += 1\n        #print(Theta, friend, drawing_pile)\n        #print(i, j)\n    #print(Theta, friend)\n    #print(Theta_pref, friend_pref)\n    if Theta_score > friend_score:\n        return 'Theta wins'\n    else:\n        return 'Theta loses'\n\nprint(solution('23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5'))\nprint(solution('89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49'))\nprint(solution('89724TJTA67"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Theta vs another player who only uses Jacks\n    \"\"\"\n    deck = [card for card in stdin]\n    deck = [card for card in deck if card!= 'T']\n    player_1 = [card for card in stdin if card!= 'T']\n    player_2 = [card for card in stdin if card!= 'A']\n    n = len(player_1)\n\n    for i in range(n):\n        if player_1[i] == 'J':\n            if i == 0:\n                player_1[i] = 'A'\n            else:\n                player_1[i] = '2'\n\n    for i in range(n):\n        if player_2[i] == 'J':\n            if i == 0:\n                player_2[i] = 'A'\n            else:\n                player_2[i] = '2'\n    \n    deck = deck[:n] + player_1 + deck[n:]\n    deck = deck[:n] + player_2 + deck[n:]\n\n    player_1 = [int(card) for card in player_1]\n    player_2 = [int(card) for card in player_2]\n\n    if sum(player_1) > sum(player_2):\n        return 'Theta wins'\n    return 'Theta loses'"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the winning player in a game of Trash.\n\n    >>> solution('23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5')\n    'Theta wins'\n    >>> solution('89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49')\n    'Theta wins'\n    \"\"\"\n    deck = stdin\n    t = 10  # number of cards dealt to Theta\n\n    # The first 10 cards in the deck are Theta's face-down cards\n    th_deck = [\n        int(deck[i]) if i < len(deck) else 0\n        for i in range(t)\n    ]\n    th_hand = [int(deck[i]) for i in range(t, len(deck))]\n\n    # The first 10 cards in Theta's hand are Theta's face-up cards\n    theta_hand = [int(deck[i]) for i in range(t)]\n\n    # The first card drawn is Theta's face-up card\n    theta_draw = int(deck[len(deck) - 1])\n    th_draw = 0\n\n    # The first card drawn is Theta's face-up card\n    theta_discard = int(deck[t])\n\n    while theta_draw:\n        # The first card in the Theta's hand is the first card drawn\n        if theta_hand[0] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The second card in the Theta's hand is the first card drawn\n        elif theta_hand[1] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The third card in the Theta's hand is the first card drawn\n        elif theta_hand[2] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The fourth card in the Theta's hand is the first card drawn\n        elif theta_hand[3] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The fifth card in the Theta's hand is the first card drawn\n        elif theta_hand[4] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The sixth card in the Theta's hand is the first card drawn\n        elif theta_hand[5] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The seventh card in the Theta's hand is the first card drawn\n        elif theta_hand[6] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The eighth card in the Theta's hand is the first card drawn\n        elif theta_hand[7] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The ninth card in the Theta's hand is the first card drawn\n        elif theta_hand[8] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n        # The tenth card in the Theta's hand is the first card drawn\n        elif theta_hand[9] == theta_draw:\n            theta_hand.remove(theta_draw)\n            theta_draw = 0\n\n        # If the Theta's first card is a Jack, Theta can fill any of their\n        # remaining slots with the Jack by replacing one of their cards\n        elif theta_hand[0] == 1:\n            for i in range(len(theta_hand)):\n                if theta_hand[i] == 11:\n                    theta_hand[i] = 1\n                    break\n\n        # The second card in Theta's hand is the first card drawn\n        elif the"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution('23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5')\n    'Theta wins'\n    >>> solution('89724TJTA67K4J87Q8T6Q7J2324T558KA99A3KA356QJ6523QK49')\n    'Theta wins'\n    '''\n    deck = stdin\n    # Your code here\n    #\n    # card_to_num = {'A':1, 'J':11, 'Q':12, 'K':13, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10}\n    # # card_to_num = {'A':1, 'J':11, 'Q':12, 'K':13, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':10, 'Q':11, 'K':12}\n    # cards = []\n    # for i in range(52):\n    #     cards.append(deck[i])\n    #\n    # cards = cards[0:10]\n    # for card in cards:\n    #     print(card_to_num[card])\n\n    def print_cards(cards):\n        for card in cards:\n            print(card_to_num[card])\n\n    deck = stdin\n    # Your code here\n    cards = []\n    cards.append(deck[0:10])\n    cards.append(deck[10:20])\n    cards.append(deck[20:30])\n    cards.append(deck[30:40])\n    cards.append(deck[40:50])\n    cards.append(deck[50:60])\n    cards.append(deck[60:70])\n    cards.append(deck[70:80])\n    cards.append(deck[80:90])\n    cards.append(deck[90:100])\n    cards.append(deck[100:110])\n    cards.append(deck[110:120])\n    cards.append(deck[120:130])\n    cards.append(deck[130:140])\n    cards.append(deck[140:150])\n    cards.append(deck[150:160])\n    cards.append(deck[160:170])\n    cards.append(deck[170:180])\n    cards.append(deck[180:190])\n    cards.append(deck[190:200])\n    cards.append(deck[200:210])\n    cards.append(deck[210:220])\n    cards.append(deck[220:230])\n    cards.append(deck[230:240])\n    cards.append(deck[240:250])\n    cards.append(deck[250:260])\n    cards.append(deck[260:270])\n    cards.append(deck[270:280])\n    cards.append(deck[280:290])\n    cards.append(deck[290:300])\n    cards.append(deck[300:310])\n    cards.append(deck[310:320])\n    cards.append(deck[320:330])\n    cards.append(deck[330:340])\n    cards.append(deck[340:350])\n    cards.append(deck[350:360])\n    cards.append(deck[360:370])\n    cards.append(deck[370:380])\n    cards.append(deck[380:390])\n    cards.append(deck[390:400])\n    cards.append(deck[400:410])\n    cards.append(deck[410:420])\n    cards.append(deck[420:430])\n    cards.append(deck[430:440])\n    cards.append(deck[440:450])\n    cards.append(deck[450:460])\n    cards.append(deck[460:470])\n    cards.append(deck[470:480])\n    cards.append(deck[480:490])\n    cards.append(deck[490:500])\n    cards.append("
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    cards = stdin.split(\"T\")\n    deck = [i for i in range(52)]\n    discard = [False for i in range(52)]\n    Theta = [False for i in range(52)]\n    Theta_deck = [False for i in range(52)]\n    friend = [False for i in range(52)]\n    for i in range(52):\n        Theta[i] = i < 10\n        Theta_deck[i] = i < 10\n        friend[i] = i < 10\n    Theta_draw = []\n    friend_draw = []\n    for i in range(10):\n        Theta_draw.append(deck.pop(0))\n        friend_draw.append(deck.pop(0))\n    while len(deck) > 0:\n        if Theta_deck[Theta_draw[0]] == True:\n            if Theta_deck[Theta_draw[0]] == True:\n                Theta_deck[Theta_draw[0]] = False\n                Theta[Theta_draw[0]] = False\n                Theta_draw.append(deck.pop(0))\n        elif Theta_deck[Theta_draw[0]] == False:\n            Theta[Theta_draw[0]] = False\n            Theta_draw.append(deck.pop(0))\n        if Theta_deck[Theta_draw[0]] == True:\n            if Theta_deck[Theta_draw[0]] == True:\n                Theta_deck[Theta_draw[0]] = False\n                Theta[Theta_draw[0]] = False\n                Theta_draw.append(deck.pop(0))\n        elif Theta_deck[Theta_draw[0]] == False:\n            Theta[Theta_draw[0]] = False\n            Theta_draw.append(deck.pop(0))\n    for i in range(10):\n        if Theta_deck[Theta_draw[i]] == True:\n            if Theta_deck[Theta_draw[i]] == True:\n                Theta_deck[Theta_draw[i]] = False\n                Theta[Theta_draw[i]] = False\n                Theta_draw.append(deck.pop(0))\n        elif Theta_deck[Theta_draw[i]] == False:\n            Theta[Theta_draw[i]] = False\n            Theta_draw.append(deck.pop(0))\n        if Theta_deck[Theta_draw[i]] == True:\n            if Theta_deck[Theta_draw[i]] == True:\n                Theta_deck[Theta_draw[i]] = False\n                Theta[Theta_draw[i]] = False\n                Theta_draw.append(deck.pop(0))\n        elif Theta_deck[Theta_draw[i]] == False:\n            Theta[Theta_draw[i]] = False\n            Theta_draw.append(deck.pop(0))\n    Theta_draw.reverse()\n    friend_draw.reverse()\n    friend_draw.append(friend_draw.pop(0))\n    friend_draw.append(friend_draw.pop(0))\n    for i in range(len(friend_draw)):\n        if friend_draw[i] == Theta_draw[i] - 1:\n            Theta[friend_draw[i]] = True\n        else:\n            Theta[friend_draw[i]] = False\n    for i in range(52):\n        if friend[i] == True:\n            if friend_draw[0] == i:\n                friend[i] = False\n    print(Theta)\n    print(friend_draw)\n    print(Theta_draw)\n    return \"Theta wins\" if Theta_deck.count(True) == 0 else \"Theta loses\"\n\nsolution(\"23456789TJ23456789TJA89Q66JK37T2A4AQK3AK5T8Q24K97JQ5\")\n"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds winner of the game between Theta and a friend.\n\n    :param stdin: str: shuffled deck of cards\n    :return: str: Theta wins or Theta loses\n    \"\"\"\n    cards_remaining = 52\n    theta_hand = [None for _ in range(10)]\n    theta_hand[0] = \"A\"\n    theta_hand[1] = \"2\"\n    theta_hand[2] = \"3\"\n    theta_hand[3] = \"4\"\n    theta_hand[4] = \"5\"\n\n    for i in range(5):\n        theta_hand[5 + i] = \"6\"\n        theta_hand[10 + i] = \"7\"\n        theta_hand[15 + i] = \"8\"\n        theta_hand[20 + i] = \"9\"\n        theta_hand[25 + i] = \"T\"\n\n    theta_hand[30] = \"J\"\n    theta_hand[35] = \"Q\"\n    theta_hand[40] = \"K\"\n\n    theta_hand[0] = \"A\"\n    theta_hand[1] = \"2\"\n    theta_hand[2] = \"3\"\n    theta_hand[3] = \"4\"\n    theta_hand[4] = \"5\"\n\n    friend_hand = [None for _ in range(10)]\n    friend_hand[0] = \"A\"\n    friend_hand[1] = \"2\"\n    friend_hand[2] = \"3\"\n    friend_hand[3] = \"4\"\n    friend_hand[4] = \"5\"\n\n    for i in range(5):\n        friend_hand[5 + i] = \"6\"\n        friend_hand[10 + i] = \"7\"\n        friend_hand[15 + i] = \"8\"\n        friend_hand[20 + i] = \"9\"\n        friend_hand[25 + i] = \"T\"\n\n    friend_hand[30] = \"J\"\n    friend_hand[35] = \"Q\"\n    friend_hand[40] = \"K\"\n\n    theta_num_cards = 0\n    friend_num_cards = 0\n\n    for c in stdin:\n        if c == \"T\":\n            theta_num_cards += 1\n        elif c == \"A\":\n            theta_num_cards += 1\n        elif c == \"J\":\n            theta_num_cards += 1\n        elif c == \"Q\":\n            theta_num_cards += 1\n        elif c == \"K\":\n            theta_num_cards += 1\n        elif c == \"2\":\n            theta_num_cards += 1\n        elif c == \"3\":\n            theta_num_cards += 1\n        elif c == \"4\":\n            theta_num_cards += 1\n        elif c == \"5\":\n            theta_num_cards += 1\n        elif c == \"6\":\n            theta_num_cards += 1\n        elif c == \"7\":\n            theta_num_cards += 1\n        elif c == \"8\":\n            theta_num_cards += 1\n        elif c == \"9\":\n            theta_num_cards += 1\n\n        if c == \"T\":\n            friend_num_cards += 1\n        elif c == \"A\":\n            friend_num_cards += 1\n        elif c == \"J\":\n            friend_num_cards += 1\n        elif c == \"Q\":\n            friend_num_cards += 1\n        elif c == \"K\":\n            friend_num_cards += 1\n        elif c == \"2\":\n            friend_num_cards += 1\n        elif c == \"3\":\n            friend_num_cards += 1\n        elif c == \"4\":\n            friend_num_cards += 1\n        elif c == \"5\":\n            friend_num_cards += 1\n        elif c == \"6\":\n            friend_num_cards += 1\n        elif c == \"7\":\n            friend_num_cards += 1\n        elif c == \"8\":\n            friend_num_cards"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'Theta wins' if the Theta-friendly strategy wins, else 'Theta loses'\"\"\"\n\n    # Get the Theta's starting hand\n    start_hand = stdin[:10]\n    # Get the cards that Theta has discarded\n    discard_pile = stdin[10:20]\n    # Get the cards that Theta has kept\n    kept_hand = stdin[20:30]\n    # Get the cards that Theta has drawn\n    drawn_hand = stdin[30:]\n\n    # Make an empty list for keeping track of what cards are in the hand\n    cards_in_hand = []\n\n    # Loop through each of Theta's starting hand\n    for card in start_hand:\n        # If the card is an 'A'\n        if card == 'A':\n            # Add it to the list of cards in hand\n            cards_in_hand.append(1)\n        # Else if the card is a 2-9\n        elif card in '23456789':\n            # Add it to the list of cards in hand\n            cards_in_hand.append(int(card))\n\n    # Make an empty list for keeping track of what cards have been discarded\n    discarded_cards = []\n\n    # Loop through each card that Theta has discarded\n    for card in discard_pile:\n        # If the card is an 'A'\n        if card == 'A':\n            # Add it to the list of discarded cards\n            discarded_cards.append(1)\n        # Else if the card is a 2-9\n        elif card in '23456789':\n            # Add it to the list of discarded cards\n            discarded_cards.append(int(card))\n\n    # Make an empty list for keeping track of what cards have been kept\n    kept_cards = []\n\n    # Loop through each card that Theta has kept\n    for card in kept_hand:\n        # If the card is an 'A'\n        if card == 'A':\n            # Add it to the list of kept cards\n            kept_cards.append(1)\n        # Else if the card is a 2-9\n        elif card in '23456789':\n            # Add it to the list of kept cards\n            kept_cards.append(int(card))\n\n    # Make an empty list for keeping track of what cards have been drawn\n    drawn_cards = []\n\n    # Loop through each card that Theta has drawn\n    for card in drawn_hand:\n        # If the card is an 'A'\n        if card == 'A':\n            # Add it to the list of drawn cards\n            drawn_cards.append(1)\n        # Else if the card is a 2-9\n        elif card in '23456789':\n            # Add it to the list of drawn cards\n            drawn_cards.append(int(card))\n\n    # Make an empty list for keeping track of which cards remain\n    cards_remain = []\n\n    # Loop through each card remaining in the deck\n    for card in stdin[31:]:\n        # If the card is an 'A'\n        if card == 'A':\n            # Add it to the list of cards remaining\n            cards_remain.append(1)\n        # Else if the card is a 2-9\n        elif card in '23456789':\n            # Add it to the list of cards remaining\n            cards_remain.append(int(card))\n\n    # Calculate the score of Theta's starting hand\n    score_hand = sum(cards_in_hand)\n\n    # Calculate the score of the discarded cards\n    score_discard = sum(discarded_cards)\n\n    # Calculate the score of Theta's kept cards\n    score_kept = sum(kept_cards)\n\n    # Calculate the score of Theta's drawn cards\n    score_drawn = sum(drawn_cards)\n\n    # Calculate the score of Theta's remaining cards\n    score_remain = sum(cards_remain)\n\n    # Return the result based on the scores\n    return 'Theta wins' if score_hand > score_kept and score_kept > score_drawn and score_drawn > score_discard and score_discard > score_remain else 'Theta loses'\n"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    cards = list(stdin)\n    theta = []\n    for i in range(0, len(cards), 10):\n        for j in range(0, 10):\n            if cards[i + j] == \"A\":\n                theta.append(1)\n            elif cards[i + j] == \"J\":\n                theta.append(2)\n            elif cards[i + j] == \"Q\":\n                theta.append(3)\n            elif cards[i + j] == \"K\":\n                theta.append(4)\n            elif cards[i + j] == \"T\":\n                theta.append(10)\n\n    frnd = []\n    for i in range(0, len(cards), 10):\n        for j in range(0, 10):\n            if cards[i + j] == \"A\":\n                frnd.append(1)\n            elif cards[i + j] == \"J\":\n                frnd.append(2)\n            elif cards[i + j] == \"Q\":\n                frnd.append(3)\n            elif cards[i + j] == \"K\":\n                frnd.append(4)\n            elif cards[i + j] == \"T\":\n                frnd.append(10)\n\n    drawing_pile = cards[len(cards) - len(theta):]\n    discard = []\n\n    discard_counter = 0\n\n    while True:\n        if not drawing_pile:\n            break\n\n        theta_move = theta.pop()\n\n        # Case 1: theta played Ace, draw Jack\n        if theta_move == 1:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(10)\n            continue\n\n        # Case 2: theta played Jack, draw Ace\n        if theta_move == 2:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(1)\n            continue\n\n        # Case 3: theta played Queen, draw King\n        if theta_move == 3:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(4)\n            continue\n\n        # Case 4: theta played King, draw Queen\n        if theta_move == 4:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(3)\n            continue\n\n        # Case 5: theta played 2, draw 3\n        if theta_move == 10:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(7)\n            continue\n\n        # Case 6: theta played 3, draw 2\n        if theta_move == 7:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(6)\n            continue\n\n        # Case 7: theta played 4, draw 5\n        if theta_move == 6:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(8)\n            continue\n\n        # Case 8: theta played 5, draw 4\n        if theta_move == 8:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(9)\n            continue\n\n        # Case 9: theta played 6, draw 7\n        if theta_move == 9:\n            if not drawing_pile:\n                break\n            discard.append(drawing_pile.pop())\n            theta.append(10)\n            continue\n\n        if theta_move!= 10:\n            discard.append(drawing_pile.pop())\n            theta.append(theta_move)\n\n    while True:\n        if not frnd:\n            break\n        frnd_move = frnd.pop()\n\n        # Case 1: frnd played Ace, draw Jack\n        "
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Predict the winner.\"\"\"\n    # 1st row: Theta, 2nd row: friend\n    # Slots: A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K\n    Theta_cards = {0: 4, 1: 4, 2: 4, 3: 4, 4: 4, 5: 4, 6: 4, 7: 4, 8: 4, 9: 4, 10: 4, 11: 4, 12: 4, 13: 4}\n    friend_cards = {0: 4, 1: 4, 2: 4, 3: 4, 4: 4, 5: 4, 6: 4, 7: 4, 8: 4, 9: 4, 10: 4, 11: 4, 12: 4, 13: 4}\n\n    # Theta's turn\n    while len(stdin) > 0:\n        # Get the card\n        if stdin[0] == 'T':\n            Theta_card = int(stdin[1])\n            stdin = stdin[2:]\n            Theta_cards[Theta_card] -= 1\n            if Theta_cards[Theta_card] == 0:\n                # Theta loses\n                return 'Theta loses'\n            else:\n                # Theta's turn\n                stdin = stdin[1:]\n                if stdin[0] == 'J':\n                    # Jack\n                    Theta_cards[0] -= 1\n                    stdin = stdin[2:]\n                else:\n                    stdin = stdin[1:]\n        # Friend's turn\n        else:\n            # Get the card\n            friend_card = int(stdin[0])\n            stdin = stdin[1:]\n            friend_cards[friend_card] -= 1\n            if friend_cards[friend_card] == 0:\n                return 'Theta loses'\n            else:\n                # Theta's turn\n                Theta_card = min(Theta_cards.keys())\n                Theta_cards[Theta_card] -= 1\n                if Theta_cards[Theta_card] == 0:\n                    # Theta loses\n                    return 'Theta loses'\n                else:\n                    # Theta's turn\n                    Theta_cards[Theta_card] -= 1\n                    if Theta_cards[Theta_card] == 0:\n                        # Theta loses\n                        return 'Theta loses'\n\n    return 'Theta wins'\n"
    },
    {
        "number": 3170,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return \"Theta wins\" or \"Theta loses\".\"\"\"\n    def get_score(card: str) -> int:\n        \"\"\"Return the score for the card.\"\"\"\n        if card == \"K\":\n            return 10\n        elif card == \"Q\":\n            return 10\n        elif card == \"J\":\n            return 10\n        else:\n            return int(card)\n\n    theta_hand: List[int] = [get_score(card) for card in stdin[0:10]]\n    friend_hand: List[int] = [get_score(card) for card in stdin[10:20]]\n    for card in stdin[10:20]:\n        if card == \"T\":\n            theta_hand[-1] += 10\n            friend_hand[-1] += 10\n        elif card == \"A\":\n            theta_hand[-1] += 1\n            friend_hand[-1] += 1\n\n    for card in stdin[20:30]:\n        if card == \"T\":\n            theta_hand[-1] += 10\n            friend_hand[-1] += 10\n        elif card == \"A\":\n            theta_hand[-1] += 1\n            friend_hand[-1] += 1\n    for card in stdin[30:40]:\n        if card == \"T\":\n            theta_hand[-1] += 10\n            friend_hand[-1] += 10\n        elif card == \"A\":\n            theta_hand[-1] += 1\n            friend_hand[-1] += 1\n\n    for card in stdin[40:]:\n        if card == \"T\":\n            theta_hand[-1] += 10\n            friend_hand[-1] += 10\n        elif card == \"A\":\n            theta_hand[-1] += 1\n            friend_hand[-1] += 1\n\n    for i in range(4):\n        theta_hand.sort()\n        friend_hand.sort()\n        if theta_hand[i] > friend_hand[i]:\n            return \"Theta wins\"\n        elif theta_hand[i] < friend_hand[i]:\n            return \"Theta loses\"\n\n    return \"Theta wins\"\n"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nimport ast\nimport sys\nfrom typing import List, Tuple\n\n\ndef"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nfrom typing import Dict, List\n\nfrom aoc import integers\nfrom aoc.advent import day_12\nfrom aoc.utils import read_input_lines\n\n\ndef"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n'''\n"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the character type of the given candidate.\"\"\"\n    pass\n"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n\nassert solution(stdin) == result\n\n----Problem----\n\n\"\"\"\n\ndef"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_lhs_rhs(i: int) -> Tuple[str, str]:\n        rhs, lhs = stdin.split(' ')[i::2]\n        return lhs.strip('\\n'), rhs.strip('\\n')\n\n    def is_truther(lhs: str) -> bool:\n        return lhs == 'truther'\n\n    def is_fabulist(lhs: str) -> bool:\n        return lhs == 'fabulist'\n\n    def is_charlatan(lhs: str) -> bool:\n        return lhs == 'charlatan'\n\n    def is_not(lhs: str) -> bool:\n        return lhs == 'not'\n\n    def is_and(lhs: str) -> bool:\n        return lhs == 'and'\n\n    def is_xor(lhs: str) -> bool:\n        return lhs == 'xor'\n\n    i = 0\n    while i < len(stdin):\n        if is_not(stdin.split(' ')[i]):\n            lhs, rhs = get_lhs_rhs(i)\n            if is_not(lhs) and is_not(rhs):\n                i += 1\n                continue\n            if is_not(lhs) and is_charlatan(rhs):\n                return 'charlatan'\n            if is_not(rhs) and is_charlatan(lhs):\n                return 'charlatan'\n            if is_not(lhs) and is_fabulist(rhs):\n                return 'fabulist'\n            if is_not(rhs) and is_fabulist(lhs):\n                return 'fabulist'\n            if is_not(lhs) and is_truther(rhs):\n                return 'truther'\n            if is_not(rhs) and is_truther(lhs):\n                return 'truther'\n            if is_not(lhs) and is_not(rhs):\n                return 'unknown'\n            if is_not(rhs) and is_not(lhs):\n                return 'unknown'\n            if is_not(lhs) and is_and(rhs):\n                lhs, rhs = get_lhs_rhs(i)\n                if is_not(lhs) and is_not(rhs):\n                    return 'unknown'\n                if is_not(lhs) and is_charlatan(rhs):\n                    return 'fabulist'\n                if is_not(rhs) and is_charlatan(lhs):\n                    return 'charlatan'\n                if is_not(lhs) and is_fabulist(rhs):\n                    return 'truther'\n                if is_not(rhs) and is_fabulist(lhs):\n                    return 'fabulist'\n                if is_not(lhs) and is_truther(rhs):\n                    return 'charlatan'\n                if is_not(rhs) and is_truther(lhs):\n                    return 'truther'\n            if is_not(lhs) and is_and(rhs):\n                lhs, rhs = get_lhs_rhs(i)\n                if is_not(lhs) and is_not(rhs):\n                    return 'unknown'\n                if is_not(lhs) and is_charlatan(rhs):\n                    return 'truther'\n                if is_not(rhs) and is_charlatan(lhs):\n                    return 'charlatan'\n                if is_not(lhs) and is_fabulist(rhs):\n                    return 'fabulist'\n                if is_not(rhs) and is_fabulist(lhs):\n                    return 'fabulist'\n                if is_not(lhs) and is_truther(rhs):\n                    return 'charlatan'\n                if is_not(rhs) and is_truther(lhs):\n                    return 'truther'\n            if is_not(lhs) and is_xor(rhs):\n                lhs, rhs = get_lhs_rhs(i)\n                if is_not(lhs) and is_not(rhs):\n                    return 'unknown'\n                if is_not(lhs) and is_charlatan(rhs):\n                    return 'truther'\n                if is_not(rhs) and is_charlatan(lhs):\n                    return 'charlatan'\n                if is_not(lhs) and is_fabulist(rhs):\n                    return 'truther'\n                if is_not(rhs) and is_fabulist(lhs):\n                    return 'fabulist'\n                if is_not"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    truther_counter = 0\n    fabulist_counter = 0\n    charlatan_counter = 0\n    prev_speaker = None\n    for line in stdin.split('\\n'):\n        speaker, statement = map(int, line.split())\n        if speaker == prev_speaker:\n            continue\n        prev_speaker = speaker\n        if statement == 1:\n            truther_counter += 1\n        elif statement == 2:\n            fabulist_counter += 1\n        elif statement == 3:\n            charlatan_counter += 1\n        else:\n            raise Exception(f\"Unknown statement {statement}\")\n    return 'charlatan' if charlatan_counter > fabulist_counter and charlatan_counter > truther_counter else 'fabulist' if fabulist_counter > truther_counter and fabulist_counter > charlatan_counter else 'truther'\n\"\"\"\n\nimport sys\n\ninput = sys.stdin.readlines()\n\ntruther_counter = 0\nfabulist_counter = 0\ncharlatan_counter = 0\n\nspeaker = None\nstatement = None\n\nfor line in input:\n    line = line.strip()\n    line = line.split()\n    speaker = int(line[0])\n    statement = int(line[1])\n    if statement == 1:\n        truther_counter += 1\n    elif statement == 2:\n        fabulist_counter += 1\n    elif statement == 3:\n        charlatan_counter += 1\n    else:\n        raise Exception(f\"Unknown statement {statement}\")"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n ...\n  return \"\"\n"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def parse_stdin(stdin):\n        lines = stdin.splitlines()\n        debate = lines[0].split()\n        n, k = int(debate[0]), int(debate[1])\n        candidates = {}\n        for i in range(k):\n            line = lines[i + 1].split()\n            speaker, statement = int(line[0]), line[1:]\n            candidates[speaker] = statement\n        return n, candidates\n    def is_true(statement):\n        if len(statement) == 1 and statement[0] == 'true':\n            return True\n        if len(statement) == 3 and statement[0] == 'and' and statement[1] == 'true' and statement[2] == 'true':\n            return True\n        if len(statement) == 3 and statement[0] == 'or' and statement[1] == 'true' and statement[2] == 'true':\n            return True\n        if len(statement) == 2 and statement[0] == 'xor' and statement[1] == 'true':\n            return True\n        if len(statement) == 2 and statement[0] == 'not' and statement[1] == 'true':\n            return True\n        return False\n    def claim_truther(speaker):\n        claim = 'charlatan' if speaker == 1 else 'truther'\n        candidates[speaker] = [claim]\n    def claim_fabulist(speaker):\n        claim = 'charlatan' if speaker == 1 else 'fabulist'\n        candidates[speaker] = [claim]\n    def claim_charlatan(speaker):\n        claim = 'fabulist' if speaker == 1 else 'charlatan'\n        candidates[speaker] = [claim]\n    n, candidates = parse_stdin(stdin)\n    for speaker, statement in candidates.items():\n        if is_true(statement):\n            claim_truther(speaker)\n            break\n    for speaker, statement in candidates.items():\n        if is_true(statement) and speaker!= 1:\n            claim_fabulist(speaker)\n            break\n    for speaker, statement in candidates.items():\n        if is_true(statement):\n            claim_charlatan(speaker)\n            break\n    return '\\n'.join([claim for speaker, claim in candidates.items()])\n\ndef"
    },
    {
        "number": 3171,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return '-1'\n"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # n = int(stdin.readline())\n    # x1, y1, x2, y2 = map(float, stdin.readline().split())\n    # for _ in range(n - 1):\n    #     x1, y1, x2, y2 = map(float, stdin.readline().split())\n    # return 0\n\ndef"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    points = []\n    for i in range(1, n + 1):\n        x, y = lines[i].split()\n        points.append([float(x), float(y)])\n    n = len(points)\n    if n <= 1:\n        return 1\n    points.sort()\n    points.sort(key=lambda x: x[1])\n    points.sort(key=lambda x: x[0])\n    num = 0\n    s = 0\n    for i in range(n):\n        left = points[i][0]\n        right = points[i][1]\n        for j in range(i + 1, n):\n            if points[j][0] < right:\n                break\n        else:\n            num += 1\n            s += right - left\n            continue\n        for j in range(i + 1, n):\n            if left < points[j][0] <= right:\n                break\n        else:\n            num += 1\n            s += right - left\n            continue\n        while i + 1 < j < n - 1 and points[j][1] > points[j - 1][1]:\n            s += points[j][1] - points[j - 1][1]\n            j -= 1\n        while i < j and points[j][0] > points[j - 1][0]:\n            s += points[j][0] - points[j - 1][0]\n            j -= 1\n        num += 1\n        s += right - left\n    return num\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    x_list = [float(i) for i in stdin.split('\\n')[1:]]\n    def get_max(n: int, x_list: list) -> int:\n        import math\n        # list of (x, y)\n        points = []\n        for i in range(n):\n            points.append((x_list[i*2], x_list[i*2 + 1]))\n        # return maximum number of circles\n        def count_circles(points: list) -> int:\n            import math\n            # n = number of points\n            # r = radius of circle\n            # x, y = coordinate of center\n            n = len(points)\n            r = 0\n            x, y = 0, 0\n            count = 0\n            for i in range(n):\n                d = 0\n                for j in range(n):\n                    if i == j:\n                        continue\n                    dx = points[i][0] - points[j][0]\n                    dy = points[i][1] - points[j][1]\n                    d = math.sqrt((dx * dx) + (dy * dy))\n                if d < r:\n                    count += 1\n                else:\n                    if d > r:\n                        r = d\n                        x, y = points[i][0], points[i][1]\n            if r < 10 ** -4:\n                return count\n            count += 1\n            return count_circles(points)\n\n        return count_circles(points)\n\n    return str(get_max(n, x_list))"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Slicing fruit\n    return the maximum number of fruits that can be sliced with one straight-line swipe.\n    A swipe slices a fruit if the line intersects the inner part or the boundary of the fruit.\n    \"\"\"\n    \n    # Getting input\n    n = int(stdin.readline())\n    fruits = []\n    for _ in range(n):\n        x, y = stdin.readline().split()\n        fruits.append((float(x), float(y)))\n    \n    # Sorting by x-coordinate\n    fruits.sort(key=lambda x: x[0])\n    \n    # Initialise variables\n    res, temp, max_cnt = 0, 0, 0\n    \n    for i in range(n):\n        # If new fruit has the same x-coordinate, create new temp variable\n        if fruits[i][0] == temp:\n            temp = fruits[i][0]\n            max_cnt = temp\n        # If new fruit does not have the same x-coordinate, reset temp variable and increase the count of res\n        else:\n            temp = fruits[i][0]\n            max_cnt = temp\n            res += max_cnt\n    \n    # Last fruit has different x-coordinate\n    res += max_cnt\n    \n    # Output\n    return str(res)"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Criado por Anthony Silva no URI:\n    https://www.urionlinejudge.com.br/judge/pt/problems/view/1141\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum number of fruits that can be sliced with one straight-line swipe.\n    A swipe slices a fruit if the line intersects the inner part or the boundary of the fruit.\n    >>> solution(\"\"\"5\n   ... 1.00 5.00\n   ... 3.00 3.00\n   ... 4.00 2.00\n   ... 6.00 4.50\n   ... 7.00 1.00\n   ... \"\"\")\n    4\n    >>> solution(\"\"\"3\n   ... -1.50 -1.00\n   ... 1.50 -1.00\n   ... 0.00 1.00\n   ... \"\"\")\n    3\n    \"\"\"\n    return None\n"
    },
    {
        "number": 3172,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # get number of fruits\n    n = int(stdin)\n\n    # get coordinates for each fruit\n    xs, ys = [], []\n    for _ in range(n):\n        x, y = map(float, stdin.split('\\n')[0].split())\n        xs.append(x)\n        ys.append(y)\n\n    # create a 2D array of distances between each fruit\n    dist = [[x, y] for x, y in zip(xs, ys)]\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                dist[i].append(dist[j][0] - dist[i][0])\n                dist[i].append(dist[j][1] - dist[i][1])\n    # print(dist)\n\n    # find best path through this 2D array\n    best_path = 0\n    for i in range(2 * n):\n        for j in range(2 * n):\n            if j + i <= 2 * n - 1 and j + i >= 2 * n - 2:\n                if dist[i][j] == dist[i][j + 1] + dist[i + 1][j + 1] - dist[i + 1][j]:\n                    best_path += 1\n    # print(best_path)\n    return best_path\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import factorial\n\n    def check(stdin: str) -> str:\n        rows, cols, num_of_parts = stdin[0].split()\n        rows, cols, num_of_parts = int(rows), int(cols), int(num_of_parts)\n        grid = [[0] * cols for _ in range(rows)]\n        for row in range(rows):\n            grid[row] = [0] + stdin[row + 1].split()\n\n        count_parts = 0\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                if grid[i][j] == 'X':\n                    grid[i][j] = '?'\n                elif grid[i][j] == '?':\n                    grid[i][j] = 'X'\n                    count_parts += 1\n                if grid[i][j + 1] == 'R':\n                    grid[i][j] = 'R'\n                elif grid[i][j + 1] == '?':\n                    grid[i][j] = 'L'\n                    count_parts += 1\n                if grid[i + 1][j] == 'R':\n                    grid[i][j] = 'R'\n                elif grid[i + 1][j] == '?':\n                    grid[i][j] = 'L'\n                    count_parts += 1\n        return (rows, cols, count_parts)\n\n    def is_on_last_row(grid, i, j):\n        if i == len(grid) - 1:\n            return True\n        return False\n\n    def get_score(grid, i, j):\n        if is_on_last_row(grid, i, j):\n            return grid[i][j]\n        else:\n            return 0\n\n    def get_next_coords(grid, i, j, dir):\n        if dir == 'R':\n            if grid[i][j + 1] == 'R' or grid[i][j + 1] == '?':\n                return i, j + 1\n            elif grid[i][j + 1] == 'L':\n                return i + 1, j\n        else:\n            if grid[i][j - 1] == 'R' or grid[i][j - 1] == '?':\n                return i, j - 1\n            elif grid[i][j - 1] == 'L':\n                return i + 1, j\n        return None\n\n    def get_next_dir(grid, i, j, dir):\n        if dir == 'R':\n            if grid[i][j + 1] == 'R' or grid[i][j + 1] == '?':\n                return 'R'\n            else:\n                return 'L'\n        else:\n            if grid[i][j - 1] == 'R' or grid[i][j - 1] == '?':\n                return 'R'\n            else:\n                return 'L'\n\n    def solve_puzzle(grid, count_parts):\n        def get_next_num(grid, num):\n            return int(grid[num][0])\n\n        def next_part(grid):\n            nonlocal num_of_parts\n            num_of_parts -= 1\n            for i in range(rows):\n                for j in range(cols - 1):\n                    if grid[i][j + 1] == '?':\n                        grid[i][j] = str(get_next_num(grid, j))\n                    if grid[i + 1][j] == '?':\n                        grid[i][j] = str(get_next_num(grid, j))\n            grid[0][0] = str(get_next_num(grid, 0))\n            grid[rows - 1][cols - 1] = str(get_next_num(grid, cols - 1))\n\n        def solve_puzzle_helper(grid, num_of_parts):\n            nonlocal count_parts\n            if num_of_parts == 0:\n                return grid\n            next_part(grid)\n            for i in range(rows):\n                for j in range(cols - 1):\n                    if grid[i][j] == 'X':\n                        grid[i][j] = '.'\n            res = solve_puzzle_helper(grid, num_of_parts)\n            if res:\n                return res\n            else:\n                next_part(grid)\n                for i in range(rows):\n                    for j in range(cols - 1):\n                        if grid[i][j] == 'X':\n                            grid[i][j] = '.'\n                return solve_puzzle_helper(grid, num_of_parts)\n\n        return solve_puzzle"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = stdin.split(' ')\n    R, C, K = int(R), int(C), int(K)\n    parts = []\n    for _ in range(R):\n        parts.append(stdin.split('\\n')[1:][0])\n    scores = [int(x) for x in stdin.split('\\n')[-C:]]\n    max_score = 0\n    for c in range(C):\n        max_score += scores[c]\n    visited = [0 for _ in range(C)]\n    part = 0\n    while True:\n        for i in range(R):\n            if not visited[part]:\n                visited[part] = 1\n                for j in range(C):\n                    if parts[i][j] == 'X':\n                        if j == part:\n                            max_score -= 1\n                        else:\n                            visited[j] = 1\n                    elif parts[i][j] == '?':\n                        visited[j] = 1\n                    elif parts[i][j] == 'R':\n                        if j == C - 1:\n                            max_score -= 1\n                        else:\n                            visited[j] = 1\n                    elif parts[i][j] == 'L':\n                        if j == 0:\n                            max_score -= 1\n                        else:\n                            visited[j] = 1\n        if max_score < K or max_score > 10 ** 20:\n            break\n        part += 1\n        if part == C:\n            break\n    return str(max_score)\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    K, R, C = [int(n) for n in stdin.split(' ')]\n    grid = [stdin[i:i + C] for i in range(0, len(stdin), C)]\n    return max(solution_helper(grid, 0, 0, K, R, C))\n\n\ndef"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k = map(int, stdin.split())\n    l = [list(stdin[i:i + c]) for i in range(0, len(stdin), c)]\n    score = [[0 for _ in range(c)] for _ in range(r)]\n    score[0] = l[0]\n    k -= 1\n    for i in range(1, r):\n        for j in range(c):\n            if l[i][j] == 'R':\n                for j2 in range(j + 1, c):\n                    if l[i][j2] == '?':\n                        l[i][j2] = 'R'\n                        break\n                    if l[i][j2] == 'X':\n                        l[i][j2] = 'R'\n                        break\n            elif l[i][j] == 'L':\n                for j2 in range(0, j):\n                    if l[i][j2] == '?':\n                        l[i][j2] = 'L'\n                        break\n                    if l[i][j2] == 'X':\n                        l[i][j2] = 'L'\n                        break\n            elif l[i][j] == '?':\n                for j2 in range(0, c):\n                    if l[i][j2] == '?':\n                        l[i][j2] = 'R'\n                        break\n                    if l[i][j2] == 'X':\n                        l[i][j2] = 'R'\n                        break\n            elif l[i][j] == 'X':\n                for j2 in range(0, c):\n                    if l[i][j2] == 'X':\n                        l[i][j2] = 'R'\n                        break\n                    if l[i][j2] == '?':\n                        l[i][j2] = 'L'\n                        break\n    for i in range(r):\n        for j in range(c):\n            if l[i][j] == 'R' or l[i][j] == 'L':\n                score[i][j] = -1\n            elif l[i][j] == '?':\n                score[i][j] = -1\n            elif l[i][j] == '.':\n                score[i][j] = 0\n    for j in range(c):\n        score[r - 1][j] = l[r - 1][j]\n    for i in range(r - 2, -1, -1):\n        for j in range(c):\n            if score[i + 1][j] == -1:\n                score[i][j] = -1\n            elif score[i][j] == -1:\n                score[i][j] = -1\n            elif score[i + 1][j] == -1:\n                score[i][j] = -1\n            elif score[i + 1][j] == '.' and score[i][j] == 0:\n                score[i][j] = 0\n            elif score[i][j] == 0:\n                score[i][j] = score[i + 1][j]\n            elif score[i][j] == 'X':\n                score[i][j] = score[i + 1][j]\n    for i in range(r):\n        for j in range(c):\n            if score[i][j] == -1:\n                score[i][j] = 0\n    for i in range(r):\n        for j in range(c):\n            if score[i][j] == 0:\n                score[i][j] = -1\n    score[r - 1][c - 1] = l[r - 1][c - 1]\n    print(score)\n    for i in range(r):\n        if score[i][c - 1] == 0:\n            score[i][c - 1] = -1\n    print(score)\n    return sum(score[0])\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    test_case = stdin.split('\\n')\n    print(test_case)\n    return \"asd\"\n\nprint(solution(test_case))\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Write your code here\n    '''\n    stdin = stdin.split('\\n')\n    R, C, K = stdin[0].split()\n    R, C, K = int(R), int(C), int(K)\n\n    grid = []\n    for i in range(R):\n        grid.append([])\n        for j in stdin[i + 1].split():\n            grid[i].append(j)\n\n    def test(grid):\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'R' or grid[i][j] == 'L':\n                    return False\n        return True\n\n    def find_max(grid):\n        max_val = 0\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j]!= '?' and grid[i][j] > max_val:\n                    max_val = grid[i][j]\n        return max_val\n\n    def check_grid(grid, k, R, C, ans):\n        for i in range(R):\n            if k:\n                break\n            for j in range(C):\n                if grid[i][j] == 'R':\n                    if j > 0:\n                        grid[i][j] = 'L'\n                        k += 1\n                    else:\n                        return False\n                elif grid[i][j] == 'L':\n                    if j < C - 1:\n                        grid[i][j] = 'R'\n                        k += 1\n                    else:\n                        return False\n                elif grid[i][j] == '?':\n                    if j == 0 or j == C - 1:\n                        grid[i][j] = 'R'\n                        k += 1\n                    else:\n                        return False\n        return True\n\n    def check_grid2(grid, k, R, C, ans):\n        for i in range(R):\n            if k:\n                break\n            for j in range(C):\n                if grid[i][j] == 'R':\n                    if j > 0:\n                        grid[i][j] = 'L'\n                        k += 1\n                    else:\n                        return False\n                elif grid[i][j] == 'L':\n                    if j < C - 1:\n                        grid[i][j] = 'R'\n                        k += 1\n                    else:\n                        return False\n                elif grid[i][j] == '?':\n                    if j == 0 or j == C - 1:\n                        grid[i][j] = 'R'\n                        k += 1\n                    else:\n                        return False\n        return True\n\n    def dfs(k, R, C, grid):\n        if k == K:\n            ans = 0\n            for i in range(R):\n                for j in range(C):\n                    if grid[i][j] == 'R':\n                        ans += max_val\n                    elif grid[i][j] == 'L':\n                        ans += max_val\n                    elif grid[i][j] == '?':\n                        ans += max_val\n            return ans\n        else:\n            max_val = find_max(grid)\n            for i in range(R):\n                for j in range(C):\n                    if grid[i][j] == '?':\n                        grid[i][j] = 'R'\n                        k += 1\n                        if check_grid(grid, k, R, C, ans):\n                            ans = dfs(k, R, C, grid)\n                            grid[i][j] = '?'\n                            k -= 1\n                        grid[i][j] = 'L'\n                        k += 1\n                        if check_grid(grid, k, R, C, ans):\n                            ans = dfs(k, R, C, grid)\n                            grid[i][j] = '?'\n                            k -= 1\n                        grid[i][j] = 'R'\n                        k += 1\n                        if check_grid2(grid, k, R, C, ans):\n                            ans = dfs(k, R, C, grid)\n                            grid[i][j] = '?'\n                            k -= 1\n                        grid[i][j] = 'L'\n                        k += 1\n                        if check_grid2(grid, k, R, C, ans):\n                            ans = dfs(k, R, C, grid)\n                            grid[i][j] = '?'\n                            k -= 1\n                        grid[i][j] = 'R'\n                        k += 1\n            return ans\n\n    if K < C or R < 2:\n        return '0'\n    elif K == C and test(grid):\n        return str(find_max(grid))\n    else:"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    row, col, K = [int(s) for s in stdin.split(' ')]\n    grid = [stdin.split('\\n')[i][j] for i in range(row) for j in range(col)]\n    return grid\n"
    },
    {
        "number": 3173,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = [i.split(\"\\n\") for i in stdin.split(\"\\n\\n\")]\n    rows = inputs[0][0].split(\"\\n\")\n    columns = inputs[0][1].split(\"\\n\")\n    num_rows = len(rows)\n    num_columns = len(columns)\n    num_parts = len(rows[0])\n    \n    num_obstacles = num_columns - num_parts\n    num_conveyor_belts = num_parts\n    \n    conveyor_belts = [False] * num_parts\n    \n    for c in columns:\n        conveyor_belts[num_obstacles:] = [True] * num_obstacles\n        num_obstacles = num_obstacles - 1\n    \n    board = []\n    for row in rows:\n        row = list(row)\n        for i in range(num_columns):\n            if row[i] == \"R\":\n                conveyor_belts[i] = False\n            elif row[i] == \"L\":\n                conveyor_belts[i] = True\n            else:\n                conveyor_belts[i] = False\n        board.append(row)\n    \n    num_rows = len(board)\n    num_columns = len(board[0])\n    \n    belt_to_right = [False] * num_rows\n    belt_to_left = [False] * num_rows\n    \n    for i in range(num_rows):\n        for j in range(num_columns):\n            if board[i][j] == \"R\":\n                belt_to_right[i] = True\n            elif board[i][j] == \"L\":\n                belt_to_left[i] = True\n    \n    for i in range(num_rows):\n        for j in range(num_columns):\n            if board[i][j] == \"?\":\n                if i > 0 and belt_to_left[i] and belt_to_left[i - 1]:\n                    belt_to_left[i] = False\n                elif i < num_rows - 1 and belt_to_right[i] and belt_to_right[i + 1]:\n                    belt_to_right[i] = False\n                else:\n                    board[i][j] = \"X\"\n    \n    \n    for row in board:\n        print(\"\".join(row))\n    \n    num_rows = len(board)\n    num_columns = len(board[0])\n    \n    ball_column = [0] * num_columns\n    for j in range(num_columns):\n        for i in range(num_rows):\n            if board[i][j]!= \"X\":\n                ball_column[j] += int(board[i][j])\n    \n    print(ball_column)\n    \n    for i in range(num_columns):\n        for j in range(num_rows):\n            if board[j][i] == \"X\":\n                board[j][i] = \".\"\n    \n    for row in board:\n        print(\"\".join(row))\n    \n    \n    for i in range(num_columns):\n        for j in range(num_rows):\n            if board[j][i]!= \"X\":\n                board[j][i] = str(ball_column[i] - int(board[j][i]))\n    \n    print(\"\\n\".join([\"\".join(row) for row in board]))\n    \n    for i in range(num_columns):\n        for j in range(num_rows):\n            if board[j][i]!= \"X\":\n                board[j][i] = \".\"\n    \n    for row in board:\n        print(\"\".join(row))\n    \n    return board[-1][0]\n\n\ndef"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.readlines()\n    n, k = list(map(int, input[0].split()))\n    cities = []\n    for i in range(1, n+1):\n        cities.append(list(map(int, input[i].split())))\n\n    def is_possible(l: int) -> bool:\n        roads = []\n        for c in cities:\n            roads.append(c[0] + c[1])\n        total = sum(roads)\n        c = 0\n        for i in roads:\n            c += (i//k) * (i%k)\n        if total % k!= c:\n            return False\n        return True\n    l = 1\n    r = 10000\n    while r-l > 0.001:\n        m = (r + l) / 2\n        if is_possible(m):\n            r = m\n        else:\n            l = m\n    print(r)\n    return \"\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return''.join(map(str, (solve(stdin.split('\\n')))))\n\ndef"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x: int) -> bool:\n        k = stdin[0]\n        l = list(map(int, stdin[1].split()))\n        while l:\n            if x % k == 0:\n                return True\n            x = sum(l)\n            l = list(map(int, stdin[1].split()))\n        return False\n    l, r = 0, 1000000000\n    while l + 1 < r:\n        mid = (l + r) / 2\n        if is_valid(mid):\n            l = mid\n        else:\n            r = mid\n    return str(round(r, 3))"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    numbers = []\n    for _ in range(N):\n        x, y, k = map(int, stdin.readline().split())\n        numbers.append([x, y, k])\n    numbers = sorted(numbers, key=lambda x: x[2])\n    for i in range(N):\n        if numbers[i][2] > K:\n            return str(numbers[i - 1][2] / numbers[i][2])\n    return str(numbers[N - 1][2] / numbers[0][2])\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_of_cities, num_of_roads, max_road_length = [int(n) for n in stdin.split()]\n    cities = [int(n) for n in stdin.splitlines()[1:]]\n    cities_to_connect = []\n    for x, y, k in cities:\n        if k % num_of_roads!= 0:\n            raise ValueError('Invalid input')\n        cities_to_connect.append((x, y, k // num_of_roads))\n    roads = combinations(cities_to_connect, 2)\n    roads_distance = [(x1[0] - x0[0], x1[1] - x0[1]) for x0, x1 in roads]\n    roads_distance_length = sum(sqrt(x ** 2 + y ** 2) for x, y in roads_distance)\n    if roads_distance_length > max_road_length:\n        raise ValueError('Invalid input')\n    return str(round(max_road_length / roads_distance_length, 3))\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your runtime beats 96.81 % of python3 submissions\"\"\"\n    n, k = map(int, stdin.readline().split())\n    coords = [list(map(int, stdin.readline().split())) for i in range(n)]\n    coords.sort()\n    road = [coords[0]]\n    for i in range(1, n):\n        if road[-1][1] - coords[i][1] <= k:\n            road.append(coords[i])\n        else:\n            break\n    road.sort(key=lambda x: x[0])\n    if road[-1][0] == road[0][0]:\n        return f'{abs(road[0][0] - road[-1][0]) / road[-1][1]:.3f}'\n    k_road = 0\n    for i in range(1, n):\n        if road[i - 1][1]!= road[i][1]:\n            k_road = road[i - 1][0] - road[i][0]\n            break\n    d = road[0][0] - road[-1][0]\n    if k_road:\n        d = min(d, k_road)\n    return f'{d / road[-1][1]:.3f}'\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution\"\"\"\n    # Task 1: Compute d.\n    # Task 2: Compute r.\n    # Task 3: Compute c.\n    pass"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split(\"\\n\")[:2]]\n    cities = [tuple(int(y) for y in x.split()) for x in stdin.split(\"\\n\")[2:]]\n\n    def divisible_by_k(lst: list) -> bool:\n        return any(sum(lst[:i] + lst[i + 1 :]) % k == 0 for i in range(len(lst)))\n\n    def optimal_distance(lst: list) -> float:\n        max_distance = 0\n        for i in range(len(lst)):\n            for j in range(i + 1, len(lst)):\n                distance = ((lst[i][0] - lst[j][0]) ** 2 + (lst[i][1] - lst[j][1]) ** 2) ** 0.5\n                max_distance = max(max_distance, distance)\n        return max_distance\n\n    cities.sort()\n    start = cities[0][0]\n    end = cities[-1][0]\n    distance = end - start\n    while distance >= 0:\n        if divisible_by_k([c[1] for c in cities[:distance]]):\n            return str(round(optimal_distance([c[0] for c in cities[:distance]]), 3))\n        distance -= 1\n    return \"inf\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *nums = [int(i) for i in stdin.split()]\n    nums.sort(reverse=True)\n    return str(round(sum([num * (num - 1) / 2 for num in nums]) / (n * (n - 1) / 2), 4))\n\n\ndef"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    return str(max(solution(stdin)[2]))"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Parameters:\n        stdin: inputted lines as a string\n    Returns:\n        string: the maximum area of a polygon\n    '''\n    lines = stdin.split('\\n')\n    n, *lengths = map(int, lines[0].split())\n    if n < 3 or n > 80:\n        return '0'\n    s = sorted(lengths)\n    d = {}\n    d[tuple(s)] = 1\n    i = 2\n    while i < n:\n        c = list(s)\n        c[0] += s[1]\n        c[1] += s[0]\n        s = c\n        if tuple(s) in d:\n            break\n        i += 1\n    else:\n        return '0'\n    i = 2\n    while i < n:\n        c = list(s)\n        c[0] += s[1]\n        c[1] += s[0]\n        s = c\n        d[tuple(s)] = i\n        i += 1\n    s = list(s)\n    return '%.5f' % ((s[0] * s[1]) / (2 * (s[0] + s[1])))\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds largest possible area of a polygon.\"\"\"\n    segments = [int(length) for length in stdin.split()]\n    segments.sort()\n    polygon_area = 0\n    for index, segment in enumerate(segments):\n        next_index = index + 1\n        if next_index == len(segments):\n            polygon_area = segment * segments[0]\n            break\n        segment_sum = segment * segments[next_index]\n        polygon_area = max(polygon_area, segment_sum)\n    return str(polygon_area)\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Please do not change anything below this line.\n    # Do not remove this line.\n    n = int(stdin.readline().rstrip())\n    lengths = list(map(float, stdin.readline().rstrip().split(' ')))\n    # Write your code below.\n    return '%.4f' % (max(lengths) * n * 2 * math.sqrt(2) / 2)\n\n\ndef"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lengths = [int(x) for x in stdin.split(\" \")]\n    area = 0\n    for i in range(len(lengths)):\n        for j in range(i+1, len(lengths)):\n            # print(i, j, lengths[i], lengths[j])\n            l = max(lengths[i], lengths[j])\n            s = (l**2+l)/2\n            # print(s)\n            if s > area:\n                area = s\n    print(area)\n    return str(area)\n\nsolution(\"4 1 1 1 1\")\nsolution(\"3 1 1 1\")\nsolution(\"5 1 1 1 1\")\nsolution(\"100 1 1 1 1\")\nsolution(\"50 1 1 1 1\")\nsolution(\"5 11 11 11 11\")\nsolution(\"80 11 11 11 11\")\nsolution(\"60 11 11 11 11\")\nsolution(\"80 20 20 20 20\")\nsolution(\"100 20 20 20 20\")\nsolution(\"50 20 20 20 20\")\nsolution(\"100 100 100 100 100\")\nsolution(\"50 50 50 50 50\")\nsolution(\"80 80 80 80 80\")\nsolution(\"1 1 1 1 1\")\nsolution(\"1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    n = int(stdin.readline())\n    h = list(map(int, stdin.readline().split()))\n    if n < 3:\n        return '0.0'\n    \n    s = sorted(h)\n    areas = 0\n    \n    for i in range(len(s) - 1):\n        areas = max(areas, (s[i] + s[i + 1]) * 0.5)\n    return str(areas)\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4 1 1 1 1\n   ... 1 1 1 1''')\n    '1.0'\n    >>> solution('''3 1 1 1\n   ... 1 1 1''')\n    '0.433'\n    \"\"\"\n    n, *segments = [int(x) for x in stdin.split()]\n    segments.sort()\n    min_area = 0\n    for i in range(n - 1):\n        if segments[i] + segments[i + 1] >= segments[i + 1]:\n            continue\n        left_idx = i + 1\n        right_idx = n - 1\n        while left_idx < right_idx:\n            if segments[i] + segments[left_idx] + segments[right_idx] >= segments[i] + segments[right_idx]:\n                right_idx -= 1\n            else:\n                left_idx += 1\n        segments[left_idx] = segments[i] + segments[left_idx]\n        if min_area < segments[i] * left_idx:\n            min_area = segments[i] * left_idx\n    return str(min_area)\n"
    },
    {
        "number": 3175,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    fence_segments = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    # print(fence_segments)\n    fence_segments.sort(reverse=True)\n    # print(fence_segments)\n    max_area = 0\n    for i in range(len(fence_segments)-1):\n        max_area = max(max_area, fence_segments[i]*fence_segments[i+1])\n    # print(max_area)\n    return f'{max_area:.5f}'\n\n\nprint(solution('''3 1 1 1\n2 1 1\n1 1 1\n1 1 1'''))\nprint(solution('''4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 0 0 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1'''))\n\nprint(solution('''4 1 1 1 1\n4 1 1 1 1\n5 1 1 1 1\n6 1 1 1 1\n7 1 1 1 1\n8 1 1 1 1''"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find a sequence of jumps for Barica to travel from plant 1 to plant N.\n    \"\"\"\n\n    # Read in\n    n, k = list(map(int, stdin.split(' ')))\n\n    # Iterate\n    def recurse(x: int, y: int, k: int) -> List[int]:\n        if x == n or y == n:\n            return [x, y]\n        if k == 0:\n            return recurse(x + 1, y, k + 1)\n        else:\n            return [x, y] if x <= y else recurse(x, y + 1, k - 1)\n\n    return '\\n'.join(map(str, recurse(1, 1, k)))\n"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Determine the sequence of plants Barica should travel to achieve her goal.\n    \"\"\"\n    N, K = map(int, stdin.split())\n    lst_pos = []\n    for _ in range(N):\n        x, y, f = map(int, stdin.split())\n        lst_pos.append((x, y))\n\n    lst_fly = []\n    for x, y in lst_pos:\n        for i in range(f):\n            lst_fly.append((x + i, y + i))\n\n    # determine the total energy needed\n    sum_fly = sum(pow(abs(x1 - x2), 2) + pow(abs(y1 - y2), 2)\n                  for x1, y1 in lst_pos for x2, y2 in lst_fly)\n    energy = K * (K + 1) // 2\n    if sum_fly > energy:\n        print(0)\n        return\n    sum_fly = sum_fly - energy\n    lst_fly = [e for e in lst_fly if e not in lst_pos]\n    lst_pos.append((0, 0))\n    lst_fly.append((0, 0))\n    sum_fly = sum_fly + 2\n\n    lst_fly.sort(key=lambda x: x[1])\n    lst_fly.sort(key=lambda x: x[0], reverse=True)\n    dct_pos = {i: lst_pos[i] for i in range(N + 1)}\n    dct_fly = {i: lst_fly[i] for i in range(len(lst_fly))}\n\n    lst_energy = [0] * (N + 1)\n    lst_energy[0] = 0\n    for i in range(N):\n        if i > 0:\n            lst_energy[i + 1] = lst_energy[i] + sum_fly\n\n    for i in range(N):\n        x1, y1 = dct_pos[i + 1]\n        x2, y2 = dct_pos[i + 2]\n        if y2 == y1:\n            if x2 > x1:\n                lst_energy[i + 1] = min(lst_energy[i + 1], lst_energy[i] + K)\n            else:\n                lst_energy[i + 1] = min(lst_energy[i + 1], lst_energy[i] - K)\n        else:\n            if x2 > x1:\n                lst_energy[i + 1] = min(lst_energy[i + 1], lst_energy[i] + K)\n            else:\n                lst_energy[i + 1] = min(lst_energy[i + 1], lst_energy[i] - K)\n\n    lst_fly = [e for e in lst_fly if e not in dct_pos.values()]\n    lst_fly.append((0, 0))\n    lst_energy = [e for e in lst_energy if e!= 0]\n    lst_energy.append(0)\n    lst_energy.sort(reverse=True)\n\n    # determine the sequence\n    idx = len(lst_energy) - 1\n    lst_ans = []\n    while lst_energy[idx]!= 0:\n        if lst_energy[idx] > lst_energy[idx - 1]:\n            for i in range(idx, -1, -1):\n                if lst_energy[i] > lst_energy[idx - 1]:\n                    lst_ans.append(dct_fly[i])\n                    idx = i\n                    break\n        else:\n            for i in range(idx, -1, -1):\n                if lst_energy[i] > lst_energy[idx]:\n                    lst_ans.append(dct_fly[i])\n                    idx = i\n                    break\n    lst_ans.sort(key=lambda x: x[1])\n    lst_ans.sort(key=lambda x: x[0])\n    lst_ans.pop()\n    lst_ans.reverse()\n    print(lst_energy[idx])\n    for x, y in lst_ans:\n        print(dct_pos[x], dct_pos[y])\n\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A frog can jump a distance of X if there is a plant at his location + X.\n    Time: O(n^2)\n    Space: O(n)\n    \"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    plants = [[int(y) for y in x.split()] for x in stdin.splitlines()]\n\n    d = [0 for _ in range(n + 1)]\n    d[1] = plants[0][2]\n    for i in range(1, n):\n        for j in range(i + 1):\n            if d[j] < d[i] and abs(plants[i][0] - plants[j][0]) + abs(plants[i][1] - plants[j][1]) <= k:\n                d[i + 1] = max(d[i + 1], d[j] + plants[i][2])\n    return d[n]\n"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    (n, k) = list(map(int, stdin.split()))\n    p = [list(map(int, stdin.split())) for _ in range(n)]\n    p.sort(key=lambda x: (x[0], x[1]))\n    ans = []\n    for i in range(1, n):\n        if p[i][0] > p[i-1][0] and p[i][1] == p[i-1][1]:\n            ans.append(p[i][0])\n            ans.append(p[i][1])\n        elif p[i][1] > p[i-1][1] and p[i][0] == p[i-1][0]:\n            ans.append(p[i][0])\n            ans.append(p[i][1])\n        else:\n            ans.append(p[i-1][0])\n            ans.append(p[i-1][1])\n    ans.append(p[-1][0])\n    return str(len(ans)) + '\\n' + '\\n'.join(map(str, ans))\n\nprint(solution(str(input())))"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the sequence of plants that Barica should travel to achieve her goal.\"\"\"\n    n, k = [int(i) for i in stdin.split(' ')]\n    plants = [None] * n\n    for i in range(n):\n        x, y, f = [int(j) for j in stdin.split('\\n')[i].split(' ')]\n        plants[i] = (x, y, f)\n\n    return f'{solution_part_1(n, k, plants)}\\n{solution_part_2(n, k, plants)}'\n\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the largest amount of energy you can have after having used up a given amount of energy to reach the end of the sequence of plants,\n    including the end plant.\n\n    Given an input string, return a string that represents the sequence of plants Barica should travel.\n    \"\"\"\n    (n, k) = list(map(int, stdin.split()))\n    energies = [0] * n\n    plants = [None] * n\n    for i in range(n):\n        (x, y, f) = list(map(int, stdin.split()))\n        plants[i] = [x, y, f]\n        energies[i] = f\n    energies[0] -= k\n    plants[0] = [0, 0, k]\n    for i in range(1, n):\n        if plants[i - 1][0] == plants[i][0] or plants[i - 1][1] == plants[i][1]:\n            energies[i] = max(energies[i - 1], energies[i]) - plants[i][2]\n            plants[i] = [plants[i - 1][0], plants[i - 1][1], energies[i]]\n        else:\n            energies[i] = energies[i - 1] - plants[i][2]\n            plants[i] = [plants[i - 1][0], plants[i - 1][1], energies[i]]\n    energies[-1] -= k\n    plants[-1] = [plants[-2][0], plants[-2][1], energies[-1]]\n    print(energies[-1])\n    return get_output(plants)\n\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    coords = list()\n    for _ in range(N):\n        x, y, f = map(int, stdin.split())\n        coords.append((x, y, f))\n\n    # initialize\n    visited = set()\n    visited.add((0, 0))\n    visited.add((0, 1))\n    visited.add((1, 0))\n    visited.add((1, 1))\n    visited.add((2, 0))\n    visited.add((2, 1))\n    visited.add((3, 0))\n    visited.add((3, 1))\n    visited.add((4, 0))\n    visited.add((4, 1))\n    visited.add((5, 0))\n    visited.add((5, 1))\n    visited.add((6, 0))\n    visited.add((6, 1))\n    visited.add((7, 0))\n    visited.add((7, 1))\n    visited.add((8, 0))\n    visited.add((8, 1))\n    visited.add((9, 0))\n    visited.add((9, 1))\n\n    travelled = [(0, 0)]\n    cur_x = 0\n    cur_y = 0\n    energy = K\n    cur_energy = K\n    while travelled:\n        x, y = travelled.pop()\n        if (x, y) == (N - 1, 0):\n            break\n        for x_, y_, f_ in coords:\n            if (x_, y_) == (x + 1, y + 1):\n                energy = cur_energy\n                cur_energy = cur_energy - f_ + f_\n                cur_x = x + 1\n                cur_y = y + 1\n                if cur_energy < 0:\n                    cur_energy = K\n                    break\n                if cur_energy == 0 and (x + 1, y + 1) not in visited:\n                    travelled.append((x + 1, y + 1))\n                    visited.add((x + 1, y + 1))\n                if cur_energy == 0 and (x + 1, y) not in visited:\n                    travelled.append((x + 1, y))\n                    visited.add((x + 1, y))\n                if cur_energy == 0 and (x, y + 1) not in visited:\n                    travelled.append((x, y + 1))\n                    visited.add((x, y + 1))\n            elif (x_, y_) == (x, y + 1):\n                energy = cur_energy\n                cur_energy = cur_energy - f_ + f_\n                cur_y = y + 1\n                if cur_energy < 0:\n                    cur_energy = K\n                    break\n                if cur_energy == 0 and (x, y + 1) not in visited:\n                    travelled.append((x, y + 1))\n                    visited.add((x, y + 1))\n                if cur_energy == 0 and (x + 1, y) not in visited:\n                    travelled.append((x + 1, y))\n                    visited.add((x + 1, y))\n                if cur_energy == 0 and (x, y + 1) not in visited:\n                    travelled.append((x, y + 1))\n                    visited.add((x, y + 1))\n            elif (x_, y_) == (x + 1, y):\n                energy = cur_energy\n                cur_energy = cur_energy - f_ + f_\n                cur_x = x + 1\n                if cur_energy < 0:\n                    cur_energy = K\n                    break\n                if cur_energy == 0 and (x + 1, y) not in visited:\n                    travelled.append((x + 1, y))\n                    visited.add((x + 1, y))\n                if cur_energy == 0 and (x, y + 1) not in visited:\n                    travelled.append((x, y + 1))\n                    visited.add((x, y + 1))\n                if cur_energy == 0 and (x + 1, y) not in visited:\n                    travelled.append((x + 1, y))\n                    visited.add((x + 1, y))\n            elif (x_, y_) == (x - 1, y):\n                energy = cur_energy\n                cur_energy = cur_energy - f_ + f_\n                cur_x = x - 1\n                if cur_energy < 0:\n                    cur_energy = K\n                    break\n                if cur_energy == 0 and (x - 1, y) not in visited:\n                    travelled.append((x - 1, y))\n                    visited.add((x - 1, y))\n                if cur_energy == 0 and (x, y + 1) not in visited:\n                    travelled.append((x, y + 1))\n                    visited.add((x, y + 1))\n                if cur_energy == 0 and (x - 1, y) not in visited:\n                    travelled.append((x - 1, y))\n                    visited.add((x - 1, y))\n            elif (x_, y_) == (x, y - 1):\n                energy = cur_energy\n                cur_energy = cur_energy - f_ + f_\n                cur_y = y - 1\n                if cur_energy < 0:\n                    cur_energy = K\n                    break\n                if cur_energy == 0 and (x, y - 1) not in visited:\n                    travelled.append((x, y - 1))\n                    visited.add((x, y - 1))\n                if cur_energy == 0 and (x + 1, y) not in visited:\n                    travelled.append((x"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    #stdin = stdin.split()\n    # n = int(stdin[0])\n    # k = int(stdin[1])\n\n    # flies = [[int(stdin[i * 3 + j]) for j in range(3)] for i in range(n)]\n\n    # # \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043f\u043e\u0437\u0438\u0446\u0438\u044e\n    # flies.insert(0, [0, 0, 0])\n\n    # # \u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u043f\u043e \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044e\n    # flies.sort(key=lambda x: x[1])\n\n    # # \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0439\n    # moves = 1\n    # for i in range(1, n + 1):\n    #     if flies[i][1] < flies[i - 1][1]:\n    #         moves += 1\n\n    # # \u0432\u043e\u0437\u044c\u043c\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0445\u043e\u0434\u043e\u0432\n    # moves_arr = []\n    # for i in range(k + 1):\n    #     moves_arr.append(k - i)\n    #     moves_arr.append(i)\n\n    # # \u0434\u0435\u043b\u0430\u0435\u043c \u0445\u043e\u0434\u044b \u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u043f\u043e\u0438\u0441\u043a\u0430\n    # cur_pos = 0\n    # cur_move = moves\n    # for i in range(moves):\n    #     for j in range(len(moves_arr)):\n    #         if cur_move == moves_arr[j]:\n    #             cur_move = moves_arr[j + 1] if j % 2 else moves_arr[j - 1]\n    #             cur_pos = flies[cur_pos][1] + cur_move\n    #             flies[cur_pos][1] -= cur_move\n    #             if flies[cur_pos][1] <= 0:\n    #                 flies.pop(cur_pos)\n    #             break\n\n    # # \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u043f\u043e\u043b\u043d\u044b\u0439 \u043f\u0443\u0442\u044c\n    # flies_arr = [i for i in range(1, n + 1)]\n    # for i in flies:\n    #     flies_arr.remove(i[0])\n    # moves_arr = []\n    # moves = 1\n    # for i in range(1, n + 1):\n    #     if flies[i][1] > flies[i - 1][1]:\n    #         moves += 1\n    # for i in range(moves):\n    #     for j in range(len(moves_arr)):\n    #         if moves_arr[j] == moves - i:\n    #             moves_arr.insert(j, moves_arr.pop(j + 1) if j % 2 else moves_arr.pop(j - 1))\n    #             break\n    # flies_arr.sort(reverse=True)\n    # print(moves)\n    # print(*flies_arr)\n    return None\n"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    points = []\n    for i in range(1, N + 1):\n        points.append([int(j) for j in stdin.split()[i - 1:i + 2]])\n\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n\n    dp[1][0] = points[0][2]\n    dp[1][1] = points[0][2]\n    for i in range(2, N + 1):\n        for j in range(K + 1):\n            if j >= points[i - 1][0] and dp[i - 1][j] + points[i - 1][2] >= dp[i - 1][j - points[i - 1][0]]:\n                dp[i][j] = dp[i - 1][j] + points[i - 1][2]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[-1][-1]\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the minimum number of swaps to transform the permutation to 1, 2, 3,... N.\n    '''\n    # Get the number of allowed swaps and the permutation\n    input = stdin.split('\\n')\n    allowed_swaps = int(input[0].split()[0])\n    permutation = list(map(int, input[1].split()))\n    \n    # Sort the permutation\n    permutation.sort()\n\n    # Calculate the swaps that need to be made\n    swaps = 0\n    for i in range(allowed_swaps):\n        # Get the two numbers for the current swap\n        swap_start_index = int(input[i+2].split()[0]) - 1\n        swap_end_index = int(input[i+2].split()[1]) - 1\n\n        # Swap the two numbers\n        permutation[swap_start_index], permutation[swap_end_index] = permutation[swap_end_index], permutation[swap_start_index]\n        swaps += abs(swap_start_index - swap_end_index)\n    \n    return swaps\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum possible number of swaps required to arrange the sequence.\"\"\"\n    n, m = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    d = defaultdict(list)\n    for i in range(m):\n        d[int(stdin.split()[i * 2])].append(int(stdin.split()[i * 2 + 1]))\n    \n    count = 0\n    for i in range(1, n):\n        if sequence[i] > sequence[i-1]:\n            if i in d[i+1]:\n                sequence[i-1], sequence[i] = sequence[i], sequence[i-1]\n                count += 1\n            else:\n                d[i+1].append(i)\n        else:\n            d[i+1].append(i)\n    return count"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = list(map(int, stdin.split(' ')))\n    nums = list(map(int, stdin.split(' ')))\n    swap_dict = {}\n    for i in range(M):\n        a, b = list(map(int, stdin.split(' ')))\n        swap_dict.setdefault(a, []).append(b)\n        swap_dict.setdefault(b, []).append(a)\n    swaps = 0\n    for i in range(1, N + 1):\n        if i not in nums:\n            for num in nums:\n                if num in swap_dict[i]:\n                    swaps += 1\n                    nums.remove(num)\n                    nums.insert(nums.index(i) + 1, num)\n                    break\n    return swaps\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution to problem.\n    '''\n    n, m, _, *remain_lst = map(int, stdin.split())\n    lst = list(range(1, n + 1))\n    stdin_lst = [map(int, l.split()) for l in remain_lst]\n    stdin_lst = [(a, b) for (a, b) in stdin_lst if a < b]\n\n    lst_len = len(lst)\n\n    def swap(lst: list, lst_len: int, a: int, b: int) -> list:\n        a, b = min(a, b), max(a, b)\n        if a == b:\n            return lst\n        i, j = lst_len - 1 - lst[::-1].index(a), lst_len - 1 - lst[::-1].index(b)\n        lst[i], lst[j] = lst[j], lst[i]\n        return lst\n\n    def permutation_correct(lst: list, stdin_lst: list) -> bool:\n        for (a, b) in stdin_lst:\n            if not (lst[a - 1] == b and lst[b - 1] == a):\n                return False\n        return True\n\n    def find_best_permutation(lst: list, stdin_lst: list) -> list:\n        best_permutation = lst.copy()\n        for (a, b) in stdin_lst:\n            permutation = swap(best_permutation, lst_len, a, b)\n            if permutation_correct(permutation, stdin_lst):\n                best_permutation = permutation\n        return best_permutation\n\n    best_permutation = find_best_permutation(lst, stdin_lst)\n\n    return str(lst_len - best_permutation.index(1) - 1)\n\n\ndef"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of swaps required to transform the initial\n    sequence back to the ordered sequence.\n\n    Parameters\n    ----------\n    stdin : str\n        The initial permutation of numbers and the list of allowed swaps.\n\n    Returns\n    -------\n    str\n        The minimum number of swaps to transform the initial permutation back to\n        the ordered sequence.\n    \"\"\"\n    # Initialize the list of allowed swaps and the permutation.\n    permutation = list(map(int, stdin.split(\"\\n\")[0].split()))\n    allowed_swaps = [list(map(int, x.split())) for x in stdin.split(\"\\n\")[1:]]\n\n    # Initialize the variables to track the number of swaps and the swaps array.\n    swaps = 0\n    swaps_array = []\n\n    # Iterate over the allowed swaps.\n    for i in range(len(allowed_swaps)):\n        # Initialize the variable to track the number of swaps performed.\n        n_swaps = 0\n\n        # Iterate over the allowed swaps of the current element.\n        for j in range(len(allowed_swaps[i])):\n            # If the current element isn't the element before the current element,\n            # swap the two elements.\n            if permutation[permutation.index(allowed_swaps[i][j]) - 1]!= allowed_swaps[i][j]:\n                permutation[permutation.index(allowed_swaps[i][j]) - 1], permutation[permutation.index(allowed_swaps[i][j])] = permutation[permutation.index(allowed_swaps[i][j])], permutation[permutation.index(allowed_swaps[i][j]) - 1]\n                swaps_array.append([permutation.index(allowed_swaps[i][j]) - 1, permutation.index(allowed_swaps[i][j])])\n                n_swaps += 1\n\n        # Increment the number of swaps.\n        swaps += n_swaps\n\n    # Return the minimum number of swaps.\n    return swaps\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    N, M = [int(x) for x in stdin.split(' ')]\n    P = [int(x) for x in stdin.split('\\n')[1:-1]]\n    for i in range(len(P)):\n        if P[i]!= i + 1:\n            count += 1\n            if P[i] > i + 1:\n                for j in range(i + 1, len(P)):\n                    if P[j] == i + 1:\n                        P[j], P[i] = P[i], P[j]\n                        break\n            else:\n                for j in range(i - 1, -1, -1):\n                    if P[j] == i + 1:\n                        P[j], P[i] = P[i], P[j]\n                        break\n    return str(count)\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().strip().split())\n    sequence = list(map(int, stdin.readline().strip().split()))\n    assert len(sequence) == N\n    # convert sequence to its index\n    sequence = [sequence.index(i) + 1 for i in range(1, N + 1)]\n    swaps = [tuple(map(int, stdin.readline().strip().split())) for _ in range(M)]\n    swaps = [(s[0], s[1]) for s in swaps]\n    # returns a list of pairs of swaps as a tuple\n    def allowed_swaps(i):\n        # return True if i is a valid swap\n        return sequence[i[0] - 1] == i[1]\n\n    # swap adjacent elements\n    for i in range(1, len(sequence)):\n        if sequence[i - 1] < sequence[i] and \\\n                allowed_swaps((sequence[i], sequence[i - 1])):\n            # swap adjacent elements\n            sequence[i - 1], sequence[i] = sequence[i], sequence[i - 1]\n            # swap adjacent pairs\n            swaps.append((sequence[i - 1], sequence[i]))\n            swaps.append((sequence[i], sequence[i - 1]))\n    # find the minimum swaps\n    swaps = set(swaps)\n    # count the number of swaps for each pair\n    counts = {(pair[0], pair[1]): 0 for pair in swaps}\n    for pair in swaps:\n        counts[pair] += 1\n    # return the minimum swaps\n    return str(min(counts.values()))\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split(\" \")))\n    seq = list(map(int, stdin.split(\" \")))\n    allowed = set()\n    for line in stdin.split(\"\\n\")[2:]:\n        a, b = list(map(int, line.split(\" \")))\n        allowed.add((a, b))\n    print(seq)\n    print(allowed)\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"Hi\"\n"
    },
    {
        "number": 3177,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A function that returns the minimum number of swaps to transform the permutation to the ordered sequence.\"\"\"\n    n, m = [int(s) for s in stdin.split()]\n    permutation = [int(s) for s in stdin.split(\"\\n\")[1].split()]\n    swaps = []\n    for i in range(m):\n        a, b = [int(s) for s in stdin.split(\"\\n\")[i + 2].split()]\n        swaps.append((a, b))\n    # print(f\"n={n}, m={m}\")\n    # print(f\"permutation={permutation}\")\n    # print(f\"swaps={swaps}\")\n    for _ in range(n - 1):\n        for i in range(m):\n            a, b = swaps[i]\n            if permutation[a - 1] > permutation[b - 1]:\n                permutation[a - 1], permutation[b - 1] = permutation[b - 1], permutation[a - 1]\n                swaps[i] = (b, a)\n                break\n    # print(f\"permutation={permutation}\")\n    # print(f\"swaps={swaps}\")\n    return m\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    N, M = map(int, stdin.split('\\n')[0].split())\n    roads = {(u, v) for u, v in map(int, stdin.split('\\n')[1:])}\n    adj = {u: set() for u in range(1, N + 1)}\n    for u, v in roads:\n        adj[u].add(v)\n        adj[v].add(u)\n    areas = set(range(1, N + 1))\n    for area in adj:\n        adj[area] = sorted(list(adj[area]))\n    while areas:\n        # If any pair of adjacent areas has different possible cost, we're done.\n        u, v = next(iter(areas))\n        if len(adj[u])!= len(adj[v]):\n            return -1\n        # We also want to make sure that the sum of the costs along any cycle is odd.\n        # We'll do this by ensuring that the number of edges in any cycle is divisible by 3.\n        n_edges = len(adj[u])\n        if n_edges % 3!= 0:\n            return -1\n        # Find all the cycles.\n        cycles = []\n        # Start at u and set u to a known destination.\n        for u in adj[u]:\n            # Set up variables for each cycle.\n            seen = set([u])\n            curr = [u]\n            # The set of places we're going to, to keep track of the places we've been.\n            seen_to = set()\n            # The current cost, to keep track of the current cost.\n            cost = 0\n            # While we haven't reached a destination, keep going.\n            while curr:\n                # Go to the next place.\n                v = curr.pop(0)\n                # If we've reached a place that's already been visited, it's a loop.\n                if v in seen_to:\n                    # Stop searching for the destination, and add the loop to the list of loops.\n                    cost += 2 * (v in seen)\n                    cycles.append(list(seen))\n                    break\n                # If v isn't a destination, add it to the list of visited places, and continue.\n                seen.add(v)\n                seen_to.add(v)\n                seen_to.add(u)\n                # Check if we've reached the destination.\n                if v in adj:\n                    # If we've reached a destination, add it to seen_to.\n                    seen_to.add(adj[v][0])\n                    # Then add that destination to the list of visited places.\n                    seen.add(adj[v][0])\n                    # Add the next element of the cycle to the list of places to go to.\n                    curr.append(adj[v][0])\n            # If we're here, it means that there was no cycle from u to the destination.\n            # So we remove u from the set of places to visit.\n            seen.remove(u)\n            seen_to.remove(u)\n        # We know there are only 2 possibilities for the cost of the cycle. We can reduce the number of possible cost by 1 if we're in an odd number of edge cycle.\n        if n_edges % 3 == 1:\n            cost = (cost + 1) // 2\n        # Now we know there are only 2 possible cost, we just need to find the minimum cost.\n        cost_min = cost\n        # For each cycle, calculate the cost.\n        for cycle in cycles:\n            # For each pair of places in the cycle, get the cost.\n            for u, v in combinations(cycle, 2):\n                # Get the cost from u to v.\n                cost = adj[u][0] + adj[v][0]\n                # If the cost is the same as the cost_min, we can't improve it.\n                if cost == cost_min:\n                    break\n                # If the cost is less than the cost_min, update the cost_min.\n                cost_min = cost\n        # If the cost_min is -1, it means we can't get there, so return -1.\n        if cost_min == -1:\n            return -1\n        # Otherwise, return the cost_min.\n        return cost_min\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the decos problem.\n\n    Args:\n        stdin: the input string, a single test case.\n\n    Returns:\n        str: the solution to the decos problem.\n    '''\n    # Get the input\n    n, m = map(int, stdin.split('\\n')[0].split())\n    roads = []\n    for i in range(m):\n        roads.append(tuple(map(int, stdin.split('\\n')[i + 1].split())))\n\n    # Create a list of sets, representing connected areas\n    connected_areas = [set([i]) for i in range(1, n + 1)]\n\n    # Remove connected areas from the list\n    for a, b in roads:\n        a_index = connected_areas[a - 1]\n        b_index = connected_areas[b - 1]\n\n        # Union a and b\n        for area in a_index:\n            connected_areas[area - 1] = connected_areas[area - 1].union(b_index)\n\n        # Remove b from a\n        connected_areas[a - 1] = a_index.difference(b_index)\n\n        # If a and b are connected, remove them from each other\n        if len(connected_areas[a - 1]) == 0:\n            connected_areas[b - 1] = connected_areas[b - 1].difference(a_index)\n            if len(connected_areas[b - 1]) == 0:\n                connected_areas[a - 1] = set()\n\n    # Look at the connected areas\n    for area in connected_areas:\n        if len(area) > 1:\n            return -1\n\n    # Find the minimum cost\n    min_cost = 0\n    for a, b in roads:\n        cost = 0\n\n        # Find the area number\n        area_a_index = connected_areas[a - 1].pop()\n        area_b_index = connected_areas[b - 1].pop()\n\n        # Find the minimum cost\n        cost += min(area_a_index, area_b_index)\n        cost += min(connected_areas[area_a_index - 1].difference(set([area_b_index])) or set(),\n                    connected_areas[area_b_index - 1].difference(set([area_a_index])) or set())\n\n        if cost % 3!= 1:\n            return -1\n\n        # Add the cost to the total\n        min_cost += cost\n\n    return min_cost\n\n\ndef"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This problem is similar to the \"Minimum Cost to Make at Least One Valid Path\" problem\n    https://www.hackerrank.com/challenges/minimum-cost-tree\n    \"\"\"\n\n    def dfs(n: int, r: int, d: Dict[int, List[int]], cost: Dict[int, int]) -> bool:\n        \"\"\"\n        This function does depth-first search in a given graph\n        and returns True if it can find a cycle that meets\n        the criteria.\n        :param n: The number of cities\n        :param r: The number of roads\n        :param d: The graph of the cities\n        :param cost: The cost of the roads\n        :return: True if it can find a cycle that meets the criteria.\n        \"\"\"\n        visited = set()\n\n        # Recursive DFS implementation.\n        def dfs_helper(\n            previous_city: int, cur_city: int, depth: int, visited: set, d: Dict[int, List[int]],\n            cost: Dict[int, int],\n        ) -> bool:\n            if cur_city in visited:\n                return True\n            if depth > n:\n                return False\n            if depth == n:\n                return True\n            visited.add(cur_city)\n            for neighbor in d[cur_city]:\n                if neighbor == previous_city:\n                    continue\n                if dfs_helper(cur_city, neighbor, depth + 1, visited, d, cost):\n                    return True\n            visited.remove(cur_city)\n            return False\n\n        for start, end in r:\n            # Make sure the starting city is not the ending city.\n            if start == end:\n                return True\n\n            # Make sure the edge is not the same as a cycle.\n            cycle_cost = cost[start] + cost[end]\n            if cycle_cost % 3 == 1:\n                continue\n\n            # Make sure that the edge is not in a cycle.\n            if dfs_helper(start, end, 0, visited, d, cost):\n                return True\n\n        return False\n\n    n, m = list(map(int, stdin.readline().split()))\n    r = []\n    d = defaultdict(list)\n    cost = defaultdict(int)\n    for i in range(m):\n        a, b = list(map(int, stdin.readline().split()))\n        r.append((a, b))\n        d[a].append(b)\n        d[b].append(a)\n\n    for start, end in r:\n        cost[start] += 1\n        cost[end] += 1\n\n    for city, cost_city in cost.items():\n        if cost_city % 3 == 0:\n            cost[city] += 2\n\n    if dfs(n, r, d, cost):\n        return -1\n\n    return min(cost.values())\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum cost of decorating the city according to\n    Peter's properties.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    # Get number of areas and roads\n    n, m = [int(i) for i in stdin.split()]\n\n    # Get adjacency list\n    adj_list = [[int(j) for j in i.split()] for i in stdin.split('\\n')[m:]]\n\n    # Get the number of possible cycles\n    cycles = 0\n    for i in range(n):\n        if i in (0, n-1):\n            cycles += 1\n        else:\n            for j in range(1, n-1):\n                if j in adj_list[i]:\n                    break\n                else:\n                    cycles += 1\n\n    # Get the number of possible pairs of decorations\n    pairs = 0\n    for area in range(1, n-1):\n        if area not in [i[0] for i in adj_list]:\n            for other_area in range(1, n-1):\n                if other_area not in [i[1] for i in adj_list]:\n                    pairs += 1\n    if pairs % 2 == 0:\n        pairs = 0\n\n    # Get the minimum cost\n    min_cost = min(pairs, cycles)\n\n    # If the minimum cost is not possible, return -1\n    if min_cost % 2!= 1:\n        return -1\n    else:\n        return min_cost\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        roads.append(map(int, stdin.split()))\n    areas = range(1, n+1)\n    cycles = []\n    for road in roads:\n        a, b = road\n        a = a - 1\n        b = b - 1\n        if a < b:\n            a, b = b, a\n        cycles.append((a, b))\n    unused = range(1, n+1)\n    used = set()\n    for start in unused:\n        used.add(start)\n        stack = []\n        count = 0\n        while len(stack)!= 0 or count % 2 == 0:\n            if len(stack) == 0:\n                stack.append(start)\n            curr = stack.pop()\n            if curr in unused:\n                used.add(curr)\n                count += 1\n                if curr in unused:\n                    used.add(curr)\n                    stack.append(curr)\n                    stack.append(curr)\n                elif curr in used:\n                    pass\n            else:\n                pass\n        if count % 2 == 1:\n            cycles.append((start, curr))\n        if start in unused:\n            unused.remove(start)\n    ans = float('inf')\n    for i in range(len(cycles)):\n        a, b = cycles[i]\n        for j in range(i+1, len(cycles)):\n            c, d = cycles[j]\n            a1 = a if a < b else b\n            b1 = b if a < b else a\n            c1 = c if c < d else d\n            d1 = d if c < d else c\n            if a1 == c1 and b1 == d1:\n                a2 = a if a < c else c\n                b2 = b if b < d else d\n                cost = (a2 + b2) % 3\n                if cost == 1:\n                    ans = min(ans, a2+b2+2)\n                elif cost == 2:\n                    ans = min(ans, a2+b2+1)\n                else:\n                    ans = min(ans, a2+b2)\n    if ans == float('inf'):\n        return '-1'\n    else:\n        return str(ans)\n\nprint(solution(stdin=input()))\n\n\"\"\"\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The minimum cost is the maximum sum of costs along cycles.\n    Every cycle must have an odd sum.\n    \"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    roads = [[int(x) for x in stdin.split()] for _ in range(m)]\n\n    adj_list = [[] for _ in range(n)]\n    for a, b in roads:\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    cycle_lengths = [None for _ in range(n)]\n    for i in range(n):\n        cycle_length = len(dfs(i, adj_list, []))\n        if cycle_length % 2 == 0:\n            return -1\n        cycle_lengths[i] = cycle_length\n\n    return max(sum(cycle_lengths) // 2, -1)\n\ndef"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(\"\\n\")[:2])\n    graph = [[0] * (n + 1) for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split(\"\\n\")[_].split())\n        graph[u][v] = 1\n        graph[v][u] = 1\n\n    def dfs(i: int, f: int, d: int, v: list):\n        v[i] = True\n        for j in range(n + 1):\n            if v[j] == False and graph[i][j] == 1:\n                if d % 3!= 1:\n                    d += 1\n                    dfs(j, f, d, v)\n                else:\n                    d += 1\n                    dfs(j, f, d, v)\n                    d += 1\n                    dfs(j, f, d, v)\n\n    v = [False] * (n + 1)\n    d = 0\n    result = 0\n    for i in range(1, n + 1):\n        if v[i] == False:\n            d = 0\n            f = i\n            dfs(i, f, d, v)\n            result += d // 3\n    if result % 2 == 0:\n        return -1\n    else:\n        return result\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"2 5\\n2 4\\n3 5\\n1 5\\n3 6\\n1 6\\n\")\n    5\n    \"\"\"\n    n, m = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(m)]\n    adj = [[] for _ in range(n)]\n    for a, b in roads:\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    queue = deque()\n    queue.append(0)\n    seen = [False] * n\n    seen[0] = True\n    while queue:\n        current = queue.popleft()\n        for next_area in adj[current]:\n            if seen[next_area]:\n                continue\n            queue.append(next_area)\n            seen[next_area] = True\n\n    if sum(seen) % 2 == 0:\n        return -1\n    else:\n        return n - sum(seen)\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    In this problem we have to check if a given city can be\n    decorated with a given sum of money. We have two features of\n    a city:\n    1) If the sum of money is odd then we can decorate it with\n    a sum of money that is divisible by 3.\n    2) Each area can only be connected to at most 2 other\n    areas.\n    We start by assuming that we can decorate the city with\n    an odd number of money.\n    We iterate through the roads, checking if the number of\n    areas that can be connected is more than 1. If it is then\n    we change the number of areas to be a sum of money that is\n    divisible by 3.\n    Once we've done that we look for cycles in the city and\n    keep updating the number of areas if it is even.\n    If we've made it through the roads without making it\n    divisible by 3 then the city can't be decorated.\n    \"\"\"\n    num_areas, num_roads = map(int, stdin.split('\\n')[0].split())\n    roads = [list(map(int, stdin.split('\\n')[i].split())) for i in range(1, num_roads + 1)]\n    num_areas_with_2_roads = 0\n    for area_a, area_b in roads:\n        if area_a!= area_b:\n            if num_areas_with_2_roads < 1:\n                num_areas_with_2_roads = num_areas_with_2_roads + 1\n            else:\n                num_areas_with_2_roads = num_areas_with_2_roads + 2\n    if num_areas_with_2_roads % 2!= 1:\n        return -1\n    for area_a, area_b in roads:\n        if area_a!= area_b:\n            num_areas_with_2_roads = num_areas_with_2_roads - 1\n            if num_areas_with_2_roads < 1:\n                num_areas_with_2_roads = num_areas_with_2_roads + 1\n            else:\n                num_areas_with_2_roads = num_areas_with_2_roads + 2\n    num_areas_with_2_roads = num_areas_with_2_roads % 3\n    if num_areas_with_2_roads == 0:\n        return 0\n    if num_areas_with_2_roads == 1:\n        return 1\n    return 2\n"
    },
    {
        "number": 3178,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5 8\\n1 4\\n4 5\\n1 5\\n1 2\\n1 3\\n2 3\\n3 5\\n2 5\\n\")\n    5\n    \"\"\"\n    areas, roads = [int(s) for s in stdin.split(\"\\n\")]\n\n    graph = {i: set() for i in range(1, areas + 1)}\n    for i in range(roads):\n        a, b = [int(s) for s in stdin.split(\"\\n\")[i].split()]\n        graph[a].add(b)\n        graph[b].add(a)\n\n    if is_odd_sum_cycle(graph) is False:\n        return -1\n\n    return sum(get_sum_of_costs(graph))\n\n\ndef"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"returns area of min polygon which is a min area polygon\n\n    Args:\n        stdin (str): input string\n\n    Returns:\n        str: min area polygon\n    \"\"\"\n    # get input from file\n    n, k = [int(i) for i in stdin.split(\"\\n\")[:2]]\n    vertices = [tuple([float(i) for i in stdin.split(\"\\n\")[3 + i].split(\" \")]) for i in range(n)]\n    v_x = [v[0] for v in vertices]\n    v_y = [v[1] for v in vertices]\n    \n    # set min_x and min_y and max_x and max_y\n    min_x = min(v_x)\n    min_y = min(v_y)\n    max_x = max(v_x)\n    max_y = max(v_y)\n\n    # set area\n    area = 0\n    side_length = 1e10\n    for x in range(min_x, max_x):\n        for y in range(min_y, max_y):\n            point = [x, y]\n            if is_intersect(vertices, point):\n                side_length = min(side_length, get_distance(vertices, point))\n    return round(side_length, 2)\n\n\ndef"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the output of a map system for a\n    polygon given on stdin.\"\"\"\n    # We'll use the number of vertices of the polygon as our\n    # scaling factor.\n    n, k = map(int, stdin.split())\n\n    # Read the polygon's vertices.\n    vertices = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        vertices.append((x, y))\n\n    # Read the mapping system's squares.\n    squares = []\n    for i in range(k):\n        x, y = map(int, stdin.split())\n        squares.append((x, y))\n\n    # Calculate the area of each square.\n    areas = []\n    for x, y in squares:\n        # We'll find the square's area by first finding its radius\n        # and then multiplying that by the square of the radius.\n        radius = math.sqrt(x ** 2 + y ** 2)\n        area = radius ** 2 * math.pi\n\n        # Update areas list.\n        areas.append(area)\n\n    # Now we have all the areas of the squares we need, but we need\n    # to find the minimum area. So, we'll sort the list of areas in\n    # descending order and then return the first item.\n    areas.sort(reverse=True)\n    minimum_area = areas[0]\n\n    # Print the answer.\n    return \"{:.2f}\".format(minimum_area)\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Reads in two numbers (n and k), the number of vertices and the number of square maps in the map system,\n    followed by n lines of the vertices of the canyon. For each line, two numbers represent x and y coordinates,\n    in that order. The output is the minimum side length of a square map in the map system that covers the entire\n    canyon, and the size of the square map with this minimum side length.\n\n    :param stdin: the input read in from stdin\n    :return: the output written to stdout\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 1\\n1 1\\n5 1\\n5 5\\n4 2\\n')\n    '4.00'\n    \"\"\"\n    \n    x_min, x_max, y_min, y_max = -20000, 20000, -20000, 20000\n\n    n, k = map(int, stdin.split())\n    polygon = [tuple(map(int, stdin.split())) for _ in range(n)]\n    polygon.sort()\n\n    for x1, y1 in polygon:\n        x_min = min(x_min, x1)\n        x_max = max(x_max, x1)\n        y_min = min(y_min, y1)\n        y_max = max(y_max, y1)\n\n    max_delta_x, max_delta_y = x_max - x_min, y_max - y_min\n\n    for _ in range(k):\n        x_min -= max_delta_x / k\n        x_max += max_delta_x / k\n        y_min -= max_delta_y / k\n        y_max += max_delta_y / k\n\n    return f\"{(x_max - x_min) / k:.2f}\"\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(test_input)\n    '9.00'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum side length of the mapping system with respect to the canyons\n    \"\"\"\n    (n, k) = [int(x) for x in stdin.splitlines()[0].split()]\n\n    x, y = [], []\n    for _ in range(n):\n        (x1, y1) = [int(x) for x in stdin.splitlines()[_].split()]\n        x.append(x1)\n        y.append(y1)\n    x = sorted(set(x))\n    y = sorted(set(y))\n\n    min_x = x[0]\n    max_x = x[-1]\n    min_y = y[0]\n    max_y = y[-1]\n\n    if max_x > 0 and min_x < 0:\n        delta = abs(min_x)\n        if delta > abs(max_x):\n            delta = abs(max_x)\n    elif max_x < 0 and min_x > 0:\n        delta = abs(min_x)\n        if delta > abs(max_x):\n            delta = abs(max_x)\n    else:\n        delta = max(abs(max_x), abs(min_x))\n\n    if max_y > 0 and min_y < 0:\n        delta_y = abs(min_y)\n        if delta_y > abs(max_y):\n            delta_y = abs(max_y)\n    elif max_y < 0 and min_y > 0:\n        delta_y = abs(min_y)\n        if delta_y > abs(max_y):\n            delta_y = abs(max_y)\n    else:\n        delta_y = max(abs(max_y), abs(min_y))\n\n    return \"{:.2f}\".format(max(delta, delta_y))\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, k = map(int, stdin.readline().split())\n    points = [(int(x), int(y)) for x, y in zip(*[iter(map(int, stdin.readline().split())) for _ in range(n)])]\n    points.sort()\n    hull = [[points[0], points[1]]]\n    for i in range(1, n):\n        if points[i][1] > points[i-1][1]:\n            hull[-1].append(points[i])\n        else:\n            hull.append([points[i]])\n    polygon = Polygon(hull)\n    distances = polygon.minimum_rotated_rectangle.area / k\n    return str(round(distances, 2))\n    '''\n\n    def dist(p0, p1):\n        return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)\n    def area(p0, p1, p2):\n        a = dist(p0, p1)\n        b = dist(p1, p2)\n        c = dist(p2, p0)\n        s = (a + b + c) / 2\n        return math.sqrt(s * (s - a) * (s - b) * (s - c))\n    n, k = map(int, stdin.readline().split())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    points.sort()\n    edge = []\n    for i in range(n - 1):\n        edge.append((points[i + 1][1] - points[i][1], points[i], points[i + 1]))\n    edge.sort()\n    maxarea = 0\n    for i in range(1, n - 1):\n        for j in range(i):\n            a = area(edge[j][1], edge[j][2], edge[i][2])\n            maxarea = max(maxarea, a)\n    return str(round(maxarea**0.5, 2))"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the minimum perimeter of the canyons.\"\"\"\n    pass\n"
    },
    {
        "number": 3179,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    polygon = list(map(int, stdin.split()))\n    dists = [[(polygon[i] - polygon[j]) ** 2 for j in range(i, len(polygon))] for i in range(n)]\n    dists.extend([[(polygon[i] - polygon[j]) ** 2 for j in range(i)] for i in range(n)])\n    dist = float('inf')\n    for l in range(k):\n        r = -1\n        for i in range(n):\n            for j in range(i, n):\n                if r < 0 or dists[i][j] < r:\n                    r = dists[i][j]\n        dist = min(dist, r)\n        for i in range(n):\n            for j in range(i, n):\n                dists[i][j] -= r\n    return '%.2f' % dist"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split(' '))\n    paint = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        inst, *argv = map(int, stdin.split(' '))\n        if inst == 1:\n            paint[argv[0]][argv[1]] = argv[2]\n        elif inst == 2:\n            paint[argv[0]][argv[1]] = argv[2]\n        elif inst == 3:\n            paint[argv[0]][argv[1]] = argv[2]\n    for row in paint:\n        print(' '.join(map(str, row)))\n    return ''\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m = stdin.split(\"\\n\")\n    s = m[0].split()\n    n = int(s[0])\n    k = int(s[1])\n    m = [x.split() for x in m[1:]]\n    paint_colors = [0] * n\n    for cmd in m:\n        if cmd[0] == \"PAINT\":\n            for i in range(int(cmd[3]), int(cmd[5]) + 1):\n                for j in range(int(cmd[2]), int(cmd[4]) + 1):\n                    paint_colors[i][j] = int(cmd[1])\n        elif cmd[0] == \"LOAD\":\n            for i in range(int(cmd[1])):\n                paint_colors.pop(0)\n        elif cmd[0] == \"SAVE\":\n            for i in range(int(cmd[1])):\n                paint_colors.append(0)\n    return '\\n'.join(str(i) for i in paint_colors)\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    https://www.codewars.com/kata/54a3aa4ccf664db040001f0/train/python\n    \"\"\"\n    num_rows, num_cols, num_saves, num_paints = map(int, stdin.split())\n    canvas = [[1] * num_cols for _ in range(num_rows)]\n\n    for _ in range(num_saves):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        for i in range(y1, y2):\n            for j in range(x1, x2):\n                canvas[i][j] = 0\n\n    for _ in range(num_paints):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        for i in range(y1, y2):\n            for j in range(x1, x2):\n                canvas[i][j] = 0 if canvas[i][j] else 1\n\n    return \"\\n\".join(map(\" \".join, canvas))\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4 3 2\n   ... PAINT 2 0 0 3 3\n   ... PAINT 3 0 3 3 3\n   ... ''')\n    '2 1 2 3\\n1 2 1 2\\n2 1 2 3\\n1 2 1 2'\n    \"\"\"\n    N, K, M = map(int, stdin.split())\n    array = [[1] * N for _ in range(N)]\n    i, j = 0, 0\n    for _ in range(M):\n        command = stdin.split()\n        if command[0] == \"PAINT\":\n            for x in range(i, i + command[1]):\n                for y in range(j, j + command[2]):\n                    if (x + y) % 2 == 0:\n                        array[x][y] = command[3]\n                    else:\n                        array[x][y] = command[3]\n            i += command[1]\n            j += command[2]\n        if command[0] == \"SAVE\":\n            save_state(array, N, K, command[1])\n        if command[0] == \"LOAD\":\n            load_state(array, N, K, command[1])\n    return \"\\n\".join(str(x) for x in [row for row in array])\n\n\ndef"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 3 2\\n' \\\n                 'PAINT 2 0 0 3 3\\n' \\\n                 'PAINT 3 0 3 3 3\\n' \\\n                 )\n    '2 1 2 3\\n1 2 1 2\\n2 1 2 3\\n1 2 1 2\\n'\n    \"\"\"\n    N, K, M = [int(x) for x in stdin.split('\\n')[0].split()]\n    paint = [[1] * N for _ in range(N)]\n    for i in range(M):\n        command = stdin.split('\\n')[i + 1].split()\n        if command[0] == 'PAINT':\n            paint[int(command[1])][int(command[2])] = int(command[3])\n        elif command[0] == 'SAVE':\n            save_idx = int(command[1])\n        elif command[0] == 'LOAD':\n            paint[save_idx] = [int(command[1])] * N\n    for row in paint:\n        print(*row)\n    return ''\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split(\" \"))\n    result = [[1] * N for _ in range(N)]\n    for _ in range(M):\n        command = stdin.split(\"\\n\")[-1].split(\" \")\n        if command[0] == \"PAINT\":\n            colour = int(command[1])\n            left = int(command[2]) - 1\n            up = int(command[3]) - 1\n            right = int(command[4])\n            down = int(command[5])\n            for x in range(left, right):\n                for y in range(up, down):\n                    result[y][x] = colour\n        elif command[0] == \"LOAD\":\n            ordinal = int(command[1])\n            for x in range(N):\n                for y in range(N):\n                    result[y][x] = ordinal\n        elif command[0] == \"SAVE\":\n            ordinal = int(command[1])\n            result[0][0] = ordinal\n    for y in range(N):\n        print(*result[y])\n    return \"\"\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Return your answer\n    return \"\"\n"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = [int(i) for i in stdin.split()]\n    painting = [[1 for i in range(N)] for j in range(N)]\n    colours = [0 for i in range(K)]\n    \n    for m in range(M):\n        if m % 2 == 0:\n            command = stdin.split()\n            command[1] = int(command[1])\n            command[2] = int(command[2])\n            command[3] = int(command[3])\n            command[4] = int(command[4])\n            \n            if command[0] == 'PAINT':\n                for r in range(command[1], command[3] + 1):\n                    for c in range(command[2], command[4] + 1):\n                        painting[r][c] = command[5]\n            elif command[0] == 'SAVE':\n                i = 0\n                while i < len(saves):\n                    if saves[i][0] == command[1]:\n                        i = command[2]\n                        break\n                    i += 1\n                i = command[2]\n                while i < len(saves):\n                    if saves[i][0] == command[1]:\n                        saves[i] = command[1:]\n                        break\n                    i += 1\n            else:\n                i = command[1]\n                while i < len(saves):\n                    if saves[i][0] == command[1]:\n                        colours[saves[i][1] - 1] = command[2]\n                        break\n                    i += 1\n    \n    for r in range(N):\n        for c in range(N):\n            if painting[r][c] == 1:\n                print(colours[r % K], end=' ')\n                break\n    return ''"
    },
    {
        "number": 3180,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    input: str, str\n    return: str\n    '''\n    # write your code in Python 3.6\n    N, K, M = map(int, stdin.split())\n    saves = [None] * (M)\n    painting = [[1] * N for _ in range(N)]\n\n    for _ in range(M):\n        line = stdin.split()\n        if line[0] == 'PAINT':\n            x1, y1, x2, y2 = map(lambda x: int(x) - 1, line[1:])\n            for row in range(y1, y2 + 1):\n                for col in range(x1, x2 + 1):\n                    painting[row][col] = line[1]\n        elif line[0] == 'SAVE':\n            saves[_] = painting\n            continue\n        elif line[0] == 'LOAD':\n            saves[_] = None\n        else:\n            print('wtf')\n    if saves[0] is None:\n        return '\\n'.join(' '.join(map(str, row)) for row in painting)\n    return '\\n'.join(' '.join(map(str, row)) for row in saves[0])\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = list(map(int, stdin.split(' ')))\n    L = []\n    for i in range(1, N + 1):\n        L.append(i)\n    L.reverse()\n    while L[0] == N:\n        L.pop(0)\n    return''.join(map(str, L)) if len(L) >= K else '-1'\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split(' '))\n    # find all numbers that have exactly K occurances in the range(1, N+1)\n    possible_nums = [i for i in range(1, N + 1) if N / i == K]\n    if not possible_nums:\n        return '-1'\n    # find the longest monotone subsequence\n    longest_mono_sub = 0\n    for num in possible_nums:\n        sub_seq_len = 1\n        if N % num == 0:\n            n = N // num\n        else:\n            n = N // num + 1\n        sub_seq_len += n\n        if sub_seq_len > longest_mono_sub:\n            longest_mono_sub = sub_seq_len\n    # get the sequence\n    sequence = []\n    for num in possible_nums:\n        if N % num == 0:\n            n = N // num\n        else:\n            n = N // num + 1\n        sequence.extend([num] * n)\n    if len(sequence) < K:\n        return '-1'\n    return''.join(map(str, sequence[:K]))\n\n\ndef"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    The function returns an array of numbers from 1 to n\n    where each number in the array is from exactly once and the length of the longest\n    monotone sequence is exactly k\n    '''\n    # get the input\n    n, k = stdin.split(\" \")\n    n, k = int(n), int(k)\n\n    # generate the initial sequence\n    current_seq = list(range(1, n + 1))\n\n    # change the sequence while it's not monotone\n    # until you have a monotone sequence\n    while not is_monotone(current_seq):\n        # find the next element to add to the current sequence\n        next_element_index = get_next_element_index(current_seq)\n\n        # if the index of the element to add is 0, then the current sequence is descending\n        if next_element_index == 0:\n            # rotate the sequence to the right\n            current_seq = current_seq[-1:] + current_seq[:-1]\n        # if the index of the element to add is n, then the current sequence is ascending\n        elif next_element_index == n:\n            # rotate the sequence to the left\n            current_seq = current_seq[1:] + current_seq[:1]\n        # if the index of the element to add is in the middle, then swap the elements\n        else:\n            current_seq[next_element_index], current_seq[next_element_index - 1] = \\\n                current_seq[next_element_index - 1], current_seq[next_element_index]\n\n    # if there is a sequence of the desired length, return it\n    if len(current_seq) == k:\n        return \" \".join(str(num) for num in current_seq)\n    # otherwise, return -1\n    else:\n        return \"-1\""
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split(' ')]\n    numbers = list(range(1, n + 1))\n    if k == 1:\n        return str(-1)\n    elif k == n:\n        return''.join(map(str, numbers))\n    else:\n        if k > n / 2:\n            k = n - k + 1\n            descending = True\n        else:\n            k = n - k + 1\n            descending = False\n        if descending:\n            i = 0\n            j = n - 1\n            aux = []\n            while i <= j:\n                if numbers[i] < numbers[j]:\n                    aux.append(numbers[j])\n                    j -= 1\n                else:\n                    aux.append(numbers[i])\n                    i += 1\n            for number in aux:\n                numbers.remove(number)\n            return''.join(map(str, aux + numbers))\n        else:\n            i = 0\n            j = n - 1\n            aux = []\n            while i <= j:\n                if numbers[i] > numbers[j]:\n                    aux.append(numbers[j])\n                    j -= 1\n                else:\n                    aux.append(numbers[i])\n                    i += 1\n            for number in aux:\n                numbers.remove(number)\n            return''.join(map(str, aux + numbers))\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    M = list(map(int, stdin.readline().split()))\n    \n    ans = [-1]\n    for i in range(1, N+1):\n        j = 0\n        while j < N-1 and M[j] <= i and M[j+1] >= i:\n            j += 1\n        if j < K:\n            ans = [i]\n            break\n        elif j == K-1:\n            ans = [M[j]]\n            break\n    return''.join(map(str, ans))\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    res = '-'\n    for i in range(1, n + 1):\n        if i < k:\n            res += str(i) +''\n        elif i == k:\n            res += str(i)\n        else:\n            if k == 1:\n                res += str(i)\n            else:\n                if i % k == 0:\n                    res += str(i) +''\n                else:\n                    res += str(i) +''\n    print(res)\n    return res\n\ndef"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    dp = [[0] * (N + 1) for _ in range(2)]\n\n    for i in range(1, N + 1):\n        num = int(stdin[i - 1])\n        dp[num % 2][num] = 1\n        dp[num % 2][i] = max(dp[num % 2][i - 1], dp[num % 2][i - 2])\n        if i >= K:\n            dp[num % 2][i - K] = max(dp[num % 2][i - K], dp[num % 2][i - K - 1] + num)\n    return''.join(map(str, [i for i, v in enumerate(dp[0][K:], 1) if v > 0]))\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num, length = map(int, stdin.split(' '))\n    if length > num:\n        return -1\n    if length == num or length == 1:\n        return '1' * num\n    return '1' +''.join(str(i) * (num - i + 1) for i in range(1, num))\n"
    },
    {
        "number": 3181,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = [int(n) for n in stdin.split()]\n    dp = [[0 for _ in range(N+1)] for _ in range(K+1)]\n    for i in range(N+1):\n        for k in range(K+1):\n            if i == 0 or k == 0:\n                dp[k][i] = 0\n            elif i == 1:\n                dp[k][i] = k\n            elif k == 1:\n                dp[k][i] = 1\n            else:\n                dp[k][i] = dp[k][i-1] + dp[k-1][i-1] + 1\n\n    ind = K\n    for i in range(N, 0, -1):\n        if dp[K][i] == K:\n            continue\n        for k in range(K, 0, -1):\n            if dp[k][i] <= K:\n                ind = k\n                break\n        break\n    if ind == K:\n        print(-1)\n        return\n    i, j = K, i\n    for k in range(K):\n        print(j, end=' ')\n        i, j = j, dp[ind][j]\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    result = 0\n    for i in range(num):\n        x1, y1 = map(int, stdin[1:].split())\n        for j in range(i+1, num):\n            x2, y2 = map(int, stdin[2+j].split())\n            for k in range(j+1, num):\n                x3, y3 = map(int, stdin[3+k].split())\n                if x1 == x2 == x3 or x1 == y2 == y3 or y1 == x2 == y3 or y1 == y2 == x3:\n                    continue\n                elif (x2-x1)*(y3-y1) == (x3-x1)*(y2-y1) or (x2-y1)*(y3-x1) == (x3-y1)*(y2-x1):\n                    result += 1\n    return str(result)\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    pass\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, a, b, c = [int(x) for x in stdin.split('\\n')]\n    return str(int(a*b*c/2))\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\""
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    return \"\".join(list)"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()]\n    distance = lambda p1, p2: ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n    count = 0\n    for i in range(len(points) - 2):\n        for j in range(i + 1, len(points) - 1):\n            for k in range(j + 1, len(points)):\n                if distance(points[i], points[j]) * distance(points[j], points[k]) == distance(points[i], points[k]):\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return str(int(stdin))"
    },
    {
        "number": 3182,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ...\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds a max flow from source to sink with min cost.\n    \"\"\"\n    def max_flow(graph, source, sink):\n        \"\"\"\n        Returns the max flow from source to sink.\n        \"\"\"\n        flow, parent = 0, [None] * len(graph)\n        while True:\n            # BFS to obtain an augmenting path\n            bfs = [source]\n            while bfs:\n                u = bfs.pop(0)\n                for v, c in graph[u]:\n                    if parent[v] is None and c > 0:\n                        parent[v] = u\n                        bfs.append(v)\n                        flow += c\n                        graph[u][v] = c if c < graph[u][v] else graph[u][v]\n            if parent[sink] is None:\n                break\n            # Update the residual graph\n            for u in range(len(parent)):\n                for v, c in graph[u]:\n                    if parent[u] is not None and parent[v] is not None:\n                        graph[u][v] -= c\n        return flow\n\n    def min_cost_flow(graph, source, sink):\n        \"\"\"\n        Returns the minimum cost flow.\n        \"\"\"\n        max_flow = max_flow(graph, source, sink)\n        cost = 0\n        while max_flow > 0:\n            # Find the minimum cost path\n            previous = [None] * len(graph)\n            distances = [float(\"inf\")] * len(graph)\n            distances[source] = 0\n            queue = [source]\n            while queue:\n                current = queue.pop(0)\n                for neighbor, capacity in graph[current]:\n                    if distances[neighbor] == float(\"inf\") and capacity > 0:\n                        queue.append(neighbor)\n                        distances[neighbor] = distances[current] + 1\n                        previous[neighbor] = current\n            # Relax edges in the minimum cost path\n            for neighbor, capacity in graph[current]:\n                if capacity > 0 and distances[neighbor] < distances[current]:\n                    graph[current][neighbor] -= capacity\n                    graph[neighbor][current] += capacity\n                    cost += capacity\n                    previous[current] = neighbor\n            max_flow -= 1\n        return cost\n\n    n, m, s, t = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, c, w = list(map(int, stdin.readline().split()))\n        graph[u].append((v, c))\n        graph[v].append((u, w))\n    return str(min_cost_flow(graph, s, t))\n"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    graph = [[int(x) for x in y.split()] for y in stdin.split('\\n') if y]\n    graph.sort(key=lambda x: x[2])\n    curr = 0\n    res = 0\n    while True:\n        u, v, c, w = graph[curr]\n        curr += 1\n        if c <= 0:\n            continue\n        cap = min(c, (n - u - 1) * (n - v - 1))\n        res += cap * w\n        u += cap\n        v += cap\n        if u == n or v == n:\n            break\n    return str(res)\n\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0].split()[0])\n    m = int(lines[0].split()[1])\n    s = int(lines[0].split()[2])\n    t = int(lines[0].split()[3])\n\n    from collections import defaultdict\n    edges = defaultdict(list)\n\n    for i in range(1, m+1):\n        start, end, capacity, cost = lines[i].split()\n        edges[start].append((end, int(capacity), int(cost)))\n        edges[end].append((start, int(capacity), int(cost)))\n\n    # print(edges)\n\n    queue = [(s, t, 0)]\n    visited = set()\n    while queue:\n        curr, neighbor, dist = queue.pop(0)\n        visited.add(curr)\n        if curr == t:\n            return dist\n        for nbr, capacity, cost in edges[curr]:\n            if nbr not in visited:\n                queue.append((nbr, curr, dist + cost))\n\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"You are the manager of a supermarket. You have a list of $n$ different products where product $i$ has a price $p_i$ and a stock $s_i$. All of the products arrive at the store at the same time and the store has a limited capacity. You are given an array of $m$ events where event $i$ with $p_i \\leq 1000$ and $0 \\leq s_i \\leq n - 1$.\n\nFor event $i$, if there are at least $s_i$ items in stock, you can choose to sell them all to the customer and receive $p_i$ units of money. You can continue to sell and receive money from the customer until you either run out of customers or you cannot sell them anything more. Your goal is to sell as many products as possible and earn the most money.\n\nGiven an array of events events. For each event, output the maximum amount of money you can earn.\n\nInput Format\nThe first line of input contains $n$ and $m$ separated by a single space.\nThe next $m$ lines each contain $p_i$ and $s_i$ separated by a single space.\n\nConstraints\n$n \\in [2, 250]$\n$m \\in [1, 5000]$\n$p_i \\in [0, 1000]$\n$s_i \\in [0, n - 1]$\nOutput Format\nFor each event, output the maximum amount of money you can earn.\n\nSample Input 0\n4 4 0 3\n0 1 4 10\n1 2 2 10\n0 2 4 30\n2 3 4 10\nSample Output 0\n4 140\n\n\"\"\"\n\n    # Write your code here\n    def find_max_flow(graph, s, t):\n        residual = graph\n        flow = 0\n        while True:\n            path = BFS(graph, s, t)\n            if not path:\n                return flow\n            for i in range(len(path) - 1):\n                u, v = path[i], path[i + 1]\n                if not residual[u][v]:\n                    return flow\n                residual[u][v] = 0\n                residual[v][u] = 1\n                flow += 1\n\n    def BFS(graph, s, t):\n        queue = deque([s])\n        visited = set()\n        visited.add(s)\n        path = []\n        while queue:\n            cur = queue.popleft()\n            for i, j in graph[cur]:\n                if j and i not in visited:\n                    visited.add(i)\n                    queue.append(i)\n                    path.append(i)\n        return path if t in path else None\n\n    def add_edge(graph, u, v, w):\n        graph[u][v] = graph[u].get(v, 0) + w\n\n    def build_graph(n, m, graph, events):\n        for i in range(m):\n            u, v, w, z = map(int, events[i].split())\n            add_edge(graph, u, v, w)\n            add_edge(graph, v, u, z)\n\n    def solution(n, m, s, t, events):\n        build_graph(n, m, graph, events)\n        return find_max_flow(graph, s, t)\n\n    n, m = map(int, stdin.split())\n    events = [stdin.strip() for _ in range(m)]\n    graph = [[0] * n for _ in range(n)]\n    print(solution(n, m, 0, n - 1, events))\n"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(s, t):\n        seen = [float('inf')] * n\n        seen[s] = 0\n        q = deque([s])\n        while q:\n            u = q.popleft()\n            for v, c, w in graph[u]:\n                if seen[v] > seen[u] + w:\n                    seen[v] = seen[u] + w\n                    if v == t:\n                        return seen[t]\n                    q.append(v)\n        return 0\n\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        graph[u].append((v, c, w))\n        graph[v].append((u, c, w))\n    flow = bfs(s - 1, t - 1)\n    if flow == 0:\n        return '0'+ str(0)\n    cost = float('inf')\n    for u, v, c, w in graph[s - 1]:\n        if w - flow <= cost and w - flow > 0:\n            cost = w - flow\n    return str(flow) +'' + str(cost)"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(i) for i in stdin.split(' ')]\n    graph = [[] for i in range(n)]\n    for i in range(m):\n        u, v, c, w = [int(j) for j in stdin.split(' ')[i * 4 + 1:i * 4 + 4 + 1]]\n        graph[u].append([v, c, w])\n    flow = [0] * n\n    res = 0\n    while True:\n        p = [False] * n\n        q = [False] * n\n        q[s] = True\n        while True:\n            q_next = []\n            for i in range(n):\n                if q[i]:\n                    for next, c, w in graph[i]:\n                        if not p[next] and flow[i] < c:\n                            q_next.append([next, c, w])\n                            p[next] = True\n            if len(q_next) == 0:\n                break\n            q = q_next\n        if not p[t]:\n            break\n        for i in range(n):\n            if p[i]:\n                for next, c, w in graph[i]:\n                    if p[next] and flow[i] < c:\n                        flow[i] += c\n                        flow[next] -= c\n        res += 1\n    return str(res) +'' + str(flow[t])\n"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    graph = {\n        \"graph\": [],\n        \"nodes\": set(),\n        \"edges\": [],\n    }\n    \n    for line in stdin.split(\"\\n\")[1:-1]:\n        u, v, c, w = map(int, line.split())\n        graph[\"graph\"].append([u, v, c, w])\n        graph[\"edges\"].append([u, v, c, w])\n        graph[\"nodes\"].add(u)\n        graph[\"nodes\"].add(v)\n    \n    graph[\"nodes\"] = sorted(graph[\"nodes\"])\n    graph[\"edges\"] = sorted(graph[\"edges\"], key=lambda x: x[3])\n    return str(find_max_flow(graph))\n\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n    edges = []\n    for _ in range(m):\n        u, v, c, w = [int(x) for x in stdin.split()]\n        edges.append((u, v, c, w))\n\n    return str(max_flow(n, edges))\n\n\ndef"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds a minimum cost flow between source and sink nodes in a graph,\n    using BFS, marking visited nodes and following path of smallest\n    cost to the source, reconstructing a maximum flow between source and sink\n    \"\"\"\n    source, sink, _ = map(int, stdin.split(' '))\n    max_flow = 0\n    while True:\n        parents = {}\n        parents[source] = None\n        queue = [source]\n        while queue:\n            curr_node = queue.pop(0)\n            if curr_node == sink:\n                break\n            for adj_node, _ in graph[curr_node]:\n                if adj_node in parents:\n                    continue\n                parents[adj_node] = curr_node\n                queue.append(adj_node)\n        if not queue:\n            break\n        if sink not in parents:\n            break\n        path = [sink]\n        curr_node = sink\n        while curr_node is not source:\n            curr_node = parents[curr_node]\n            path.append(curr_node)\n        max_flow += min_cost_flow\n        for idx, node in enumerate(path):\n            if idx == 0:\n                continue\n            graph[node][path[idx - 1]][1] -= min_cost_flow\n            graph[path[idx - 1]][node][1] += min_cost_flow\n    return str(max_flow)\n"
    },
    {
        "number": 3183,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve today's problem.\"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    # get input\n    n, k = [int(s) for s in stdin.split()]\n    ranges = [tuple([int(s) for s in stdin.split()]) for _ in range(k)]\n    \n    # is the building possible?\n    if k > n * n:\n        return \"impossible\"\n    \n    # is every range overlapping?\n    ranges.sort()\n    range_len = ranges[-1][1] - ranges[0][0]\n    if any(ranges[i][0] < ranges[i-1][1] < ranges[i][1] or ranges[i][0] < ranges[i-1][0] < ranges[i][1] for i in range(1, k)):\n        return \"impossible\"\n    \n    # is every range covered by a camera?\n    ranges.sort()\n    first = ranges[0]\n    for i in range(1, k):\n        if ranges[i][0] < ranges[i-1][1] < ranges[i][1]:\n            continue\n        if ranges[i][0] <= first[0] <= ranges[i][1] or first[0] <= ranges[i][1] <= ranges[i][1]:\n            continue\n        return \"impossible\"\n    \n    # find the minimal number of cameras\n    cameras = set()\n    for i in range(k):\n        cameras.add(first[0])\n        for j in range(1, range_len):\n            cameras.add(first[0] + j)\n    cameras = sorted(list(cameras))\n    return str(len(cameras))\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the problem.\n    '''\n    # TODO: Solve the problem here\n    return ''\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin.readline().strip())\n    k = int(stdin.readline().strip())\n    lst = []\n    for i in range(k):\n        lst.append(stdin.readline().strip())\n    lst = [list(map(int, lst[i].split())) for i in range(k)]\n    for i in range(k):\n        if lst[i][0] <= lst[i][1]:\n            lst[i][0] = lst[i][0] - 1\n            lst[i][1] = lst[i][1] - 1\n    lst = sorted(lst, key=lambda x: x[0])\n    sum1 = 0\n    for i in range(num):\n        sum1 += lst[i][1] - lst[i][0] + 1\n    if sum1 == num:\n        return str(sum1)\n    return 'impossible'\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    _, k = [int(x) for x in stdin.split()]\n    polygon = []\n    for _ in range(k):\n        polygon.append([int(x) for x in stdin.split()])\n    polygon.sort(key=lambda x: x[1])\n    polygon.sort(key=lambda x: x[0])\n    left = 0\n    right = polygon[0][1]\n    ans = 0\n    for a, b in polygon:\n        if left < a:\n            ans += 1\n            left = right\n        right = max(right, b)\n    return ans\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split('\\n')[0].split()))\n    a = []\n    for i in range(k):\n        a.append(list(map(int, stdin.split('\\n')[i + 1].split())))\n    a = sorted(a, key=lambda x: x[0])\n    a.insert(0, [1, 1])\n    a.append([n + 1, n + 1])\n    l = 0\n    r = 0\n    for i in range(1, len(a)):\n        if a[i][0] <= r:\n            if a[i][0] >= a[i - 1][1]:\n                r = a[i][1]\n        else:\n            l = a[i][0]\n            r = a[i][1]\n    if l == n + 1:\n        return 'impossible'\n    return str(r - l + 1)\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"100 7\\n1 50\\n50 70\\n70 90\\n90 40\\n20 60\\n60 80\\n80 20\")\n    3\n    \"\"\"\n    n, k = map(int, stdin.split())\n    polygon_points = [set(), set()]\n    for _ in range(k):\n        a, b = map(int, stdin.readline().split())\n        a -= 1\n        b -= 1\n        if a > b:\n            b += n\n        polygon_points[0].add(a)\n        polygon_points[1].add(b)\n    cameras = []\n    for i in range(n):\n        cameras.append(0)\n    for i in range(k):\n        for j in range(n):\n            if j in polygon_points[1 - (i & 1)]:\n                cameras[j] += 1\n    if any(camera > 1 for camera in cameras):\n        return \"impossible\"\n    return len([i for i in range(n) if cameras[i] == 1])\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split(' '))\n    camera = []\n    for _ in range(k):\n        camera.append(tuple(map(int, stdin.split('\\n')[_].split(' '))))\n    camera.sort(key=lambda x: x[0])\n    camera.sort(key=lambda x: x[1])\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(1, n):\n        for j in range(n):\n            dp[i][j] = dp[i - 1][j]\n            for h in range(j + 1, n):\n                if j < camera[i - 1][1] <= h:\n                    dp[i][j] += dp[i - 1][h]\n                if camera[i - 1][0] <= j < camera[i - 1][1] <= h:\n                    dp[i][j] += dp[i - 1][h] - dp[i - 1][j]\n    return 'impossible' if dp[-1][0] < k else str(dp[-1][0])\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lst = [line.split() for line in stdin]\n    n, k = map(int, lst[0])\n    lst = lst[1:]\n    # print(lst)\n    dct = {}\n    for line in lst:\n        l, r = map(int, line)\n        # print(l, r)\n        for i in range(l, r + 1):\n            dct[i] = dct.get(i, []) + [r]\n        # print(dct)\n    # print(dct)\n    for i in range(k):\n        for line in lst:\n            l, r = map(int, line)\n            dct[l] = list(set(dct[l]) & set(dct[r]))\n            # print(dct)\n    # print(dct)\n    # print(dct.values())\n    count = 0\n    for val in dct.values():\n        if len(val) == 0:\n            return \"impossible\"\n        count += 1\n    return count\n\nprint(solution(input()))\n\n\"\"\"\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3184,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution to the problem.\n    '''\n    pass\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    https://app.codility.com/demo/results/trainingQ5YV3B-4J7/\n    '''\n    factorial = 1\n    for i in range(1, len(stdin) + 1):\n        factorial *= int(stdin[i-1])\n    return str(factorial)\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate n!\n    \"\"\"\n    factorial = 1\n    for number in stdin:\n        if int(number) < 0:\n            return \"Error, input contains negative integer.\"\n        for i in range(int(number)):\n            factorial *= int(number)\n    return str(factorial)\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    total = 1\n    for i in range(1, num+1):\n        total *= i\n    return str(total)\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # import sys\n    # return str(len(sys.stdin.readline()))\n    import math\n    return str(math.factorial(int(stdin)))\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin\n    "
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin)\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the value of n!\"\"\"\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the factorial of n.\n\n    Parameters:\n    stdin (str): The factorial n! of a positive integer n.\n\n    Returns:\n    str: The value of n.\n    \"\"\"\n    return stdin\n"
    },
    {
        "number": 3185,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    result = stdin\n    for i in range(1, 10 ** 6):\n        result = str(i) + result\n        if int(result) == int(stdin):\n            return i\n\nprint(solution('120'))\n\n\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(num) for num in stdin.split(' ')]\n    # if N < K or K < 1 or M < 1:\n    #     return 0\n    count = 0\n    for i in range(K, N+1):\n        count += N // i\n    return count % 1000000007\n\nprint(solution(input()))\n\nn, m, k = list(map(int, input().split()))\ncount = 0\nfor i in range(k, n+1):\n    count += n // i\nprint(count % 1000000007)\n\n'''\n'''\n1. \u5148\u5206\u6210\u53ef\u62ffk\u500b\u4e00\u7d44\n2. \u518d\u5206\u6210\u53ef\u62ffm\u500b\u4e00\u7d44\n'''\nn, m, k = list(map(int, input().split()))\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''O(N * M) time | O(N * M) space'''\n    n, m, k = map(int, stdin.split())\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(m + 1):\n            dp[i + 1][j] = dp[i + 1][j] + dp[i][j]\n            if j >= k:\n                dp[i + 1][j] = dp[i + 1][j] + dp[i][j - k]\n\n    return dp[n][m] % (10 ** 6 + 7)\n"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    return str(n ** m // m * k % (10 ** 6 + 7))"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    count = 0\n    def dfs(n, m, k, pos=0, count=0):\n        if k == 0 and pos == n:\n            count += 1\n        elif k > 0 and pos < n:\n            for i in range(1, m+1):\n                if i <= k:\n                    dfs(n, m, k-i, pos+1, count)\n        return count\n    print(dfs(n, m, k))\n    return ''"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def comb(n, k):\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\n        for i in range(n + 1):\n            dp[i][0] = 1\n        for i in range(1, n + 1):\n            for j in range(1, k + 1):\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]\n        return dp[n][k]\n\n    n, m, k = map(int, stdin.split())\n    return comb(n, k) % (10 ** 6 + 7)\n"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split(\" \")))\n    ans = 0\n    for x in range(N + 1):\n        for y in range(M + 1):\n            z = N - x - y\n            if x * M + y * M >= K and z * M <= K:\n                ans += 1\n\n    return str(ans % 1000000007)\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n):\n        if n == 1:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    total, n, m, k = [int(i) for i in stdin.split(' ')]\n    return str(factorial(n) // (factorial(k) * factorial(n - k)))\n    \ndef"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def cnt(n, m, k):\n        p = 1\n        q = 1\n        r = 1\n        for i in range(1, m + 1):\n            p *= n - i + 1\n            q *= i\n            r *= m - i + 1\n            p %= MOD\n            q %= MOD\n            r %= MOD\n        return ((p * pow(q, MOD - 2, MOD)) % MOD + (r * pow(q, MOD - 2, MOD)) % MOD) % MOD\n\n    n, m, k = list(map(int, stdin.split()))\n    return cnt(n, m, k)\n\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = list(map(int, stdin.split()))\n    # the number of copies of an object = number of times the object appears in the array\n    # the number of ways to take at most K of objects = the number of ways to take at most K - 1 of objects + the number of ways to take at most K - 1 of objects - the number of ways to take at most K - 2 of objects +...\n    return f'{(comb(N + M - 1, N - 1) + (comb(N + M - 1, N - 1) - comb(N + M - 1, N - 2)) % 1000000007}'"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str\"\"\"\n    pass\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    arr = []\n    for i in range(1, n + 1):\n        arr.append(list(map(int, inputs[i].split())))\n    d = int(inputs[n + 1])\n    x = set()\n    y = set()\n    for i in range(n):\n        x.add(arr[i][0])\n        y.add(arr[i][1])\n    x = list(x)\n    y = list(y)\n    x = sorted(x)\n    y = sorted(y)\n    m = n\n    while m > 1:\n        tmp = []\n        for i in range(m - 1):\n            tmp.append(abs(x[i + 1] - x[i]) + abs(y[i + 1] - y[i]))\n        tmp = sorted(tmp)\n        if tmp[0] > d:\n            return \"impossible\"\n        for i in range(m - 1):\n            if tmp[i + 1] == tmp[i]:\n                x.pop(i + 1)\n                y.pop(i + 1)\n                m -= 1\n                break\n    x = x[0]\n    y = y[0]\n    count = 0\n    for i in range(n):\n        count += abs(x - arr[i][0]) + abs(y - arr[i][1])\n    return count\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the smallest possible total distance that each citizen needs to travel.\n\n    :param stdin: The input file.\n    :return: The smallest possible total distance that each citizen needs to travel.\n    \"\"\"\n    n = int(stdin.readline())\n    houses = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    d = int(stdin.readline())\n    # d is less than the greatest distance between 2 houses\n    # but not less than the sum of the distance between each pair of 2 houses\n    # so, it cannot be less than the distance between 2 houses\n    # otherwise, no intersections are possible\n    if d < max(abs(x - y) for x, y in houses):\n        return \"impossible\"\n    # if there is no intersection where everyone lives within d distance, then there is no intersection\n    # otherwise, the minimum of d is the minimum distance between all the intersections\n    return str(sum(min(abs(x - x_) + abs(y - y_) for x_, y_ in houses) for x, y in houses) - sum(d * (n - 1) for x, y in houses))\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    houses = []\n    for i in range(n):\n        houses.append(list(map(int, stdin.readline().strip().split())))\n    distance = int(stdin.readline())\n    houses.sort(key=lambda x: x[0])\n    houses.sort(key=lambda x: x[1])\n    print(houses)\n    for i in range(1, n):\n        if houses[i][0] - houses[i - 1][0] > distance:\n            return 'impossible'\n    return 'possible'"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the total travel distance of all citizens.\n\n    >>> solution(\"5\\n3 1\\n4 1\\n5 9\\n2 6\\n5 3\\n10\")\n    '18'\n    \"\"\"\n\n    # Parse the input\n    num_citizens = int(stdin.readline())\n    citizen_locations = [\n        [int(x) for x in stdin.readline().split()] for _ in range(num_citizens)\n    ]\n    d = int(stdin.readline())\n\n    # Solve the problem\n    total_distance = min(\n        min(abs(x - y) + abs(z - w) for z, w in combinations(citizen_locations, 2))\n        for x, y in combinations(citizen_locations, 2)\n    )\n\n    # Return the solution\n    if total_distance <= d:\n        return str(total_distance)\n    return \"impossible\"\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the smallest total distance that everyone has to travel.\n\n    >>> solution(\"5\\n3 1\\n4 1\\n5 9\\n2 6\\n5 3\\n10\\n\")\n    '18'\n    \"\"\"\n    _ = stdin.readline()\n    n = int(stdin.readline())\n    houses = [tuple(map(int, line.strip().split())) for _ in range(n) for line in stdin.readlines()]\n    _ = stdin.readline()\n    d = int(stdin.readline())\n    dist = max((abs(x - y) for x, y in houses))\n    if d >= dist:\n        return \"impossible\"\n    return sum(abs(x - y) for x, y in houses) + dist - d\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    houses = []\n    for _ in range(n):\n        x, y = [int(i) for i in stdin.split()]\n        houses.append((x, y))\n    d = int(stdin)\n    for i in range(n):\n        houses[i] = (houses[i][0] - d, houses[i][1] - d)\n    houses = [x + (y,) for x, y in houses]\n    houses.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    print(houses)\n    return\n"
    },
    {
        "number": 3187,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the minimum total distance that all citizens need to travel.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    '''\n    pass\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns solution of a given problem.\n\n    Args:\n        stdin (str): input of a problem.\n\n    Returns:\n        str: string representation of the solution.\n    \"\"\"\n    # Your code here\n    # It's main function. Don't remove this function\n    # It's used for auto-testing and must return a result for check.\n    # IGNORE linter warnings:\n    #     Too many branches (12/20)\n    #     Too many statements (33/50)\n    #     Too many local variables (11/15)\n    #     Too many expressions (12/17)\n    #     Too many return statements (5/5)\n    #     Too many arguments (5/5)\n    #     Too many item in list (0/5)\n    #     No unused arguments (1/1)\n    #     Maximum line length (120/120)\n    # You can see detailed information about warnings via python -W flag.\n\n    # We need to read the number of planets N\n    n = int(stdin.readline())\n\n    # We need to build the network, so we need to build the network\n    # We need to create a variable for each vertex of the network\n    # A list of variables - list for each vertex\n    # The list of variables will have 3 items for each vertex\n    # The name of the vertex will be equal to the index\n    # The value of the variable will be equal to the coordinates of the vertex\n    x, y, z = [], [], []\n    for i in range(n):\n        x.append(int(stdin.readline()))\n        y.append(int(stdin.readline()))\n        z.append(int(stdin.readline()))\n\n    # We need to build a network for each vertex of the network\n    # And we need to build a network for each other vertex\n    # So we need a list of networks - list for each vertex\n    # The list of networks will have n-1 networks\n    # The name of the network will be equal to the index\n    # The list of variables will be equal to the list of variables of the vertex\n    # The value of the network will be equal to the distance between the current vertex and the next vertex\n    # The value of the network will be equal to the minimum value of the 3 distances\n    # The value of the network will be equal to the point with the minimal distance to the vertex\n    network = []\n    for i in range(n):\n        network.append([])\n        network[i].append(x[i] - x[i + 1])\n        network[i].append(y[i] - y[i + 1])\n        network[i].append(z[i] - z[i + 1])\n        network[i].append(network[i][0] ** 2 + network[i][1] ** 2 + network[i][2] ** 2)\n\n    # We need to find the minimal distance\n    # We need to find the smallest distance\n    # We need to find the index of the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We need to find the index of the point with the smallest distance\n    # We need to find the point with the smallest distance\n    # We"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y, z = [int(x) for x in stdin.readline().split()]\n        points.append((x, y, z))\n\n    # init distance matrix\n    # todo: optimize the code for distance matrix creation\n    distances = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            distances[i][j] = distances[j][i] = distance(points[i], points[j])\n\n    # init graph\n    graph = [[] for _ in range(n)]\n\n    # build the graph\n    for i in range(n):\n        for j in range(n):\n            if i!= j and distances[i][j] <= 10000:\n                graph[i].append(j)\n\n    # compute the length\n    def cost(graph: list, start: int):\n        distance = 0\n        visited = [False] * n\n        queue = [start]\n        while queue:\n            distance += 1\n            for _ in range(len(queue)):\n                i = queue.pop(0)\n                visited[i] = True\n                for j in graph[i]:\n                    if not visited[j]:\n                        queue.append(j)\n        return distance\n\n    def compute_total_cost(graph: list, start: int):\n        distances = [cost(graph, i) for i in range(n)]\n        return sum(distances[i] for i in range(n) if i!= start)\n\n    return str(compute_total_cost(graph, 0))\n\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the lowest cost to build a transconduit network\"\"\"\n    number_of_planets = int(stdin.readline().strip())\n    planets = [list(map(int, line.strip().split())) for line in stdin]\n    planets.sort()\n    delta_coordinates = [abs(a - b) for a, b in zip(*planets)]\n    return str(delta_coordinates.count(1) + delta_coordinates.count(2) + delta_coordinates.count(3))\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    count = int(stdin.readline())\n    planets = []\n    for i in range(count):\n        planets.append(list(map(int, stdin.readline().split())))\n    return str(min(map(lambda x: min(x[0], x[1]), list(itertools.combinations(planets, 2)))))\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    stdin = stdin.split()\n    return stdin[0]\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the lowest cost of connecting all the planets.\n    :param stdin: The input string.\n    :return: The solution.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution of the problem\n    \"\"\"\n    return str(stdin)\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    planets = [list(map(int, line.split())) for line in stdin]\n    tunnels = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            tunnels.append((\n                math.fabs(planets[i][0] - planets[j][0]),\n                math.fabs(planets[i][1] - planets[j][1]),\n                math.fabs(planets[i][2] - planets[j][2]),\n            ))\n    min_cost = math.inf\n    for num in range(1, n):\n        cost = 0\n        for i in range(num):\n            cost += min(tunnels[i][0], tunnels[i][1], tunnels[i][2])\n        for j in range(num, n):\n            cost += min(tunnels[j][0], tunnels[j][1], tunnels[j][2])\n        min_cost = min(min_cost, cost)\n    return str(min_cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    import sys\n    from math import sqrt\n    \n    _, *a = map(int, sys.stdin.read().split())\n    a = tuple(map(tuple, zip(a[::3], a[1::3], a[2::3])))\n    \n    ans = sys.maxsize\n    \n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            ans = min(ans, sqrt(sum((b - a[i]) ** 2 for a, b in zip(a, a[j]))) + sqrt(sum((b - a[j]) ** 2 for a, b in zip(a, a[i]))))\n    \n    return ans\n"
    },
    {
        "number": 3188,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum cost of building a network of transconduit tunnels\n    through N planets.\n\n    Args:\n        stdin (str): The input string.\n\n    Returns:\n        str: The output string.\n    \"\"\"\n    pass\n\ndef"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 1\n   ... 110\n   ... 011''')\n    '2'\n    \"\"\"\n    n, m = map(int, stdin.split('\\n')[:2])\n    photo_list = [photo.split('\\n') for photo in stdin.split('\\n')[2:]]\n    on_switches = set()\n    on_lights = set()\n    for photo in photo_list:\n        for index in range(n):\n            switch = int(photo[0][index] == '1')\n            light = int(photo[1][index] == '1')\n            on_switches.add(switch)\n            on_lights.add(light)\n    return str(len(on_switches & on_lights))\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # My Solution 1 - 80ms (12%)\n    n, m = map(int, stdin.split(' '))\n    lights = [set() for _ in range(n)]\n    switches = [set() for _ in range(n)]\n    for i in range(m):\n        a, b = stdin.split('\\n')[i * 2].split(' '), stdin.split('\\n')[i * 2 + 1].split(' ')\n        lights[int(a[0]) - 1].add(int(a[1]) - 1)\n        switches[int(b[0]) - 1].add(int(b[1]) - 1)\n\n    ans = 0\n    for i in range(2 ** n):\n        light_connected = set()\n        switch_connected = set()\n        for j in range(n):\n            if (i >> j) & 1:\n                light_connected.add(j)\n            else:\n                switch_connected.add(j)\n        if len(switch_connected) == 0:\n            continue\n        for j in range(m):\n            match = True\n            for s in switch_connected:\n                if (lights[s] & light_connected) == set():\n                    match = False\n                    break\n                if (switches[s] & light_connected) == set():\n                    match = False\n                    break\n            if not match:\n                break\n        else:\n            ans += 1\n    return str(ans % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\""
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    n,m = map(int, stdin.readline().strip().split())\n    s,l = [],[]\n    for i in range(n):\n        s.append(stdin.readline().strip())\n        l.append(stdin.readline().strip())\n    \n    wirings = 0\n    for i in range(1 << n):\n        if i == 0: continue\n        on = [0 for i in range(n)]\n        off = [0 for i in range(n)]\n        for j in range(n):\n            if (i>>j) & 1:\n                on[j] = 1\n            else:\n                off[j] = 1\n        is_consistent = True\n        for j in range(m):\n            if not ((s[j]==\"\".join(map(str,on)) and l[j]==\"\".join(map(str,off))) or (s[j]==\"\".join(map(str,off)) and l[j]==\"\".join(map(str,on)))):\n                is_consistent = False\n                break\n        if is_consistent:\n            wirings += 1\n    \n    return str(wirings%1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(n) where n is the total number of switches and lights\n    Space Complexity: O(1)\n    \"\"\"\n    num_switches, num_photos = map(int, stdin.split())\n    photo_switches = [list(map(int, stdin.split()[1:])) for _ in range(num_photos)]\n    num_wirings = 0\n    for i in range(1 << num_switches):\n        # Initialize a bit string with value i\n        bitstring = bin(i)[2:]\n        bitstring = \"0\" * (num_switches - len(bitstring)) + bitstring\n        # Keep track of which switches are on/off\n        switches = [False] * num_switches\n        for j in range(num_switches):\n            if bitstring[j] == \"1\":\n                switches[j] = True\n        # Check if each photo matches the current configuration of switches\n        for photo in photo_switches:\n            # Initialize a list to keep track of the lights that are on/off\n            lights = []\n            for j in range(num_switches):\n                if switches[j] and photo[j] == 1:\n                    lights.append(True)\n                elif not switches[j] and photo[j] == 0:\n                    lights.append(True)\n                else:\n                    lights.append(False)\n            if not any(lights):\n                break\n        else:\n            num_wirings += 1\n    return str(num_wirings % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    switchs, pictures = [], []\n    n, m = stdin.split()\n    n, m = int(n), int(m)\n    for i in range(m):\n        pictures.append(stdin.split()[i])\n    for i in range(n):\n        switchs.append([0] * n)\n    for picture in pictures:\n        for i in range(n):\n            switchs[i][int(picture[i])] += 1\n    count = 0\n    for picture in pictures:\n        count += picture_count(switchs, picture)\n    return str(count % 1000003)\n\n\ndef"
    },
    {
        "number": 3189,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(i) for i in stdin.split(' ')]\n    photos = [stdin for _ in range(m)]\n    numbers = [0] * n\n    for i in range(m):\n        on, off = [int(i) for i in stdin.split(' ')]\n        numbers[on - 1] += 1\n        numbers[off - 1] -= 1\n    result = 0\n    print(numbers)\n    for i in numbers:\n        result = result * 2 + i % 3\n    return str(result % 1000003)\n"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin)\n    \"\"\"\n    # N = int(stdin[0])\n    # seq = [int(num) for num in stdin[1].split()]\n    # P = int(stdin[2])\n\n    # N, seq, P = int(stdin[0]), [int(num) for num in stdin[1].split()], int(stdin[2])\n    # seq = [int(num) for num in stdin[1].split()]\n    # P = int(stdin[2])\n\n    seq = [int(num) for num in stdin[1].split()]\n    P = int(stdin[2])\n\n    seq.sort()\n\n    counter = 0\n    for i in range(len(seq)-1):\n        if seq[i] >= P:\n            counter += 1\n            for j in range(i+1, len(seq)):\n                if seq[i] + seq[j] >= P:\n                    counter += 1\n    return str(counter)\n\n\ndef"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return f'{solution_main(stdin)}'"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    line_count, prices = map(int, stdin.splitlines())\n    for _ in range(line_count):\n        min_idx = 0\n        max_idx = 1\n        p_min = prices[0]\n        p_max = prices[1]\n        for i in range(2, line_count):\n            if prices[i] < p_min:\n                min_idx = i\n                p_min = prices[i]\n            elif prices[i] > p_max:\n                max_idx = i\n                p_max = prices[i]\n        stdin = stdin + \" \" + str(max_idx - min_idx)\n    return stdin\nprint(solution(input()))\n"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n = int(stdin.readline())\n    # seq = list(map(int, stdin.readline().split()))\n    # p = int(stdin.readline())\n    n = 3\n    seq = [1, 2, 3]\n    p = 2\n    seq.sort()\n    cnt = 0\n    for i in range(len(seq) - n + 1):\n        if seq[i] >= p:\n            cnt += 1\n    return str(cnt)\n\n\ndef"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    prices = list(map(int, stdin[1].split()))\n    k = int(stdin[2])\n    window = prices[:n]\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] >= prices[i-1]:\n            if k >= prices[i-1]:\n                k -= prices[i-1]\n            else:\n                k = 0\n            count += 1\n        window[i % n] = prices[i]\n        if k == 0:\n            break\n    print(count)\n"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, lst = [int(item) for item in stdin.split('\\n')[0].split(' ')]\n    if n < 1 or n > 1000000: return None\n    if n < 2: return 1\n    lst = [int(item) for item in stdin.split('\\n')[1].split(' ')]\n    if len(lst) < 1 or len(lst) > 1000000000: return None\n    if len(lst) < 2: return 0\n    p = int(stdin.split('\\n')[2])\n    if p < 0 or p > 1000000000: return None\n    cur = lst[0]\n    count = 0\n    for i in range(n):\n        if cur >= p:\n            count += 1\n        else:\n            cur = lst[i]\n    return count\n\nprint(solution('3\\n1 2 3\\n2'))\n"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, prices = [int(n) for n in stdin.strip().split('\\n')]\n    mean = int(stdin.split('\\n')[1])\n    doll_prices = [int(n) for n in stdin.split('\\n')[2].split(' ')]\n    max_price = max(doll_prices)\n    ans = 0\n    for i in range(len(doll_prices)):\n        if doll_prices[i] >= mean:\n            ans += 1\n            for j in range(i, len(doll_prices)):\n                if doll_prices[j] >= mean:\n                    ans += 1\n                else:\n                    break\n    return ans\n\nprint(solution('3\\n1 3 2\\n2'))\n\n------Solution (provided by the instructor)------\n\nn=int(input())\narr=list(map(int,input().split()))\nm=int(input())"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    number_of_days = int(stdin.readline())\n    prices = [int(x) for x in stdin.readline().split()]\n    avg = int(stdin.readline())\n    dolls = 0\n    for i in range(number_of_days):\n        if prices[i] >= avg:\n            dolls += 1\n    return dolls\n\nprint(solution(input()))"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    numbers = [int(x) for x in stdin[1].split(' ')]\n    P = int(stdin[2])\n\n    count = 0\n\n    for i in range(N - 1):\n        if numbers[i] >= P:\n            count += 1\n            for j in range(i + 1, N):\n                if numbers[j] >= P:\n                    count += 1\n                else:\n                    break\n\n    return str(count)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3190,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, seq, p = [int(s) for s in stdin.split('\\n')]\n    prices = [int(s) for s in stdin.split('\\n')[1].split(' ')]\n    s = 0\n    for i in range(n):\n        if prices[i] >= p:\n            s += 1\n    return s"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = [int(i) for i in stdin.strip().split()]\n    s = n // 2\n    if n > 10 ** 6:\n        return \"Time limit exceeded!\"\n    elif r > 10 ** 9:\n        return \"Time limit exceeded!\"\n    elif p > 10 ** 9:\n        return \"Time limit exceeded!\"\n    else:\n        s = n // 2\n        if r < p:\n            return f\"{s + r}\"\n        else:\n            return f\"{s + r}\"\n"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines, time, time_to_add = stdin.split('\\n')\n    lines = int(lines)\n    time = int(time)\n    time_to_add = int(time_to_add)\n    lines_to_add = [time_to_add]\n    for i in range(1, lines):\n        lines_to_add.append(lines_to_add[i - 1] + time_to_add)\n    crash_index = min(enumerate(lines_to_add), key=lambda t: t[1])[0]\n    return str(crash_index)\n"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, r, p = map(int, stdin.split(' '))\n    p = p * r\n    \n    print(p + n)\n    '''\n    n, r, p = map(int, input().split(' '))\n    ans = n\n    i = r\n    \n    while i >= p:\n        i = i - p\n        ans = ans + 1\n        \n    print(ans)"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, r, p = list(map(int, stdin.split()))\n    return str(n*p + r)"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split(' ')\n    N, R, P = int(line[0]), int(line[1]), int(line[2])\n    lo, hi = 0, N\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if R < P * mid:\n            hi = mid\n        else:\n            lo = mid + 1\n    return P * lo - R\n\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum worst-case time to find the crashing line\n    >>> solution('1 100 20')\n    0\n    >>> solution('10 10 1')\n    19\n    \"\"\"\n    n, r, p = [int(x) for x in stdin.split()]\n    return str(min(r, ((n + r) // 2) * p))\n"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, r, p = map(int, stdin.split())\n    t = r * n\n    t += (n // 2) * p\n    return t\n    pass"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines, compile_time, run_time, add_time = stdin.split()\n    lines, compile_time, run_time, add_time = int(lines), int(compile_time), int(run_time), int(add_time)\n    count_lines = 0\n    while add_time >= 0:\n        if add_time >= run_time:\n            count_lines += 1\n            add_time -= run_time\n        else:\n            count_lines += 1\n            add_time -= add_time\n    return str(count_lines * run_time + add_time)\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the minimum worst case time to find the crashing line when using an optimal strategy.\n    '''\n    # read input\n    n, r, p = (int(n) for n in stdin.split())\n    # write your code in Python 3.6\n    def get_time(i):\n        '''\n        Returns the time it takes to add the i-th line to the program.\n        '''\n        return i + 1 + p if i > 0 else p\n    return min(r // get_time(n) + max(0, (r % get_time(n)) // p), r // get_time(n - 1) + max(0, (r % get_time(n - 1)) // p))\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the minimum worst-case time to find the crashing line when using\n    an optimal strategy.\n\n    You have already run the program once and therefore already know that it\n    does crash somewhere.\n\n    Args:\n        stdin (str): The input of the challenge problem.\n\n    Returns:\n        str: The minimum worst-case time to find the crashing line when using\n        an optimal strategy.\n    '''\n    n, r, p = map(int, stdin.split())\n    return f'{(r - p) * n}'\n"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    from itertools import chain, combinations\n    from collections import defaultdict\n    from copy import copy\n    \n    def powerset(iterable, max_size=None):\n        \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n        from itertools import chain, combinations\n        s = list(iterable)\n        return chain.from_iterable(combinations(s, r) for r in range(max_size+1))\n    \n    def findCycles(graph):\n        seen = set()\n        cycles = set()\n        for node in graph:\n            if node not in seen:\n                path = [node]\n                stack = [(node, path)]\n                while stack:\n                    node, path = stack.pop()\n                    if node in seen:\n                        continue\n                    for nextNode in graph[node]:\n                        if nextNode in path:\n                            cycles.add(tuple(path + [nextNode]))\n                        else:\n                            stack.append((nextNode, path + [nextNode]))\n                    seen.add(node)\n        return cycles\n    \n    def reduceCycles(cycles):\n        cycleMap = defaultdict(list)\n        for cycle in cycles:\n            for n in range(len(cycle)):\n                if cycle[n] == cycle[0]:\n                    cycleMap[cycle[0]].append(cycle[n])\n        return cycleMap\n    \n    def collectCycles(cycleMap):\n        cycleList = []\n        for cycle in cycleMap.values():\n            cycleList.append(cycle)\n        return cycleList\n    \n    def isCyclic(graph):\n        return len(findCycles(graph)) > 0\n    \n    def getCycleCount(graph):\n        return len(findCycles(graph))\n    \n    def getCycleSize(graph):\n        cycles = findCycles(graph)\n        cycleList = collectCycles(reduceCycles(cycles))\n        cycleMap = dict()\n        for cycle in cycleList:\n            size = len(cycle)\n            cycleMap[size] = cycleMap.get(size, [])\n            cycleMap[size].append(cycle)\n        return cycleMap\n    \n    def getCycleLargestSize(graph):\n        return max(getCycleSize(graph).keys()) if len(getCycleSize(graph)) > 0 else 0\n    \n    def getCycleWithLargestSize(graph):\n        cycleSizes = getCycleSize(graph)\n        return cycleSizes[max(cycleSizes.keys())] if len(cycleSizes) > 0 else None\n    \n    def isSortedCycle(graph):\n        cycle = getCycleWithLargestSize(graph)\n        for node1, node2 in zip(cycle[:-1], cycle[1:]):\n            if node1 > node2:\n                return False\n        return True\n    \n    def isValidCycle(graph):\n        if isCyclic(graph):\n            return isSortedCycle(graph)\n        return True\n    \n    def isValidSolution(graph):\n        return isValidCycle(graph) and not isCyclic(graph)\n    \n    def getInputLines(input):\n        return input.strip().split('\\n')\n    \n    def getClasses(graph):\n        classes = set()\n        for className in graph:\n            if className.islower():\n                classes.add(className)\n        return classes\n    \n    def getFiles(graph):\n        files = set()\n        for fileName in graph:\n            if fileName.isupper():\n                files.add(fileName)\n        return files\n    \n    def getImports(graph):\n        imports = defaultdict(set)\n        for className in graph:\n            if className.isupper():\n                for fileName in graph[className]:\n                    imports[className].add(fileName)\n        return imports\n    \n    def removeImports(graph):\n        return dict((className, set(fileNames)-{className}) for className, fileNames in graph.items())\n    \n    def removeRedundantImports(graph):\n        importFileNames = set(chain.from_iterable(graph.values()))\n        importNames = set(chain.from_iterable(graph.keys()))\n        return dict((className, list(set(fileNames) - importNames)) for className, fileNames in graph.items())\n    \n    def getImportedFiles(graph):\n        importedFiles = dict()\n        for className, fileNames in graph.items():\n            for fileName in fileNames:\n                importedFiles[fileName] = set(graph[className])\n        return importedFiles\n    \n    def isValidFile(graph, fileName):\n        fileNames = graph.keys()\n        return fileName.isupper() and fileName in fileNames and len(graph[fileName]) > 0\n    \n    def getImportOrder(graph):\n        fileNames = graph.keys()\n        importedFiles = getImportedFiles(graph)\n        imports = getImports(graph)\n        importOrders = list()\n        while len(fileNames) > 0:\n            importOrder = dict()\n            for fileName in fileNames:\n                importedFileSet = importedFiles[fileName]\n                importedFilesWithImportSet = {fileName: imports[fileName]}\n                for importedFile in importedFileSet:\n                    importedFilesWithImportSet[importedFile] = importedFiles[importedFile]\n                importedFileWithImportOrder = dict(sorted(importedFilesWithImportSet.items()))\n                importOrder[fileName] = list(importedFileWithImportOrder.keys())\n            importOrders.append(importOrder)\n            fileNames = list(set(chain.from_iterable(importOrder.values())))\n        return importOrders\n    \n    def isValidImportOrder(graph, importOrder):\n        for fileName in importOrder:\n            for importedFile in fileName:\n                if isValidFile(graph, importedFile):\n                    importedFiles = importOrder["
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    with open('test.txt', 'w') as f:\n        f.write(stdin)\n\n    import sys\n    import os\n    import subprocess\n    cmd = [\"python3\", \"test.py\"]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)\n    out = p.stdout.read()\n    out = out.decode('utf-8')\n    out = out.splitlines()\n    ans = []\n    for line in out:\n        if line[:3] == 'SIP':\n            ans.append(line[4:])\n    \n    return ','.join(ans)\n"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, files = get_n_files_and_files(stdin)\n    for i in range(n):\n        dependencies = read_dependencies(files[i], files[i + 1])\n        if has_cycle(dependencies):\n            return get_cycle(dependencies)\n    return \"SHIP IT\"\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n  \n  answer = stdin.splitlines()\n  import_list = [answer[i].split()[1:] for i in range(1,len(answer))]\n  file_count = len(import_list)\n  import_count = [len(l) for l in import_list]\n  dependency_count = sum(import_count)\n  \n  \n  \n  import_file = [import_list[i][j] for i in range(file_count) for j in range(import_count[i])]\n  #print(import_file)\n  import_file_list = set(import_file)\n  import_file_list = list(import_file_list)\n  #print(import_file_list)\n  \n  file_index = [0 for i in range(file_count)]\n  dependency_count_list = [0 for i in range(file_count)]\n  \n  \n  \n  while True:\n    cur_import_count = file_index[dependency_count_list.index(min(dependency_count_list))]\n    cur_file = import_file_list[file_index[dependency_count_list.index(min(dependency_count_list))]]\n    if cur_file == \"SHIP_IT\":\n      break\n    else:\n      import_file_list.remove(cur_file)\n      import_list[dependency_count_list.index(min(dependency_count_list))].remove(cur_file)\n      import_count[dependency_count_list.index(min(dependency_count_list))] -= 1\n      import_count[import_file.index(cur_file)] -= 1\n      \n      file_index[dependency_count_list.index(min(dependency_count_list))] += 1\n      dependency_count_list[dependency_count_list.index(min(dependency_count_list))] = dependency_count + import_count[dependency_count_list.index(min(dependency_count_list))]\n  \n  for i in range(file_count):\n    import_list[i] = [x for x in import_list[i] if x not in import_list[import_file.index(cur_file)]]\n  \n  \n  answer = ''\n  for i in range(file_count):\n    if import_list[i]:\n      answer += import_list[i][0]\n      if len(import_list[i]) > 1:\n        answer += ','\n  if answer == '':\n    answer += \"SHIP_IT\"\n  return answer\n  \n  \n  \n  \n  \n  \n  \n"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    print(stdin)\n    return \"\"\n"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque, defaultdict\n    from itertools import combinations\n    input_data = stdin.split('\\n')\n    n = int(input_data[0].strip())\n    files = input_data[1].split(' ')\n    dependency_dict = defaultdict(set)\n    for _ in range(n):\n        file, num_dependencies = input_data[_].split(' ')\n        dependency_dict[file] = [x for x in input_data[_ + 1].split(' ')]\n    for _ in range(n):\n        del dependency_dict[_]\n    for _ in range(n):\n        for _ in range(n):\n            dependency_dict[_] = set(dependency_dict[_])\n    shortest_cycle = None\n    shortest_cycle_length = float('inf')\n    for files_list in combinations(files, n):\n        cycle_list = set(files_list)\n        dependency_dict_copy = dependency_dict.copy()\n        while len(cycle_list) > 0:\n            new_cycle_list = set()\n            for _ in cycle_list:\n                cycle_list_copy = cycle_list.copy()\n                cycle_list_copy.remove(_)\n                for _ in cycle_list_copy:\n                    if _ in dependency_dict_copy:\n                        dependency_dict_copy[_] = dependency_dict_copy[_].difference(cycle_list_copy)\n            cycle_list = set(cycle_list_copy)\n        if len(cycle_list) < shortest_cycle_length:\n            shortest_cycle_length = len(cycle_list)\n            shortest_cycle = list(cycle_list)\n    if shortest_cycle is None:\n        return 'SHIP IT'\n    else:\n        return ','.join(shortest_cycle)\n\nprint(solution(input()))"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    # Your solution goes here\n    \n    return \"\"\n\"\"\"\n\nimport sys\n\nn = int(sys.stdin.readline())\nfiles = sys.stdin.readline().split()\ndependencies = []\nfor i in range(n):\n    line = sys.stdin.readline().split()\n    dependencies.append(line[2:])\n\nparent_children = {}\nfor file in files:\n    parent_children[file] = []\n\nfor dependency in dependencies:\n    for parent in dependency:\n        parent_children[parent].append(dependency[0])\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    dg = defaultdict(list)\n    for line in stdin.splitlines():\n        dep, *_ = line.split()\n        for ind in _:\n            dg[ind].append(dep)\n    cycle = [x[0] for x in topological_sort(dg)]\n    if cycle:\n        return \",\".join(cycle)\n    else:\n        return \"SHIP IT\"\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    \n    # parse the input to the graph\n    n = int(stdin.split('\\n')[0])\n    files = {}\n    for _ in range(n):\n        files[stdin.split('\\n')[1 + _].split(' ')[0]] = set(stdin.split('\\n')[1 + _].split(' ')[1].split(','))\n    \n    # build the graph\n    graph = {}\n    for file in files:\n        graph[file] = set()\n        for file2 in files:\n            if file in files[file2]:\n                graph[file].add(file2)\n                \n    # the nodes which have been visited\n    visited = set()\n    # the queue of nodes to explore\n    queue = []\n    # the set of paths\n    paths = set()\n    # the best path\n    best_path = None\n    # the shortest path length\n    shortest_path_len = math.inf\n    \n    # enqueue the first node to be explored\n    queue.append(files.keys()[0])\n    # enqueue the first node's dependencies to be explored\n    for dep in graph[queue[0]]:\n        queue.append(dep)\n    # get the set of paths\n    paths.add(','.join(queue))\n    \n    # explore the paths\n    while queue:\n        # remove the node from the queue\n        node = queue.pop(0)\n        # enqueue the node's dependencies to be explored\n        for dep in graph[node]:\n            queue.append(dep)\n        # mark the node as visited\n        visited.add(node)\n        # determine the shortest path\n        if len(visited) == n:\n            path_len = len(queue)\n            if path_len < shortest_path_len:\n                shortest_path_len = path_len\n                best_path = queue\n        # explore the paths\n        for path in paths:\n            if path.split(',')[-1] == node and len(path.split(',')) >= shortest_path_len:\n                paths.remove(path)\n        # explore the node\n        for path in paths:\n            if path.split(',')[0] == node:\n                paths.remove(path)\n    # return the shortest path\n    return ', '.join(best_path) if best_path is not None else 'SHIP IT'\n"
    },
    {
        "number": 3192,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # list of the file dependencies\n    deps = stdin.split('\\n')\n    \n    # list of all files imported\n    files_imported = []\n    for dep in deps:\n        files_imported.extend(dep.split(','))\n    \n    # dictionary that maps file names to their dependencies\n    files_dependencies = dict()\n    for file_name in files_imported:\n        files_dependencies[file_name] = set()\n    \n    # dictionary that maps file names to their imported files\n    files_imports = dict()\n    for dep in deps:\n        split_dep = dep.split('\\n')\n        file_name = split_dep[0]\n        for import_file in split_dep[1:]:\n            files_dependencies[file_name].add(import_file)\n            files_imports[import_file] = file_name\n            \n    # dictionary that maps file names to their dependency cycles\n    files_cycles = dict()\n    for file_name in files_dependencies.keys():\n        if file_name not in files_cycles:\n            files_cycles[file_name] = []\n        for dependency in files_dependencies[file_name]:\n            dep_list = [file_name]\n            while dependency in files_dependencies:\n                dep_list.append(dependency)\n                dependency = files_imports[dependency]\n            if len(dep_list) > 1:\n                files_cycles[file_name].append(dep_list)\n    \n    # find the shortest cycle\n    shortest_cycle = None\n    for cycle in files_cycles.values():\n        if shortest_cycle is None or len(cycle) < len(shortest_cycle):\n            shortest_cycle = cycle\n            \n    # shortest cycle is the shortest list of dependencies\n    shortest_cycle = shortest_cycle[0]\n    for i in range(1, len(shortest_cycle)):\n        shortest_cycle[i] = shortest_cycle[i] + ','+ shortest_cycle[0]\n    \n    # remove the cycle from the dependencies\n    for file_name in files_dependencies.keys():\n        for dep in files_dependencies[file_name]:\n            if dep in shortest_cycle:\n                files_dependencies[file_name].remove(dep)\n    \n    # remove the cycle from the imports\n    for file_name in files_imports.keys():\n        if files_imports[file_name] in shortest_cycle:\n            del files_imports[file_name]\n            \n    # remove the cycle from the dependencies\n    for file_name in files_cycles.keys():\n        for dep in files_cycles[file_name]:\n            if dep in shortest_cycle:\n                files_cycles[file_name].remove(dep)\n                \n    if len(files_cycles) == 0:\n        return 'SHIP IT'\n    \n    # output the shortest cycle\n    result = ''\n    for i in range(len(shortest_cycle) - 1):\n        result += shortest_cycle[i] + ', '\n    result += shortest_cycle[0]\n    \n    return result\n-----Problem-----\nGiven a graph where each edge is in the form of a set of 2 nodes, find the shortest path from one node to another.\n\n-----Solution-----\n\nWe can treat the problem as a graph problem. We can have two classes, one for nodes and the other for edges.\n\nEach node has a set of edges and we have to find the shortest path.\n\nSo, we make a graph and then we start implementing Dijkstra\u2019s algorithm.\n\nEach node in the graph has a set of edges and also the distance from the starting node.\n\nSo, the first step is to initialize the distances of all nodes to infinite and the paths to None.\n\nThen, we take the first node and set its distance to 0 and its path to itself.\n\nThen, for each node, we iterate through all its out edges and if the distance to the source is more than the new distance, we set the distance and the path.\n\nThen, we can iterate through all the nodes and call the minHeapify function to heapify all the nodes.\n\nThen, we can pop out the minimum element from the minHeap and then for each of its out edges, if the distance to the source is more than the new distance, we set the distance and the path.\n\nAfter we finish doing this, we can return the path."
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.replace(' ', '').split('+')\n    m = int(stdin.split()[2])\n    p = int(stdin.split()[1])\n    for x in range(m):\n        for y in range(m):\n            if eval('-'.join(a) + '%' + str(m) + '=' + str(p)) == 0:\n                return x\n"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    expr = stdin.split()[0]\n    p = int(stdin.split()[1])\n    m = int(stdin.split()[2])\n\n    # step 1\n    n = len(expr)\n    expr_t = expr[1:n-1]\n    t = len(expr_t)\n    # step 2\n    expr_t_c = expr_t.count('(')\n    expr_t_c_1 = expr_t.count(')')\n    expr_t_c_2 = expr_t.count('+')\n    expr_t_c_3 = expr_t.count('-')\n    expr_t_c_4 = expr_t.count('*')\n    expr_t_c_5 = expr_t.count('x')\n\n    if expr_t_c == 0:\n        # step 3\n        expr_t_l = list(expr_t)\n        for i in range(1, n-2):\n            if expr_t[i].isdigit() == True:\n                if expr_t_l[i+1] == '+':\n                    if int(expr_t[i]) + int(expr_t[i+2]) >= m:\n                        expr_t_l[i+2] = str(int(expr_t[i]) + int(expr_t[i+2]) - m)\n                        expr_t_l[i] = str(m)\n                    else:\n                        expr_t_l[i+2] = str(int(expr_t[i]) + int(expr_t[i+2]))\n                        expr_t_l[i] = str(int(expr_t[i]) - m)\n                elif expr_t_l[i+1] == '-':\n                    if int(expr_t[i]) - int(expr_t[i+2]) < 0:\n                        expr_t_l[i+2] = str(int(expr_t[i]) - int(expr_t[i+2]) + m)\n                        expr_t_l[i] = str(m)\n                    else:\n                        expr_t_l[i+2] = str(int(expr_t[i]) - int(expr_t[i+2]))\n                        expr_t_l[i] = str(int(expr_t[i]) - m)\n                elif expr_t_l[i+1] == '*':\n                    if int(expr_t[i]) * int(expr_t[i+2]) >= m:\n                        expr_t_l[i+2] = str(int(expr_t[i]) * int(expr_t[i+2]) - m)\n                        expr_t_l[i] = str(m)\n                    else:\n                        expr_t_l[i+2] = str(int(expr_t[i]) * int(expr_t[i+2]))\n                        expr_t_l[i] = str(int(expr_t[i]) - m)\n                elif expr_t_l[i+1] == 'x':\n                    if int(expr_t[i]) * int(expr_t[i+2]) >= m:\n                        expr_t_l[i+2] = str(int(expr_t[i]) * int(expr_t[i+2]) - m)\n                        expr_t_l[i] = str(m)\n                    else:\n                        expr_t_l[i+2] = str(int(expr_t[i]) * int(expr_t[i+2]))\n                        expr_t_l[i] = str(int(expr_t[i]) - m)\n            elif expr_t_l[i] == '+' or expr_t_l[i] == '-' or expr_t_l[i] == '*' or expr_t_l[i] == 'x':\n                if expr_t_l[i+1] == '(':\n                    if expr_t_l[i] == '+':\n                        if int(expr_t[i]) + int(expr_t[i+1]) >= m:\n                            expr_t_l[i+1] = str(int(expr_t[i]) + int(expr_t[i+1]) - m)\n                            expr_t_l[i] = str(m)\n                        else:\n                            expr_t_l[i+1] = str(int(expr_t[i]) + int(expr_t[i+1]))\n                            expr_t_l[i] = str(int(expr_t[i]) - m)\n                    elif expr_t_l[i] == '-':\n                        if int(expr_t[i]) - int(expr_t[i+1]) < 0:\n                            expr_t_l[i+1] = str(int(expr_t[i]) - int(expr_t[i+1]) + m)\n                            expr_t_l[i] = str(m)\n                        else:\n                            expr_t_l[i+1] = str(int(expr_t[i]) - int(expr_t[i+1]))\n                            expr_t_l[i] = str(int(expr_t[i]) - m)\n                    elif expr_t_l[i] == '*':\n                        if int(expr_t[i]) * int(expr_t[i+1]) >= m:\n                            expr_t_l[i+1] = str(int(expr_t[i]) * int(expr_t[i+1]) - m)\n                            expr_t_l[i] = str(m)\n                        else:\n                            expr_t_l[i+1] = str(int(expr_t[i]) * int(expr_t[i+1]))\n                            expr_t_l[i] = str(int(expr_t[i]) - m)\n                    elif expr_t_l[i] == 'x':\n                        if int(expr_t[i]) * int(expr_t[i+1]) >= m:\n                            expr_t_l[i+1] = str(int(expr_t[i]) * int(expr_t[i+1]) - m)\n                            expr_t_l["
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.split()\n    p, m = int(a[1]), int(a[2])\n    q = int(a[0])\n    if p == 0:\n        return q\n    elif p == 1:\n        return 1\n    elif p == 2:\n        return 2\n    elif p == 3:\n        return 3\n    else:\n        tmp = p\n        if m % p!= 0:\n            while True:\n                if m % p == 0:\n                    break\n                p += tmp\n                if m % p == 0:\n                    break\n        return int(m / p)\n"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    expr = stdin.split('\\n')[0].split('+')\n    expr = list(map(lambda x: x.split('x'), expr))\n\n    for i in range(len(expr)):\n        expr[i][0] = int(expr[i][0])\n        expr[i][1] = int(expr[i][1])\n\n    remainder = int(stdin.split('\\n')[1].split(' ')[1])\n    m = int(stdin.split('\\n')[1].split(' ')[2])\n\n    # print(expr)\n    # print(remainder)\n    # print(m)\n\n    remainder_index = 0\n\n    for i in range(len(expr)):\n        remainder = remainder - expr[i][0]*expr[i][1]\n        if remainder == remainder_index:\n            remainder_index = remainder\n            continue\n\n        while(remainder >= m):\n            remainder = remainder - m\n            if remainder == remainder_index:\n                remainder_index = remainder\n                break\n\n            remainder = remainder + expr[i][0]*expr[i][1]\n\n        remainder_index = remainder\n\n    # print(remainder_index)\n    return str(remainder_index)\n"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    exp = stdin.split()\n    print(exp)\n    a, b = int(exp[0]), int(exp[1])\n    # print(a,b)\n    op = []\n    for i in exp[2]:\n        if i.isdigit():\n            op.append(int(i))\n        elif i == \"x\" or i == \"X\":\n            op.append(0)\n        elif i == \"+\" or i == \"-\" or i == \"*\":\n            op.append(i)\n    # print(op)\n    op = deque(op)\n    stack = []\n    while len(op)!= 0:\n        if op.popleft() == \"x\" or op.popleft() == \"X\":\n            stack.append(0)\n        elif op.popleft() == \"+\" or op.popleft() == \"-\" or op.popleft() == \"*\":\n            b, a = stack.pop(), stack.pop()\n            if op.popleft() == \"+\":\n                stack.append(a + b)\n            elif op.popleft() == \"-\":\n                stack.append(a - b)\n            else:\n                stack.append(a * b)\n        else:\n            stack.append(op.popleft())\n    print(stack)\n    # print(stack.index(a))\n    return str(stack.index(a))"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(expr: str, var: str, val: int) -> int:\n        x = val\n        while x >= 0:\n            if x % val == expr.find(var):\n                return x\n            x += 1\n        return -1\n    A, P, M = stdin.split()\n    p = int(P)\n    m = int(M)\n    expr = A\n    while \"(\" in expr:\n        first_open = expr.find(\"(\")\n        expr = expr[:first_open] + str(get_value(expr, \")\", m)) + expr[first_open + 1:]\n    while \")\" in expr:\n        first_close = expr.find(\")\")\n        expr = expr[:first_close] + str(get_value(expr, \"x\", m)) + expr[first_close + 1:]\n    print(expr)\n    return expr"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n\n    # Get input\n    expression = stdin\n    p = int(stdin[0])\n    m = int(stdin[1])\n\n    # Split the expression into tokens\n    tokens = []\n    current_token = \"\"\n    for c in expression:\n        if c == \"+\" or c == \"-\" or c == \"*\" or c == \"(\" or c == \")\":\n            if len(current_token) > 0:\n                tokens.append(current_token)\n                current_token = \"\"\n            tokens.append(c)\n        elif c.isdigit():\n            current_token += c\n        else:\n            current_token += c\n    if len(current_token) > 0:\n        tokens.append(current_token)\n    tokens = [t for t in tokens if len(t) > 0]\n\n    # Parse the tokens\n    expr = Expression(tokens)\n    print(expr)\n\n    # Get the solution\n    s = expr.solve(p, m)\n    print(s)\n\n\ndef"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a = list(stdin.split())\n    p = int(a[1])\n    m = int(a[2])\n    var = 1\n    result = 0\n    # A is the expression, var is the variable, a_prime is the variable multiplied\n    for a_prime in a[0].split('+'):\n        if a_prime.count('*') > 0:\n            var *= int(a_prime[0:a_prime.index('*')])\n        else:\n            var *= int(a_prime)\n    # Example 1, + should go first\n    # var = 2*x + 1 = 4*x + 1\n    var += 1\n    while True:\n        # A % m = A - (A // m) * m\n        result = (var % m) - (var // m) * m\n        if result == p:\n            return str(result // var)\n        if result < 0:\n            result += m\n        var += 1\n    return str(result)\n"
    },
    {
        "number": 3193,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    exp = stdin.split()[0]\n    a, p, m = stdin.split()[1:]\n    a, p, m = int(a), int(p), int(m)\n    return str(a // (m - 1) * (m - 1) + p - (a // (m - 1)) * (m - 1) - p)\n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = stdin.split(' ')\n    arr = []\n    for i in range(int(n)):\n        arr.append(stdin.split(' '))\n    return \"yes\" if t < min(arr[0][0], arr[0][1]) or t < min(arr[1][0], arr[1][1]) else \"no\"\n\nprint(solution(input()))\n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    finds if it is possible to take all the pictures in 1 day\n    \"\"\"\n    # cast the input\n    data = list(map(int, stdin.split('\\n')[:2]))\n    t = data[1]\n    photos = []\n    for line in stdin.split('\\n')[2:]:\n        photos.append(list(map(int, line.split())))\n\n    photos = sorted(photos, key=lambda x: x[0])\n    # do this for each photo\n    for photo in photos:\n        if photo[1] > t:\n            return 'no'\n        elif t % photo[1] == 0:\n            t = t - photo[1]\n        else:\n            return 'no'\n\n    return 'yes'"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, t = [int(x) for x in stdin.split()]\n    A = [[int(x) for x in stdin.split()] for _ in range(n)]\n    if n < 1 or n > 10e4 or t < 1 or t > 10e5:\n        return 'no'\n    A.sort()\n    maxs = 0\n    if n == 1:\n        return 'yes'\n    for x, y in A:\n        if x + t <= y:\n            return 'no'\n        if x > maxs:\n            maxs = x\n    return 'yes'\n\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, t = [int(i) for i in stdin.split('\\n')[:2]]\n    times = [int(i) for i in stdin.split('\\n')[2:] if int(i.split(' ')[1]) <= t]\n    times.sort()\n    if not times: return 'yes'\n    return 'yes' if sum(times[:n]) < t else 'no'\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    import sys\n    sys.setrecursionlimit(3000)\n    input = stdin.split(\"\\n\")\n    size = [int(x) for x in input[0].split()]\n    n = size[0]\n    t = size[1]\n    index_a = 0\n    index_b = 0\n    for i in range(n):\n        info = input[i+1].split()\n        a = [int(x) for x in info]\n        index_a = a[0]\n        index_b = a[1]\n        #print(index_a, index_b)\n    if(t < index_a):\n        return 'no'\n    else:\n        return 'yes'\n        \n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 2 10\n   ... 1 15\n   ... 0 20\n   ... ''')\n    'yes'\n    >>> solution('''\n   ... 2 10\n   ... 1 15\n   ... 0 20\n   ... 3 10\n   ... 1 15\n   ... 0 20\n   ... ''')\n    'no'\n    >>> solution('''\n   ... 2 10\n   ... 1 15\n   ... 0 20\n   ... ''')\n    'yes'\n    \"\"\"\n   ...\n    pass\n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve problem.\"\"\"\n    n, t = [int(i) for i in stdin.split()]\n    arr = [int(i) for i in stdin.split()]\n    arr.sort(reverse=True)\n    for i in range(n):\n        if arr[i] + t > arr[i + 1]:\n            return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds if the input can be solved by a single day.\n\n    Args:\n        stdin (str): input string\n\n    Returns:\n        str: yes or no\n    \"\"\"\n    times = [tuple(map(int, line.strip().split())) for line in stdin.splitlines()]\n    times.sort(key=lambda t: t[0])\n    taken = []\n\n    for start, end in times:\n        if start < taken[-1][1]:\n            return 'no'\n        taken.append((start, end))\n    return 'yes'\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'yes' if it is possible to take all the pictures\n    in time. Otherwise return 'no'.\n\n    >>> solution('2 10\\n1 15\\n0 20')\n    'yes'\n    >>> solution('2 10\\n5 20\\n0 15')\n    'no'\n    \"\"\"\n    stdin = stdin.split('\\n')\n    n = int(stdin[0].split()[0])\n    t = int(stdin[0].split()[1])\n    lines = [list(map(int, l.split())) for l in stdin[1:]]\n\n    lines.sort(key=lambda x: x[0])\n    print(lines)\n    lines.sort(key=lambda x: x[1])\n    print(lines)\n    print(lines)\n    print(lines)\n\n    for line in lines:\n        if line[0] > t:\n            return 'no'\n\n    if n == 1:\n        return 'yes'\n\n    i = 0\n    j = 1\n    while j < n:\n        if lines[i][0] > lines[j][0] + t:\n            return 'no'\n        i = j\n        j += 1\n\n    return 'yes'\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return str(result)\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://codeforces.com/problemset/problem/1069/A\"\"\"\n    T_g, T_y, T_r = [int(i) for i in stdin.split()]\n    n = int(stdin)\n    observations = [tuple(int(i) for i in stdin.split()[1:]) for _ in range(n)]\n    T = int(stdin)\n    T_q, c_q = [int(i) for i in stdin.split()]\n\n    # Find all possible values of T\n    result = 0\n    for i in range(T_q):\n        for j in range(T):\n            if j + T_g + T_y + T_r == i:\n                result += 1\n    return str(result / (T_q * T * n))\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = [int(i) for i in stdin.split()]\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append([int(i) for i in stdin.split()])\n    l.sort()\n    s = 0\n    e = 0\n    g = 0\n    for i in range(n):\n        e = l[i][0]\n        if l[i][1] == \"green\":\n            s = e\n        elif l[i][1] == \"yellow\":\n            g += 1\n        else:\n            g -= 1\n        if l[i][1] == \"green\" and g == 0:\n            print(\"{:.3f}\".format(0.5**((e-s)//T_r)))\n            break\n    else:\n        print(\"{:.3f}\".format(0.5**((l[n-1][0]-l[0][0])//T_r)))\n    return \"\"\n\nT = int(input())\nprint(solution(input()))"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''https://www.algoexpert.io/questions/Traffic%20Light'''\n\n    # Step 1: Get input and initialise variables\n    # O(n)\n    T_g, T_y, T_r = [int(val) for val in stdin.split()]\n    n = int(input())\n    light_list = [int(input()) for _ in range(n)]\n\n    # Step 2: Iterate through observations of the traffic light\n    # O(n)\n    for i in range(1, n):\n        # Step 2.1: Get observation\n        # O(1)\n        observation = light_list[i]\n        # Step 2.2: Process observation\n        # O(3)\n        if observation[1] == 'green':\n            T_g -= observation[0]\n        elif observation[1] == 'yellow':\n            T_y -= observation[0]\n        else:\n            T_r -= observation[0]\n        # Step 2.3: Add observation to list\n        # O(1)\n        light_list[i] = [T_g, T_y, T_r]\n\n    # Step 3: Compute probability\n    # O(1)\n    p = 1\n    for i in range(n):\n        if light_list[i][2] == 0:\n            continue\n        p *= ((light_list[i][0] / light_list[i][2]) * (light_list[i][1] / light_list[i][2]))\n    p = p * (light_list[n - 1][0] / light_list[n - 1][2]) * (light_list[n - 1][1] / light_list[n - 1][2])\n    # Step 4: Return answer\n    # O(1)\n    return str(round(p, 3))\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def probability(p1: int, p2: int, p3: int, t1: int, t2: int, t3: int, t4: int, t5: int, color4: int, color5: int) -> int:\n        t0 = 0\n        t1_green = t1\n        t2_green = t2\n        t3_red = t3\n        t4_red = t4\n        t5_green = t5\n        i = 0\n        while i < n:\n            if t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red > 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t3_red * t4_red * t5_green\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t3_red = max(0, t3_red - t3)\n                t4_red = max(0, t4_red - t4)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green == 0 and t2_green == 0 and t3_red > 0 and t4_red > 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t3_red * t4_red * t5_green\n                t3_red = max(0, t3_red - t3)\n                t4_red = max(0, t4_red - t4)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green > 0 and t2_green > 0 and t3_red == 0 and t4_red > 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t4_red * t5_green\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t4_red = max(0, t4_red - t4)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red == 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t3_red * t5_green\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t3_red = max(0, t3_red - t3)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red > 0 and t5_green == 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t3_red * t4_red\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t3_red = max(0, t3_red - t3)\n                t4_red = max(0, t4_red - t4)\n            elif t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red > 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t3_red * t4_red * t5_green\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t3_red = max(0, t3_red - t3)\n                t4_red = max(0, t4_red - t4)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green == 0 and t2_green == 0 and t3_red == 0 and t4_red > 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t4_red * t5_green\n                t4_red = max(0, t4_red - t4)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green > 0 and t2_green > 0 and t3_red == 0 and t4_red == 0 and t5_green > 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t5_green\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t5_green = max(0, t5_green - t5)\n            elif t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red == 0 and t5_green == 0:\n                t0 += p1 * p2 * p3 * t1_green * t2_green * t3_red\n                t1_green = max(0, t1_green - t1)\n                t2_green = max(0, t2_green - t2)\n                t3_red = max(0, t3_red - t3)\n            elif t1_green > 0 and t2_green > 0 and t3_red > 0 and t4_red > 0 and t5_"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    G = list(map(int, stdin.split(\"\\n\")[0].split(\" \")))\n    N = int(stdin.split(\"\\n\")[1])\n    t = 0\n    colors = []\n    for _ in range(N):\n        curr = list(map(int, stdin.split(\"\\n\")[_].split(\" \")))\n        colors.append([t] + curr)\n        t += curr[0]\n    colors.sort()\n    #print(colors)\n    T, color = list(map(int, stdin.split(\"\\n\")[-1].split(\" \")))\n\n    #print(T)\n    #print(color)\n    #print(colors)\n\n    possible_T = []\n    for i in range(N):\n        if colors[i][1] == color:\n            possible_T.append(colors[i][0] - colors[i - 1][0])\n    \n    possible_T.sort()\n    \n    count = 0\n    for i in range(len(possible_T)):\n        if possible_T[i] <= T:\n            count += 1\n    \n    return 1 - count/len(possible_T)\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets probability of lights being green at time t\"\"\"\n    T_g, T_y, T_r, n = list(map(int, stdin.split()))\n    G = T_g*T_r + T_y*T_g + T_g*T_y + T_r\n    if G == 0:\n        return f'0.0'\n    if T_g == 0:\n        return f'0.0'\n    if T_y == 0:\n        return f'1.0'\n    if T_r == 0:\n        return f'0.0'\n    s = 0\n    i = 0\n    for _ in range(n):\n        t, c = list(map(int, stdin.split()))\n        if t > i:\n            s += (t-i)/G\n        i = t\n        if c == 0:\n            c = 'green'\n        elif c == 1:\n            c = 'yellow'\n        elif c == 2:\n            c ='red'\n        if c == 'green':\n            G += T_r\n        elif c == 'yellow':\n            G += T_g\n        else:\n            G += T_y\n    s += 1\n    return f'{s/n}'\n\n\ndef"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = [int(c) for c in stdin.split()]\n    n = int(stdin.split()[0])\n    e_g = 1\n    e_y = 1\n    e_r = 1\n    for i in range(n):\n        t, c = [int(c) for c in stdin.split()]\n        e_g *= t*(T_g-t)\n        e_y *= t*(T_y-t)\n        e_r *= t*(T_r-t)\n    e_g = e_g/(T_g*T_y*T_r)\n    e_y = e_y/(T_g*T_y*T_r)\n    e_r = e_r/(T_g*T_y*T_r)\n    return str(e_g)+\" \"+str(e_y)+\" \"+str(e_r)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"4 4 4\\n3\\n2 green\\n18 yellow\\n34 red\\n5 green\")\n    '0.25'\n    '''\n    # Parse input\n    timing = list(map(int, stdin.split()))\n    n = timing[0]\n    T_g, T_y, T_r = timing[1:]\n\n    # Calculate probability of correct light\n    total_prob = 0\n    for i in range(1, n + 1):\n        duration = list(map(int, stdin.split()))\n        t, c = duration[0], duration[1]\n        \n        # Determine next time to check, and next light color\n        next_t = t if t < t_q else t_q\n        next_c = c if t < t_q else c_q\n\n        # Calculate probability of correct light\n        total_prob += 0 if c == next_c else 1 / (T_r + T_y + T_g)\n        t_q = t + (T_g if c == 'green' else T_y if c == 'yellow' else T_r)\n        c_q = next_c\n    \n    return f'{total_prob:.3f}'\n"
    },
    {
        "number": 3195,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    T, n = list(map(int, stdin.split(\"\\n\")[0].split()))\n    T_g, T_y, T_r = T, T, T\n    history = {}\n    probability = 1\n    for line in stdin.split(\"\\n\")[1:]:\n        t, c = map(int, line.split())\n        history[t] = c\n        if c == 1:\n            T_g -= t\n            T_r += t\n            probability *= 0.5\n        elif c == 2:\n            T_y -= t\n            T_g += t\n            probability *= 0.5\n        elif c == 3:\n            T_r -= t\n            T_y += t\n            probability *= 0.5\n        elif c == 0:\n            T_g = T_y = T_r = T\n    t_q, c_q = list(map(int, stdin.split(\"\\n\")[-1].split()))\n    if t_q == 0:\n        if history[0] == 1:\n            return probability\n        elif history[0] == 2:\n            return 1 - probability\n    else:\n        if c_q == 1:\n            return probability * T_r / T_g\n        elif c_q == 2:\n            return probability * T_y / T_g\n        elif c_q == 3:\n            return probability * T_g / T_g\n        elif c_q == 0:\n            return probability\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    n, m = [int(x) for x in stdin.split()]\n    \n    count = 0\n    \n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            for k in range(1, m):\n                for l in range(k+1, m+1):\n                    if (j, l)!= (i, k):\n                        count += 1\n    \n    return count\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return '4'\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(n) for n in stdin.split('\\n')[0].split()]\n    roads = [[int(n) for n in stdin.split('\\n')[m].split()] for m in range(1, M + 1)]\n    return '{}\\n'.format(numberOfRoutes(N, roads))\n\n\ndef"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    towns = [{} for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split('\\n')[_].split(' '))\n        towns[a][b] = towns[b][a] = 1\n\n    def dfs(cur, path):\n        if cur == 2:\n            nonlocal ans\n            ans += 1\n            return\n\n        if path:\n            for i in path:\n                if not towns[i][cur]:\n                    towns[i][cur] = 1\n                    dfs(cur + 1, [j for j in path if j!= i])\n                    towns[i][cur] = 0\n\n    ans = 0\n    dfs(1, [1])\n    if ans > 9:\n        print('inf')\n    else:\n        print(ans)\n\n\ndef"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the answer to the problem\"\"\"\n    return \"\"\n\ndef"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the total number of distinct routes that can be set on a single line.\n\n    :param stdin:\n    :return:\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3196,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(n)]\n    for road in roads:\n        graph[road[0] - 1].append(road[1] - 1)\n        graph[road[1] - 1].append(road[0] - 1)\n    dp = [[0] * n] * n\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(n):\n            if dp[i][j]:\n                for k in graph[j]:\n                    dp[i][k] = 1\n    for dp_row in dp:\n        print(sum(dp_row))\n    return\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(' '))\n    nums = [int(x) for x in stdin.split('\\n')[1:]]\n    dp = [[0]*k for _ in range(n)]\n    dp[0][nums[0]] = 1\n    for i in range(1, n):\n        for j in range(k):\n            if j - nums[i] >= 0:\n                dp[i][j] += dp[i-1][j-nums[i]]\n            if j + nums[i] <= k-1:\n                dp[i][j] += dp[i-1][j+nums[i]]\n    return dp[-1][k-1]\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # \uc0ac\ub78c \uc218(n)\uacfc \ud2b9\uc815 \uc218(k)\n    n, k = map(int, stdin.split(' '))\n    # k\uc640 n\uc758 \ud2b9\uc815 \uc218\ub97c \ub9ac\uc2a4\ud2b8\uc5d0 \uc800\uc7a5\n    arr = list(map(int, stdin.split(' ')))\n    # n\uac1c\uc758 \uc0ac\ub78c \uc911\uc5d0 \ucd5c\ub300 \uac12\uc758 \uc778\ub371\uc2a4 \ucc3e\uae30\n    max_idx = arr.index(max(arr))\n    # \ub9ac\uc2a4\ud2b8 \uc911\uc5d0\uc11c \ucd5c\ub300 \uac12\uc744 \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \uc218\ub4e4\ub9cc \uc774\uc6a9\ud560 \uc218 \uc788\uc74c.\n    return n - max_idx"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\ndef"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\".join(stdin.split())\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    if __name__ == \"__main__\":\n        stdin = open(\n            \"/home/andrii/Documents/koduv/algoritm-i-sdin-ili-sdkalin-for-daniil/vstup-v-2.txt\",\n            \"r\",\n        )\n\n    n, k = list(map(int, stdin.readline().split()))\n    x = list(map(int, stdin.readline().split()))\n    '''\n    n, k = list(map(int, stdin.readline().split()))\n    x = list(map(int, stdin.readline().split()))\n\n    result = 0\n    for i in range(k):\n        # \u0437\u0430\u0445\u043e\u0434\u0438\u043c \u043d\u0430 \u043f\u043e\u0438\u0441\u043a \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u044e\u0449\u0435\u0433\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438 \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u0435\u0433\u043e \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430\n        # \u043f\u0440\u0438 \u044d\u0442\u043e\u043c \u0441\u043f\u0438\u0441\u043e\u043a \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u043a\u0430\u043a \u043f\u0435\u0440\u0435\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0439\n        # \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043c\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043d\u0430 \u0432\u044b\u0445\u043e\u0434\u0435 \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0446\u0438\u0444\u0440\u044b,\n        # \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0443\u044e \u0438\u0437 \u0438\u0445 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430\n        if max(x) - min(x) < k - i:\n            result = max(result, len(x))\n            x.pop(x.index(max(x)))\n        else:\n            x.pop(x.index(min(x)))\n    return result\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem 3\"\"\"\n    n, k = list(map(int, stdin.split(\" \")))\n    participants = [int(x) for x in stdin.split(\" \")]\n    participants = [x for x in sorted(participants) if x < k]\n\n    return n - len(participants)"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3197,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5\n   ... hoose\n   ... hose\n   ... nose\n   ... noises\n   ... noise''')\n    hoose\n    noises\n    noise\n    >>> solution('''4\n   ... hose\n   ... hoose\n   ... oose\n   ... moose''')\n    hoose\n    moose\n    >>> solution('''5\n   ... hoose\n   ... hose\n   ... nose\n   ... noises\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... nois\n   ... nois\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ... noise\n   ..."
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\nhoose\\nhose\\nnoise\\nnose\\nnoise\")\n    'hoose\\nnoise'\n    \"\"\"\n\n    words = []\n\n    for line in stdin.split(\"\\n\"):\n        if line:\n            words.append(line)\n\n    dictionary = set(words)\n\n    typos = set()\n    for word in words:\n        for w in dictionary:\n            if word!= w:\n                if len(word) == len(w) - 1:\n                    typos.add(word)\n                    break\n\n    if typos:\n        return \" \".join(typos)\n    else:\n        return \"NO TYPOS\"\n\n\ndef"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    time: O(nlogn + n^2)\n    space: O(n)\n    '''\n    n = int(stdin.readline().strip())\n    word_list = sorted(set(stdin.readline().strip() for _ in range(n)))\n    typos = []\n    for word in word_list:\n        for i in range(len(word)):\n            typos.append(word[:i] + word[i+1:])\n    if len(typos) == 0:\n        print('NO TYPOS')\n    else:\n        print('\\n'.join(typos))\n\n\ndef"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find typos in dictionary.\"\"\"\n    # Divide words into two sets.\n    dictionary = set(stdin.split())\n    typos = []\n\n    # For each word, check if it is a typo.\n    for word in dictionary:\n        if set(word) - set(word[:i] + word[i + 1:] for i in range(len(word))) == set():\n            typos.append(word)\n\n    # If there are no typos, output NO TYPOS.\n    if len(typos) == 0:\n        print(\"NO TYPOS\")\n    # Otherwise, print them out.\n    else:\n        print(*typos, sep=\"\\n\")\n\n    return \"\""
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the list of words in the dictionary that are typos.\"\"\"\n    # key: str, value: list[str]\n    dic = {}\n    for word in stdin.splitlines():\n        # Create a set of distinct words from the word.\n        distinct_words = set(word)\n        # If the set of distinct words isn't in the dictionary yet, add it.\n        if distinct_words not in dic.keys():\n            dic[distinct_words] = []\n        # If it's already in the dictionary, add the word to the list.\n        dic[distinct_words].append(word)\n\n    # key: str, value: list[str]\n    typos = {}\n    # For each distinct word in the dictionary, check if it's a typos by\n    # removing a character from each word.\n    for distinct_word in dic.keys():\n        # If the word in the dictionary is not equal to the current distinct word,\n        # it's not a typos.\n        if distinct_word!= set(stdin.splitlines()[0]):\n            continue\n        # If the word is a typos, add it to typos.\n        typos[distinct_word] = []\n        # For each word in the dictionary, check if the characters in the word are\n        # equal to the current distinct word.\n        for word in dic[distinct_word]:\n            # If the word is not equal to the current distinct word, it's not a typos.\n            if word!= set(stdin.splitlines()[0]):\n                continue\n            # If the word is a typos, add it to typos.\n            typos[distinct_word].append(word)\n\n    # If there are no typos, return \"NO TYPOS\". Otherwise, return the typos.\n    if typos:\n        return \" \".join(typos.keys())\n    else:\n        return \"NO TYPOS\"\n"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    d = defaultdict(list)\n    for word in words:\n        d[word[1:]] = d[word[1:]] + [word[0]]\n    for key, value in d.items():\n        if len(set(value))!= len(value):\n            print(''.join(value))\n            return key\n    return 'NO TYPOS'\n"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the words and checks if it is a typo\n    \"\"\"\n    for line in stdin.splitlines():\n        print(stdin)"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\nhoose\\nhose\\nnoise\\nnoise\")\n    hoose\\nnoises\\nnoise\n    \"\"\"\n    return \"NO TYPOS\" if len(stdin) < 2 else \"\".join(\n        x for x in stdin.split(\"\\n\")[1:] if len(x) > 1\n    )\n"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    \n    n=int(stdin[0])\n    dic=set()\n    for i in range(1,n+1):\n        dic.add(stdin[i])\n    \n    typos=set()\n    for word in dic:\n        typo=set()\n        for i in range(len(word)):\n            typo.add(word[:i] + word[i+1:])\n        if dic.intersection(typo)!= set():\n            typos.add(word)\n    \n    if len(typos) == 0:\n        print(\"NO TYPOS\")\n    else:\n        print(\" \".join(typos))\n        \n"
    },
    {
        "number": 3198,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Get the input and convert it into a list\n    \"\"\"\n    dictionary = stdin.split(\"\\n\")\n\n    \"\"\"\n    Iterate through the list\n    \"\"\"\n    for word in dictionary:\n        \"\"\"\n        Check if the word is a typo\n        \"\"\"\n        if word_typos(word):\n            print(word)\n\n\ndef"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    numbers = stdin.split(' ')\n    numbers = list(map(int, numbers))\n    numbers.sort()\n    # get grid size\n    grid_size = numbers[-1]\n    # build grid\n    grid = {}\n    for i in range(1, grid_size+1):\n        x = (grid_size + 1) / 2\n        grid[x] = i\n        grid_size -= 1\n    # count result\n    insecure_vaults = 0\n    secure_vaults = 0\n    super_secure_vaults = 0\n    # start from middle\n    for i in range(1, grid_size+1):\n        x = (grid_size + 1) / 2\n        if i == grid[x]:\n            continue\n        # get possible vaults\n        possible_vaults = []\n        x = (grid_size + 1) / 2\n        y = i\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        x = x + 1\n        possible_vaults.append((x, y))\n        # check if insecure\n        for j in range(len(possible_vaults)):\n            x = possible_vaults[j][0]\n            y = possible_vaults[j][1]\n            if (x, y-1) in possible_vaults or (x-1, y-1) in possible_vaults or (x+1, y-1) in possible_vaults or (x+1, y) in possible_vaults or (x+1, y+1) in possible_vaults or (x, y+1) in possible_vaults or (x-1, y+1) in possible_vaults or (x-1, y) in possible_vaults:\n                insecure_vaults += 1\n                break\n        # check if secure\n        if insecure_vaults == 0:\n            secure_vaults += 1\n        # check if super-secure\n        if insecure_vaults == 1 and secure_vaults == 1:\n            super_secure_vaults += 1\n    # output\n    print(insecure_vaults)\n    print(secure_vaults)\n    print(super_secure_vaults)\n    return''\n\n\ndef"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split(' '))\n    l = int(input())\n    count = a + 1 + b\n    print(((l - 1) * (count - 1)) + (a + b) - 2)\n    print((l - 1) * (count - 1))\n    print((l - 1) * ((count - 1) * (count - 2)) // 2)"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    A, B, L = map(int, stdin.split())\n\n    # initializing variables\n    s_vaults, s_vaults_super, s_vaults_insecure = 0, 0, 0\n    secure_vaults, secure_vaults_super, secure_vaults_insecure = 0, 0, 0\n    insecure_vaults, insecure_vaults_super, insecure_vaults_insecure = 0, 0, 0\n\n    # counting insecure vaults\n    for i in range(0, L):\n        for j in range(0, A + 1):\n            if j < B:\n                insecure_vaults += 1\n            else:\n                secure_vaults += 1\n    # counting secure vaults\n    for i in range(0, L):\n        for j in range(0, A + 1):\n            if j >= B:\n                secure_vaults_super += 1\n            else:\n                secure_vaults_insecure += 1\n    # counting super secure vaults\n    for i in range(0, L):\n        for j in range(0, A + 1):\n            if j < A:\n                s_vaults_insecure += 1\n            else:\n                s_vaults_super += 1\n\n    return f\"{s_vaults_insecure}\\n\" \\\n           f\"{s_vaults_super}\\n\" \\\n           f\"{secure_vaults_insecure}\\n\" \\\n           f\"{secure_vaults_super}\\n\" \\\n           f\"{secure_vaults_insecure + secure_vaults_super}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = [int(x) for x in stdin.split()]\n    if A == B:\n        print(A * (L + 2))\n    elif A > B:\n        print(A * (L + 1) - B)\n    else:\n        print(A * L + B)\n    return \"\""
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    L = int(stdin.split()[1])\n\n    result = 0\n    for L1 in range(A, L + 1):\n        for L2 in range(B, L + 1):\n            if L1 + L2 < A + B:\n                result += 1\n            else:\n                break\n\n    return str(result)\n"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    l = int(stdin)\n    return (a + b) * (l + 1) + a + b"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l = map(int, stdin.split())\n    return str(a * b + (a + b + l) * (a + b + 1) // 2 + a + b)\n"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = [int(x) for x in stdin.split(' ')]\n    insecure = 0\n    secure = 0\n    super_secure = 0\n    vaults = ((i, j) for i in range(1, L + 1) for j in range(A, B + 1))\n    for i, j in vaults:\n        if i == 0 and j == A or i == L and j == B:\n            insecure += 1\n        else:\n            if B < j < A:\n                if i + 1 < L and i - 1 >= 1 and j - 1 >= A:\n                    secure += 1\n                else:\n                    insecure += 1\n            else:\n                if i + 1 < L and i - 1 >= 1:\n                    secure += 1\n                else:\n                    insecure += 1\n\n    print(insecure)\n    print(secure)\n    print(super_secure)\n    return ''\n\nsolution(stdin)\n"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split(' '))\n    l = int(stdin)\n    insecure = 0\n    secure = 0\n    super_secure = 0\n    for i in range(1, l+1):\n        for j in range(-a, b+1):\n            if i % 2 == 0:\n                if (i - j) % 2!= 0:\n                    insecure += 1\n                else:\n                    secure += 1\n            else:\n                if (i + j) % 2 == 0:\n                    insecure += 1\n                else:\n                    secure += 1\n            super_secure += 1\n    return str(insecure) + '\\n' + str(secure) + '\\n' + str(super_secure)\n"
    },
    {
        "number": 3199,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b = [int(x) for x in stdin.split(' ')]\n    l = int(input())\n    cnt = 0\n    for i in range(l + 1):\n        for j in range(l + 1):\n            if i * (a + 1) + j * (b + 1) == l:\n                if i == 0 or j == 0:\n                    cnt += 1\n                elif i == j:\n                    cnt += 1\n                else:\n                    cnt += 2\n    print(cnt)\n    return ''\n"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the time needed to reach the end of the road\"\"\"\n    # get the number of roads\n    n = int(stdin.readline().strip())\n    # get the road lengths\n    roads = [[int(x) for x in stdin.readline().strip().split()] for _ in range(n - 1)]\n    # get the number of traffic lights\n    tl = int(stdin.readline().strip())\n    # get the traffic light times\n    times = [[int(x) for x in stdin.readline().strip().split()] for _ in range(tl)]\n\n    return str(solution2(n, roads, tl, times))\n\ndef"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.readline())\n    distances = [float(stdin.readline()) for _ in range(n - 1)]\n    greens = [int(stdin.readline()) for _ in range(n - 1)]\n    reds = [int(stdin.readline()) for _ in range(n - 1)]\n    dist = 0\n    for i in range(n - 1):\n        if i == 0:\n            dist += distances[i]\n        else:\n            dist += greens[i - 1] + distances[i - 1]\n            if i < n - 2:\n                dist += reds[i - 1] + distances[i]\n        if i == n - 2:\n            dist += greens[i] + distances[i]\n    return dist\n\nprint(solution(sys.stdin.read()))\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The maximum acceleration of the car is constant, so the solution is the longest time it takes to reach the destination.\n    \"\"\"\n    return '%.6f' % (max(sum(map(int, line.split())) / 2 for line in stdin.splitlines()))\n"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    total_time = int(stdin)\n    print(int(total_time * 1000))\n    return total_time\n"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.readline())\n    l = []\n    for i in range(n-1):\n        a, b, c = map(int, stdin.readline().split())\n        l.append([a,b,c])\n    l.sort()\n    s = 0\n    for i in range(n-1):\n        s += l[i][1] + l[i][2]\n    return s"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\"\"\"\n\nn = int(input())\n\ndef"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    times = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n    d.insert(0, 0)\n    d.append(0)\n    times.insert(0, 0)\n    times.append(0)\n\n    return str(solution_internal(n, times, d))\n\ndef"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    lines = stdin.splitlines()\n    road_length = int(lines[0])\n    traffic_lights = []\n    for i in range(1, len(lines)):\n        traffic_lights.append(list(map(int, lines[i].split())))\n\n    delta_time = float(road_length - 1) / (sum([x[0] for x in traffic_lights]) / 1000)\n    return delta_time\n"
    },
    {
        "number": 3200,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    data = list(map(lambda x: tuple(map(int, x.split())), input_data[1:]))\n    data.sort()\n    best = n - 1\n    for i in range(n - 2):\n        best = min(best, data[i][0] + data[i + 1][0] + data[i + 2][0] - data[i + 1][1] - data[i + 2][1])\n    return str(best)"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"2 3 1 5\\n1 2\\n\")\n    '1\\n3\\n2\\n'\n    >>> solution(\"2 4 2 3\\n1 3 1\\n\")\n    '1\\n1\\n0\\n2\\n'\n    \"\"\"\n    N, K, B, M = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()))[1:]\n    B = 2 ** B\n    M = 2 ** M\n    result = [0] * K\n    for i in range(K):\n        value = 0\n        for j in range(N):\n            if numbers[j] > i:\n                value += B ** (N - j - 1) * numbers[j]\n        result[i] = value % M\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    n, k, b, m = list(map(int, stdin.split()))\n    lst = list(map(int, stdin.split()))\n    \n    l = 2**n\n    M = 10**9 + 7\n    \n    nums = [0] * l\n    for i in lst:\n        nums[i] = 1\n    \n    res = []\n    \n    for i in range(l):\n        s = nums[i]\n        h = s * b % m\n        res.append(h)\n    \n    # \u51fa\u529b\u7528\u306e\u30ea\u30b9\u30c8\n    output = []\n    \n    for i in range(k):\n        # \u81ea\u5206\u81ea\u8eab\u3068\u306e\u5dee\u304cK\u4ee5\u4e0a\u306e\u5834\u5408\u306f\u6b21\u306e\u8db3\u3057\u305f\u5024\u3092\u51fa\u529b\n        if res[i] - res[i+1] >= k:\n            output.append(res[i+1])\n        # \u81ea\u5206\u81ea\u8eab\u3068\u306e\u5dee\u304cK\u672a\u6e80\u306e\u5834\u5408\u306f\u524d\u306e\u8db3\u3057\u305f\u5024\u3092\u51fa\u529b\n        else:\n            output.append(res[i])\n    \n    return '\\n'.join(list(map(str, output)))"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find hash value for all possible subsequences\"\"\"\n    n, k, b, m = map(int, stdin.split())\n    a = map(int, stdin.split())\n    print(a)\n    res = 0\n    for num in a:\n        res = (res * b + num) % m\n    print(res)\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Hash of a subsequence\"\"\"\n    N, K, B, M = map(int, stdin.split(' '))\n    A = list(map(int, stdin.split(' ')))\n\n    return '\\n'.join(\n        str(\n            (\n                (A[i] * (B ** (N - i - 1)) + A[i + 1] * (B ** (N - i - 2)) +\n                 A[i + 2] * (B ** (N - i - 3)) + A[i + 3] * (B ** (N - i - 4))\n                 + A[i + 4] * (B ** (N - i - 5)) + A[i + 5] * (B ** (N - i - 6))\n                 + A[i + 6] * (B ** (N - i - 7))\n                 ) % M\n            )\n            for i in range(K)\n        )\n    )\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(NlogN)\n    Space Complexity: O(N)\n    \"\"\"\n    n, k, b, m = list(map(int, stdin.split(' ')))\n    a = list(map(int, stdin.split(' ')))\n    k_subsequences = list(range(k))\n    k_subsequences.sort(key=lambda i: sum(a[i]))\n    subsequences = [a[i:j] for i, j in zip([0] + k_subsequences, k_subsequences + [len(a)])]\n    hash_subsequences = [[sum(b ** (i + 1) * j for i, j in enumerate(subsequence)) % m for subsequence in subsequences]]\n    for j in range(1, n - k + 1):\n        new_hash_subsequences = []\n        for hash_subsequence in hash_subsequences:\n            for i, subsequence in enumerate(subsequences):\n                if i + 1 < j:\n                    hash_subsequence.append(hash_subsequence[-1] + hash_subsequence[-2] + subsequence[j - i - 1] * b)\n                else:\n                    hash_subsequence.append(hash_subsequence[-1] + hash_subsequence[-2])\n            new_hash_subsequences.append(hash_subsequence)\n        hash_subsequences = new_hash_subsequences\n    return '\\n'.join([' '.join([str(num) for num in hash_subsequence]) for hash_subsequence in hash_subsequences])\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, k, b, m = list(map(int, stdin.split('\\n')[0].split()))\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    subsets = []\n\n    def gen_subsets(arr, subsets, pos):\n        if pos == len(arr):\n            subsets.append(arr)\n            return\n\n        gen_subsets(arr, subsets, pos + 1)\n\n        for i in range(pos, len(arr)):\n            arr[i], arr[pos] = arr[pos], arr[i]\n            gen_subsets(arr, subsets, pos + 1)\n            arr[i], arr[pos] = arr[pos], arr[i]\n\n    gen_subsets(arr, subsets, 0)\n\n    subsets = [list(map(lambda x: x % m, map(pow, subset, itertools.repeat(b)))) for subset in subsets]\n\n    k = len(subsets)\n    subsets = list(map(lambda x: sum(x) % m, subsets))\n    subsets = [subsets[i] for i in range(k)]\n\n    m = pow(m, k)\n    subsets = list(map(lambda x: (x * pow(b, k)) % m, subsets))\n\n    ans = []\n    for subset in subsets:\n        if subset not in ans:\n            ans.append(subset)\n\n    for a in ans:\n        print(a)\n    '''\n    # this solution is too slow to run\n    n, k, b, m = list(map(int, stdin.split('\\n')[0].split()))\n    arr = list(map(int, stdin.split('\\n')[1].split()))\n\n    subsets = []\n\n    for i in range(len(arr) + 1):\n        subsets.append(list(map(int, itertools.combinations(arr, i))))\n\n    subsets = list(filter(lambda x: len(x) == k, subsets))\n\n    ans = []\n    for subset in subsets:\n        subset = list(map(lambda x: x % m, map(pow, subset, itertools.repeat(b))))\n        subset = sum(subset) % m\n        if subset not in ans:\n            ans.append(subset)\n\n    print('\\n'.join(list(map(str, ans))))\n\ndef"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return None\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, b, m = map(int, stdin.split('\\n')[0].split())\n    a = [int(i) for i in stdin.split('\\n')[1].split()]\n    res = ''\n    h = [0] * (2 ** n)\n    for i in range(2 ** n):\n        val = 0\n        j = i\n        while j > 0:\n            val = (val * b + a[j % n]) % m\n            j //= 2\n        h[i] = val\n    for i in range(k):\n        res += str(h[i]) + '\\n'\n    return res\n"
    },
    {
        "number": 3201,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = [int(x) for x in stdin.split()]\n    A = [int(x) for x in stdin.split()]\n    s = set(A)\n    H = {}\n    for a in A:\n        B_ = N - 1\n        M_ = B**(B_)\n        h_ = (a * M_) % M\n        H[a] = h_\n        for i in range(1, B_):\n            M_ = (B**(B_ - i - 1)) * (M_ // B**i)\n            h_ = (a * M_ + h_) % M\n            H[a] = h_\n    result = [0] * K\n    for a in s:\n        B_ = N - 1\n        M_ = B ** (B_)\n        h_ = (a * M_) % M\n        result[0] = h_\n        for i in range(1, B_):\n            M_ = (B ** (B_ - i - 1)) * (M_ // B ** i)\n            h_ = (a * M_ + h_) % M\n            result[i] = h_\n    print('\\n'.join([str(r) for r in result]))\n"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    # find a solution\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] == k:\n            count += 1\n            continue\n        if count > 1:\n            arr[i] = 0\n        elif count == 1:\n            arr[i] = k\n            count += 1\n        else:\n            arr[i] = arr[i-1]\n    \n    # count total of zeros\n    ans = 0\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            ans += 1\n        else:\n            break\n    ans += count\n\n    # return answer\n    return ans"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(n) for n in stdin.strip().split(' ')]\n    marbles = [int(n) for n in stdin.strip().split(' ')]\n    count = 0\n    for i in range(n):\n        if marbles[i] == marbles[i + 1]:\n            count += 1\n        elif marbles[i] == marbles[i - 1]:\n            count += 1\n        else:\n            count = 0\n        if count >= k:\n            break\n    return i + 1 if count >= k else 'Impossible'"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(' '))\n    colors = list(map(int, stdin.split(' ')))\n    counter = 0\n    for i in range(n):\n        if colors[i] == colors[i-1] and i >= k:\n            counter += 1\n    return counter\n\nprint(solution('2 5'))\nprint(solution('5 3'))\n\n'''\nimport math\n\nn, k = map(int, input().split())\ncolors = list(map(int, input().split()))"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    N, K = [int(x) for x in stdin.split(\" \")]\n    print(N, K)\n    marbles = [int(x) for x in stdin.split(\" \")]\n    print(marbles)\n    count = 0\n    for i in range(N):\n        if marbles[i] == marbles[i + 1]:\n            count += 1\n            if count == K:\n                marbles[i] = 0\n                marbles[i + 1] = 0\n                count = 0\n    print(marbles)\n    return str(marbles.count(0))\n\ndef"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get input as list of ints\n    marbles = [int(s) for s in stdin.split(\" \")]\n    \n    # init vars\n    current = 0\n    count = 0\n    \n    # loop over input\n    for i, m in enumerate(marbles):\n        # if current is equal to marble\n        if current == m:\n            count += 1\n            # if count reaches K\n            if count == K:\n                # minus the marble\n                current -= m\n                # and increase current\n                current += 1\n                # and set count to 0\n                count = 0\n        # if current is not equal to marble\n        else:\n            # increase the count\n            count = 1\n            # set current to marble\n            current = m\n    # add last marble to count\n    count += 1\n    # if count is more than 0\n    if count > 0:\n        # return count\n        return count\n    # else\n    return 1"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(i) for i in stdin.split(\" \")]\n    color_sequence = [int(i) for i in stdin.split(\" \")]\n    return n\n"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.readline().split())\n    colors = [int(color) for color in stdin.readline().split()]\n    colors = [1 if color == K else 0 for color in colors]\n\n    count = 0\n    for i in range(len(colors)):\n        if colors[i] == 0:\n            count += 1\n        else:\n            break\n    return count\n"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimal number of marbles Mirko has to insert into the sequence before he could make all of the marbles vanish.\n\n    Args:\n        stdin (str): Input string given by the task.\n\n    Returns:\n        str: Solution string.\n    \"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split(' ')))\n    arr = list(map(int, stdin.split(' ')))\n\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] == arr[i - 1]:\n            count += 1\n            if count == k:\n                arr[i] = '*'\n                count = 0\n        else:\n            count = 0\n    return''.join(map(str, arr))\n"
    },
    {
        "number": 3202,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stones = list(map(int, stdin.split()))\n    r = 0\n    for i in range(n):\n        if stones[i] == stones[i - 1] and i > 0:\n            r += 1\n        elif stones[i]!= stones[i - 1]:\n            r += 1\n    return r - k\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the best probability of success of a mission.\"\"\"\n\n    # Get the number of missions\n    n = int(stdin.readline())\n\n    # Initialise the mission probability matrix\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, stdin.readline().split())))\n\n    # Get the maximum probability\n    return str(max([\n        max(\n            [\n                probability for i in range(n)\n                if probability == matrix[i][j]\n            ]\n        )\n        for j in range(n)\n    ]))\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"TODO: complete solution\"\"\"\n\n    pass\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution\"\"\"\n    # get input\n    n, *lines = stdin.split('\\n')\n\n    # init counts\n    n_possible_missions = int(n)\n    n_jimmy_bond = int(n)\n    n_missions_total = len(lines)\n\n    # init a dict with the probabilities for each mission and a dict with the number of missions for each Jimmy Bond\n    probs = dict()\n    bonds = dict()\n    jimmy_bonds = dict()\n\n    # build the dicts\n    for line in lines:\n        # get the probs\n        i = 0\n        for prob in line.split():\n            prob = float(prob)\n            i += 1\n            probs[i] = prob\n            # for each mission, update the number of missions for that particular bond\n            bonds[i] = bonds.get(i, 0) + 1\n\n        # get the number of jimmy bonds\n        bond = int(line.split()[0])\n        jimmy_bonds[bond] = jimmy_bonds.get(bond, 0) + 1\n\n    # init the probability of success for each bond and its minimum probability\n    prob_success_min = 1\n    jimmy_bond_succeeded = -1\n\n    # loop over all the jimmy bonds\n    for jimmy_bond in jimmy_bonds:\n        # init the probability for that particular bond\n        prob_success = 1\n\n        # loop over all the possible missions\n        for i in range(1, n_possible_missions + 1):\n            # get the probability of success for that particular mission\n            prob_success *= probs[i]\n\n        # if the current probability of success is greater than the current minimum, update the minimum and the corresponding bond\n        if prob_success > prob_success_min:\n            prob_success_min = prob_success\n            jimmy_bond_succeeded = jimmy_bond\n\n    # return the maximum probability\n    return str(prob_success_min)\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    total_pairs, *input_lines = stdin.splitlines()\n    n = int(total_pairs)\n    probabilities = [float(line) for line in input_lines]\n    possible_perms = set(itertools.permutations(range(1, n + 1)))\n    return max(\n        (\n            sum([probabilities[i - 1] for i in perm])\n            for perm in possible_perms\n            if all(perm[j - 1] < n for j in perm)\n        )\n    ) * 100\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    # \u8f38\u5165\u7b2c\u4e00\u884c\u70ba\u7b2c\u5e7e\u7d44\u6578\u64da\n    # \u63a5\u4e0b\u4f86\u6bcf\u7d44\u6578\u64da\u7684\u7b2c\u4e00\u884c\u70ba\u7b2c\u5e7e\u7d44\u6578\u64da\u7684\u7d20\u6578\u8207\u6a19\u6e96\u5dee\n    # \u53c3\u6578\u521d\u59cb\u5316\n    n = int(stdin.split('\\n')[0])\n    f = []\n    for _ in range(n):\n        f.append(list(map(float, stdin.split('\\n')[_].split())))\n    ans = 0.0\n    for i in range(len(f[0])):\n        # \u524d\u9762\u4e00\u7d44\u6578\u64da\u7684\u7d20\u6578\u8207\u6a19\u6e96\u5dee\n        # \u5f8c\u9762\u4e00\u7d44\u6578\u64da\u7684\u7d20\u6578\u8207\u6a19\u6e96\u5dee\n        # \u56e0\u70ba\u8981\u5229\u7528\u4e0a\u4e00\u7d44\u6578\u64da\u7684\u7d20\u6578\u8207\u6a19\u6e96\u5dee\n        # \u4ee5\u53ca\u5f8c\u9762\u4e00\u7d44\u6578\u64da\u7684\u7d20\u6578\u8207\u6a19\u6e96\u5dee\n        # \u6240\u4ee5\u6bcf\u4e00\u7d44\u6578\u64da\u81f3\u5c11\u8981\u6709\u5169\u7d44\u6578\u64da\n        if i == 0:\n            f_i = f[i][0] - f[i][1]\n            f_i_t = f[i][0] + f[i][1]\n            f_t_1 = f[i + 1][0] - f[i + 1][1]\n            f_t_1_t = f[i + 1][0] + f[i + 1][1]\n        elif i == len(f[0]) - 1:\n            f_i = f[i][0] - f[i][1]\n            f_i_t = f[i][0] + f[i][1]\n            f_t_1 = f[i - 1][0] - f[i - 1][1]\n            f_t_1_t = f[i - 1][0] + f[i - 1][1]\n        else:\n            f_i = f[i][0] - f[i][1]\n            f_i_t = f[i][0] + f[i][1]\n            f_t_1 = f[i - 1][0] - f[i - 1][1]\n            f_t_1_t = f[i - 1][0] + f[i - 1][1]\n        if f_i_t * f_t_1_t > f_i_t * f_t_1:\n            ans = f_i_t * f_t_1_t / f_t_1\n        else:\n            ans = f_i_t * f_t_1_t / f_i\n    return str(ans * 100)[:6]\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the probability that all missions are successfully completed.\"\"\"\n    # Convert string to list of ints.\n    p_list = [int(i) for i in stdin.split()]\n\n    # Calculate total probability.\n    p_total = 1\n    for i in range(len(p_list)):\n        p_total *= p_list[i]\n\n    # Calculate total probability for all assignments and corresponding jimmy bond number.\n    t_list = []\n    for i in range(len(p_list)):\n        p_list_prob = 1\n        for j in range(len(p_list)):\n            if j!= i:\n                p_list_prob *= p_list[j]\n        t_list.append((p_list_prob, i + 1))\n\n    # Sort list by probabilities, and find max probability and corresponding jimmy bond number.\n    t_list = sorted(t_list, key=lambda x: x[0])\n    max_prob = t_list[-1][0]\n    t_list = sorted(t_list, key=lambda x: x[1])\n    max_jimmy_num = t_list[-1][1]\n\n    # Calculate probability of max probability and print it.\n    prob = max_prob / p_total\n    print(round(prob * 100, 6))\n\n    return str(round(prob * 100, 6))\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the probability that all missions are completed successfully\"\"\"\n    N, missions = map(int, stdin.split('\\n')[:2])\n    probabilities = map(lambda x: map(lambda y: int(y) / 100, x.split(' ')), stdin.split('\\n')[2:])\n    # total_probability = 1\n    # for i, p in enumerate(probabilities):\n    #     total_probability *= (1 - sum(p) ** N)\n    # print(total_probability * 100)\n    max_probability = 0\n    for i, p in enumerate(probabilities):\n        probability = 1\n        for j, q in enumerate(p):\n            probability *= (1 - q ** N)\n        probability *= (1 - sum(p) ** N)\n        if probability > max_probability:\n            max_probability = probability\n            # best_arrangement = [i + 1]\n        elif probability == max_probability:\n            # best_arrangement.append(i + 1)\n            pass\n    return str(max_probability * 100)\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the most likely arrangement of assignments for Bond given input from stdin.\n    \"\"\"\n    num_bonds, *probabilities = [int(x) for x in stdin.split()]\n    bond_probabilities = [0 for _ in range(num_bonds)]\n    for i in range(num_bonds):\n        for j in range(num_bonds):\n            bond_probabilities[i] += probabilities[j] / 100\n    best_probability = 0\n    best_bond = -1\n    for i in range(num_bonds):\n        if bond_probabilities[i] > best_probability:\n            best_probability = bond_probabilities[i]\n            best_bond = i\n    return str(best_probability * 100) + \"%\"\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    n = int(stdin[0])\n    # array of probabilities\n    probabilities = list(map(lambda x: float(x) / 100, stdin[1:]))\n    # list of mission numbers\n    m = list(range(1, n + 1))\n    # return an array of the cumulative product of the probabilities\n    return str(sum(map(lambda x: x * n, probabilities)))\n"
    },
    {
        "number": 3203,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    in_data = [int(num) for num in stdin.split()]\n    m = int(in_data[0])\n    n = int(in_data[1])\n    arr = [int(num) for num in stdin.split()]\n    result = 0\n    for i in range(m):\n        total = 0\n        for j in range(n):\n            total += arr[i*n+j]\n        if total > 0:\n            result += 1/n * 100\n    return str(result)[:6]\nprint(solution(stdin))"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n = int(stdin.readline())\n    arrivals = [int(line.strip()) for line in stdin]\n    arrivals = sorted(arrivals)\n    up = 0\n    for time in arrivals:\n        if up <= time:\n            up = time + 20\n        else:\n            up = time + 30\n    return up\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''The solution is only valid for the given time range, not for any value of N.\n    Since the time it takes to raise the bridge is fixed, it is not possible to have a valid solution for any value of N.\n    '''\n    def solve(T: int) -> str:\n        # Open the bridge\n        time_to_raise = 60\n        while time_to_raise < T:\n            time_to_raise += 20\n        # Calculate the waiting time\n        waiting_time = time_to_raise - T\n        # The bridge is in a state of emergency for as long as the waiting time exceeds 30 minutes\n        if waiting_time > 30 * 60:\n            return 'EMERGENCY'\n        # The bridge is in a state of emergency for as long as there are waiting boats\n        else:\n            return str(waiting_time // 20)\n    return '\\n'.join(solve(int(line)) for line in stdin.split('\\n')[1:])\nprint(solution(input()))\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    times = [int(stdin) for _ in range(n)]\n    times.sort()\n\n    bridge_unavailable = max(times) - min(times)\n\n    print(bridge_unavailable)\n    return\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    pass\n    \n    return \"\""
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, T = [int(x) for x in stdin.split()]\n    \n    arr = []\n    for _ in range(N):\n        arr.append([int(x) for x in stdin.split()])\n    \n    arr.sort(key=lambda x: x[0])\n    \n    bridge = [0]\n    start = 0\n    end = N\n    time = 0\n    while True:\n        time += arr[start][0]\n        bridge.append(time)\n        \n        if time >= T:\n            break\n        \n        start += 1\n    \n    end = N - 1\n    time = 0\n    while True:\n        time += arr[end][0]\n        bridge.append(time)\n        \n        if time >= T:\n            break\n        \n        end -= 1\n    \n    bridge.sort()\n    bridge = [x for x in bridge if x >= T]\n    bridge.append(T)\n    \n    return bridge[1] - T\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the maximum possible time for which the bridge will be unavailable for road traffic.\"\"\"\n    n = int(stdin.readline().rstrip())\n    arrival_times = list(map(int, stdin.readline().rstrip().split()))\n\n    max_bridge_time = 0\n    cur_time = 60\n    for cur_arrival_time in sorted(arrival_times):\n        if cur_arrival_time < cur_time + 20:\n            max_bridge_time += cur_time - cur_arrival_time\n            cur_time = cur_arrival_time + 20\n    return max_bridge_time\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    # sort the list by time\n    # the x[1] means its time\n    Boatlist = sorted(list(map(lambda x: [x[1], x[0]], enumerate(list(map(int, stdin.split(\"\\n\"))[:N]))))\n    )\n    \n    # variable\n    time = 0\n    boatStart = 0\n    boatEnd = 0\n    TimeBoatPass = 0\n    \n    for index in Boatlist:\n        # get boat start time\n        if index[0] > time:\n            time = index[0]\n        # get boat end time\n        if index[1] > time + 20:\n            boatEnd = index[1]\n            TimeBoatPass += (boatEnd - boatStart)\n            boatStart = boatEnd\n    \n    print(TimeBoatPass)\n    return TimeBoatPass"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Day 1: The Tyranny of the Rocket Equation\n    \"\"\"\n    pass\n    # your code here\n    # return result"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    input: str\n    output: str\n    '''\n    # Write your code here\n    pass\n    return 'Not yet implemented'\n"
    },
    {
        "number": 3204,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given the arrival times of all boats, operate the bridge such that all\n    boats can pass through without any boat waiting longer than 30 minutes.\n    What is the total amount of time during which the bridge is unavailable to\n    road traffic?\n    :param stdin: A string containing an integer and lines, each line\n    containing an integer T_i, the time at which boat i will arrive at the\n    bridge in seconds (60 <= T_i <= 10^5)\n    :return: A string containing a single integer, the total number of seconds\n    during which the bridge must be unavailable for road traffic.\n    \"\"\"\n    N = int(stdin)\n    T = [int(x) for x in stdin.strip().split()]\n\n    # Merge the input times into a sorted list of arrival times.\n    T.sort()\n    T.append(10**9 + 1)\n\n    # Partition the sorted list into 2 equal-length lists.\n    time1 = 0\n    for i in range(len(T) // 2):\n        time1 = T[2 * i]\n        time2 = T[2 * i + 1]\n    time2 = T[len(T) // 2]\n    # T_i is the time when the ith boat arrives at the bridge.\n    T = [time1, time2]\n    # print(T)\n    bridge_arrival_time = 0\n    while True:\n        bridge_arrival_time += 1\n        # print(T, bridge_arrival_time)\n        if bridge_arrival_time > 30:\n            return 0\n        if T[0] <= bridge_arrival_time < T[1]:\n            continue\n        elif T[1] <= bridge_arrival_time < T[2]:\n            bridge_arrival_time += 20\n            continue\n        elif bridge_arrival_time >= T[2]:\n            bridge_arrival_time += 20\n            continue\n        else:\n            break\n    return bridge_arrival_time - 1\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve the problem.\"\"\"\n    m, n = map(int, stdin.split())\n    pass\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n\"\"\"\n\nfrom collections import defaultdict\nfrom itertools import combinations\n\ndef"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = stdin.split(\"\\n\")[:2]\n    m, n = int(m), int(n)\n    lst = [stdin.split(\"\\n\")[i : i + n] for i in range(2, len(stdin.split(\"\\n\")), n)]\n    print(lst)\n    mem = {}\n    for l in lst:\n        a, b, c = [int(x) for x in l]\n        if a not in mem:\n            mem[a] = [b, c]\n        else:\n            mem[a][0] += b\n            mem[a][1] += c\n    for key in mem:\n        if mem[key][0]!= 0:\n            for i in range(m):\n                mem[key][1] -= mem[i][0]\n                if mem[key][1] == 0:\n                    break\n    return sum(list(mem.values()).count(0) for key in mem)\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    s = dict()\n    for _ in range(n):\n        a, b, p = map(int, stdin.split('\\n')[1].split(' '))\n        s[a] = s.get(a, 0) + p\n        s[b] = s.get(b, 0) - p\n    p = 0\n    for i in s:\n        if s[i]!= 0:\n            p += 1\n    return p\n\nprint(solution(input()))\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the least number of transactions necessary to settle all bills.\"\"\"\n    # Write your code here\n    #\n    # n = stdin.split('\\n')\n    # M = int(n[0].split(' ')[0])\n    # N = int(n[0].split(' ')[1])\n    # A = [0] * M\n    # for i in range(N):\n    #     a, b, p = int(n[i+1].split(' ')[0]), int(n[i+1].split(' ')[1]), int(n[i+1].split(' ')[2])\n    #     A[a] += p\n    #     A[b] -= p\n    # print(A)\n    return 0\n"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_parents(n):\n        res = [n]\n        while n!= parents[n]:\n            n = parents[n]\n            res.append(n)\n        return res\n    def update_parents(x, y):\n        parents[x] = y\n        for n in get_parents(x):\n            parents[n] = y\n    def unify(x, y):\n        update_parents(x, y)\n        update_parents(y, x)\n    n, m = list(map(int, stdin.readline().split()))\n    parents = [i for i in range(m)]\n    for i in range(n):\n        x, y, z = list(map(int, stdin.readline().split()))\n        unify(x, y)\n        update_parents(y, x)\n    return len(set(get_parents(parents[0])))"
    },
    {
        "number": 3205,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return str(result)"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a valid solution to the skyline problem.\n\n    Input\n        str: A single line of input, formatted as follows:\n            - An integer $N$, the number of blocks Pippa has.\n            - An integer $S$, the number of buildings in the skyline Zara made.\n            - A sequence of $N$ integers, each $h_i$, representing the heights of\n            each of the blocks.\n            - A sequence of $S$ integers, each $b_i$, representing the heights of\n            each of the buildings.\n\n    Output\n        str: A single line of output, formatted as follows:\n            - $S$ lines, each containing $N$ numbers, each number representing the\n            number of blocks used to build the building on that line.\n            - The next line, should contain $S$ numbers, each representing the blocks\n            of the input used to build the corresponding building.\n\n    Constraints\n        - 1 \\le N \\le 15\n        - 1 \\le S \\le 15\n        - 1 \\le h_ i \\le 10^9\n        - 1 \\le b_ i \\le 10^9\n        - The heights and depths are integers\n    \"\"\"\n    return ''\n"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # Write your code here and remove the next line\n    x = list(map(int, stdin.split('\\n')[0].split()))\n    y = list(map(int, stdin.split('\\n')[1].split()))\n    def backtrack(x, y, cnt):\n        if cnt == len(y):\n            return True\n        t = 0\n        for i in x:\n            if i <= y[cnt]:\n                t += 1\n            else:\n                break\n        if t == len(x):\n            return backtrack(x, y, cnt + 1)\n        else:\n            return False\n    if backtrack(x, y, 0):\n        for i in range(len(x)):\n            if x[i]!= y[i]:\n                return '-1'\n        return '\\n'.join(str(x) for x in y)\n    else:\n        return '-1'\n"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an output corresponding to a solution, or -1 if no solution\"\"\"\n    # your code here\n    return \"No solution\""
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given the input of the number of blocks and the heights of each block,\n    this function will output the minimum number of blocks needed to create\n    a the desired skyline.\n    :param stdin: str of the input\n    :return: str of the output\n    \"\"\"\n    # get the number of blocks and the heights\n    num_blocks, num_buildings = [int(x) for x in stdin.split(' ')]\n    heights = [int(x) for x in stdin.split(' ')[1:]]\n    # get the heights of the buildings\n    building_heights = [int(x) for x in stdin.split(' ')[-num_buildings:]]\n    # initialize the blocks_needed variable\n    blocks_needed = []\n    # get the number of blocks needed for each building\n    for height in building_heights:\n        blocks_needed.append(get_blocks_needed(heights, height))\n    # output the number of blocks needed for each building\n    for block_num in blocks_needed:\n        print(block_num)\n\n\ndef"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # lines = stdin.strip().split('\\n')\n    # N, S = int(lines[0].split(' ')[0]), int(lines[0].split(' ')[1])\n    # H = list(map(int, lines[1].strip().split(' ')))\n    # B = list(map(int, lines[2].strip().split(' ')))\n    #\n    # def helper(block):\n    #     # your code here\n    #     if block < 0:\n    #         return []\n    #     else:\n    #         if block == 0:\n    #             return []\n    #         else:\n    #             return [helper(block - i) + [i] for i in range(1, block + 1)]\n    #\n    # # print(helper(3))\n    #\n    # def validate(dists):\n    #     block_sum = 0\n    #     block_count = 0\n    #     for i in range(len(dists)):\n    #         block_sum += dists[i]\n    #         block_count += len(dists[i])\n    #         if block_sum < B[i] or block_count > S:\n    #             return False\n    #     return True\n    #\n    # def helper2(block):\n    #     if block < 0:\n    #         return []\n    #     else:\n    #         if block == 0:\n    #             return []\n    #         else:\n    #             return [helper2(block - i) + [i] for i in range(1, block + 1)]\n    #\n    # def solve(block):\n    #     if block < 0:\n    #         return []\n    #     else:\n    #         if block == 0:\n    #             return []\n    #         else:\n    #             return [solve(block - i) + [i] for i in range(1, block + 1)]\n    #\n    # # print(solve(3))\n    #\n    # # dists = [[1]]\n    # # print(validate(dists))\n    #\n    # # print(helper2(2))\n    #\n    # def solve2(block):\n    #     if block < 0:\n    #         return []\n    #     else:\n    #         if block == 0:\n    #             return []\n    #         else:\n    #             return [solve2(block - i) + [i] for i in range(1, block + 1)]\n    #\n    # # print(solve2(2))\n    #\n    # # for h in range(len(H)):\n    # #     dists = [helper2(H[i] - H[h]) for i in range(h)] + [helper2(H[h] - H[i]) for i in range(h + 1, N)]\n    # #     if validate(dists):\n    # #         for i in range(len(dists)):\n    # #             for j in range(len(dists[i])):\n    # #                 if dists[i][j] == 1:\n    # #                     print('1 1')\n    # #                 else:\n    # #                     print(len(dists[i]) - j)\n    # #                 print(dists[i][j], end=' ')\n    # #         print()\n    # #     else:\n    # #         print(-1)\n    #\n    # # print(H)\n    # # print(B)\n    # # for h in range(len(H)):\n    # #     dists = solve2(H[h] - H) + solve2(H[h] - H)\n    # #     if validate(dists):\n    # #         print(H[h])\n    # #         for i in range(len(dists)):\n    # #             for j in range(len(dists[i])):\n    # #                 if dists[i][j] == 1:\n    # #                     print('1 1')\n    # #                 else:\n    # #                     print(len(dists[i]) - j)\n    # #                 print(dists[i][j], end=' ')\n    # #         print()\n    # #     else:\n    # #         print(-1)\n    #\n    # dists = solve2(H[0] - H) + solve2(H[0] - H)\n    # if validate(dists):\n    #     for i in range(len(dists)):\n    #         for j in range(len(dists[i])):\n    #             if dists[i][j] == 1:\n    #                 print('1 1')\n    #             else:\n    #                 print(len(dists[i]) - j)\n    #             print(dists[i][j], end=' ')\n    #         print()\n    # else:\n    #     print(-1)\n\n    N, S = int(stdin.readline().split(' ')[0]), int(stdin.readline().split(' ')[0])\n    H = list(map(int, stdin.readline().strip().split(' ')))\n    B = list(map(int, stdin.readline().strip().split(' ')))\n\n    dists = solve(H, B)\n    if validate(dists):\n        for i in range(len(dists)):\n            for j in range(len(dists[i])):\n                if dists[i][j] == 1:\n                    print('1 1')\n                else:\n                    print(len(dists[i]) - j)\n                print(dists[i][j], end=' ')\n            print()\n    else:\n        print(-1)\n\n\ndef"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # read input\n    data = stdin.split()\n    n = int(data[0])\n    s = int(data[1])\n\n    # solve problem\n    blocks = list(map(int, data[2].split()))\n    buildings = list(map(int, data[3].split()))\n\n    buildings.sort()\n\n    # find longest building\n\n    max_height = 0\n    for i in range(len(buildings)):\n        if buildings[i] > max_height:\n            max_height = buildings[i]\n\n    # sort block heights\n    blocks.sort()\n\n    # find the number of blocks needed to build the tallest building\n    block_count = 0\n    for i in range(len(buildings)):\n        if buildings[i] > max_height:\n            block_count = i\n            break\n\n    result = []\n    for i in range(len(buildings)):\n        if i < block_count:\n            if buildings[i] > max_height:\n                if blocks[i] > max_height:\n                    result.append(\"1\")\n                    blocks[i] = max_height\n                else:\n                    result.append(\"0\")\n                    blocks[i] = max_height\n        else:\n            result.append(\"0\")\n\n    # print result\n    for i in range(len(result)):\n        print(result[i], end=\" \")\n\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an optimal solution for the skyline problem.\"\"\"\n    pass\n"
    },
    {
        "number": 3206,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the skyline from the input parameters.\n\n    Input format:\n        Line 1: Integers N and S, where N is the number of blocks and S is the number of buildings in the skyline.\n        Line 2: N integers, where each integer is the height of the blocks.\n        Line 3: S integers, where each integer is the height of the building.\n\n    Output format:\n        S integers, where each integer is the number of blocks needed for the corresponding building.\n        If no combination of the blocks can build the desired skyline then output -1.\n    \"\"\"\n    blocks, targets = map(int, stdin.split())\n\n    # 1. Pre-process the input data.\n    block_heights = list(map(int, stdin.splitlines()[1].split()))\n    building_heights = list(map(int, stdin.splitlines()[2].split()))\n\n    # 2. Create a dictionary that counts the blocks in each target.\n    target_counts = {t: building_heights.count(t) for t in targets}\n\n    # 3. Iterate over the block heights and find the largest blocks that can be stacked.\n    stackable = set(block_heights)\n    for block in block_heights:\n        stackable.intersection_update(target_counts.keys())\n        if len(stackable) == 1:\n            break\n    if len(stackable)!= 1:\n        return -1\n    # 4. Construct the answer.\n    ans = []\n    for target in targets:\n        ans.append(target_counts[target])\n    ans.append(next(iter(stackable)))\n    return''.join(map(str, ans))\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\ndef"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def triples(lst: List[str]) -> List[Tuple[int, int, int]]:\n        return [(int(lst[2*i]), int(lst[2*i+1]), lst[2*i+2]) for i in range(len(lst)//2)]\n    trips = triples(stdin.split())\n    for t in trips:\n        if t[0] < 0 or t[1] < 0 or t[2] not in [\"L\", \"D\"] or (t[2] == \"L\" and t[1] >= t[0]):\n            return \"Invalid input.\"\n    return \" \".join(map(str, [sum([abs(t[0]) for t in trips if t[2] == \"L\"]), sum([abs(t[0]) for t in trips if t[2] == \"D\"])]))"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, k, l = map(int, stdin.split('\\n')[0].split(' '))\n    nums = [list(map(int, stdin.split('\\n')[i].split(' '))) for i in range(1, n + 1)]\n    max_dis = 0\n    for i in range(n):\n        max_dis = max(max_dis, nums[i][0])\n    res = [0 for i in range(k)]\n    for i in range(n):\n        if nums[i][0] > max_dis:\n            continue\n        for j in range(i + 1, n):\n            if nums[j][0] > max_dis:\n                break\n            if nums[i][1] == nums[j][1]:\n                if nums[i][2] == 'L':\n                    if nums[j][2] == 'D':\n                        if nums[j][0] - nums[i][0] > res[nums[i][1]]:\n                            res[nums[i][1]] = nums[j][0] - nums[i][0]\n                if nums[i][2] == 'D':\n                    if nums[j][2] == 'L':\n                        if nums[i][0] - nums[j][0] > res[nums[i][1]]:\n                            res[nums[i][1]] = nums[i][0] - nums[j][0]\n            else:\n                if nums[i][2] == 'L':\n                    if nums[j][2] == 'L':\n                        if nums[i][0] - nums[j][0] > res[nums[i][1]] + res[nums[j][1]]:\n                            res[nums[i][1]] = nums[j][0] - nums[i][0]\n                            res[nums[j][1]] = nums[i][0] - nums[j][0]\n                    else:\n                        if nums[i][0] - nums[j][0] > res[nums[i][1]]:\n                            res[nums[i][1]] = nums[i][0] - nums[j][0]\n                if nums[i][2] == 'D':\n                    if nums[j][2] == 'D':\n                        if nums[i][0] - nums[j][0] > res[nums[i][1]] + res[nums[j][1]]:\n                            res[nums[i][1]] = nums[i][0] - nums[j][0]\n                            res[nums[j][1]] = nums[j][0] - nums[i][0]\n                    else:\n                        if nums[j][0] - nums[i][0] > res[nums[i][1]]:\n                            res[nums[i][1]] = nums[i][0] - nums[j][0]\n    for i in range(k):\n        print(res[i])\n    return ''\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Determine the number of turns taken by chameleons moving along the stick\n    by using the following algorithm:\n    1. Create a set that will contain the initial color of each chameleon.\n    2. Loop while the length of the set is greater than one:\n        2.1. Set the number of turns to be equal to 0.\n        2.2. Find all possible ways that the next chameleon can move.\n        2.3. For each of the possible ways (left or right) add to the set the\n             initial color of the next chameleon.\n        2.4. If the color of the next chameleon does not exist in the set,\n             add it and add the number of turns to the number of turns taken.\n    3. Return the number of turns taken\n    \"\"\"\n    chameleons = set()\n    for _ in range(int(stdin.split()[0])):\n        chameleons.add(stdin.split()[-2])\n    chameleons = list(chameleons)\n    chameleons.sort()\n    n = 0\n    for _ in range(int(stdin.split()[1])):\n        chameleons.sort()\n        moves = ['L', 'R']\n        for color in chameleons:\n            for move in moves:\n                if move == 'R' and (color + 1) not in chameleons:\n                    chameleons.append(color + 1)\n                    n += 1\n                elif move == 'L' and (color - 1) not in chameleons:\n                    chameleons.append(color - 1)\n                    n += 1\n    return n\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\".join([str(stdin[1] * i) + '\\n' if stdin[2] == 'L' else str(stdin[1] * i + 1) + '\\n' for i in range(int(stdin[0]))])\n    return 0"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    N, K, L = [int(c) for c in stdin.split()]\n    nums = []\n    colors = []\n    directions = []\n    for i in range(N):\n        nums.append(int(stdin.split()[0]))\n        colors.append(int(stdin.split()[1]))\n        directions.append(stdin.split()[2])\n    # init output\n    result = [0 for _ in range(K)]\n    # go\n    for i in range(N):\n        n = nums[i]\n        color = colors[i]\n        direction = directions[i]\n        while n > 0:\n            if direction == 'L':\n                n -= 1\n                if color == 0:\n                    result[0] += 1\n                elif color == 1:\n                    result[1] += 1\n                elif color == 2:\n                    result[2] += 1\n                elif color == 3:\n                    result[3] += 1\n                elif color == 4:\n                    result[4] += 1\n                elif color == 5:\n                    result[5] += 1\n                elif color == 6:\n                    result[6] += 1\n                elif color == 7:\n                    result[7] += 1\n                elif color == 8:\n                    result[8] += 1\n                elif color == 9:\n                    result[9] += 1\n                elif color == 10:\n                    result[10] += 1\n                elif color == 11:\n                    result[11] += 1\n                elif color == 12:\n                    result[12] += 1\n                elif color == 13:\n                    result[13] += 1\n                elif color == 14:\n                    result[14] += 1\n                elif color == 15:\n                    result[15] += 1\n                elif color == 16:\n                    result[16] += 1\n                elif color == 17:\n                    result[17] += 1\n                elif color == 18:\n                    result[18] += 1\n                elif color == 19:\n                    result[19] += 1\n                elif color == 20:\n                    result[20] += 1\n                elif color == 21:\n                    result[21] += 1\n                elif color == 22:\n                    result[22] += 1\n                elif color == 23:\n                    result[23] += 1\n                elif color == 24:\n                    result[24] += 1\n            elif direction == 'D':\n                n -= 1\n                if color == 0:\n                    result[0] += 1\n                elif color == 1:\n                    result[1] += 1\n                elif color == 2:\n                    result[2] += 1\n                elif color == 3:\n                    result[3] += 1\n                elif color == 4:\n                    result[4] += 1\n                elif color == 5:\n                    result[5] += 1\n                elif color == 6:\n                    result[6] += 1\n                elif color == 7:\n                    result[7] += 1\n                elif color == 8:\n                    result[8] += 1\n                elif color == 9:\n                    result[9] += 1\n                elif color == 10:\n                    result[10] += 1\n                elif color == 11:\n                    result[11] += 1\n                elif color == 12:\n                    result[12] += 1\n                elif color == 13:\n                    result[13] += 1\n                elif color == 14:\n                    result[14] += 1\n                elif color == 15:\n                    result[15] += 1\n                elif color == 16:\n                    result[16] += 1\n                elif color == 17:\n                    result[17] += 1\n                elif color == 18:\n                    result[18] += 1\n                elif color == 19:\n                    result[19] += 1\n                elif color == 20:\n                    result[20] += 1\n                elif color == 21:\n                    result[21] += 1\n                elif color == 22:\n                    result[22] += 1\n                elif color == 23:\n                    result[23] += 1\n                elif color == 24:\n                    result[24] += 1\n    # return result\n    return '\\n'.join([str(result[i]) for i in range(K)])\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split()\n    N = int(stdin[0])\n    K = int(stdin[1])\n    L = int(stdin[2])\n    import numpy as np\n    c = np.array([[int(k) for k in i.split()] for i in stdin[3:]])\n    length = c[:,0]\n    colors = c[:,1]\n    directions = c[:,2]\n    length = list(length)\n    colors = list(colors)\n    directions = list(directions)\n    steps = [np.zeros(N)]\n    for i in range(K):\n        steps.append(np.zeros(N))\n    for i in range(1,N+1):\n        if i == 1:\n            for j in range(K):\n                if directions[j] == 'L':\n                    steps[j][i-1] = length[j]\n                else:\n                    steps[j][i-1] = -1*length[j]\n        else:\n            for j in range(K):\n                if directions[j] == 'L':\n                    steps[j][i-1] = length[j] + steps[j][i-2]\n                else:\n                    steps[j][i-1] = -1*length[j] + steps[j][i-2]\n    # print(steps)\n    trip = np.zeros(K)\n    for i in range(K):\n        trip[i] = sum(steps[i])\n    for i in range(K):\n        print(f'{trip[i]:.1f}')\n    return ''"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    'Computes the trip of each color before getting off the stick, then returns the answer.'\n    # The number of chameleons, colors and directions.\n    _, _, _ = map(int, stdin.split('\\n')[:3])\n    # Initial positions, colors and directions of the chameleons.\n    positions = {i: tuple(map(int, stdin.split('\\n')[i+1].split())) for i in range(3)}\n    # Creates a set of colors.\n    colors = set()\n    for position in positions.values():\n        colors.add(position[1])\n    # The longest distance between the chameleons and the stick.\n    max_distance = positions[0][0]\n    # The solution.\n    solution = ''\n    # All colors.\n    for color in colors:\n        # The total trip.\n        total_trip = 0\n        # All chameleons of the same color.\n        chameleons = [c for c in positions.values() if c[1] == color]\n        # The index of the first chameleon.\n        i = 0\n        # The current direction.\n        direction = chameleons[0][2]\n        # The distance between the current and the first chameleon.\n        distance = chameleons[0][0]\n        while i < len(chameleons):\n            # The distance between the current and the next chameleon.\n            delta_distance = chameleons[i][0] - distance\n            # The next position of the current chameleon.\n            position = (distance if direction == 'L' else distance + max_distance) + delta_distance\n            # The new direction.\n            direction = 'L' if chameleons[i][2] == 'L' else 'D'\n            # The distance between the current and the next chameleon.\n            distance = position\n            # The new total trip.\n            total_trip += distance\n            i += 1\n        solution += f'{total_trip:.1f}' + '\\n'\n    return solution.rstrip('\\n')\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3207,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest stick in the galaxy, then returns the result for each color\"\"\"\n    n, k, L = [int(s) for s in stdin.split(\"\\n\")[0].split(\" \")]\n    a = [[int(s) for s in line.split(\" \")] for line in stdin.split(\"\\n\")[1:n + 1]]\n    stick = [a[i][0] for i in range(n)]\n    b = [a[i][1] for i in range(n)]\n    c = [a[i][2] for i in range(n)]\n    color = [a[i][1] for i in range(n)]\n    direction = [a[i][2] for i in range(n)]\n    return \"\\n\".join([str(max([stick[i] + stick[i - 1] for i in range(1, n)]))] +\n                     [str(max([stick[i] + stick[i - 1] for i in range(1, n) if color[i] == color[i - 1]]))])\n"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    keys = [\n        ['be', 'our', 'rum', 'will', 'dead', 'hook','ship', 'blood','sable', 'avenge', 'parrot', 'captain'],\n        ['dz', 'hz', 'eo', 'jm', 'kc', 'ug', 'qc', 'pm', 'vd', 'ck', 'pz','mj', 'bi', 'cc', 'im', 'kh','mn', 'co', 'dl', 'gk','st', 'qd', 'pb', 'ah', 'kc', 'jz', 'bn', 'ap', 'qe', 'bw', 'qf', 'bp', 'jg', 'qh', 'qk','sk', 'qj', 'qt', 'qu', 'qo','mq', 'qv', 'qw', 'qy', 'qr', 'qz', 'qa', 'kd', 'ku', 'kv', 'kl', 'ku', 'kv', 'kg', 'kj', 'km', 'kn', 'ko', 'kp', 'kl', 'ks', 'kq', 'km', 'kf', 'kq', 'kj', 'kk', 'kn', 'ku', 'kh', 'kv', 'kw', 'km', 'kd', 'kc', 'km', 'kq', 'kn', 'kd', 'ks', 'kp', 'kl', 'kf', 'kg', 'kv', 'kf', 'kq', 'kj', 'kn', 'kp', 'ks', 'kq', 'kj', 'ku', 'kv', 'kc', 'ki', 'kj', 'kk', 'kn', 'ku', 'kh', 'kv', 'kw', 'kq', 'km', 'kn', 'kk', 'kg', 'kd', 'kq', 'kc', 'km', 'kp', 'kc', 'kg', 'kf', 'kv', 'kl', 'kp', 'kd', 'kc', 'kf', 'kq', 'kj', 'km', 'ku', 'kh', 'kv', 'kw', 'km', 'kd', 'kc', 'kf', 'kv', 'kw', 'kq', 'km', 'kj', 'kk', 'kn', 'ku', 'kh', 'kv', 'kw', 'km', 'kw', 'kq', 'km', 'kq', 'kn', 'kq', 'kj', 'kn', 'kp', 'kq', 'kq', 'kc', 'kd', 'kk', 'kh', 'kv', 'kw', 'kq', 'kg', 'kh', 'kv', 'kf', 'kq', 'kj', 'kf', 'kv', 'kj', 'ks', 'ko', 'ku', 'kj', 'kk', 'km', 'ku', 'kj', 'kk', 'kf', 'kg', 'kv', 'kh', 'kv', 'kh', 'kq', 'kj', 'kj', 'kf', 'kq', 'kq', 'kp', 'kq', 'kf', 'kg', 'kq', 'kh', 'kp', 'ki', 'kp', 'kf', 'kj', 'kq', 'kq', 'kq', 'ks', 'kv', 'kq', 'kq', 'kf', 'kg', 'kf', 'kv', 'kj', 'kk', 'kd', 'kd', 'kk', 'kq', 'kq', 'kg', 'kq', 'kq', 'kq', 'kj', 'kq', 'kv', 'kq', 'kf', 'kf', 'kj', 'kq', 'kq', 'ki', 'kq', 'kq', 'kq', 'kv', 'kq', 'km', 'kr', 'kv', 'kj', 'kq', 'kq', 'kq', 'kq', 'kq', 'kv', 'kq', 'kq', 'ks', 'kv', 'kq', 'kq', 'kq', 'kv', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kv', 'kq', 'kq', 'kq', 'kq', 'kq', 'kv', 'kv', 'kq', 'kv', 'kv', 'kv', 'kq', 'kq', 'kq', 'kv', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kv', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq', 'kq"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: Read input\n    enc = stdin\n\n    # TODO: Solve problem\n    return \"qwe\"\n\"\"\"\n"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    words = [\n        'be', 'our', 'rum', 'will', 'dead', 'hook','ship', 'blood','sable',\n        'avenge', 'parrot', 'captain'\n    ]\n    ciphers = {\n        'a': 'h', 'b': 'e', 'c': 't', 'd': 'o', 'e': 'n', 'f': 'w', 'g': 'r',\n        'h': 'a', 'i': 'i', 'j': 'k', 'k': 'a', 'l': 'd','m': 'c', 'n': 'b',\n        'o': 'f', 'p': 'g', 'q': 'u', 'r':'s','s': 'q', 't': 'p', 'u': 'j',\n        'v':'m', 'w': 'x', 'x': 'v', 'y': 'l', 'z': 'y','': 'z'\n    }\n    encrypted = stdin.lower()\n\n    for plain, cipher in ciphers.items():\n        encrypted = encrypted.replace(plain, cipher)\n\n    return 'Impossible' if len(set(words))!= len(set(encrypted.split(' '))) else encrypted\n"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nimport re\nimport string\nimport itertools\nfrom collections import Counter\nfrom typing import Dict, List\nfrom pprint import pprint\n\n\ndef"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = {'be', 'our', 'rum', 'will', 'dead', 'hook','ship', 'blood','sable', 'avenge', 'parrot', 'captain'}\n    substitutions = {}\n    substitutions[' '] =''\n    substitutions['e'] = 'h'\n    substitutions['o'] = 'w'\n    substitutions['i'] = 'l'\n    substitutions['j'] = 'a'\n    substitutions['x'] = 'c'\n    substitutions['b'] = 'u'\n    substitutions['z'] ='s'\n    substitutions['c'] = 'd'\n    substitutions['v'] = 'f'\n    substitutions['u'] = 'r'\n    substitutions['t'] = 'g'\n    substitutions['s'] = 'b'\n    substitutions['n'] ='m'\n    substitutions['d'] = 'e'\n    substitutions['k'] = 'y'\n    substitutions['p'] = 'p'\n    substitutions['m'] = 'o'\n    substitutions['g'] = 'l'\n    substitutions['w'] = 'o'\n    substitutions['f'] = 'r'\n    substitutions['v'] = 't'\n    substitutions['y'] = 'v'\n    substitutions['r'] = 'n'\n    substitutions['a'] = 'd'\n    substitutions['e'] = 'z'\n    substitutions['l'] = 'i'\n    substitutions['t'] = 'w'\n    substitutions['h'] = 'c'\n    substitutions['s'] = 'a'\n    substitutions['a'] = 'k'\n    substitutions['o'] = 'n'\n    substitutions['n'] ='m'\n    substitutions['y'] = 'q'\n    substitutions['q'] = 'y'\n    substitutions['z'] = 'j'\n    substitutions['c'] = 'x'\n    substitutions['m'] = 'p'\n    substitutions['k'] = 'o'\n    substitutions['p'] = 'l'\n    substitutions['r'] = 'z'\n    substitutions['i'] = 'i'\n    substitutions['q'] = 'j'\n    substitutions['z'] = 'd'\n    substitutions['x'] = 'c'\n    substitutions['e'] = 'v'\n    substitutions['d'] = 'b'\n    substitutions['k'] = 'e'\n    substitutions['s'] = 'b'\n    substitutions['t'] = 'r'\n    substitutions['h'] = 'f'\n    substitutions['b'] = 'u'\n    substitutions['r'] ='s'\n    substitutions['y'] = 'k'\n    substitutions['o'] = 'n'\n    substitutions['n'] = 't'\n    substitutions['e'] = 'x'\n    substitutions['l'] = 'o'\n    substitutions['p'] ='m'\n    substitutions['f'] = 'g'\n    substitutions['c'] = 'y'\n    substitutions['v'] = 'e'\n    substitutions['d'] = 'w'\n    substitutions['o'] = 'r'\n    substitutions['q'] = 'q'\n    substitutions['z'] = 'c'\n    substitutions['m'] = 'a'\n    substitutions['a'] = 'i'\n    substitutions['y'] ='s'\n    substitutions['q'] = 'y'\n    substitutions['z'] = 'j'\n    substitutions['k'] = 'q'\n    substitutions['g'] = 'p'\n    substitutions['c'] = 'r'\n    substitutions['i'] = 'y'\n    substitutions['f'] = 't'\n    substitutions['b'] = 'n'\n    substitutions['r'] = 'e'\n    substitutions['s'] ='m'\n    substitutions['x'] = 'j'\n    substitutions['v'] = 'k'\n    substitutions['d'] = 'n'\n    substitutions['o'] = 'p'\n    substitutions['y'] ='s'\n    substitutions['q'] = 'o'\n    substitutions['z'] = 'l'\n    substitutions['e'] = 'c'\n    substitutions['t'] = 'g'\n    substitutions['n'] = 't'\n    substitutions['w'] = 'f'\n    substitutions['a'] = 'p'\n    substitutions['s'] = 'r'\n    substitutions['i'] = 'n'\n    substitutions['g'] = 'e'\n    substitutions['r'] = 'u'\n    substitutions['y'] = 'q'\n    substitutions['q'] = 'k'\n    substitutions['x'] = 'i'\n    substitutions['v'] = 'j'\n    substitutions['w'] ='m'\n    substitutions['s'] = 'v'\n    substitutions['d'] = 'y'\n    substitutions['k'] = 'z'\n    substitutions['f'] = 'z'\n    substitutions"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution converts the input into a standard text representation,\n    then computes the mapping between standard and cipher text, and\n    finally converts the cipher text into standard text using the mapping.\n    \"\"\"\n    cipher = [stdin.replace(\" \", \"\").lower()]\n    for i in range(len(cipher[0])):\n        if cipher[0][i] not in ALPHABET:\n            cipher[0] = cipher[0][:i] + \"*\" + cipher[0][i + 1:]\n    for j in range(len(STANDARD)):\n        if STANDARD[j] in cipher[0]:\n            cipher[0] = cipher[0].replace(STANDARD[j], \"*\")\n    table = {}\n    for i in range(len(ALPHABET)):\n        for j in range(len(STANDARD)):\n            if cipher[0].count(ALPHABET[i]) == STANDARD.count(STANDARD[j]):\n                table[cipher[0][i]] = ALPHABET[i]\n                break\n    standard = \"\"\n    for i in range(len(cipher[0])):\n        if cipher[0][i] in table.keys():\n            standard += table[cipher[0][i]]\n        else:\n            standard += cipher[0][i]\n    return standard\n"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # return \"no solution\"\n    # Your code here\n    # return \"\"\n    stdin = stdin.split()\n\n    dict_map = {'a': 'z', 'b': 'y', 'c': 'x', 'd': 'w', 'e': 'v', 'f': 'u', 'g': 't', 'h':'s', 'i': 'r', 'j': 'q',\n                'k': 'p', 'l': 'o','m': 'n', 'n':'m', 'o': 'l', 'p': 'k', 'q': 'j', 'r': 'i','s': 'h', 't': 'g',\n                'u': 'f', 'v': 'e', 'w': 'd', 'x': 'c', 'y': 'b', 'z': 'a'}\n    decoded_string = \"\"\n\n    for element in stdin:\n        # print(element)\n        if element in dict_map:\n            decoded_string += dict_map[element]\n        else:\n            decoded_string += element\n\n    return decoded_string\n    # return decoded_string"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Decrypts the encrypted text\"\"\"\n    def decrypt_word(word, cipher_dict):\n        for key, value in cipher_dict.items():\n            if word == value:\n                return key\n        return \"Impossible\"\n\n    def decrypt_text(text):\n        \"\"\"Decrypts the encrypted text\"\"\"\n        cipher_dict = {}\n        for i in range(len(alpha_list)):\n            cipher_dict[alpha_list[i]] = text[i]\n        decrypted_text = []\n        word = \"\"\n        for char in text:\n            if char.isalpha():\n                word += char\n                continue\n            if word:\n                decrypted_text.append(decrypt_word(word, cipher_dict))\n                word = \"\"\n            decrypted_text.append(char)\n        if word:\n            decrypted_text.append(decrypt_word(word, cipher_dict))\n        return \" \".join(decrypted_text)\n    text = stdin.strip()\n    alpha_list = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',' ']\n    print(decrypt_text(text))\n    return 0\n"
    },
    {
        "number": 3208,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Decrypts the given text using the wordset given in the problem.\n    \"\"\"\n    encrypted_text = stdin\n    with open(\"words.txt\", \"r\") as word_file:\n        word_set = set(word_file.read().splitlines())\n        encrypted_word_list = []\n        for word in word_set:\n            encrypted_word_list.append(word.lower())\n        encrypted_word_list.append(\"\")\n        word_dict = dict(zip(encrypted_word_list, word_set))\n        decrypted_list = []\n        for c in encrypted_text:\n            if c!= \" \":\n                decrypted_list.append(word_dict[c])\n        decrypted_string = \"\".join(decrypted_list)\n        if len(decrypted_string) == len(set(decrypted_string)):\n            return decrypted_string\n        return \"Impossible\"\n    \n    \n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"The code has been validated successfully and the function is ready to use!\""
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"Hamburg Bremen\\n3\\nHamburg Bremen 15 68 10 5\\nHamburg Bremen 46 55 50 60\\nBremen Frankfurt 14 226 10 120\")\n    68.3\n    >>> solution(\"Amsterdam Rotterdam\\n1\\nAmsterdam Utrecht 10 22 5 10\")\n    'IMPOSSIBLE'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    start = stdin.split()\n    destination = start[1]\n    train_connections = int(stdin.split()[0])\n    dict = {}\n    for i in range(train_connections):\n        train = stdin.split()[i + 2]\n        dict[train] = [stdin.split()[i + 2], stdin.split()[i + 4], stdin.split()[i + 6], stdin.split()[i + 8]]\n    dictionary = {}\n    for key, value in dict.items():\n        if value[0] not in dictionary.keys():\n            dictionary[value[0]] = []\n        dictionary[value[0]].append([key, value[1], value[2], value[3]])\n    minimized_train_duration = float('inf')\n    for key, value in dictionary.items():\n        if key == destination:\n            for x in value:\n                if int(x[2]) + int(x[3]) < minimized_train_duration:\n                    minimized_train_duration = int(x[2]) + int(x[3])\n    if minimized_train_duration == float('inf'):\n        return \"IMPOSSIBLE\"\n    return minimized_train_duration\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    input_s = stdin.split('\\n')\n    orig = input_s[0].split()\n    dest = input_s[1].split()\n    \n    # get train details\n    train_details = []\n    for i in range(2, len(input_s)):\n        train_details.append(input_s[i].split())\n    \n    # get miniumum\n    min_t = float('inf')\n    for i in range(len(train_details)):\n        start = train_details[i][0]\n        end = train_details[i][1]\n        arrival_time = int(train_details[i][2])\n        departure_time = int(train_details[i][3])\n        journey_time = int(train_details[i][4])\n        delay_time = int(train_details[i][5])\n        if start == orig[0]:\n            if end == dest[0]:\n                min_t = min(min_t, (journey_time + arrival_time - delay_time) / 60)\n        else:\n            if end == dest[0]:\n                min_t = min(min_t, (arrival_time + departure_time - delay_time) / 60)\n    \n    if min_t == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return min_t"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.split('\\n')\n    if lst[0][0] == lst[1][0]:\n        print('IMPOSSIBLE')\n        return\n    judges = lst[0].split()\n    n = int(lst[1])\n    lst = lst[2:]\n    graph = dict()\n    # build graph\n    for i in range(n):\n        src = lst[i].split()\n        if src[0] not in graph:\n            graph[src[0]] = [float(src[3]), dict()]\n        if src[1] not in graph:\n            graph[src[1]] = [float(src[4]), dict()]\n        # add edge\n        graph[src[0]][1][src[1]] = float(src[2])\n        graph[src[1]][1][src[0]] = float(src[2])\n    # build dp\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    # build dp\n    dp[0][0] = graph[judges[0]][0]\n    for j in range(n):\n        dp[0][j] = dp[0][j-1] + graph[judges[0]][1][lst[j].split()[0]]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + graph[lst[i].split()[0]][1][judges[1]]\n    # build dp\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j-1] + graph[lst[j].split()[0]][1][lst[i].split()[0]], dp[i][j-1] + graph[lst[j].split()[0]][1][judges[1]])\n    # search path\n    i = j = 0\n    while True:\n        if i == n-1 and j == n-1:\n            break\n        if i == 0 and j!= n-1:\n            j += 1\n        elif i!= 0 and j == 0:\n            i += 1\n        else:\n            if dp[i][j] <= dp[i-1][j-1] + graph[judges[0]][1][lst[j].split()[0]]:\n                j += 1\n            else:\n                i += 1\n    # output\n    print(dp[-1][-1])\n\nsolution(stdin)\n\ndef"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    O, D = stdin.split(\"\\n\")\n    O, D = O.split(\" \"), D.split(\" \")\n    origin = O[0]\n    destination = O[1]\n    travel_times = [int(x) for x in O[2:]]\n    train_times = [int(x) for x in D[2:]]\n    intercity_time = int(D[0])\n    delays = [int(x) for x in D[3:]]\n    # Probability of delayed travel on any given connection\n    p = sum([float(x) / y for x, y in zip(delays, travel_times)]) / len(delays)\n    # Expected duration of travel on any given connection\n    e = sum([(float(x) + y) / z for x, y, z in zip(travel_times, delays, train_times)]) / len(delays)\n\n    # Determine the minimum possible travel time and the delay at that time\n    c = 0\n    for i in range(len(delays)):\n        if (delays[i] > 0) and (train_times[i] / delays[i] >= c):\n            c = train_times[i] / delays[i]\n    if c == 0:\n        return \"IMPOSSIBLE\"\n    return \"{:.6f}\".format(e * (1 + p) * intercity_time / c)\n"
    },
    {
        "number": 3209,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Get the input from the stdin and solve the problem\n    '''\n    origin = stdin.split(\"\\n\")[0].split(\" \")[0]\n    destination = stdin.split(\"\\n\")[0].split(\" \")[1]\n    n = int(stdin.split(\"\\n\")[1])\n\n    def dfs(node, distance, delay):\n        '''\n        A DFS algorithm that solves the problem\n        '''\n        global min_time\n\n        if node == destination:\n            min_time = distance\n            return\n\n        if distance > min_time:\n            return\n\n        for i, connection in enumerate(connections):\n            if connection[0] == node:\n                if np.random.randint(0, 101) < connection[4]:\n                    new_delay = np.random.randint(1, 121)\n                    new_distance = distance + new_delay * connection[2]\n                    if new_distance < min_time:\n                        dfs(connections[i][1], new_distance, new_delay)\n\n    connections = []\n    for _ in range(n):\n        connections.append(list(map(int, stdin.split(\"\\n\")[_].split(\" \"))))\n\n    connections = sorted(connections, key=lambda x: x[1])\n    min_time = float(\"inf\")\n    dfs(origin, 0, 0)\n\n    return str(round(min_time, 6)) if min_time < float(\"inf\") else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    size = int(stdin.split()[0])\n    # state = stdin.split('\\n')[1:-1]\n    state = []\n    for row in stdin.split('\\n')[1:]:\n        state.append(list(row))\n\n    # define empty lists\n    score_a = []\n    score_b = []\n    scores = [score_a, score_b]\n\n    # loop through to find the score\n    for i in range(size):\n        for j in range(size):\n            if state[i][j] == '*':\n                score_a.append(0)\n            elif state[i][j] == '.':\n                score_a.append(0)\n                score_b.append(0)\n            elif state[i][j] == '|':\n                score_a.append(1)\n                score_b.append(0)\n            elif state[i][j] == '-':\n                score_a.append(0)\n                score_b.append(1)\n            else:\n                score_a.append(math.inf)\n                score_b.append(math.inf)\n\n    moves = []\n    for i in range(size - 1):\n        for j in range(size - 1):\n            # check if a possible move\n            if state[i][j] == '*':\n                if state[i][j] == state[i][j + 1]:\n                    moves.append(min(score_a[i * size + j], score_b[i * size + j]))\n                elif state[i][j] == state[i + 1][j]:\n                    moves.append(min(score_a[i * size + j], score_b[(i + 1) * size + j]))\n                else:\n                    moves.append(math.inf)\n            else:\n                moves.append(math.inf)\n    moves.append(max(score_a[size * size - 1], score_b[size * size - 1]))\n    return str(min(moves))\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    line_l = stdin.split('\\n')\n    board = np.array(list(map(list, line_l[1:4])))\n    queue = deque()\n    queue.append(((0, 0), 1))\n    visited = set()\n    while queue:\n        curr, score = queue.popleft()\n        if curr[0] == curr[1]:\n            return score\n        if curr in visited:\n            continue\n        visited.add(curr)\n        if board[curr[0], curr[1]] == '*':\n            queue.append(((curr[0] - 1, curr[1]), score + 1))\n            queue.append(((curr[0] + 1, curr[1]), score + 1))\n            queue.append(((curr[0], curr[1] - 1), score + 1))\n            queue.append(((curr[0], curr[1] + 1), score + 1))\n        elif board[curr[0], curr[1]] == '|':\n            queue.append(((curr[0], curr[1] - 1), score + 1))\n            queue.append(((curr[0], curr[1] + 1), score + 1))\n        elif board[curr[0], curr[1]] == '.':\n            queue.append(((curr[0] - 1, curr[1]), score))\n            queue.append(((curr[0] + 1, curr[1]), score))\n            queue.append(((curr[0], curr[1] - 1), score))\n            queue.append(((curr[0], curr[1] + 1), score))\n    return None\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    N = int(rows[0])\n    lattice = []\n    for row in rows[1:]:\n        lattice.append(list(row))\n    ans = 0\n    def dfs(i, j):\n        nonlocal lattice\n        nonlocal ans\n        ans += 1\n        lattice[i][j] = 0\n        if i > 0 and lattice[i-1][j] == '*':\n            dfs(i-1, j)\n        if j > 0 and lattice[i][j-1] == '*':\n            dfs(i, j-1)\n        if i < N-1 and lattice[i+1][j] == '*':\n            dfs(i+1, j)\n        if j < N-1 and lattice[i][j+1] == '*':\n            dfs(i, j+1)\n    for i in range(N):\n        for j in range(N):\n            if lattice[i][j] == '*':\n                dfs(i, j)\n    return ans\ndef"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, state = [int(line) for line in stdin.split('\\n')]\n    state = state.split('\\n')\n    return \"Alice: \" + str(alice(N, state)) + \"\\n\" + \"Bob: \" + str(bob(N, state))\n\ndef"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\"\n"
    },
    {
        "number": 3210,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the minimum number of swaps necessary to ensure victory, \n    or outputs \"impossible\" if that is not possible.\"\"\"\n    n = int(stdin)\n    votes = stdin\n    tellers = [int(vote) for vote in votes if vote == \"0\"]\n    candidates = [int(vote) for vote in votes if vote!= \"0\"]\n    tellers_to_candidates = dict(zip(tellers, candidates))\n    swaps = len(tellers)\n    \n    for teller in tellers:\n        if tellers_to_candidates.get(teller + 1):\n            swaps -= 1\n        if tellers_to_candidates.get(teller - 1):\n            swaps -= 1\n    \n    if swaps < 0:\n        return \"impossible\"\n    else:\n        return swaps"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Complete this function\n    pass\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def swap(s: str, i1: int, i2: int) -> str:\n        return s[:i1] + s[i2] + s[i1+1:i2] + s[i1] + s[i2+1:]\n    \n    def is_valid(s: str) -> bool:\n        for i, c in enumerate(s):\n            if c == '0' and i > 0 and s[i-1]!= '2':\n                return False\n            if c == '2' and i < len(s)-1 and s[i+1]!= '0':\n                return False\n        return True\n\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    if n == len(s) and is_valid(s):\n        return '0'\n\n    swaps = 0\n    while True:\n        i = 0\n        while True:\n            if s[i] == '0':\n                break\n            i += 1\n        j = n-1\n        while True:\n            if s[j] == '0':\n                break\n            j -= 1\n        if i > j:\n            break\n        i1, i2 = i, j\n        while s[i1] == '0':\n            i1 += 1\n        while s[i2] == '0':\n            i2 -= 1\n        if i1 > i2:\n            i1, i2 = i2, i1\n        if s[i1] == '1' and s[i2] == '2':\n            s = swap(s, i1, i2)\n            swaps += 1\n            i1 += 1\n            i2 += 1\n        elif s[i1] == '2' and s[i2] == '1':\n            s = swap(s, i1, i2)\n            swaps += 1\n            i1 -= 1\n            i2 -= 1\n        else:\n            break\n    return str(swaps) if is_valid(s) else 'impossible'\n    \nprint(solution(input()))\n\ndef"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline()\n    m = n // 2\n    if '0' not in s:\n        return 'impossible'\n    else:\n        p = {'1': 1, '2': 0}\n        c = 0\n        q = []\n        for i in s:\n            if i == '0':\n                q.append(c)\n            else:\n                c += 1\n        q = sorted(q)\n        for i in q:\n            if i == 0 or i == m:\n                pass\n            elif p[s[i]] == 0 or p[s[i + 1]] == 0:\n                pass\n            else:\n                p[s[i]] += 1\n                p[s[i + 1]] -= 1\n                if p[s[i]] > p[s[i + 1]]:\n                    c += 1\n        return c\n"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This function takes the string stdin and passes it to the solve function. It then returns the solution of the problem.\"\"\"\n    n = int(stdin)\n    s = stdin\n    return str(solve(n, s))\n\n\ndef"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    votes = stdin\n    swaps = 0\n    for i in range(n):\n        if votes[i] == votes[i - 1]:\n            swaps += 1\n        elif votes[i] == '0':\n            swaps += 1\n    if swaps == 0:\n        return \"impossible\"\n    else:\n        return swaps\n        "
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the minimum number of swaps necessary to ensure the party with the most votes wins.\n    Returns 'impossible' if this is not possible.'''\n    # Parse input.\n    n = int(stdin.readline())\n    votes = list(map(int, stdin.readline().strip()))\n    # Initialize variables.\n    swaps = 0\n    # Initially, all the votes are in the same party.\n    party = votes[0]\n    # Define a function that swaps the roles of two tellers.\n    def swap_tellers(i: int, j: int) -> None:\n        '''Swaps the roles of the two tellers with indices i and j.'''\n        nonlocal swaps\n        # Swap the indices.\n        t1, t2 = votes[i], votes[j]\n        votes[i], votes[j] = t2, t1\n        # Update the number of swaps.\n        swaps += 1\n    # Define a function that checks whether swapping a teller with an adjacent person in the list of arrivals gives a better or worse outcome.\n    def better_or_worse(i: int, j: int) -> bool:\n        '''Returns whether swapping the people with indices i and j gives a better or worse outcome.'''\n        # If the swapping would make the party with more votes worse, return False.\n        if party == 1 and votes[j] >= votes[i] or party == 2 and votes[j] <= votes[i]:\n            return False\n        # If the swapping would make the party with more votes better, return True.\n        if party == 1 and votes[j] < votes[i] or party == 2 and votes[j] > votes[i]:\n            return True\n    # Define a function that makes a swap.\n    def make_a_swap(i: int, j: int) -> None:\n        '''Makes a swap of the two people with the indices i and j.'''\n        nonlocal swaps\n        # Swap the people at the indices.\n        votes[i], votes[j] = votes[j], votes[i]\n        # Update the number of swaps.\n        swaps += 1\n    # Initialize a variable that records the best outcome.\n    best = len(votes)\n    # If there is only one teller, it is impossible to get a better outcome.\n    if n == 1:\n        return 'impossible'\n    # Initialize a variable that records whether it is possible to get a better outcome.\n    possible = True\n    # Loop over the citizens in order of arrival.\n    for i in range(n):\n        # If this person is a teller, they cannot be swapped with an adjacent person.\n        if votes[i] == 0:\n            continue\n        # Otherwise, loop over the adjacent tellers.\n        for j in range(1, n):\n            # If there is an adjacent teller, check whether swapping them gives a better outcome.\n            if votes[i]!= votes[j] and votes[i]!= 0 and votes[j]!= 0:\n                # If so, check whether swapping the two tellers gives a better or worse outcome.\n                if better_or_worse(i, j):\n                    # If so, swap the tellers.\n                    swap_tellers(i, j)\n                    # If swapping the tellers results in a better outcome, update the number of swaps.\n                    if swaps < best:\n                        best = swaps\n                    # If swapping the tellers results in a worse outcome, update the possibility of getting a better outcome.\n                    else:\n                        possible = False\n                    # Make sure the tellers are not swapped back.\n                    make_a_swap(i, j)\n    # If it is possible to get a better outcome, return the minimum number of swaps.\n    if possible:\n        return str(best)\n    # Otherwise, return 'impossible'.\n    return 'impossible'"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(8, '12210020')\n    4\n    >>> solution(4, '1111')\n    'impossible'\n    \"\"\"\n    n = int(stdin.readline())\n    votes = stdin.readline()\n    swaps = 0\n    for i, vote in enumerate(votes):\n        if vote == '1':\n            if i - 1 >= 0 and votes[i - 1] == '0' and votes[i] == '1':\n                votes = votes[:i - 1] + '0' + votes[i:]\n                swaps += 1\n            if i + 1 < len(votes) and votes[i + 1] == '0' and votes[i] == '1':\n                votes = votes[:i] + '0' + votes[i + 1:]\n                swaps += 1\n    if swaps == 0:\n        return 'impossible'\n    else:\n        return swaps\n"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = stdin.readline()\n\n    # for i in range(n):\n    #     if a[i] == \"0\":\n    #         a[i] = \"1\"\n    #     if a[i] == \"2\":\n    #         a[i] = \"3\"\n    #     if a[i] == \"1\":\n    #         a[i] = \"0\"\n    #     if a[i] == \"3\":\n    #         a[i] = \"2\"\n    arr = [0] * n\n    for i in range(n):\n        if a[i] == \"0\":\n            arr[i] = 1\n        if a[i] == \"2\":\n            arr[i] = 2\n        if a[i] == \"1\":\n            arr[i] = 3\n        if a[i] == \"3\":\n            arr[i] = 0\n    arr[0], arr[1] = arr[1], arr[0]\n    arr[3], arr[4] = arr[4], arr[3]\n    arr[4], arr[2] = arr[2], arr[4]\n    arr[5], arr[6] = arr[6], arr[5]\n    arr[6], arr[7] = arr[7], arr[6]\n    arr[7], arr[8] = arr[8], arr[7]\n    arr[8], arr[9] = arr[9], arr[8]\n    arr[9], arr[10] = arr[10], arr[9]\n    if arr[0] == 1 and arr[3] == 2 and arr[6] == 3:\n        print(3)\n    else:\n        print(\"impossible\")\n        # return a\n"
    },
    {
        "number": 3211,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of swaps necessary to ensure party 1 wins in an election.\n    \"\"\"\n    n = int(stdin.readline())\n    citizen_swap_list = stdin.readline()\n    swaps = 0\n    # 1 is the party of the president\n    party_1 = 0\n    # 2 is the party of the candidate\n    party_2 = 0\n    # Check if there are two tellers\n    if citizen_swap_list.count('0') == 2:\n        for i, c in enumerate(citizen_swap_list):\n            if c == '0':\n                swaps += 1\n                if swaps % 2 == 0:\n                    party_1 += 1\n                else:\n                    party_2 += 1\n                citizen_swap_list = citizen_swap_list[:i] + citizen_swap_list[i + 1:]\n    else:\n        for i, c in enumerate(citizen_swap_list):\n            if c == '0':\n                swaps += 1\n                if swaps % 2 == 0:\n                    party_1 += 1\n                else:\n                    party_2 += 1\n                citizen_swap_list = citizen_swap_list[:i] + citizen_swap_list[i + 1:]\n    # Check if election is impossible\n    if party_1 > party_2:\n        return 'impossible'\n    return swaps\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    snakes = stdin.splitlines()\n    snakes = sorted([[int(x) for x in snake.split()] for snake in snakes])\n    snakes = [[snake[0] // 1000, snake[1] // 1000] for snake in snakes]\n    sx, sy = snakes[0]\n    ex, ey = snakes[1]\n    if sx == 0 or sx == ex:\n        # print(sx,sy,ex,ey)\n        return f\"Bill will be bitten.\\n\"\n    if sy == 0 or sy == ey:\n        # print(sx,sy,ex,ey)\n        return f\"Bill will be bitten.\\n\"\n    else:\n        for sx in range(0, ex + 1):\n            for sy in range(0, ey + 1):\n                if sx!= ex and sy!= ey:\n                    if sx + sy == ex + ey or sx - sy == ex - ey:\n                        return f\"{sx:.2f} {sy:.2f}\\n\"\n        return \"Bill will be bitten.\\n\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    number_of_snakes = int(stdin.readline())\n    snake_coordinates = []\n    for _ in range(number_of_snakes):\n        x, y, distance = map(int, stdin.readline().split())\n        snake_coordinates.append(tuple([x, y, distance]))\n    snake_coordinates.sort(key=lambda x: x[0])\n    snake_coordinates.sort(key=lambda x: x[1])\n    snake_coordinates.sort(key=lambda x: x[2])\n    snake_coordinates.sort(key=lambda x: x[0] + x[1])\n    snake_coordinates.sort(key=lambda x: x[0] - x[1])\n    snake_coordinates.sort(key=lambda x: x[0] + x[1])\n    snake_coordinates.sort(key=lambda x: x[0] - x[1])\n    # print(snake_coordinates)\n    sorted_snake_coordinates = snake_coordinates[:]\n    for _, _, distance in sorted_snake_coordinates:\n        if distance % 2 == 1:\n            sorted_snake_coordinates.remove((_, _, distance))\n    # print(sorted_snake_coordinates)\n    if len(sorted_snake_coordinates)!= number_of_snakes:\n        print('Bill will be bitten.')\n    else:\n        print(f'Bill enters at {round(sorted_snake_coordinates[0][0], 2)}, '\n              f'{round(sorted_snake_coordinates[0][1], 2)}, '\n              f'leaves at {round(sorted_snake_coordinates[-1][0], 2)}, '\n              f'{round(sorted_snake_coordinates[-1][1], 2)}.')\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    snakes = [tuple(map(int, line.split())) for line in stdin]\n    snakes.sort()\n    \n    start, end = 0, n\n    while end - start > 1:\n        mid = (start + end) // 2\n        if snakes[mid][0] >= snakes[0][0]:\n            end = mid\n        else:\n            start = mid\n\n    for i in range(n):\n        if snakes[i][0] >= snakes[0][0]:\n            start = i\n            break\n\n    for i in range(n - 1, -1, -1):\n        if snakes[i][0] >= snakes[0][0]:\n            end = i\n            break\n\n    for i in range(start, end + 1):\n        for j in range(1, n):\n            if abs(snakes[i][0] - snakes[j][0]) > snakes[i][1]:\n                return \"Bill will be bitten.\"\n            if abs(snakes[i][0] - snakes[j][0]) > snakes[j][1]:\n                return \"Bill will be bitten.\"\n            if abs(snakes[i][0] - snakes[j][0]) <= snakes[i][1]:\n                if abs(snakes[i][1] - snakes[j][1]) > snakes[j][1]:\n                    return \"Bill will be bitten.\"\n                if abs(snakes[i][1] - snakes[j][1]) <= snakes[j][1]:\n                    return \"Bill will be bitten.\"\n\n    return f\"{format(snakes[start][0], '0.2f')} {format(snakes[end][1], '0.2f')}\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    # n = int(input())\n    # snakes = []\n    # for i in range(n):\n    #     x, y, d = map(int, input().split())\n    #     snakes.append((x, y, d))\n    #\n    # max_x = 1000\n    # max_y = 1000\n    #\n    # for x, y, d in snakes:\n    #     max_x = min(max_x, x + d)\n    #     max_y = min(max_y, y + d)\n    #\n    # # print(snakes)\n    # # print(max_x, max_y)\n    #\n    # if max_x > max_y:\n    #     print('Bill will be bitten.')\n    # else:\n    #     print('{:.2f}, {:.2f}'.format(max_y, max_x))\n\n    n = int(input())\n    snakes = {}\n    for i in range(n):\n        x, y, d = map(int, input().split())\n        if (x, y) in snakes:\n            snakes[(x, y)].append(d)\n        else:\n            snakes[(x, y)] = [d]\n    # print(snakes)\n    max_x = 0\n    max_y = 0\n    for pos, ds in snakes.items():\n        max_x = max(max_x, pos[0])\n        max_y = max(max_y, pos[1])\n    # print(max_x, max_y)\n    for i in range(max_y, -1, -1):\n        for j in range(max_x, -1, -1):\n            if (j, i) in snakes:\n                for d in snakes[(j, i)]:\n                    if j + d > max_x:\n                        max_x = j + d\n                    if i + d > max_y:\n                        max_y = i + d\n                break\n        if max_x <= max_y:\n            break\n    print('{:.2f}, {:.2f}'.format(max_y, max_x))\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    snakes: list = []\n    for _ in range(int(stdin)):\n        snakes.append([int(coord) for coord in stdin.split('\\n')[-1].split(' ')])\n    snakes.sort()\n    if snakes[0][1] == 1000 or snakes[-1][1] == 0:\n        return 'Bill will be bitten.'\n    for i in range(len(snakes)):\n        for j in range(i + 1, len(snakes)):\n            if snakes[i][1] <= snakes[j][1] <= snakes[i][2] or snakes[j][1] <= snakes[i][2] <= snakes[j][2]:\n                return 'Bill will be bitten.'\n    return f'{snakes[0][0]:.2f}, {snakes[-1][1]:.2f}'\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"read the input and provide the solution\"\"\"\n    pass\n    # write your code in Python 3.6\n    # take input\n    # transform the input into a list of all the coordinates of snakes\n    # start off with the most northest pair of coordinates\n    # then go through each pair of coordinates and see if any of the snakes are on that pair\n    # if they are, then that's the one closest to the previous pair\n    # then if any of the snakes are on the next pair, then the most northest pair is the one closest to both of the snakes on the previous pair\n    # do this until all the snakes have been checked\n    # at the end, the most northest pair is the answer\n    # return the answer\n"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    snakes = []\n    num_snakes = int(stdin.readline().strip())\n    for snake in range(num_snakes):\n        loc, dist = [int(x) for x in stdin.readline().split()]\n        snakes.append((loc, dist))\n    locs = []\n    for loc, dist in snakes:\n        if loc == 0 and dist == 1000:\n            continue\n        if loc < dist:\n            for i in range(loc, dist+1):\n                if (i, 1000-i) not in locs:\n                    locs.append((i, 1000-i))\n        else:\n            for i in range(loc, 1000):\n                if (i, 1000-i) not in locs:\n                    locs.append((i, 1000-i))\n    for i in range(1000):\n        for j in range(1000-i):\n            if (i, j) not in locs:\n                print(f\"Bill will be bitten.\\n\")\n                return\n    locs.sort(key=lambda x: x[0])\n    for i in range(len(locs)//2):\n        print(f\"{locs[i][0]:.2f} {locs[i][1]:.2f}\\n\")\n\nSolution:\n    :param stdin:\n    :return:\n\"\"\"\nimport math\nimport sys\nimport functools\n\nsys.setrecursionlimit(1000000)\n\ninputs = []\nwhile True:\n    try:\n        inputs.append(input())\n    except EOFError as e:\n        break\n\nsnakes = []\nfor i in inputs:\n    snakes.append([int(x) for x in i.split()])\n\n\ndef"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    count = 0\n    positions = {}\n    for line in stdin:\n        if count == 0:\n            count = int(line)\n        else:\n            x, y, d = line.split(\" \")\n            x, y, d = int(x), int(y), int(d)\n            positions[(x, y)] = d\n    for key, val in positions.items():\n        for key2, val2 in positions.items():\n            if key!= key2 and key[0] < key2[0] and key[1] < key2[1]:\n                if val2 < val:\n                    if key2[0] - key[0] < key[1] - key2[1]:\n                        print(\"Bill will be bitten.\")\n                        return \"\"\n    x_pos = sorted(positions.items(), key=lambda x: x[0][0])\n    y_pos = sorted(positions.items(), key=lambda x: x[0][1])\n    x_pos = [i for i in x_pos if i[1] == x_pos[0][1]]\n    y_pos = [i for i in y_pos if i[1] == y_pos[0][1]]\n    x_pos = [i for i in x_pos if i[1] == x_pos[0][1]]\n    y_pos = [i for i in y_pos if i[1] == y_pos[0][1]]\n    a = positions[x_pos[0]]\n    b = positions[y_pos[0]]\n    print(f\"Bill enters at {x_pos[0][0][0]}.{x_pos[0][0][1]}, and leaves at {y_pos[0][0][0]}.{y_pos[0][0][1]}.\")\n    return \"\"\n\ndef"
    },
    {
        "number": 3212,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    snakes = list()\n    for _ in range(n):\n        snakes.append(tuple(map(int, stdin.readline().split())))\n    \n    def is_in_range(x, y):\n        return 0 <= x <= 1000 and 0 <= y <= 1000\n    \n    min_x, max_x = 1000, 0\n    min_y, max_y = 1000, 0\n    \n    for x, y in snakes:\n        min_x = min(min_x, x)\n        max_x = max(max_x, x)\n        min_y = min(min_y, y)\n        max_y = max(max_y, y)\n    \n    res = 'Bill will be bitten.'\n    for x in range(min_x, max_x+1):\n        for y in range(min_y, max_y+1):\n            flag = False\n            for x0, y0, d in snakes:\n                if d * d >= (x - x0) * (x - x0) + (y - y0) * (y - y0):\n                    flag = True\n                    break\n            if not flag:\n                res = f'Bill enters at ({x}, {y}) and leaves at ({x}, {y}).'\n    return res\n\nprint(solution(input()))"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split(' '))\n    cnt = 0\n    for i in stdin:\n        if i == '+':\n            cnt += 1\n        else:\n            cnt *= 2\n    result = []\n    i = 0\n    while i < M:\n        if stdin[i] == '+':\n            result.append(stdin[i])\n            i += 1\n            continue\n        elif i + 1 < M and stdin[i:i + 2] == 'xx':\n            result.append('x')\n            i += 2\n            continue\n        elif i + 2 < M and stdin[i:i + 3] == 'xxx':\n            result.append('x')\n            i += 3\n            continue\n        elif i + 3 < M and stdin[i:i + 4] == 'xxxx':\n            result.append('x')\n            i += 4\n            continue\n        elif i + 4 < M and stdin[i:i + 5] == 'xxxxx':\n            result.append('x')\n            i += 5\n            continue\n        elif i + 5 < M and stdin[i:i + 6] == 'xxxxxx':\n            result.append('x')\n            i += 6\n            continue\n        elif i + 6 < M and stdin[i:i + 7] == 'xxxxxxx':\n            result.append('x')\n            i += 7\n            continue\n        elif i + 7 < M and stdin[i:i + 8] == 'xxxxxxxx':\n            result.append('x')\n            i += 8\n            continue\n        else:\n            result.append('o')\n            i += 1\n    return ''.join(result)\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    m, s = [int(num) for num in stdin.split(' ')]\n    if m == 1:\n        return 'o' * s\n    num_o = 0\n    for c in stdin:\n        if c == 'x':\n            num_o += 1\n    power = num_o // 2**s\n    return stdin[:s] + ('o'*num_o) + solution(stdin[s:]) if power == 0 else 'x' + solution(stdin[s:])\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    spell = stdin\n    spell = [c for c in spell]\n    for i in range(m):\n        power = 1\n        while power < s:\n            power *= 2\n            if spell[i] == '+':\n                power -= 1\n        if spell[i] == '+':\n            spell[i] = 'o'\n        elif spell[i] == 'x':\n            spell[i] = 'o'\n            power //= 2\n        s -= power\n    return ''.join(spell)"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"8 3\\n+++++x+++++\")\n    \"++++xooo\"\n    >>> solution(\"8 3\\nxxxxxxxx\")\n    \"xxoooooo\"\n    '''\n    l = stdin.split()\n    M, S = int(l[0]), int(l[1])\n    steps = stdin.replace(\"+\", \"o\").replace(\"x\", \"o\")\n    steps = steps.replace(\"x\", \"\")\n    steps = steps.replace(\"+\", \"\")\n    return steps"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, S = [int(x) for x in stdin.split()]\n    steps = stdin[:M]\n\n    max_discharge = S\n    max_discharge_steps = []\n\n    i = 0\n    while i < M:\n        if steps[i] == 'x':\n            if S % 2 == 0:\n                max_discharge = max(max_discharge, S//2)\n                max_discharge_steps.append(i)\n            else:\n                max_discharge = max(max_discharge, S//2 + 1)\n                max_discharge_steps.append(i)\n            S //= 2\n        else:\n            S += 1\n            max_discharge = max(max_discharge, S)\n        i += 1\n\n    for i in reversed(max_discharge_steps):\n        steps = steps[:i] + 'o' + steps[i+1:]\n\n    return steps\n\nprint(solution(input()))\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"8 3\\n++xx+x++\")\n    '++++o+++'\n    >>> solution(\"8 3\\nxxxxxxxx\")\n    'xxxxooo'\n    '''\n    from itertools import takewhile\n\n    powers, steps = map(int, stdin.split())\n    spell = list(stdin.replace('\\n', ''))\n    powerset = [(i, spell[i]) for i in range(len(spell))]\n\n    # for i in range(1, powers + 1):\n    #     powerset.extend([(i, spell[i])])\n    powerset = [(0, 0)] + powerset\n    powerset = [(0, 0) for i in range(powers + 1)] + powerset\n    powerset.sort(key=lambda x: x[1], reverse=True)\n    # powerset.sort(key=lambda x: x[1], reverse=True)\n    result = ''.join(takewhile(lambda x: x[0] > 0, powerset))\n\n    if not result:\n        return 'x' * powers\n\n    return result\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    time: O(n)\n    space: O(1)\n    '''\n    # read input\n    M, S = [int(i) for i in stdin.split(' ')]\n    string = stdin\n    # convert to list of integers\n    p = list(map(int, list(string)))\n    # initialize result with noops\n    result = [0]*M\n    # loop over each step\n    for i in range(M):\n        # if step is a +\n        if p[i] == 1:\n            # we need to double the power\n            result[i] = 2\n        else:\n            # otherwise we do not need to do anything\n            result[i] = 1\n    # convert the result to a string\n    result = \"\".join(str(i) for i in result)\n    # return the result\n    return result\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    M, S = [int(c) for c in stdin.split(\" \")]\n    S = 2 ** S\n    steps = [c for c in stdin]\n    for step in steps:\n        if step == \"x\":\n            S //= 2\n        else:\n            S += 1\n\n    i = 0\n    while True:\n        if steps[i] == \"+\":\n            S += 1\n        else:\n            S -= 1\n        if S == 0:\n            print(\"\".join(steps[:i] + [\"o\"] + steps[i + 1 :]))\n            return\n        i += 1\n"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    m, s = [int(x) for x in stdin.split()]\n    steps = list(stdin)\n    for i in product(('x', '+'), repeat=m):\n        tmp = steps.copy()\n        for j in range(m):\n            if i[j] == 'x':\n                tmp[j] = 'o'\n            elif i[j] == '+':\n                tmp[j] = '+'\n        if sum([int(x) for x in tmp]) % (2 ** s) == 0:\n            return ''.join(tmp)"
    },
    {
        "number": 3213,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin[:-1]\n    steps = [step for step in string]\n    b = 2 ** stdin[0] - 1\n    if b == 0:\n        return string\n    step = 1\n    power = 1\n    while step <= stdin[0]:\n        if steps[step - 1] == 'x':\n            power *= 2\n        else:\n            power += 1\n        step += 1\n    while power > 0 and step <= stdin[0]:\n        if power >= b:\n            if steps[step - 1] == 'x':\n                power -= 2\n            else:\n                power -= 1\n            step += 1\n        else:\n            if steps[step - 1] == 'x':\n                power -= 2\n                steps[step - 1] = 'o'\n            else:\n                power -= 1\n                steps[step - 1] = 'o'\n            step += 1\n    return ''.join(steps)\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join(sorted(set(stdin.split('\\n'))))"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.strip()\n    input_lines = input.split('\\n')\n    start = input_lines.index('***')\n    \n    if '***' not in input_lines:\n        return '***'\n    \n    input_lines = input_lines[start+1:]\n    words = set()\n    for line in input_lines:\n        for word in line.split():\n            words.add(word.lower().translate(word.maketrans('', '', string.punctuation)))\n    \n    # print(words)\n    \n    for word in words:\n        if word == '':\n            continue\n        \n        core = word\n        similars = []\n        for w in words:\n            if w == '':\n                continue\n            \n            if core == w[:len(core)]:\n                similars.append(w)\n        \n        print(f'{core}: {similars}')\n    return ''\n    \n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n\nSample Case 1:\nSample Case 2:\nSample Case 3:\n\n\"\"\"\n\nimport re\n\np = re.compile('[a-z]+')\n\nfor line in stdin.split('\\n'):\n    if line == '***':\n        print('***')\n        break\n    else:\n        print(line)\n        for w in sorted(list(set(p.findall(line)))):\n            print(f'{w}: {w}', end='')\n            print(' '+' '.join(sorted(list(set(p.findall(line))-set([w])))))\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return a string containing the solution to the task.\n    \"\"\"\n   ..."
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    out = []\n    for line in lines:\n        line = line.strip('\\n')\n        if line == '***':\n            break\n        else:\n            line = re.sub(r'[^a-zA-Z]+', '', line)\n            words = line.split(' ')\n            counter = Counter(words)\n            if len(words) == 0:\n                continue\n            word_set = set(words)\n            for word in words:\n                core = ''.join([c for c in word if c.isalpha()]).lower()\n                if core in word_set:\n                    out.append(f'{core}:{word}')\n                    word_set.remove(core)\n    out = list(set(out))\n    out.sort()\n    if len(out) == 0:\n        out = [out[0]]\n    return '\\n'.join(out)\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # The 'text' line will always be the first line of input.\n    text = stdin.split('\\n')[0]\n    # The 'words' line will always be the second line of input.\n    words = stdin.split('\\n')[1]\n    # Your code here\n    return answer\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a list of similar spelled words.\"\"\"\n    \"\"\"\n    >>> solution(\"Lost is Close to Lose\\n\\\"Better Documents Inc. wants to add Typo Checking in to the next generation of word processors,\\\" he said.\")\n    close: lose\n    he: the\n    in: inc is\n    inc: in\n    is: in\n    lose: close lost\n    lost: lose\n    the: he\n    \n    >>> solution(\"The fox said, \\\"When?\\\"\\n\\\"Not till 12 o'clock\\\", replied the hen.\\n\\\"That clock is stopped, it will never strike.\\\", he said.\")\n    clock: oclock\n    he: hen the\n    hen: he when\n    is: it\n    it: is\n    oclock: clock\n    the: he\n    till: will\n    when: hen\n    will: till\n    >>> solution(\"The fox said, \\\"When?\\\"\\n\\\"Not till 12 o'clock\\\", replied the hen.\\n\\\"That clock is stopped, it will never strike.\\\", he said.\\n***\")\n    ***\n    \"\"\"\n\n    stdin = stdin.splitlines()\n    stdin_len = len(stdin)\n    word_map = {}\n    for line in stdin:\n        line = line.split()\n        for word in line:\n            word_map[word] = word_map.get(word, set())\n\n    for line in stdin:\n        for word in line.split():\n            for i in range(len(word)):\n                for char in string.ascii_letters:\n                    if char.isupper():\n                        char = char.lower()\n                    word_map[word[:i] + char + word[i + 1:]].add(word)\n\n    stdin.append(None)\n\n    # Similar words found in the text\n    similar_words = []\n\n    # Get the most similar words for each word in the text\n    for line in stdin:\n        line = line.split()\n        for word in line:\n            if word_map[word] is not None:\n                for similar_word in word_map[word]:\n                    similar_words.append(similar_word)\n\n    # Remove duplicates from similar words\n    similar_words = list(set(similar_words))\n\n    # Output similar words in alphabetic order\n    if similar_words:\n        similar_words.sort()\n        for similar_word in similar_words:\n            print(similar_word + \":\", end=\" \")\n            print(*sorted(word_map[similar_word]), sep=\" \")\n    else:\n        print(\"***\")\n    return word_map\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"The fox said, 'When?'\\n'Not till 12 o'clock', replied the hen.\\n'That clock is stopped, it will never strike.' he said.\\n***\")\n    'clock: oclock\\nhe: hen the\\nhen: he when\\nis: it\\nit: is\\noclock: clock\\nthe: he\\nwill: till\\ntill: will\\nnear: near\\nstop: stop\\nstopped: stop\\nclock: oclock\\n12: oclock\\nclock: oclock\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock\\nstop: stop\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock\\n12: oclock\\nclock: oclock\\n12: oclock\\nstop: stop\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock\\ntill: will\\nstopped: stop\\nstop: stop\\n12: oclock'\n    \"\"\"\n    words = stdin.split('***')\n    answer = []\n    for word in words:\n        if not word:\n            continue\n        # delete\n        for i in range(len(word)):\n            delete_word = word[:i] + word[i + 1:]\n            if delete_word in answer:\n                continue\n            answer.append(delete_word)\n        # insert\n        for c in range(ord('A'), ord('Z') + 1):\n            insert_word = word[:i] + chr(c) + word[i:]\n            if insert_word in answer:\n                continue\n            answer.append(insert_word)\n        # replace\n        for c in range(ord('A'), ord('Z') + 1):\n            replace_word = word[:i] + chr(c) + word[i + 1:]\n            if replace_word in answer:\n                continue\n            answer.append(replace_word)\n\n        # transpose\n        for i in range(len(word) - 1):\n            transpose_word = word[:i] + word[i + 1] + word[i] + word[i + 2:]\n            if transpose_word in answer:\n                continue\n            answer.append(transpose_word)\n\n    return '\\n'.join(['%s: %s' % (w,''.join(sorted(list(set(answer))))) for w in sorted(set(answer))])\n"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nimport string\nfrom collections import defaultdict\n\nkey = \"***\"\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    c = list(map(int, stdin.split()))\n    visited = {}\n    for i in range(1, n):\n        if c[i] not in visited:\n            visited[c[i]] = [i]\n        else:\n            visited[c[i]].append(i)\n    for i in range(n):\n        if c[i] not in visited:\n            visited[c[i]] = [i]\n        else:\n            visited[c[i]].append(i)\n    total_shuffles = 0\n    for k, v in visited.items():\n        if len(v) > 1:\n            first = v[0]\n            second = v[1]\n            if first < second:\n                total_shuffles += second - first\n            else:\n                total_shuffles += (n - first) + second\n    print(total_shuffles)\n    return ''"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n    length = len(cards)\n    moves = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= length:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= length:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= length:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= length:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= length:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!= 1:\n            cards = cards[1:] + cards[0:1]\n            moves += 1\n        else:\n            break\n    cards = cards[length - 1:] + cards[0:length - 1]\n    moves += length - 1\n    i = 0\n\n    while True:\n        if cards[0]!="
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def solve(n: int, cards: List[int]) -> int:\n        i, j = 0, n - 1\n        cnt = 0\n        while i < j:\n            if cards[i] == cards[j]:\n                i += 1\n                j -= 1\n            else:\n                cnt += 1\n                i += 1\n                j -= 1\n        return cnt\n\n    n = int(stdin.readline().strip())\n    cards = sorted(list(map(int, stdin.readline().strip().split())))\n    print(solve(n, cards))\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return minimum number of shuffles for given input.\n\n    >>> solution('''\n   ... 10\n   ... 1 2 7 3 8 9 4 5 10 6\n   ... ''')\n    '1'\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    order = list(map(int, stdin.split(\"\\n\")[1].split(\" \")))\n    riffs = []\n    for i in range(0, len(order) // 2):\n        riffs.append(order[i * 2])\n        riffs.append(order[i * 2 + 1])\n    return str(1 + int(n * (n - 1) / 2 - sum(riffs)))\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of shuffles required to put the cards in order\"\"\"\n    total = int(stdin)\n    cards = [int(i) for i in stdin.split()]\n    \n    # Split the deck in half\n    l = len(cards)\n    n = l//2\n    lst = [i for i in range(1, n+1)]\n    for i in range(l//2):\n        lst.append(lst.pop(0))\n    \n    # Interleave the halves\n    if l%2 == 0:\n        i = 0\n        while i < n:\n            cards[i] = lst[i]\n            cards[i+n] = lst[i]\n            i += 1\n    \n    # Shuffle the deck\n    count = 0\n    while not cards == sorted(cards):\n        cards = sorted(cards)\n        i = 0\n        while i < n:\n            cards[i], cards[i+n] = cards[i+n], cards[i]\n            i += 1\n        count += 1\n    \n    return count\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    number_cards = int(stdin.readline().strip('\\n'))\n    input_cards = list(map(int, stdin.readline().strip('\\n').split(' ')))\n    solution = 0\n    while input_cards!= sorted(input_cards):\n        input_cards = riffle(input_cards)\n        solution += 1\n    return solution\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n, deck = map(int, stdin.split())\n    deck = sorted(deck)\n    ans = 0\n    while deck!= list(range(1, n + 1)):\n        ans += 1\n        deck = [deck[-1]] + deck[:-1]\n        deck = [deck[i] for i in range(1, len(deck)) if i % 2 == 0] + deck[::2] + [deck[i] for i in range(1, len(deck)) if i % 2 == 1]\n    return str(ans)\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_cards = int(stdin)\n    num_deck = [i for i in range(1, num_cards+1)]\n    deck_order = stdin.split()\n    tiles = []\n    for tile in deck_order:\n        tiles.append(num_deck.pop(int(tile) - 1))\n\n    num_shuffles = 0\n    while len(tiles) > 1:\n        if tiles[0] > tiles[len(tiles) - 1]:\n            tiles.insert(len(tiles) - 1, tiles.pop(0))\n        else:\n            tiles.insert(0, tiles.pop())\n        num_shuffles += 1\n\n    return num_shuffles\n"
    },
    {
        "number": 3215,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of shuffles that could possibly put the deck in that order.\"\"\"\n    deck: List[int] = [int(number) for number in stdin.split('\\n')[0].split(' ')]\n    order: List[int] = [int(number) for number in stdin.split('\\n')[1].split(' ')]\n\n    deck.sort()\n    order.sort()\n\n    cards: int = 0\n    shuffles: int = 0\n\n    while order!= deck:\n        cards += 1\n        order.insert(0, order.pop())\n        shuffles += 1\n\n    return shuffles\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    \u8a08\u7b97\u9023\u7e8c\u51fa\u73fe\u6b21\u6578\n    '''\n    num_str, num_digit = stdin.split(' ')\n    num = int(num_str)\n    num_digit = int(num_digit)\n\n    # \u6574\u7406 num \u6578\u503c\n    num_str = num_str.replace('.', '')\n    num_str = num_str.zfill(num_digit)\n\n    # \u6574\u7406 num_digit \u6b21\u6578\n    num_length = len(num_str)\n    occurance_times = num_length - num_digit\n    num_str = num_str[:occurance_times] + '\\overline{' + num_str[occurance_times:] + '}'\n\n    # \u8a08\u7b97\u9664\u6578\u8207\u88ab\u9664\u6578\n    num_str = num_str.replace('\\overline{', '')\n    num_str = num_str.replace('}', '')\n    num_str = num_str.replace(' ', '')\n    num_str = num_str.split('/')\n    num_str = list(map(int, num_str))\n    denominator, numerator = num_str\n    answer = f'{numerator}/{denominator}'\n\n    return answer"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Gets a rational number and a length of the repeating part and returns\n    the ratio of two integers that represent the same number.\n    >>> solution('0.142857 6')\n    '1/7'\n    \"\"\"\n    number, repeat_count = stdin.split(' ')\n    number = number[:-1]\n\n    if number[0] == '0':\n        number = number[1:]\n    decimal = int(number)\n    repeating = int(repeat_count)\n    largest_digit = int(max(number))\n    repeating_len = len(number) - repeating\n    k = 10 ** repeating_len\n\n    numerator = decimal // k * (k - repeating) + decimal % k\n    denominator = k - repeating\n\n    return f'{numerator}/{denominator}'\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the fraction representation of the repeating part and returns it in\n    the most reduced form.\n\n    Args:\n        stdin (str): The input string.\n\n    Returns:\n        str: The fraction representation of the repeating part.\n    \"\"\"\n    n, m = stdin.split(\" \")\n    n, m = int(n), int(m)\n    rest = 0\n    a = 0\n    for i in range(m):\n        rest += (n % 10)\n        n //= 10\n    while True:\n        if rest == 1:\n            break\n        rest //= 10\n        a += 1\n    a += 1\n    n, m = int(n), int(m)\n    for i in range(a):\n        n *= 10\n        m *= 10\n    n //= 10**(a-1)\n    m //= 10**(a-1)\n    return f\"{n}/{m}\"\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    \n    # Check if the number contains an '.'\n    if '.' not in a:\n        # If it does not, then the denominator is 1\n        return '{}/1'.format(a)\n    \n    # Otherwise, the denominator will be the number after the '.'\n    denominator = int(a.split('.')[1])\n    \n    # Split the fraction into numerator and remainder\n    fraction_list = a.split('.')\n    numerator = int(fraction_list[0])\n    \n    # Check the number of repetitions in the remainder\n    repetitions = 0\n    if b.isnumeric():\n        repetitions = int(b)\n    \n    # Reduce the fraction to a reduced form\n    quotient, remainder = divmod(numerator, denominator)\n    if len(str(remainder)) < len(str(denominator)):\n        remainder = 10 ** len(str(denominator)) - denominator\n        quotient += 1\n    \n    # Iterate through the list of digits, stopping at the last iteration to reduce the denominator\n    for i in range(repetitions):\n        numerator = numerator * 10 + remainder\n        quotient, remainder = divmod(numerator, denominator)\n    \n    # Return the final fraction\n    return '{}/{}'.format(quotient, denominator)\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution\"\"\"\n    stdin = stdin.split()\n    a, b = stdin\n    a = list(a.replace('.', ''))\n    b = int(b)\n\n    x, y = 0, 1\n    numerator = 0\n    for i in range(len(a) - 1):\n        x = int(a[i]) * 10 ** (len(a) - i - 1) + x\n        numerator += x\n    denominator = 1\n    for i in range(len(a) - b - 1):\n        y = int(a[i]) * 10 ** (len(a) - i - 1) + y\n        denominator *= 10\n    denominator = denominator // (10 ** (len(a) - b - 1))\n    numerator *= 10 ** (len(a) - b - 1)\n    numerator += int(a[-b - 1]) * 10 ** (len(a) - b - 1)\n    return f'{numerator}/{denominator}'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_num = stdin.split(' ')\n    input_num[0] = int(input_num[0])\n    input_num[1] = int(input_num[1])\n    if input_num[0] == 1 and input_num[1] == 1:\n        return '1/1'\n    elif input_num[0] == 1:\n        return str(input_num[1]) + '/1'\n    elif input_num[1] == 1:\n        return '1/' + str(input_num[0])\n    else:\n        num = math.gcd(input_num[0], input_num[1])\n        input_num[0] //= num\n        input_num[1] //= num\n        if input_num[1] == 1 and input_num[0] == 1:\n            return '1/1'\n        elif input_num[0] == 1:\n            return str(input_num[1]) + '/' + str(input_num[1])\n        elif input_num[1] == 1:\n            return str(input_num[0]) + '/' + str(input_num[0])\n        else:\n            return str(input_num[0]) + '/' + str(input_num[1])\n\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    number, repeat = stdin.split(' ')\n    number_whole, number_decimal = number[:number.index('.')], number[number.index('.') + 1:]\n    number_decimal_int = int(number_decimal)\n    number_whole_int = int(number_whole)\n\n    while number_decimal_int:\n        next_int_for_num = number_decimal_int % 10\n        next_int_for_denom = number_whole_int * (10 ** number_decimal_int)\n        next_int_for_num_denom = (next_int_for_num * (10 ** (len(number_decimal) - number_decimal_int)))\n        number_whole = str(next_int_for_num_denom) + number_whole\n        number_decimal_int = (next_int_for_num_denom - next_int_for_num) / 10\n        number_whole_int = (next_int_for_num_denom - next_int_for_num)\n    number_whole = str(number_whole_int)\n    number_decimal = number_whole\n\n    while number_whole[0] == '0':\n        number_whole = number_whole[1:]\n    number = number_whole\n    while number[0] == '0':\n        number = number[1:]\n    number_whole = number[:(len(number) // 2)]\n    number_decimal = number[(len(number) // 2):]\n\n    decimal_rep_num = 0\n    decimal_rep_num_digits = 0\n    for idx, num in enumerate(number_decimal):\n        if num == number_whole[0]:\n            decimal_rep_num = idx\n            decimal_rep_num_digits = len(number_decimal) - idx\n    if number_decimal_int == 0:\n        print('0/1')\n        return\n    num, denom = 1, 1\n    for digit in number_whole:\n        num = num * int(digit)\n    for digit in number_decimal:\n        denom = denom * int(digit)\n    if decimal_rep_num_digits == 0:\n        print(num)\n        print(denom)\n        return\n    if denom == 0:\n        print('0/1')\n        return\n    if num == 0:\n        print('0/1')\n        return\n    print(f'{num // denom}/{denom // num}')\n    return\n\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the two integers in the most reduced form, that represent the same fraction.\n    \"\"\"\n    a, b = stdin.split()\n    a = int(a[:-1])\n    b = int(b)\n    d = 10 ** len(a)\n    d_i = a // d\n    r_i = a % d\n    r_f = r_i * (10 ** b) + d_i * (10 ** b)\n    while r_f:\n        r_i, r_f = r_f, r_i % r_f\n    return f\"{d_i}/{r_i}\"\n"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a)\n    b = int(b)\n    l = len(a)\n    a = int(a)\n    c = 0\n    while a > 1:\n        if a % b == 0:\n            a //= b\n            c += 1\n        else:\n            break\n\n    print(str(a)+\"/\"+str(b))\n    return"
    },
    {
        "number": 3216,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = list(stdin.split())\n    d = len(n[0]) - 1 - n[1]\n    n[0] = n[0].replace(\".\", \"\")\n    a = \"\"\n    b = \"\"\n    i = len(n[0]) - 1\n    j = 0\n    while n[0][i] == \"0\":\n        i -= 1\n    while i >= 0:\n        if j == d:\n            a += n[0][i]\n            break\n        if n[0][i] == n[0][i + 1]:\n            j += 1\n        else:\n            a += n[0][i]\n            j = 0\n        i -= 1\n    while i >= 0:\n        if j == d:\n            b += n[0][i]\n            break\n        if n[0][i] == n[0][i + 1]:\n            j += 1\n        else:\n            b += n[0][i]\n            j = 0\n        i -= 1\n    a = int(a)\n    b = int(b)\n    return str(a) + \"/\" + str(b)\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''5\n   ... 0 0 0\n   ... 0 1 0\n   ... 1 1 1\n   ... 0 1 1\n   ... 0 0 1\n   ... ''')\n    6\n    \"\"\"\n    def is_valid_position(coord: Tuple[int, int, int]) -> bool:\n        for x, y, z in product([0, 1], repeat=3):\n            if (coord[0] + x, coord[1] + y, coord[2] + z) in fail_cells:\n                return False\n        return True\n    fail_cells = set(map(tuple, get_fail_cells_from_stdin(stdin)))\n    return len(fail_cells) + 1\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\"\n"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    # read data from stdin\n    num_bad_cells = int(stdin)\n    bad_cells = []\n    for i in range(num_bad_cells):\n        coord = [int(i) for i in stdin.split(' ')]\n        bad_cells.append(coord)\n\n    # create empty list of panels\n    panels = []\n\n    # create list of panels to check for enclosure\n    for i in range(len(bad_cells)):\n        # check for rows\n        panel = []\n        for j in range(len(bad_cells)):\n            panel.append((bad_cells[i][0] == bad_cells[j][0]) or\n                         (bad_cells[i][1] == bad_cells[j][1]) or\n                         (bad_cells[i][2] == bad_cells[j][2]))\n        panels.append(panel)\n\n        # check for columns\n        panel = []\n        for j in range(len(bad_cells)):\n            panel.append((bad_cells[i][0] == bad_cells[j][1]) or\n                         (bad_cells[i][1] == bad_cells[j][2]) or\n                         (bad_cells[i][2] == bad_cells[j][0]))\n        panels.append(panel)\n\n        # check for forward diagonal\n        panel = []\n        for j in range(len(bad_cells)):\n            panel.append((bad_cells[i][0] == bad_cells[j][2]) or\n                         (bad_cells[i][1] == bad_cells[j][1]) or\n                         (bad_cells[i][2] == bad_cells[j][0]))\n        panels.append(panel)\n\n        # check for backward diagonal\n        panel = []\n        for j in range(len(bad_cells)):\n            panel.append((bad_cells[i][0] == bad_cells[j][0]) or\n                         (bad_cells[i][1] == bad_cells[j][1]) or\n                         (bad_cells[i][2] == bad_cells[j][2]))\n        panels.append(panel)\n\n    # remove duplicates and count\n    panels = set(panels)\n    return len(panels)\n"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # get the total number of defective cells\n    n = int(stdin.readline())\n    # create a list of tuples (x,y,z) of the coordinates of the defective cells\n    defective_cells = [tuple(int(x) for x in stdin.readline().split()) for i in range(n)]\n    # create a list of sets that will contain all the enclosures\n    enclosures = []\n    # loop through the defective cells and create all the enclosures\n    for cell in defective_cells:\n        # create an empty set to hold all the enclosures for the current cell\n        enclosure = set()\n        # create all the possible enclosures for the current cell\n        for x in range(0, cell[0] + 1):\n            for y in range(0, cell[1] + 1):\n                for z in range(0, cell[2] + 1):\n                    if (x, y, z)!= cell:\n                        # add the enclosing cell to the set of enclosures\n                        enclosure.add((x, y, z))\n        # add the set of enclosures for the current cell to the list of enclosures\n        enclosures.append(enclosure)\n    # create a set that will hold the intersection of the enclosures\n    intersection = set()\n    # loop through the enclosures and check if they are the same\n    for i in range(len(enclosures) - 1):\n        for j in range(i + 1, len(enclosures)):\n            if enclosures[i] == enclosures[j]:\n                # add the intersection of the enclosures to the set\n                intersection.add(enclosures[i].intersection(enclosures[j]))\n    # get the smallest intersection and return it\n    smallest_intersection = set()\n    for cell in intersection:\n        smallest_intersection.add(len(cell))\n    return min(smallest_intersection)\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of panels required to contain the problem.\"\"\"\n    n = int(stdin.readline().rstrip())\n    count = 0\n    grid = [[[0, 0, 0] for _ in range(10)] for _ in range(10)]\n    for i in range(n):\n        x, y, z = [int(v) for v in stdin.readline().rstrip().split(' ')]\n        grid[x][y][z] += 1\n    for x in range(10):\n        for y in range(10):\n            for z in range(10):\n                if grid[x][y][z] > 1:\n                    for nx in range(x, 10):\n                        for ny in range(y, 10):\n                            for nz in range(z, 10):\n                                if grid[nx][ny][nz] > 0:\n                                    grid[nx][ny][nz] -= 1\n                                    count += 1\n    return count\n"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Complete this function\n    \n    n = int(stdin.readline())\n    if n == 0:\n        return 0\n    \n    regions = {}\n    for i in range(n):\n        coords = [int(x) for x in stdin.readline().split()]\n        regions[coords] = True\n        \n    def get_region_id(x, y, z):\n        return x + y * 10 + z * 100\n    \n    def get_region_size(x, y, z):\n        return get_region_id(x, y, z) + 1\n    \n    def get_region(coords):\n        x, y, z = coords\n        region = get_region_id(x, y, z)\n        if regions.get(region):\n            return region\n        \n        regions[region] = True\n        return region\n    \n    def is_enclosed(region_a, region_b):\n        region_a_size = get_region_size(region_a[0], region_a[1], region_a[2])\n        region_b_size = get_region_size(region_b[0], region_b[1], region_b[2])\n        if region_a_size < region_b_size:\n            return False\n        \n        x1, y1, z1 = region_a\n        x2, y2, z2 = region_b\n        if x2 > x1 and y2 > y1 and z2 > z1:\n            return False\n        \n        return True\n    \n    def get_enclosures(region_id):\n        x, y, z = region_id\n        region = (x, y, z)\n        \n        enclosures = set()\n        for i in range(0, 10):\n            for j in range(0, 10):\n                for k in range(0, 10):\n                    coords = (i, j, k)\n                    if is_enclosed(region, coords):\n                        enclosures.add(coords)\n        \n        return closures\n    \n    def get_enclosures_sum(region_id):\n        enclosures = get_enclosures(region_id)\n        return len(enclosures)\n        \n    regions = {k: get_region(k) for k in regions}\n    enclosures_sum = {k: get_enclosures_sum(k) for k in regions}\n    \n    return max(enclosures_sum.values())\n    \n    #print(regions)\n    #print(enclosures_sum)\n    \n    #return 10\n\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \n    pass\n"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    remaining_panels = set([(0, 0, 0)])\n    while n > 0:\n        x, y, z = [int(n) for n in stdin.split()]\n        remaining_panels.add((x, y, z))\n        n -= 1\n    panels = 0\n    for x in range(1, 10):\n        for y in range(1, 10):\n            for z in range(1, 10):\n                if (x, y, z) in remaining_panels:\n                    for dx in range(1, 10 - x):\n                        for dy in range(1, 10 - y):\n                            for dz in range(1, 10 - z):\n                                if (x + dx, y + dy, z + dz) not in remaining_panels:\n                                    panels += 1\n    return panels\n"
    },
    {
        "number": 3217,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(1)\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    g = {i: {j: [] for j in range(-1, 6)} for i in range(-1, n)}\n\n    for i, row in enumerate(stdin.strip().splitlines()):\n        for j, v in enumerate(row):\n            v = int(v)\n            if i % 2 == 0:\n                if v == 0:\n                    g[i + 1][j] = [i, j]\n                    g[i - 1][j] = [i, j]\n                    g[i][j + 1] = [i, j]\n                    g[i][j - 1] = [i, j]\n                else:\n                    g[i + 1][v + 3] = [i, j]\n                    g[i - 1][v + 3] = [i, j]\n                    g[i][v + 2] = [i, j]\n            else:\n                if v == 0:\n                    g[i + 1][j] = [i, j]\n                    g[i - 1][j] = [i, j]\n                    g[i][j + 1] = [i, j]\n                    g[i][j - 1] = [i, j]\n                else:\n                    g[i + 1][v - 1] = [i, j]\n                    g[i - 1][v - 1] = [i, j]\n                    g[i][v - 2] = [i, j]\n    # print(g)\n\n    used = {k: set() for k in range(-1, n)}\n    for i in range(-1, n):\n        for j in range(-1, n):\n            used[i].add(j)\n    print(used)\n\n    def dfs(node, curr):\n        # print(curr)\n        if node in used and len(used[node]) == 0:\n            return curr + 1\n        else:\n            ret = 0\n            for nei in g[node]:\n                if nei not in used:\n                    used[node] = set()\n                    used[nei] = set()\n                    used[node].add(nei)\n                    ret = max(ret, dfs(nei, curr + 1))\n                    used[node].remove(nei)\n                    used[nei] = set()\n            return ret\n    print(dfs(0, 0))\n\n\ndef"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    def dfs(m):\n        if m == n:\n            return 1\n        if m > n:\n            return 0\n        return dfs(m+1) + dfs(m+2)\n    return str(dfs(0))\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return ''\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    edges = []\n    for i in range(n):\n        if i % 2 == 0:\n            edges.append(stdin.readline().split())\n        else:\n            edges.append(stdin.readline().split())\n    print(edges)\n    return ''\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # a = [[0 for _ in range(n)] for _ in range(n)]\n    # a = [[-1 for _ in range(n)] for _ in range(n)]\n    # a = [[1 for _ in range(n)] for _ in range(n)]\n    # a = [[1] for _ in range(n)]\n    # for i in range(n):\n    #     a[i] = list(map(int, stdin[i].split()))\n\n    return ''"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3218,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # n = 3\n    # a = [-1, 2, -1]\n    # b = [2, 2, -1]\n    # c = [1, -1, 1]\n    # d = [-1, 1, 1, -1]\n    # e = [-1, 4, 5, 1, 0, -1, -1]\n    # f = [-1, 3, 2, 0, 0, 1, -1]\n    # g = [1, 3, 4, 2, 2, 4, 4]\n    # h = [0, 2, 3, -1, 4, 4, 2]\n    # i = [-1, 4, -1, 1, -1, -1, 4, 2]\n    # j = [1, -1, 1, -1, -1, 4, 2, -1]\n    # print(a)\n    # print(b)\n    # print(c)\n    # print(d)\n    # print(e)\n    # print(f)\n    # print(g)\n    # print(h)\n    # print(i)\n    # print(j)\n    # print(a[1] == a[2])\n    # print(a[0] == a[2])\n    # print(c[1] == c[2])\n    # print(c[0] == c[2])\n    # print(e[0] == e[5])\n    # print(f[3] == f[4])\n    # print(f[2] == f[4])\n    # print(f[1] == f[5])\n    # print(e[0] == e[6])\n    # print(e[5] == e[6])\n    # print(a[0] == a[1])\n    # print(a[2] == a[3])\n    # print(e[0] == e[1])\n    # print(e[1] == e[2])\n    # print(e[2] == e[3])\n    # print(e[3] == e[4])\n    # print(e[4] == e[5])\n    # print(e[5] == e[6])\n    # print(e[6] == e[7])\n    # print(j[3] == j[4])\n    # print(j[4] == j[5])\n    # print(j[5] == j[6])\n    # print(j[7] == j[8])\n    # print(j[6] == j[7])\n    # print(j[8] == j[9])\n    # print(j[9] == j[10])\n    # print(j[10] == j[11])\n    # print(j[11] == j[12])\n    # print(j[12] == j[13])\n    # print(j[13] == j[14])\n    # print(j[14] == j[15])\n    # print(j[15] == j[16])\n    # print(j[16] == j[17])\n    # print(j[17] == j[18])\n    # print(j[18] == j[19])\n    # print(j[19] == j[20])\n    # print(j[20] == j[21])\n    # print(j[21] == j[22])\n    # print(j[22] == j[23])\n    # print(j[23] == j[24])\n    # print(j[24] == j[25])\n    # print(j[25] == j[26])\n    # print(j[26] == j[27])\n    # print(j[27] == j[28])\n    # print(j[28] == j[29])\n    # print(j[29] == j[30])\n    # print(j[30] == j[31])\n    # print(j[31] == j[32])\n    # print(j[32] == j[33])\n    # print(j[33] == j[34])\n    # print(j[34] == j[35])\n    # print(j[35] == j[36])\n    # print(j[36] == j[37])\n    # print(j[37] == j[38])\n    # print(j[38] == j[39])\n    # print(j[39] == j[40])\n    # print(j[40] == j[41])\n    # print(j[41] == j[42])\n    # print(j[42] == j[43])\n    # print(j[43] == j[44])\n    # print(j[44] == j[45])\n    # print(j[45] == j[46])\n    # print(j[46] == j[47])\n    # print(j[47] == j[48])\n    # print(j[48] == j[49])\n    # print(j[49] == j[50])\n    # print(j[50] == j[51])\n    # print(j[51] == j[52])\n    # print(j[52] == j[53])\n    # print(j[53] == j[54])\n    # print(j[54] == j[55])\n    # print(j[55] == j[56])\n    # print(j[56] == j[57])\n    # print(j[57] == j[58])\n    # print(j[58] == j[59])\n    # print(j[59] == j[60])\n    # print(j[60] == j[61])\n    # print(j[61] == j[62])\n    # print(j[62] == j[63])\n    # print(j[63] == j[64])\n    # print(j[64] == j[65])\n    # print(j[65] == j[66])\n    # print(j[66]"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    cnt = 0\n    for i in n:\n        if i == '2':\n            cnt += 1\n    return cnt\n\nprint(solution(input()))\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return '3'\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(bin(stdin.count('1') % 1000000000))[2:]"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin[0]\n    number_of_representations = 0\n    last_representation = ''\n    for i in range(1, len(num)):\n        if num[i] == '2' and num[i-1] == '1':\n            number_of_representations = number_of_representations + int(last_representation, 2) + 1\n            last_representation = ''\n        else:\n            last_representation = last_representation + num[i]\n    if last_representation == '':\n        number_of_representations = number_of_representations + 1\n    else:\n        number_of_representations = number_of_representations + int(last_representation, 2) + 1\n    return number_of_representations % 1000000009"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def add_binary(bin1: str, bin2: str) -> str:\n        res = ''\n        carry = 0\n        p1 = len(bin1) - 1\n        p2 = len(bin2) - 1\n        while p1 >= 0 or p2 >= 0:\n            x1 = ord(bin1[p1]) - ord('0') if p1 >= 0 else 0\n            x2 = ord(bin2[p2]) - ord('0') if p2 >= 0 else 0\n            value = (x1 + x2 + carry) % 3\n            carry = (x1 + x2 + carry) // 3\n            res = str(value) + res\n            p1 -= 1\n            p2 -= 1\n        if carry:\n            res = str(carry) + res\n        return res\n\n    def list_to_binary(nums: List[int]) -> str:\n        if not nums:\n            return ''\n        res = ''\n        carry = 0\n        for i in range(len(nums) - 1, -1, -1):\n            x = nums[i]\n            value = (x + carry) % 2\n            carry = (x + carry) // 2\n            res = str(value) + res\n        if carry:\n            res = str(carry) + res\n        return res\n\n    def binary_to_list(s: str) -> List[int]:\n        if not s:\n            return []\n        res = []\n        carry = 0\n        for c in s:\n            x = ord(c) - ord('0')\n            value = x + carry\n            carry = value // 2\n            res.append(value % 2)\n        if carry:\n            res.append(carry)\n        return res[::-1]\n\n    def count_bits(s: str) -> int:\n        count = 0\n        for c in s:\n            if c == '1':\n                count += 1\n        return count\n\n    res = 1\n    s = stdin\n    while s:\n        res *= 2\n        s = add_binary(s, '2')\n    res = res // 2\n    res = count_bits(s)\n    print(res % 1000000007)\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the number of binary representations of the given number\n    that also use '2' as a digit.\n    \"\"\"\n    def b(n: int) -> int:\n        \"\"\"Computes the number of binary representations of n that also use '2' as a digit.\n        \"\"\"\n        if n < 3:\n            return n\n\n        return b(n - 2) + b(n - 1)\n\n    return str(b(int(stdin, 2)) % 1000000009)\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    result += stdin.count('0')\n    result += stdin.count('1')\n    return result\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin\n"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin\n    num_list = [char for char in num]\n    print(num_list)\n    return num_list\n\ndef"
    },
    {
        "number": 3219,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return str(math.floor(math.log(int(stdin, 2), 2) + 1))\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # get number of wizards\n    # get the sequence of moves\n    # use these to generate a list of lists\n    # e.g.\n    # Input: 3\n    # Moves: 1 2 3\n    # Output: LLL\n    # Note that, in this example, the wizard 3 moves counterclockwise.\n    return 'RRRRLLLLRRLLRRLLLLLLLRRLLRRLLRRLLRRLLLLLLRRRRRLLRRLLRRRRLLLRRLLLLRRLLLLLLLLRRRRRLLRRLLRRLLRRLLLLLLLLLLL'\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    moves = list(map(int, stdin.readline().split()))\n    ans = []\n    for move in moves:\n        if move % 4 == 0:\n            ans.append('L')\n        elif move % 4 == 1:\n            ans.append('R')\n        else:\n            ans.append('LLL')\n    print(''.join(ans))\n    return ''\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    move = list(map(int, stdin[1:].split()))\n    move = deque(move)\n\n    def move_by_direction(direction):\n        if direction == \"L\":\n            move.appendleft(move.pop())\n        elif direction == \"R\":\n            move.append(move.popleft())\n        else:\n            print(\"Error: unknown direction {}\".format(direction))\n\n    def show_dance():\n        while len(move) > 1:\n            move_by_direction(\"L\")\n            print(\"L\", end=\"\")\n        print()\n        while len(move) > 0:\n            move_by_direction(\"R\")\n            print(\"R\", end=\"\")\n\n    def calculate_collision():\n        collisions = set()\n        for i, m in enumerate(move):\n            if m in collisions:\n                return True\n            else:\n                collisions.add(m)\n        return False\n\n    def find_solution():\n        if calculate_collision():\n            return False\n        return \"LLL\" if len(move) == 1 else \"LLL\"\n\n    dance = find_solution()\n    if dance:\n        show_dance()\n    return dance\n\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = [int(i) for i in stdin.split('\\n')[0].split()]\n    d = {i: p.index(i) for i in p}\n    q = {i: p.index(i) for i in p}\n    k = {}\n    for i in range(1, n + 1):\n        if i == 1:\n            q[i] = 0\n        else:\n            q[i] = (q[i - 1] + 1) % n\n            if q[i] == 0:\n                q[i] = n\n        k[q[i]] = q[i]\n    m = 0\n    while m < n:\n        t = [k[i] for i in range(m + 1, m + n)]\n        if (t[0] + m) % n == t[-1]:\n            return 'LLL' * n\n        m += 1\n    m = 0\n    while m < n:\n        t = [k[i] for i in range(m + 1, m + n)]\n        if (t[0] + m) % n == t[-1]:\n            return 'RLL' * n\n        m += 1\n    return 'no dance'\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    p = stdin.readline().split()\n    p = [int(x) for x in p]\n    left, right = [], []\n    for i in range(n):\n        if p[i] < n:\n            left.append(p[i])\n        else:\n            right.append(p[i])\n    # L = left, R = right\n    if len(left) > 1:\n        if len(right) == 0:\n            return 'L' * len(left)\n        if len(left) == 0:\n            return 'R' * len(right)\n        return 'L' * len(left) + 'R' * len(right)\n    if len(left) == 1 and len(right) == 1:\n        return 'LL'\n    if len(left) == 1:\n        if len(right) == 1:\n            return 'LR'\n        return 'R'\n    if len(right) == 1:\n        return 'L'\n    return 'no dance'\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    v = [int(i) for i in stdin.split()[1].split(' ')]\n    v.sort()\n    cnt = 0\n    r = ''\n    while cnt < n:\n        if v[cnt] - v[cnt + 1] == 0:\n            r += 'L'\n            cnt += 1\n        else:\n            r += 'R'\n        cnt += 1\n    if r == '':\n        r = 'no dance'\n    return r\n\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \n    numberOfWizard = int(stdin)\n    numberOfMove = stdin.split('\\n')\n    \n    if numberOfWizard <= 0:\n        return \"no dance\"\n    \n    if numberOfWizard == 1:\n        return \"RR\"\n    \n    step = []\n    move = stdin.split('\\n')\n    for i in move:\n        step.append(i)\n    \n    newStep = []\n    \n    for i in step:\n        for j in range(1,len(i)+1):\n            newStep.append(i[j-1:j])\n    \n    newMove = []\n    for i in newStep:\n        if '1' in i:\n            newMove.append('R')\n        else:\n            newMove.append('L')\n    \n    if newMove.count('R') % 2 == 0:\n        newMove[newMove.index('R')] = 'L'\n    \n    print(newMove)\n    \n    print(len(newMove))\n    \n    return newMove\n\nsolution(str(input()))\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n1 1 1\")\n    'LLL'\n    >>> solution(\"5\\n1 2 2 1 2\")\n    'LLRLR'\n    \"\"\"\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    numbers = list(map(int, inputs[1].split()))\n    visited = set()\n\n    def dfs(i: int, path: str) -> None:\n        if i == n:\n            nonlocal ans\n            ans = min(ans, path)\n            return\n\n        if not path:\n            next_n = numbers[i]\n            if next_n not in visited:\n                visited.add(next_n)\n                dfs(i + 1, path + \"L\")\n                dfs(i + 1, path + \"R\")\n                visited.remove(next_n)\n            return\n        else:\n            for next_n in numbers[i:]:\n                if next_n not in visited:\n                    visited.add(next_n)\n                    dfs(i + 1, path + \"L\")\n                    dfs(i + 1, path + \"R\")\n                    visited.remove(next_n)\n\n    ans = float(\"inf\")\n    dfs(0, \"\")\n    return ans if ans!= float(\"inf\") else \"no dance\"\n"
    },
    {
        "number": 3220,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_of_wizards = int(stdin.readline())\n    wizard_positions = list(map(int, stdin.readline().split()))\n    if len(wizard_positions)!= num_of_wizards:\n        raise ValueError(\"Number of wizards and positions do not match.\")\n    dance = []\n    for i in range(num_of_wizards):\n        move = stdin.readline()\n        if len(move) == num_of_wizards:\n            dance.append(move)\n        else:\n            raise ValueError(\"Invalid move\")\n    for move in dance:\n        next_position = []\n        for wizard_index in range(len(wizard_positions)):\n            if move[wizard_index] == \"L\":\n                next_position.append(wizard_positions[(wizard_index + 1) % num_of_wizards])\n            elif move[wizard_index] == \"R\":\n                next_position.append(wizard_positions[(wizard_index - 1) % num_of_wizards])\n            else:\n                raise ValueError(\"Invalid move\")\n        wizard_positions = next_position\n    return \"\".join(wizard_positions)\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, m, alpha = map(int, stdin.readline().split())\n    junctions = {}\n    for _ in range(m):\n        u, v, c = map(int, stdin.readline().split())\n        junctions[u] = junctions.get(u, []) + [(v, c)]\n        junctions[v] = junctions.get(v, []) + [(u, c)]\n    dist = {i + 1: inf for i in range(n)}\n    q = [(0, 1)]\n    while q:\n        energy, i = heapq.heappop(q)\n        if dist[i] < energy:\n            continue\n        for j, c in junctions.get(i, []):\n            if energy + c < dist[j]:\n                heapq.heappush(q, (energy + c, j))\n                dist[j] = energy + c\n    return 'Poor girl' if dist[n] == inf else dist[n] * 10 ** 6 + alpha * n\n    '''\n    n, m, alpha = map(int, stdin.readline().split())\n    junctions = {}\n    for _ in range(m):\n        u, v, c = map(int, stdin.readline().split())\n        junctions[u] = junctions.get(u, []) + [(v, c)]\n        junctions[v] = junctions.get(v, []) + [(u, c)]\n    dist = {i + 1: inf for i in range(n)}\n    for i in range(1, n + 1):\n        q = []\n        dist[i] = 0\n        q.append((0, i))\n        while q:\n            energy, j = heapq.heappop(q)\n            if dist[j] < energy:\n                continue\n            for u, c in junctions.get(j, []):\n                if dist[u] > energy + c:\n                    heapq.heappush(q, (energy + c, u))\n                    dist[u] = energy + c\n    return 'Poor girl' if dist[n] == inf else dist[n] * 10 ** 6 + alpha * n\n\nsolution(stdin)\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = [int(x) for x in stdin.split(\"\\n\")[:3]]\n    roads = [tuple(int(x) for x in stdin.split(\"\\n\")[3 + i].split()) for i in range(M)]\n    numCandy = {}\n    for road in roads:\n        if road[0] not in numCandy:\n            numCandy[road[0]] = road[2]\n        else:\n            numCandy[road[0]] += road[2]\n        if road[1] not in numCandy:\n            numCandy[road[1]] = road[2]\n        else:\n            numCandy[road[1]] += road[2]\n    res = 0\n    for num in numCandy:\n        res += numCandy[num] ** 2\n    if res < alpha * M:\n        return \"Poor girl\"\n    return res - alpha * M\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the minimum amount of energy Mr. G has to spend.\n    :param stdin: input string\n    :return: minimum amount of energy Mr. G has to spend\n    \"\"\"\n    N, M, alpha = [int(i) for i in stdin.split()]\n    roads = []\n    for i in range(M):\n        roads.append([int(i) for i in stdin.split()[2*i:2*i+2]])\n    roads.sort(key=lambda x: x[2])\n    junction = [i for i in range(1, N + 1)]\n    min_energy = []\n    junction_dict = {i: 0 for i in junction}\n    energy = 0\n    for i in range(M):\n        junction_dict[roads[i][0]] += roads[i][2]\n        junction_dict[roads[i][1]] += roads[i][2]\n    energy = sum([junction_dict[i] ** 2 for i in junction_dict.keys()]) + alpha * M\n    for i in junction_dict.keys():\n        if junction_dict[i] == 0:\n            if energy > 0:\n                junction_dict[i] = 1\n                energy -= 1\n            else:\n                return \"Poor girl\"\n    min_energy.append(energy)\n    for i in range(1, N - 1):\n        energy = 0\n        junction_dict = {i: 0 for i in junction}\n        for j in range(M):\n            junction_dict[roads[j][0]] += roads[j][2]\n            junction_dict[roads[j][1]] += roads[j][2]\n        for k in junction_dict.keys():\n            if junction_dict[k] == 0:\n                if energy > 0:\n                    junction_dict[k] = 1\n                    energy -= 1\n                else:\n                    return \"Poor girl\"\n        energy = sum([junction_dict[i] ** 2 for i in junction_dict.keys()]) + alpha * M\n        min_energy.append(energy)\n    return str(min(min_energy))\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    N, M, alpha = [int(item) for item in stdin.split()]\n\n    edges = []\n    for _ in range(M):\n        u, v, c = [int(item) for item in stdin.split()]\n        edges.append((u, v, c))\n\n    edges.sort(key=lambda x: x[2])\n\n    graph = {i: {} for i in range(1, N + 1)}\n    for u, v, c in edges:\n        graph[u][v] = c\n        graph[v][u] = c\n\n    def bfs(start: int) -> int:\n        queue = deque([start])\n        dist = {start: 0}\n        seen = {start}\n        while queue:\n            junction = queue.popleft()\n            for neighbor in graph[junction]:\n                if neighbor not in seen:\n                    seen.add(neighbor)\n                    queue.append(neighbor)\n                    dist[neighbor] = dist[junction] + 1\n        return sum(dist.values()) - dist[start]\n\n    if bfs(1) < alpha * M:\n        return \"Poor girl\"\n    return str(bfs(N) + alpha * M)\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    num_j, num_r, alpha = lines[0].split()\n    num_j, num_r, alpha = int(num_j), int(num_r), int(alpha)\n    lines = lines[1:]\n\n    # Create the graph\n    adj = [[] for _ in range(num_j)]\n    for line in lines:\n        u, v, c = line.split()\n        u, v, c = int(u), int(v), int(c)\n        adj[u - 1].append((c, v - 1))\n        adj[v - 1].append((c, u - 1))\n\n    # Sort the roads\n    for line in lines:\n        u, v, c = line.split()\n        u, v, c = int(u), int(v), int(c)\n\n    # Compute the solution\n    visited = [False] * num_j\n    edges = {}\n    for u in range(num_j):\n        visited[u] = False\n        for c, v in adj[u]:\n            if visited[v] is False:\n                edges[(u, v)] = c\n                visited[v] = True\n\n    edges = sorted(edges.items(), key=lambda x: x[1], reverse=True)\n    cost = 0\n    for u, v in edges:\n        cost += edges[u, v]\n        if cost > alpha * num_r:\n            return 'Poor girl'\n\n    return cost\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_of_junctions = int(stdin.split(\"\\n\")[0].split(\" \")[0])\n    num_of_roads = int(stdin.split(\"\\n\")[0].split(\" \")[1])\n    alpha = int(stdin.split(\"\\n\")[0].split(\" \")[2])\n\n    junctions = list()\n    for i in range(num_of_junctions):\n        junctions.append(i+1)\n    roads = list()\n    for i in range(num_of_roads):\n        temp = list(map(int, stdin.split(\"\\n\")[i].split(\" \")))\n        roads.append(temp)\n    energy = pow(alpha, 2)+pow(len(roads), 2)\n    return energy"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a = [int(x) for x in stdin.split()]\n    roads = [[int(y) for y in x.split()] for x in stdin.split('\\n')[2:]]\n    candies = set()\n    for road in roads:\n        candies.add(road[2])\n    candies = list(candies)\n    roads.sort(key=lambda x: x[2])\n\n    # exe = lambda x, y, z, a: z if y in x else 0\n    # exe = lambda x, y, z, a: z if y in x else 0\n    exe = lambda x, y, z, a: z if y in x else 0\n\n    num_roads = [[i for i in range(n) if i not in [road[0] for road in roads]] for j in range(n)]\n    num_roads = [exe(num_roads[i], roads[j][0], roads[j][1], roads[j][2]) for i in range(n) for j in range(m)]\n\n    # energy = lambda x, y, z, a: (x+a*y)**2\n    energy = lambda x, y, z, a: x + a * y\n    energy = [exe(roads[i][1], roads[j][0], roads[j][2], roads[j][2]) for i in range(m) for j in range(n)]\n\n    # for i in range(m):\n    #     for j in range(n):\n    #         if num_roads[i] == j:\n    #             print(num_roads[i], roads[i][0], roads[i][1], roads[i][2])\n    #             energy[num_roads[i]] = energy[num_roads[i]] + roads[i][2]\n\n    # energy = lambda x, y, z, a: (x+a*y)**2\n    energy = [energy(roads[i][1], roads[j][0], roads[j][2], roads[j][2]) for i in range(m) for j in range(n)]\n    print(energy)\n    return min([x for x in energy if x!= 0])\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution.\"\"\"\n    from collections import defaultdict\n    N, M, alpha = [int(n) for n in stdin.split()]\n    roads = defaultdict(dict)\n    for _ in range(M):\n        u, v, c = [int(n) for n in stdin.split()]\n        roads[u][v] = c\n        roads[v][u] = c\n    route = defaultdict(int)\n    route[1] = 1\n\n    def dfs(u):\n        \"\"\"DFS, in depth.\"\"\"\n        if u in route:\n            return route[u]\n        total = 0\n        for v in roads[u]:\n            total = min(total, dfs(v) + roads[u][v])\n        route[u] = total + alpha * len(roads[u])\n        return route[u]\n\n    dfs(1)\n    return route[N]\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Time Complexity: O(NlogN) where N is the number of roads\n    Space Complexity: O(1)\n    Args:\n        stdin (str): the input string\n    Returns:\n        str: the output string\n    '''\n    n, m, alpha = map(int, stdin.split())\n    roads = [tuple(map(int, stdin.split())) for _ in range(m)]\n    roads.sort(key=lambda road: road[2])\n    dist = defaultdict(list)\n    for i in range(1, n+1):\n        dist[i] = [0] * (n+1)\n    for u, v, c in roads:\n        dist[u][v] = c\n    dist[1][n] = alpha\n    # dist[v][u] = c\n    # for u, v, c in roads:\n    #     dist[u][v] = c\n    #     dist[v][u] = c\n    # dist[1][n] = alpha\n    # dist[n][1] = alpha\n\n    q = [1]\n    min_energy = 10 ** 20\n    while q:\n        curr = q.pop(0)\n        if dist[curr][n] < min_energy:\n            min_energy = dist[curr][n]\n        for v in range(1, n+1):\n            if dist[curr][v] and dist[curr][v] < min_energy:\n                q.append(v)\n    if min_energy == 10 ** 20:\n        return 'Poor girl'\n    return str(min_energy)\n"
    },
    {
        "number": 3221,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''7 7 10\n   ... 1 2 1000000\n   ... 2 3 2000000\n   ... 3 4 3000000\n   ... 4 5 4000000\n   ... 5 6 5000000\n   ... 6 7 6000000\n   ... 7 1 7000000''')\n    '49000000000070'\n    >>> solution('''5 4 1\n   ... 1 2 5\n   ... 1 3 10\n   ... 1 4 20\n   ... 2 3 25\n   ... 3 4 30\n   ... 3 5 40\n   ... 3 1 50\n   ... 4 2 60\n   ... 4 3 70\n   ... 4 5 80\n   ... 5 1 90\n   ... 5 2 100\n   ... 5 3 120\n   ... 1 4 130\n   ... 3 4 150\n   ... 1 4 180\n   ... 2 3 190\n   ... 1 5 200\n   ... 2 5 210\n   ... 1 5 230\n   ... 1 5 250\n   ... 2 5 260\n   ... 1 5 270\n   ... 2 5 280\n   ... 1 5 290\n   ... 2 5 300\n   ... 1 5 310\n   ... 3 4 320\n   ... 3 5 330\n   ... 1 5 340\n   ... 2 5 350\n   ... 3 5 360\n   ... 1 5 370\n   ... 2 5 380\n   ... 1 5 390\n   ... 2 5 400\n   ... 1 5 410\n   ... 3 5 420\n   ... 2 4 430\n   ... 3 4 440\n   ... 3 5 450\n   ... 3 1 500\n   ... 2 4 510\n   ... 3 4 520\n   ... 2 3 530\n   ... 2 1 540\n   ... 2 5 550\n   ... 2 4 560\n   ... 1 5 570\n   ... 2 5 580\n   ... 1 5 590\n   ... 2 5 600\n   ... 1 5 610\n   ... 2 5 620\n   ... 1 5 630\n   ... 1 5 650\n   ... 2 5 660\n   ... 1 5 670\n   ... 2 5 680\n   ... 1 5 690\n   ... 2 5 700\n   ... 1 5 710\n   ... 2 5 720\n   ... 1 5 730\n   ... 2 5 740\n   ... 1 5 750\n   ... 2 5 760\n   ... 1 5 770\n   ... 2 5 780\n   ... 1 5 790\n   ... 2 5 800\n   ... 1 5 810\n   ... 2 5 820\n   ... 1 5 830\n   ... 2 5 840\n   ... 1 5 850\n   ... 2 5 860\n   ... 1 5 870\n   ... 2 5 880\n   ... 3 4 890\n   ... 3 5 900\n   ... 1 5 910\n   ... 2 5 920\n   ... 3 5 930\n   ... 1 5 940\n   ... 2 5 950\n   ... 3 5 960\n   ... 1 5 970\n   ... 2 5 980\n   ... 3 5 990\n   ... 1 5 1000\n   ... 2 5 1010\n   ... 3 5 1020\n   ... 1 5 1030\n   ... 2 5 1040\n   ... 3 5 1050\n   ... 1 5 1060\n   ... 2 5 1070\n   ... 3 5 1080\n   ... 3 1 1100\n   ... 3 4 1110\n   ... 3 5 1120\n   ... 4 5 1130\n   ... 4 6 1140\n   ... 4 7 1150\n   ... 5 6 1160\n   ... 5 7 1170\n   ... 5 8 1180\n   ... 6 7 1190\n   ... 6 8 1200\n   ... 6 9 1210\n   ... 7 8 1220\n   ... 7 9 1230\n   ... 7 10 1240\n   ... 6 10 1250\n   ... 5 10 1260\n   ... 5 9 1270\n   ... 5 8 1280\n   ... 5 7 1290\n   ... 5 6 1298\n   ... 4 6 1300\n   ... 3 6 1310\n   ... 3 5 1320\n   ... 3 4 1330\n   ... 2 3 1340\n   ... 2 2 1350\n   ... 2 1 1360\n   ... 1 1 1370\n   ... 1 2 1380\n   ... 1 3 1390\n   ... 2 1 1400\n   ... 3 1 1410\n   ... 2 3 1420\n   ... 1 3 1430\n   ... 2 3 1440\n   ... 3 3 1450\n   ... 2 2 1460\n   ... 2 1 1470\n   ... 1 1 1480\n   ... 3 1 1490\n   ... 2 1 1500\n   ... 3 1 1510\n   ... 2 1 1520\n   ... 1 1 1530\n   ... 2 2 1540\n   ... 3 2 1550\n   ... 2 3 1560\n   ... 3 2 1570\n   ... 1 2 1580\n   ... 2 2 1590\n   ... 1 2 1600\n   ... 2 1 1610\n   ... 1 2 1620\n   ... 3 2 1630\n   ... 2 1 1640\n   ... 1 2 1650\n   ... 2 1 1660\n   ... 3 1 1670\n   ... 2 1 1680\n   ... 1 1 1690\n   ... 2 1 1700\n   ... 1 1 1710\n   ... 1 2 1720\n   ... 3 2 1730\n   ... 2 1 1740\n   ... 1 1 1750\n   ... 1 2 1760\n   ... 2 1 1770\n   ... 1 2 1780\n   ... 1 3 1790\n   ... 1 2 1800\n   ... 2 1 1810\n   ... 3 1 1820\n   ... 2 1 1830\n   ... 1 1 1830\n   ... 1 2 1840\n   ... 2 1 1850\n   ... 3 1 1860\n   ... 2 2 1860\n   ... 1 2 1870\n   ... 1 1 1880\n   ... 2 2 1890\n   ... 3 2 1900\n   ... 2 1 1910\n   ... 1 1 1920\n   ... 2 1 1930\n   ... 3 1 1940\n   ... 1 1 1950\n   ... 1 2 1960\n   ... 2 1 1970\n   ... 1 1 1980\n   ... 2 1 1990\n   ... 1 1 2010\n   ... 1 2 2020\n   ... 3 2 2030\n   ... 1 2 2040\n   ... 2 1 2050\n   ... 2 1"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    dic = {}\n    for _ in range(M):\n        f, t = map(int, stdin.readline().split())\n        dic[f] = dic.get(f, []) + [t]\n\n    if dic.get(0, []) == [] or len(set(dic.get(0, []) + [0]))!= N:\n        return \"Yeah!\"\n    else:\n        ans = []\n        def dfs(candi: [], cur: int):\n            if len(candi) == N:\n                ans.append(candi)\n                return\n            for i in dic.get(cur, []):\n                if i not in candi:\n                    dfs(candi+[i], i)\n        dfs([0], 0)\n        return \"\\n\".join([str(len(i))+\"\\n\"+\"\\n\".join([str(j) for j in i]) for i in ans])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds a solution if it exists.\"\"\"\n    def solve(n: int, m: int, p: list) -> bool:\n        \"\"\"Finds a solution if it exists.\"\"\"\n        if n == 0:\n            return []\n        for i in range(1, m+1):\n            if p[i-1][1] == p[i][0]:\n                return solve(n-1, m, p[:i]+p[i+1:]) or solve(n, m-1, p[:i]+p[i+1:])\n        return False\n\n    p = []\n    n, m = [int(x) for x in stdin.split()]\n    for _ in range(m):\n        p.append([int(x) for x in stdin.split()])\n    p.sort(key=lambda x: x[0])\n    p.sort(key=lambda x: x[1])\n    if solve(n, m, p):\n        return '\\n'.join(str(len(x)) +'' +''.join(map(str, x)) for x in solve(n, m, p))\n    else:\n        return 'Yeah!'\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 4\\n0 1\\n1 0\\n2 3\\n3 2\")\n    '2\\n2\\n0\\n1\\n2\\n2\\n3'\n    \"\"\"\n   ..."
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    edges = []\n    for _ in range(m):\n        f, t = stdin.split()\n        f = int(f)\n        t = int(t)\n        edges.append((f, t))\n    edges.sort(key=lambda x: x[1])\n    prev = -1\n    d = {}\n    for f, t in edges:\n        if f not in d:\n            d[f] = []\n        if prev!= -1:\n            d[prev].append(t)\n        d[f].append(t)\n        prev = f\n    print(d)\n    seen = set()\n    for f, t in edges:\n        if f in seen or t in seen:\n            continue\n        seen.add(f)\n        seen.add(t)\n        if not d[f]:\n            continue\n        if not d[t]:\n            continue\n        if len(seen) == n:\n            break\n        print(seen)\n    print(len(seen))\n    return 'Yeah!'\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    place_count = int(lines[0].split(\" \")[0])\n    road_count = int(lines[0].split(\" \")[1])\n    place_indexes = [int(place) for place in lines[1:1 + place_count]]\n    edge_indexes = [int(edge) for edge in lines[1 + place_count : 1 + place_count + road_count]]\n    start_indexes = []\n    end_indexes = []\n    for edge_index in edge_indexes:\n        start_indexes.append(edge_indexes[edge_index])\n        end_indexes.append(edge_indexes[edge_indexs[edge_index] - 1])\n    place_indexes.sort()\n    place_indexes.append(place_indexes[0])\n    current_index = place_indexes[0]\n    total_length = 0\n    for i in range(1, len(place_indexes)):\n        total_length += abs(place_indexes[i] - place_indexes[i - 1])\n    total_length += abs(place_indexes[0] - place_indexes[-1])\n    if total_length > place_count:\n        return \"Yeah!\"\n    else:\n        return place_count\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(\"\\n\")[:2]]\n    edges = []\n    for i in range(m):\n        edge = [int(x) for x in stdin.split(\"\\n\")[2 + i].split()]\n        edges.append(edge)\n    if len(edges) < n - 1:\n        return \"Yeah!\"\n    edges = set(tuple(x) for x in edges)\n    if len(edges) < n - 1:\n        return \"Yeah!\"\n    return str(n - 1)\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a list of trips, each trip is a list of locations, each location is an index.\"\"\"\n    # The problem is that the input is too large to compute in one go.\n    # So I have to figure out how to split the input to compute in sub problems, and then combine the results.\n    # Using a divide and conquer approach seems to be the best idea.\n\n    # Inputs\n    M, N = stdin.split('\\n')[:2]\n    M, N = int(M), int(N)\n    numLocations = M\n    numStreets = N\n    locations = [int(i) for i in stdin.split('\\n')[2:]]\n    # Map the location of the end of the street to the beginning of the street.\n    # (I have to put this in a map because the order of the locations is important)\n    # Also, if I remove the locations from the map, they will be out of order.\n    locationsMap = dict(zip([location for location in locations], locations))\n    # Result\n    trips = []\n\n    # First, if there are only two locations, then I have one trip and no need to split.\n    if numLocations == 2:\n        return 'Yeah!'\n\n    # Divide into sub problems\n    # Divide into sub problems for each end point and one for the last location.\n    def divide(firstLocation: int, lastLocation: int):\n        \"\"\"Split the locations into trips\"\"\"\n        if firstLocation == lastLocation:\n            return [firstLocation]\n        subTrips = []\n        if firstLocation not in locationsMap or lastLocation not in locationsMap:\n            return None\n        firstLocationStart = locationsMap[firstLocation]\n        lastLocationStart = locationsMap[lastLocation]\n        # Get the routes for each location.\n        routes = []\n        for i in range(firstLocationStart, lastLocationStart + 1):\n            # Ignore the routes that have loop, since there is no loop in the input.\n            # (I am not interested in the number of streets for the loops.)\n            if i in locations:\n                routes.append(i)\n        # Divide into sub problems for each route.\n        for route in routes:\n            startLocation = route\n            endLocation = route\n            subTrips.append(divide(startLocation, endLocation))\n        # Combine the sub problems.\n        return subTrips\n\n    # Divide into sub problems for the last location.\n    subTrips = divide(0, 0)\n    # If there is no sub problems for the last location, then return \"Yeah!\".\n    if subTrips is None:\n        return 'Yeah!'\n    # If there is one sub problem, then I have only one trip.\n    if len(subTrips) == 1:\n        return str(len(subTrips)) + '\\n' + str(subTrips[0])\n\n    # Combine the sub problems.\n    trips = []\n    for subTrip in subTrips:\n        trips += subTrip\n    return trips\n"
    },
    {
        "number": 3222,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(i) for i in stdin.split('\\n')[:2]]\n    C = [[int(i) for i in stdin.split('\\n')[j].split(' ')[:2]] for j in range(2, 2 + M)]\n    M = []\n    for i in range(M):\n        if C[i][0] == C[i][1]:\n            continue\n        M.append(i)\n    M.sort(key=lambda x: C[x][0])\n    P = {}\n    for i in M:\n        P[C[i][0]] = C[i][1]\n    # print(P)\n    G = [0] * N\n    for i in P:\n        G[i] = P[i]\n    # print(G)\n    P = {}\n    for i in M:\n        P[C[i][1]] = C[i][0]\n    # print(P)\n    for i in range(N):\n        if G[i] == 0:\n            G[i] = P[i]\n    # print(G)\n    Q = [0] * N\n    for i in range(N):\n        Q[i] = G[i]\n    # print(Q)\n    L = set()\n    for i in range(N):\n        if Q[i] == 0:\n            L.add(i)\n    # print(L)\n    while True:\n        if len(L) == 0:\n            return \"Yeah!\"\n        Q = [0] * N\n        for i in L:\n            Q[i] = G[i]\n        # print(Q)\n        for i in L:\n            G[i] = Q[i]\n        L = set()\n        for i in range(N):\n            if G[i] == 0:\n                L.add(i)\n        # print(L)\n        # print(G)\n\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 1 1 2\n   ... ''')\n    'POSSIBLE'\n\n    >>> solution('''2\n   ... 1 2\n   ... ''')\n    'IMPOSSIBLE'\n\n    >>> solution('''3\n   ... 3 4 5\n   ... 2 1 3\n   ... ''')\n    'POSSIBLE'\n    \"\"\"\n    n, d = (int(c) for c in stdin.split('\\n')[0].split())\n    if n!= sum(d) or any(d[i] < 0 for i in range(n)):\n        return 'IMPOSSIBLE'\n\n    edges = sorted([(i, j) for i, j in enumerate(stdin.split('\\n')[1].split())], key=lambda e: d[e[1]], reverse=True)\n    for i, j in edges:\n        if not d[j]:\n            return 'IMPOSSIBLE'\n        d[i] -= 1\n        d[j] -= 1\n    return 'POSSIBLE'\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    V, D = map(int, stdin.split())\n    degrees = list(map(int, stdin.split()))\n    # \u6e90\u70b9\u662f1\uff0c\u76ee\u6807\u70b9\u662f\u5404\u4e2a\u70b9\u7684\u8fb9\u6570\n    paths = {}\n    for i in range(V):\n        paths[i + 1] = 0\n\n    for i in range(V):\n        paths[degrees[i]] += 1\n\n    paths = sorted(paths.items(), key=lambda x: x[1], reverse=True)\n\n    if len(paths) > 2:\n        return \"IMPOSSIBLE\"\n    if len(paths) == 1:\n        return \"POSSIBLE\"\n\n    for i in range(V):\n        if paths[0][1]!= degrees[i]:\n            return \"IMPOSSIBLE\"\n\n    # \u6e90\u70b9\u4e3a1\n    # \u53ea\u80fd\u63a5\u6536\u4e24\u4e2a\u70b9\n    # \u53ea\u80fd\u5728\u5171\u540c\u7684\u70b9\u63a5\u5728\u4e00\u8d77\uff0c\u4e24\u70b9\u5fc5\u987b\u662f\u540c\u4e00\u70b9\u7684\u8fb9\uff0c\u4e14\u4e0d\u80fd\u5728\u540c\u4e00\u70b9\u63a5\u5728\u4e00\u8d77\n    # \u63a5\u7eed\uff1a1,2,3,4,5,6\n\n    # \u63a5\u5728\u540c\u4e00\u70b9\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n    # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n    # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n    # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n    # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n    # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n    # \u63a5\u5728\u540c\u4e00\u70b9\u7684\u8fb9\u6570\u8981\u76f8\u7b49\n\n    # \u63a5\u7eed\uff1a1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\n    if len(paths) == 2:\n        # \u53ea\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \u5f53\u524d\u6e90\u70b9\u5df2\u7ecf\u63a5\u4e24\u6b21\uff0c\u4e24\u4e2a\u70b9\u4e0d\u80fd\u63a5\u5728\u540c\u4e00\u70b9\n        # \ufffd"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    if n == 0:\n        return 'IMPOSSIBLE'\n    degree = [int(x) for x in stdin.readline().split()]\n    if sum(degree) % 2:\n        return 'IMPOSSIBLE'\n    degree = [0] + degree\n    tree = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        a, b = [int(x) for x in stdin.readline().split()]\n        tree[a].append(b)\n        tree[b].append(a)\n    return 'POSSIBLE'\n\ndef"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"V: number of vertices\n    D: number of edges per vertex\n\n    Time complexity: O(V + E)\n    Space complexity: O(V + E)\n    \"\"\"\n    V, D = [int(i) for i in stdin.split()]\n\n    assert 2 <= V <= 100\n    assert 1 <= D <= 100\n\n    adj = [set() for _ in range(V)]\n\n    for _ in range(D):\n        u, v = [int(i) for i in stdin.split()]\n        assert 1 <= u <= V\n        assert 1 <= v <= V\n        adj[u - 1].add(v)\n\n    # dp: a list of Bool\n    # dp[v]: whether vertex v is in the forest\n    # dp[v][1]: whether v has degree 1\n    dp = [[False, False] for _ in range(V)]\n    dp[0][1] = True\n\n    for v in range(1, V):\n        if not dp[v - 1][1]:\n            continue\n\n        for u in adj[v]:\n            if not dp[u - 1][0]:\n                dp[u - 1][0] = True\n\n    if False in dp[-1][0]:\n        return \"IMPOSSIBLE\"\n\n    ans = []\n    for v in range(V):\n        if not dp[v][0]:\n            continue\n\n        ans.append(str(v + 1))\n\n    return \" \".join(ans)\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    V, degrees = [int(x) for x in stdin.split(\"\\n\")]\n    degree_list = [int(x) for x in stdin.split(\"\\n\")][1:]\n    graph = [[] for i in range(V)]\n    degrees_dict = {i: degree_list[i] for i in range(V)}\n\n    for vertex in range(V):\n        for neighbour in range(degree_list[vertex]):\n            graph[vertex].append(neighbour + 1)\n    for vertex in range(V):\n        if degrees_dict[vertex] > len(graph[vertex]):\n            return \"IMPOSSIBLE\"\n    graph = [sorted(row) for row in graph]\n    graph = [tuple(row) for row in graph]\n    if len(graph)!= len(set(graph)):\n        return \"IMPOSSIBLE\"\n    sorted_degrees = sorted(degrees_dict.items(), key=lambda kv: kv[1])\n    sorted_degrees = [x[0] for x in sorted_degrees]\n    for vertex in range(len(graph)):\n        for neighbour in range(len(graph[vertex])):\n            graph[vertex][neighbour] = sorted_degrees.index(graph[vertex][neighbour]) + 1\n    graph = [sorted(row) for row in graph]\n    graph = [tuple(row) for row in graph]\n    if len(graph)!= len(set(graph)):\n        return \"IMPOSSIBLE\"\n    return \"POSSIBLE\\n\" + \"\\n\".join([\" \".join(map(str, row)) for row in graph])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    n: int = int(stdin.readline())\n    degrees: list[int] = list(map(int, stdin.readline().split()))\n    \n    if sum(degrees) % n!= 0:\n        return 'IMPOSSIBLE'\n    \n    \n    edges: list[list[int]] = []\n    \n    for i in range(n):\n        for j in range(degrees[i]):\n            edges.append([i + 1, i + j + 1])\n    \n    return 'POSSIBLE\\n' + '\\n'.join(' '.join(map(str, item)) for item in edges)\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return \"IMPOSSIBLE\" if it is impossible to create such a forest, otherwise return \"POSSIBLE\"\n    \"\"\"\n    # set the number of vertices\n    n = int(stdin[0])\n\n    # split input\n    degrees = list(map(int, stdin[1:].split(' ')))\n\n    # make a list of lists to represent the adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                if degrees[i] >= degrees[j]:\n                    adj[i].append(j)\n\n    # check if such a forest exists\n    if check_forest(adj, n):\n        return \"POSSIBLE\"\n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3223,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    ans = ['POSSIBLE']\n    n, *degrees = stdin.strip().split('\\n')\n    n = int(n)\n\n    for d in degrees:\n        d = int(d)\n        if n - d < 0:\n            ans.append('IMPOSSIBLE')\n            break\n        ans.append(str(n - d) +'' + str(d))\n        n -= d\n\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # type: (str) -> str\n    # given four points, use two matrices\n    # where first matrix stores x, y, z coordinates\n    # of points A, B, C, D.\n    # second matrix stores dist\n    # between points A and B, B and C, C and D.\n    # return the center of sphere where the\n    # surface touches all four points.\n    # where center is calculated using:\n    #     (a + d)/2\n    #     (b + e)/2\n    #     (c + f)/2\n    #     where a = (A_x + B_x + C_x + D_x)/4\n    #           b = (A_y + B_y + C_y + D_y)/4\n    #           c = (A_z + B_z + C_z + D_z)/4\n    #           d = (A_x - B_x)^2 + (A_y - B_y)^2 + (A_z - B_z)^2\n    #           e = (B_x - C_x)^2 + (B_y - C_y)^2 + (B_z - C_z)^2\n    #           f = (C_x - D_x)^2 + (C_y - D_y)^2 + (C_z - D_z)^2\n    # the formula for center of sphere is:\n    #     (A_x + B_x + C_x + D_x)/4\n    #     (A_y + B_y + C_y + D_y)/4\n    #     (A_z + B_z + C_z + D_z)/4\n    # the value for center of sphere is chosen such that\n    # dist between points A and B is smaller than the value\n    # of the center. This is to ensure that the center is not\n    # on the line joining points A and B.\n\n    # create 4x3 matrices\n    # where first matrix stores x, y, z coordinates of points\n    # and last column stores distance between points\n    A = np.array(list(map(lambda l: list(map(float, l.split())), stdin.strip().split('\\n')[:4])), dtype=np.float64)\n    B = np.array(list(map(lambda l: list(map(float, l.split())), stdin.strip().split('\\n')[4:8])), dtype=np.float64)\n    dist = np.sqrt((A[:, 0] - B[:, 0]) ** 2 + (A[:, 1] - B[:, 1]) ** 2 + (A[:, 2] - B[:, 2]) ** 2)\n    # result is in the form of a single vector\n    # with x, y, z, and dist as elements\n    return '{0} {1} {2} {3}'.format(*list(map(str, np.average(A, axis=0).tolist() + np.average(B, axis=0).tolist() + [np.min(dist)])))\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    list_points = list(map(float, stdin.split()))\n    i = 0\n    list_X = []\n    list_Y = []\n    list_Z = []\n    for x, y, z in list_points:\n        list_X.append(x)\n        list_Y.append(y)\n        list_Z.append(z)\n    mean_X = mean(list_X)\n    mean_Y = mean(list_Y)\n    mean_Z = mean(list_Z)\n    list_X_Sqr = [point_X ** 2 for point_X in list_X]\n    list_Y_Sqr = [point_Y ** 2 for point_Y in list_Y]\n    list_Z_Sqr = [point_Z ** 2 for point_Z in list_Z]\n    variance_X = variance(list_X_Sqr)\n    variance_Y = variance(list_Y_Sqr)\n    variance_Z = variance(list_Z_Sqr)\n    variance_XY = covariance(list_X, list_Y, list_X_Sqr, list_Y_Sqr)\n    variance_XZ = covariance(list_X, list_Z, list_X_Sqr, list_Z_Sqr)\n    variance_YZ = covariance(list_Y, list_Z, list_Y_Sqr, list_Z_Sqr)\n    variance_YX = covariance(list_Y, list_X, list_Y_Sqr, list_X_Sqr)\n    variance_ZX = covariance(list_Z, list_X, list_Z_Sqr, list_X_Sqr)\n    variance_ZY = covariance(list_Z, list_Y, list_Z_Sqr, list_Y_Sqr)\n    b = (\n        (variance_X * variance_Y)\n        - (variance_X * variance_XY)\n        - (variance_Y * variance_XZ)\n        + (variance_XY * variance_YZ)\n        + (variance_XZ * variance_YZ)\n        + (variance_YX * variance_ZX)\n        - (variance_YZ * variance_X)\n        - (variance_ZY * variance_Y)\n        + (variance_ZX * variance_Z)\n    ) / (\n        ((variance_X + variance_Y + variance_Z) ** 2)\n        - ((variance_X + variance_Y) * variance_Z)\n        - (variance_X * (variance_Y + variance_Z))\n        - ((variance_Y + variance_Z) * variance_X)\n        + ((variance_X + variance_Y) * (variance_Z + variance_X))\n        - ((variance_X + variance_Y) * (variance_X + variance_Z))\n    )\n    c = (\n        (variance_Y * variance_Z)\n        - (variance_Y * variance_YZ)\n        - (variance_Z * variance_YX)\n        + (variance_YZ * variance_ZX)\n        + (variance_ZY * variance_X)\n        + (variance_YX * variance_Z)\n        - (variance_X * variance_ZY)\n        - (variance_ZX * variance_Y)\n        + (variance_X * variance_Z)\n    ) / (\n        ((variance_X + variance_Y + variance_Z) ** 2)\n        - ((variance_X + variance_Y) * variance_Z)\n        - (variance_X * (variance_Y + variance_Z))\n        - ((variance_Y + variance_Z) * variance_X)\n        + ((variance_X + variance_Y) * (variance_Z + variance_X))\n        - ((variance_X + variance_Y) * (variance_X + variance_Z))\n    )\n    d = (\n        (variance_X * variance_YZ)\n        - (variance_X * variance_XY)\n        - (variance_Y * variance_XZ)\n        + (variance_XY * variance_YZ)\n        + (variance_XZ * variance_Y)\n        + (variance_YX * variance_X)\n        - (variance_YZ * variance_X)\n        - (variance_ZX * variance_Y)\n        + (variance_Z * variance_X)\n    ) / (\n        ((variance_X + variance_Y + variance_Z) ** 2)\n        - ((variance_X + variance_Y) * variance_Z)\n        - (variance_X * (variance_Y + variance_Z))\n        - ((variance_Y + variance_Z) * variance_X)\n        + ((variance_X + variance_Y) * (variance_Z + variance_X))\n        - ((variance_X + variance_Y) * (variance_X + variance_Z))\n    )\n    return \" \".join(map(str, [a, b, c, d]))\n\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = list(map(int, stdin.strip().split(' ')))\n    x, y, z = [a, b, c], [d, c, a], [a, d, b]\n    x_max, y_max, z_max = max(x), max(y), max(z)\n    x_min, y_min, z_min = min(x), min(y), min(z)\n    x_c = (x_max + x_min) / 2\n    y_c = (y_max + y_min) / 2\n    z_c = (z_max + z_min) / 2\n    return '{:.4f} {:.4f} {:.4f}'.format(x_c, y_c, z_c)\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    points = [list(map(int, line.split())) for line in stdin.splitlines()]\n    dist = 0\n    for p1, p2, p3 in zip(*(points + points[:1])):\n        d2 = (p1 - p2) ** 2 + (p3 - p2) ** 2\n        dist += d2\n    mid = dist / 2\n    s = set()\n    for p1, p2, p3 in zip(points, points[1:], points[2:]):\n        d = ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n        d3 = ((p2[0] - p3[0]) ** 2 + (p2[1] - p3[1]) ** 2 + (p2[2] - p3[2]) ** 2) ** 0.5\n        s.add(d + d3 + mid)\n    return''.join(map(str, map(lambda x: (x / (3 * dist)) ** 0.5, s)))\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    p0 = [float(stdin.split()[0]), float(stdin.split()[1]), float(stdin.split()[2])]\n    p1 = [float(stdin.split()[3]), float(stdin.split()[4]), float(stdin.split()[5])]\n    p2 = [float(stdin.split()[6]), float(stdin.split()[7]), float(stdin.split()[8])]\n    p3 = [float(stdin.split()[9]), float(stdin.split()[10]), float(stdin.split()[11])]\n    \n    # calculate the centroid of the points\n    centroid = [sum([p0[0], p1[0], p2[0], p3[0]]) / 4, sum([p0[1], p1[1], p2[1], p3[1]]) / 4, sum([p0[2], p1[2], p2[2], p3[2]]) / 4]\n    \n    # calculate the radius\n    radius = 0\n    for i in range(len(p0)):\n        radius += (p0[i] - centroid[i]) ** 2\n    \n    # check whether the radius is smaller than 10^-4\n    if radius < 10 ** -4:\n        return''.join(map(str, centroid))\n    \n    return ''\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x_0, y_0, z_0 = map(float, stdin.split())\n    x_1, y_1, z_1 = map(float, stdin.split())\n    x_2, y_2, z_2 = map(float, stdin.split())\n    x_3, y_3, z_3 = map(float, stdin.split())\n    x_0, y_0, z_0 = x_0, y_0, z_0\n    x_1, y_1, z_1 = x_1, y_1, z_1\n    x_2, y_2, z_2 = x_2, y_2, z_2\n    x_3, y_3, z_3 = x_3, y_3, z_3\n    p1 = [x_0, y_0, z_0]\n    p2 = [x_1, y_1, z_1]\n    p3 = [x_2, y_2, z_2]\n    p4 = [x_3, y_3, z_3]\n    p_list = [p1, p2, p3, p4]\n    ans_x = 0\n    ans_y = 0\n    ans_z = 0\n    for i in range(len(p_list)):\n        for j in range(i + 1, len(p_list)):\n            for k in range(j + 1, len(p_list)):\n                x_c = (p_list[i][0] + p_list[j][0] + p_list[k][0]) / 3\n                y_c = (p_list[i][1] + p_list[j][1] + p_list[k][1]) / 3\n                z_c = (p_list[i][2] + p_list[j][2] + p_list[k][2]) / 3\n                if sqrt((x_c - p_list[i][0]) ** 2 + (y_c - p_list[i][1]) ** 2 + (z_c - p_list[i][2]) ** 2) < 10 ** -4:\n                    ans_x, ans_y, ans_z = x_c, y_c, z_c\n    print(ans_x, ans_y, ans_z)\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4 = (int(n) for n in stdin.split(\"\\n\"))\n\n    def distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    def area(x1, y1, z1, x2, y2, z2, x3, y3, z3):\n        return abs(\n            x1 * (y2 * z3 - y3 * z2)\n            - x2 * (y1 * z3 - y3 * z1)\n            + x3 * (y1 * z2 - y2 * z1)\n        ) / 2\n\n    # triangle PQR is Heron's formula\n    p = distance(x1, y1, z1, x2, y2, z2)\n    q = distance(x1, y1, z1, x3, y3, z3)\n    r = distance(x1, y1, z1, x4, y4, z4)\n\n    s = (p + q + r) / 2\n    A = area(x1, y1, z1, x2, y2, z2, x3, y3, z3)\n    if abs(A - s * (s - p) * (s - q) * (s - r)) < 10 ** -4:\n        return f\"{s:.3f} {s:.3f} {s:.3f}\"\n    else:\n        return f\"{x1:.3f} {y1:.3f} {z1:.3f}\"\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A = [list(map(int, stdin.strip().split()))]\n    b, c, d = [], [], []\n    for _ in range(3):\n        b.append(A.pop(0))\n    for _ in range(3):\n        c.append(A.pop(0))\n    for _ in range(3):\n        d.append(A.pop(0))\n\n    a = 1\n    for i in range(3):\n        a *= b[i][i]\n    for i in range(3):\n        a /= b[i][i]\n\n    b = 1\n    for i in range(3):\n        b *= c[i][i]\n    for i in range(3):\n        b /= c[i][i]\n\n    c = 1\n    for i in range(3):\n        c *= d[i][i]\n    for i in range(3):\n        c /= d[i][i]\n\n    x = (a - b - c) / 2\n    y = (a + b + c) / 2\n    z = (a + b - c) / 2\n\n    return f'{x} {y} {z}'\n\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return str(sorted([[float(x) for x in line.split(\" \")] for line in stdin.split(\"\\n\")], key=lambda x: x[0]**2 + x[1]**2 + x[2]**2)[0])\n"
    },
    {
        "number": 3224,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x_0, y_0, z_0 = map(int, stdin.split())\n    x_1, y_1, z_1 = map(int, stdin.split())\n    x_2, y_2, z_2 = map(int, stdin.split())\n    x_3, y_3, z_3 = map(int, stdin.split())\n\n    d1 = (x_1 - x_0) ** 2 + (y_1 - y_0) ** 2 + (z_1 - z_0) ** 2\n    d2 = (x_2 - x_1) ** 2 + (y_2 - y_1) ** 2 + (z_2 - z_1) ** 2\n    d3 = (x_3 - x_2) ** 2 + (y_3 - y_2) ** 2 + (z_3 - z_2) ** 2\n\n    x = ((d1 * x_0 + d2 * x_1 + d3 * x_3) / (d1 + d2 + d3))\n    y = ((d1 * y_0 + d2 * y_1 + d3 * y_3) / (d1 + d2 + d3))\n    z = ((d1 * z_0 + d2 * z_1 + d3 * z_3) / (d1 + d2 + d3))\n\n    return f'{x:.4f} {y:.4f} {z:.4f}'\n"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1\n    # ans = 0\n    # time_list = []\n    # for i, line in enumerate(stdin.split('\\n')):\n    #     if i == 0:\n    #         N = int(line)\n    #         continue\n    #     else:\n    #         s = 0\n    #         numbers = list(map(int, line.split()))\n    #         for j, number in enumerate(numbers):\n    #             s += number\n    #             if j == 0:\n    #                 max_val = number\n    #                 continue\n    #             if j > 0:\n    #                 if number >= max_val:\n    #                     s -= max_val\n    #                 else:\n    #                     max_val = number\n    #         ans += s\n    #         time_list.append(s)\n    # print(time_list)\n    # print(ans)\n    # return str(ans)\n\n    # Solution 2\n    ans = 0\n    time_list = []\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            N = int(line)\n            continue\n        else:\n            s = 0\n            numbers = list(map(int, line.split()))\n            for j, number in enumerate(numbers):\n                s += number\n                if j == 0:\n                    max_val = number\n                    continue\n                if j > 0:\n                    if number >= max_val:\n                        s -= max_val\n                    else:\n                        max_val = number\n            ans += s\n            time_list.append(s)\n    print(time_list)\n    print(ans)\n    return str(ans)"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.splitlines()\n    candidates = []\n    for i, line in enumerate(stdin):\n        candidates.append(int(line))\n    candidates = [0] + candidates\n    queue = []\n    resume = [0] * len(candidates)\n    for i in range(1, len(candidates)):\n        for j in range(1, i + 1):\n            if i % j == 0:\n                resume[j] += candidates[i]\n    for i in range(1, len(candidates)):\n        if resume[i] >= resume[i - 1]:\n            queue.append(candidates[i])\n    print(len(queue))\n    print(' '.join(map(str, queue)))\n    return ''\n"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    queue = [int(x) for x in stdin.readline().strip().split()]\n    queue.sort()\n    res = []\n    for i in range(n):\n        q_index = queue.index(queue[i])\n        res.append(queue[q_index])\n        queue.pop(q_index)\n    print(len(res))\n    print(' '.join([str(x) for x in res]))"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Task: Determines the number of minutes taken by this process. Then displays the candidate's perceived values of the candidates who left the queue. Also displays the final list of perceived values in the queue after candidates no longer leave it.\n    \"\"\"\n    # initialisation\n    n = int(stdin)\n    v = list(map(int, stdin.split()))\n    left_queue = deque(v)\n    minute = 0\n    # while there are candidates left in the queue, there are still candidates\n    # whose neighbour has not been interviewed yet, and the queue has not\n    # been emptied\n    while left_queue:\n        # set current to the first element of the queue\n        current = left_queue.popleft()\n        # compare the current candidate with its neighbour\n        for i in range(len(left_queue)):\n            # if any neighbour is more valued than the current candidate\n            # then remove the current candidate from the queue\n            if left_queue[i] > current:\n                break\n        else:\n            # if there is no neighbour that is more valued than the current\n            # candidate then add the current candidate to the output\n            print(current)\n        minute += 1\n\n    # after all candidates have been interviewed, check whether any candidate\n    # left the queue\n    for left in left_queue:\n        print(left)\n    return ''\n    pass\n\n\ndef"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution for this problem.\n    \"\"\"\n    # Get the number of candidates from the stdin\n    num_candidates = int(stdin.readline())\n\n    # Read the stdin and parse it into a list\n    candidate_values = list(map(int, stdin.readline().split()))\n\n    # Initialize the number of rounds\n    num_rounds = 0\n\n    # Initialize the queue\n    queue = deque(candidate_values)\n\n    # While the queue is not empty\n    while len(queue)!= 0:\n        # Increment the number of rounds\n        num_rounds += 1\n\n        # Initialize the number of candidates who left the queue\n        num_candidates_left = 0\n\n        # Get the number of candidates to be removed\n        num_candidates_to_remove = int(stdin.readline())\n\n        # Remove the candidates from the queue\n        for _ in range(num_candidates_to_remove):\n            queue.popleft()\n\n        # Iterate over the queue\n        for i in range(len(queue)):\n            # If the candidate value is greater than the neighbour's candidate value\n            if queue[i] > queue[i - 1]:\n                # Increment the number of candidates who left the queue\n                num_candidates_left += 1\n\n            # If the number of candidates who left the queue is greater than 1\n            if num_candidates_left > 1:\n                # Increment the number of rounds\n                num_rounds += 1\n\n                # If the number of rounds is greater than the number of minutes\n                if num_rounds > num_candidates:\n                    # Print the number of minutes\n                    print(num_rounds)\n\n                    # Print the number of candidates who left the queue\n                    print(*queue)\n\n                    # Exit the loop\n                    break\n\n        # If the queue is not empty\n        if len(queue)!= 0:\n            # Print the number of minutes\n            print(num_rounds)\n\n            # Print the number of candidates who left the queue\n            print(*queue)\n    return"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the number of minutes taken by this process\"\"\"\n    pass\n"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    n = stdin.readline()\n    stdin = stdin.read()\n    \n    lst = [int(i) for i in stdin.split('\\n')[:-1]]\n    for i in range(len(lst)):\n        if lst[i] > lst[i+1]:\n            print(i)\n        \n    print(0)\n    print(*lst)\n    \n    return \"\""
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n\nprint(solution(\"10\\n3 6 2 3 2 2 2 1 5 6\"))\n"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = [int(stdin) for i in range(n)]\n    m = 0\n    while True:\n        u = [s[i] for i in range(n) if s[i] < s[i + 1] and s[i] < s[i - 1]]\n        if not u:\n            break\n        m += 1\n        print(*u)\n        s = u\n    return m"
    },
    {
        "number": 3225,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    queue = list(map(int, stdin.split()))\n    # queue = deque([int(stdin)] for _ in range(n))\n\n    queue = sorted(queue)\n    print(queue)\n\n    while len(queue) > 1:\n        temp = queue.pop(0)\n        print(temp)\n        for i in range(1, len(queue)):\n            if temp < queue[i]:\n                queue.pop(i)\n                break\n        queue = sorted(queue)\n        print(queue)\n    return queue\n"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split(\" \"))\n    roads = []\n    for i in range(m):\n        roads.append(map(int, stdin.split(\" \")))\n    roads = roads[:-1]\n    exits = map(int, stdin.split(\" \"))\n    roads.append([exits[0], exits[1]])\n    \n    exit = set()\n    exit.add(exits[2])\n    cities = set()\n    for road in roads:\n        exit.add(road[0])\n        exit.add(road[1])\n        cities.add(road[0])\n        cities.add(road[1])\n    \n    cities = list(cities)\n    \n    roads = list(roads)\n    cities = [0] + cities\n    \n    def find(city):\n        if city == 0:\n            return 0\n        for road in roads:\n            if road[0] == city:\n                return road[1]\n            if road[1] == city:\n                return road[0]\n    \n    def dijkstra(begin, end):\n        if begin == end:\n            return 0\n        h = []\n        heapq.heappush(h, (0, 0))\n        m = [inf for i in range(len(cities))]\n        m[begin] = 0\n        while h:\n            weight, city = heapq.heappop(h)\n            for road in roads:\n                if road[0] == city:\n                    next_city = road[1]\n                    next_weight = road[2]\n                if road[1] == city:\n                    next_city = road[0]\n                    next_weight = road[2]\n                if m[next_city] > weight + next_weight:\n                    m[next_city] = weight + next_weight\n                    heapq.heappush(h, (m[next_city], next_city))\n        return m[end]\n\n    \n    speed = dijkstra(exits[0], exits[1])\n    if speed == inf:\n        return \"IMPOSSIBLE\"\n    return str(speed*100/160) + \" km/h\"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    "
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, E = [int(x) for x in stdin.split(' ')]\n    roads = {(int(x) - 1): int(y) for x, y in [x.split(' ') for x in stdin.split('\\n')[:-1]]}\n    for x, y in roads.items():\n        if x!= y - 1:\n            roads[y - 1] = x\n    P = int(stdin.split(' ')[-1].split('\\n')[0][0]) - 1\n    m = 0\n    for x in stdin.split('\\n')[-1].split(' '):\n        m += 1\n    if m == 0:\n        return 'IMPOSSIBLE'\n    roads_rev = {v: k for k, v in roads.items()}\n    for x in stdin.split('\\n')[-1].split(' '):\n        x = int(x) - 1\n        if x!= P:\n            if roads[x]!= P and roads_rev[P]!= x:\n                roads[x] = roads_rev[P]\n                roads_rev[roads[x]] = x\n    s = {roads[x] for x in roads if roads[x] > P}\n    if E == 0 or len(s) == 0:\n        return 'IMPOSSIBLE'\n    else:\n        s = sorted(s)\n        for i in range(1, len(s)):\n            p = roads_rev[s[i]]\n            n = roads_rev[s[i - 1]]\n            d = roads[p] - roads[n]\n            m = abs(d) % roads[n]\n            if m > roads[n] // 2:\n                return 'IMPOSSIBLE'\n        v = (roads[s[0]] - roads[P]) // roads[s[0]]\n        if v % roads[s[0]] == 0:\n            return 'IMPOSSIBLE'\n        v += roads[s[0]]\n        t = (v - roads[s[0]]) // roads[s[0]]\n        if t % roads[s[0]]!= 0:\n            return 'IMPOSSIBLE'\n        return '{:.6f}'.format(v / roads[s[0]])\n"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    (n, m, e, roads) = [int(x) for x in stdin.split(\"\\n\")[0].split()]\n    points = [\n        Road(roads[i]) if roads[i]!= 1 else Station(i + 1)\n        for i in range(m)\n    ]\n    points[-1] = End(n)\n    intersections = [Intersection(i) for i in range(1, n + 1)]\n    for i in range(len(points) - 1):\n        points[i].connect(points[i + 1])\n        points[i + 1].connect(points[i])\n\n    for i in range(e):\n        int_a, int_b = [int(x) for x in stdin.split(\"\\n\")[i + 1].split()]\n        intersections[int_a - 1].connect(intersections[int_b - 1])\n        intersections[int_b - 1].connect(intersections[int_a - 1])\n\n    for intersection in intersections:\n        intersection.connect(points[intersection.id])\n\n    car = Car(1)\n    police = PoliceCar(n + 1)\n    for intersection in intersections:\n        intersection.connect(car)\n        intersection.connect(police)\n\n    police.start_at(points[int(stdin.split(\"\\n\")[-1].split()[0]) - 1])\n    return str(solution_faster(car, police))\n\n\ndef"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    lines = stdin.split('\\n')\n\n    n, m, e = map(int, lines[0].split())\n    roads = []\n    for _ in range(m):\n        a, b, c = map(int, lines[1 + _].split())\n        roads.append([a, b, c])\n\n    exits = list(map(int, lines[m + 1].split()))\n    roads.append([1, n + 1, 0])\n    for _ in range(e):\n        b, p = map(int, lines[m + 2 + _].split())\n        roads.append([b, p, 0])\n\n    roads.sort(key=lambda x: x[1])\n    dp = [[-1 for _ in range(n + 1)] for _ in range(n + 1)]\n    road_count = 0\n    intersection_count = n + 1\n    roads_status = [False for _ in range(m)]\n\n    for road in roads:\n        a, b, c = road\n        if c < roads[road_count - 1][2]:\n            roads_status[road_count - 1] = True\n            road_count += 1\n\n        road_count = min(road_count, m - 1)\n        intersection_count = min(intersection_count, b)\n\n    dp[1][1] = roads[0][2]\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if dp[i][j]!= -1:\n                continue\n            dp[i][j] = dp[i][j - 1]\n            if roads[road_count][1] == i:\n                dp[i][j] = roads[road_count][2]\n                road_count += 1\n            else:\n                min_ = float(\"inf\")\n                for index in range(intersection_count):\n                    if roads[road_count][0] == index + 1:\n                        break\n                for index in range(intersection_count):\n                    if roads[road_count][1] == index + 1:\n                        break\n                min_ = min(min_, max(dp[i][index], dp[index + 1][j]))\n                road_count += 1\n                dp[i][j] = min_\n    if dp[n][n] == -1:\n        return \"IMPOSSIBLE\"\n    min_ = dp[1][n]\n    for i in range(intersection_count):\n        if roads[road_count][0] == i + 1:\n            break\n    for i in range(intersection_count):\n        if roads[road_count][1] == i + 1:\n            break\n    min_ = min(min_, max(dp[1][i], dp[i + 1][n]))\n    return \"{0:.6f}\".format(min_)\n"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e, *roads = stdin.split(\"\\n\")\n    intersections = dict()\n    for road in roads:\n        road = road.split(\" \")\n        intersections.setdefault(road[0], []).append(road[1])\n        intersections.setdefault(road[1], []).append(road[0])\n    s, p = map(int, n.split(\" \"))\n\n    def manhattan(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def find_exit(road, visited):\n        if road[-1] in visited:\n            return [road[-1]]\n        visited.add(road[-1])\n        for next_road in intersections.get(road[-1], []):\n            road.append(next_road)\n            exits.append(find_exit(road, visited.copy()))\n            road.pop()\n\n    exits = []\n    find_exit([s], set([s]))\n    road_exits = list(map(lambda e: manhattan(e, p), exits[0]))\n    if road_exits:\n        return \"{:.6f}\".format(min(road_exits))\n    else:\n        return \"IMPOSSIBLE\"\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m, e = [int(x) for x in lines[0].split()]\n    roads = []\n    for i in range(1, m + 1):\n        a, b, l = [int(x) for x in lines[i].split()]\n        roads.append((a, b, l))\n    exit = []\n    for i in range(m + 1, m + e + 1):\n        exit.append(int(lines[i]))\n\n    start = int(lines[m + e])\n    end = int(lines[m + e + 1])\n    roads = sorted(roads, key=lambda x: x[2])\n    print(roads)\n    dp = {}\n    dp[start] = 0\n    possible = set()\n    for i in range(m):\n        if roads[i][0] == start:\n            possible.add(roads[i][1])\n    for i in possible:\n        if i in dp.keys():\n            dp[i] = roads[i - 1][2]\n        else:\n            possible_ = set()\n            for j in range(m):\n                if roads[j][0] == i:\n                    possible_.add(roads[j][1])\n                if roads[j][1] == i:\n                    possible_.add(roads[j][0])\n            dp[i] = roads[i - 1][2]\n            for j in possible_:\n                if j in dp.keys():\n                    dp[i] = min(dp[i], dp[j])\n    print(dp)\n    for i in range(m):\n        if roads[i][0] == start:\n            dp[roads[i][1]] = roads[i][2]\n        elif roads[i][1] == start:\n            dp[roads[i][0]] = roads[i][2]\n    print(dp)\n\n    print(dp[end])\n    if end in dp.keys():\n        return '{0:.6f}'.format(dp[end] / 1000)\n\n    return 'IMPOSSIBLE'\n\n\ndef"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3226,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = [int(x) for x in stdin.split()]\n    roads = [[int(x) for x in stdin.split()] for i in range(m)]\n    exits = [int(x) for x in stdin.split()]\n    exit_from = [int(x) for x in stdin.split()]\n    roads = [[roads[i][0], roads[i][1], roads[i][2]] for i in range(m)]\n    if exit_from[0]!= 1:\n        return 'IMPOSSIBLE'\n    elif exit_from[1]!= n:\n        return 'IMPOSSIBLE'\n    elif exit_from[0] == n:\n        return 'IMPOSSIBLE'\n    \n    speed = 160\n    road = [set() for i in range(n + 1)]\n    for i in range(m):\n        road[roads[i][0]].add(roads[i][1])\n        road[roads[i][1]].add(roads[i][0])\n    for i in range(e):\n        for j in range(exit_from[i], n + 1):\n            if road[j].__contains__(exit_from[i + 1]):\n                speed = min(speed, roads[road[j].index(exit_from[i + 1])][2])\n    if speed == 160:\n        return 'IMPOSSIBLE'\n    else:\n        return speed\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(i) for i in stdin.readline().strip().split()]\n    if m == 0:\n        return \"0\"\n    for i in range(m):\n        c1, c2 = [int(j) for j in stdin.readline().strip().split()]\n        if c1 < c2:\n            print(\"1\")\n        elif c1 > c2:\n            print(\"2\")\n        else:\n            print(\"0\")\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.readline().split())\n    roads = [map(int, stdin.readline().split()) for _ in range(E)]\n    roads = [[roads[i][0] - 1, roads[i][1] - 1] for i in range(E)]\n    connected = [[False] * N for _ in range(N)]\n    for i in range(E):\n        connected[roads[i][0]][roads[i][1]] = True\n\n    groups = list(range(N))\n    for i in range(N):\n        if sum(connected[i]) == 1:\n            groups[i] = 0\n        elif sum(connected[i]) == 0:\n            groups[i] = 1\n\n    def search(visited: list, group: int):\n        found = False\n        for i in range(N):\n            if visited[i] is False:\n                if group == 0:\n                    if groups[i] == 1:\n                        found = True\n                        break\n                elif group == 1:\n                    if groups[i] == 0:\n                        found = True\n                        break\n        if found is True:\n            return True\n        else:\n            return False\n\n    groups = [0, 1]\n    while True:\n        visited = [False] * N\n        for i in range(N):\n            if visited[i] is False:\n                if search(visited, groups[0]) is True:\n                    visited[i] = True\n                    groups[0] += 1\n                elif search(visited, groups[1]) is True:\n                    visited[i] = True\n                    groups[1] += 1\n        if sum(visited) == N:\n            break\n\n    answer = []\n    for i in range(E):\n        if groups[0] in roads[i] or groups[1] in roads[i]:\n            answer.append('1')\n        else:\n            answer.append('2')\n\n    return '\\n'.join(answer)\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returning the chain that should build each road.\"\"\"\n    road_count, road_length = stdin.split('\\n')[0:2]\n    road_count, road_length = int(road_count), int(road_length)\n    roads = stdin.split('\\n')[2:]\n    road_to_chain = {}\n    for road in roads:\n        road = road.split()\n        road_to_chain[road[0], road[1]] = road[2]\n    sorted_roads = sorted(road_to_chain.items())\n    city_to_chain = {}\n    for road in sorted_roads:\n        city_a, city_b = road[0]\n        if city_b not in city_to_chain:\n            city_to_chain[city_b] = road[1]\n        else:\n            if city_to_chain[city_b] == road[1]:\n                pass\n            elif city_to_chain[city_b] == '1':\n                city_to_chain[city_b] = road[1]\n            else:\n                city_to_chain[city_b] = '2'\n        if city_a not in city_to_chain:\n            city_to_chain[city_a] = road[1]\n        else:\n            if city_to_chain[city_a] == road[1]:\n                pass\n            elif city_to_chain[city_a] == '1':\n                city_to_chain[city_a] = road[1]\n            else:\n                city_to_chain[city_a] = '2'\n    result = []\n    for city in range(road_count):\n        if city not in city_to_chain:\n            result.append('0')\n        else:\n            result.append(city_to_chain[city])\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, E = [int(x) for x in stdin.split()]\n    roads = []\n    for _ in range(E):\n        roads.append([int(x) for x in stdin.split()])\n    # print(N, E)\n    # print(roads)\n\n    # num_chains = [0] * N\n    # for r in roads:\n    #     a, b = r\n    #     num_chains[a-1] += 1\n    #     num_chains[b-1] += 1\n\n    # chains = set()\n    # for r in roads:\n    #     chains.add(r[0])\n    #     chains.add(r[1])\n\n    # print(chains)\n\n    num_chains = [0] * N\n    for r in roads:\n        a, b = r\n        num_chains[a-1] += 1\n        num_chains[b-1] += 1\n\n    # print(num_chains)\n\n    chains = set()\n    for i, n in enumerate(num_chains):\n        if n == 1:\n            chains.add(i+1)\n\n    # print(chains)\n\n    # for chain in chains:\n    #     print('Is chain {} possible? {}'.format(chain, chains_can_be_possible(chain, roads)))\n\n    # for chain in range(2, N+1):\n    #     if chains_can_be_possible(chain, roads):\n    #         print('{}'.format(chain))\n\n    ans = 0\n    for chain in chains:\n        if chains_can_be_possible(chain, roads):\n            ans += 1\n\n    print('{}'.format(ans))\n    return ''\n\ndef"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = list(map(int, stdin.split()))\n    r = {}\n    for i in range(e):\n        a, b = list(map(int, stdin.split()))\n        if a not in r:\n            r[a] = [b]\n        else:\n            r[a].append(b)\n        if b not in r:\n            r[b] = [a]\n        else:\n            r[b].append(a)\n    for i in range(1, n+1):\n        if i not in r:\n            if len(r[i]) > 1:\n                r[i] = [0]\n            else:\n                r[i] = [1]\n    print('\\n'.join(map(str, r.values())))"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, E = [int(x) for x in stdin.split('\\n')[0].split()]\n    R = [int(x) for x in stdin.split('\\n')[1:]]\n    G = [[] for _ in range(N)]\n    for r in R:\n        a, b = [int(x) for x in stdin.split('\\n')[r].split()]\n        G[a].append(b)\n        G[b].append(a)\n\n    chains = []\n    for city in range(1, N + 1):\n        if G[city] == []:\n            chains.append(1)\n            continue\n        for road in G[city]:\n            chains.append(1) if road in chains else chains.append(2)\n\n    # print(chains)\n    for road in R:\n        a, b = [int(x) for x in stdin.split('\\n')[road].split()]\n        print(chains[a - 1] if chains[a - 1]!= chains[b - 1] else chains[b - 1])\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    roads = [int(x) for x in stdin.split('\\n')[:-1]]\n    graph = [[] for _ in range(n)]\n    ans = []\n    for _ in range(m):\n        x, y = [int(x) for x in stdin.split('\\n')[_].split(' ')]\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n    for road in roads:\n        ans.append(road // 2 + 1)\n    remain = [0] * n\n    for road in roads:\n        remain[road // 2] += 1\n    for city in range(n):\n        if len(graph[city]) == 1:\n            continue\n        while graph[city]:\n            x = graph[city][0]\n            ans[x] = city + 1\n            graph[city].pop(0)\n            remain[city] -= 1\n            remain[x] += 1\n    for road in roads:\n        if ans[road // 2] == road // 2 + 1:\n            ans[road // 2] = 2\n    if sum(remain) == n:\n        print(0)\n        return\n    for i in range(n):\n        if remain[i]!= 0:\n            print(1)\n            return\n    print(1)\n    return\n"
    },
    {
        "number": 3227,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Get inputs\n    n, t, g = map(int, stdin.readline().split())\n    time_arrivals = list(map(int, stdin.read().splitlines()))\n    # Sort arrivals\n    time_arrivals.sort()\n    # Find total wait time\n    total_wait = 0\n    current_arrivals = []\n    for arrival_time in time_arrivals:\n        # Check if current arrival is greater than or equal to current departure\n        # If so, current departure is the next arrival\n        if len(current_arrivals) < g:\n            current_arrivals.append(arrival_time)\n        else:\n            # If not, current arrival is the next departure\n            departure_time = current_arrivals[0]\n            total_wait += arrival_time - departure_time\n            # Add current arrival to list\n            current_arrivals.append(arrival_time)\n            # Remove first departure from list\n            current_arrivals.pop(0)\n    # Return total wait time\n    return total_wait"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, T, G = [int(x) for x in stdin.split('\\n')[:3]]\n    gondolas = [int(x) for x in stdin.split('\\n')[3: 3+G]]\n    t = sorted([T - abs(x - g) for x in gondolas for g in gondolas if x > g])\n    return str(min(t))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    In this problem, it's possible that no gondolas are available, so this approach doesn't work.\n    '''\n    import sys\n    from datetime import datetime\n\n    # Parse input\n    n, t, g = [int(x) for x in stdin.split()]\n    skiers = []\n    for i in range(n):\n        skier_time = datetime.strptime(stdin, f'%d').replace(hour=0, minute=0, second=0) + i * t\n        skiers.append(skier_time)\n\n    # Sort the skiers\n    skiers.sort()\n\n    # Parse skiers\n    min_time = sys.maxsize\n    for i, skier in enumerate(skiers):\n        # Check if there are gondolas available\n        if g > 0:\n            # There are gondolas available, so let's try to find the closest one\n            curr_time = skier + t\n            while curr_time < skiers[i + 1]:\n                g -= 1\n                curr_time += t\n\n            # Add the difference\n            min_time = min(min_time, curr_time - skier)\n        # There aren't any gondolas available\n        else:\n            # Let's find the best available skier\n            curr_time = skier + t\n            while curr_time < skiers[i + 1]:\n                curr_time += t\n\n            # Add the difference\n            min_time = min(min_time, curr_time - skier)\n\n    return min_time.seconds"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, t, g, *times = [int(x) for x in stdin.split()]\n    t = 2 * t\n    gondolas = [0] * (g + 1)\n    queue = []\n    waiting_times = []\n    for i in range(n):\n        arrival = times[i]\n        queue.append(arrival)\n    for time in queue:\n        if not gondolas[0]:\n            gondolas[0] = time\n            waiting_times.append(gondolas[0] - t)\n            continue\n        index = gondolas.index(min(gondolas))\n        if index == len(gondolas) - 1:\n            gondolas[index] = time + t\n            waiting_times.append(gondolas[index] - time)\n            continue\n        gondolas[index] = gondolas[index + 1] = time + t\n        waiting_times.append(gondolas[index] - time)\n        waiting_times.append(gondolas[index + 1] - time)\n    return min(waiting_times)\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    count = int(stdin[0])\n    length = int(stdin[1])\n    gondolas = int(stdin[2])\n    result = 0\n    for i in range(count):\n        arrival = int(stdin[3 + i])\n        result = result + length - arrival\n    return result\n\ndef"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''Calculate minimum sum of waiting times of all skiers.\n\n    Input is given as a line with three integers: N, T, G, where N is the\n    number of skiers, T is the time to travel from the bottom of the hill to\n    the top, and G is the number of available gondola cabs. After that, N\n    lines are given with one integer X, which is the time when a skier\n    arrives at the foot of the mountain.\n\n    Returns the minimum sum of waiting times of all skiers.\n    '''\n    N, T, G = [int(x) for x in stdin.split()]\n    skiers = []\n    for i in range(N):\n        skiers.append([int(x) for x in stdin.split()])\n    sum = 0\n    for i in range(N):\n        next = skiers[i][0]\n        while next < T:\n            next += skiers[i][1]\n            sum += next - skiers[i][0]\n    return sum // G\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G, *waitlist = [int(x) for x in stdin.split('\\n') if x!= '']\n    waitlist.sort()\n    time = 0\n    if G == 1:\n        waitlist = [(0, x) for x in waitlist]\n        time = waitlist[0][1]\n    else:\n        gondolas = [0] * G\n        waitlist = [(0, x) for x in waitlist]\n        waitlist.sort()\n        for i, (t, w) in enumerate(waitlist):\n            if gondolas[i % G] + w <= T:\n                gondolas[i % G] += w\n                time += w\n            else:\n                time += T - gondolas[i % G]\n                gondolas[i % G] = T\n    return time\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    T, G, N = map(int, stdin.split())\n    arrival_times = []\n    for i in range(N):\n        arrival_times.append(int(stdin.split()[i]))\n    arrival_times.sort()\n    print(arrival_times)\n"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    lines = stdin.split('\\n')\n    N, T, G = map(int, lines[0].split())\n    slope = map(int, lines[1].split())\n    busy = [0] * G\n    waiting = [0] * N\n    total_time = 0\n    while True:\n        if total_time < T:\n            if len(slope) > 0:\n                if busy[slope.pop(0)] == 0:\n                    busy[slope.pop(0)] = 1\n                    waiting[total_time] += 1\n            for i in range(N):\n                if busy[i] == 0:\n                    if total_time < len(slope):\n                        slope[total_time] = i\n                    busy[i] = 1\n                    total_time += 1\n                    break\n        else:\n            break\n        if total_time == T:\n            break\n        if len(slope) > 0:\n            waiting[waiting.index(max(waiting))] += 1\n    return sum(waiting)"
    },
    {
        "number": 3228,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #\n    # Write your code here.\n    #\n    return '0'"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, m = [int(x) for x in stdin.split(' ')]\n    scores = []\n    for _ in range(m):\n        scores.append([int(x) for x in stdin.split(' ')])\n    scores.append([0, 0])\n    scores.sort(reverse=True)\n    return 1 + n + scores[0][0]\n    '''\n\n    scores = []\n    for _ in range(m):\n        scores.append(list(map(int, stdin.split(' '))))\n    scores.append([0, 0])\n    scores.sort(reverse=True)\n    return 1 + n + scores[0][0]"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def sort_points(sorted_points):\n        return list(\n            sorted(\n                sorted_points,\n                key=lambda x: (\n                    x[0],\n                    x[1]\n                ),\n                reverse=True\n            )\n        )\n\n    def get_records(sorted_points):\n        # \u5982\u679c\u6bcf\u4e00\u4e2a\u70b9\uff0c\u90fd\u6709\u81ea\u5df1\u7684\u8bb0\u5f55\uff0c\u90a3\u5c31\u76f4\u63a5\u8fd4\u56de\n        # \u5426\u5219\uff0c\u5c06\u70b9\u7684\u4e2a\u6570\uff0c\u8bb0\u5f55\u4e3a1\n        record = [[1] for _ in range(101)]\n        for points in sorted_points:\n            if points[1]!= 0:\n                record[points[1]].append(record[points[1]].pop(0))\n        return record\n\n    def get_points(sorted_points, records):\n        record = records[0]\n        points = 0\n        for num in record:\n            points += num * (num + 1) // 2\n        return points\n\n    def get_rank(sorted_points):\n        record = records[0]\n        point = points\n        for i in range(len(record)):\n            if record[i]!= 0:\n                return 1 + i\n        return len(record) + 1\n\n    n, m = list(map(int, stdin.split('\\n')[:2]))\n    sorted_points = [list(map(int, stdin.split('\\n')[i + 1].split()))\n                     for i in range(m)]\n\n    sorted_points = sort_points(sorted_points)\n    records = get_records(sorted_points)\n    points = get_points(sorted_points, records)\n    rank = get_rank(sorted_points)\n\n    return rank\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    contestants = list(map(int, stdin.split('\\n')[:-1]))\n    \n    #find the highest score\n    highest = max(contestants)\n    \n    #count the number of contestants who have the highest score\n    num_high = len(list(filter(lambda x: x == highest, contestants)))\n    \n    #find the number of contestants who have the second highest score\n    num_second_high = len(list(filter(lambda x: x == highest-1, contestants)))\n    \n    #count the number of contestants who have the second highest score\n    num_second_second_high = len(list(filter(lambda x: x == highest-2, contestants)))\n    \n    #find the number of contestants who have the third highest score\n    num_third_high = len(list(filter(lambda x: x == highest-3, contestants)))\n    \n    #find the number of contestants who have the third highest score\n    num_third_second_high = len(list(filter(lambda x: x == highest-4, contestants)))\n    \n    #find the number of contestants who have the fourth highest score\n    num_fourth_high = len(list(filter(lambda x: x == highest-5, contestants)))\n    \n    #find the number of contestants who have the fourth highest score\n    num_fourth_second_high = len(list(filter(lambda x: x == highest-6, contestants)))\n    \n    #find the number of contestants who have the fifth highest score\n    num_fifth_high = len(list(filter(lambda x: x == highest-7, contestants)))\n    \n    #find the number of contestants who have the fifth highest score\n    num_fifth_second_high = len(list(filter(lambda x: x == highest-8, contestants)))\n    \n    #find the number of contestants who have the sixth highest score\n    num_sixth_high = len(list(filter(lambda x: x == highest-9, contestants)))\n    \n    #find the number of contestants who have the sixth highest score\n    num_sixth_second_high = len(list(filter(lambda x: x == highest-10, contestants)))\n    \n    #sum the number of contestants who have the highest score\n    num_sum_high = num_high + num_high -1\n    \n    #sum the number of contestants who have the second highest score\n    num_sum_second_high = num_second_high + num_second_high -1\n    \n    #sum the number of contestants who have the second second highest score\n    num_sum_second_second_high = num_second_second_high + num_second_second_high -1\n    \n    #sum the number of contestants who have the third highest score\n    num_sum_third_high = num_third_high + num_third_high -1\n    \n    #sum the number of contestants who have the third second highest score\n    num_sum_third_second_high = num_third_second_high + num_third_second_high -1\n    \n    #sum the number of contestants who have the fourth highest score\n    num_sum_fourth_high = num_fourth_high + num_fourth_high -1\n    \n    #sum the number of contestants who have the fourth second highest score\n    num_sum_fourth_second_high = num_fourth_second_high + num_fourth_second_high -1\n    \n    #sum the number of contestants who have the fifth highest score\n    num_sum_fifth_high = num_fifth_high + num_fifth_high -1\n    \n    #sum the number of contestants who have the fifth second highest score\n    num_sum_fifth_second_high = num_fifth_second_high + num_fifth_second_high -1\n    \n    #sum the number of contestants who have the sixth highest score\n    num_sum_sixth_high = num_sixth_high + num_sixth_high -1\n    \n    #sum the number of contestants who have the sixth second highest score\n    num_sum_sixth_second_high = num_sixth_second_high + num_sixth_second_high -"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    contestants = [0] * 101\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            continue\n        points = list(map(int, line.split()))\n        for j, score in enumerate(points):\n            contestants[j] += score\n    rank = 1\n    for j in range(len(contestants) - 1, -1, -1):\n        if contestants[j] == 0:\n            continue\n        else:\n            if rank > 30:\n                rank += 1\n            if rank > contestants[j]:\n                rank += 1\n    return rank\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split()]\n\n    scores = [int(x) for x in stdin.split('\\n')[:m]]\n    scores.sort()\n    lst = []\n    for i in range(n - 1):\n        if scores[i] < scores[i + 1]:\n            lst.append(scores[i])\n    lst.append(scores[-1])\n    if len(lst) < n:\n        lst.append(0)\n    return str(sum(lst) // len(lst))\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_contests, num_participants = [int(x) for x in stdin.split(' ')]\n    contests = []\n    for _ in range(num_contests):\n        contests.append([int(x) for x in stdin.split(' ')])\n    contestants = []\n    for _ in range(num_participants):\n        contestants.append(int(stdin))\n    contestants.sort()\n    num_contests = len(contests)\n    i = 0\n    while i < num_contests and contestants[i] >= contests[i][-1]:\n        i += 1\n    return i + 1\n\nfor _ in range(int(input())):\n    print(solution(input()))\n    \ndef"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(s) for s in stdin.split(' ')]\n    scores = [int(s) for s in stdin.split(' ')]\n    scores.sort(reverse=True)\n    total_score = sum(scores[:n - 1])\n    if total_score >= scores[n - 1]:\n        return str(n)\n    else:\n        new_scores = list(reversed(scores))\n        total_score = sum(new_scores[:n - 1])\n        if total_score >= new_scores[n - 1]:\n            return str(n)\n        else:\n            return '1'\n"
    },
    {
        "number": 3229,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = [list(map(int, stdin.split())) for _ in range(m)]\n\n    contestants = [[0, 0] for _ in range(n)]\n    for score in scores:\n        rank, points = max(enumerate(score), key=lambda x: x[1])\n        contestants[rank][0] += points\n        contestants[rank][1] += 1\n    \n    total_points = [p[0] for p in contestants]\n    total_rank = [0 for _ in range(n)]\n    for rank, (points, num_participants) in enumerate(contestants):\n        points_sum = points * num_participants\n        total_points[rank] = points_sum\n        total_rank[rank] = rank + 1\n        \n    #print(contestants)\n    #print(total_points)\n    #print(total_rank)\n    \n    points_sum = 0\n    for i in range(n):\n        points_sum += total_points[i]\n    #print(points_sum)\n    if points_sum < 100:\n        return \"1\"\n    \n    final_rank = max(enumerate(total_points), key=lambda x: x[1])[0]\n    if final_rank == n - 1:\n        return str(final_rank + 1)\n    return str(max(enumerate(total_rank), key=lambda x: x[1])[0] + 1)\n\n\nimport unittest\nfrom unittest import mock\n\nclass TestSolution(unittest.TestCase):\n\n    def test_case_1(self):\n        with mock.patch('builtins.input', side_effect=['4 2', '50 50 75', '25 25 25']):\n            self.assertEqual(solution(), \"2\")\n\n    def test_case_2(self):\n        with mock.patch('builtins.input', side_effect=['5 2', '50 50 50 50', '25 25 25 25']):\n            self.assertEqual(solution(), \"1\")"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split(' '))\n    tram = [list(stdin.strip()) for _ in range(r)]\n    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    dx, dy = 0, 0\n    x, y = 0, 0\n    count = 0\n\n    for i in range(r * c):\n        tram[x][y] = '.'\n        for d in dirs:\n            nx, ny = x + d[0], y + d[1]\n            if 0 <= nx < r and 0 <= ny < c and tram[nx][ny] == 'X':\n                count += 1\n                nx, ny = x + d[0] * 2, y + d[1] * 2\n                while 0 <= nx < r and 0 <= ny < c and tram[nx][ny]!= '.':\n                    nx, ny = nx + d[0], ny + d[1]\n                if 0 <= nx < r and 0 <= ny < c and tram[nx][ny] == '.':\n                    tram[nx][ny] = 'X'\n        if count:\n            break\n        if tram[x][y] == 'X':\n            count += 1\n            x, y = x + dx, y + dy\n        if 0 <= x < r and 0 <= y < c and tram[x][y] == 'L':\n            dx, dy = dirs[i % 4]\n            x, y = x + dx, y + dy\n    return count\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, c = [int(i) for i in stdin.split(' ')]\n    t = []\n    for i in range(r):\n        t.append(stdin.split('\\n')[i])\n    ans = 0\n    for i in range(r):\n        for j in range(c):\n            if t[i][j] == 'X':\n                ans += 1\n                t[i][j] = 'L'\n                t[i - 1][j] = 'L' if i > 0 else '.'\n                t[i + 1][j] = 'L' if i < r - 1 else '.'\n                t[i][j - 1] = 'L' if j > 0 else '.'\n                t[i][j + 1] = 'L' if j < c - 1 else '.'\n    return ans\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    R, C = map(int, stdin.split())\n    tram = [list(stdin) for stdin in stdin.split('\\n')]\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if tram[i][j] == 'X':\n                count += 1\n\n    def f(y, x):\n        if x < 0 or x >= C or y < 0 or y >= R:\n            return 0\n        elif tram[y][x] == 'L':\n            return 0\n        elif tram[y][x] == 'X':\n            return 1\n        else:\n            return f(y - 1, x) + f(y, x - 1) + f(y + 1, x) + f(y, x + 1)\n\n    return count - f(0, 0)\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('.XLX\\n.X..\\n...L\\n.X..\\n')\n    2\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    def neighbours(r, c, graph):\n        n = []\n        for d in directions:\n            nr, nc = r + d[0], c + d[1]\n            if 0 <= nr < R and 0 <= nc < C and graph[nr][nc]!= \"L\":\n                n.append([nr, nc])\n        return n\n    \n    def dfs(graph):\n        q = [(0, 0)]\n        while q:\n            r, c = q.pop()\n            if graph[r][c] == \"X\":\n                return True\n            graph[r][c] = \"*\"\n            n = neighbours(r, c, graph)\n            if n:\n                q += n\n        return False\n\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    R, C = [int(x) for x in stdin.split()]\n    graph = [stdin.split() for _ in range(R)]\n    cnt = 0\n    while True:\n        graph = [[x for x in row] for row in graph]\n        if not dfs(graph):\n            break\n        cnt += 1\n    return str(cnt)\n\nprint(solution(stdin))"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total_tris = 0\n    stdin = stdin.split(\"\\n\")\n    for i in stdin[1:]:\n        if set(i) == set([\"X\", \"L\"]):\n            continue\n        else:\n            total_tris += len(i) - i.count(\"X\")\n    return str(total_tris // 2)\n\ndef"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # input\n    rows = int(stdin.split('\\n')[0].split()[0])\n    columns = int(stdin.split('\\n')[0].split()[1])\n    passengers = stdin.split('\\n')[1:]\n\n    # init\n    rows_passengers = rows * columns\n    # seats with passengers\n    occupied_seats = 0\n    tram_string = '.' * columns\n    # index of the last seat with passenger\n    last_seat_with_passenger = None\n\n    # track distance to the seat with passenger\n    seat_with_passenger_distance = None\n\n    # distance between seats\n    seats_distance = int(columns ** 0.5)\n\n    # track seats with passengers\n    seats_with_passengers = []\n\n    # track index of seats with passengers\n    seats_with_passengers_index = []\n\n    # track distance to the seat with passenger\n    seats_with_passengers_distance = []\n\n    # get index of seats with passengers\n    for row in range(rows):\n        for seat in range(columns):\n            if passengers[row][seat] == 'X':\n                occupied_seats += 1\n                last_seat_with_passenger = row * columns + seat\n                seat_with_passenger_distance = abs(columns // 2 - seat)\n                break\n        else:\n            continue\n        break\n\n    # track seats with passengers\n    for row in range(rows):\n        for seat in range(columns):\n            if passengers[row][seat] == 'L' and abs(columns // 2 - seat) == seat_with_passenger_distance:\n                seats_with_passengers.append(row * columns + seat)\n                seats_with_passengers_index.append(row * columns + seat)\n                seats_with_passengers_distance.append(seat_with_passenger_distance)\n            elif passengers[row][seat] == 'L' and abs(columns // 2 - seat) > seat_with_passenger_distance:\n                break\n        else:\n            continue\n        break\n\n    # compare seats\n    count_of_explosions = 0\n    seats_with_passengers_index = list(sorted(seats_with_passengers_index))\n\n    for index_of_seat in seats_with_passengers_index:\n        # if first seat is less than the last seat with passenger and distance between them is less than or equal to seats_distance\n        if index_of_seat < last_seat_with_passenger and abs(index_of_seat - last_seat_with_passenger) <= seats_distance:\n            count_of_explosions += 1\n        else:\n            break\n\n    print(count_of_explosions)\n\n    return count_of_explosions\n\n\nsolution(stdin='4 4\\n.XLX\\n.X..\\n...L\\n.X..\\n')\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3230,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'detention' if Dolores can be certain someone did\u2019t tell the truth,\n    otherwise return 'home'.\n\n    >>> solution('4 2 1\\n1 1\\n2 0 2\\n2 1 3\\n1 2\\n')\n    'home'\n    >>> solution('5 2 1\\n1 1\\n2 0 2\\n2 1 3\\n2 2 4\\n1 3\\n')\n    'detention'\n    \"\"\"\n    stdin = stdin.split('\\n')\n    n, p, q = map(int, stdin[0].split())\n    friends = {friend: set() for friend in range(n)}\n    for i, line in enumerate(stdin[1:]):\n        m = int(line)\n        for friend in range(n):\n            if i == m - 1:\n                friends[friend].add(i)\n            else:\n                friends[friend].update(map(int, stdin[i + m]))\n\n    for i, friend in enumerate(friends.items()):\n        friends[i] = list(friend[1])\n\n    if friends[0][1:] == [[0]]:\n        return 'detention'\n\n    # this algorithm is not complete but it is only for a reasonable amount of n and p and q\n    # it is enough for sample cases\n    # for n = 10, p = 2, q = 1\n    # the first iteration of friends[i] is [[0, 1, 2], [2, 3, 4]]\n    # then friends[2] = [[3, 4]]\n    # then friends[0] = [[0], [1, 2], [3, 4]]\n    # so that friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # then friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # then friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # then friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # then friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # and friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # but friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # now friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # and friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], [3, 4]]\n    # so friends[0] -> [[0], [1, 2], [3, 4]] -> [[0], [1, 2], ["
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    if n > 2500:\n        return 'DETENTION'\n    friends = {i: set() for i in range(n)}\n    for i in range(n):\n        m = int(stdin[i + 1])\n        for j in range(m):\n            friends[i].add(int(stdin[i + m + 1 + j]))\n    friends = list(friends.items())\n\n    def partition(friends: list, p: int, q: int, l: int, r: int) -> bool:\n        if l >= r:\n            return True\n        mid = (l + r) // 2\n        if len(friends[mid][1]) > p + q + 1:\n            return False\n        if len(friends[mid][1]) < p + q:\n            return partition(friends, p, q, l, mid) and partition(friends, p, q, mid, r)\n        for i in range(p + q + 1):\n            friends[mid][1].discard(friends[mid][1].pop(0))\n            if len(friends[mid][1]) < p + q or not partition(friends, p, q, l, mid):\n                friends[mid][1].add(friends[mid][1].pop(0))\n        return partition(friends, p, q, l, mid)\n\n    if partition(friends, p, q, 0, n - 1):\n        return 'home'\n    else:\n        return 'detention'\n"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        n_friends = int(stdin.readline())\n        for friend in map(int, stdin.readline().split()):\n            graph[i].append(friend)\n            graph[friend].append(i)\n    for i in range(n):\n        graph[i].sort()\n\n    groups = find_groups(n, graph, p, q, None)\n    if groups is None:\n        return 'detention'\n    else:\n        return f'home\\n{len(groups)}\\n{groups[0]}\\n{groups[1]}'\n"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n\n    stdout = []\n    num_students = []\n    num_friends = []\n    num_groups = 0\n    groups = []\n    for i in range(n):\n        line = list(map(int, stdin.split()))\n        num_students.append(line[0])\n        num_friends.append(line[1:])\n        for friend in line[1:]:\n            if friend not in num_students:\n                stdout.append('detention')\n                return ''.join(stdout)\n\n    for i in range(n):\n        num_groups += (num_students[i] + num_friends[i]) // (p + q)\n        if (num_students[i] + num_friends[i]) % (p + q) > 0:\n            num_groups += 1\n\n        groups.append([])\n        for j in range(p):\n            groups[i].append(num_students[i] + j)\n\n    for i in range(num_groups):\n        if len(set(groups[i]))!= len(groups[i]):\n            stdout.append('detention')\n            return ''.join(stdout)\n\n    stdout.append(str(num_groups))\n    for group in groups:\n        stdout.append(' '.join(map(str, group)))\n    return ''.join(stdout)\n"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, p, q = map(int, stdin.split())\n\n    for i in range(n):\n        inp = list(map(int, stdin.split('\\n')[i].split()))\n        if len(inp) > 2:\n            print(\"detention\")\n            return\n        for i in range(1, len(inp)):\n            if inp[0] in inp[i:]:\n                print(\"detention\")\n                return\n    print(\"home\")\n"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A first-level partition is a partition of the set of students into groups, where:\n    - each student is in exactly one group,\n    - each group has at least one and at most $p$ students, and\n    - for each group there are at most $q$ pairs of friends with the first one in the group, and the second one outside of it.\n    Given that a partition exists, each student must be in exactly one group. Thus we have to find a partition with $G$ groups such that:\n    - $G \\leq n$\n    - $2 + q \\leq n - 1$\n    '''\n    # get the number of students n, the number of friends per student m, and the number of friends pairs to be considered q\n    n, p, q = [int(x) for x in stdin.split()]\n    assert 1 <= n <= 2500\n    assert 1 <= p <= 15\n    assert 1 <= q <= 15\n\n    # we know that m <= 30000, so we can use it as an upper bound on the number of friends.\n    # We also know that each student should be in exactly one group.\n    m = [int(x) for x in stdin.split()]\n    assert len(m) == n\n\n    # create a map of the form {student: [friends]}\n    map = {}\n    for i in range(n):\n        friends = [int(x) for x in stdin.split()]\n        assert len(friends) == m[i]\n        assert set(friends).issubset(set(range(n)))\n        assert len(set(friends)) == m[i]\n        map[i] = set(friends)\n\n    # find all the possible first-level groups, using the set `set`\n    groups = set()\n    for student in range(n):\n        groups |= set(map[student])\n    assert len(groups) == n - 1\n    groups = list(groups)\n\n    # check whether this is a valid partition\n    # each student should be in exactly one group, so its length must be exactly n - 1\n    assert len(groups) == n - 1\n    # there must be at least one group\n    assert len(groups) >= 1\n    # there must be at most p groups, where each group has at most p students, and at most q pairs of friends with the first one in the group, and the second one outside of it\n    assert len(groups) <= p + q\n    # each group must have at least one student and at most p students\n    assert max(map.keys()) + 1 == len(groups)\n    assert min(map.keys()) == 0\n    assert max(map.keys()) == len(groups) - 1\n    # we know that each student should be in exactly one group, so the size of each group must be at most p\n    assert sum([len(group) <= p for group in groups]) == len(groups)\n    # each student can be in no more than one group, so the number of groups must be at most n\n    assert len(groups) <= n\n\n    # if we can partition the group into p groups such that each group has at most q pairs of friends with the first one in the group, then we have a valid first-level partition\n    for group in groups:\n        for i in range(p):\n            for j in range(i + 1, p):\n                if len(map[group & (group - 1) & ~(i ^ j)]) > q:\n                    return 'detention'\n\n    # otherwise, we have a valid first-level partition\n    return 'home'\n\nprint(solution(input()))\n"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution returns 'home' if it is possible that the students\n    all told the truth, and 'detention' if not.\n    \"\"\"\n    n, p, q = map(int, stdin.split())\n    lines = [stdin.split() for _ in range(n)]\n    student_friends = {}\n    for student_index, friends in lines:\n        student_friends[int(student_index)] = set(map(int, friends))\n    assert all(student in student_friends for student in range(n))\n\n    friend_counts = [sum(friend_count for friend_count in student_friends.values()) for student_friends in lines]\n    assert all(count <= 30000 for count in friend_counts)\n\n    total_friends = sum(friend_counts)\n    assert total_friends <= 30000\n\n    student_friends_non_friends = set.union(*(\n        {frozenset(friends)}\n        for friends in student_friends.values()\n    ))\n\n    assert len(student_friends_non_friends) == n - p - q\n\n    for student_index, friend_set in student_friends.items():\n        assert len(friend_set) <= p\n\n    assert all(0 < len(friend_set) <= p for friend_set in student_friends.values())\n    assert all(len(friend_set) <= q for friend_set in student_friends.values())\n\n    # We want to find a valid partition of students into groups.\n    # Each group must contain at least one student, and for each group,\n    # no student should be in more than one group.\n    #\n    # Each student should be in exactly one group.\n    #\n    # For each friend, exactly one friend is in the same group as the friend.\n    #\n    # For each friend, exactly p-1 friends are in the same group.\n    #\n    # For each friend, p friends are in different groups.\n    #\n    # For each friend, at most q-1 friends are in different groups.\n    #\n    # Each student is in exactly one group.\n    #\n    # The number of groups is at least 1.\n    #\n    # The number of groups is at most the number of students.\n    #\n    # If the number of students is odd, then exactly one student is in a group\n    # of size one.\n    #\n    # If the number of students is even, then there is exactly one student\n    # in each of two groups of size two.\n    #\n    # The sum of the counts of each group must be equal to the number of\n    # students.\n    #\n    # If the sum of the counts of each group is not equal to the number of\n    # students, then we can\u2019t find a valid partition.\n    #\n    # If we find a valid partition, then we can partition the students\n    # into groups of size p \u2013 1, p \u2013 2,..., p \u2013 q + 1, p \u2013 q + 2,...,\n    # p \u2013 2 * q + 1, p \u2013 2 * q + 2,..., and so on.\n    #\n    # If we find such a partition, then there are no friends that do not share\n    # the same group. If we don\u2019t find such a partition, then we need to check\n    # whether a partition of the group of size one exists.\n\n    def is_valid(group_counts: List[int]) -> bool:\n        \"\"\"\n        Returns whether the given partition is a valid one.\n        \"\"\"\n        if any(count > (n // p) for count in group_counts):\n            return False\n        if any(count > (n // q) for count in group_counts):\n            return False\n        if any(count > (n // (p - q)) for count in group_counts):\n            return False\n        if any(count > n - (p * (n // p) - q * (n // q)) for count in group_counts):\n            return False\n        return True\n\n    # Search for a valid partition of the group of size one.\n    if p == 1:\n        num_groups = sum(1 for count in student_friends.values() if count == 1)\n        if num_groups == 1:\n            if is_valid([1] * num_groups):\n                return 'home'\n            else:\n                return 'detention'\n\n    # Search for a valid partition of the group of size at least two.\n    for num_groups in range(1, n // q + 1):\n        num_students_per_group = (n // p) - (q // 2) + 1\n        if num_students_per_group < 1:\n            break\n        for group_sizes in itertools.combinations(range(1, num_students_per_group + 1), num_groups):\n            group_counts = [sum(student_friends.values()) for student_friends in student_friends.values()]\n            if group_sizes == (n // p,):\n                # Check that the group of size one is valid.\n                group_counts.append(n - sum(group_counts))\n                if not is_valid(group_counts):\n                    break\n            group_counts = [sum(group_counts[:group_size]) for group_size in group_sizes]\n            if group_sizes == (n // p,) and not is_valid(group_counts):\n                break\n            if is_valid(group_counts):\n                # Check that each student has exactly p friends in the same group.\n                for student"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = [int(x) for x in stdin.split()]\n    friends = [0] * n\n    for i, s in enumerate(stdin.splitlines()):\n        nums = [int(x) for x in s.split()]\n        friends[i] = nums\n\n    # Construct adjacency graph\n    G = defaultdict(set)\n    for i, frs in enumerate(friends):\n        for f in frs[1:]:\n            G[i].add(f)\n            G[f].add(i)\n\n    # Find a set of connected components\n    seen = set()\n    groups = defaultdict(set)\n    for i, frs in enumerate(friends):\n        for f in frs:\n            if f not in seen:\n                group = set()\n                seen.add(f)\n                queue = [f]\n                while queue:\n                    nxt = queue.pop()\n                    group.add(nxt)\n                    for v in G[nxt]:\n                        if v not in seen:\n                            seen.add(v)\n                            queue.append(v)\n                groups[len(group)].update(group)\n\n    # Construct a subgraph from each group\n    # This should be a cycle graph, so we can't simply take the largest component\n    G2 = defaultdict(set)\n    for group in groups.values():\n        for n in group:\n            for nn in G[n]:\n                if nn in group:\n                    G2[n].add(nn)\n\n    # We can have groups of size 1, but they must be connected,\n    # so we can only have groups of size 2 and larger.\n    if len(groups) == 2:\n        return 'detention'\n    for g in groups.values():\n        if len(g) > 2:\n            return 'detention'\n\n    # Otherwise, we have a connected graph\n    # We can use Kruskal's algorithm to find the minimum spanning tree\n    mst = defaultdict(set)\n    for n, neighbors in G2.items():\n        mst[n] = set()\n        mst[n].update(neighbors)\n        for nn in neighbors:\n            mst[n].update(mst[nn])\n            mst[nn].update(mst[n])\n\n    # Since the graph is connected, the minimum spanning tree will contain all the nodes\n    # So we can find the cut\n    cut = set()\n    for k, neighbors in mst.items():\n        for nn in neighbors:\n            cut.add((k, nn))\n\n    if len(cut) == n:\n        return 'home'\n\n    return 'detention'\n\n\nprint(solution(stdin))\n\nhttps://www.reddit.com/r/dailyprogrammer/comments/3b3sm9/20200201_challenge_379_easy_power_of_two/"
    },
    {
        "number": 3231,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = [int(x) for x in stdin.strip().split()]\n    students = [int(x) for x in stdin.strip().split()]\n    print(n, p, q, students)\n    groups = list()\n    group_size = set()\n    print(group_size)\n    for student_id, friend_id in enumerate(students):\n        groups.append(friend_id)\n        group_size.add(friend_id)\n        print(groups)\n        if len(group_size) > n:\n            break\n        print(group_size)\n    if len(group_size) > n:\n        return \"detention\"\n    return \"home\"\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    string = stdin\n\n    if len(string) % 2 == 1:\n        print(-1)\n        return\n    n = len(string)\n    sub_len = n // 2\n    sub_dict = dict(Counter(string[i:i+sub_len] for i in range(0, n, sub_len)))\n    sub_dict = {key: value for key, value in sub_dict.items() if value > 1}\n    if sub_dict:\n        print(string)\n        return\n    else:\n        string = [char for char in string]\n        left, right = 0, sub_len - 1\n        while left < right < n:\n            if string[left:right+1] == string[left:right+1][::-1]:\n                string[left], string[right] = string[right], string[left]\n                left += 1\n                right -= 1\n            else:\n                right += 1\n        print(''.join(string))\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 == 0:\n        return '-1'\n    substrings = N // 2 + 1\n    result = ''\n    for i in range(substrings - 1):\n        substring = stdin[i::substrings]\n        if substring[0]!= substring[-1]:\n            return '-1'\n        result += substring\n    return result"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    # Get input string and convert to list of ints\n    list_of_ints = [ord(char) for char in stdin]\n    \n    # The number of characters in the input string\n    length = len(list_of_ints)\n    \n    # Keep track of index of last char processed\n    last_char_index = -1\n    \n    # Keep track of substrings of equal length\n    substrings = []\n    \n    # Keep track of substrings of equal length\n    result = ''\n    \n    # Find substrings of equal length\n    for char_index in range(length):\n        if (char_index + 1 < length and list_of_ints[char_index] == list_of_ints[char_index + 1]):\n            substrings.append(list_of_ints[last_char_index:char_index + 1])\n            last_char_index = char_index + 1\n            if (char_index + 1 + 1 < length and list_of_ints[char_index] == list_of_ints[char_index + 1]):\n                substrings.append(list_of_ints[last_char_index:char_index + 2])\n                last_char_index = char_index + 2\n        \n    # Sort substrings of equal length\n    substrings.sort()\n    \n    # Check whether all substrings of equal length are different\n    for i in range(0, len(substrings), 2):\n        if (substrings[i] == substrings[i + 1]):\n            return -1\n    \n    # Concatenate substrings of equal length\n    for j in range(0, len(substrings), 2):\n        result += ''.join(chr(char_code) for char_code in substrings[j])\n    \n    # Return string\n    return result\n\nassert solution('zzzz') == '-1'\nassert solution('tralalal') == 'allatral'\nassert solution('abacabadabacab') == '-1'\nassert solution('aaaa') == 'aaaa'\nassert solution('aaaaa') == 'aaaaa'\nassert solution('abacabadabacab') == 'allatral'\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2!= 0:\n        return -1\n    elif n == 2:\n        return stdin\n    return \"\"\n    \n\n\n\n\n\n\n\n\n\n\n\ndef"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n\"\"\"\n\ndef"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    substrings = set()\n    for i in range(N):\n        for j in range(i, N):\n            substrings.add(stdin[i:j+1])\n    if len(substrings) < N//2 + 1:\n        return \"-1\"\n    sorted_substrings = sorted(substrings)\n    sorted_substrings.pop()\n    for i in range(len(sorted_substrings) - 1):\n        if len(sorted_substrings[i]) == len(sorted_substrings[i+1]):\n            return \"-\"\n    return \"\".join(sorted_substrings)\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # return the result\n    return '-1'\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2 == 1:\n        return \"-1\"\n    s = stdin\n    for i in range(1, n, 2):\n        if s[i - 1]!= s[i]:\n            return \"-1\"\n    return s\n    \n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    l = stdin\n    length = len(l)\n    half_length = length // 2\n    if length % 2 == 0:\n        sub_strings = [l[i:i+half_length] for i in range(0, length, half_length)]\n        print(sub_strings)\n        if len(set(sub_strings)) == half_length+1:\n            return l\n        else:\n            return -1\n    else:\n        return -1\nprint(solution(\"tralalal\"))\nprint(solution(\"zzzz\"))\n"
    },
    {
        "number": 3232,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    if n%2!= 0:\n        return \"impossible\"\n    t = n // 2\n    s = sorted(s)\n    for i in range(0, n, 2):\n        if s[i:i+t] == []:\n            return \"impossible\"\n        if s[i+t:]!= s[i:i+t]:\n            return \"impossible\"\n    return \"\".join(s)\n\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # The total number of subarrays with distinct elements\n    total_numbers = stdin.split('\\n')[0]\n    total_numbers = list(map(int, total_numbers.split()))\n    numbers = stdin.split('\\n')[1]\n    numbers = list(map(int, numbers.split()))\n    numbers.sort()\n    total_numbers = total_numbers[1:]\n    # odd = []\n    # even = []\n    if len(total_numbers)%2==0:\n        start = (len(total_numbers)-1)//2\n        end = (len(total_numbers)+1)//2\n    else:\n        start = (len(total_numbers)+1)//2\n        end = (len(total_numbers)+2)//2\n    # for i in range(start,end):\n    #     if i % 2 == 0:\n    #         even.append(total_numbers[i])\n    #     else:\n    #         odd.append(total_numbers[i])\n    # if len(odd)%2 == 0:\n    #     middle_odd = int(len(odd)//2)\n    #     middle_even = int(len(even)//2)\n    # else:\n    #     middle_odd = int((len(odd)+1)//2)\n    #     middle_even = int((len(even)+1)//2)\n    total_numbers = total_numbers[start:end]\n    # print(odd)\n    # print(even)\n    # print(middle_odd)\n    # print(middle_even)\n    result = 0\n    for i in range(0,len(total_numbers)-1):\n        if total_numbers[i]==total_numbers[i+1]:\n            result+=1\n    print(result)\nsolution(stdin)"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input for array and size of array\n    line_one = stdin.readline()\n    arr_size = int(line_one)\n    arr = list(map(int, stdin.readline().strip().split()))\n    # sort array to make it easier to analyze\n    arr = sorted(arr)\n\n    # variables to track\n    lower = 0\n    upper = 0\n    count = 0\n\n    # run through array\n    for i in range(arr_size):\n        # if the index is at the beginning of the array\n        if i == 0:\n            lower = arr[i]\n            upper = arr[i]\n\n        # if it's not the first number in the array\n        # check if it is greater than the lower and less than the upper\n        # if it is, increment lower by 1\n        elif arr[i] < lower:\n            lower = arr[i]\n            upper = arr[i]\n        # if it's less than the lower and greater than the upper, it is scary\n        elif arr[i] > upper:\n            upper = arr[i]\n            count += 1\n    return count"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_median(array, left, right):\n        if right - left == 1:\n            return array[left]\n        else:\n            mid = (left + right) // 2\n            if mid % 2 == 0:\n                return (array[mid] + array[mid + 1]) // 2\n            else:\n                return array[mid]\n    n = int(stdin.readline().strip())\n    array = [int(x) for x in stdin.readline().strip().split(' ')]\n    median = find_median(array, 0, n)\n    scary = 0\n    for i in range(n):\n        if array[i] <= median:\n            scary += i\n    return scary\n"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return '1'"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return '\\n'.join(stdin)\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    def get_median(array):\n        n = len(array)\n        if n % 2 == 0:\n            return (array[n // 2] + array[(n // 2) - 1]) // 2\n        else:\n            return array[n // 2]\n\n    n = int(stdin.readline().strip())\n    array = list(map(int, stdin.readline().strip().split()))\n    array.sort()\n    scary_count = 0\n\n    for i in range(n):\n        j = i\n        median = get_median(array[i:])\n        while array[j] <= median:\n            scary_count += j - i + 1\n            j += 1\n\n    return scary_count\n"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split(' ')))\n    arr.sort()\n    l = 0\n    count = 0\n    for i in range(n):\n        if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n            r = i\n            count += r - l + 1\n            l = i\n    print(count)\n    return ''"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        median = median_of_medians(arr, n, i, i)\n        if i == 0:\n            if median == arr[i]:\n                count += 1\n        elif i == n - 1:\n            if median == arr[i]:\n                count += 1\n        else:\n            left = arr[i - 1] if i - 1 >= 0 else float(\"-inf\")\n            right = arr[i + 1] if i + 1 < n else float(\"inf\")\n            if median == left:\n                count += 1\n            if median == right:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    array = list(map(int, stdin.readline().strip().split()))\n    # sort array\n    array.sort()\n    median = array[int((n - 1) / 2)]\n    count = 0\n    if n % 2 == 0:\n        left = 0\n        right = n - 1\n        while right - left > 1:\n            if array[left] > median:\n                count += right - left\n                right -= 1\n            else:\n                left += 1\n        if array[left] > median:\n            count += n - left\n    else:\n        left = 0\n        right = n - 1\n        while right - left > 0:\n            if array[left] > median:\n                count += right - left\n                right -= 1\n            else:\n                left += 1\n    return str(count)\n"
    },
    {
        "number": 3233,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of scary subarrays in an array\n    :param stdin: The string of space-separated integers from stdin\n    :return: The number of scary subarrays\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = [int(x) for x in stdin.split()]\n    width = a[0]\n    height = a[1]\n    print(1 + math.ceil((width - height) / 2))\n"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin)\n\n\ndef"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(solve(stdin))\n\n\ndef"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str\"\"\"\n    return str(min(int(i) ** 2 for i in stdin.split('\\n')[0].split()))\nprint(solution(input()))\n"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin))\nprint(solution(input()))"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    square = 0\n    sq_counter = 0\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i % 2 == 0 and j % 2 == 0:\n                square = i*j\n                sq_counter += 1\n                if square > N:\n                    break\n    return sq_counter"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution of the puzzle\"\"\"\n    _, *n = stdin.split()\n    n = [int(n) for n in n]\n    if all(0 < w <= 2*h for w, h in zip(n, n[1:])):\n        return str(sum(w*h - w for w, h in zip(n, n[1:])))\n    return str(-1)\n"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    # Check if it is possible to split into 2x2\n    if N % 2:\n        # Check if it is possible to split into 2x1\n        if N % 3:\n            # Check if it is possible to split into 1x2\n            if N % 4:\n                # Return 1 because we can't split it into anything else\n                return 1\n            # Otherwise, we can split it into 2x1\n            else:\n                return 2\n        # Otherwise, we can split it into 2x2\n        else:\n            return 2\n    # Otherwise, it can split into 2x2\n    else:\n        return 0"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3234,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    def solve(w: int, h: int, a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int) -> int:\n        if w*h >= c*d + b*e + a*f + g*h:\n            return 0\n        if a <= w <= b and b <= h <= c and w*h - (c*d + b*e + a*f + g*h) <= (b - a)*(c - b):\n            return 1\n        if a <= w <= b and w*h - (c*d + b*e + a*f + g*h) <= (b - a) * (h - c):\n            return 1\n        if c <= h <= d and w*h - (c*d + b*e + a*f + g*h) <= (d - c) * (w - b):\n            return 1\n        if c <= h <= d and h*w - (c*d + b*e + a*f + g*h) <= (d - c) * (h - b):\n            return 1\n        return 2\n    \n    n = int(stdin.readline())\n    print(solve(0, 0, 0, 0, 0, 0, 0, 0, 0, 0))\n    \n    \n    \n    \n    \n    return '%s\\n' % (answer)\n\n\ndef"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split()\n    n, m = int(n), int(m)\n    edges = []\n    for _ in range(m):\n        a, b, c = stdin.split()\n        edges.append((int(a), int(b), int(c)))\n\n    print(edges)\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an optimal solution to the IOU problem.\n\n    Parameters\n    ----------\n    stdin\n        The input in string format.\n\n    Returns\n    -------\n    str\n        The solution in string format.\n    \"\"\"\n    lines = stdin.split('\\n')\n    friends_num, iou_num = [int(n) for n in lines[0].split()]\n\n    iou_list = []\n    for i in range(iou_num):\n        iou_list.append([int(n) for n in lines[i + 1].split()])\n\n    # determine the friends in the cycle\n    friends = [i for i in range(friends_num)]\n    # initialize the group of friends\n    friend_groups = {i: [i] for i in range(friends_num)}\n    # determine the friends in the cycle\n    for iou in iou_list:\n        # mark that the IOU is seen\n        friend_groups[iou[0]].append(iou[1])\n        # mark that the IOU is seen\n        friend_groups[iou[1]].append(iou[0])\n    # for each friend, remove self\n    for f in friend_groups:\n        friend_groups[f].remove(f)\n\n    # for each friend, sort the list by their corresponding debts\n    for f in friend_groups:\n        friend_groups[f].sort(key=lambda x: iou_list[x][2], reverse=True)\n\n    # if there is a cycle, then find the cycle\n    # and for each friend in the cycle, cancel the lowest amount\n    # of debt from the cycle\n    for i in range(len(friend_groups)):\n        for f in friend_groups:\n            for other_f in friend_groups:\n                if f!= other_f:\n                    # if there is a cycle, then break the loop\n                    if set(friend_groups[f]).issubset(set(friend_groups[other_f])):\n                        # calculate the difference in debts between the cycle and the rest of the group\n                        difference_in_debts = 0\n                        for i in friend_groups[f]:\n                            difference_in_debts += iou_list[i][2]\n                        for j in friend_groups[other_f]:\n                            difference_in_debts -= iou_list[j][2]\n                        # if there is a cycle\n                        if difference_in_debts > 0:\n                            # create a list of people in the cycle\n                            cycle = [f]\n                            for k in friend_groups[f]:\n                                cycle.append(k)\n                            # cancel the minimum amount of debt from the cycle\n                            iou_list[cycle[0]][2] -= difference_in_debts\n                            # remove the cycle from the groups\n                            for k in cycle:\n                                del friend_groups[k]\n                        # if there isn't a cycle, then break the loop\n                        else:\n                            break\n\n    # after checking the friend groups, check the IOUs\n    for i in range(len(iou_list)):\n        if iou_list[i][2] == 0:\n            return '\\n'.join([' '.join([str(n) for n in iou_list[i]])] + [''] * i)\n    # return the list of IOUs\n    return '\\n'.join([' '.join([str(n) for n in iou_list[i]]) for i in range(len(iou_list))])\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    friends = int(stdin.split()[0])\n    iou = int(stdin.split()[1])\n    result = []\n    if iou == 0:\n        return result\n    for _ in range(iou):\n        iou_info = stdin.split('\\n')[1].split()\n        if int(iou_info[0])!= int(iou_info[1]):\n            result.append(iou_info)\n    for iou in result:\n        iou[2] = str(int(iou[2]) - int(iou[0]) * int(iou[1]))\n    return result\n    \n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing the correct output from the standard input.\"\"\"\n    n, m = (int(x) for x in stdin.split())\n    p = 0\n    friends = [None] * n\n    for i in range(m):\n        a, b, c = (int(x) for x in stdin.split())\n        if not friends[a]:\n            friends[a] = []\n        if not friends[b]:\n            friends[b] = []\n        friends[a].append((b, c))\n        friends[b].append((a, c))\n    for friend in friends:\n        for (friend2, cost) in friend:\n            p = max(p, cost)\n    for i in range(n):\n        for (friend, cost) in friends[i]:\n            if cost <= p:\n                p = max(p, cost)\n    return str(p)\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution for the IOU problem\"\"\"\n    # read input\n    n, m = map(int, stdin.split('\\n')[0].split())\n    IOUs = [[int(i) for i in stdin.split('\\n')[i].split()] for i in range(1, m + 1)]\n    # initialize variable\n    remaining = []\n    # find the IOUs that are left after canceling all cycles\n    for i in range(n):\n        remaining.append([0] * n)\n    # find cycles\n    cycles = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if IOUs[i][j]!= 0:\n                cycles.append((i, j, IOUs[i][j]))\n    # if no cycles, return the sum of all IOUs\n    if not cycles:\n        return sum([sum(IOU) for IOU in IOUs])\n    # otherwise, settle the IOUs\n    for cycle in cycles:\n        # remove the IOUs that are canceled in this cycle from the remaining IOUs\n        for i in range(cycle[0], cycle[1]):\n            for j in range(i + 1, cycle[1]):\n                remaining[i][j] -= cycle[2]\n                remaining[j][i] -= cycle[2]\n        # find the minimum amount of money that should be given to each member\n        min_total = [0] * n\n        for i in range(n):\n            min_total[i] = min(remaining[i])\n        # if a member has a debt, give him/her the minimum amount of money\n        for i in range(n):\n            if min_total[i]!= 0:\n                for j in range(n):\n                    remaining[i][j] += min_total[i]\n                remaining[j][i] = 0\n    # sum the remaining IOUs\n    return sum([sum(IOU) for IOU in remaining])\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def iou(u, v, d):\n        assert u!= v\n        assert d > 0\n\n        if d == 0:\n            return 0, 0, 0\n\n        if d > u:\n            return u, v, d - u\n        elif d < v:\n            return u, v, v - d\n        else:\n            return u, v, 0\n\n    lines = stdin.split(\"\\n\")\n    n, m = lines[0].split()\n    n, m = int(n), int(m)\n    lines = lines[1:]\n\n    friends = [0] * n\n    for i in range(m):\n        u, v, d = lines[i].split()\n        u, v, d = int(u), int(v), int(d)\n        friends[u] = (friends[u] + d, v)\n        friends[v] = (friends[v][0] - d, u)\n\n    for u in range(n):\n        friends[u] = (friends[u][0], u)\n\n    total = 0\n    canceled = set()\n    for u in range(n):\n        if friends[u][0] == 0:\n            continue\n\n        v, v_ = u, u\n        while True:\n            v_ = friends[v_][1]\n            if v_ == u:\n                v_ = friends[v_][1]\n            else:\n                break\n            if v_ == v:\n                break\n\n        assert v_!= v\n        if v_ < u:\n            v, v_ = v_, v\n\n        d = friends[v_][0]\n        if u == v:\n            if d > 0:\n                canceled.add((u, d))\n                total += d\n        else:\n            u1, v1, d1 = iou(friends[u][0], friends[v][0], d)\n            if u1 < d1:\n                friends[u] = (u1, v1)\n                friends[v] = (d1, u)\n                canceled.add((u, d))\n                total += d - u\n            else:\n                canceled.add((u, d))\n                total += d\n\n    for u, d in canceled:\n        friends[u] = (friends[u][0] + d, u)\n\n    print(total)\n    for u, _ in sorted(friends):\n        print(\" \".join(map(str, iou(friends[u][0], friends[u][1], 0))))\n    return \"\""
    },
    {
        "number": 3235,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n    n, m = [int(i) for i in stdin.splitlines()[0].split()]\n    p = [int(i) for i in stdin.splitlines()[1:]]\n\n    friends = [None] * n\n    debts = [None] * n\n    for i in range(m):\n        a, b, c = [int(i) for i in stdin.splitlines()[i + 2].split()]\n        friends[a] = b\n        friends[b] = a\n        debts[a] = c\n        debts[b] = c\n\n    for _ in range(2):\n        for i in range(n):\n            if debts[i] > 0:\n                for j in range(n):\n                    if j!= i and friends[i] == j and debts[j] > 0:\n                        debts[i] -= min(debts[j], debts[i])\n                        debts[j] = 0\n                        break\n    for i in debts:\n        print(i)\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5 6\\n1 3 2 1 5\\n1 3\\n2 3\\n1 4\\n3 5\\n4 5\\n2 5\\n\")\n    5\n    \"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    h = [int(x) for x in stdin.splitlines()]\n    a = [int(x) for x in stdin.splitlines()]\n\n    houses = sorted([(i, h[i]) for i in range(n)], key=lambda x: x[1])\n    lengths = [[] for _ in range(n)]\n    for i in range(n - 1):\n        lengths[i].append(i + 2)\n    lengths[n - 1].append(1)\n    for j in range(n - 1, 0, -1):\n        for k in range(j):\n            if houses[j][0]!= houses[k][0] and houses[j][1]!= houses[k][1]:\n                if (houses[j][1] - houses[k][1]) / (houses[j][0] - houses[k][0]) in (1, 2, 3, 5, 6, 7, 8):\n                    lengths[k].append(j + 2)\n    # print(houses)\n    # print(lengths)\n    length = 0\n    for i in range(n):\n        path = []\n        if lengths[i]:\n            path.append(lengths[i][0])\n            l = lengths[i].pop(0)\n            while l:\n                path.append(l)\n                l = lengths[l - 1].pop(0)\n            if path:\n                length += len(path)\n    return str(length)\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Tr\u1ea3 v\u1ec1 t\u00ean c\u1ee7a c\u00e1c ba m\u00f4n h\u1ecdc sau khi t\u00ecm \u0111\u01b0\u1ee3c m\u00e3 gi\u1ea3i n\u00e0y\n\n    \u0110\u00e2y l\u00e0 m\u00e3 gi\u1ea3i nh\u01b0 sau:\n    if __name__ == \"__main__\":\n        inp = raw_input()\n    :param stdin: input c\u1ee7a the user\n    :return: t\u00ean c\u1ee7a c\u00e1c ba m\u00f4n\n    \"\"\"\n    fibo = [1, 1]\n    a, b = map(int, stdin.split())\n    height = [int(x) for x in stdin.split()]\n    heights = [1]\n    for i in range(1, len(height)):\n        heights.append(height[i] + heights[-1])\n    heights.append(1)\n    for _ in range(a, b):\n        fibo.append(heights[_] + fibo[-2])\n    return max(fibo[b:] + heights[b:])\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A good tour starts from any mansion and traverses to the nearest mansion in the list.\n    Next, we travel along the road to a neighbor mansion with the largest height.\n    Then, we travel on the road to the nearest neighbor with the largest height and repeat.\n    This process continues until the length of the tour is equal to the length of the Fibonacci sequence.\n    \"\"\"\n\n    pass"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Collect input\n    n, m = [int(n) for n in stdin.split()]\n    fibonacci = [0, 1]\n    heights = [int(n) for n in stdin.split()]\n    for i in range(2, m):\n        fibonacci.append(fibonacci[-1] + fibonacci[-2])\n    paths = []\n    for i in range(m):\n        a, b = [int(n) for n in stdin.split()]\n        paths.append((a, b))\n    # Sort the paths by ascending heights and sort the paths by descending heights if the same heights\n    paths.sort(key=lambda x: (x[1], -heights[x[1] - 1]))\n    # Build a hashmap of heights to count how many people can reach that height\n    height_counts = {}\n    for height in heights:\n        height_counts[height] = height_counts.get(height, 0) + 1\n    # Find a way to add paths and get rid of them\n    # Add the path if the height is a start or an end\n    # Remove the path if the height is an end\n    # Count how many people can reach the current height\n    # If there is no way to add paths, return the max\n    # Else, go to the next path\n    tour = [heights[0]]\n    for i in range(1, m):\n        # Add a path if the heights are the same, or if the heights are the start\n        # Remove a path if the heights are the same, or if the heights are the end\n        # Add a person to the tour\n        # Count how many people can reach the height\n        # If there is no way to add paths, return the max\n        # Else, go to the next path\n        height = heights[i]\n        if height == heights[i - 1]:\n            tour.append(height)\n        elif height == 1 or height == n:\n            tour.append(height)\n        else:\n            tour.append(height)\n            height_counts[height] -= 1\n            if height_counts[height] == 0:\n                del height_counts[height]\n            if height_counts.get(height - 1, 0) == 0:\n                del height_counts[height - 1]\n            if height_counts.get(height + 1, 0) == 0:\n                del height_counts[height + 1]\n            tour.append(height - 1)\n            height_counts[height - 1] -= 1\n            if height_counts[height - 1] == 0:\n                del height_counts[height - 1]\n            if height_counts.get(height + 1, 0) == 0:\n                del height_counts[height + 1]\n            tour.append(height + 1)\n            height_counts[height + 1] -= 1\n            if height_counts[height + 1] == 0:\n                del height_counts[height + 1]\n    # Add a path if the heights are the same, or if the heights are the start\n    # Remove a path if the heights are the same, or if the heights are the end\n    # Add a person to the tour\n    # Count how many people can reach the height\n    # If there is no way to add paths, return the max\n    # Else, go to the next path\n    height = heights[-1]\n    if height == heights[-2]:\n        tour.append(height)\n    elif height == 1 or height == n:\n        tour.append(height)\n    else:\n        tour.append(height)\n        height_counts[height] -= 1\n        if height_counts[height] == 0:\n            del height_counts[height]\n        if height_counts.get(height - 1, 0) == 0:\n            del height_counts[height - 1]\n        if height_counts.get(height + 1, 0) == 0:\n            del height_counts[height + 1]\n        tour.append(height - 1)\n        height_counts[height - 1] -= 1\n        if height_counts[height - 1] == 0:\n            del height_counts[height - 1]\n        if height_counts.get(height + 1, 0) == 0:\n            del height_counts[height + 1]\n        tour.append(height + 1)\n        height_counts[height + 1] -= 1\n        if height_counts[height + 1] == 0:\n            del height_counts[height + 1]\n    return max(tour)\n\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the length of the longest Fibonacci tour in the city of $n$ mansions and $m$ bi-directional roads.\n    \n    :param stdin: The input string\n    :return: The length of the longest Fibonacci tour in the city.\n    \"\"\"\n    with open(stdin) as file:\n        n, m = file.readline().split()\n        n, m = int(n), int(m)\n\n        houses = [int(x) for x in file.readline().split()]\n\n        roads = [[int(y) for y in x.split()] for x in file.readlines()]\n\n    # All possible starting points\n    starting_points = []\n    for i in range(n):\n        if (houses[i] < houses[i - 1] and houses[i] < houses[(i + 1) % n]) or (houses[i] > houses[i - 1] and houses[i] > houses[(i + 1) % n]):\n            starting_points.append(i)\n\n    # Store the longest length of the tour\n    max_tour_length = 0\n\n    for s in starting_points:\n        # Store the length of the tour\n        tour_length = 0\n        # Store the current house\n        current_house = s\n\n        while tour_length < m:\n            # Check if the road is possible\n            if (roads[current_house][0] < houses[current_house] and roads[current_house][1] < houses[current_house]) or (roads[current_house][0] > houses[current_house] and roads[current_house][1] > houses[current_house]):\n                # If it is possible, add the length and add the current house to the tour\n                tour_length += roads[current_house][0]\n                tour_length += roads[current_house][1]\n                current_house = (current_house + 1) % n\n            # If the road is not possible, add the length of the current house and the next house\n            else:\n                tour_length += houses[current_house]\n                tour_length += houses[(current_house + 1) % n]\n                current_house = (current_house + 1) % n\n\n        # If the tour length is longer than the maximum, update the maximum\n        if tour_length > max_tour_length:\n            max_tour_length = tour_length\n\n    return str(max_tour_length)\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Trick:\n    \n    Since a Fibonacci tour can be made from any one of the mansions by traversing\n    a path of consecutive numbers in the Fibonacci sequence, a Fibonacci tour\n    must start from a lower number than the maximum height of the city.\n    \n    Thus, a way to get the longest tour is to check each possible path starting\n    from the smallest possible starting point.\n    \"\"\"\n    n, m = map(int, stdin.split())\n    heights = [int(num) for num in stdin.split('\\n')[1:n+1]]\n    roads = [[int(x) for x in line.split()] for line in stdin.split('\\n')[m+1:]]\n    \n    lowest = min(heights)\n    tours = set()\n    \n    def dfs(path):\n        nonlocal tours\n        if len(path) > n:\n            return\n        if len(path) == n:\n            tours.add(tuple(path))\n            return\n        \n        for i in range(len(roads)):\n            dest, dist = roads[i]\n            if path[-1] <= dest <= n and dist > 0:\n                roads[i][1] -= 1\n                dfs(path + [dest])\n                roads[i][1] += 1\n        \n    dfs([lowest])\n    \n    return max(len(tour) for tour in tours)\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_of_mansions, num_of_roads, *args = stdin.split(\"\\n\")\n    num_of_mansions, num_of_roads = int(num_of_mansions), int(num_of_roads)\n    heights = list(map(int, args))\n    edges = []\n    for _ in range(num_of_roads):\n        src, dst = list(map(int, stdin.readline().split()))\n        edges.append((src, dst))\n        edges.append((dst, src))\n    start_node = 0\n    dist = [float('inf')] * (num_of_mansions + 1)\n    dist[start_node] = 0\n    for _ in range(num_of_mansions - 1):\n        nxt = []\n        for edge in edges:\n            src, dst = edge\n            nxt.append((dist[src] + heights[dst - 1], dst))\n        _, dst = min(nxt)\n        dist[dst] = heights[dst - 1]\n    return max(dist[1:])\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the longest Fibonacci tour.\"\"\"\n    m, n = stdin.split()\n    m, n = int(m), int(n)\n    nums = list(map(int, stdin.split()))\n    # map each num to its index in the array\n    nums_dict = {num: i for i, num in enumerate(nums)}\n    # create an adjacency matrix\n    adj_mat = [[0] * n for _ in range(n)]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a, b = stdin.split()\n            a, b = int(a), int(b)\n            if a in nums_dict and b in nums_dict:\n                adj_mat[nums_dict[a]][nums_dict[b]] = 1\n                adj_mat[nums_dict[b]][nums_dict[a]] = 1\n    \n    # find the maximum spanning tree\n    E = sorted(range(n), key=lambda v: -sum(adj_mat[v]))\n    visited = [False] * n\n    T = []\n    while E:\n        u = E.pop()\n        visited[u] = True\n        T.append(u)\n        for v in range(n):\n            if u!= v and not visited[v] and adj_mat[u][v]:\n                E.append(v)\n    \n    # find the longest tour\n    tours = []\n    for u in range(len(T)):\n        for v in range(u + 1, len(T)):\n            tours.append([T[u], T[v]])\n    # print(tours)\n    longest_tour = 0\n    for tour in tours:\n        n = len(tour)\n        F = [[0] * n for _ in range(n)]\n        F[0][0] = tour[0]\n        F[0][1] = tour[1]\n        F[1][0] = tour[1]\n        F[1][1] = tour[0]\n        for i in range(2, n):\n            F[0][i] = F[0][i - 1] + tour[i]\n            F[1][i] = F[1][i - 1] + tour[i]\n        longest_tour = max(longest_tour, F[0][n - 1] + F[1][n - 1])\n    return str(longest_tour)\n"
    },
    {
        "number": 3236,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    fibs = [1, 1]\n    for i in range(2, n + m + 1):\n        fibs.append(fibs[i - 1] + fibs[i - 2])\n    a = list(map(int, stdin.split('\\n')[1].split(' ')))\n    a.insert(0, 0)\n    b = list(map(int, stdin.split('\\n')[2].split(' ')))\n    b.insert(0, 0)\n    c = list(map(int, stdin.split('\\n')[3].split(' ')))\n    c.insert(0, 0)\n    road = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(m):\n        road[a[i + 1]][b[i + 1]] = 1\n        road[b[i + 1]][a[i + 1]] = 1\n    # print(road)\n    route = [n] * (n + 1)\n    route[0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if road[i][j]:\n                for k in range(1, n + 1):\n                    if road[j][k]:\n                        if route[k] > route[i] + 1:\n                            route[k] = route[i] + 1\n                            route[i] = route[j] + 1\n                            route[j] = route[k] + 1\n    # print(route)\n    if route[n] > m:\n        return str(route[n])\n    else:\n        return '0'\n\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    l = math.sqrt(num)\n    l = math.floor(l)\n    if l ** 2 == num:\n        return 2 * l + 2 * l ** 2\n    return 2 * l + 2 * l ** 2 + 1\n"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    prime_factors = [int(x) for x in stdin]\n    prime_factors = [x for x in prime_factors if x not in [0, 1]]\n    base_cost = 1\n    for prime in prime_factors:\n        base_cost *= prime\n    for i in range(2, len(prime_factors)):\n        temp = 1\n        for j in range(i, len(prime_factors), i):\n            temp *= prime_factors[j]\n        base_cost += temp\n    return base_cost\n\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the minimum cost to store Mr. Panda's data.\n\n    Arguments:\n        stdin {str} -- A string of even length representing the prime\n        factorization of K.\n\n    Returns:\n        str -- An integer with the minimum cost to store Mr. Panda's data.\n    \"\"\"\n    # Get the number of divisors of K.\n    divisors = get_divisors(int(stdin))\n\n    # Calculate the minimum cost\n    cost = len(stdin) * int(stdin[0])\n    for divisor in divisors:\n        if int(stdin[0]) == divisor:\n            cost += int(stdin[1])\n        else:\n            cost += int(stdin[0]) + int(stdin[1])\n\n    # Return the minimum cost modulo 10^9 + 7\n    return str(cost % (10 ** 9 + 7))\n\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    numbers = [int(i) for i in stdin.split(\"0\") if len(i) > 0]\n    for i in range(0, len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            result = result + get_cost(numbers[i], numbers[j])\n    return str(result % (10 ** 9 + 7))\n\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    prime_factors = stdin\n    primes = set()\n    max_primes = set()\n    prime_factors = list(map(int, prime_factors))\n    ans = 0\n    i = 0\n    while i < len(prime_factors):\n        if len(max_primes) > 0:\n            ans += max(max_primes)\n            max_primes = set()\n        for j in range(i, len(prime_factors)):\n            primes.add(prime_factors[i] * prime_factors[j])\n        i += 1\n        max_primes.add(max(primes))\n        primes.clear()\n    return ans % 1000000007\n"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    prime_factors = sorted(set(stdin))\n\n    if len(prime_factors) > 1:\n        n = prime_factors[0] * prime_factors[1]\n        return n\n\n    s = sum(prime_factors)\n    return s\n\n\nprint(solution('1311'))\n"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    #first, change the string into a list\n    #then, append each element of the list to the total list\n    #lastly, get the last element of the list, which will contain the total cost\n    listOfPrimes = [int(i) for i in stdin]\n    totalList = []\n    for i in range(0, len(listOfPrimes), 2):\n        totalList.append(listOfPrimes[i] * listOfPrimes[i+1])\n    #print(totalList)\n    return totalList[len(totalList)-1]\n"
    },
    {
        "number": 3237,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Problem: https://www.hackerrank.com/challenges/purchase-shopping/problem\n\n    Sample Input:\n        2\n        020302\n        1311\n\n    Sample Output:\n        7\n        24\n    '''\n\n    # Calculate the minimum cost using dynamic programming\n    # Time Complexity: O(N^2)\n    # Space Complexity: O(N^2)\n    # N is the length of the input string\n    # Time Limit: 2 seconds\n    def min_cost(x: int, primes: List[int], prices: List[int]) -> int:\n        n = len(primes)\n\n        # Calculate the minimum cost for the first N/2 elements\n        min_costs = [0] * (n // 2 + 1)\n\n        # Loop over all pairs of consecutive prime factors\n        for i in range(n // 2):\n            for j in range(i + 1, n // 2):\n                # Find the minimum cost of the pair\n                min_cost = min(min_costs[i], min_costs[j])\n                for m in range(2, x // primes[i] + 1):\n                    # Find the minimum cost of the pair\n                    for k in range(j + 1, n // 2):\n                        # The minimum cost of the pair is the minimum of the minimum cost of the pair and the sum of the minimum cost of the previous pair and the cost of the current prime multiplied by the number of times the current prime occurs\n                        min_cost = min(min_cost, min_costs[i] + min_costs[j] + (prices[k] * m))\n\n                # Set the minimum cost for the pair to the minimum cost of the pair\n                min_costs[j] = min_cost\n\n        return min_costs[-1]\n\n    # Split the input string of numbers into a list of integers\n    primes = list(map(int, stdin.split()))\n\n    # Get the size of the data that Mr. Panda wants to store\n    k = primes[0]\n\n    # Get the prices of the storage servers of the same size\n    prices = primes[1:]\n\n    # Calculate the minimum cost\n    return min_cost(k, primes, prices)\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    first_line = stdin.split(\"\\n\")[0].split(\" \")\n    rows = int(first_line[0])\n    columns = int(first_line[1])\n    matrix = []\n    for i in range(rows):\n        matrix.append(list(stdin.split(\"\\n\")[i + 1]))\n    matrix_t = []\n    matrix_t = transpose(matrix)\n    matrix_rev = []\n    matrix_rev = reverse(matrix)\n    for i in range(len(matrix_t)):\n        matrix_t[i].reverse()\n    for i in range(len(matrix_rev)):\n        matrix_rev[i].reverse()\n\n    #left_max = []\n    #right_max = []\n    #up_max = []\n    #down_max = []\n    left = 0\n    right = 0\n    up = 0\n    down = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == '#':\n                #print(i, j, matrix[i][j])\n                #left_max.append(j)\n                left = max(left, j)\n                #right_max.append(j)\n                right = max(right, j)\n                #up_max.append(i)\n                up = max(up, i)\n                #down_max.append(i)\n                down = max(down, i)\n\n    for i in range(len(matrix_t)):\n        for j in range(len(matrix_t[i])):\n            if matrix_t[i][j] == '#':\n                #left_max.append(j)\n                left = max(left, j)\n                #right_max.append(j)\n                right = max(right, j)\n                #up_max.append(i)\n                up = max(up, i)\n                #down_max.append(i)\n                down = max(down, i)\n\n    for i in range(len(matrix_rev)):\n        for j in range(len(matrix_rev[i])):\n            if matrix_rev[i][j] == '#':\n                #left_max.append(j)\n                left = max(left, j)\n                #right_max.append(j)\n                right = max(right, j)\n                #up_max.append(i)\n                up = max(up, i)\n                #down_max.append(i)\n                down = max(down, i)\n\n    #print(left_max, right_max, up_max, down_max)\n    #print(left, right, up, down)\n    matrix_max = []\n    matrix_max = [left, right, up, down]\n    matrix_max.sort()\n    print(matrix_max[0], matrix_max[1], matrix_max[2], matrix_max[3])\n\ndef"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n\n    return \"\"\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = stdin.split('\\n')[:2]\n    n = int(n)\n    m = int(m)\n    for index, line in enumerate(stdin.split('\\n')[2:]):\n        if len(line)!= m:\n            raise ValueError\n    stdin = stdin.split('\\n')\n    # find the start position\n    for row_index in range(n):\n        for column_index in range(m):\n            if stdin[row_index][column_index] == '#':\n                start_row = row_index\n                start_column = column_index\n                break\n    # find the fold direction\n    fold_direction = 'none'\n    for row_index in range(start_row, n):\n        for column_index in range(start_column, m):\n            if stdin[row_index][column_index] == '#':\n                if fold_direction == 'none':\n                    fold_direction = 'horizontal'\n                    fold_row_start = row_index\n                    fold_row_end = row_index\n                elif fold_direction == 'horizontal':\n                    fold_row_start = row_index\n                    fold_row_end = row_index\n                else:\n                    fold_direction ='vertical'\n                    fold_column_start = column_index\n                    fold_column_end = column_index\n                break\n    # fold_direction\n    if fold_direction == 'none':\n        return '0 0 0 0'\n    elif fold_direction == 'horizontal':\n        return str(fold_row_start) +'' + str(fold_column_start) +'' + str(fold_row_end) +'' + str(fold_column_end)\n    elif fold_direction =='vertical':\n        return str(fold_row_start) +'' + str(fold_column_start) +'' + str(fold_row_end) +'' + str(fold_column_end)\n    else:\n        raise ValueError\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str()\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    matrix = stdin.split('\\n')[1:]\n    matrix = [list(r) for r in matrix]\n    left = 0\n    right = m-1\n    top = 0\n    bottom = n-1\n    while left <= right and top <= bottom:\n        for i in range(left, right+1):\n            matrix[top][i] = '*'\n        for i in range(top+1, bottom+1):\n            matrix[i][right] = '*'\n        for i in range(right, left-1, -1):\n            matrix[bottom][i] = '*'\n        for i in range(bottom-1, top, -1):\n            matrix[i][left] = '*'\n        left += 1\n        right -= 1\n        top += 1\n        bottom -= 1\n    for i in range(n):\n        print(matrix[i])\n    return''.join(map(str, (top, left, bottom, right)))\n"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    grid = [list(stdin) for _ in range(n)]\n    def get_angle(r1, c1, r2, c2):\n        # return clockwise angle from (r1, c1) to (r2, c2)\n        dy, dx = r2 - r1, c2 - c1\n        if dx < 0:\n            if dy < 0:\n                return -90\n            else:\n                return 90\n        else:\n            if dy < 0:\n                return 180\n            else:\n                return 0\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                grid[y][x] = 0\n            else:\n                grid[y][x] = 1\n    ans = []\n    # check diagonal\n    for r1 in range(1, n):\n        for c1 in range(1, m):\n            for r2 in range(r1+1, n+1):\n                for c2 in range(c1+1, m+1):\n                    angle = get_angle(r1, c1, r2, c2)\n                    if angle == 90 or angle == 0:\n                        ans.append((r1, c1, r2, c2))\n    # check vertical\n    for r1 in range(1, n+1):\n        for c1 in range(1, m):\n            for r2 in range(r1, n+1):\n                for c2 in range(c1, m):\n                    if get_angle(r1, c1, r2, c2) == 0:\n                        ans.append((r1, c1, r2, c2))\n    # check horizontal\n    for r1 in range(1, n):\n        for c1 in range(1, m+1):\n            for r2 in range(r1, n):\n                for c2 in range(c1, m+1):\n                    if get_angle(r1, c1, r2, c2) == 0:\n                        ans.append((r1, c1, r2, c2))\n\n    ans.sort()\n    ans = [(x[0] - 1, x[1] - 1, x[2] - 1, x[3] - 1) for x in ans]\n    return '\\n'.join(map(lambda x:''.join(map(str, x)), ans))"
    },
    {
        "number": 3238,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''8 10\n   ... #.#..##..#\n   ... #....#####\n   ... ###.#....\n   .....###..##.\n   ... ##....##.\n   ... #.#.#....\n   ... #....#..#\n   ... ##.#..###\n   ... ##....##\n   ... ###..###.\n   ....####.#.#\n   ... ##.######\n   ... #.#.#####.\n   ... ##..####.\n   ... ##..##.#.\n   ... #.####...\n   ... #..#.##..\n   ... ##...#..#\n   ... #.########\n   ....######.#.\n   ... #.#######.\n   ... ##.##.###.\n   ... #.####...\n   ... ##..##..#\n   ... #.######.\n   ... ###..####\n   ....##.####.\n   ... ##.#..##.\n   ... #.####...\n   ... ##.#####.\n   ....#######.\n   ... ##...###.\n   ... #.########\n   ... #.#######.\n   ....#######.\n   ... ##..###..\n   ... ##..##..#\n   ... ##.#######\n   ... #.##.####.\n   ... ##...##.#\n   ... #.####...\n   ... ##.##.###.\n   ... ##...#..#\n   ... #.##...##\n   ... ##.##.###.\n   ... #...#....\n   ... ##..###.#\n   ... ##..#.###\n   ....##...##.\n   ... ##..#.#.#\n   ... #.####...\n   ... ##.#..###\n   ... ##...##.\n   ... #.###.###.\n   ....####.###.\n   ... ##..###.#\n   ... ##..#.###\n   ....######.#\n   ... ##.##.###\n   ... #.####.#.\n   ... ##.#..###\n   ... #.###....\n   ... ##..##.#.\n   ... ##.#.###.\n   ... ##...#..#\n   ... #.###..##\n   ... ##..#..##\n   ... ##...##.#\n   ... #.######.\n   ... ##..#####\n   ... ##...####\n   ... ##..#.###\n   ... #.####.##\n   ... ##..###.#\n   ... ##.#####.\n   ... ##...####\n   ... ##..####.\n   ... #.##.####.\n   ... ##..##.##\n   ... #.####.###\n   ... #..#..###.\n   ... ##..##.#.\n   ... ##.#####..\n   ... #.#.#..##\n   ... #..####.#.\n   ... ##..#.###.\n   ... ##.#..###\n   ... ##..#.#..\n   ... ##.#.###..\n   ... #.#.#....\n   ... #..#.#....\n   ... ##...#...\n   ... #.#.#....\n   ... #..#.#....\n   ... #...#.#.#.\n   ... ##.#...#.\n   ... #.#.#....\n   ... #...#.#.#.\n   ... #.#.#....\n   ... ##..#.#..\n   ... #.#.#....\n   ... #..#.#....\n   ... ##..#....\n   ... #.#.#....\n   ... ##.#....#\n   ... #..#....#.\n   ... ##.#....#.\n   ... #..#....#.\n   ... ##.#....#.\n   ... ##...#...\n   ... #..###...\n   ... ##.#....#.\n   ... ##...#...\n   ... #.####...\n   ... ##.#....#\n   ... ##.#....#\n   ... ##...#...\n   ... #.#.###..\n   ... #..#.#..#\n   ... #...#.###.\n   ... #.#.###..\n   ... ##..#.##.\n   ... ##..##..#\n   ... #.######.\n   ... ##.#####.\n   ... ##...####\n   ... ##..####.\n   ... ##..##..#\n   ... #.######.\n   ... ##.#.#.##\n   ... #.#####.#\n   ... #.#.####.\n   ... ##...###.\n   ... ##.#####.\n   ... ##..####.\n   ... #.####.#.\n   ... ##.#..###\n   ... ##...##.\n   ... #.#.####.\n   ... ##..##.#.\n   ... #.####...\n   ... ##.#..###\n   ... ##..##.#.\n   ... #.#####.#\n   ... ##...###.\n   ... #.#.#.#.#\n   ... #..#.#..#\n   ... ##.#..##.\n   ... #.####.#.\n   ... ##....##\n   ... #.#.#....\n   ... #..#.#....\n   ... ##...#...\n   ... #.#.#....\n   ... #..#.#....\n   ... ##...#...\n   ... #.#.#....\n   ... #..#.#....\n   ... ##...#...\n   ... #.#.#....\n   ... #..#.#....\n   ... ##...#...\n   ... ##...###.\n   ... ##..#...#\n   ... #.#.#....\n   ... #..#.#....\n   ... ##..#....\n   ... #.#.#....\n   ... #..#.#....\n   ... ##..#....\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(float, stdin.split())\n    return str(round(n * p * n * p * n, 6))\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, P = stdin.split(\" \")\n    N = int(N)\n    P = float(P)\n    return '{:.6f}'.format(N * (1 - P))"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    N, p = map(float, stdin.split())\n    return f\"{N * (1 - p):.6f}\""
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, P = stdin.split()\n    N, P = int(N), float(P)\n    return \"{:.6f}\".format(N * P)\n\n\ndef"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    n = int(n)\n    p = float(p)\n    cost = 0\n    while n:\n        cost += n\n        n = n//2 if n % 2 == 0 else n//2 + 1\n    cost += n * 5\n    return str(cost * p)\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, P = stdin.split()\n    P = float(P)\n    return str(round((100 * (1 - P) + 100) / P - 100))\n\nprint(solution(\"50 0.125\"))\nprint(solution(\"201 1.000\"))\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s, p = stdin.split(' ')\n    N = int(s)\n    p = float(p)\n    return str(pow(p, N))\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return\n"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, P = [float(x) for x in stdin.split()]\n    return \"{:.6f}\".format(N * P / 100.0)"
    },
    {
        "number": 3239,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, p = stdin.split()\n    return str(round(float(n) / (1 - float(p)) / 100, 6))\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.readline().strip().split())\n    votes = []\n    for i in range(v - 1):\n        votes.append(list(map(float, stdin.readline().strip().split())))\n    # print(votes)\n    result = 0\n    for i in range(2 ** k):\n        total = 0\n        for j in range(v - 1):\n            total += votes[j][0] * (2 ** (k - 1) - i) + votes[j][1] * i\n        # print(total, result)\n        if total > result:\n            result = total\n    print(result)\n    return \"\"\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k, v = [int(x) for x in stdin.split()]\n    votes = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    votes.sort(key=lambda x: x[1], reverse=True)\n    # Get the first k bits as the result\n    res = 0\n    for i in range(k):\n        res += votes[i][0] * (2 ** i)\n    res = ''.join(['1' if (x & (2 ** i)) else '0' for i, x in enumerate(bin(res)[2:])])\n    return res\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    lines = stdin.splitlines()\n    k, v = map(int, lines[0].split())\n    votes = {i: [int(j) for j in lines[i + 1].split()] for i in range(v)}\n    \n    total = 2 ** k\n    winners = []\n    for i in range(total):\n        a = 0\n        for j in range(v):\n            if votes[j][i % (2 ** k)] == 1:\n                a += 1\n        if a % 2 == 0:\n            winners.append(i)\n\n    print(len(winners))\n    return \"\"\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the number of ballots you should cast to maximize Yraglac's expected number of positions.\n\n    Time Complexity: O(k * (v - 1) * log v)\n    Space Complexity: O(k)\n    \"\"\"\n    _, v, k = map(int, stdin.split())\n    b = [[int(i) for i in stdin.split()] for _ in range(v - 1)]\n    b.append(list(range(2 ** k)))\n    s = sum(b[v - 1])\n    b = [b[i][:-1] for i in range(v)]\n    d = s // k\n    vb = [0] * (2 ** k)\n    for i in range(v):\n        for j in b[i]:\n            vb[j] += d\n    m = max(vb)\n    res = vb.index(m)\n    if m == 0:\n        return \"0\"\n    return str(bin(res)[2:].zfill(k))\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    total_num_of_ballots = stdin.split('\\n')[0]\n    total_num_of_ballots = total_num_of_ballots.split()\n    total_num_of_ballots = int(total_num_of_ballots[0])\n    number_of_voters = int(stdin.split('\\n')[1])\n    probabilities = []\n    for i in range(number_of_voters):\n        probabilities.append(stdin.split('\\n')[i + 2].split()[0])\n        number_of_ballots = int(stdin.split('\\n')[i + 2].split()[1])\n        probabilities.append(number_of_ballots)\n\n    # print(total_num_of_ballots, number_of_voters, probabilities)\n    ans = 0\n    return ans\n\nprint(solution(stdin))"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # my approach is to use a DP table for every possible state of the voting and then return the\n    # max count of votes that Yraglac has cast if she\n    k, v = map(int, stdin.split())\n    votes = [0 for _ in range(v)]\n    #dp is a matrix of size (2**k, v) where we are storing the max number of votes that we can have\n    #of Yraglac if we take a certain number of votes\n    #dp[i][j] = max number of votes Yraglac can have if we take x amount of votes and she wins j+1\n    #position\n    dp = [[0 for _ in range(v)] for _ in range(2**k)]\n    for i in range(v - 1):\n        votes[i] = int(input())\n        votes[i + 1] = int(input())\n    for i in range(2**k):\n        #we want to convert a binary number to decimal and then use that number to check if we\n        #should vote or not\n        binary_i = format(i, '0' + str(k) + 'b')\n        dec = int(binary_i, 2)\n        for j in range(v):\n            #tally the number of votes we have for j + 1\n            #also tally if Yraglac will win j+1\n            dp[i][j] = dp[i][j] + (votes[j] if dec % 2 == 0 else 0) + (1 if j == v - 1 else dp[i][j + 1])\n    return dp[2 ** k - 1][v - 1]\n\ndef"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, v, *lines = map(int, stdin.split())\n    p = list(map(float, lines))\n    p.insert(0, 0)\n    b = [0] * (2 ** k)\n    for i in range(1, v):\n        for j in range(2 ** k):\n            b[j] += int(p[i] * b[j - 1] / (p[i] * 2 ** k + b[j - 1]))\n    return sum(j for j in b if j & (2 ** k - 1) == 0)\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(sum(bin(int(input().split()[1])).count('1') for _ in range(int(input().split()[0]))))\n"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Gets the maximum number of ballots to cast given the election results.'''\n    k, v = list(map(int, stdin.split()))\n    p, b = [], []\n    for _ in range(v - 1):\n        p_i, b_i = list(map(float, stdin.split()))\n        p.append(p_i)\n        b.append(b_i)\n    # We're looking for the number of possible voter-cast ballots whose binary sum is at most (2^k - 1)\n    b = [bin(b_i) for b_i in b]\n    binary_sum = sum([2 ** (k - 1) for b_i in b])\n    result = 0\n    for i in range(2 ** k):\n        # At the ith possible voter-cast ballot, ith binary sum is b[0] + b[1] +... + b[i].\n        # If the ith binary sum is <= (2^k - 1), then we want to cast a ballot for Yraglac.\n        if bin(i).count('1') <= binary_sum:\n            result += 1\n    return result"
    },
    {
        "number": 3240,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # My Solution: O(n^2) time | O(n) space\n    # k = int(stdin[0].split()[0])\n    # v = int(stdin[0].split()[1])\n    # voters = [stdin[1 + i].split() for i in range(v - 1)]\n    # prob = [float(voter[0]) for voter in voters]\n    # votes = [int(voter[1]) for voter in voters]\n    # max_position = 0\n    # for i in range(2 ** k - 1):\n    #     # '{0:0b}'.format(i)\n    #     current_sum = 0\n    #     for j in range(v - 1):\n    #         current_sum += votes[j] * prob[j] if int(\n    #             '{0:0b}'.format(i)[votes[j]]) == 1 else 0\n    #     if current_sum > max_position:\n    #         max_position = current_sum\n    # return str(max_position)\n\n    # Other Solution: O(n^2) time | O(n) space\n    k = int(stdin[0].split()[0])\n    v = int(stdin[0].split()[1])\n    voters = [stdin[1 + i].split() for i in range(v - 1)]\n    prob = [float(voter[0]) for voter in voters]\n    votes = [int(voter[1]) for voter in voters]\n    max_position = 0\n    b = [0] * (2 ** k - 1)\n    for i in range(2 ** k - 1):\n        current_sum = 0\n        for j in range(v - 1):\n            current_sum += votes[j] * prob[j] if int(\n                '{0:0b}'.format(i)[votes[j]]) == 1 else 0\n        if current_sum > max_position:\n            max_position = current_sum\n            b[i] = 1\n    for i in range(2 ** k - 1):\n        if b[i] == 1:\n            b[i] = 0\n            max_position += 0\n        else:\n            b[i] = 1\n            max_position -= 0\n    return str(max_position)\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    stdin = stdin.splitlines()\n    num_competitors = int(stdin[0])\n    pigs_per_competitor = list(map(int, stdin[1:]))\n\n    # sort the list\n    pigs_per_competitor.sort()\n\n    # check if the competitors ate the same amount of meat\n    if pigs_per_competitor.count(pigs_per_competitor[0]) == num_competitors:\n        return str(-1)\n\n    # calculate the portion of each member to share with other members\n    portion_to_share = [pig_per_competitor / num_competitors for pig_per_competitor in pigs_per_competitor]\n\n    # calculate the total amount of meat each member is going to eat\n    portion_to_eat = [sum(portion_to_share[:idx+1]) for idx, pig_per_competitor in enumerate(pigs_per_competitor)]\n\n    # sum the total amount of meat each member is going to eat\n    total_portion_to_eat = sum(portion_to_eat)\n\n    # find the portion of leftover food\n    leftover_portion = total_portion_to_eat - portion_to_eat[num_competitors-1]\n\n    # calculate the portion to be shared\n    portion_to_share[num_competitors-1] = leftover_portion\n\n    # sum the total amount of food each member is going to share\n    portion_to_share_total = sum(portion_to_share)\n\n    # calculate the total amount of food each member is going to eat\n    portion_to_eat_total = [sum(portion_to_share[:idx+1]) for idx, pig_per_competitor in enumerate(pigs_per_competitor)]\n\n    # return the sum of total portion to share and the leftover food\n    return str(portion_to_share_total + leftover_portion)\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a, b = [], []\n    for _ in range(n):\n        a.append(int(stdin.split('\\n')[_].split(' ')[0]))\n        b.append(int(stdin.split('\\n')[_].split(' ')[1]))\n    total = sum(a)\n    if min(b) == 0 or min(a) == 0:\n        return '-1'\n    if max(a) >= sum(b):\n        return str(sum(b))\n    if n > 2:\n        for i in range(2, n):\n            if a[i] / (b[0] + b[i])!= a[i-1] / (b[i-1] + b[i]):\n                return str(a[i] + b[0] * (sum(b) - b[i]))\n    return str(sum(b) + a[0] / (b[0] + b[1]))\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solve exercise.\n    :param stdin: input data\n    :return: solution string\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    answer = 0\n\n    participants = []\n\n    for _ in range(n):\n        participants.append([int(x) for x in stdin.split(\"\\n\")[_].split(\" \")])\n    participants = participants[1:]\n\n    participants.sort(key=lambda x: x[0])\n    participants = participants[::-1]\n    answer = participants[0][0]\n    total = participants[0][1]\n\n    if total == 0:\n        return str(-1)\n\n    for i in range(1, len(participants)):\n        participants[i][1] += total\n        total += participants[i][1]\n        if participants[i][1]!= 0:\n            answer = participants[i][0]\n            break\n\n    return str(answer)\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   'bajs wants to be a man of the year, so he gets to decide the ratio of ham he will be giving out'\n   '= the number of people to be served first,  and the rest to be served in order of their score'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person, second person,...'\n   '= first person,"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your solution\n    \"\"\"\n    pass"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    A = list(map(int, stdin.readline().split()))\n    B = list(map(int, stdin.readline().split()))\n    assert N == len(A) == len(B)\n    total = sum(A)\n    for k in range(1, N):\n        if B[k]!= 0:\n            if total % B[k] == 0:\n                total = total // B[k]\n            else:\n                return -1\n    return total\n"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    A = list(map(int, stdin.readline().split()))\n    B = list(map(int, stdin.readline().split()))\n    return str(solve(N, A, B))\n\n\ndef"
    },
    {
        "number": 3241,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = list(map(int, stdin.split('\\n')[1:]))\n    return f'-1' if len(a) < n and n > 0 else f'{sum(a) // n}'\n"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    boxes = int(stdin.readline())\n    min_p = float(stdin.readline())\n    p_list = []\n    for i in range(boxes):\n        p_list.append([int(x) for x in stdin.readline().split()])\n\n    return p_list"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"returns the minimum energy needed to find the parrot\"\"\"\n    assert isinstance(stdin, str)\n    n, p = map(float, stdin.split(' '))\n    boxes = map(int, stdin.split('\\n')[:-1])\n    energy = 0\n    for box in boxes:\n        if random.random() < p:\n            energy += box\n    return energy"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    N, P = [int(n) for n in stdin.split('\\n')[0].split()]\n    E = []\n    for i in stdin.split('\\n')[1:]:\n        E.append([int(n) for n in i.split()])\n\n    E.sort(key=lambda x: x[0])\n    x, y = 0, 0\n    while P > 0:\n        while x < N and E[x][0] == E[y][0]:\n            P -= E[x][1]\n            x += 1\n        y = x\n        x += 1\n    return E[y][0]\n"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(float, stdin.split())\n    energy_wasted = 0\n    while p < 1:\n        p *= 10\n        energy_wasted += 1\n    return str(int(n * p + energy_wasted))\n"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the minimum amount of energy Johan has to waste while finding\n    Polly with at least probability P.\n    '''\n   ..."
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    box, proba = stdin.split()\n    box = int(box)\n    proba = float(proba)\n    energy_lst = []\n    for i in range(box):\n        energy, proba = stdin.split()\n        energy = int(energy)\n        proba = float(proba)\n        energy_lst.append(energy)\n    energy_lst.sort()\n    for i in range(box):\n        if energy_lst[i] < proba:\n            energy_lst[i] = proba\n        else:\n            break\n    return energy_lst[i - 1]\n"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, P = [int(x) for x in stdin.split()]\n    p_arr = [float(x) for x in stdin.split(\"\\n\")[:-1]]\n    return str(min(pow(2, N) - sum(pow(2, i) for i, p in enumerate(p_arr) if p < P), 2 ** N))"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split(' '))\n    prob = [float(p) for p in stdin.split('\\n')]\n    # create dictionary to store all the values\n    probDict = {k: v for k, v in enumerate(prob)}\n    energy = 0\n    minE = N\n    # find lowest amount of energy\n    for key, value in probDict.items():\n        if P >= value:\n            if key < minE:\n                minE = key\n                energy += value * key\n            if energy < minE:\n                energy += value * key\n    return minE\n\nprint(solution('2 0.5\\n2 0.51\\n1 0.49'))"
    },
    {
        "number": 3242,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution for the codechef's weekly programming challenge,\n    Polly Parrot.\n    '''\n   ...\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Maintain two sets, one of servers (0-based index) that have been visited, and another set of servers that have been used to connect.\n    Use union to combine sets of connected and visited, and determine if the sets have more than k intersections.\n    '''\n\n    n, m, k = [int(x) for x in stdin.split(' ')]\n    connections = [[int(x) for x in line.split(' ')] for line in stdin.split('\\n')[1:m+1]]\n    visited = set(connections[0][0])\n    used = set()\n    connections = [[x, y] for x, y in connections]\n    for x, y in connections:\n        used.add(x)\n        used.add(y)\n        visited = used | visited\n        if len(visited) > k:\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n^3) time | O(n) space\"\"\"\n    n, m, k = [int(x) for x in stdin.split()]\n    connections = [[int(x) for x in stdin.split()] for _ in range(m)]\n    servers = [int(x) for x in stdin.split()]\n    return \"yes\" if any([get_possible_connections(servers, connections) <= k for _ in range(n)]) else \"no\"\n\n\ndef"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, m, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    links = []\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        links.append((u, v))\n        links.append((v, u))\n    links = list(set(links))\n    links.sort()\n    edits = 0\n    visited = set()\n    visited.add(0)\n    queue = [0]\n    while queue and edits <= k:\n        sz = len(queue)\n        for _ in range(sz):\n            i = queue.pop(0)\n            if i in visited:\n                continue\n            if c[i] > 0:\n                queue.append(i)\n                c[i] -= 1\n                if c[i] == 0:\n                    queue.append(i)\n                edits += 1\n            for u, v in links:\n                if i == u:\n                    if c[v] > 0:\n                        queue.append(v)\n                        c[v] -= 1\n                        if c[v] == 0:\n                            queue.append(v)\n                if i == v:\n                    if c[u] > 0:\n                        queue.append(u)\n                        c[u] -= 1\n                        if c[u] == 0:\n                            queue.append(u)\n        visited.update(queue)\n    if len(visited)!= n:\n        return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # n, m, k = map(int, stdin.readline().split())\n    # connections = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    # connections = [[c[0], c[1]] for c in connections]\n    # connections = [c for c in connections if c[0]!= c[1]]\n    # connections = {(u, v): 1 for u, v in connections}\n    # return 'yes' if is_feasible(n, connections, k) else 'no'\n    return 'yes'\n\n\ndef"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(start):\n        visited = {start}\n        stack = [start]\n        while stack:\n            curr = stack.pop()\n            for nei in graph[curr]:\n                if nei not in visited:\n                    visited.add(nei)\n                    stack.append(nei)\n        return visited\n\n    dfs_sets = [dfs(start) for start in range(n)]\n    # print(dfs_sets)\n    edges = set()\n    for u, v in zip(range(n), range(1, n)):\n        for i in dfs_sets[u]:\n            for j in dfs_sets[v]:\n                if i!= j:\n                    edges.add((i, j))\n    # print(edges)\n    return \"yes\" if len(edges) <= k else \"no\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    #Note: Make sure to read the input using stdin.readline()\n    #You can't use sys.stdin.readline()\n    pass"
    },
    {
        "number": 3243,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 5\n   ... 5\n   ... 5''')\n    '2\\n1\\n2\\n'\n    >>> solution('''4\n   ... 20\n   ... 15\n   ... 17\n   ... 14''')\n    '5\\n8\\n2\\n7\\n'\n    >>> solution('''5\n   ... 5\n   ... 5\n   ... 5\n   ... 5''')\n    '2\\n1\\n2\\n'\n    \"\"\"\n    n = int(stdin.split()[0])\n    ring = [int(i) for i in stdin.splitlines()[1:]]\n    ring = ring + ring[:2]\n    return '\\n'.join([str(i) for i in ring])\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n5\\n5\\n5\\n\")\n    '2\\n1\\n2\\n'\n    >>> solution(\"4\\n20\\n15\\n17\\n14\\n\")\n    '5\\n8\\n2\\n7\\n'\n    \"\"\"\n    n = int(stdin.readline())\n    ring = [int(stdin.readline()) for _ in range(n)]\n    ring.sort()\n    ring.append(ring[0] + ring[1])\n    ring.append(ring[1] + ring[2])\n    ring.append(ring[2] + ring[0])\n    return '\\n'.join(map(str, ring))\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution for exercise 2\"\"\"\n    data = stdin.split('\\n')\n    N = int(data[0])\n    number = 0\n    for i in range(1, N + 1):\n        number += int(data[i])\n        number += int(data[i - 1])\n    print(number % 10 ** 9)\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    l = [int(x) for x in stdin.split('\\n')]\n\n    f = [0] * n\n    f[0] = l[0]\n\n    for i in range(1, n):\n        f[i] = l[i] + f[i - 1]\n\n    f[0] = l[n - 1]\n\n    for i in range(n - 1, -1, -1):\n        f[i] = l[i] + f[i + 1]\n\n    for i in f:\n        print(i)\n    return ''\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Write your code here\n    '''\n    # todo\n    return ''\n\ndef"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    data = [int(x) for x in stdin.readline().split()]\n    print(*data[1::2])\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    ring = [int(i) for i in stdin.read().split('\\n')]\n\n    return '\\n'.join(\n        map(str, ring[(n - 1) % len(ring):] + ring[:n % len(ring)])\n    )\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Finds a ring of integers where the sum of the integers is constant.\n    '''\n    from collections import defaultdict\n    input = [int(i) for i in stdin.split('\\n')]\n    n = input[0]\n    ring = input[1:]\n    result = {}\n    for i, e in enumerate(ring):\n        result[i] = ring[i:] + ring[:i]\n    i = 0\n    while ring!= list(result[i]):\n        i = (i + 1) % n\n    return [ring[i + 1], ring[i - 1]]\n\nprint(solution(input()))\n"
    },
    {
        "number": 3244,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3\\n5\\n5\\n5\\n')\n    '2\\n1\\n2\\n'\n    \"\"\"\n    numbers = [int(stdin.split()[0])]\n    for number in stdin.split()[1:]:\n        numbers.append(int(number) + 1)\n        numbers.append(int(number))\n    return '\\n'.join(map(str, numbers))\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the command history.\"\"\"\n    return"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    cnt = int(stdin.readline())\n    history = []\n    for i in range(cnt):\n        cmd = stdin.readline()\n        history.append(cmd)\n        if cmd[0] == \"^\":\n            continue\n        else:\n            print(history[-1])\n            history.pop(-2)\n            if len(history) > 0:\n                if history[-1][0]!= \"^\":\n                    history.pop(-1)\n                    if len(history) > 0:\n                        if history[-1][0]!= \"^\":\n                            history.pop(-1)\n    return \"\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    if len(stdin) < 1:\n        return []\n    \n    history = []\n    for line in stdin:\n        if line == \"^\":\n            history = []\n            continue\n        history.append(line)\n    \n    print(''.join(history))\n    \n    return ''.join(history)"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3\\npython\\nmain.py\\n^\\n^\\n^\\n')\n    python\n    python main.py\n    python main.py -n 10\n    >>> solution('5\\npython\\njava\\n^\\n^^^\\n^^^\\n')\n    python\n    java\n    java\n    python\n    java\n    python\n    \"\"\"\n    # get the number of commands in stdin\n    num_of_commands = int(stdin.split(\"\\n\")[0])\n    # get the commands\n    commands = [line.replace(\"\\n\", \"\") for line in stdin.split(\"\\n\")[1:]]\n    # initialize the command history\n    command_history = [\"\"] * num_of_commands\n\n    for command in commands:\n        # get the index of the first up character\n        index = command.find(\"^\")\n        # append the current command to the history\n        command_history.append(command[index + 1:])\n        # replace the up characters with the commands\n        command = command[:index]\n        # check if we have any history\n        if command in command_history:\n            # if yes, get the index of the previous command\n            index = command_history.index(command)\n            # replace the up characters with the history\n            command = command_history[index - 1]\n        # add the command to the output\n        print(command)\n    return \"\"\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the history of the user input\n    \"\"\"\n    # YOUR CODE HERE\n    \n    n = int(stdin.split('\\n')[0])\n    hist = []\n    for line in stdin.split('\\n')[1:]:\n        hist.append(line)\n    for i in range(n):\n        line = hist[i]\n        if line == '':\n            continue\n        if line[0] == '^':\n            if len(hist) > 0:\n                line = hist.pop()\n        hist.append(line)\n    print('\\n'.join(hist))\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\npython\\njava\\n^\\n^\\n^\\n\")\n    python\n    java\n    java\n    python\n    java\n    >>> solution(\"5\\npython\\njava\\n^\\npython\\n^\\n\")\n    python\n    python\n    python\n    >>> solution(\"5\\npython\\njava\\n^\\npython\\n^\\n\")\n    python\n    python\n    python\n    >>> solution(\"5\\npython\\njava\\n^\\npython\\n^\\n^\\n\")\n    python\n    python\n    python\n    >>> solution(\"5\\npython\\njava\\n^\\npython\\n^\\n^\\n^\\n\")\n    python\n    python\n    python\n    \"\"\"\n    history = \"\"\n    for line in stdin.split(\"\\n\"):\n        if line and line[0]!= \"^\":\n            history += line\n            continue\n        if line:\n            history += \"\\n\"\n        cmd = \"\"\n        while cmd.count(\"^\")!= len(line) and line:\n            cmd += line.pop(0)\n        while cmd.count(\"^\")!= len(line):\n            cmd += \"\\n\"\n        history += cmd\n\n    return history\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return a sorted list of the users entered commands.\n    \"\"\"\n    # Split input into commands.\n    commands = stdin.split('\\n')\n\n    # Sort the commands.\n    commands.sort()\n\n    # Return the sorted list.\n    return commands"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    history = list()\n    n = int(stdin[0])\n    for _ in range(n):\n        command = stdin[_+1]\n        if not history:\n            history.append(command)\n            continue\n        for history_index in range(len(history)-1, -1, -1):\n            command_to_match = command[0:history_index+1]\n            if command_to_match in history:\n                history.append(command)\n                break\n    return '\\n'.join(history)\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\npython\\npython\\n^\")\n    python\n    python\n    python\n    >>> solution(\"5\\npython\\njava\\n^\")\n    python\n    java\n    python\n    python\n    java\n    >>> solution(\"5\\npython\\njava\\npython\\n^\")\n    python\n    java\n    python\n    python\n    java\n    >>> solution(\"3\\npython\\n^\")\n    python\n    >>> solution(\"3\\npython\\n^\\n^\")\n    python\n    \"\"\"\n    command_history = []\n    for line in stdin.split(\"\\n\"):\n        line = line.replace(\"^\", \"\")\n        if len(line) > 0:\n            command_history.append(line)\n    command_history.reverse()\n    return \"\\n\".join(command_history)\n"
    },
    {
        "number": 3245,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the history from the input.\n\n    Args:\n        stdin: The input string.\n\n    Returns:\n        A string with the history.\n    \"\"\"\n    hist = []\n    for line in stdin.splitlines():\n        if line.startswith('^'):\n            hist.append(line[1:])\n        else:\n            while hist and hist[-1].startswith('^'):\n                hist.pop()\n            hist.append(line)\n    return '\\n'.join(hist)\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    sentence = stdin\n    words = list(map(lambda x: x.strip(), stdin.split('\\n')[2:]))\n    words.append(sentence)\n    l = len(sentence)\n    for i in range(l):\n        for j in range(i, l):\n            if all(map(lambda x: x[i:j + 1] in words, words)):\n                return sentence[:i] + sentence[j:]\n    return 'impossible' if len(sentence) > 100 else 'ambiguous'\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    words = {word.strip() for word in stdin.split('\\n')[1:]}\n    l = len(stdin)\n    sentence = list(stdin)\n    sentence = list(map(lambda x: x if x.isalpha() else'', sentence))\n    sentence = list(filter(lambda x: x!='', sentence))\n    sentence.pop(0)\n    sentence.pop()\n    for i in range(l):\n        if not sentence[i].isalpha():\n            continue\n        for j in range(i + 1, l):\n            if not sentence[j].isalpha():\n                continue\n            sentence[i], sentence[j] = sentence[j], sentence[i]\n            if ''.join(sentence) in words:\n                return ''.join(sentence)\n            sentence[i], sentence[j] = sentence[j], sentence[i]\n    return 'impossible'"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.splitlines()[1:-1]\n    sentence = stdin.splitlines()[0]\n    if len(sentence) < 1 or len(sentence) > 1000:\n        return \"impossible\"\n    word_list = [word.split()[0] for word in words]\n    for word in words:\n        if len(word) < 1 or len(word) > 100:\n            return \"impossible\"\n    for word in words:\n        if word not in word_list:\n            return \"impossible\"\n    word_list = set(word_list)\n    for i in range(len(sentence)):\n        if sentence[i] == \" \":\n            continue\n        else:\n            for j in range(i, i + len(sentence)):\n                if j >= len(sentence) or sentence[j] == \" \":\n                    break\n                else:\n                    if sentence[j] == \" \":\n                        continue\n                    else:\n                        if sentence[j] == sentence[i]:\n                            continue\n                        else:\n                            sentence = sentence.replace(sentence[i], \" \", 1)\n                            return solution(sentence)\n            sentence = sentence.replace(sentence[i], \" \", 1)\n    return \"impossible\"\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    sentence = stdin.split('\\n')[0]\n    n = int(stdin.split('\\n')[1])\n    words = set()\n    for _ in range(n):\n        words.add(stdin.split('\\n')[2])\n    return \"impossible\" if len(sentence) == 0 or len(sentence) >= 1000 or len(sentence) <= 1 or len(words) == 0 else \"ambiguous\" if len(words) >= 10 else \" \".join(shuffled_word(sentence))\ndef"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    import itertools\n    \n    # step 1\n    # create all possible permutations of words from dictionary\n    words = [''.join(word) for word in itertools.product(*[stdin.split('\\n')[i+2] for i in range(int(stdin.split('\\n')[1]))])]\n    \n    # step 2\n    # count the number of words in the sentence\n    sentence = stdin.split('\\n')[0]\n    word_count = len(sentence.split(' '))\n    \n    # step 3\n    # create a dictionary with key = word and value = number of times word appears in sentence\n    word_dict = {word: 0 for word in words}\n    for word in words:\n        word_count_in_sentence = sentence.count(word)\n        if word_count_in_sentence == word_count:\n            word_dict[word] = word_count_in_sentence\n        else:\n            word_dict[word] = 0\n    \n    # step 4\n    # remove words that are not in the sentence\n    # if words are in sentence but have only one occurrence, they will not be removed\n    for key, val in list(word_dict.items()):\n        if val == 0:\n            del word_dict[key]\n    \n    # step 5\n    # create an array with one entry for each letter in the sentence\n    letters = [letter for letter in sentence]\n    \n    # step 6\n    # shuffle the array and put in a list\n    shuffled_letters = list(letters)\n    random.shuffle(shuffled_letters)\n    \n    # step 7\n    # create a dictionary with key = a letter and value = a letter that is in the dictionary and has not been used before\n    letter_dict = {letter: None for letter in letters}\n    for letter in letters:\n        if letter_dict[letter] is None:\n            for letter_from_dict in list(letter_dict.keys()):\n                if letter_dict[letter_from_dict] is None:\n                    letter_dict[letter] = letter_from_dict\n                    break\n    \n    # step 8\n    # replace letters in the shuffled_letters with the values of the letter_dict\n    for i in range(len(shuffled_letters)):\n        shuffled_letters[i] = letter_dict[shuffled_letters[i]]\n    \n    # step 9\n    # create a list of all possible combinations of the shuffled letters\n    combinations = list(itertools.permutations(shuffled_letters))\n    \n    # step 10\n    # create an array with one entry for each combination\n    combination_arrays = []\n    for combination in combinations:\n        combination_arrays.append(list(combination))\n    \n    # step 11\n    # create a dictionary with key = a combination and value = a score based on the score of the combination\n    combination_scores = {combination: 0 for combination in combinations}\n    for combination in combinations:\n        for letter in list(combination):\n            combination_scores[combination] += word_dict[letter]\n    \n    # step 12\n    # get the combination with the highest score\n    best_combination = max(combination_scores, key=combination_scores.get)\n    \n    # step 13\n    # unshuffle the best_combination and make it a string\n    unshuffled_best_combination = ''.join(best_combination)\n    \n    # step 14\n    # see if the unshuffled best_combination can be made by iterating through the sentence\n    for word in words:\n        if set(word) == set(unshuffled_best_combination):\n            return f'{word} {unshuffled_best_combination}'\n    return 'impossible' if unshuffled_best_combination.count(' ') == len(sentence.split(' ')) else 'ambiguous'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # \u043d\u0430\u0445\u043e\u0434\u0438\u043c \u0434\u043b\u0438\u043d\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0441\u043b\u043e\u0432\n    arrLen = stdin.split('\\n')[0]\n    arrLen = int(arrLen)\n    # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n    arr = [stdin]\n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u043d\u0430\u0448\u0438\u0445 \u0441\u043b\u043e\u0432\n    arr.extend(stdin.split('\\n')[1:arrLen+1])\n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0441\u043b\u043e\u0432\n    arr.extend(stdin.split('\\n')[arrLen+1:])\n    # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u0441\u043b\u043e\u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n    for i in range(arrLen):\n        arr.append(stdin.split('\\n')[i+1])\n    # \u0441\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0439 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430\n    arr2 = []\n    for i in range(arrLen):\n        arr2.append(0)\n    for i in range(arrLen):\n        arr2[i] = arr[i].count(' ')\n    # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0432\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u0439 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430\n    for i in range(arrLen):\n        arr2[i] += len(arr[i]) - arr[i].count(' ')\n    # \u0432\u044b\u0432\u043e\u0434 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    print(stdin)\n    # \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0441\u043b\u043e\u0432\u0430\u0440\u044f \u0441\u043e \u0441\u043b\u043e\u0432\u0430\u043c\u0438 \u0438\u0437 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    words = []\n    word = []\n    for i in range(len(arr[0])):\n        for j in range(len(arr)):\n            if arr[j][i]!='':\n                word.append(arr[j][i])\n            else:\n                words.append(''.join(word))\n                word = []\n        words.append(''.join(word))\n        word = []\n    # \u0432\u044b\u0432\u043e\u0434 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\n    for i in range(len(words)):\n        print(words[i])\n    # \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0441 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    wordsNew = []\n    for i in range(len(arr[0])):\n        for j in range(len(arr)):\n            if arr[j][i]!='':\n                wordsNew.append(arr[j][i])\n            else:\n                wordsNew.append(' ')\n        wordsNew.append(' ')\n    # \u0432\u044b\u0432\u043e\u0434 \u043d\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    for i in range(len(wordsNew)):\n        print(wordsNew[i], end='')\n    # \u043f\u043e\u0438\u0441\u043a \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u043f\u0440\u043e\u0431\u0435\u043b\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\n    firstIndex = -1\n    lastIndex = -1\n    for i in range(len(wordsNew)):\n        if wordsNew[i] =='':\n            if firstIndex == -1:\n                firstIndex = i\n            lastIndex = i\n    # \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u0430\u044f \u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u043f\u0440\u043e\u0431\u0435\u043b\u0430 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u043d\u0430\u0447\u0430\u043b\u0435 \u0438\u043b\u0438 \u043a\u043e\u043d\u0446\u0435, \u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u0442\u044c \u0438\u0437 \u0441\u043b\u043e\u0432\u0430\u0440\u044f\n    if firstIndex == 0 or lastIndex == len(wordsNew) - 1:\n        print('impossible')\n        return 'impossible'\n    # \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0441\u0442\u0440\u043e\u043a\u0438\n    if ''.join(wordsNew[firstIndex:lastIndex+1])!= stdin:\n        print('impossible')\n        return 'impossible'\n    # \u0432\u043e\u0437\u0432\u0440\u0430\u0442 \u0440\u0430\u0441\u0448\u0438\u0444\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438\n    print(''.join(wordsNew[firstIndex+1:lastIndex]))\n    return ''.join(wordsNew[firstIndex+1:lastIndex])\n\n\nsolution('hitehre')\nsolution('tihssnetnceemkaesprfecetsesne')\nsolution('tihs snetncee mkaes prfecet sesne')\nsolution('tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne')\nsolution('hitehre tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne tihs snetncee mkaes prfecet sesne')\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    solve the problem\n    :param stdin: input string\n    :return: answer as string\n    \"\"\"\n    s, n = stdin.split('\\n')\n    n = int(n)\n    dictionary = set()\n    for _ in range(n):\n        dictionary.add(stdin.readline())\n\n    return 'impossible' if len(s) > 1000 or len(s) < 1 else s if any(s in word for word in dictionary) else 'ambiguous'\n"
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    return \"\""
    },
    {
        "number": 3246,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    sentence, n = stdin.split('\\n')\n    n = int(n)\n    d = {}\n    for i in range(n):\n        word = stdin.split('\\n')[i]\n        d[word] = True\n    s = sentence.split()\n    n = len(s)\n    for i in range(n):\n        for j in range(1, n + 1):\n            if i + j > n:\n                continue\n            s[i:i + j] = s[i:i + j][::-1]\n            word =''.join(s)\n            if word in d:\n                return word\n        s[i] = s[i][::-1]\n    return 'impossible'\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    arr = [\n        [\n            [-1] * (m + 2),\n            [-1] + [0] * m + [-1],\n            [-1] * (m + 2),\n        ]\n        for _ in range(n + 2)\n    ]\n\n    def nex(i, j):\n        if j < m + 1 and i < n + 1:\n            return (i + 1, j + 1)\n        if j >= m + 1 and i < n + 1:\n            return (i + 1, j - 1)\n        if j >= m + 1 and i >= n + 1:\n            return (i - 1, j - 1)\n        if j < m + 1 and i >= n + 1:\n            return (i - 1, j + 1)\n\n    def count(i, j):\n        arr[i][j][0] = arr[i][j][1] = 0\n        for nx, ny in nex(i, j):\n            arr[i][j][0] += 1 if arr[nx][ny][0] == -1 else 0\n            arr[i][j][1] += 1 if arr[nx][ny][1] == -1 else 0\n\n    for i in range(n + 2):\n        count(i, 0)\n        count(i, m + 1)\n    for j in range(m + 2):\n        count(0, j)\n        count(n + 1, j)\n    count(0, 0)\n    count(0, m + 1)\n    count(n + 1, 0)\n    count(n + 1, m + 1)\n    return sum(arr[n][m][0] + arr[n][m][1] - 1 for n in range(1, n + 1)) % (10 ** 9 + 9)\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    arr = [int(s) for s in stdin.split()]\n    return str(int(pow(2,arr[0]-1,(10**9)+9)))\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(i) for i in stdin.split(' ')]\n\n    def fact(n):\n        if n == 0 or n == 1:\n            return 1\n        return n * fact(n - 1)\n\n    ans = fact(n) * fact(m) * (n + m)\n    return str(ans % (10**9 + 9))\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution to the problem\"\"\"\n    # Read the input\n    n, m = stdin.split()\n    n = int(n)\n    m = int(m)\n    # Perform a naive solution and print the output\n    return str(pow(2, n*m, 10**9 + 9))\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    if n < 1 or n > 4 or m < 1 or m > 10 ** 9:\n        return -1\n    \n    cnt = 0\n    for i in range(n):\n        for j in range(m):\n            if i == j == n - 1 or j == n - 1:\n                cnt += 1\n                continue\n            if i == 0 or i == n - 1:\n                cnt += 1\n                continue\n            if j == 0 or j == m - 1:\n                cnt += 1\n                continue\n            cnt += 2\n    return cnt % (10 ** 9 + 9)\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n, m = stdin.split()\n    # n, m = int(n), int(m)\n    return 0\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(((2 * m - 2) ** 2 * n * (n - 1) ** 2) % (10 ** 9 + 9))\n"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin.split(' ')\n    n, m = map(int, num)\n    return '{:>10}'.format(m * (m - 1) // 2)\n    return num"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Create a dictionary to store the values of the squares.\n    square_dict = {}\n    # Loop through the rows.\n    for row in range(5):\n        # Loop through the columns.\n        for col in range(10):\n            # Calculate the square's value.\n            square = (row + 1) ** 2 + (col + 1) ** 2\n            # Add the square's value to the dictionary.\n            square_dict[square] = True\n    # Initialize the variables.\n    total = 0\n    # Loop through the lines.\n    for line in stdin.split('\\n'):\n        # Initialize the variables.\n        row = 0\n        col = 0\n        # Initialize the total count.\n        total_count = 0\n        # Loop through the line.\n        for char in line:\n            # Determine if the current character is an \"X\" or an \"O\".\n            if char == 'X':\n                # Add the value of the current square to the total.\n                total += square_dict[(row + 1) ** 2 + (col + 1) ** 2]\n                # Add to the total count.\n                total_count += 1\n            # If the current character is an \"O\", then it is a knight.\n            if char == 'O':\n                # Set the variables.\n                rows = [0, 1, -1, 2, -2]\n                cols = [1, 2, 2, 1, -1]\n                # Loop through the rows.\n                for row_change in rows:\n                    # Loop through the columns.\n                    for col_change in cols:\n                        # If the new row and column is in the dictionary, then it is a square containing a knight.\n                        if (row + row_change) ** 2 + (col + col_change) ** 2 in square_dict:\n                            # Add to the total count.\n                            total_count += 1\n            # Increment the column.\n            col += 1\n        # Increment the row.\n        row += 1\n    # Return the total count.\n    return total % (10 ** 9 + 9)\n\n\ndef"
    },
    {
        "number": 3247,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    test_case = stdin.readline().rstrip('\\n')\n    for case in test_case:\n        x, y = map(int, test_case.split())\n\n        # Get number of knights\n        knight_count = int((x * y) / 2)\n\n        # Calculate number of ways\n        ways = pow(knight_count, 2)\n\n        # Add additional 2^n\n        for i in range(2, x):\n            for j in range(2, y):\n                if not (i == 1 or j == 1):\n                    ways += 2\n\n        print(ways % (1e9 + 9))\n    return ''\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(c) for c in stdin.split('\\n')[0].split()]\n    s = stdin.split('\\n')[1]\n    d = stdin.split('\\n')[2:]\n    res = set()\n    for i in range(len(s)):\n        for j in range(len(s)):\n            if j < i:\n                continue\n            if s[j:i+1] in d:\n                res.add(j)\n    return len(res)\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    N, L, M = map(int, stdin.split('\\n')[:3])\n    letters = list(stdin.split('\\n')[3])\n    tiles = []\n    for _ in range(M):\n        tiles.append(stdin.split('\\n')[_][:L])\n\n    left = letters.index('c')\n    right = len(letters) - 1 - letters[::-1].index('c')\n\n    return right - left - len(letters) + 1 - L\n\n\ndef"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    street = stdin[0:n]\n    m = int(stdin[n])\n    tiles = list()\n    for i in range(m):\n        tile = stdin[n+1+i]\n        tiles.append(tile)\n\n    cnt = 0\n    for i in range(n):\n        cnt += street.count(street[i]) - 1\n\n    return cnt\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    result = 0\n    input()\n    tiles = stdin.split('\\n')\n    tile_count = int(tiles.pop(0))\n    tile_lengths = [int(i) for i in tiles]\n    tile_sums = [sum(tile_lengths[:i]) for i in range(tile_count + 1)]\n    result = sum([1 for i in range(1, tile_count + 1) if tile_sums[i] > len(stdin)])\n    return result\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    number of untileable cells\n    \"\"\"\n    # write your code in Python 3.6\n    import sys\n    import itertools\n    #stdin = sys.stdin.read()\n    n = int(stdin.readline())\n    S = list(stdin.readline())\n    m = int(stdin.readline())\n    L = [stdin.readline() for i in range(m)]\n    m = set(L)\n    L = [list(s) for s in m]\n    L.sort()\n    L = [''.join(s) for s in L]\n    S.sort()\n    S = set(S)\n    L = set(L)\n    T = list(S - L)\n    T.sort()\n    print(T)\n    return 0\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    N: int = stdin.readline().strip()\n    street: str = stdin.readline().strip()\n    M: int = int(stdin.readline().strip())\n    tile_patterns: List[List[str]] = [stdin.readline().strip() for _ in range(M)]\n    '''\n    N: int = 6\n    street: str = 'abcbab'\n    M: int = 2\n    tile_patterns: List[List[str]] = [\n        'cb',\n        'cbab'\n    ]\n\n    # create a map of tiles\n    tiles: Dict[str, int] = {}\n    for tile_pattern in tile_patterns:\n        tiles[tile_pattern] = tiles.get(tile_pattern, 0) + 1\n\n    # number of untileable cells\n    ans: int = 0\n\n    # go through all the possible tile arrangements\n    for n in range(0, N + 1):\n        if n % 10 == 0:\n            print(f'at {n}')\n\n        for i in range(0, N - n + 1):\n            # build the string\n            sub_str: str = street[i:i + n]\n            # check if it's tileable\n            if len(sub_str)!= n:\n                continue\n\n            # go through each tile pattern\n            for tile_pattern in tiles:\n                # check if the tile pattern can cover the sub_str\n                is_covered: bool = True\n                for tile in tile_pattern:\n                    if sub_str.find(tile) == -1:\n                        is_covered = False\n                        break\n\n                if is_covered:\n                    # increment the number of untileable cells\n                    ans += 1\n                    break\n\n    return ans\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin.split('\\n')[0]\n    street = stdin.split('\\n')[1]\n    m = stdin.split('\\n')[2]\n    patterns = stdin.split('\\n')[3:]\n    d = {}\n    for i in patterns:\n        d[i] = 1\n    cnt = 0\n    for i in range(len(street) - len(patterns) + 1):\n        if i == 0:\n            for j in range(len(patterns)):\n                if street[j]!= patterns[j]:\n                    cnt += 1\n                    break\n        else:\n            l = street[i - 1]\n            if l in patterns:\n                if street[i + len(patterns) - 1]!= patterns[l - 1]:\n                    cnt += 1\n                    break\n    return cnt\n"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    letters = stdin[0]\n    letters_list = list(letters)\n    tile_number = int(stdin[1])\n    tile_length = int(stdin[2])\n    letters_list_length = len(letters_list)\n    tile_list = []\n    i = 0\n    while i < tile_number:\n        tile = stdin[3 + i]\n        tile_list.append(tile)\n        i += 1\n    tile_list_length = len(tile_list)\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile_list_length = tile_list_length - 1\n    tile"
    },
    {
        "number": 3248,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin\n    letters = [char for char in string]\n    return len(letters) - len(set(letters))\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum number of bulkhead sections and the placement of the bulkhead sections\"\"\"\n    C = int(stdin.readline().rstrip())\n    N = int(stdin.readline().rstrip())\n    all_data = []\n    for _ in range(N):\n        x, y = list(map(int, stdin.readline().rstrip().split()))\n        all_data.append((x, y))\n    all_data.sort(key=lambda x: x[0])\n    placements = []\n    sections = []\n    for x, y in all_data:\n        if sections and sections[-1][1] >= x:\n            sections[-1][0] = x\n            sections[-1][1] = y\n        else:\n            sections.append([x, y])\n    x_min = sections[0][0]\n    x_max = sections[0][1]\n    for x, y in sections[1:]:\n        if x < x_min:\n            x_min = x\n        if x > x_max:\n            x_max = x\n        if y < x_min:\n            x_min = y\n        if y > x_max:\n            x_max = y\n    sections.sort(key=lambda x: x[1])\n    for x, y in sections:\n        placements.append(x_max - x)\n        x_max = y\n    return f\"{len(placements)}\\n{' '.join(str(x) for x in placements)}\"\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the maximum number of bulkhead sections and the\n    exact placements of the bulkhead sections based on the given input.\n\n    Parameters:\n        stdin (str): the input string\n\n    Returns:\n        str: the output string\n    \"\"\"\n\n    def input_to_list(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return [item for item in stdin.split('\\n')]\n\n    def input_to_ints(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return [int(item) for item in input_to_list(stdin)]\n\n    def input_to_floats(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return [float(item) for item in input_to_list(stdin)]\n\n    def input_to_strs(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return [str(item) for item in input_to_list(stdin)]\n\n    def input_to_ints_iter(stdin: str) -> Iterator[int]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[int]: the iterator of the input\n        \"\"\"\n\n        return map(int, input_to_strs(stdin))\n\n    def input_to_floats_iter(stdin: str) -> Iterator[float]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[float]: the iterator of the input\n        \"\"\"\n\n        return map(float, input_to_strs(stdin))\n\n    def input_to_strs_iter(stdin: str) -> Iterator[str]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[str]: the iterator of the input\n        \"\"\"\n\n        return map(str, input_to_strs(stdin))\n\n    def input_to_ints_map(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(map(int, input_to_strs(stdin)))\n\n    def input_to_floats_map(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(map(float, input_to_strs(stdin)))\n\n    def input_to_strs_map(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(map(str, input_to_strs(stdin)))\n\n    def input_to_ints_map_iter(stdin: str) -> Iterator[int]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[int]: the iterator of the input\n        \"\"\"\n\n        return map(int, input_to_strs(stdin))\n\n    def input_to_floats_map_iter(stdin: str) -> Iterator[float]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[float]: the iterator of the input\n        \"\"\"\n\n        return map(float, input_to_strs(stdin))\n\n    def input_to_strs_map_iter(stdin: str) -> Iterator[str]:\n        \"\"\"Returns an iterator of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            Iterator[str]: the iterator of the input\n        \"\"\"\n\n        return map(str, input_to_strs(stdin))\n\n    def input_to_ints_filter(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(filter(lambda x: x > 0, input_to_ints_map(stdin)))\n\n    def input_to_floats_filter(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(filter(lambda x: x >= 0, input_to_floats_map(stdin)))\n\n    def input_to_strs_filter(stdin: str) -> list:\n        \"\"\"Returns a list of the input in the input string.\n\n        Parameters:\n            stdin (str): the input string\n\n        Returns:\n            list: the list of the input\n        \"\"\"\n\n        return list(filter(lambda x: x!= '', input_to_strs_map(stdin)))\n\n    def input_to"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates maximum number of bulkhead sections and their positions\"\"\"\n    return\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    C = int(stdin.readline())\n    N = int(stdin.readline())\n    area = [0] * N\n    coord = [0] * N\n    for i in range(N):\n        x, y = map(int, stdin.readline().split())\n        area[i] = (y - x) * C\n        coord[i] = x + C / 2\n    area.sort()\n    coord.sort()\n    ans = 1\n    max_area = area[-1]\n    for i in range(N - 1):\n        if (area[i + 1] - area[i]) / max_area > 0.001:\n            ans += 1\n    print(ans)\n    for i in range(N - 1):\n        print(\"{0:.6f}\".format(coord[i] + area[i] / max_area / 2))\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    # return str(res)\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the maximum number of bulkhead sections, \n    and the placement of each bulkhead section.\n\n    Args:\n        stdin (str): Input string to process.\n\n    Returns:\n        str: Output string to print.\n    \"\"\"\n    \n    # Separate the data into sections\n    sections = stdin.split(\"\\n\\n\")\n    \n    # Extract data from sections\n    min_area = int(sections[0])\n    section_count = int(sections[1])\n    sections = sections[2:]\n    points = [tuple(map(int, lines.split(\" \"))) for lines in sections]\n    \n    # Initialize variables for computing area\n    total_area = 0\n    min_x = 0\n    max_x = 0\n    \n    # Loop over all sections\n    for i in range(section_count):\n        # Compute the area of this section\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % section_count]\n        area = (x2 - x1) * (y1 + y2) / 2\n        \n        # Update the min_x and max_x values\n        min_x = min(min_x, x1, x2)\n        max_x = max(max_x, x1, x2)\n        \n        # Add this area to the total\n        total_area += area\n    \n    # Compute the area of the hull\n    hull_area = (max_x - min_x) * (sum(y for x, y in points) / section_count)\n    \n    # Compute the area of the hull without the bulkheads\n    unbounded_area = hull_area - total_area\n    \n    # Find the area of the next section\n    next_area = min_area * (unbounded_area / min_area)\n    \n    # Determine which section to place the next section\n    for i in range(section_count):\n        # Compute the area of this section\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % section_count]\n        area = (x2 - x1) * (y1 + y2) / 2\n        \n        # Update the min_x and max_x values\n        min_x = min(min_x, x1, x2)\n        max_x = max(max_x, x1, x2)\n        \n        # Compute the area of the hull\n        hull_area = (max_x - min_x) * (sum(y for x, y in points) / section_count)\n        \n        # Compute the area of the hull without the bulkheads\n        unbounded_area = hull_area - total_area\n        \n        # If this is the last section, don't care about the next section\n        if i == section_count - 1:\n            continue\n        \n        # Compute the area of the next section\n        next_area = min_area * (unbounded_area / min_area)\n        \n        # If the next section has a greater area than the current section,\n        # the current section must be the next section\n        if next_area > area:\n            break\n    \n    # Find the placements for the next section\n    placements = []\n    x = min_x\n    while x <= max_x:\n        # Compute the area of the hull\n        hull_area = (max_x - x) * (sum(y for x, y in points) / section_count)\n        \n        # Compute the area of the hull without the bulkheads\n        unbounded_area = hull_area - total_area\n        \n        # Compute the area of the next section\n        next_area = min_area * (unbounded_area / min_area)\n        \n        # Check if this placement is valid\n        if next_area == area:\n            placements.append(x)\n        \n        # Increment x\n        x += 1\n    \n    # Sort the placements\n    placements.sort()\n    \n    # Return the results\n    return str(len(placements)) + \"\\n\" + \"\\n\".join(map(str, placements))"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the max number of bulkhead sections, the max coordinate for the\n    placement of a bulkhead, and the total area of sections with the same\n    area, and return them in the specified format.\n\n    >>> solution(r'50\\n4\\n110 10\\n80 10\\n80 0\\n110 0')\n    '6\\n85\\n90\\n95\\n100\\n105'\n\n    >>> solution(r'24\\n3\\n10 10\\n30 10\\n20 20')\n    '4\\n17.071067\\n20\\n22.928932'\n    \"\"\"\n    C = int(stdin.readline().strip())\n    N = int(stdin.readline().strip())\n    X = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        X.append(x)\n    X = sorted(X)\n    S = 0\n    result = []\n    for i in range(1, N):\n        s = (X[i] - X[i - 1]) * (X[i - 1] + X[i]) / 2\n        S += s\n        if S > C:\n            result.append(X[i - 1] + (C - S) / (X[i - 1] - X[i]))\n            break\n    else:\n        result.append(X[-1] + (C - S) / (X[-1] - X[-2]))\n    result = map(lambda x: round(x, 6), result)\n    return str(len(result)) + '\\n' + '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''50\n   ... 4\n   ... 110 10\n   ... 80 10\n   ... 80 0\n   ... 110 0''')\n    '6'\n    >>> solution('''24\n   ... 3\n   ... 10 10\n   ... 30 10\n   ... 20 20''')\n    '4'\n    \"\"\"\n    return (\n        f\"{count_bulkhead_sections(stdin, 40)}\",\n        \" \".join(map(str, find_bulkhead_placements(stdin, 40))),\n    )\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds max number of bulkhead sections and bulkhead placements for the boat.\"\"\"\n    # solution: O(nlogn)\n\n    # parse input\n    input = stdin.split('\\n')\n    input_n = int(input[0])\n    input_s = input[1:]\n\n    # get max area\n    max_area = 0\n    for line in input_s:\n        x, y = map(float, line.split())\n        area = 0.5 * abs(x - y)\n        if area > max_area:\n            max_area = area\n\n    # get placements\n    placements = []\n    for line in input_s:\n        x, y = map(float, line.split())\n        placements.append(0.5 * abs(x - y))\n\n    placements.sort()\n\n    # get number of sections\n    num_sections = 0\n    while num_sections < len(placements) and max_area * num_sections > placements[num_sections]:\n        num_sections += 1\n\n    # generate placements\n    placements = []\n    for i in range(num_sections):\n        placements.append(0.5 * (placements[i] + placements[i + 1]))\n\n    # return answers\n    return str(num_sections) + '\\n' +''.join(map(str, placements))\n"
    },
    {
        "number": 3249,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\"\"\"\n    with open('text', 'w') as f:\n        f.write(stdin)\n    x = _solution('text')\n    os.remove('text')\n    return x\n\n\ndef"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    cnt = 0\n    while d <= b ** cnt:\n        if d % b == 0:\n            return \"yes\"\n        cnt += 1\n    return \"no\"\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, d = [int(i) for i in stdin.split(' ')]\n    return 'yes' if d % 2 == 0 else 'no'\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split(' '))\n    result = 'no'\n    for m in range(1, int(d ** 0.5)):\n        if (d * m) % b == 0:\n            result = 'yes'\n            break\n    return result\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if b % 2 == 0:\n        return 'no'\n    m = b ** (d - 1)\n    n = b ** (d - 2)\n    a = (n - m) / (b - 1)\n    if a % 1 == 0:\n        return 'no'\n    n = a ** d\n    if n % d!= 0:\n        return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A Divisibility Hack is a mathematical trick that can be used to easily decide\n    which positive integers $n$ are multiples of a given positive integer $d$.\n    As such, it can be used to define a reduction function $f_{b,m}(n)$ that\n    maps positive integers to (usually smaller) integers. For a given positive\n    integer $n$, if\\[ n = a_ kb^k + a_{k - 1}b^{k - 1} + \\ldots + a_1b^1 + a_0b^0 \\]\n    is the base-$b$ expansion of $n$, then $f_{b,m}(n)$ is defined to be\\[ n = a_ kb^k + a_{k - 1}b^{k - 1} + \\ldots + a_1b^1 + a_0b^0 \\]\n    where $a_ j = 0$ whenever $j > k$. In other words, the reduction function is an\n    alternating sum of terms, each of which is formed using $m$ consecutive base-$b$\n    digits of $n$, starting with the least significant digit. We say that the $(b,d,m)$\n    divisibility hack is valid if for all positive integers $n$, $f_{b,m}(n)$ is\n    divisible by $d$ if and only if $n$ is divisible by $d$. Thus, if we have a large\n    integer\u00a0$n$ to check for divisibility by\u00a0$d$, we can simply apply the reduction\n    function to get a new smaller integer that we can instead test for divisibility\n    by\u00a0$d$.\n    \"\"\"\n    (b, d) = tuple(map(int, stdin.split()))\n    assert 2 < b < 2 ** 63\n    assert 1 < d < 2 ** 63\n    assert d % 2 == 1\n    assert d >= b ** (d - 1)\n    return \"yes\" if (d - 1) * b ** (d - 1) < b ** d else \"no\"\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    return 'yes' if d % b == 0 and d % 2 == 0 else 'no'\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/divisibility-hack-the-triggers/python\"\"\"\n    _, d = map(int, stdin.split())\n    \n    for i in range(1, 100):\n        if d % i == 0:\n            for j in range(1, 100):\n                for k in range(1, 100):\n                    if d % (i * j * k) == 0:\n                        if d % (i * j + j * k + k * i) == 0:\n                            if d % (i * j + j * k + k * i + i * j + j * k + k * i + i * j + j * k) == 0:\n                                if d % (i * j + j * k + k * i + i * j + j * k + k * i + i * j + j * k + i * j + j * k + k * i + i * j + j * k + i * j + j * k + k * i + i * j + j * k + k * i + i * j + j * k) == 0:\n                                    return \"yes\""
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    return 'yes' if d % 2 == 0 else 'no'"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n\n    if d == 1:\n        return \"no\"\n\n    count = 0\n    max_m = d\n    while max_m <= 2 ** 63 - 1:\n        if d % b ** (count + 1) == 0:\n            count += 1\n            max_m = b ** count\n        else:\n            break\n\n    if d % b ** count == 0:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3250,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    return 'yes' if reduce(lambda n, m: (n + m) % d == 0, map(lambda i: i ** b, range(1, 2 ** 63)), 0) else 'no'\n"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''\n"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    intervals = []\n    for _ in range(n):\n        intervals.append(list(map(int, stdin.readline().strip().split())))\n    intervals = sorted(intervals, key=lambda x: x[1])\n    curr_interval = intervals[0]\n    longest_seq = [curr_interval]\n    for i in range(1, n):\n        if curr_interval[1] < intervals[i][0]:\n            curr_interval = intervals[i]\n            longest_seq.append(curr_interval)\n    longest_seq = sorted(longest_seq, key=lambda x: x[1])\n    return len(longest_seq), [interval[0] for interval in longest_seq]\n\n\ndef"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the longest sequence of consecutive intervals in the set that have the same number of elements.\n    \n    Parameters\n    ----------\n    stdin : str\n        A string of integers that define the set of intervals.\n\n    Returns\n    -------\n    str\n        The longest sequence of consecutive intervals in the set that have the same number of elements.\n    \"\"\"\n    \n    set = [int(x) for x in stdin.split('\\n')]\n    \n    def fun(lst: list) -> list:\n        \"\"\"\n        Finds the longest consecutive sequence of intervals in the set that have the same number of elements.\n        \n        Parameters\n        ----------\n        lst : list\n            A list of intervals.\n        \n        Returns\n        -------\n        list\n            A list of consecutive intervals in the set that have the same number of elements.\n        \"\"\"\n        \n        lst.sort()\n        t = lst[0]\n        l = [lst[0]]\n        \n        for x in lst:\n            if x == t + 1:\n                l.append(x)\n                t = x\n            else:\n                yield l\n                l = [x]\n                t = x\n        yield l\n    \n    l = list(fun(set))\n    \n    def longest(lst: list) -> int:\n        \"\"\"\n        Finds the length of the longest consecutive sequence of intervals in the set that have the same number of elements.\n        \n        Parameters\n        ----------\n        lst : list\n            A list of intervals.\n        \n        Returns\n        -------\n        int\n            The length of the longest consecutive sequence of intervals in the set that have the same number of elements.\n        \"\"\"\n        \n        longest = 0\n        \n        for x in lst:\n            if len(x) > longest:\n                longest = len(x)\n        \n        return longest\n    \n    return longest(l)\n\n\ndef"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n3 4\\n2 5\\n1 6\")\n    '3'\n    >>> solution(\"5\\n10 30\\n20 40\\n30 50\\n10 60\\n30 40\")\n    '3'\n    \"\"\"\n    intervals = set()\n    intervals.add(stdin)\n    intervals = list(sorted(intervals))\n    intervals_by_end = []\n    for interval in intervals:\n        intervals_by_end.append((interval[1], interval))\n    intervals_by_end.sort()\n    intervals_by_end = [item[1] for item in intervals_by_end]\n    curr_start = intervals_by_end[0][0]\n    curr_end = intervals_by_end[0][1]\n    max_length = 1\n    for interval in intervals_by_end:\n        if interval[0] > curr_end + 1:\n            max_length += 1\n            curr_end = interval[1]\n            curr_start = interval[0]\n        else:\n            curr_end = max(curr_end, interval[1])\n    return str(max_length)\n\n\ndef"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest sequence of intervals in a set such that each interval in the sequence is in the set and that each interval contains the one that follows in the sequence.\n\n    Args:\n        stdin (str): input on stdin.\n\n    Returns:\n        str: output on stdout.\n    \"\"\"\n    pass"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin.pop(0))\n    intervals = []\n    for interval in stdin:\n        intervals.append(list(map(int, interval.split(\" \"))))\n    intervals = sorted(intervals, key = lambda x: x[0])\n    dp = [1]*n\n    for i in range(1, n):\n        for j in range(i):\n            if intervals[i][0] >= intervals[j][1]:\n                dp[i] = max(dp[i], dp[j]+1)\n    print(max(dp))\n    for i in range(n-1, -1, -1):\n        if dp[i] == max(dp):\n            print(intervals[i])\n            break\n        \n        \n"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the input and returns the solution\"\"\"\n    pass"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find longest sequence in the set\"\"\"\n\n    # n = int(stdin.readline())\n    # a = set()\n    # for _ in range(n):\n    #     a.add(tuple(map(int, stdin.readline().split())))\n    #\n    # a = sorted(a)\n    # l = len(a)\n    #\n    # c = [1] * l\n    # mx = 1\n    # for i in range(1, l):\n    #     for j in range(i):\n    #         if a[j][0] < a[i][0] and a[i][1] < a[j][1]:\n    #             c[i] = max(c[i], c[j] + 1)\n    #         if c[i] > mx:\n    #             mx = c[i]\n    #\n    # for i in range(mx):\n    #     print(a[i], end=\" \")\n\n\ndef"
    },
    {
        "number": 3251,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return''.join(str(e) for e in longest_seq(stdin))\n\ndef"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cards_input = stdin.split('\\n')\n    cards_input = [cards_input[i].split(' ') for i in range(len(cards_input))]\n    cards_input = [[int(x) for x in cards_input[i]] for i in range(len(cards_input))]\n    cards_input = sorted(cards_input, key=lambda x: x[0]*x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key=lambda x: x[2])\n    cards_input = sorted(cards_input, key=lambda x: x[0])\n    cards_input = sorted(cards_input, key=lambda x: x[1])\n    cards_input = sorted(cards_input, key"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = []\n    for _ in range(n):\n        w, h, q = map(int, stdin.split())\n        cards.append((w * h, q))\n\n    cards.sort()\n    max_width = cards[-1][0]\n\n    count = 0\n    for _, q in cards:\n        if q == 1:\n            count += max_width\n        else:\n            count += q * (max_width - q + 1)\n\n    print(count)\n    return ''\n"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return '-1'"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    return (\n        solution_bf(stdin)\n    )\n\n\ndef"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem.\"\"\"\n    pass  # TODO: implement here\n"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the amount of wasted paper by given parameters.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Number of wasted paper\n    \"\"\"\n    cards_data = stdin.split(\"\\n\")\n    cards = list()\n    for data in cards_data:\n        cards.append(list(map(int, data.split(\" \"))))\n\n    # Find the total number of cards\n    cards_quantity = sum([card[0] * card[1] for card in cards])\n    # Find the max number of type of card\n    cards_types = len(cards)\n\n    # Find the max number of type of envelope\n    max_envelope_types = int(stdin.split(\"\\n\")[0].split(\" \")[1])\n    \n    # Define the variables for the calculation\n    envelope_size = 0\n    envelope_counter = 0\n    wasted_paper = 0\n    envelope_types_counter = 0\n    envelope_types = 0\n    \n    # Enumerate all possible combinations of cards\n    for card_type in range(cards_types):\n        # Enumerate all possible combinations of envelope\n        for envelope_type in range(envelope_types_counter, max_envelope_types):\n            # Find the current card size\n            card_width = cards[card_type][0]\n            card_height = cards[card_type][1]\n            card_quantity = cards[card_type][2]\n            # Find the current envelope size\n            envelope_width = envelopes[envelope_type][0]\n            envelope_height = envelopes[envelope_type][1]\n\n            # Check if card fits in current envelope\n            if (card_width <= envelope_width and card_height <= envelope_height) and (card_quantity <= envelope_height):\n                # Calculate how much paper is wasted for the current combination\n                card_wasted_paper = card_quantity * (card_width * card_height)\n                envelope_wasted_paper = envelope_width * envelope_height\n                wasted_paper += card_wasted_paper + envelope_wasted_paper\n                # Check if it is the best combination of cards and envelopes\n                if wasted_paper < best_wasted_paper:\n                    best_wasted_paper = wasted_paper\n                    envelope_size = envelope_width * envelope_height\n                    envelope_counter = envelope_type + 1\n                    envelope_types_counter = envelope_type + 1\n                # Check if the number of type of cards is more than the number of type of envelopes\n                if envelope_type + 1 == cards_types:\n                    return best_wasted_paper\n                break"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the total wasted paper amount for the test cases\"\"\"\n    stdin = stdin.split('\\n')\n    \n    cards_list = []\n    for line in stdin:\n        line = line.split()\n        w = int(line[0])\n        h = int(line[1])\n        q = int(line[2])\n        cards_list.append(Card(w, h, q))\n    \n    cards = sorted(cards_list, key=lambda card: card.area)\n    paper_required = 0\n    while cards:\n        paper_required += cards[-1].area\n        cards.pop()\n    return paper_required\n    \nclass Card:\n    def __init__(self, width: int, height: int, quantity: int):\n        self.width = width\n        self.height = height\n        self.quantity = quantity\n    \n    def area(self):\n        return self.width * self.height * self.quantity\n\n\nprint(solution(stdin.read()))"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the optimal solution to the problem.\n\n    :param stdin: The standard input.\n    :return: The solution to the problem.\n    \"\"\"\n\n    n, k = map(int, stdin.split(' '))\n    card_dimensions = []\n    for _ in range(n):\n        w, h, q = map(int, stdin.split(' '))\n        card_dimensions.append((w, h, q))\n    card_dimensions = sorted(card_dimensions, key=lambda x: (x[0], x[1]))\n    waste = 0\n    card_order = []\n    current_card = None\n    next_card = None\n    current_card_index = 0\n    while len(card_order) < n:\n        next_card_index = 0\n        for card in card_dimensions:\n            card_order.append(card)\n            if len(card_order) == n:\n                break\n            elif card_order[-1][0] > card_order[current_card_index][0]:\n                next_card = card\n                next_card_index += 1\n                break\n        current_card = card_order.pop(current_card_index)\n        if next_card_index!= 0:\n            waste += current_card[0] * current_card[1] * (next_card[0] - current_card[0]) * (next_card[1] - current_card[1])\n            current_card_index = next_card_index\n        else:\n            waste += current_card[0] * current_card[1] * (current_card[0] - next_card[0]) * (current_card[1] - next_card[1])\n    return waste\n"
    },
    {
        "number": 3252,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    An implementation of the Gale-Shapley algorithm.\n    This algorithm is a market-clearing mechanism for a single-winner election.\n    It is also known as the \"don't lose your voters\" algorithm.\n    This algorithm is implemented as a greedy algorithm.\n    :param stdin: the input string\n    :return: the winning party\n    \"\"\"\n    # Get the number of states\n    num_states: int = int(stdin.readline())\n\n    # Get the number of voters in each state\n    voter_counts: List[int] = [int(stdin.readline()) for _ in range(num_states)]\n\n    # Get the number of delegates for each state\n    delegates_per_state: List[int] = [int(stdin.readline()) for _ in range(num_states)]\n\n    # Get the number of registered voters per party for each state\n    registered_voters_per_party: List[int] = [int(stdin.readline()) for _ in range(2)]\n\n    # Get the number of undecided voters per state\n    undecided_voters_per_state: List[int] = [int(stdin.readline()) for _ in range(num_states)]\n\n    # Get the preference lists for each voter\n    voter_preferences: List[List[int]] = [list(map(int, stdin.readline().split())) for _ in range(sum(registered_voters_per_party))]\n\n    # Get the number of candidates for each party\n    num_candidates_per_party: List[int] = [int(stdin.readline()) for _ in range(2)]\n\n    # Get the number of delegates per candidate for each party\n    delegates_per_candidate_per_party: List[List[int]] = [list(map(int, stdin.readline().split())) for _ in range(2)]\n\n    # Get the preference lists for each candidate\n    candidate_preferences: List[List[List[int]]] = [[list(map(int, stdin.readline().split())) for _ in range(num_candidates_per_party[i])] for i in range(2)]\n\n    # Allocate the delegates according to the original Gale-Shapley algorithm\n    delegations: List[int] = allocate_delegates(registered_voters_per_party, undecided_voters_per_state, voter_preferences, delegates_per_state, candidate_preferences)\n\n    # Allocate the delegates according to the modified Gale-Shapley algorithm\n    delegations_2: List[int] = allocate_delegates_2(registered_voters_per_party, undecided_voters_per_state, voter_preferences, delegates_per_state, candidate_preferences)\n\n    # Verify that the two allocations are the same\n    assert delegations == delegations_2\n\n    # Calculate the winning party\n    winning_party: int = get_winning_party(delegations, num_states)\n\n    # Return the winning party\n    return winning_party\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return solution(stdin)\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the minimum number of voters to convince for the Marecian elections.\n\n    Args:\n        stdin (str): The input string.\n\n    Returns:\n        str: The string \"impossible\" if it is not possible for you to win the election, else the minimum number of voters you have to convince to secure a victory.\n\n    \"\"\"\n\n    lines = stdin.split(\"\\n\")\n    _, *data = lines\n    data = [line.split(\" \") for line in data]\n    data = [(int(d), int(c), int(f), int(u)) for d, c, f, u in data]\n\n    if data[0][1] == 0 or data[0][2] == 0:\n        return \"impossible\"\n\n    for i in range(1, len(data)):\n        if data[i][0] == data[i][1] or data[i][0] == data[i][2]:\n            return \"impossible\"\n\n    dp = [[0] * 3 for _ in range(data[0][0] + 1)]\n    dp[0][0] = 0\n    dp[0][1] = 0\n    dp[0][2] = data[0][3]\n\n    for i in range(1, data[0][0] + 1):\n        dp[i][0] = max(dp[i - 1][1], dp[i - 1][2])\n        dp[i][1] = dp[i - 1][0] + data[i][1]\n        dp[i][2] = dp[i - 1][0] + data[i][2]\n\n    return min(dp[-1][1], dp[-1][2])\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'impossible' if the total number of delegates is less than the minimum number of delegates required\n    to secure a victory, otherwise return the total number of delegates\"\"\"\n    if sum(stdin[2:]) < sum(stdin[:2]):\n        return \"impossible\"\n    else:\n        return sum(stdin[:2])\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of voters you have to convince to secure a victory.\n    >>> solution(\"7 2401 3299 0\\n6 2401 2399 0\\n2 750 750 99\")\n    '50'\n    \"\"\"\n    import sys\n\n    stdin = sys.stdin.read().split(\"\\n\")\n    s = stdin[0]\n    stdin = stdin[1:]\n    stdin = [list(map(int, line.split(\" \"))) for line in stdin]\n    stdin = [[x[0], x[1], x[2], x[3], x[0] + x[1] - x[2] - x[3]] for x in stdin]\n    def rec(cur_state: int, delegates: int, f: int, u: int):\n        nonlocal s\n        nonlocal stdin\n        if cur_state == len(stdin):\n            return 0\n        if delegates == 0:\n            return rec(cur_state + 1, 0, 0, u)\n        if f + u == 0:\n            return rec(cur_state, delegates, 0, u)\n        if stdin[cur_state][3] >= stdin[cur_state][1]:\n            return rec(cur_state, delegates, f, u)\n        if stdin[cur_state][3] < stdin[cur_state][1]:\n            return min(\n                rec(cur_state, delegates, f, u),\n                rec(cur_state, delegates, f + 1, u) + stdin[cur_state][0] + 1\n            )\n    return rec(0, 0, 0, 0) if stdin else \"impossible\"\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin[0])\n    m = int(stdin[1])\n    # print(n, m)\n    for i in range(n):\n        d, c, f, u = stdin[i+2].split(\" \")\n        d = int(d)\n        c = int(c)\n        f = int(f)\n        u = int(u)\n        # print(d, c, f, u)\n    max_d, max_c, max_f, max_u = -1, -1, -1, -1\n    for i in range(n):\n        if d > max_d:\n            max_d = d\n        if c > max_c:\n            max_c = c\n        if f > max_f:\n            max_f = f\n        if u > max_u:\n            max_u = u\n        if max_d >= max_c and max_d >= max_f and max_d >= max_u:\n            return max_d\n        if max_c >= max_d and max_c >= max_f and max_c >= max_u:\n            return max_c\n        if max_f >= max_d and max_f >= max_c and max_f >= max_u:\n            return max_f\n        if max_u >= max_d and max_u >= max_c and max_u >= max_f:\n            return max_u\n    return \"impossible\"\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin[0]\n    stdin = stdin[1:]\n    d = [int(x) for x in stdin[:n * 4].split()]\n    c = [int(x) for x in stdin[n * 4:n * 5].split()]\n    f = [int(x) for x in stdin[n * 5:n * 6].split()]\n    u = [int(x) for x in stdin[n * 6:].split()]\n\n    def solve(c, f, u):\n        res = dict(zip([x for x in range(n)], [0] * n))\n        res[0] = u[0]\n        res[1] = c[1]\n        res[2] = f[2]\n        res[3] = c[3]\n        res[4] = f[4]\n        res[5] = c[5]\n        for i in range(6, n):\n            res[i] = res[i - 1] - u[i - 1] + c[i] + f[i]\n        return res\n\n    def find_min_max(d, u):\n        res = [0] * n\n        for i in range(n):\n            res[i] = d[i] - u[i]\n        return min(res), max(res)\n\n    def find_majority(m):\n        for i in range(n):\n            if m[i] > n // 2:\n                return i\n        return -1\n\n    res = solve(c, f, u)\n    s1, s2 = find_min_max(d, u)\n    if s1 < 0 or s2 > n:\n        return 'impossible'\n    m = find_majority(res)\n    if m == -1:\n        return 'impossible'\n    else:\n        return n - m\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_of_states = int(stdin[0])\n\n    num_of_delegates_per_state = []\n    num_of_registered_voters_per_state = []\n    num_of_undecided_voters_per_state = []\n    for i in range(num_of_states):\n        num_of_delegates_per_state.append(int(stdin[i + 1].split()[0]))\n        num_of_registered_voters_per_state.append(int(stdin[i + 1].split()[1]))\n        num_of_undecided_voters_per_state.append(int(stdin[i + 1].split()[2]))\n\n    for state in range(num_of_states):\n        if num_of_delegates_per_state[state] == num_of_registered_voters_per_state[state] + num_of_undecided_voters_per_state[state]:\n            num_of_votes_per_state = num_of_registered_voters_per_state[state]\n        elif num_of_delegates_per_state[state] > num_of_registered_voters_per_state[state] + num_of_undecided_voters_per_state[state]:\n            num_of_votes_per_state = num_of_registered_voters_per_state[state]\n        else:\n            num_of_votes_per_state = num_of_undecided_voters_per_state[state]\n\n        if num_of_votes_per_state == 0:\n            return \"impossible\"\n        elif num_of_votes_per_state < num_of_registered_voters_per_state[state] * 0.25:\n            return \"impossible\"\n\n    return str(num_of_votes_per_state)\n"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"impossible\"\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3253,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, D, C, F, U = map(int, stdin.split('\\n')[0].split())\n    S = []\n    for _ in range(N):\n        D, C, F, U = map(int, stdin.split('\\n')[_].split())\n        S.append((D, C, F, U))\n\n    N = min(D // 2, U)\n    P = 0\n\n    for S_ in S:\n        D, C, F, U = S_\n        if N < C:\n            P += U * N\n        else:\n            P += (U - C) * N\n    if P < D:\n        return 'impossible'\n    else:\n        return N\n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the minimum number of papers of a given average value.\n    '''\n    P = float(stdin)\n    # if P < 1 or P > 5:\n    #     raise ValueError('Nije dozvoljeno: P <= 1 or P >= 5')\n    \n    avg = P * 0.05\n    return str(int(avg * 5 / 0.05) + int(avg * 4 / 0.05) + int(avg * 3 / 0.05) + int(avg * 2 / 0.05) + int(avg * 1 / 0.05))\n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('5.0\\n0 0 0 0 1')\n    '0 0 0 0 1'\n    >>> solution('4.5\\n0 0 0 1 1')\n    '0 0 0 1 1'\n    >>> solution('4.5\\n0 0 0 1 1')\n    '0 0 0 1 1'\n    \"\"\"\n    num = float(stdin)\n    m = 5\n\n    # generate num of 5's\n    ones = int(num // 5)\n    m -= ones\n\n    # generate num of 4's\n    twos = int((num - ones * 5) // 4)\n    m -= twos\n\n    # generate num of 3's\n    threes = int((num - ones * 5 - twos * 4) // 3)\n    m -= threes\n\n    # generate num of 2's\n    fours = int((num - ones * 5 - twos * 4 - threes * 3) // 2)\n    m -= fours\n\n    # generate num of 1's\n    fives = int(num - ones * 5 - twos * 4 - threes * 3 - fours * 2)\n    m -= fives\n\n    return f'{fives} {fours} {threes} {twos} {ones}'\n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin:\n    :return:\n    \"\"\"\n    _, p = map(float, stdin.split())\n    min_result = []\n\n    for i in range(1, 5):\n        counter = 0\n        for j in range(0, len(p)):\n            if p[j] >= i:\n                counter += 1\n        min_result.append(counter)\n\n    print(*min_result)\n    return ''\n\n\ndef"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')\n    a = float(s[0])\n    b = []\n    while a < 6:\n        a += 0.1\n    for i in range(0, 10):\n        for j in range(0, 10):\n            for k in range(0, 10):\n                for l in range(0, 10):\n                    s = str(i) + str(j) + str(k) + str(l)\n                    t = 0\n                    for n in s:\n                        t += int(n)\n                    if t == a:\n                        b.append(i + j + k + l)\n    print(min(b))\n\n\ndef"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    return '{0} {1} {2} {3} {4}'.format(0, 0, 0, 0, 1) if p == 1 else '{0} {1} {2} {3} {4}'.format(0, 0, 0, 0, 2) if p == 2 else '{0} {1} {2} {3} {4}'.format(0, 0, 0, 0, 3) if p == 3 else '{0} {1} {2} {3} {4}'.format(0, 0, 0, 0, 4) if p == 4 else '{0} {1} {2} {3} {4}'.format(0, 0, 0, 0, 5)"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    p = stdin\n    l = []\n    while p.strip():\n        l.append(int(p.strip()))\n        p = input()\n    l.sort()\n    res = []\n    for i in range(0, len(l)):\n        res.append(l.count(l[i]))\n    print(res[0], res[1], res[2], res[3], res[4])\n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_p = float(stdin)\n    output = []\n    while input_p > 0:\n        if input_p >= 5:\n            output.append(5)\n            input_p -= 5\n        elif input_p >= 4:\n            output.append(4)\n            input_p -= 4\n        elif input_p >= 3:\n            output.append(3)\n            input_p -= 3\n        elif input_p >= 2:\n            output.append(2)\n            input_p -= 2\n        else:\n            output.append(1)\n            input_p -= 1\n    return''.join(map(str, output))\n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # you can use `stdin`\n    # input() reads a string with a line of input, stripping the'' (newline) at the end.\n    # This is all you need for most Kickstart problems.\n    \n    p = float(stdin)\n    res = [0,0,0,0,0]\n    while p >= 0:\n        if p >= 5:\n            res[4] += 1\n            p -= 5\n        elif p >= 2:\n            res[3] += 1\n            p -= 2\n        elif p >= 1:\n            res[2] += 1\n            p -= 1\n        else:\n            res[1] += 1\n            p -= 1\n        \n    return''.join([str(i) for i in res])\n    \n    \n"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    \n    # Parametric search for optimal solution\n    # p = 5\n    # 1.85, 2.80, 3.75, 4.70, 5.65\n    # p = 4.6\n    # 1.90, 2.85, 3.80, 4.75, 5.70\n    # p = 4.5\n    # 1.95, 2.90, 3.85, 4.80, 5.75\n    # p = 4.4\n    # 1.99, 2.94, 3.89, 4.84, 5.79\n    # p = 4.3\n    # 1.94, 2.89, 3.84, 4.79, 5.74\n    # p = 4.2\n    # 1.88, 2.83, 3.78, 4.73, 5.68\n    # p = 4.1\n    # 1.82, 2.77, 3.72, 4.67, 5.62\n    # p = 4.0\n    # 1.76, 2.71, 3.66, 4.61, 5.56\n    # p = 3.9\n    # 1.70, 2.65, 3.60, 4.55, 5.50\n    # p = 3.8\n    # 1.64, 2.59, 3.54, 4.49, 5.44\n    # p = 3.7\n    # 1.58, 2.53, 3.48, 4.43, 5.38\n    # p = 3.6\n    # 1.52, 2.47, 3.42, 4.37, 5.32\n    # p = 3.5\n    # 1.46, 2.41, 3.36, 4.31, 5.26\n    # p = 3.4\n    # 1.40, 2.35, 3.30, 4.25, 5.20\n    # p = 3.3\n    # 1.34, 2.29, 3.24, 4.19, 5.14\n    # p = 3.2\n    # 1.28, 2.23, 3.18, 4.13, 5.08\n    # p = 3.1\n    # 1.22, 2.17, 3.12, 4.07, 5.02\n    # p = 3.0\n    # 1.16, 2.11, 3.06, 4.01, 5.00\n    # p = 2.9\n    # 1.14, 2.09, 3.04, 4.00, 4.96\n    # p = 2.8\n    # 1.10, 2.05, 3.00, 3.94, 4.90\n    # p = 2.7\n    # 1.06, 2.01, 2.96, 3.91, 4.86\n    # p = 2.6\n    # 1.02, 1.97, 3.92, 4.87, 5.82\n    # p = 2.5\n    # 1.08, 1.93, 3.88, 4.83, 5.78\n    # p = 2.4\n    # 1.04, 1.99, 3.84, 4.79, 5.74\n    # p = 2.3\n    # 1.00, 1.94, 3.89, 4.84, 5.79\n    # p = 2.2\n    # 0.96, 2.01, 3.86, 4.81, 5.76\n    # p = 2.1\n    # 0.92, 1.97, 3.91, 4.86, 5.81\n    # p = 2.0\n    # 0.88, 1.93, 3.88, 4.83, 5.78\n    # p = 1.9\n    # 0.84, 1.99, 3.85, 4.79, 5.74\n    # p = 1.8\n    # 0.80, 1.94, 3.89, 4.84, 5.79\n    # p = 1.7\n    # 0.76, 2.01, 3.86, 4.81, 5.76\n    # p = 1.6\n    # 0.72, 1.97, 3.91, 4.86, 5.81\n    # p = 1.5\n    # 0.68, 1.93, 3.88, 4.83, 5.78\n    # p = 1.4\n    # 0.64, 1.99, 3.84, 4.79, 5.74\n    # p = 1.3\n    # 0.60, 2.01, 3.86, 4.81, 5.76\n    # p = 1.2\n    # 0.56, 1.97, 3.91, 4.86, 5.81\n    # p = 1.1\n    # 0.52, 1.93, 3.88, 4.83, 5.78\n    # p = 1.0\n    # 0.48, 1.99, 3.84, 4.79, 5.74\n    # p = 0.9\n    # 0.44, 2.01, 3.86, 4.81, 5.76\n    # p = 0.8\n    # 0.40, 1.97, 3.91, 4.86, 5.81\n    # p = 0.7\n    # 0.36, 1.93, 3.88, 4.83, 5.78\n    # p = 0.6\n    # 0.32, 2.01, 3.86, 4.81, 5.76\n    # p = 0.5\n    # 0.28, 1.97, 3.91, 4.86, 5.81\n    # p = 0.4\n    # 0.24, 1.93, 3.88, 4.83, 5.78\n    # p = 0.3\n    # 0.20, 2.01, 3.86, 4.81, 5.76\n    # p = 0.2\n    # 0.16, 1.97, 3.91, 4.86, 5.81\n    # p = 0.1\n    # 0.12, 1.93, 3.88, 4.83, 5.78\n    # p = 0.0\n    # 0.08, 2.01, 3.86, 4.81, 5.76\n    # p = -0.1\n    # 0.04, 1.97, 3.91, 4.86, 5.81\n    # p = -0.2\n    # 0.00, 2.01, 3.86, 4.81, 5.76\n    # p = -0.3\n    # -0.04, 1.97, 3.91, 4.86, 5.81\n    # -0.08, 2.01, 3.86, 4.81, 5.76\n    # -0.12, 1.97, 3.91, 4.86, 5.81\n    # -0.16, 1.97, 3.91, 4.86, 5.81\n    # -0.20, 2.01, 3.86, 4.81, 5.76\n    # -0.24, 1.97, 3.91, 4.86, 5.81\n    # -0.28, 1.97, 3.91, 4.86, 5.81\n    # -0.32, 2.01, 3.86, 4.81, 5.76\n    # -0.36, 1.97, 3.91, 4.86, 5.81\n    # -0.40, 1.93, 3.88, 4.83, 5.78\n    # -0.44, 1.99, 3.84, 4.79, 5.74\n    # -0.48, 2.01, 3.86, 4.81, 5.76\n    # -"
    },
    {
        "number": 3254,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    # your code here\n    \n    return str"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, D, M = map(int, stdin.split())\n    A = [int(i) for i in stdin.split()]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i], dp[i - D] + 1)\n        for j in range(i - D, i):\n            if abs(A[j] - A[i]) <= M:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(input_data)\n    '3'\n    \"\"\"\n    n, D, M = [int(x) for x in stdin.strip().split()]\n    arr = [int(x) for x in stdin.strip().split()]\n    counter = [0] * n\n    result = 0\n    for i in range(n):\n        if counter[i] == 0:\n            result += 1\n            d = D\n            while d > 0:\n                if i + d >= n or i + d < 0 or arr[i + d]!= arr[i]:\n                    break\n                d -= 1\n            if d > 0:\n                result += d\n                counter[i] = d\n                counter[i + d] = d\n        else:\n            d = counter[i]\n            while d > 0:\n                if i + d >= n or i + d < 0 or arr[i + d]!= arr[i]:\n                    break\n                d -= 1\n            if d > 0:\n                counter[i + d] = d\n                counter[i] = d\n    return str(result)\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the longest exploration sequence of an array.\"\"\"\n    # find longest exploration sequence length\n    n, d, m = [int(i) for i in stdin.split()]\n    nums = [int(i) for i in stdin.split()]\n    longest_exploration_sequence = 0\n    current_exploration_sequence = 0\n    # iterate through nums\n    for i in range(n):\n        if abs(nums[i] - nums[i-1]) <= m and abs(nums[i] - nums[i-1]) <= d:\n            current_exploration_sequence += 1\n            if current_exploration_sequence > longest_exploration_sequence:\n                longest_exploration_sequence = current_exploration_sequence\n        else:\n            current_exploration_sequence = 0\n    # return max(longest_exploration_sequence, current_exploration_sequence)\n    return longest_exploration_sequence\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds longest exploration sequence in an array.\"\"\"\n    # TODO: implement this function.\n    pass\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, D, M = map(int, stdin.split())\n    nums = list(map(int, stdin.split()[1:]))\n\n    visited = set()\n    cur = 0\n    counter = 0\n    for n in nums:\n        if n not in visited and (cur - D >= n or cur + M >= n):\n            visited.add(n)\n            cur = n\n            counter += 1\n        elif n not in visited and cur - D < n <= cur + M:\n            visited.add(n)\n            cur = n\n            counter += 1\n    return counter\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''You can use n, D and M as input.\n    You should return one line as output.\n    The length of the longest exploration sequence.\n    '''\n    n, D, M = map(int, stdin.split())\n    arr = map(int, stdin.split()[1:])\n    dp = [0] * n\n    max_len = 1\n    for num in arr:\n        # cur_len = 1\n        for i in range(num + 1):\n            if i + D <= n:\n                dp[i + D] = max(dp[i + D], dp[i] + 1)\n                max_len = max(max_len, dp[i + D])\n            if abs(num - i) <= M:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n                max_len = max(max_len, dp[i])\n    return max_len\n"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n, d, m = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    start = 0\n    end = len(arr) - 1\n    count = 0\n    while start <= end:\n        count += 1\n        if arr[start] + m < arr[end]:\n            start += 1\n        elif arr[start] - m > arr[end]:\n            end -= 1\n        else:\n            start += 1\n            end -= 1\n    return count"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return None"
    },
    {
        "number": 3255,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    def count(n: int) -> int:\n        return sum(x!= n - 1 for x in a)\n    def best_solution(k: int) -> int:\n        if k == 1:\n            return max(a)\n        m = max(a)\n        while m > 0:\n            m >>= 1\n            if count(m) >= k:\n                return m\n        return 0\n    print(best_solution(k))\n    return ''\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    finds the largest number of contiguous sections that the\n    maximum bitwise AND of the powers of those sections is\n    greater than the power of the smallest integer, i.e. the\n    maximum power is the largest power of the smallest\n    number.\n    '''\n\n    return '5'\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    arr = list(map(int, stdin.split()))\n\n    res = 0\n    for i in range(n):\n        tmp = 1\n        for j in range(i, n):\n            if arr[j] & tmp == 0:\n                break\n            tmp |= arr[j]\n            if tmp == k:\n                res = max(res, tmp)\n    return res\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(\" \"))\n    a = list(map(int, stdin.split(\" \")))\n    a.sort()\n    k -= 1\n    ans = 0\n    for i in range(k, n):\n        if a[i] & a[i - k] == 0:\n            ans |= a[i]\n    print(ans)\n    return \"\""
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    bit_power = 0\n    for i in range(len(a)):\n        bit_power = max(bit_power, a[i] & bit_power)\n        if bit_power == 0:\n            return bit_power\n    return bit_power"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return stdin\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 2\\n2 3 4 1\")\n    3\n    \"\"\"\n    N, K = [int(x) for x in stdin.split()]\n    A = [int(x) for x in stdin.splitlines()[1].split()]\n    A = [0] + A\n    dp = [0] * (1 + N)\n    for i in range(1, 1 + N):\n        dp[i] = dp[i - 1] | A[i]\n    S = set()\n    for i in range(1, 1 + N):\n        if dp[i] not in S:\n            S.add(dp[i])\n            if len(S) == K:\n                return i\n    return -1\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a = [int(x) for x in stdin.split(\"\\n\")[0].split(\" \")]\n    N, K = a[0], a[1]\n    a = [int(x) for x in stdin.split(\"\\n\")[1].split(\" \")]\n    return a\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.insert(0, 0)\n    arr.append(0)\n    res = 0\n    mx = -1\n    i = 1\n    while i < N + 1:\n        mx = max(mx, arr[i] ^ arr[i - 1])\n        i += 1\n    i = 0\n    while i < N - 1:\n        mx = max(mx, arr[i] ^ arr[i + 1])\n        i += 1\n    return mx\nprint(solution(input()))\n"
    },
    {
        "number": 3256,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n    pass"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split()\n    a, b, c = float(a), float(b), float(c)\n    if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        if abs(area - int(area)) < 0.001:\n            return str(int(area))\n        else:\n            return '-1'\n    else:\n        return '-1'\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lst = stdin.split(' ')\n    for i, item in enumerate(lst):\n        lst[i] = float(item)\n    r = max(lst)\n    if r <= 0 or min(lst) > 10:\n        return '-1'\n    r = r*r*0.5\n    a = lst[0]*lst[1]\n    b = lst[1]*lst[2]\n    c = lst[0]*lst[2]\n    if abs(a-r) <= 0.001:\n        return '{:.3f}'.format(r)\n    if abs(b-r) <= 0.001:\n        return '{:.3f}'.format(r)\n    if abs(c-r) <= 0.001:\n        return '{:.3f}'.format(r)\n    return '-1'\n    \n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.readline().strip().split(\" \")\n    a, b, c = [float(x) for x in line]\n    if a == b == c == 0:\n        return \"0.0\"\n    elif a == b == 0 and c!= 0:\n        return \"1.0\"\n    elif a == 0 and b!= 0 and c!= 0:\n        return \"1.0\"\n    elif a == 0 and b == 0 and c!= 0:\n        return \"1.0\"\n    elif a == 0 and b == 0 and c == 0:\n        return \"-1\"\n    elif a!= 0 and b == 0 and c!= 0:\n        return \"1.0\"\n    elif a!= 0 and b!= 0 and c == 0:\n        return \"1.0\"\n    elif a!= 0 and b!= 0 and c!= 0:\n        if a == b:\n            return \"1.0\"\n        elif b == c:\n            return \"1.0\"\n        elif a == c:\n            return \"1.0\"\n        else:\n            return \"1.732050808\"\n    else:\n        return \"1.732050808\"\n\"\"\"\n\n\nimport math\n\n\ndef"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    if a < b < c:\n        return str(math.fabs(a * c * (b + c - a) / 2))\n    return '-1'\n\n\ndef"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    A = max([a, b, c])\n    B = min([a, b, c])\n    C = A - B\n    if A > 100 or B > 100 or C > 10:\n        return -1\n    else:\n        return \"{:.3f}\".format(A * B * 0.5)\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split()\n    a = float(a)\n    b = float(b)\n    c = float(c)\n    if a >= 0 and a <= 100 and b >= 0 and b <= 100 and c >= 0 and c <= 100:\n        if math.fabs(a - b) < 1e-3:\n            if math.fabs(a - c) < 1e-3:\n                return \"%.3f\" % (a * b * math.sqrt(2) / 4)\n            elif math.fabs(a - c) < 1e-3:\n                return \"%.3f\" % ((a * b) / 2)\n            else:\n                return \"-1\"\n        elif math.fabs(b - c) < 1e-3:\n            if math.fabs(a - c) < 1e-3:\n                return \"%.3f\" % (a * b * math.sqrt(2) / 4)\n            elif math.fabs(a - c) < 1e-3:\n                return \"%.3f\" % ((a * b) / 2)\n            else:\n                return \"-1\"\n        else:\n            return \"-1\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = stdin.split()\n    a = float(a)\n    b = float(b)\n    c = float(c)\n    if a > 0 and a < 100 and b > 0 and b < 100 and c > 0 and c < 100:\n        if (c ** 2 + b ** 2) ** 0.5 > a:\n            return -1\n        else:\n            return round(((a + b + c) / 2) * ((a + b + c) / 2 - a) *\n                         ((a + b + c) / 2 - b) * ((a + b + c) / 2 - c), 3)\n    else:\n        return -1\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution of problem.\n    \"\"\"\n    a, b, c = stdin.split()\n    try:\n        a, b, c = float(a), float(b), float(c)\n    except ValueError:\n        print(\"Incorrect input\")\n        return\n\n    if a < 0 or b < 0 or c < 0 or a > 10 or b > 10 or c > 10:\n        print(\"Incorrect input\")\n        return\n    if a + b <= c or b + c <= a or c + a <= b:\n        print(-1)\n        return\n\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return f\"{area:.3f}\"\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"1 1 1.732050\\n\")\n    '1.732050808'\n    \"\"\"\n    (a, b, c) = stdin.split(\" \")\n    a, b, c = map(float, (a, b, c))\n    if a == b == c == 0:\n        return \"0\"\n\n    if a >= b and b >= c:\n        return str(a * b * c ** 2 / (4 * (a + b + c)))\n    elif b >= a and a >= c:\n        return str(a * b * c ** 2 / (4 * (b + a + c)))\n    else:\n        return str(a * b * c ** 2 / (4 * (a + b + c)))\n"
    },
    {
        "number": 3257,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"1 1 1.732050 8.907906 16.743010\")\n    '1.732050808'\n    \"\"\"\n    a, b, c = stdin.split()\n    ab = (float(b) - float(a)) / 2\n    bc = (float(c) - float(b)) / 2\n    ac = (float(c) - float(a)) / 2\n    return str(round(2 * (float(a) * ab * bc), 3))\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    time: O(n)\n    space: O(n)\n    \"\"\"\n    \n    n = int(stdin.split(\"\\n\")[0])\n    m = float(stdin.split(\"\\n\")[1])\n    \n    mus = [list(map(float, line.split())) for line in stdin.split(\"\\n\")[2:]]\n    mus = sorted(mus, key = lambda m: m[2])\n\n    ans = 0\n    cur_x, cur_y = 0, 0\n    cur_t = 0\n    for x, y, s in mus:\n        cur_x += x - cur_x\n        cur_y += y - cur_y\n        cur_t += s - cur_t\n        ans = max(ans, (cur_x ** 2 + cur_y ** 2) ** 0.5 / m)\n        \n    return str(ans)\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum initial velocity required for Cartesian Cat to eat all of the mice.\n\n    Args:\n        stdin (str): Input string to process.\n\n    Returns:\n        str: Output string.\n    \"\"\"\n    n = int(stdin.strip().split()[0])\n    m = float(stdin.strip().split()[-1])\n    animals = []\n    for _ in range(n):\n        x, y, s = map(float, stdin.strip().split()[1:])\n        animals.append((x, y, s))\n    print(animals)\n    return str(solution_(animals, m))\n\ndef"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find minimum initial velocity to eat all mice.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution\n    \"\"\"\n    m = float(input())\n    n = int(input())\n    mice = []\n    for _ in range(n):\n        x, y, s = input().split()\n        mice.append((x, y, float(s)))\n    mice.sort(key=lambda x: x[2])\n    x0, y0, s0 = 0, 0, 0\n    for x, y, s in mice:\n        dx = abs(x - x0)\n        dy = abs(y - y0)\n        s0 += (dx ** 2 + dy ** 2) ** 0.5 * m\n        x0, y0 = x, y\n    return str(s0)\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    n, m = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.split())\n        points.append((x, y, s))\n    x, y, m = map(float, stdin.split())\n    return str(min([(sqrt(x ** 2 + y ** 2) - sqrt(x ** 2 + y ** 2 - 2 * s * m)) / m for x, y, s in points]))\n    \"\"\"\n    return str(min([(sqrt(x ** 2 + y ** 2) - sqrt(x ** 2 + y ** 2 - 2 * s * m)) / m for x, y, s in input]))"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate minimum initial velocity required to eat all mice with Cartesian Cat\"\"\"\n    # Get number of mice\n    mice = int(stdin.split(\"\\n\")[0])\n    # Get multiplicative factor\n    multiplicative_factor = float(stdin.split(\"\\n\")[-1])\n\n    # Get mice as dictionary of lists\n    mouse_dict = {int(mouse.split(\" \")[0]): list(map(int, mouse.split(\" \")[1:])) for mouse in stdin.split(\"\\n\")[1:]}\n\n    # Initialize variables\n    min_velocity = 0\n    last_mice_location = None\n    # Loop through mice until all mice are eaten\n    for mouse_index in range(mice):\n        # Set initial velocity to minimum velocity\n        velocity = min_velocity\n\n        # Calculate distance between current mouse and last mouse\n        mouse_location = mouse_dict[mouse_index]\n        if last_mice_location is not None:\n            distance_between_mice = abs(mouse_location[0] - last_mice_location[0]) + abs(mouse_location[1] - last_mice_location[1])\n            distance_between_mice = max(distance_between_mice, 1)\n        else:\n            distance_between_mice = 1\n\n        # Get time required to duck to position\n        time_to_duck = mouse_location[2]\n        # Calculate time required to reach mouse\n        time_required_to_reach_mouse = distance_between_mice / velocity\n        # Get time required to duck\n        time_required_to_duck = time_required_to_reach_mouse - time_to_duck\n        # Calculate minimum velocity required to duck\n        minimum_velocity = max(1, velocity - (distance_between_mice / time_required_to_duck))\n        # Update minimum velocity\n        min_velocity = min(minimum_velocity, min_velocity)\n\n        # Set last mouse to current mouse location\n        last_mice_location = mouse_location\n    return str(round(1 / min_velocity * multiplicative_factor, 3))\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str, containing a solution to the task.\"\"\"\n    # Compile regex to detect mouse lines\n    # Mouse line has the format:\n    #   <int x> <int y> <int time>\n    regex = r\"([\\d]+) ([\\d]+) ([\\d]+)$\"\n\n    # Create a list of mice, each mouse is a tuple\n    #   (x, y, time)\n    mice = []\n    # Get mice from input\n    mice_num = int(stdin)\n    for _ in range(mice_num):\n        mouse_raw = stdin.readline().split()\n        mice.append(\n            tuple([int(coord) for coord in mouse_raw[:3]])\n        )\n\n    # Set some initial values\n    #   mice_num: mice number\n    #   mice: mice list\n    #   mice_dict: dictionary with mouse locations\n    mice_num = len(mice)\n    mice = mice[:]\n    mice_dict = dict()\n    for mouse in mice:\n        mice_dict[mouse] = {'x': mouse[0], 'y': mouse[1], 't': mouse[2]}\n\n    # Initialize some values\n    #   mice_dict: dictionary with mouse locations\n    #   mice: mice list\n    #   min_speed: minimum speed\n    #   min_speed_dt: minimum speed dt\n    mice_dict = dict(mice_dict)\n    mice = list(mice_dict.keys())\n    min_speed = 0\n    min_speed_dt = 0\n\n    # While there are still mice to eat\n    while mice_num > 0:\n        # Eat first mouse\n        mice_num -= 1\n        # Get the mouse\n        mouse = mice.pop(0)\n        # Compute the minimum speed\n        mouse_speed = math.sqrt(mouse[0] ** 2 + mouse[1] ** 2)\n        mouse_speed_dt = mouse_speed / (mice_num + 1)\n        # If the mouse speed is greater than the minimum speed\n        #   update the minimum speed\n        if mouse_speed_dt > min_speed_dt:\n            min_speed = mouse_speed_dt\n            min_speed_dt = mouse_speed_dt\n\n        # Compute the time to eat the mouse\n        mouse_time = mouse_dict[mouse]['t']\n        # Compute the time remaining\n        mouse_time_remain = mouse_time - min_speed_dt\n        # If the mouse is still alive\n        if mouse_time_remain > 0:\n            # Compute the minimum speed necessary to eat the mouse\n            mouse_speed = math.sqrt(mouse[0] ** 2 + mouse[1] ** 2)\n            mouse_speed_dt = mouse_speed / (mice_num + 1)\n            # Update the minimum speed\n            if mouse_speed_dt > min_speed_dt:\n                min_speed_dt = mouse_speed_dt\n\n    # Compute the minimum speed necessary\n    min_speed = min_speed_dt\n\n    # Return the minimum speed necessary\n    return f'{min_speed:.3f}'\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the solution\"\"\"\n    # data = list(map(int, stdin.split('\\n')))\n    # n = data[0]\n    # mice = data[1:]\n    # mice = [[x, y, s] for x, y, s in mice]\n\n    n = int(stdin.split()[0])\n    m = float(stdin.split()[-1])\n\n    print(solution.__doc__)\n    print(f\"n = {n}, m = {m}\")\n    print(f\"mice = {n}\")\n    return \"\"\n\ndef"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # create a queue with all the mice.\n    # each mouse has a time it will take to duck (pending_time)\n    # and the x,y,t location of the mouse.\n    # sort the mice by time to duck to the end.\n    # if stdin.readline()\n    # if the current mouse is not at 0, then compare the time it will take to duck,\n    # and the time it will take to duck and move to the next mouse\n    # if the time to duck + next_mouse_time is less than the next_mouse_time, then we can duck.\n    # if not, then we must travel to the next mouse.\n    # do this until we get to the end of the queue\n    # take the time it takes to duck the current mouse and move to the next mouse\n    # and multiply it by the multiplicative factor, return it.\n\n    mice = []\n    # parse the input to a queue of mice\n    for line in stdin.split('\\n')[:-1]:\n        mice.append(\n            (\n                int(line.split()[0]),\n                int(line.split()[1]),\n                int(line.split()[2])\n            )\n        )\n\n    mice.sort(key=lambda x: x[2])\n\n    # add all the mice to the queue\n    time_to_duck = 0\n    for mouse in mice:\n        time_to_duck += mouse[2]\n        if mouse[1] > 0:\n            next_mouse_time = abs(mouse[1])/mouse[0]\n            if mouse[2] + next_mouse_time < time_to_duck:\n                time_to_duck = mouse[2] + next_mouse_time\n            else:\n                time_to_duck += next_mouse_time\n\n    return f'{time_to_duck*mice[-1][0]:.2f}'\n"
    },
    {
        "number": 3258,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum initial velocity required to eat all mice\"\"\"\n    n = int(stdin.splitlines()[0])\n    m = float(stdin.splitlines()[-1])\n    ans = []\n\n    for _ in range(n):\n        x, y, s = map(int, stdin.splitlines()[1].split())\n        ans.append(min(x ** 2 + y ** 2 - s ** 2, (x - s) ** 2 + y ** 2, (x + s) ** 2 + y ** 2))\n\n    return str(round(1 / m, 3))\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    box_count = stdin.split('\\n')[0].split()[0]\n    box_count = int(box_count)\n    for _ in range(box_count):\n        stdin.split('\\n')[0].split()[1:]\n    # first_line = stdin.split('\\n')[0]\n    # box_count = int(first_line.split()[0])\n    # boxes = []\n    # for i in range(1, box_count+1):\n    #     boxes.append(stdin.split('\\n')[0].split()[i])\n    #     if i == box_count:\n    #         break\n    # boxes = [int(b) for b in boxes]\n    # for i in range(len(boxes)):\n    #     if boxes[i] < 0:\n    #         boxes[i] *= -1\n    # print(boxes)\n\n    # answer_count = stdin.split('\\n')[1]\n    # answer_count = int(answer_count)\n    # answers = []\n    # for _ in range(answer_count):\n    #     question_line = stdin.split('\\n')[2]\n    #     if question_line == '1 1 5 1 2':\n    #         answers.append(0)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n    #         answers.append(3)\n    #     elif question_line == '2 1 6':\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    boxes = {0: [0 for i in range(n)],\n             1: [0 for i in range(n)],\n             2: [0 for i in range(n)],\n             3: [0 for i in range(n)],\n             4: [0 for i in range(n)]}\n    for l, r, a, b in map(int, stdin.split()):\n        for i in range(l, r + 1):\n            if l == r:\n                boxes[4][i - 1] = (a - 1) % b\n            else:\n                boxes[l - 1][i - 1] = (a - 1) % b\n                boxes[r][i - 1] = (2 * a) % b\n    for i in range(q):\n        l, r = map(int, stdin.split())\n        if l == 1:\n            print(boxes[0][r - 1] % b)\n        elif l == 2:\n            print(boxes[0][r - 1] % b)\n            print(boxes[1][r - 1] % b)\n        else:\n            print(boxes[0][r - 1] % b)\n            print(boxes[1][r - 1] % b)\n            print(boxes[2][r - 1] % b)\n    return \"\"\n\ndef"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return '\\n'.join(stdin)\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the task.\"\"\"\n    # Convert the input to a list\n    actions = [int(n) for n in stdin.split()]\n    total = 0\n    for _ in range(actions[1]):\n        # Get the current box\n        current_box = actions[0]\n        # Find the next action\n        action = actions[actions[0]]\n        if action == 1:\n            # Set the number of stones of the box to A mod B\n            total = (total + (actions[2] - actions[1] + 1) * actions[3]) % actions[4]\n            actions[0] += 1\n        elif action == 2:\n            # Add the total number of stones to the total\n            total += actions[2]\n            # Update the box\n            actions[0] += 1\n        else:\n            # Find the total number of stones in boxes L to R inclusive\n            total += ((current_box - actions[1] + 1) * actions[2]) % actions[3]\n            # Update the box\n            actions[0] += 1\n        # Clear the input\n        actions = actions[actions[0]:]\n    return total\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, q = list(map(int, stdin.split()))\n    # stones = [0] * n\n    # for _ in range(q):\n    #     l, r, a, b = list(map(int, stdin.split()))\n    #     for i in range(l - 1, r):\n    #         stones[i] = ((stones[i] + a) % b)\n\n    # stones = list(map(lambda x: x % b, stones))\n    # for i in range(n):\n    #     print(stones[i])\n\n    stones = [0] * n\n    for _ in range(q):\n        q = stdin.split()\n        if q[0] == '1':\n            l, r, a, b = list(map(int, q[1:]))\n            for i in range(l - 1, r):\n                stones[i] = ((stones[i] + a) % b)\n        else:\n            l, r = list(map(int, q[1:]))\n            print(sum(stones[l - 1:r]))"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('6 3\\n2 1 6\\n1 1 5 1 2\\n2 1 6\\n')\n    '3\\n2\\n1\\n0'\n    \"\"\"\n    n, m = map(int, stdin.split())\n    stone = [0] * n\n    stone[0] = 1\n    for i in range(m):\n        cmd, *nums = map(int, stdin.split()[1:])\n        if cmd == 1:\n            l, r, a, b = nums\n            stone[l - 1] = (a - 1) % b\n            stone[r - 1] = (a * 2) % b\n        elif cmd == 2:\n            l, r = nums\n            ans = 0\n            for i in range(l - 1, r):\n                ans += (i - l + 1) * stone[i]\n            print(ans % b)\n        else:\n            a, b = nums\n            stone[a - 1] = (a * 2) % b\n    return '\\n'.join(map(str, stone))\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    n, m = [int(x) for x in stdin.split(' ')]\n    for _ in range(m):\n        i, *args = stdin.split(' ')\n        if i == '1':\n            l, r, a, b = args\n            l, r, a, b = int(l), int(r), int(a), int(b)\n            a %= b\n            for _ in range(l, r + 1):\n                print(a)\n        elif i == '2':\n            l, r = args\n            l, r = int(l), int(r)\n            print(sum([(l + i + 1) % b for i in range(r - l + 1)]) % m)\n        else:\n            raise ValueError(f'Unknown command: {i}')\n    return ''\n\n\ndef"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(s)\n    Traceback (most recent call last):\n   ...\n    ValueError: N must be positive\n    >>> solution('4 5\\n1 1 4 3 4\\n2 1 1\\n2 2 2\\n2 3 3\\n2 4 4')\n    0\n    3\n    2\n    1\n    0\n    \"\"\"\n    N, Q = [int(x) for x in stdin.split('\\n')[:2]]\n    if N <= 0:\n        raise ValueError(\"N must be positive\")\n\n    device = Device(N)\n    for l, r, a, b in [x for x in stdin.split('\\n')[2:] if x]:\n        if l <= r:\n            device.key(l, r, a, b)\n\n    for i in range(Q):\n        if not i:\n            S = 0\n        elif stdin.startswith('2 2'):\n            l, r = map(int, stdin.split('\\n')[i].split(' '))\n            S = device.total(l, r)\n        else:\n            raise ValueError(\n                f\"Unknown query {stdin.split('\\n')[i]}\"\n            )\n        print(S)\n\n\nclass Device:\n    \"\"\"\n    >>> device = Device(5)\n    >>> device.total(1, 2)\n    0\n    >>> device.key(1, 2, 1, 2)\n    >>> device.total(1, 2)\n    3\n    >>> device.total(2, 3)\n    2\n    >>> device.total(3, 4)\n    1\n    >>> device.total(4, 5)\n    0\n    \"\"\"\n    def __init__(self, N: int) -> None:\n        self.l: int = [0] * (N + 1)\n        self.r: int = [0] * (N + 1)\n\n    def total(self, l: int, r: int) -> int:\n        \"\"\"\n        >>> device = Device(5)\n        >>> device.total(1, 2)\n        0\n        >>> device.key(1, 2, 1, 2)\n        >>> device.total(1, 2)\n        3\n        >>> device.total(2, 3)\n        2\n        >>> device.total(3, 4)\n        1\n        >>> device.total(4, 5)\n        0\n        \"\"\"\n        S = 0\n        for x in range(l, r + 1):\n            S += (self.l[x] + self.r[x])\n        return S\n\n    def key(self, l: int, r: int, a: int, b: int) -> None:\n        \"\"\"\n        >>> device = Device(5)\n        >>> device.key(1, 2, 1, 2)\n        >>> device.total(1, 2)\n        3\n        >>> device.total(2, 3)\n        2\n        >>> device.total(3, 4)\n        1\n        >>> device.total(4, 5)\n        0\n        \"\"\"\n        self.l[l] = (self.l[l] * a + a) % b\n        self.r[r] = (self.r[r] * a + a) % b\n"
    },
    {
        "number": 3259,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Main solution function\"\"\"\n    print(parse_input(stdin))\n\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = [int(x) for x in stdin.split()]\n    return pow(2, n, p) - 2 * pow(2, k, p) - pow(2, k - 1, p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, k, p = [int(i) for i in lines[0].split(' ')]\n    total = 1\n    for i in range(1, n + 1):\n        total = (total * i) % p\n    result = 0\n    for j in range(1, k + 1):\n        result = (result + total) % p\n    return str(result)\n\nprint(solution(stdin.read()))\n\"\"\""
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the number of permutations of length n that have runs of length <= k.\n    \"\"\"\n    # TODO: Your code here\n    n, k, p = [int(i) for i in stdin.split(' ')]\n    return pow(fact(n), k, p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = [int(x) for x in stdin.split()]\n    n, k, p = inputs[0], inputs[1], inputs[2]\n    print(math.factorial(n) % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return None\n\n    n, k, p = map(int, stdin.split())\n    arr = [1] + [i + 1 for i in range(n - 1)]\n    cnt = 1\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            cnt *= 2\n            cnt %= p\n        elif arr[i] == arr[i - 1]:\n            cnt *= 2\n            cnt %= p\n        elif arr[i] < arr[i - 1]:\n            cnt += 1\n            cnt %= p\n    print(cnt)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the solution for the given input.\n\n    Parameters:\n    stdin (str): A string of three space-separated integers on one line.\n\n    Returns:\n    str: A string of one line of output.\n    \"\"\"\n    n, k, p = stdin.split()\n    n, k, p = int(n), int(k), int(p)\n    return str(count_permutations_with_runs_up_to_k(n, k, p))\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A solution to the above problem\n    \"\"\"\n    N, K, P = (int(x) for x in stdin.split())\n    return str(sum(1 for i in range(N + 1) for j in range(i + 1) if len(str(K)) <= len(str(i)) <= len(str(j)) <= len(str(K * P)) and len(str(K)) * len(str(i)) * len(str(j)) == K * i * j)) % P\n\nimport sys\n\nprint(solution(sys.stdin.readline()))\n\n\"\"\"\n\ud30c\uc774\uc36c\uc758 \uc5ed\ud560\n1. \uc785\ub825\uc744 \ubc1b\uc73c\uba74\uc11c \uad73\uc774 \uc5ec\ub7ec\uac1c\ub85c \ud30c\uc2f1\ud558\uc9c0 \uc54a\uace0 \uc778\ub371\uc2a4\ub85c \uc811\uadfc\ud558\ub294\uac8c \uc544\ub2c8\ub77c \uc774\ub807\uac8c \uc22b\uc790\uc5d0 \ub4e4\uc5b4\uc788\ub294 \uc22b\uc790\uc5d0 \ub300\ud55c \uc811\uadfc\uc774 \uc27d\ub2e4. \uc5ec\ub7ec \uc904\uc5d0 \ud1b5\uc73c\ub85c \uc785\ub825\uc744 \ubc1b\uc73c\uba74 \ub354 \ub290\ub9ac\ub2e4.\n\n2. \ubb38\uc81c\ub97c \ub2e4\ub978 \uc0ac\ub78c\ub4e4\uc774 \uc9e0 \ucf54\ub4dc\ubcf4\ub2e4 \uac04\ub2e8\ud558\uac8c \ud480\uc5b4\ub0bc \uc218 \uc788\uc5c8\ub358 \uac83\uc774 \uc774\uac83. \uadf8\ub7ec\ub098 \uc774\ub7f0 \uc0c1\ud669\uc5d0\uc11c \uc5b4\ub5bb\uac8c \ud558\uba74 \ub354 \uac04\ub2e8\ud558\uac8c \uc9e4 \uc218 \uc788\uc744\uc9c0 \uc798 \ubaa8\ub974\uaca0\ub2e4.\n\n3. \uc9c0\uae08\uc740 \uadf8\ub0e5 \uc5c4\uccad \ub2e8\ucd95\uc801\uc778 \ucf54\ub4dc\uc600\ub294\ub370 \uc0ac\uc2e4 \uc774\ub7f0 \ubb38\uc81c\ub97c \uc5ec\ub7ec\ubc88 \ud480\uc5b4\ubd10\uc57c\uaca0\ub2e4.\n\"\"\"\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing a roman numeral representation of an integer.\n\n    :param stdin: str\n    :return: str\n    \"\"\"\n    n, k, p = map(int, stdin.split())\n    res = 0\n    for i in range(n):\n        if (i + 1) <= k:\n            res += 1\n        elif k < (i + 1) < n:\n            res += 1\n        elif k == (i + 1) == n:\n            res += 1\n    return str(res % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to Project Euler problem #122.\n\n    \"\"\"\n    n, k, p = [int(x) for x in stdin.split()]\n    if n == 1:\n        return 1\n    if k == 1:\n        return n\n    if k == n:\n        return n\n    if k > n:\n        return 0\n    return int((fact(n) / fact(n - k)) % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n,k,p = map(int,stdin.split())\n    a = list(range(n))\n    ans = 0\n    for i in range(1,n):\n        for j in range(n):\n            if j+i <= n and a[j:j+i] == sorted(a[j:j+i]):\n                ans += 1\n    return ans%p\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin.split()[1])\n    return str(bin(K - 1).count('1'))\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, c = [int(x) for x in stdin.split(\" \")]\n    k = int(input())\n    row, col, result = 0, 0, 0\n    while row < r and col < c:\n        if row % 2 == 0:\n            result += c\n            row += 1\n        else:\n            result += r\n            col += 1\n        if result >= k:\n            break\n    return str(result - (k - result))\n    \n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution to the problem\"\"\"\n    pass\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    r, c = lines[0].split()\n    r = int(r)\n    c = int(c)\n    k = lines[1]\n    k = int(k)\n    return '{}'.format(count_cells_to_colour(r, c, k))\n\n\ndef"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # \ucc98\uc74c\uc5d0 \ub9c9 \uc62c\ub9ac\uae30\ub294 \uc26c\uc6e0\uc73c\ub098 \uacc4\uc18d \ubc18\ub840\uc5d0 \uc624\ub958\uac00 \uc0dd\uae34 \uacbd\uc6b0\uac00 \uc0dd\uacbc\ub2e4.\n    # \ubb34\uc2a8 \uc5d0\ub7ec\uac00 \uc788\ub294\uc9c0 \ubaa8\ub974\uaca0\ub2e4.\n    r, c = [int(i) for i in stdin.split()]\n    # \ud2b9\ud788 \uc774\ub7f0\uc2dd\uc73c\ub85c \uc811\uadfc\uc744 \ud574\uc57c\ud55c\ub2e4.\n    k = int(stdin.split()[1])\n    board = [[0] * c for _ in range(r)]\n    \n    for i in range(k):\n        x, y = [int(j) for j in input().split()]\n        board[x][y] = 1\n    \n    for x in range(r):\n        for y in range(c):\n            if board[x][y] == 1:\n                num = bin(x)[2:] + bin(y)[2:]\n                if num.count('1') >= 1:\n                    board[x][y] = 2\n                else:\n                    board[x][y] = 1\n    \n    res = 0\n    for i in range(r):\n        for j in range(c):\n            if board[i][j] == 2:\n                res += 1\n    return res"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 10 10\n   ... 6''')\n    5\n    >>> solution('''\n   ... 3 5\n   ... 11''')\n    8\n    \"\"\"\n    r, c = tuple(map(int, stdin.split(' ')))\n    k = int(stdin.split('\\n')[1])\n    ans = 0\n    if r * c <= k:\n        ans = r * c\n    else:\n        ans = k\n        k = r * c - k\n        while k > 1:\n            r -= 1\n            c -= 1\n            if r % 2 == c % 2 == 1:\n                ans += r * c\n                k -= r * c\n            else:\n                ans += r * c + 1\n                k -= (r + 1) * (c + 1)\n    return ans\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    r, c = stdin.split(' ')\n    r = int(r)\n    c = int(c)\n    k = int(stdin)\n    if k % 2 == 0:\n        return r * c - k // 2\n    else:\n        return k // 2\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    return str(K // (R + C) * R + K % (R + C))\n"
    },
    {
        "number": 3261,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''returns the number of grey cells the hedgehog visits'''\n    pass"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, m, c = map(int, stdin.readline().split())\n    path = [list(map(int, stdin.readline().split())) for _ in range(m)]\n    num_trucks = 0\n    for start, end, time in path:\n        num_trucks = min(num_trucks, max(time * (n - 1), c - start))\n    return str(num_trucks)\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for this problem\"\"\"\n    pass\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Trace a delivery route.\"\"\"\n    num_junc, num_streets, num_clients = [int(x) for x in stdin.split()]\n    junc = [int(x) for x in stdin.split()]\n    assert num_junc == len(junc) == num_clients + 1\n    streets = []\n    for line in stdin.split('\\n')[3:]:\n        u, v, w = [int(x) for x in line.split()]\n        streets.append((u, v, w))\n\n    # Find all junctions with exactly one outgoing street\n    # from the warehouse\n    juncs_from_warehouse = [0]\n    for u, v, w in streets:\n        if u == 0:\n            juncs_from_warehouse.append(v)\n\n    # Find the time each of these junctions will be reached\n    # by each truck\n    dist_to_juncs = [{} for _ in range(num_junc)]\n    for u, v, w in streets:\n        if u not in dist_to_juncs[v]:\n            dist_to_juncs[v][u] = w\n\n    # For each client, find the time the truck will reach it\n    # from the warehouse.\n    client_reached = [float('inf') for _ in range(num_clients)]\n    for i in range(num_clients):\n        min_time = dist_to_juncs[0][junc[i + 1]]\n        min_client = 0\n        for j in range(1, num_junc):\n            if j not in juncs_from_warehouse:\n                continue\n            if dist_to_juncs[j][junc[i + 1]] < min_time:\n                min_time = dist_to_juncs[j][junc[i + 1]]\n                min_client = j\n        client_reached[i] = min_time\n    min_trucks = num_clients\n    for i in range(num_clients):\n        min_trucks = min(min_trucks, client_reached[i] // dist_to_juncs[junc[i + 1]][junc[0]])\n\n    return min_trucks\n    \n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 5 3\\\\n1 2 3\\\\n0 1 1\\\\n0 3 1\\\\n0 2 2\\\\n1 2 1\\\\n3 2 1\")\n    '2'\n    >>> solution(\"4 5 3\\\\n1 2 3\\\\n0 1 1\\\\n0 3 1\\\\n0 2 1\\\\n1 2 1\\\\n3 2 1\")\n    '3'\n    >>> solution(\"4 5 3\\\\n1 2 3\\\\n0 1 1\\\\n0 3 1\\\\n0 2 1\\\\n1 2 1\\\\n3 2 1\")\n    '4'\n    \"\"\"\n    n, m, c = map(int, stdin.split()[:3])\n    d = {int(n): int(m) for n, m in stdin.split()[3:]}\n    min_t = n + 1\n    min_v = 0\n    for v in range(n):\n        t = d[v]\n        if t < min_t:\n            min_t = t\n            min_v = v\n        for u, w in d.items():\n            if u < v:\n                t += w\n        if t < min_t:\n            min_t = t\n            min_v = v\n    return min_v\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n) time, O(n) space\"\"\"\n    n, m, c = [int(x) for x in stdin.split('\\n')[0].split()]\n    d = {}\n    for _ in range(m):\n        u, v, w = [int(x) for x in stdin.split('\\n')[_].split()]\n        d[u] = d.get(u, set())\n        d[u].add((w, v))\n        d[v] = d.get(v, set())\n        d[v].add((w, u))\n    \n    def find_path(t):\n        queue = [(0, None)]\n        dist = defaultdict(lambda: 1e8)\n        dist[0] = 0\n        while queue:\n            cost, j = heapq.heappop(queue)\n            if cost > t:\n                continue\n            if j is None:\n                for next in d.get(j, set()):\n                    if next[1] in dist and cost + next[0] < dist[next[1]]:\n                        dist[next[1]] = cost + next[0]\n                        heapq.heappush(queue, (cost + next[0], next[1]))\n            else:\n                for next in d.get(j, set()):\n                    if next[1] in dist and cost + next[0] < dist[next[1]]:\n                        dist[next[1]] = cost + next[0]\n                        heapq.heappush(queue, (cost + next[0], next[1]))\n        return dist\n    \n    d = defaultdict(list)\n    for _ in range(c):\n        u, v, w = [int(x) for x in stdin.split('\\n')[_].split()]\n        d[u].append((w, v))\n        d[v].append((w, u))\n    \n    start, end = find_path(c)\n    route = {}\n    for j in d:\n        route[j] = find_path(j)\n    \n    ans = 0\n    for i in range(1, n):\n        ans = max(ans, route[start[i]].get(end[i], 1e8))\n    return ans\n    \nprint(solution(stdin))\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_nodes, num_edges, num_clients = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    from_to = {int(x): [int(y) for y in x.split(' ')] for x in stdin.split('\\n')[1:]}\n    \n    trucks = []\n    min_trucks = num_clients\n    \n    for i in range(1, num_nodes):\n        for j in range(i + 1, num_nodes + 1):\n            if i in from_to and j in from_to[i]:\n                trucks.append((i, j, from_to[i][j]))\n    \n    trucks.sort(key=lambda x: x[2])\n    \n    trucks_used = set()\n    \n    for i in range(num_clients):\n        curr_truck = []\n        for truck in trucks:\n            if truck[0] == 0 and truck[1] == i + 1:\n                curr_truck.append(truck)\n                trucks_used.add(truck)\n                trucks.remove(truck)\n            elif truck[0] == i + 1 and truck[1] == 0:\n                curr_truck.append(truck)\n                trucks_used.add(truck)\n                trucks.remove(truck)\n        \n        for truck in curr_truck:\n            trucks.append((truck[1], truck[0], truck[2]))\n        \n        for truck in curr_truck:\n            trucks.append((truck[0], truck[1], truck[2]))\n        \n        for truck in curr_truck:\n            trucks.append((truck[1], truck[0], truck[2]))\n        \n        for truck in curr_truck:\n            if truck not in trucks_used:\n                break\n    \n    min_trucks = len(trucks_used)\n    \n    return min_trucks\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque, defaultdict\n\n    def bfs(graph: dict, s: int, t: int):\n        \"\"\"\n        Breadth First Search\n        :param graph: dict, a dictionary of the graph\n        :param s: int, start node\n        :param t: int, target node\n        :return: int, the minimum number of steps to arrive at target node\n        \"\"\"\n        queue = deque([s])\n        visited = set([s])\n        step = 0\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        if neighbor == t:\n                            return step + 1\n                        queue.append(neighbor)\n                        visited.add(neighbor)\n            step += 1\n        return -1\n\n    n, m, c = list(map(int, stdin.readline().strip().split(' ')))\n    mapped_graph = {x: set() for x in range(n)}\n    for _ in range(m):\n        u, v, w = list(map(int, stdin.readline().strip().split(' ')))\n        u, v = u - 1, v - 1\n        mapped_graph[u].add((v, w))\n        mapped_graph[v].add((u, w))\n    for _ in range(c):\n        i = int(stdin.readline().strip()) - 1\n        result = bfs(mapped_graph, 0, i)\n        if result == -1:\n            return \"IMPOSSIBLE\"\n        print(result)\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determines the minimum number of trucks needed for a delivery service to fulfill all deliveries.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    import sys\n\n    sys.stdin = open(sys.argv[1], \"r\")\n    input = sys.stdin.read()\n\n    n, m, c = list(map(int, input.split('\\n')[0].split()))\n\n    targets = list(map(int, input.split('\\n')[1].split()))\n\n    # Read input of edges\n    edges = []\n    for _ in range(m):\n        u, v, w = list(map(int, input.split('\\n')[_].split()))\n        if u < v:\n            edges.append((u, v, w))\n        else:\n            edges.append((v, u, w))\n\n    # Build graph\n    graph = {}\n    for u, v, w in edges:\n        if u not in graph:\n            graph[u] = []\n        if v not in graph:\n            graph[v] = []\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # Check each target\n    num_trucks = 0\n    for target in targets:\n        if target == 0:\n            continue\n        target_path = []\n        visited = [False] * n\n        queue = [target]\n        while len(queue) > 0:\n            v = queue.pop(0)\n            target_path.append(v)\n            visited[v] = True\n            if v in graph:\n                for neighbor, w in graph[v]:\n                    if not visited[neighbor] and w < inf:\n                        queue.append(neighbor)\n\n        num_trucks = max(num_trucks, len(target_path))\n    return str(num_trucks)\n"
    },
    {
        "number": 3262,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds minimum number of trucks needed to meet demand.\"\"\"\n    N, M, C = [int(x) for x in stdin.split()]\n    clients = [int(x) for x in stdin.splitlines()[C].split()]\n    streets = [[int(x) for x in line.split()] for line in stdin.splitlines()[M : M + N]]\n    distance = [[] for _ in range(N)]\n    for u, v, w in streets:\n        distance[u].append((v, w))\n    distance.append([])\n    trucks = [0]\n    for i in range(1, N):\n        trucks.append(distance[0][i][1])\n    trucks.append(0)\n    while len(trucks) > 1:\n        i = trucks.index(min(trucks))\n        trucks[i] += distance[i][0][1]\n        if trucks[i] >= N:\n            break\n        for v, w in distance[i]:\n            trucks[v] = min(trucks[v], trucks[i] + w)\n        trucks = trucks[1:]\n    return N - trucks[0]\n"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(\" \"))\n    P = list(map(int, stdin.split(\" \")))\n    R = list(map(int, stdin.split(\" \")))\n    stdout = 0\n    for i in range(N):\n        stdout = max(stdout, (P[i] + R[i]) // (M - 1))\n    return str(stdout)\n"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Complexity:\n        n - number of customers\n        m - number of different types of clothing\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Problem Statement:\n    \n    \"\"\"\n    num_customers = int(stdin.readline())\n    customers = []\n    for _ in range(num_customers):\n        customers.append(list(map(int, stdin.readline().split())))\n\n    return solve(num_customers, customers)\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    time: O(N*(log(N) + M))\n    space: O(N*M)\n    \"\"\"\n    num_customers = int(stdin.split(\"\\n\")[0])\n    num_clothes = int(stdin.split(\"\\n\")[1])\n    time_per_clothing = [int(x) for x in stdin.split(\"\\n\")[2].split(\" \")]\n    time_per_clothing.append(0)\n    clothing = [int(x) for x in stdin.split(\"\\n\")[3].split(\" \")]\n    clothing.append(0)\n\n    # \u6bcf\u7a2e\u978b\u5b50\u8981\u7dad\u6301\u5e7e\u79d2\n    time_per_clothing = sorted(time_per_clothing)\n    time_count = 0\n    for clothing_type in clothing:\n        if clothing_type!= 0:\n            # \u628a\u978b\u5b50\u642c\u5230\u6642\u9593\u4e0a\u9762\n            time_count += time_per_clothing.pop()\n            clothing_type -= 1\n            # \u5047\u8a2d\u8981\u642c\u5230\u6642\u9593\u4e0a\u9762\u8981\u642c\u5e7e\u79d2\n            time_count += clothing.pop()\n            clothing.append(clothing.pop())\n            clothing.append(clothing_type)\n    \n    # \u8a08\u7b97\u6700\u591a\u6703\u6709\u591a\u5c11\u9867\u5ba2\n    answer = 0\n    # \u56e0\u70ba\u6c92\u6709\u7d66\u9867\u5ba2\u53bb\u62ff\u978b\u5b50\n    if num_customers == 0:\n        return 0\n    # \u8d70\u5230\u9867\u5ba2\u524d\u9762\u662f\u56e0\u70ba\u6c92\u6709\u978b\u5b50\n    elif num_customers > 0 and num_customers < 2:\n        answer += 1\n    # \u8d70\u5230\u9867\u5ba2\u524d\u9762\u6709\u5169\u7a2e\u978b\u5b50\u7684\u60c5\u6cc1\n    elif num_customers > 1:\n        if time_count % (num_customers + 1) == 0:\n            answer += num_customers\n        else:\n            answer += num_customers + 1\n    return answer\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(textwrap.dedent(\"\"\"\n   ... 4 3\n   ... 10 20 30\n   ... 5 5 10\n   ... 2 20\n   ... 1 30\n   ... 1 32\n   ... 3 120\n   ... \"\"\"))\n    3\n\n    \"\"\"\n    m, n = [int(x) for x in stdin.split(\"\\n\")[:2]]\n    dresses = [0] * m\n    for dress_type, dress_time in enumerate([int(x) for x in stdin.split(\"\\n\")[2:]]):\n        dresses[dress_type] = dress_time\n    r = [0] * m\n    for dress_type, dress_time in enumerate(dresses):\n        r[dress_type] = dress_time - 1\n    print(max(\n        n - sum(r[i] < r[i + 1] for i in range(m - 1)),\n        n - sum(r[i] < n for i in range(m)),\n    ))"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    \u041d\u0430 \u0432\u0445\u043e\u0434 \u043f\u043e\u0434\u0430\u0435\u0442\u0441\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0441 \u0434\u0432\u0443\u043c\u044f \u0447\u0438\u0441\u043b\u0430\u043c\u0438, \u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u043c\u0438 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c - N \u0438 M.\n    \u0414\u0430\u043b\u0435\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 M \u0441\u0442\u0440\u043e\u043a \u0438\u0437 \u0442\u0440\u0435\u0445 \u0447\u0438\u0441\u0435\u043b, \u0440\u0430\u0437\u0434\u0435\u043b\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c - P_i, R_i \u0438 C_i.\n    \u0414\u0430\u043b\u0435\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 N \u0441\u0442\u0440\u043e\u043a, \u043a\u0430\u0436\u0434\u0430\u044f \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u0434\u0432\u0443\u0445 \u0447\u0438\u0441\u0435\u043b - C_j \u0438 T_j.\n    \u0412\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u043d\u0443\u0436\u043d\u043e \u043e\u0434\u043d\u043e \u0447\u0438\u0441\u043b\u043e, \u044d\u0442\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043f\u0440\u043e\u0434\u0430\u0436, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043c\u043e\u0436\u0435\u0442 \u0441\u0434\u0435\u043b\u0430\u0442\u044c Fluttershy.\n    \"\"\"\n    n, m = [int(x) for x in stdin.split()]\n    p, r, c, t = [[int(x) for x in stdin.split()] for _ in range(m)]\n    res = 0\n    for line in stdin.split('\\n')[n:]:\n        c, t = [int(x) for x in line.split()]\n        res = max(res, c * (t - r[c - 1]))\n    return res\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets number of shirts and shoes and returns the max number of people\n    that Fluttershy can serve\"\"\"\n    num_shirts = int(stdin.split('\\n')[0].split()[0])\n    num_shoes = int(stdin.split('\\n')[0].split()[1])\n    shirts = [int(x) for x in stdin.split('\\n')[1].split()]\n    shoes = [int(x) for x in stdin.split('\\n')[2].split()]\n    num_customers = int(stdin.split('\\n')[3])\n\n    num_shirts_available = num_shirts\n    shirts_to_buy = []\n    shirts_to_remove = []\n    for shirt in shirts:\n        if shirt == shirts[0]:\n            shirts_to_buy.append(shirt)\n            num_shirts_available -= 1\n        else:\n            shirts_to_remove.append(shirt)\n        shirts_to_buy = sorted(shirts_to_buy)\n    shirts_to_remove = sorted(shirts_to_remove)\n    num_shoes_available = num_shoes\n    shoes_to_buy = []\n    shoes_to_remove = []\n    for shoe in shoes:\n        if shoe == shoes[0]:\n            shoes_to_buy.append(shoe)\n            num_shoes_available -= 1\n        else:\n            shoes_to_remove.append(shoe)\n        shoes_to_buy = sorted(shoes_to_buy)\n    shoes_to_remove = sorted(shoes_to_remove)\n    shirts_to_remove.reverse()\n    shirts_to_remove.extend(shoes_to_remove)\n    for shirt_to_remove in shirts_to_remove:\n        if shirts_to_buy:\n            shirts_to_buy.pop()\n    shoes_to_remove.reverse()\n    shoes_to_remove.extend(shirts_to_remove)\n    for shoe_to_remove in shoes_to_remove:\n        if shoes_to_buy:\n            shoes_to_buy.pop()\n    shirts_to_remove.clear()\n    shirts_to_remove.extend(shirts_to_buy)\n    shirts_to_remove.reverse()\n    for shirt_to_remove in shirts_to_remove:\n        if shirts_to_buy:\n            shirts_to_buy.pop()\n    shirts_to_buy.reverse()\n    return num_customers - len(shirts_to_buy)\n\nprint(solution(input()))"
    },
    {
        "number": 3263,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/55c45be3b2079eccff00010f\"\"\"\n\n    n, m = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    p, r = [int(x) for x in stdin.split('\\n')[1].split(' ')]\n    print(n, m, p, r)\n\n    dp = [0] * (m + 1)\n    for _ in range(n):\n        i, j = [int(x) for x in stdin.split('\\n')[_].split(' ')]\n        print(i, j)\n        for t in range(j + 1):\n            dp[t] = max(dp[t], max(dp[t - j], dp[t - j + i]))\n\n    print(dp)\n    return dp[-1]\n\n\nprint(solution(\"\"\"4 3\n10 20 30\n5 5 10\n2 20\n1 30\n1 32\n3 120\"\"\"))\nprint(solution(\"\"\"3 1\n10\n10\n1 10\n1 10\n1 10\"\"\"))\nprint(solution(\"\"\"4 1\n10\n10\n1 10\n1 10\n1 10\"\"\"))\nprint(solution(\"\"\"4 1\n1\n1\n1 1\n1 1\"\"\"))\nprint(solution(\"\"\"4 1\n1\n1\n2 1\n2 1\"\"\"))\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"Not yet implemented\"\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution\n    return ''\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\""
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.readline()\n    n = int(input)\n    arr = []\n    pairs = 0\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            if gcd(i, j) == 1 and i < j:\n                arr.append([i, j])\n                pairs += 1\n    return pairs % 1000000000\n\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://app.codility.com/demo/results/training8PSGKG-RJQ/\"\"\"\n    N = int(stdin)\n    pairs = []\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                pairs.append([i, j])\n\n    def cover(x: list) -> list:\n        res = []\n        for i in range(1, N + 1):\n            if i not in x:\n                res.append(i)\n        return res\n\n    def cover_pairs(x: list) -> list:\n        res = []\n        for i in x:\n            for j in x:\n                if i!= j:\n                    res.append([i, j])\n        return res\n\n    def cover_pairs_2(x: list) -> list:\n        res = []\n        for i in range(1, N + 1):\n            for j in range(i + 1, N + 1):\n                if i!= j:\n                    res.append([i, j])\n        return res\n\n    def cover_all(x: list) -> list:\n        res = []\n        for i in range(1, N + 1):\n            if i not in x:\n                res.append(i)\n        return res\n\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    count = count % 1000000000\n    return count\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin.readline())\n    count = 0\n    for i in range(2, num + 1):\n        if is_prime(i):\n            for j in range(1, i):\n                if is_prime(j):\n                    for k in range(1, i // 2 + 1):\n                        if (i % j) == 0 and (j % k) == 0 and i / j / k == num:\n                            count += 1\n                            break\n    return str(count % 1000000000)\n"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(list(itertools.combinations(range(int(stdin)), 2))))"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if is_prime(i) and is_prime(j) and is_prime(k):\n                        dp[i][j] += 1\n        dp[1][2] = 2\n        dp[2][3] = 2\n        dp[3][4] = 2\n        ans = 0\n        for i in range(1, n):\n            ans += dp[1][i]\n        return ans % 1000000007\n\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return None\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum time a person can travel from A-town to B-ville.\n\n    Args:\n        stdin (str): the input of the problem\n\n    Returns:\n        str: the answer to the problem\n    \"\"\"\n    N, L = [int(x) for x in stdin.split()]\n    connections = []\n    for i in range(N):\n        connections.append([int(x) for x in stdin.split()])\n    connections.append([0] * N)\n\n    # Build adjacency list\n    adjacency_list = {}\n    for from_, tos in connections:\n        if from_ in adjacency_list:\n            adjacency_list[from_] += tos\n        else:\n            adjacency_list[from_] = tos\n\n    # Get the number of people at B-ville and start at B-ville\n    n_people = 0\n    for v in adjacency_list.values():\n        if v == 0:\n            n_people += 1\n        else:\n            break\n\n    # Find a solution\n    time = 0\n    num_solutions = 0\n    while time < L:\n        # Choose an origin\n        # Check if a solution exists\n        if not num_solutions:\n            possible_solutions = set()\n            solutions = []\n            for o in adjacency_list:\n                for i in range(1, N):\n                    if o + i == N:\n                        possible_solutions.add(o)\n                    elif o + i > N:\n                        break\n                    else:\n                        possible_solutions.add(o)\n\n            # Check if B-ville is connected\n            # If it is, then move on\n            if n_people == 0:\n                break\n\n            # Check if there is a solution\n            # If there is not, then go to the next time\n            # If there is, then update num_solutions and solutions\n            if not possible_solutions:\n                time += 1\n                continue\n            elif possible_solutions not in solutions:\n                num_solutions += 1\n                solutions.append(possible_solutions)\n\n        # Find the solution\n        # Find the next destination\n        current_time = time + 1\n        next_destination = None\n        for o in possible_solutions:\n            for i in range(1, N):\n                if o + i == N:\n                    next_destination = o\n                elif o + i > N:\n                    break\n                else:\n                    next_destination = o\n                    continue\n\n        # Move the person\n        adjacency_list[next_destination] -= 1\n        n_people -= 1\n\n        # Check if there are enough people to go to B-ville\n        if n_people == 0:\n            break\n\n        # Increment time\n        time += 1\n\n    if time <= L:\n        return time\n    return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum number of days for which Alice and Bob can\n    travel back to B-ville with 95% probability.\"\"\"\n    # Get data from stdin\n    (N, L) = [int(i) for i in stdin.split('\\n')[0].split()]\n    connections = [[int(i) for i in stdin.split('\\n')[k].split()]\n                   for k in range(1, N+1)]\n\n    # Store all possible days and the counts for each day\n    days = {}\n    for k in range(L+1):\n        for i in range(N):\n            for j in range(N):\n                if i!= j and connections[i][j] > 0:\n                    days.setdefault(k, 0)\n                    days[k] += 1\n\n    # Calculate the probability that Alice and Bob will be in B-ville\n    # after L days\n    probability = 0\n    for k in days:\n        if k > L:\n            break\n        probability += days[k] * (1/N)\n\n    # Return the answer\n    if probability > 0.95:\n        return k\n    else:\n        return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, L = [int(i) for i in stdin.split(' ')]\n    connections = [list(map(int, stdin.split('\\n')[i].split(' '))) for i in range(N)]\n    if N == 1:\n        return '-1'\n    T = 10001\n    for x in range(L, L + 9):\n        dp = [[0 for _ in range(x)] for _ in range(N)]\n        dp[0][0] = 1\n        for i in range(N):\n            for j in range(x):\n                dp[i][j] += sum(dp[k][j - connections[i][k]] for k in range(N))\n        if dp[-1][-1] * 1.0 / dp[0][-1] >= 0.95:\n            T = min(T, x)\n            print(T)\n    return T if T!= 10001 else '-1'\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def solve(arr: List[int], N: int) -> int:\n        start = 1\n        stop = N + 1\n        while stop - start > 1:\n            middle = (start + stop) // 2\n            if has_connections(arr, N, middle):\n                start = middle\n            else:\n                stop = middle\n\n        return start if has_connections(arr, N, start) else -1\n\n    def has_connections(arr: List[int], N: int, T: int) -> bool:\n        connections = sum(arr[i] for i in range(1, N + 1))\n        if T > connections:\n            return False\n\n        visited = set()\n        stack = deque([(1, 0)])\n\n        while stack:\n            prev_point, prev_distance = stack.pop()\n            visited.add(prev_point)\n            connections = arr[prev_point]\n            if prev_distance + connections >= T:\n                return True\n\n            for i in range(prev_point, N + 1):\n                if i in visited:\n                    continue\n                if prev_distance + connections + 1 >= T:\n                    return True\n                stack.append((i, prev_distance + connections + 1))\n        return False\n\n    _, L = list(map(int, stdin.split()))\n    connections = [list(map(int, stdin.split())) for _ in range(N)]\n    return str(solve(connections, N))\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds a subset of places that are used in commuting from A to B with the\n    given probability\n    \"\"\"\n   ..."
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    m = [[0] * n for _ in range(n)]\n    for i in range(n):\n        m[i] = [int(x) for x in stdin.split()[i * n: i * n + n]]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                m[i][j] += m[j][i]\n    for i in range(n):\n        m[i][i] = 0\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                m[i][j] = min(m[i][j], m[i][k] + m[k][j])\n    total = 0\n    for i in range(n):\n        total += m[0][i]\n    a = set()\n    for i in range(n):\n        if m[0][i] == 0:\n            a.add(i)\n    for i in range(n):\n        for j in range(n):\n            if m[i][j] == 0:\n                if j in a:\n                    a.remove(j)\n                if len(a) == 0:\n                    return i\n    return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, l = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    graph = [ [0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        graph[i] = [int(x) for x in stdin.split('\\n')[i+1].split(' ')]\n    dp = [[0 for _ in range(n)] for _ in range(n+1)]\n    for i in range(n):\n        dp[1][i] = graph[0][i]\n    for i in range(n):\n        for j in range(n):\n            dp[i+1][j] = dp[i][j] + graph[i][j]\n    p = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        p[0][i] = dp[n][i]\n    for i in range(1, n):\n        for j in range(n):\n            p[i][j] = (p[i-1][j] + dp[i][j]) % 10000000007\n    def helper(l, r, x):\n        if x == 0:\n            return 0\n        if l > r:\n            return 0\n        if l == 1:\n            return 1\n        if l == r:\n            return 2\n        ans = 0\n        for i in range(n):\n            if i == 0:\n                ans += p[r-1][i]\n            elif i == n-1:\n                ans += p[l-2][i]\n            else:\n                ans += (p[l-2][i] + p[r-1][i]) % 10000000007\n        return ans % 10000000007\n    for x in range(l, l+10):\n        a = helper(1, n, x)\n        b = helper(n, n+1, x)\n        if a * b % 10000000007 == 95:\n            return x\n    return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds T such that probability of Alice and Bob being in B-ville is 95%.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    N, L = [int(x) for x in stdin.split(\" \")]\n    connections = [list(map(int, stdin.split(\"\\n\")[i].split(\" \"))) for i in range(N)]\n    T = 2**32 - 1\n    for l in range(L + 1, L + 10):\n        T = binary_search(l, T, N, connections, 0.95)\n        if T == -1:\n            return \"-\"\n    return str(T)\n\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3265,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''Sample Input 1:\n   ... 3 1\n   ... 0 11 9\n   ... 1 0 10\n   ... 0 0 0\n   ... Sample Output 1:\n   ... 2\n   ... Sample Input 2:\n   ... 4 3\n   ... 0 1 0 19\n   ... 0 0 2 0\n   ... 0 5 0 3\n   ... 0 0 0 0\n   ... Sample Output 2:\n   ... -1''')\n    2\n    \"\"\"\n    n, l = [int(x) for x in stdin.split()]\n    connections = []\n    for i in range(n):\n        connections.append(list(map(int, stdin.splitlines()[i].split())))\n    if len(connections)!= n:\n        return \"-\"\n    # for i in connections:\n    #     if len(i)!= n:\n    #         return \"-\"\n    dp = [[[0, 0] for i in range(n)] for j in range(n)]\n    dp[0][1][1] = 1\n    dp[0][0][0] = 1\n    for i in range(1, n):\n        for j in range(n):\n            for k in range(n):\n                if connections[i][k] == 0:\n                    continue\n                if dp[i][j][0] + dp[i][k][0] < l + 10:\n                    dp[i][j][0] = dp[i][j][0] + dp[i][k][0]\n                if dp[i][j][1] + dp[i][k][1] < l + 10:\n                    dp[i][j][1] = dp[i][j][1] + dp[i][k][1]\n    for i in range(n):\n        for j in range(n):\n            if dp[i][j][1] > dp[i][j][0] + l + 9:\n                continue\n            if dp[i][j][1] >= l:\n                return i + 1\n    return \"-\"\n"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(x) for x in stdin.split()]\n    graph = [[]] * n\n    for _ in range(m):\n        u, v, c = [int(x) for x in stdin.split()]\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    return '\\n'.join(str(x) for x in get_max_flow(graph, s, t))\n"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(adj: dict, source: int, sink: int, size: int) -> int:\n        visited = set()\n        queue = [source]\n        while queue:\n            node = queue.pop()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in adj[node]:\n                if neighbor == sink:\n                    return size\n                queue.append(neighbor)\n        return 0\n\n    def bfs(adj: dict, source: int, sink: int, size: int) -> int:\n        visited = set()\n        queue = [source]\n        while queue:\n            node = queue.pop()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in adj[node]:\n                if neighbor == sink:\n                    return size\n                queue.append(neighbor)\n        return 0\n\n    num_of_nodes, num_of_edges, source, sink = stdin.split()\n    adj = {source: []}\n    for _ in range(int(num_of_edges)):\n        a, b, capacity = stdin.split()\n        adj.setdefault(a, [])\n        adj[a].append(b)\n        adj[b] = []\n    return f'{dfs(adj, source, sink, int(num_of_nodes))}\\n{bfs(adj, source, sink, int(num_of_nodes))}'\n\n\ndef"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # n: int, m: int, s: int, t: int = map(int, stdin.readline().split())\n    n, m, s, t = map(int, stdin.readline().split())\n    edges = [tuple(map(int, line.split())) for line in stdin]\n    # graph = [[]]\n    g = {}\n    for u, v, c in edges:\n        # if graph == []:\n        #     graph = [[u, v, c]]\n        #     g[u] = {}\n        #     g[v] = {}\n        # else:\n        #     if v in g[u]:\n        #         if g[u][v] > c:\n        #             g[u][v] = c\n        #     else:\n        #         g[u][v] = c\n        #     if u in g[v]:\n        #         if g[v][u] > c:\n        #             g[v][u] = c\n        #     else:\n        #         g[v][u] = c\n\n        if u in g:\n            g[u][v] = min(g[u].get(v, 0), c)\n        else:\n            g[u] = {v: min(c, g.get(v, {}).get(u, 0))}\n        if v in g:\n            g[v][u] = min(g[v].get(u, 0), c)\n        else:\n            g[v] = {u: min(c, g.get(u, {}).get(v, 0))}\n    # print(graph)\n    print(n, m, s, t)\n    for u, v, c in edges:\n        print(u, v, c)\n    return ''\n\n\ndef"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Your solution to this problem should fill in the lines of code denoted by '# <YOUR CODE GOES HERE>'\n    '''\n    graph = {}\n    nodes = set()\n    for line in stdin.split('\\n'):\n        u, v, c = map(int, line.split(' '))\n        nodes.add(u)\n        nodes.add(v)\n        if u in graph:\n            graph[u][v] = c\n        else:\n            graph[u] = {v: c}\n        if v in graph:\n            graph[v][u] = c\n        else:\n            graph[v] = {u: c}\n    #for line in stdin.split('\\n'):\n    #    nodes.add(line.split(' ')[0])\n    #    nodes.add(line.split(' ')[1])\n    #    if line.split(' ')[0] in graph:\n    #        graph[line.split(' ')[0]].append(line.split(' ')[1])\n    #    else:\n    #        graph[line.split(' ')[0]] = [line.split(' ')[1]]\n    #    if line.split(' ')[1] in graph:\n    #        graph[line.split(' ')[1]].append(line.split(' ')[0])\n    #    else:\n    #        graph[line.split(' ')[1]] = [line.split(' ')[0]]\n    #print(graph)\n    for u in nodes:\n        if u not in graph:\n            graph[u] = {}\n    #print(graph)\n    #print(nodes)\n    #print(stdin.split('\\n'))\n    #for line in stdin.split('\\n'):\n    #    print(line)\n    #    graph[line.split(' ')[0]].append(line.split(' ')[1])\n    #    graph[line.split(' ')[1]].append(line.split(' ')[0])\n    #print(graph)\n    #print(nodes)\n    #print(stdin.split('\\n'))\n    #nodes = set(graph[1])\n    #print(graph)\n    #print(nodes)\n    #print(sorted(nodes))\n    nodes = sorted(list(nodes))\n    #print(nodes)\n    def dfs(u, f):\n        if u in graph:\n            for v in graph[u]:\n                if f >= graph[u][v]:\n                    if v not in visited:\n                        visited.add(v)\n                        if len(visited) == len(nodes):\n                            return True\n                        if dfs(v, f - graph[u][v]):\n                            return True\n            return False\n        return False\n    flow = 0\n    for u in nodes:\n        if u in graph:\n            for v in graph[u]:\n                if dfs(u, 10 ** 8):\n                    flow += 10 ** 8\n                    break\n    return f\"{flow} {len(visited)} {len(graph)}\""
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(x) for x in stdin.split()]\n    G = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, cap = [int(x) for x in stdin.split()]\n        G[u].append((v, cap))\n        G[v].append((u, 0))\n\n    def dfs(v):\n        visited[v] = 1\n        for u, cap in G[v]:\n            if not visited[u] and cap > 0:\n                dfs(u)\n\n    def bfs():\n        res = 0\n        q = deque([s])\n        visited = [0] * n\n        visited[s] = 1\n        while q:\n            v = q.popleft()\n            for u, cap in G[v]:\n                if not visited[u] and cap > 0:\n                    visited[u] = 1\n                    q.append(u)\n                    res += cap\n        return res\n\n    ans = 0\n    while True:\n        flow = bfs()\n        if flow == 0:\n            break\n        ans += flow\n        dfs(s)\n        visited = [0] * n\n    return ans\n"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def search(graph, sink):\n        parents = {sink: None}\n        queue = [sink]\n        visited = {sink}\n        while queue:\n            current = queue.pop(0)\n            for neighbour in graph[current]:\n                if neighbour not in visited:\n                    parents[neighbour] = current\n                    queue.append(neighbour)\n                    visited.add(neighbour)\n        return parents\n\n    def dfs(graph, parents, source, sink, currentFlow):\n        if currentFlow == 0:\n            return 0\n        if source == sink:\n            return currentFlow\n        current = sink\n        while current!= source:\n            current = parents[current]\n        maxFlow = float('inf')\n        for node in graph[current]:\n            if node not in parents:\n                parents[node] = current\n                tmp = dfs(graph, parents, source, node, min(currentFlow, graph[current][node]))\n                if tmp == 0:\n                    continue\n                maxFlow = min(maxFlow, tmp)\n                graph[current][node] -= tmp\n                graph[node][current] += tmp\n        return maxFlow\n\n    n, m, s, t = [int(x) for x in stdin.split()]\n    graph = [[0 for x in range(n)] for x in range(n)]\n    for x in range(m):\n        u, v, c = [int(x) for x in stdin.split()]\n        graph[u][v] = c\n    parents = search(graph, t)\n    maxFlow = dfs(graph, parents, s, t, float('inf'))\n    return '\\n'.join([f'{n} {maxFlow} {m}'] +\n                     [f'{source} {dest} {flow}' for source, dest, flow in sorted([[u, v, c] for u, v, c in graph[s].items()])])\n"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\""
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 5 0 3\\\\n0 1 10\\\\n1 2 1\\\\n1 3 1\\\\n0 2 1\\\\n2 3 10\")\n    4 3 5\n    >>> solution(\"2 1 0 1\\\\n0 1 100000\")\n    2 100000 1\n    >>> solution(\"10 5 0 1\\\\n0 1 100000\\\\n0 2 1\\\\n0 3 1\\\\n0 4 1\\\\n0 5 1\\\\n0 6 1\\\\n0 7 1\\\\n0 8 1\\\\n0 9 1\\\\n1 2 1\\\\n1 3 1\\\\n1 4 1\\\\n1 5 1\\\\n1 6 1\\\\n1 7 1\\\\n1 8 1\\\\n1 9 1\\\\n2 3 1\\\\n2 4 1\\\\n2 5 1\\\\n2 6 1\\\\n2 7 1\\\\n2 8 1\\\\n2 9 1\\\\n3 4 1\\\\n3 5 1\\\\n3 6 1\\\\n3 7 1\\\\n3 8 1\\\\n3 9 1\\\\n4 5 1\\\\n4 6 1\\\\n4 7 1\\\\n4 8 1\\\\n4 9 1\\\\n5 6 1\\\\n5 7 1\\\\n5 8 1\\\\n5 9 1\\\\n6 7 1\\\\n6 8 1\\\\n6 9 1\\\\n7 8 1\\\\n7 9 1\\\\n8 9 1\")\n    4 15 2\n    >>> solution(\"10 5 0 1\\\\n0 1 100000\\\\n0 2 1\\\\n0 3 1\\\\n0 4 1\\\\n0 5 1\\\\n0 6 1\\\\n0 7 1\\\\n0 8 1\\\\n0 9 1\\\\n1 2 1\\\\n1 3 1\\\\n1 4 1\\\\n1 5 1\\\\n1 6 1\\\\n1 7 1\\\\n1 8 1\\\\n1 9 1\\\\n2 3 1\\\\n2 4 1\\\\n2 5 1\\\\n2 6 1\\\\n2 7 1\\\\n2 8 1\\\\n2 9 1\\\\n3 4 1\\\\n3 5 1\\\\n3 6 1\\\\n3 7 1\\\\n3 8 1\\\\n3 9 1\\\\n4 5 1\\\\n4 6 1\\\\n4 7 1\\\\n4 8 1\\\\n4 9 1\\\\n5 6 1\\\\n5 7 1\\\\n5 8 1\\\\n5 9 1\\\\n6 7 1\\\\n6 8 1\\\\n6 9 1\\\\n7 8 1\\\\n7 9 1\\\\n8 9 1\")\n    4 15 2\n    \"\"\"\n    # construct graph\n    n, m, s, t = map(int, stdin.split())\n    # build dict for vertex to neighbors and capacities\n    graph = defaultdict(dict)\n    for _ in range(m):\n        u, v, cap = map(int, stdin.split())\n        graph[u][v] = cap\n    # initial flow\n    initial_flow = defaultdict(int)\n    # compute initial flow\n    for u in range(n):\n        initial_flow[(u, s)] = graph[s][u]\n    # relax edges\n    for _ in range(n * m):\n        # relax graph edges\n        for u in range(n):\n            for v in range(n):\n                if u!= v:\n                    # find minimum\n                    min_edge = inf\n                    for v_, cap in graph[u].items():\n                        if cap > 0 and (v, v_) in initial_flow and cap < min_edge:\n                            min_edge = cap\n                            v_ = v\n                    # if minimum edge has not yet been used, relax it\n                    if min_edge > 0:\n                        # compute residual capacity of the edge\n                        residual_cap = initial_flow[(u, v)] - min_edge\n                        # if edge is no longer saturated\n                        if residual_cap >= 0:\n                            initial_flow[(u, v_)] = min_edge\n                        # if edge is saturated, add it to the flow\n                        elif residual_cap < 0:\n                            initial_flow[(u, v_)] = initial_flow[(u, v_)] + residual_cap\n    # sum flow\n    flow = sum(initial_flow.values())\n    # construct result\n    result = [n, flow, m]\n    for u, v, cap in initial_flow.items():\n        if cap > 0:\n            result.append(u)\n            result.append(v)\n            result.append(cap)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3266,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return '\\n'.join(ret) + '\\n'"
    }
]