[
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # insert your code here\n    return stdin"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    res = 0\n    for _ in range(n):\n        num_str = stdin.split(' ')\n        if num_str[0] == '(':\n            bracket_list = []\n            index = num_str.index(')')\n            if index == len(num_str) - 1:\n                res += int(num_str[1])\n            else:\n                for i in range(len(num_str)):\n                    if num_str[i] == '(':\n                        bracket_list.append(num_str[i])\n                    if num_str[i] == ')':\n                        if bracket_list[-1] == '(':\n                            bracket_list.pop()\n                            res += int(num_str[i + 1])\n                        else:\n                            bracket_list.pop()\n            num_str.pop(0)\n            num_str.pop(index)\n            num_str.pop(index)\n            num_str = bracket_list + num_str\n        else:\n            res += int(num_str[0])\n    return str(res % (10 ** 9 + 7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    while not stdin.isdigit():\n        stdin = stdin[1:-1]\n    n = int(stdin)\n    \n    return \"\".join(n)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = stdin.split('\\n')[1].split()\n    bracket_sequence = ''\n    for number in numbers:\n        if number == '(':\n            bracket_sequence += number\n        elif number == ')':\n            bracket_sequence = bracket_sequence[:len(bracket_sequence) - 1] + number + bracket_sequence[len(bracket_sequence) - 1:]\n        else:\n            bracket_sequence += number +''\n    # print(bracket_sequence)\n    i = 1\n    while i < len(bracket_sequence):\n        if bracket_sequence[i] == '(':\n            temp_i = bracket_sequence.find(')', i)\n            bracket_sequence = bracket_sequence[:i] + bracket_sequence[i + 1:temp_i] + bracket_sequence[i] + bracket_sequence[temp_i + 1:]\n            i = 1\n        else:\n            i += 1\n    # print(bracket_sequence)\n    i = 0\n    bracket_sequence = bracket_sequence.split()\n    # print(bracket_sequence)\n    while i < len(bracket_sequence) - 1:\n        if bracket_sequence[i] == '+':\n            bracket_sequence[i] = str(int(bracket_sequence[i - 1]) + int(bracket_sequence[i + 1]))\n            bracket_sequence.pop(i + 1)\n            bracket_sequence.pop(i - 1)\n            i = 0\n        else:\n            i += 1\n    return bracket_sequence[0]\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Given a bracket sequence, returns its value.\n    \"\"\"\n    # Initialise the input and output\n    brackets = stdin\n\n    # Initialise the function that performs the calculation\n    def calc(brackets: str) -> str:\n        \"\"\"\n        Given a bracket sequence, returns its value.\n        \"\"\"\n        # Initialise the output variable\n        out = \"\"\n        \n        # Initialise the current bracket level\n        level = 0\n        \n        # Loop through the brackets\n        for bracket in brackets:\n            # If the bracket is a opening bracket\n            if bracket == \"(\":\n                # Increment the bracket level\n                level += 1\n            # Otherwise if the bracket is a closing bracket\n            elif bracket == \")\":\n                # Decrement the bracket level\n                level -= 1\n                # If the bracket level is 0, end the calculation\n                if level == 0:\n                    return out\n            # Otherwise if the bracket is an operator\n            else:\n                # Add the bracket to the output\n                out += bracket\n        # Return the output\n        return out\n    \n    # Initialise the final output variable\n    final = \"\"\n    \n    # Loop through the brackets\n    for bracket in brackets:\n        # If the bracket is an opening bracket\n        if bracket == \"(\":\n            # Get the value of the bracket sequence and add it to the final output variable\n            final += calc(calc(brackets[brackets.find(\"(\", brackets.find(\")\")+1) :]))\n        # Otherwise if the bracket is a closing bracket\n        elif bracket == \")\":\n            # Get the value of the bracket sequence and add it to the final output variable\n            final += calc(calc(brackets[brackets.find(\"(\", brackets.find(\")\")+1) :]))\n        # Otherwise\n        else:\n            # Add the bracket to the final output variable\n            final += bracket\n    \n    # Return the final output variable\n    return final"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    l = []\n    for _ in range(n):\n        l.append(stdin.split())\n    return str(sum([eval(i[0]) for i in l]))"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = stdin.splitlines()[0]\n    return str(compute_bracket_sequence_value(bracket_sequence))\n\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(str(6))\n    5\n    \"\"\"\n    n, x = [int(x) for x in stdin.split()]\n    ans = 0\n    while n > 1:\n        if x % 2 == 1:\n            ans += x * (n % 2)\n        x //= 2\n        n //= 2\n    return ans\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    res = 0\n    cur_op = '+'\n    stack = []\n    for i, c in enumerate(stdin):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                stack.append(i)\n        elif c =='':\n            if stack:\n                op_ind = stack.pop()\n                if cur_op == '+':\n                    res += i - op_ind\n                else:\n                    res *= i - op_ind\n                cur_op = c\n            else:\n                cur_op = c\n        else:\n            if cur_op == '+':\n                res += int(c)\n            else:\n                res *= int(c)\n    print(res)\n    return str(res % (10 ** 9 + 7))\n\nsolution(stdin)\n"
    },
    {
        "number": 3000,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://codeforces.com/problemset/problem/1099/A\"\"\"\n    # n = int(stdin)\n    # sequence = stdin.split()\n    # answer = 0\n    # # sequence[0] = \"5 + 2 + (3 * 1 * (2 + 2) * (3 + 3) * 1)\"\n    # # sequence[1] = \"5 + 2 + (3 * 1 * (2 + 2) * (3 + 3) * 1)\"\n    # print(sequence)\n    #\n    # for element in sequence:\n    #     if element == \"(\":\n    #         answer += 1\n    #     elif element == \")\":\n    #         answer -= 1\n    #\n    # print(answer)\n    return \"15:05:17\"\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = stdin\n    for i in range(len(num)):\n        if num[i] == \"0\" and num[i - 1]!= \"0\":\n            num = num[i:len(num)] + num[0:i]\n    return num\n    \n    "
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return 0\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    counter = int(stdin)\n    steps = 0\n\n    while not is_palindrome(counter):\n        counter += 1\n        steps += 1\n\n    return steps\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_str = stdin\n    while num_str[0] == '0':\n        num_str = num_str[1:]\n    while num_str[-1] == '0':\n        num_str = num_str[:-1]\n    num = int(num_str)\n    if num == 0:\n        return '0'\n    elif num == 1:\n        return '1'\n    elif num == 9:\n        return '9'\n    elif num == 8:\n        return '8'\n    elif num == 7:\n        return '7'\n    elif num == 6:\n        return '6'\n    elif num == 5:\n        return '5'\n    elif num == 4:\n        return '4'\n    elif num == 3:\n        return '3'\n    elif num == 2:\n        return '2'\n    elif num == 1:\n        return '1'\n    else:\n        raise ValueError(f'Unexpected input: {num}')"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This function take a string of digits and return the number of wheel to advance for get a palindrome.\n\n    Args:\n        stdin (str): The string of digits\n\n    Returns:\n        str: The number of wheel to advance for get a palindrome.\n\n    Examples:\n        >>> solution(\"0\")\n        0\n        >>> solution(\"009990001\")\n        3\n        >>> solution(\"29998\")\n        5\n        >>> solution(\"610\")\n        4\n        >>> solution(\"981\")\n        2\n\n    \"\"\"\n    num_of_counter = len(stdin)\n    wheel_left = stdin[num_of_counter::-1]\n    wheel_right = stdin[num_of_counter:]\n    num_of_advances = 0\n    while True:\n        if wheel_left[0] == \"0\":\n            wheel_left = wheel_left[1::]\n        else:\n            break\n    if wheel_right[-1] == \"0\":\n        wheel_right = wheel_right[:-1]\n    else:\n        num_of_advances = len(wheel_right)\n\n    while wheel_right:\n        if wheel_right[0] == \"0\":\n            wheel_right = wheel_right[1::]\n        elif wheel_right[-1] == \"0\":\n            wheel_right = wheel_right[:-1]\n        else:\n            break\n        num_of_advances += 1\n    print(num_of_advances + num_of_advances // 2)\n    return num_of_advances + num_of_advances // 2\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pal_ind = is_palindrome(stdin)\n    \n    if pal_ind == False:\n        return -1\n    \n    return len(stdin) - len(pal_ind)\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin\n    input = input.split('\\n')[0]\n    input = [int(c) for c in input]\n    N = len(input)\n    result = []\n    def solve(pos: int, res: list) -> int:\n        if len(res) == 2 * N:\n            return sum(res) - res[N - 1]\n        if pos < N and res[N - pos - 1] == 0:\n            res[N - pos - 1] = input[pos]\n            result.append(solve(pos + 1, res))\n            return solve(pos + 1, res)\n        else:\n            if input[pos] > 0:\n                res[N - pos - 1] = input[pos] - 1\n                return solve(pos + 1, res)\n            else:\n                res[N - pos - 1] = 9\n                return solve(pos + 1, res)\n    solve(0, input)\n    return result[0]\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    digits = list(stdin)\n    for digit in reversed(digits):\n        if digit == '0':\n            digits.pop()\n        else:\n            break\n    digits.reverse()\n    return len(digits)"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum number of wheel advances required to produce a palindrome.\n\n    Args:\n        stdin (str): input string\n\n    Returns:\n        str: minimum number of wheel advances required to produce a palindrome\n    \"\"\"\n    # you can write to stdout for debugging purposes, e.g.\n    # print(\"this is a debug message\")\n    # input = open(file_path, \"r\").read()\n\n    # Strip all trailing zeroes in the input\n    # input = input.rstrip('0')\n\n    input = stdin.strip()\n\n    # Convert the input to a list of integers\n    input = [int(x) for x in input]\n\n    # Check if the input is palindrome\n    if input == input[::-1]:\n        return 0\n\n    # Iterate through each digit in the input\n    for i, d in enumerate(input):\n        # Create a copy of the input\n        input_copy = input.copy()\n\n        # Set the current digit to a 9\n        input_copy[i] = 9\n\n        # Check if the input is palindrome\n        if input_copy == input_copy[::-1]:\n            # If so, return the number of digits\n            return len(input_copy) - 1\n\n    # If we get here, there is no palindrome in the input\n    return -1\n"
    },
    {
        "number": 3001,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return None\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    service = [stdin.strip().split() for _ in range(n)]\n    service.sort(key=lambda x: int(x[2]))\n    if service[0][0]!= '2013':\n        return 'tampered odometer'\n    if int(service[0][2]) < 1:\n        return 'insufficient service'\n    prev = int(service[0][2])\n    count = 1\n    for i in range(1, n):\n        if int(service[i][2]) == prev:\n            count += 1\n            if count >= 12:\n                return 'tampered odometer'\n        else:\n            count = 1\n        prev = int(service[i][2])\n    return'seems legit'\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    service = []\n    for i in range(n):\n        service.append([int(i) for i in stdin.readline().split()])\n    if n == 1:\n        return'seems legit'\n    elif n == 2:\n        if service[0][0] == service[1][0] and service[0][1] == service[1][1]:\n            return'seems legit'\n        else:\n            return 'tampered odometer'\n    else:\n        r = 0\n        for i in range(1, len(service)):\n            if service[i][0] == service[i - 1][0] and service[i][1] == service[i - 1][1]:\n                return 'tampered odometer'\n            elif service[i][0] == service[i - 1][0]:\n                if service[i - 1][2] + 1000 < service[i][2]:\n                    r += 1\n                elif service[i - 1][2] > service[i][2]:\n                    r += 1\n                else:\n                    r += 0\n            elif service[i - 1][1] == service[i][1]:\n                if service[i - 1][2] + 1000 < service[i][2]:\n                    r += 1\n                elif service[i - 1][2] > service[i][2]:\n                    r += 1\n                else:\n                    r += 0\n            elif service[i - 1][1] + 1 == service[i][1]:\n                if service[i - 1][2] < service[i][2]:\n                    r += 1\n                else:\n                    r += 0\n            elif service[i - 1][1] == 12 and service[i][1] == 1:\n                if service[i - 1][2] < service[i][2]:\n                    r += 1\n                else:\n                    r += 0\n        if r == 0:\n            return'seems legit'\n        elif r == 1:\n            return 'insufficient service'\n        else:\n            return 'tampered odometer'\nprint(solution(stdin))\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the total amount of mileage traveled on the car. If the total mileage exceeds $100,000,\n    find the year and month of the last service, and find the year and month of the next service.\n    Make sure that this date is the month following the month of the last service.\n\n    If the total mileage is less than $100,000, the car was serviced on average every $3,000,000.\n    Otherwise, if the total mileage was less than $12,000, the car was serviced on average every $6,000,000.\n    Finally, if the total mileage was less than $15,000, the car was serviced on average every $12,000,000.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    services = {\n        'cat': {'min': 3000,'max': 12},\n       'service': {'min': 12,'max': 12}\n    }\n\n    entries = list(map(lambda x: list(map(lambda x: int(x), x.split(' '))), stdin.split('\\n')[:-1]))\n\n    total = 0\n    for entry in entries:\n        for i in range(entry[0], entry[1]):\n            if i % 12 == 0:\n                total += entry[2]\n            else:\n                total += entry[2]\n                if total >= 12 * services['service']['min'] and total <= 12 * services['service']['max']:\n                    return'seems legit'\n    return 'tampered odometer'\n"
    },
    {
        "number": 3002,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_ = stdin.splitlines()\n\n    n = int(input_[0])\n    assert 2 <= n <= 11, 'Number of vertices must be 2 <= n <= 11'\n\n    graph = {i: set() for i in range(n)}\n    for line in input_[1:]:\n        a, b = line.split()\n        graph[int(a)].add(int(b))\n        graph[int(b)].add(int(a))\n\n    colors = {}\n    for key, value in graph.items():\n        for v in value:\n            if key in colors:\n                if v not in colors[key]:\n                    colors[key].append(v)\n            else:\n                colors[key] = [v]\n\n    color_count = {}\n    for key, value in colors.items():\n        for v in value:\n            if v not in color_count:\n                color_count[v] = 1\n            else:\n                color_count[v] += 1\n\n    return max(color_count.values())\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # The input string\n    in_str = stdin.strip()\n    # The number of vertices\n    num_v = int(in_str.split(\"\\n\")[0])\n    # The list of edges\n    edges = in_str.split(\"\\n\")[1:]\n\n    # The adjacency list of the graph\n    adj = [set() for _ in range(num_v)]\n    # Loop over each edge\n    for edge in edges:\n        # Split the edge into two vertex indices\n        i, j = map(int, edge.split())\n        # Add the vertex to the target index\n        adj[i].add(j)\n        adj[j].add(i)\n\n    # The colors used to color the graph\n    colors = set()\n    # The number of colors needed\n    num_colors = 0\n\n    # The next available color to assign\n    color = 0\n    # Loop over the vertices\n    for v in range(num_v):\n        # Check each color\n        for c in colors:\n            # If the color is valid for the vertex, break\n            if (c not in adj[v]) or (c in adj[v] and v not in adj[c]):\n                break\n        # Add the color to the list\n        colors.add(c)\n        # Update the number of colors used\n        num_colors = len(colors)\n        # Check if the number of colors is greater than or equal to the solution\n        if num_colors > num_v:\n            return str(num_v)\n    # Otherwise, return the number of colors\n    return str(num_colors)\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    vertices = [set() for _ in range(int(stdin.readline()))]\n    for line in stdin:\n        line = line.split()\n        for vertex in line[1:]:\n            vertices[int(line[0])].add(vertex)\n    return str(len(vertices) - max([len(v) for v in vertices]))\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    number_of_vertices, number_of_edges = list(map(int, stdin.split('\\n')[0].split(' ')))\n    number_of_colors = number_of_vertices + 1\n    edges = []\n    for i in range(number_of_edges):\n        edges.append(list(map(int, stdin.split('\\n')[i + 1].split(' '))))\n    edges = sorted(edges, key=lambda x: len(x))\n    colors = list(range(number_of_colors))\n    color_dict = dict(zip(colors, [None for i in range(number_of_colors)]))\n    for edge in edges:\n        start_vertex, end_vertex = edge[0], edge[1]\n        if color_dict[start_vertex] == color_dict[end_vertex]:\n            return 'impossible'\n        elif color_dict[start_vertex] is not None:\n            if color_dict[end_vertex] is None:\n                color_dict[end_vertex] = color_dict[start_vertex]\n            elif color_dict[end_vertex]!= color_dict[start_vertex]:\n                return 'impossible'\n        elif color_dict[end_vertex] is not None:\n            if color_dict[start_vertex] is None:\n                color_dict[start_vertex] = color_dict[end_vertex]\n            elif color_dict[start_vertex]!= color_dict[end_vertex]:\n                return 'impossible'\n        else:\n            color_dict[end_vertex] = color_dict[start_vertex]\n    return number_of_colors - 1\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _ = int(stdin.readline())\n    graph = {i: [] for i in range(0, _)}\n    for i in range(0, _):\n        line = list(map(int, stdin.readline().split(' ')))\n        for j in line[1:]:\n            graph[i].append(j)\n    color_list = set()\n    _ = int(stdin.readline())\n    for i in range(0, _):\n        line = list(map(int, stdin.readline().split(' ')))\n        color_list.add(line[1])\n    color_list = list(color_list)\n    color_list.sort()\n    vertex_list = graph.keys()\n    for i in vertex_list:\n        if len(graph[i]) == 0:\n            continue\n        edge_list = graph[i]\n        for j in edge_list:\n            if color_list.index(j) >= color_list.index(i):\n                return 'IMPOSSIBLE'\n    return color_list[-1] + 1\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum number of colors required to color all vertices of the graph such that no vertices that share an edge are colored using the same color.\"\"\"\n    graph = defaultdict(set)\n    for i, _ in enumerate(stdin.split('\\n')):\n        graph[i] = {int(x) for x in _.split()}\n    return len(find_colors(graph))\n\n\ndef"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    sys.stdin = open(\"input.txt\")\n\n    N = int(input())\n    graph = [[] for _ in range(N)]\n    # graph = [[] for _ in range(N+1)]\n    for _ in range(N):\n        a, b = input().split()\n        a, b = int(a), int(b)\n        graph[a].append(b)\n        # graph[a+1].append(b+1)\n        # graph[b+1].append(a+1)\n\n    color = [-1] * N\n    color[0] = 0\n\n    for v in range(1, N):\n        # find all uncolored neighbors\n        uncolored = []\n        for u in graph[v]:\n            if color[u] < 0:\n                uncolored.append(u)\n\n        # pick a neighbor with the smallest color, and color it\n        # if the smallest color has already been picked, pick the next smallest\n        if uncolored:\n            uncolored.sort()\n            next_color = min(uncolored)\n            color[v] = next_color\n            uncolored.remove(next_color)\n            if uncolored:\n                uncolored.sort()\n                next_color = uncolored[0]\n\n    return N - color.count(-1)\n"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Finds minimum number of colors required to color all vertices of the graph such that no vertices that share an edge are colored using the same color!\n    Returns the minimum number of colors required.\n    '''\n    \n    n = int(stdin.readline().rstrip())\n    \n    colors = set()\n    while n > 0:\n        n -= 1\n        line = stdin.readline().rstrip().split()\n        colors = colors.union(set(map(int, line)))\n        \n    return len(colors)"
    },
    {
        "number": 3003,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_vertices, num_edges = map(int, stdin.split(\"\\n\")[0].split())\n    connections = [[int(j) for j in i.split()] for i in stdin.split(\"\\n\")[1:]]\n\n    dsu = DSU(num_vertices)\n    colors = {i: -1 for i in range(num_vertices)}\n\n    for connection in connections:\n        dsu.union(connection[0], connection[1])\n\n    for vertex in range(num_vertices):\n        for vertex_two in range(vertex + 1, num_vertices):\n            if dsu.connected(vertex, vertex_two):\n                if colors[vertex] == colors[vertex_two]:\n                    return \"IMPOSSIBLE\"\n    \n    return max(colors.values()) + 1\n\nclass DSU:\n    def __init__(self, num_vertices):\n        self.parent = [i for i in range(num_vertices)]\n    \n    def union(self, vertex, vertex_two):\n        vertex_parent = self.find(vertex)\n        vertex_two_parent = self.find(vertex_two)\n\n        self.parent[vertex_two_parent] = vertex_parent\n\n    def find(self, vertex):\n        if vertex!= self.parent[vertex]:\n            self.parent[vertex] = self.find(self.parent[vertex])\n\n        return self.parent[vertex]"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = [line.split() for line in stdin.splitlines()[1:]]\n\n    b = set()\n    r = set()\n    o = set()\n    g = set()\n\n    for line in lines:\n        a = int(line[1])\n        b = int(line[2])\n        if line[0] == \"BLUE\":\n            for i in range(a, b + 1):\n                b.add(i)\n        elif line[0] == \"RED\":\n            for i in range(a, b + 1):\n                r.add(i)\n        elif line[0] == \"ORANGE\":\n            for i in range(a, b + 1):\n                o.add(i)\n        elif line[0] == \"GREEN\":\n            for i in range(a, b + 1):\n                g.add(i)\n\n    r = list(r)\n    o = list(o)\n    g = list(g)\n\n    a = len(b.intersection(r).intersection(o))\n    b = len(b.intersection(r).intersection(g))\n    c = len(b.intersection(r).intersection(o).intersection(g))\n\n    if a + b + c > 3:\n        return \"IMPOSSIBLE\"\n    if a == 3 and b == 3 and c == 3:\n        return str(n)\n    if a == 3 and b == 3:\n        return str(n - 1)\n    if a == 3:\n        return str(n - 2)\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    color_dict = {}\n    for i in range(1, n + 1):\n        color_dict[i] = [int(x) for x in stdin.readline().split()]\n    color_list = [0] * (n + 1)\n    color_list[1] = color_dict[1]\n    color_list[2] = color_dict[2]\n    for i in range(3, n + 1):\n        color_list[i] = color_dict[i][1:] + [i]\n    ans = 0\n    for i in range(1, n + 1):\n        ans += color_list[i][0]\n        for j in range(1, n + 1):\n            if j < n and color_list[i][0] < color_list[j][0]:\n                break\n        else:\n            ans += 1\n        for j in range(1, n + 1):\n            if i == j:\n                continue\n            if max(color_list[i]) > max(color_list[j]):\n                break\n        else:\n            ans += 1\n    if ans >= n:\n        print('IMPOSSIBLE')\n    else:\n        print(ans)\n\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    number_of_offers = int(stdin[0])\n    offers = []\n    for i in range(1, number_of_offers + 1):\n        offers.append(stdin[i].split())\n    return get_number_of_offers(offers)\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n > 3:\n        return \"IMPOSSIBLE\"\n    count = 0\n    nums = list(map(int, stdin.split()))\n    for i in range(n):\n        for j in range(n):\n            if j > i:\n                if nums[i] * (j - i + 1) <= 10000 and nums[i] * (j - i + 1) >= nums[j] * (i - j + 1):\n                    count += 1\n    return count\n\ndef"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    count = 0\n    red = []\n    blue = []\n    color = []\n    for i in range(N):\n        x = stdin.readline().strip().split(' ')\n        if 'RED' in x:\n            red.append(int(x[1]))\n            red.append(int(x[2]))\n            color.append('RED')\n        else:\n            blue.append(int(x[1]))\n            blue.append(int(x[2]))\n            color.append('BLUE')\n    color = list(set(color))\n    if len(color) > 3:\n        return 'IMPOSSIBLE'\n    blue.sort()\n    red.sort()\n    if blue[0] > red[0]:\n        red, blue = blue, red\n    if blue[0] <= red[0]:\n        if blue[1] <= red[0]:\n            return 'IMPOSSIBLE'\n        if blue[1] > red[0]:\n            red = [0, blue[1]]\n            color = ['RED']\n    if len(blue) > 2:\n        if blue[2] <= red[1]:\n            return 'IMPOSSIBLE'\n    if len(blue) > 1:\n        if blue[1] <= red[1]:\n            return 'IMPOSSIBLE'\n    if len(blue) == 1:\n        if blue[0] <= red[1]:\n            return 'IMPOSSIBLE'\n    if len(blue) == 2:\n        if blue[0] <= red[0] and blue[1] <= red[1]:\n            return 'IMPOSSIBLE'\n    if len(blue) == 1:\n        if blue[0] <= red[0]:\n            return 'IMPOSSIBLE'\n    for i in range(N):\n        if color[i] == 'RED':\n            count += red[1] - red[0]\n        else:\n            count += blue[1] - blue[0]\n    return str(count)\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3004,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    ans = 0\n    n = int(stdin.split()[0])\n    for _ in range(n):\n        ans = ans + 1\n    return str(ans)"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the weight of a maximal factoring of the input string.\"\"\"\n    # Perform factoring on the input string.\n    # Return the smallest weight of all maximal factorings.\n    #\n    # Time Complexity: O(N^2)\n    # Space Complexity: O(1)\n\n    # Note:\n    # A string s can be factored as s = p * q, where p and q are positive strings, and p <= q.\n    # A maximal factoring is always an irreducible factoring.\n\n    # Note:\n    # We are allowed to use O(1) extra memory.\n    # We are allowed to assume the number of characters in the input string is at most 200.\n\n    # Find the maximal factoring of the input string.\n    # Return the weight of the maximal factoring.\n\n    # Get the input string.\n    string = stdin\n\n    # Perform factoring on the input string.\n    # Return the smallest weight of all maximal factorings.\n\n    # Set the smallest weight of all maximal factoring to the longest possible.\n    smallest_weight = len(string)\n\n    # Iterate over every substring of the input string.\n    for i in range(len(string)):\n        # If the substring is the empty string, skip it.\n        if string[i]!= string[0]:\n            # Get the substring and its length.\n            substring = string[i:]\n            substring_length = len(substring)\n\n            # Perform factoring on the substring.\n            # Return the smallest weight of all maximal factorings.\n            # Store the weight of the factor if it is smaller than the current smallest weight.\n            smallest_weight = min(smallest_weight, get_substring_weight(substring))\n\n    return smallest_weight\n\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximal factoring of a string.\"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    # take input\n    string = stdin\n    # find the max length string\n    max_length = len(string)\n    # initialize a list to store all possible substring\n    list_of_substrings = []\n    for i in range(max_length):\n        for j in range(max_length):\n            if i+j <= max_length-1:\n                if string[i:i+j+1] in list_of_substrings:\n                    continue\n                else:\n                    list_of_substrings.append(string[i:i+j+1])\n    # find the sum of the weight of the substring\n    weight = 0\n    for substring in list_of_substrings:\n        if substring in string:\n            weight += len(substring)\n    return weight"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    if stdin.count('A') == 1:\n        return 1\n    else:\n        max_weight = 1\n        for i in range(len(stdin)):\n            for j in range(i, len(stdin)):\n                substring = stdin[i:j]\n                if stdin[j] == 'A':\n                    substring_len = len(substring)\n                    max_weight = max(substring_len, max_weight)\n                    break\n        return max_weight\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    ans = 1\n    s = stdin\n    while True:\n        for i in range(0, len(s) - 1):\n            if s[i] == s[i+1]:\n                ans += 1\n            else:\n                ans -= 1\n                break\n        s = s[:i] + str(ans) + s[i+1:]\n        if len(s) <= 3:\n            break\n        ans = 1\n    return ans\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"A recursive Python3 program to\n    count factoring of the given string.\n\n    :param stdin: String for which factoring\n    is to be found\n    :return: Count of maximal factoring\n    \"\"\"\n    ans = 0\n    n = len(stdin)\n    if n == 0:\n        return 0\n    for i in range(1, n):\n        if n % i == 0:\n            # Get count of substrings\n            # starting from ith index\n            j = n // i\n            curr_count = i * j\n            if i == j:\n                curr_count -= 1\n\n            # Check if curr_count is\n            # greater than ans\n            if curr_count > ans:\n                ans = curr_count\n\n    return ans\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest string that has no overlapping letters, and returns the\n    weights of the longest possible factoring, with the minimum possible weights.\n\n    >>> solution(\"AAAAABBB\")\n    (4, \"A(AB)^2\")\n\n    >>> solution(\"CCCCCCCCCCCCC\")\n    (8, \"((CC)^2)^2\")\n\n    >>> solution(\"ABABAB\")\n    (5, \"A(BA)^2\")\n    \"\"\"\n    # Note: The input string must be at least one character long.\n    # This is enforced in the test cases.\n    best = None\n    best_weight = 0\n    for i in range(1, len(stdin)):\n        for j in range(len(stdin) - i + 1):\n            substring = stdin[j:j + i]\n            if not any(substring[k] == substring[k + 1] for k in range(i - 1)):\n                weight = len(substring) - 1 + i * 2\n                if weight > best_weight:\n                    best = (i, substring + \"^\" + str(weight))\n                    best_weight = weight\n\n    return best\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    max_weight = 1\n    for i in range(1, len(stdin)):\n        current_weight = 1\n        for j in range(0, len(stdin) - i):\n            substring = stdin[j:j + i]\n            if substring not in stdin[j + i:] and substring not in stdin[j + 1:j + i + 1]:\n                current_weight += 1\n        if current_weight > max_weight:\n            max_weight = current_weight\n\n    return max_weight\n"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Return the weight of a maximal factoring of stdin'''\n    return min(len(min_factoring(stdin)), len(max_factoring(stdin)))\n\ndef"
    },
    {
        "number": 3005,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximal irreducible facotring in a string\"\"\"\n    # Get rid of duplicates\n    string = stdin.lower()\n    string = list(set(string))\n    string.sort()\n\n    # Compute max weight and its corresponding factor\n    max_weight = 0\n    max_factor = 0\n    for i in range(len(string)):\n        temp = string[i]\n        factor = 1\n        weight = 0\n        for j in range(i + 1, len(string)):\n            if string[j] == temp:\n                factor += 1\n            else:\n                break\n        if factor > 1:\n            weight = len(temp) + (2 * len(str(factor))) + 1\n        if weight > max_weight:\n            max_weight = weight\n            max_factor = temp + str(factor)\n    return max_factor\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dna = stdin.strip()\n    current_dna = \"\"\n    current_position = 0\n\n    for command in dna:\n        if command == \"E\":\n            break\n        elif command == \"I\":\n            current_position += 1\n        elif command == \"D\":\n            current_position += int(command.split()[1])\n\n        current_dna += command\n\n    return \"0\" if dna == current_dna else \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    deletions = dict()\n    insertions = dict()\n    previous_line = \"\"\n    for line in stdin.split(\"\\n\"):\n        if previous_line:\n            action, index, value = previous_line.split()\n            if action == \"D\":\n                deletions[int(index)] = value\n            elif action == \"I\":\n                insertions[int(index)] = value\n        previous_line = line\n    answer = \"1\" if deletions == insertions else \"0\"\n    return answer\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return '0'"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    my_list = []\n    i = 0\n    while i < len(stdin):\n        if stdin[i] == 'E':\n            break\n        if stdin[i] == 'D':\n            my_list.append(int(stdin[i + 1]))\n            i += 2\n        elif stdin[i] == 'I':\n            my_list.append(int(stdin[i + 1]))\n            my_list.append(stdin[i + 2])\n            i += 3\n    # write your code in Python 3.6\n    return '0' if my_list == [] else '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    program1 = stdin.splitlines()\n    program2 = stdin.splitlines()\n    \n    if len(program1)!= len(program2):\n        return \"1\"\n    \n    program1_list = []\n    for line in program1:\n        if line == \"E\":\n            break\n        \n        if line[0] == \"I\":\n            index, char = line[2:].split()\n            program1_list.append((int(index), char))\n            \n        elif line[0] == \"D\":\n            index = line[2:]\n            program1_list.append((int(index), \"\"))\n            \n    program2_list = []\n    for line in program2:\n        if line == \"E\":\n            break\n        \n        if line[0] == \"I\":\n            index, char = line[2:].split()\n            program2_list.append((int(index), char))\n            \n        elif line[0] == \"D\":\n            index = line[2:]\n            program2_list.append((int(index), \"\"))\n            \n    if len(program1_list)!= len(program2_list):\n        return \"1\"\n    \n    for i in range(len(program1_list)):\n        if program1_list[i]!= program2_list[i]:\n            return \"1\"\n    \n    return \"0\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    prog1, prog2 = stdin.split('\\n')\n    cur_i = 0\n    ops_i = 0\n    ops1 = []\n    ops2 = []\n    for op in prog1:\n        if op == 'E':\n            break\n        elif op == 'D':\n            ops1.append(cur_i)\n            cur_i += int(prog1[cur_i + 1])\n            cur_i += 1\n        elif op == 'I':\n            ops1.append(cur_i)\n            ops1.append(prog1[cur_i + 1])\n            cur_i += 2\n    cur_i = 0\n    for op in prog2:\n        if op == 'E':\n            break\n        elif op == 'D':\n            ops2.append(cur_i)\n            cur_i += int(prog2[cur_i + 1])\n            cur_i += 1\n        elif op == 'I':\n            ops2.append(cur_i)\n            ops2.append(prog2[cur_i + 1])\n            cur_i += 2\n    print('0' if ops1 == ops2 else '1')\n    return ''\n\n\ndef"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return \"0\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin)\n    Outputs:\n        0\n    \"\"\"\n    s = stdin.strip().split(\"\\n\")\n    for i in range(len(s)):\n        if s[i][0] == \"I\":\n            s[i] = s[i][1:] + \" \" + s[i][1:].upper()\n        elif s[i][0] == \"D\":\n            s[i] = s[i][1:]\n    if len(s) < 2:\n        return \"1\"\n    return \"0\" if s[0] == s[1] else \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"D 2\\nD 3\\nE\\nD 1\\nD 2\\nE\")\n    '0'\n    >>> solution(\"D 2\\nI 1 X\\nD 1\\nE\\nE\")\n    '0'\n    >>> solution(\"I 14 B\\nI 14 A\\nE\\nI 14 A\\nI 15 B\\nE\")\n    '0'\n    >>> solution(\"I 14 A\\nI 15 B\\nE\\nI 14 A\\nI 15 B\\nE\")\n    '1'\n    \"\"\"\n    string1, string2 = stdin.split('\\n')[:-1], stdin.split('\\n')[1:]\n    for i in range(len(string1)):\n        if string1[i]!= string2[i]:\n            return '1'\n    return '0'\n"
    },
    {
        "number": 3006,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution for DNA Editing Problem.\n    \"\"\"\n    stdin = stdin.split(\"\\n\")\n    program_a = stdin[0]\n    program_b = stdin[1]\n    \n    # 1. Iterate through both programs,\n    # 2. If the current line is an INS,\n    # 3. Then perform the operation on the current line\n    # 4. If the current line is a DEL,\n    # 5. Then perform the operation on the current line\n    # 6. If the current line is an END,\n    # 7. Then compare the result of the previous operation to the next one\n    # 8. Repeat until the end of the program\n    for i in range(len(program_a)):\n        if program_a[i] == \"I\":\n            program_a = program_a[:i] + program_a[i+1:]\n        elif program_a[i] == \"D\":\n            del program_a[i]\n        if program_b[i] == \"I\":\n            program_b = program_b[:i] + program_b[i+1:]\n        elif program_b[i] == \"D\":\n            del program_b[i]\n        if program_a[-1] == \"E\" and program_b[-1] == \"E\":\n            return \"0\"\n        if program_a[-1] == \"E\" and program_b[-1]!= \"E\":\n            return \"1\"\n        if program_b[-1] == \"E\" and program_a[-1]!= \"E\":\n            return \"1\""
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    days, bling, fruits, trees1, trees2, trees3 = [int(s) for s in stdin.split()]\n    trees = [trees1, trees2, trees3]\n    fruits, trees = sorted(fruits, reverse=True), sorted(trees, reverse=True)\n    r, s, p = list(), [0] * 3, [0] * 3\n    for i in range(len(trees)):\n        if trees[i] <= fruits[i] and trees[i] > 0:\n            trees[i] = -1\n            fruits[i] -= trees[i]\n            s[i] = trees[i]\n            r.append(i)\n            if i < len(trees) - 1:\n                s[i + 1] += s[i]\n            else:\n                if len(r) == 0:\n                    p[0] = 0\n                else:\n                    p[0] = r[0]\n                    r.pop(0)\n        else:\n            break\n    if len(r) == 0:\n        p[0] = 0\n    else:\n        p[0] = r[0]\n    if len(r) == 0:\n        if sum(s) < bling:\n            p[1] = bling - sum(s)\n        else:\n            p[1] = 0\n    else:\n        if s[r[0]] < bling:\n            p[1] = bling - s[r[0]]\n        else:\n            p[1] = 0\n    if len(r) == 0:\n        if trees[0] == 0:\n            p[2] = 0\n        else:\n            if s[0] < bling:\n                p[2] = bling - s[0]\n            else:\n                p[2] = 0\n    else:\n        if s[r[0]] < bling:\n            p[2] = bling - s[r[0]]\n        else:\n            p[2] = 0\n    p = [p[i] if p[i]!= 0 else None for i in range(len(p))]\n    print(sum(s) + bling * sum(p))\n    return \"\""
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = [int(x) for x in stdin.split(' ')]\n    crops = [t0, t1, t2]\n    days = d + 1\n    while days > 0:\n        if cropping_day(crops) > 0:\n            days -= 1\n            b += 400\n            f += cropping_day(crops)\n            if cropping_day(crops) == 0:\n                b += 100\n            elif cropping_day(crops) == 1:\n                b += 200\n            elif cropping_day(crops) == 2:\n                b += 300\n        else:\n            b += 500\n            crops = [0, 0, 0]\n    return b\n\n\ndef"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Reads the input and computes the maximum Bling John can have after playing John's remaining days and current Bling amount.\n    :param stdin: the input string\n    :return: the maximum Bling John can have\n    '''\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n    return b + f * 400 + t_0 * 500 + t_1 * 500 + t_2 * 500 + (d - 3) // 3 * 500\n\nprint(solution(input()))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, *t = map(int, stdin.split())\n    crops = {tuple(map(int, line.split())) for line in stdin.splitlines()[3:]}\n    res = max(b, f * 400, f * 400 + sum(t) * 500)\n    for i in range(d):\n        new_crops = set()\n        for a, b, c in crops:\n            if c > 0:\n                new_crops.add((a, b, c - 1))\n            if c < 2:\n                new_crops.add((a + 1, b, c + 1))\n        crops = new_crops\n    return str(res)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    input_lines = stdin.splitlines()\n    d = int(input_lines[0].split()[0])\n    b = int(input_lines[0].split()[1])\n    f = int(input_lines[0].split()[2])\n    t0 = int(input_lines[0].split()[3])\n    t1 = int(input_lines[0].split()[4])\n    t2 = int(input_lines[0].split()[5])\n\n    max_b = b\n    i = 1\n    while d >= i:\n        if t0 >= i:\n            b += i * 100\n        if t1 >= i:\n            b += i * 500\n        if t2 >= i:\n            b += i * 500\n        if f > 0:\n            if f % 3 == 0:\n                b += i * 100 * 3\n                f -= 3\n            else:\n                b += i * 100 * (f % 3)\n                f -= f % 3\n        max_b = max(max_b, b)\n        i += 1\n    return max_b\n\nprint(solution(stdin))"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution for the input\"\"\"\n    (d, b, f, t_0, t_1, t_2) = [int(num) for num in stdin.split()]\n\n    if t_0 > 0:\n        t_0_cost = t_0 * 100\n        d += t_0_cost\n    if t_1 > 0:\n        t_1_cost = t_1 * 300\n        d += t_1_cost\n    if t_2 > 0:\n        t_2_cost = t_2 * 500\n        d += t_2_cost\n\n    if b > 0:\n        b_cost = b * 100\n        f += b_cost\n\n    b_per_day = f / d\n    result = d * b_per_day\n    return result\n\nprint(solution(\"4 0 1 0 0 0\"))\nprint(solution(\"5 0 1 0 1 0\"))\nprint(solution(\"6 0 1 1 0 0\"))\nprint(solution(\"10 399 0 0 0 0\"))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    d, b, f, t_0, t_1, t_2 = [int(x) for x in stdin.split()]\n    return str(max(300, b + (f * 3) + (t_0 * 200) + (t_1 * 500) + (t_2 * 900)))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution of the challenge.\"\"\"\n    d, b, f, t0, t1, t2 = [int(v) for v in stdin.split()]\n    return str(max(b, f, t0 * 100 + t1 * 150 + t2 * 200))\n"
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets input, strips unnecessary spaces and checks for input errors, then runs the algorithm.\"\"\"\n    d, b, f, t0, t1, t2 = stdin.split()\n    d, b, f, t0, t1, t2 = int(d), int(b), int(f), int(t0), int(t1), int(t2)\n    return max(\n        {\n            \"fruits\": b,\n            \"exotics\": b,\n            \"day\": d,\n            \"days\": d,\n            \"total\": b,\n            \"fruit\": f,\n            \"fruit_trees\": t0,\n            \"fruit_trees_2\": t1,\n            \"fruit_trees_3\": t2,\n            \"fruit_tree\": 0,\n            \"fruit_tree_2\": 0,\n            \"fruit_tree_3\": 0,\n            \"exotic_fruit\": 0,\n            \"exotic_fruit_2\": 0,\n            \"exotic_fruit_3\": 0,\n            \"exotic_trees\": 0,\n            \"exotic_trees_2\": 0,\n            \"exotic_trees_3\": 0,\n            \"exotic_tree\": 0,\n            \"exotic_tree_2\": 0,\n            \"exotic_tree_3\": 0,\n            \"total_fruits\": 0,\n            \"total_exotic\": 0,\n            \"total_exotic_trees\": 0,\n            \"total_exotic_trees_2\": 0,\n            \"total_exotic_trees_3\": 0,\n            \"day_1\": 0,\n            \"day_2\": 0,\n            \"day_3\": 0,\n            \"day_4\": 0,\n            \"day_5\": 0,\n            \"day_6\": 0,\n            \"day_7\": 0,\n            \"day_8\": 0,\n            \"day_9\": 0,\n            \"day_10\": 0,\n            \"day_11\": 0,\n            \"day_12\": 0,\n            \"day_13\": 0,\n            \"day_14\": 0,\n            \"day_15\": 0,\n            \"day_16\": 0,\n            \"day_17\": 0,\n            \"day_18\": 0,\n            \"day_19\": 0,\n            \"day_20\": 0,\n            \"day_21\": 0,\n            \"day_22\": 0,\n            \"day_23\": 0,\n            \"day_24\": 0,\n            \"day_25\": 0,\n            \"day_26\": 0,\n            \"day_27\": 0,\n            \"day_28\": 0,\n            \"day_29\": 0,\n            \"day_30\": 0,\n            \"day_31\": 0,\n            \"day_32\": 0,\n            \"day_33\": 0,\n            \"day_34\": 0,\n            \"day_35\": 0,\n            \"day_36\": 0,\n            \"day_37\": 0,\n            \"day_38\": 0,\n            \"day_39\": 0,\n            \"day_40\": 0,\n            \"day_41\": 0,\n            \"day_42\": 0,\n            \"day_43\": 0,\n            \"day_44\": 0,\n            \"day_45\": 0,\n            \"day_46\": 0,\n            \"day_47\": 0,\n            \"day_48\": 0,\n            \"day_49\": 0,\n            \"day_50\": 0,\n            \"day_51\": 0,\n            \"day_52\": 0,\n            \"day_53\": 0,\n            \"day_54\": 0,\n            \"day_55\": 0,\n            \"day_56\": 0,\n            \"day_57\": 0,\n            \"day_58\": 0,\n            \"day_59\": 0,\n            \"day_60\": 0,\n            \"day_61\": 0,\n            \"day_62\": 0,\n            \"day_63\": 0,\n            \"day_64\": 0,\n            \"day_65\": 0,\n            \"day_66\": 0,\n            \"day_67\": 0,\n            \"day_68\": 0,\n            \"day_69\": 0,\n            \"day_70\": 0,\n            \"day_71\": 0,\n            \"day_72\": 0,\n            \"day_73\": 0,\n            \"day_74\": 0,\n            \"day_75\": 0,\n            \"day_76\": 0,\n            \"day_77\": 0,\n            \"day_78\": 0,\n            \"day_79\": 0,\n            \"day_80\": 0,\n            \"day_81\": 0,\n            \"day_82\": 0,\n            \"day_83\": 0,\n            \"day_84\": 0,\n            \"day_85\": 0,\n            \"day_86\": 0,\n            \"day_87\": 0,\n            \"day_88\": 0,\n            \"day_89\": 0,\n            \"day_90\": 0,\n            \"day_91\": 0,\n            \"day_92\": 0,\n            \"day_93\": 0,\n            \"day_94\": 0,\n            \"day_95\": 0,\n            \"day_96\": 0,\n            \"day_97\": 0,\n            \"day_98\": 0,\n            \"day_99\": 0,\n            \"day_100\": 0,\n            \"day_101\": 0,\n            \"day_102\": 0,\n            \"day_103\": 0,\n            \"day_104\": 0,\n            \"day_105\": 0,\n            \"day_106\": 0,\n            \"day_107\": 0,\n            \"day_108\": 0,\n            "
    },
    {
        "number": 3007,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a = [int(x) for x in stdin.strip().split(' ')]\n    days, bling, fruits, fruit_tree1, fruit_tree2, exotic_fruit_tree = a\n    fruit_tree1, fruit_tree2, exotic_fruit_tree = int(fruit_tree1), int(fruit_tree2), int(exotic_fruit_tree)\n    if days == 1:\n        if fruit_tree1 > 0:\n            return 400 + bling\n        else:\n            return 0\n    if days == 2:\n        if fruit_tree1 > 0:\n            return 200 + bling\n        else:\n            return 0\n    if days == 3:\n        if fruit_tree1 > 0:\n            return 100 + bling\n        else:\n            return 0\n    if days == 4:\n        if fruit_tree1 > 0 and fruit_tree2 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 5:\n        if fruit_tree1 > 0 and fruit_tree2 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 6:\n        if exotic_fruit_tree > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 7:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 8:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 9:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 10:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 11:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 12:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 13:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 14:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 15:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 16:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 17:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 18:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 19:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 20:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 21:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 22:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 23:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 24:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 25:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 26:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 27:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 28:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 29:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 30:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 31:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 32:\n        if exotic_fruit_tree > 0 and fruit_tree1 > 0:\n            return 500 + bling\n        else:\n            return 0\n    if days == 33:\n        if exotic_fruit_tree"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    _ = stdin.readline()\n    a = [*map(int, stdin.readline().split())]\n    _ = stdin.readline()\n    b = [*map(int, stdin.readline().split())]\n    r = {i: (a[i], b[i]) for i in range(len(a))}\n    r = sorted(r.items(), key=lambda x: x[1][1] / (x[1][0] + 1), reverse=True)\n    r = [*filter(lambda x: x[1][1] / (x[1][0] + 1) >= r[0][1][1] / (r[0][1][0] + 1), r)]\n    r = [*map(lambda x: x[1][0] + 1, r)]\n    return str(max(set(r)))\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum number of distinct ranks, taken over all possible rankings.\n    :type stdin: str\n    :rtype: str\n    \"\"\"\n    N, K = tuple(int(number) for number in stdin.split(' '))\n    measurements = tuple(tuple(int(number) for number in stdin.split(' ')[N * i + 1: N * i + 3]) for i in range(N))\n    sorted_measurements = sorted(measurements, key=lambda x: (x[0], x[1]))\n    count = 1\n    prev_measurement = sorted_measurements[0]\n    for measurement in sorted_measurements[1:]:\n        if measurement[0] + K >= prev_measurement[0] or measurement[1] + K >= prev_measurement[1]:\n            count += 1\n        prev_measurement = measurement\n    return str(count)\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    (N, K) = list(map(int, lines[0].split(' ')))\n    assistants = list(map(int, lines[1].split(' ')))\n    grades = list(map(int, lines[2].split(' ')))\n\n    a = [(assistants[i], grades[i]) for i in range(N)]\n    a.sort(key=lambda t: t[0])\n    result = 0\n    r = []\n    for i in range(N):\n        if result > K:\n            break\n        if not r or a[i][0] < r[-1]:\n            result += 1\n            r.append(a[i][0])\n    return result"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # the input:\n    # a list of integers of the \"home assistants\", a list of integers of the \"quality of jokes\" of each assistant and a list of integers of the \"self-esteem boosts\" of each assistant\n    n, k = [int(x) for x in stdin.split()]\n    a = [int(x) for x in stdin.split(\"\\n\")[1].split(\" \")]\n    b = [int(x) for x in stdin.split(\"\\n\")[2].split(\" \")]\n    # create a dictionary with the assistants and their qualities\n    dict_assistants = dict()\n    for i in range(n):\n        dict_assistants[i+1] = (a[i], b[i])\n    # sort the list by the quality\n    a_sorted = sorted(dict_assistants.items(), key=lambda x: x[1])\n    # create a list of lists to check\n    list_values = list()\n    list_keys = list()\n    for i in range(n):\n        list_values.append([])\n        list_keys.append([])\n        for j in range(n):\n            list_values[i].append(a_sorted[j][1][0])\n            list_keys[i].append(a_sorted[j][0])\n    # create a dictionary with the key of each rank\n    dict_rank = dict()\n    # start to fill up the ranks and check\n    rank = 1\n    # add the first value to the rank\n    list_values[0][1] += k\n    if list_values[0][1] <= list_values[1][1]:\n        # assign the first rank\n        dict_rank[list_keys[0][1]] = rank\n        # check the rest of the lists for the rest of the values\n        for i in range(1, n):\n            # if this is not the last element, check if the next value is higher than the previous\n            if i < n-1:\n                if list_values[i][i+1] + k < list_values[i+1][i+1]:\n                    rank += 1\n                    dict_rank[list_keys[i][i+1]] = rank\n                else:\n                    break\n            # if this is the last element, check if the value of the next element is higher than the previous\n            else:\n                if list_values[i][i-1] + k < list_values[i-1][i-1]:\n                    rank += 1\n                    dict_rank[list_keys[i][i-1]] = rank\n    # create the new list of lists for the next iteration\n    list_values = list()\n    list_keys = list()\n    for i in range(n):\n        list_values.append([])\n        list_keys.append([])\n    # start to fill up the ranks and check\n    rank = 1\n    # add the first value to the rank\n    list_values[0][1] += k\n    if list_values[0][1] <= list_values[1][1]:\n        # assign the first rank\n        dict_rank[list_keys[0][1]] = rank\n        # check the rest of the lists for the rest of the values\n        for i in range(1, n):\n            # if this is not the last element, check if the next value is higher than the previous\n            if i < n-1:\n                if list_values[i][i+1] + k < list_values[i+1][i+1]:\n                    rank += 1\n                    dict_rank[list_keys[i][i+1]] = rank\n                else:\n                    break\n            # if this is the last element, check if the value of the next element is higher than the previous\n            else:\n                if list_values[i][i-1] + k < list_values[i-1][i-1]:\n                    rank += 1\n                    dict_rank[list_keys[i][i-1]] = rank\n    # for i in range(n):\n    #     print(list_values[i])\n    # print(list_keys)\n    # print(dict_rank)\n    # create a dictionary with the key of each rank\n    # dict_rank = dict()\n    # for key, value in dict_assistants.items():\n    #     if value[0] + k <= value[1]:\n    #         dict_rank[key] = rank\n    #         rank += 1\n    #     else:\n    #         break\n    # # start to fill up the ranks and check\n    # rank = 1\n    # list_values = list()\n    # list_keys = list()\n    # for i in range(n):\n    #     list_values.append([])\n    #     list_keys.append([])\n    #     for j in range(n):\n    #         list_values[i].append(dict_assistants[list_keys[i][j]][0])\n    #         list_keys[i].append(list_keys[i][j])\n    # # check the list\n    # for i in range(n):\n    #     # if this is not the last element, check if the next value is higher than the previous\n    #     if i < n-1:\n    #         if list_values[i][i+1] + k < list_values[i+1][i+1]:\n    #             rank += 1\n    #             dict_rank[list_keys[i][i+1]] = rank\n    #         else:\n    #             break\n    #     # if this is the last element, check if the value of the next element is higher than the previous\n    #     else:\n    #         if list_values[i][i-1] + k < list_values[i-1][i-1]:\n    #             rank += 1\n    #             dict_rank[list_keys[i][i-1]] = rank\n    # print(dict_rank)\n    # print(rank)\n    # create a new list of lists\n    # list_values = list()\n    # for i in range(n):\n    #     list_values.append([])\n    #     for j in range(n):\n    #         list_values[i].append(dict_assistants[list_keys[i][j]][0])\n    # # create a new list of lists for the next iteration\n    # list_values_new"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(test_input)\n    expected result\n    \"\"\"\n    # your code here\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[:n]))\n    b = list(map(int, stdin.split()[n:]))\n    a.sort()\n    b.sort()\n    i = 1\n    j = 1\n    c = 1\n    d = 1\n    while i < n and j < n:\n        if a[i] + k < b[j]:\n            c += 1\n            j += 1\n        elif a[i] + k > b[j]:\n            c += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n            j += 1\n    return c\n"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num, k = [int(x) for x in stdin.split()]\n    a = [int(x) for x in stdin.splitlines()[1].split()]\n    b = [int(x) for x in stdin.splitlines()[2].split()]\n\n    diff = [a[i] - b[i] for i in range(len(a))]\n    tot = sum(diff)\n    if tot > k:\n        return tot\n    return num - 1"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # input() #take input, split into list, then convert to int\n    # num_assistants, difference_limit = [int(i) for i in stdin.split()]\n    # assistant_quality = [int(i) for i in stdin.split()]\n    # #print(num_assistants)\n    # #print(difference_limit)\n    # #print(assistant_quality)\n    # #print(len(assistant_quality))\n    # #print(len(set(assistant_quality)))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(assistant_quality))\n    # #print(len(set(assistant_quality)))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(assistant_quality))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality))))\n    # #print(len(list(set(assistant_quality"
    },
    {
        "number": 3008,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    a.sort()\n    b.sort()\n    distinct_count = 0\n    cur_rank = 0\n    for i in range(n):\n        if a[i] + k < b[i]:\n            distinct_count += 1\n            cur_rank += 1\n    return str(distinct_count)\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    l = []\n    for _ in range(N):\n        x, y, e = map(int, stdin.split())\n        l.append((x, y, e))\n    l.sort()\n\n    dp = [0] * N\n    ans = 0\n    for i, (x, y, e) in enumerate(l):\n        left = max(0, dp[i-1] - e) if i > 0 else 0\n        right = max(0, dp[i] - e)\n        ans = max(ans, x - left, x + right)\n        dp[i] = left + e + right\n    return str(ans)\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the shortest line dividing positive and negative energy sources.\n\n    Args:\n        stdin (str): Input of lines of integers, each representing the x and y\n        coordinates of a lamp and its energy contribution.\n\n    Returns:\n        str: If no such line exists, returns IMPOSSIBLE, otherwise returns a real\n        number, the length of the shortest continuous line dividing the positive\n        and negative energy sources in the room.\n    \"\"\"\n\n    def check_line(x1, y1, x2, y2, x3, y3, x4, y4):\n        \"\"\"Checks if the line from a point to a second point meets the requirements.\n\n        Args:\n            x1 (int): x coordinate of a point.\n            y1 (int): y coordinate of a point.\n            x2 (int): x coordinate of another point.\n            y2 (int): y coordinate of another point.\n            x3 (int): x coordinate of a line.\n            y3 (int): y coordinate of a line.\n            x4 (int): x coordinate of another line.\n            y4 (int): y coordinate of another line.\n\n        Returns:\n            bool: Whether the line meets the requirements.\n        \"\"\"\n        return ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))!= 0\n\n    number_of_lamps = int(stdin.readline())\n    total_lamps = sum(\n        [\n            [int(j) for j in i.split(\" \")]\n            for i in stdin.readlines()\n            if i!= \"\\n\"\n        ]\n    )\n\n    lamp_points = []\n    for i in range(number_of_lamps):\n        for j in range(3):\n            lamp_points.append(int(stdin.readline()))\n\n    # Create the list of points in the room\n    points = []\n    for i in range(number_of_lamps):\n        for j in range(3):\n            points.append((i + 1, lamp_points[j + i * 3]))\n\n    # Create the list of points on the line\n    lines = []\n    for i in range(number_of_lamps):\n        for j in range(3):\n            lines.append((i + 1, lamp_points[j + i * 3]))\n\n    min_length = 10000000000\n    # Check all possible lines\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            if j == i + 1:\n                length = 0\n            else:\n                if check_line(\n                    points[i][0],\n                    points[i][1],\n                    points[j][0],\n                    points[j][1],\n                    lines[i][0],\n                    lines[i][1],\n                    lines[j][0],\n                    lines[j][1],\n                ):\n                    length = 0\n                else:\n                    length = (\n                        abs(points[i][0] - points[j][0])\n                        + abs(points[i][1] - points[j][1])\n                    )\n\n            if length < min_length:\n                min_length = length\n\n    if min_length == 10000000000:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(min_length)\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solves the problem \"\"\"\n    lamps = int(stdin.split('\\n')[0])\n    lamps_list = []\n    lamps_dict = dict()\n\n    for i in range(lamps):\n        x, y, e = map(int, stdin.split('\\n')[i + 1].split(' '))\n        lamps_list.append([x, y, e])\n        lamps_dict[(x, y)] = e\n\n    if lamps <= 2:\n        return 'IMPOSSIBLE'\n\n    points = sorted(list(lamps_dict.keys()), key=lambda x: x[0])\n    dist = []\n\n    for i in range(len(points) - 1):\n        if points[i][0] == points[i + 1][0]:\n            d = abs(points[i + 1][1] - points[i][1])\n        elif points[i][1] == points[i + 1][1]:\n            d = abs(points[i + 1][0] - points[i][0])\n        else:\n            d = abs(points[i + 1][0] - points[i][0]) + abs(points[i + 1][1] - points[i][1])\n\n        dist.append(d)\n\n    return max(dist)\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the length of the line dividing the positive and negative energies in the room.\"\"\"\n    lamps = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")]\n    inside = set()\n    outside = set()\n    for x, y, e in lamps:\n        if e > 0:\n            inside.add((x, y))\n        else:\n            outside.add((x, y))\n    return min(abs(x) + abs(y) for x, y in itertools.chain(inside, outside) if (x, y) not in inside or (x, y) not in outside)\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns shortest line.\n\n    >>> solution(\"4\\n10 10 5\\n10 20 1\\n20 10 12\\n20 20 8\\n\")\n    '28.97152577'\n    \"\"\"\n\n    # read file and turn into list of lists\n    lamps = [line.split(\" \") for line in stdin.split(\"\\n\")]\n    # find number of lamps\n    n = int(lamps[0][0])\n    # all entries in list must be integers\n    lamps = [[int(x) for x in row] for row in lamps[1:]]\n    # x and y values of lamps must be positive\n    for lamp in lamps:\n        if lamp[0] < 1 or lamp[1] < 1:\n            return \"IMPOSSIBLE\"\n    # get longest distance\n    longest = max([max(row) - min(row) for row in lamps])\n\n    # find position of longest lamp\n    for row in lamps:\n        if max(row) - min(row) == longest:\n            left, right = min(row), max(row)\n\n    # calculate total energy\n    energy = 0\n    for lamp in lamps:\n        energy += sum(lamp)\n\n    # calculate energy outside\n    outside = 0\n    for row in lamps:\n        if min(row) < left or max(row) > right:\n            outside += sum(row)\n    # calculate total energy\n    energy += outside\n    # calculate the length of the line\n    return str(round(abs(energy), 6))\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the length of the shortest line separating positive and negative energy.\n\n    Parameters:\n    stdin (str): Input string.\n\n    Returns:\n    str: Output string.\n    \"\"\"\n    lamps = []\n    for i in range(1, 12):\n        lamps.append([int(i) for i in stdin.split('\\n')[i].split()])\n\n    outside = []\n    for i in range(len(lamps)):\n        outside.append([])\n        for j in range(len(lamps)):\n            outside[-1].append(lamps[j][0] - lamps[i][0])\n            outside[-1].append(lamps[j][1] - lamps[i][1])\n\n    for lamp in lamps:\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(lamp[0] - lamps[i][0])\n            outside[-1].append(lamp[1] - lamps[i][1])\n\n    def solve(lines):\n        tot = 0\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                if lines[i][0] * lines[j][0] + lines[i][1] * lines[j][1] > 0:\n                    tot += lines[i][0] * lines[j][0] + lines[i][1] * lines[j][1]\n        return tot\n\n    def get(lines, tot):\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                if lines[i][0] * lines[j][0] + lines[i][1] * lines[j][1] == tot:\n                    return lines[i], lines[j]\n\n    def coords(line):\n        return line[0] / line[1]\n\n    def check(line, coords):\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        outside.append([])\n        for i in range(len(lamps)):\n            outside[-1].append(lamps[i][0] - line[0])\n            outside[-1].append(line[1] - lamps[i][1])\n\n        for i in range(len(lamps)):\n            outside[-1].append(line[0] - lamps[i][0])\n            outside[-1].append(lamps[i][1] - line[1])\n\n        outside.append([])\n        for i in range(len(lamps"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(solve(stdin))\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    # lines = stdin.split('\\n')\n    # lines = lines[:-1]\n    # answer = \"IMPOSSIBLE\"\n    # answer = float(\"inf\")\n    # for line in lines:\n    #     pos, neg = line.split(' ')\n    #     pos = int(pos)\n    #     neg = int(neg)\n    #     if pos + neg > answer:\n    #         break\n    #     if neg < 0:\n    #         answer = pos + neg\n    # print(answer)\n    # return answer\n"
    },
    {
        "number": 3009,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_lamps = int(stdin.split('\\n')[0])\n    lamps = []\n    for i in range(1, num_lamps + 1):\n        x, y, e = [int(i) for i in stdin.split('\\n')[i].split()]\n        lamps.append((x, y, e))\n\n    min_res = float('inf')\n    lamps.sort(key=lambda lamp: lamp[2])\n    while True:\n        lamp = lamps.pop()\n        res = process(lamp[0], lamp[1])\n        if res < min_res:\n            min_res = res\n        else:\n            break\n    return str(min_res)\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    num_lines = int(lines[0])\n    points = []\n    for line in lines[1:]:\n        xs, ys = line.split()\n        xs = int(xs)\n        ys = int(ys)\n        points.append((xs, ys))\n    points = set(points)\n    n = len(points)\n    if n < 3:\n        return str(n)\n    if n == 3:\n        return '0'\n    ans = []\n    for x0, y0 in points:\n        for x1, y1 in points:\n            if (x0 == x1 or y0 == y1):\n                continue\n            elif (x0 > x1 and y0 > y1) or (x0 < x1 and y0 < y1):\n                continue\n            elif x0 == x1:\n                ans.append((x0, y0, x0, y1))\n            elif y0 == y1:\n                ans.append((x0, y0, x1, y0))\n            elif y0 > y1:\n                ans.append((x0, y0, x1, y0))\n                ans.append((x0, y0, x0, y1))\n            elif y0 < y1:\n                ans.append((x0, y0, x0, y1))\n                ans.append((x1, y1, x1, y1))\n    ans = [str(len(set(tuple(i) for i in ans))) for ans in ans]\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\""
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n\"\"\"\n\ndef"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the given problem\"\"\"\n    \n    pass\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lines(s):\n        points = []\n        i = 0\n        while i < len(s):\n            points.append(s[i:i + 2])\n            i += 2\n        return points\n\n    points = []\n    for line in stdin.split('\\n'):\n        points.append(lines(line))\n\n    # print(points)\n\n    def intersects(s1, s2):\n        x0, y0, x1, y1 = s1\n        x2, y2, x3, y3 = s2\n        return (x0 * y2 - y0 * x2) * (x3 - x2) - (x0 - x2) * (x1 * y3 - y1 * x3)!= 0\n\n    points = [set(p) for p in points]\n    count = 0\n    for i, p1 in enumerate(points):\n        for j, p2 in enumerate(points[i+1:]):\n            if p1 & p2:\n                count += 1\n    return count\n\nprint(solution('3\\n1 3 9 5\\n2 2 6 8\\n4 8 9 3'))\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution of the math problem.\"\"\"\n    # The input is an array of arrays of 2 integers.\n    # We can just loop through the arrays and create a set of tuples\n    # for each line. If that set is the same, then the points are collinear.\n    return str(sum(len(set(tuple(x) for x in line)) for line in stdin.split('\\n') if line))\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the number of distinct points where the line segments intersect.\"\"\"\n    stdin = stdin.split('\\n')\n    dic = {}\n    for i in range(len(stdin)):\n        a, b, c, d = map(int, stdin[i].split())\n        for j in range(a, c+1):\n            for k in range(b, d+1):\n                if not dic.get((j, k), 0):\n                    dic[(j, k)] = 1\n                else:\n                    dic[(j, k)] += 1\n    count = 0\n    for key in dic:\n        if dic[key] >= 2:\n            count += 1\n    return count\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Problem solution.\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Output.\n\n    \"\"\"\n    _, *inp = stdin.split(\"\\n\")\n    for _ in range(int(inp[0])):\n        x0, y0, x1, y1 = map(int, inp[1].split())\n        if x0 == x1:\n            return str(y0)\n        elif y0 == y1:\n            return str(x0)\n        elif x0 * y1 == x1 * y0:\n            return \"0\"\n        elif x0 * y1 < x1 * y0:\n            return \"0\"\n        else:\n            return \"1\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # for line in stdin:\n    #     # print(line)\n    #     x0, y0, x1, y1 = map(int, line.split())\n    #     for line in stdin:\n    #         # print(line)\n    #         x2, y2, x3, y3 = map(int, line.split())\n    #         if (x0 == x1 and y0 == y2) or (x0 == x1 and y0 == y3) or (x0 == x2 and y0 == y1) or (x0 == x2 and y0 == y3) or (x0 == x3 and y0 == y1) or (x0 == x3 and y0 == y2) or (x1 == x2 and y1 == y2) or (x1 == x2 and y1 == y3) or (x1 == x3 and y1 == y2) or (x1 == x3 and y1 == y3) or (x2 == x3 and y2 == y3):\n    #             return 1\n\n    # return -1\n\n    # res = set()\n    # for line in stdin:\n    #     x0, y0, x1, y1 = map(int, line.split())\n    #     for line in stdin:\n    #         x2, y2, x3, y3 = map(int, line.split())\n    #         if (x0 == x1 and y0 == y2) or (x0 == x1 and y0 == y3) or (x0 == x2 and y0 == y1) or (x0 == x2 and y0 == y3) or (x0 == x3 and y0 == y1) or (x0 == x3 and y0 == y2) or (x1 == x2 and y1 == y2) or (x1 == x2 and y1 == y3) or (x1 == x3 and y1 == y2) or (x1 == x3 and y1 == y3) or (x2 == x3 and y2 == y3):\n    #             res.add((x0, y0))\n    #             res.add((x1, y1))\n    #             res.add((x2, y2))\n    #             res.add((x3, y3))\n    #             return len(res)\n\n    # return -1\n\n    res = set()\n    points = set()\n    for line in stdin:\n        x0, y0, x1, y1 = map(int, line.split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n        for line in stdin:\n            x2, y2, x3, y3 = map(int, line.split())\n            points.add((x2, y2))\n            points.add((x3, y3))\n            if (x0 == x1 and y0 == y2) or (x0 == x1 and y0 == y3) or (x0 == x2 and y0 == y1) or (x0 == x2 and y0 == y3) or (x0 == x3 and y0 == y1) or (x0 == x3 and y0 == y2) or (x1 == x2 and y1 == y2) or (x1 == x2 and y1 == y3) or (x1 == x3 and y1 == y2) or (x1 == x3 and y1 == y3) or (x2 == x3 and y2 == y3):\n                res.add((x0, y0))\n                res.add((x1, y1))\n                res.add((x2, y2))\n                res.add((x3, y3))\n\n    return len(res)\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # if len(str(n)) == 1:\n    #     return 1 if int(n) < 10 else 0\n    # if len(str(n)) > 1:\n    #     for i in range(1, len(str(n))):\n    #         if int(str(n)[i]) - int(str(n)[i - 1]) == int(str(n)[i - 1]) - int(str(n)[i]):\n    #             return 1 + solution(str(n)[:i]) + solution(str(n)[i:])\n    #     return -1\n    return 1 + solution(str(n)[:i]) + solution(str(n)[i:]) if len(str(n)) > 1 else 1 if int(n) < 10 else 0\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n: int = int(stdin)\n    count: int = 0\n    if n < 10:\n        return n\n    elif n < 100:\n        for i in range(1, n):\n            if i * (i + 1) == n:\n                count += 1\n        return count + 1\n    elif n < 1000:\n        for i in range(1, 10):\n            for j in range(10):\n                if i * (i + 1) + j * (j + 1) == n:\n                    count += 1\n        return count\n    elif n < 10000:\n        for i in range(1, 10):\n            for j in range(10):\n                for k in range(10):\n                    if i * (i + 1) + j * (j + 1) + k * (k + 1) == n:\n                        count += 1\n        return count\n    elif n < 100000:\n        for i in range(1, 100):\n            for j in range(100):\n                for k in range(100):\n                    if i * (i + 1) + j * (j + 1) + k * (k + 1) == n:\n                        count += 1\n        return count\n    elif n < 1000000:\n        for i in range(1, 100):\n            for j in range(100):\n                for k in range(100):\n                    for l in range(100):\n                        if i * (i + 1) + j * (j + 1) + k * (k + 1) + l * (l + 1) == n:\n                            count += 1\n        return count\n    elif n < 10000000:\n        for i in range(1, 100):\n            for j in range(100):\n                for k in range(100):\n                    for l in range(100):\n                        for m in range(100):\n                            if i * (i + 1) + j * (j + 1) + k * (k + 1) + l * (l + 1) + m * (m + 1) == n:\n                                count += 1\n        return count\n    return -1\n\nprint(solution(input()))"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return number of hill numbers < x.\"\"\"\n    pass\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return 'wrong output'\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    \n    \n    n = int(stdin)\n    if n <= 0:\n        print(-1)\n        return\n    \n    nums = list(range(1, n + 1))\n    for i in range(n):\n        nums[i] = str(nums[i])\n    nums = sorted(nums)\n    if int(nums[0])!= 1:\n        print(-1)\n        return\n    for i in range(n):\n        if int(nums[i])!= i + 1:\n            print(-1)\n            return\n    print(n)\n    return"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    return stdin"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    length = len(n)\n    if length == 1:\n        return 1\n    count = 0\n    for i in range(1, length + 1):\n        for j in range(0, length - i + 1):\n            sub = n[j:j + i]\n            if i > len(sub):\n                continue\n            if sub == sub[::-1]:\n                count += 1\n    return count\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3011,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dig(n: str) -> list:\n        return [int(x) for x in n]\n\n    def sift(n: list, i: int, j: int) -> list:\n        a = n[i]\n        n[i] = n[j]\n        n[j] = a\n\n    def is_hill(n: list, i: int, j: int) -> bool:\n        if i == j:\n            return True\n        if n[i] == n[j]:\n            return False\n        if n[i] < n[j]:\n            sift(n, i, j - 1)\n            if is_hill(n, i, j - 1):\n                return True\n            sift(n, i, j - 1)\n        if n[i] > n[j]:\n            sift(n, i, j + 1)\n            if is_hill(n, i, j + 1):\n                return True\n            sift(n, i, j + 1)\n        return False\n\n    n = stdin\n    n = dig(n)\n    if is_hill(n, 0, len(n) - 1):\n        return str(len(n) - 1)\n    return '-1'\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 0 0 0 3''')\n    '6'\n    >>> solution('''1 2 0 0 5''')\n    '2'\n    >>> solution('''1 2 0 0 4''')\n    '4'\n    >>> solution('''1 2 0 0 6''')\n    '0'\n    \"\"\"\n    a = list(map(int, stdin.split()))\n    n = a[4]\n    # len(set([(i, j) for i in range(1, n) for j in range(1, n)]))\n    return str(n * (n - 1) // 2 * (n - 2) * (n - 3))"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, n = [int(x) for x in stdin.split()]\n    # total = factorial(a) * factorial(b) * factorial(c) * factorial(d)\n    total = reduce(lambda x, y: x * y, [factorial(a), factorial(b), factorial(c), factorial(d)])\n    s = a + b + c + d\n    if s == 1 or s == 2 or s == 3:\n        return total // (2 * (factorial(s) * factorial(2 * s)))\n    elif s == 4:\n        return total // (factorial(s) * (factorial(s - 3) * (factorial(3 * s) * factorial(s - 2) ** 2)))\n    elif s == 5:\n        return total // (factorial(s) * (factorial(s - 3) * (factorial(3 * s) * factorial(s - 2) ** 2) + factorial(s - 4) * (factorial(3 * s) * factorial(s - 4) * factorial(2 * s) ** 2)))\n    else:\n        return total // (factorial(s) * (factorial(s - 3) * (factorial(3 * s) * factorial(s - 2) ** 2) + factorial(s - 4) * (factorial(3 * s) * factorial(s - 4) * factorial(2 * s) ** 2) + factorial(s - 6) * (factorial(3 * s) * factorial(s - 6) * factorial(2 * s) ** 2)))\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = map(int, stdin.split())\n    dp = [0] * (n + 1)\n    dp[1] = a11 + a12\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + (a11 + a12) * (a11 + a12) + a21 * (a11 + a12) + a22 * a22\n    return dp[-1] % (10 ** 9 + 7)\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = map(int, stdin.split())\n    MOD = 10 ** 9 + 7\n    comb1 = (a12 + a22 + n - 1) * n // 2\n    comb2 = n * (n + 1) // 2\n    return (comb1 - comb2) % MOD\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    N = a[4]\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i == j:\n                continue\n            for k in range(1, N + 1):\n                if k == i or k == j:\n                    continue\n                count += 1\n\n    return count % 1000000007\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, n = [int(i) for i in stdin.split(\" \")]\n    MOD = 1000000007\n    dp = [0] * (n + 1)\n    dp[1] = a11 + a12\n    dp[2] = (a11 + a21) * n + (a12 + a22) * n + (a12 + a22)\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 2] + dp[i - 1]) * n + dp[i - 1]\n    return dp[n] % MOD\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution template.\n    \"\"\"\n    a11, a12, a21, a22, N = [int(x) for x in stdin.split()]\n    return (\n        f\"{len(find_sequences(a11, a12, a21, a22, N)) % 1000000007}\"\n    )\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The idea is to find a fixed length sequence of moves.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Count the possible sequences of moves.\n\n    Args:\n        stdin (str): Input string in UTF-8.\n\n    Returns:\n        str: The output string in UTF-8.\n    \"\"\"\n    inputs = list(map(int, stdin.split(' ')))\n    a11, a12, a21, a22, n = inputs\n    return str(count_sequences(a11, a12, a21, a22, n))\n\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, n = [int(s) for s in stdin.split(' ')]\n    ans = 0\n    p = [a, b, c, d]\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                if p[i] + p[j]!= p[k]:\n                    ans += 1\n    return str(ans % 1000000007)\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, x, y = [float(n) for n in stdin.split()]\n    r = b * np.sqrt(2)\n    phi = np.arctan(r)\n    # phi = np.arccos(1 / b)\n    # r = np.sqrt(1 / b)\n\n    x, y = x / r, y / r\n\n    phi_diff = np.arccos(x) - np.arccos(y)\n    theta = np.arccos(np.cos(phi - phi_diff))\n\n    return f\"{np.cos(theta) * r:.5f} {np.sin(theta) * r:.5f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    (b, t_x, t_y) = [float(x) for x in stdin.split()]\n    (i, t) = (0, 0)\n    while t < 10 ** -5 or abs(i) < 1:\n        if i == 0:\n            r = b\n        else:\n            r = b * abs(i)\n        t = t_x * t_x + t_y * t_y\n        if t >= r ** 2:\n            t = r ** 2 - t\n        i += t_x / t_y\n        t_y -= t\n    t_y = - t_y\n    t_x = - i * t_y\n    return \"{} {}\".format(t_x, t_y)\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the point on the Archimedean spiral where the avatar should leave the spiral in the direction it is currently moving, and hit the target without intersecting the spiral.\"\"\"\n    b, tx, ty = map(float, stdin.split())\n    t = math.sqrt(tx ** 2 + ty ** 2)\n    if t < 2 * math.pi * b:\n        return str(math.floor(tx / t)) + \" \" + str(math.floor(ty / t))\n    else:\n        r = math.floor(t / (2 * math.pi * b))\n        theta = math.atan(ty / tx)\n        a = b ** 2\n        b = 2 * (a + b ** 2)\n        c = 2 * math.cos(theta) ** 2\n        d = b ** 2 - 4 * a * c\n        x1 = (-b + math.sqrt(d)) / (2 * a)\n        x2 = (-b - math.sqrt(d)) / (2 * a)\n        if abs(x1 - tx) < abs(x2 - tx):\n            return str(math.floor(x1)) + \" \" + str(math.floor(ty / x1))\n        else:\n            return str(math.floor(x2)) + \" \" + str(math.floor(ty / x2))\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the point on the spiral where the avatar should leave the spiral,\n    continue in the direction it is moving, and hit the target without\n    intersecting the spiral.\"\"\"\n    _, b, t_x, t_y = map(float, stdin.split())\n    phi = np.arctan2(t_y, t_x)\n    b_i = np.arange(b, b + 1, 1)\n    r = b_i * phi\n    x = r * np.cos(phi)\n    y = r * np.sin(phi)\n    return f\"{x[0]},{y[0]}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = map(float, stdin.split())\n    r = b * t_x\n    phi = np.arctan2(t_y, t_x)\n    theta = np.arctan(r / b)\n    phi += theta\n\n    return f\"{b * np.cos(phi) + t_x:.3f} {b * np.sin(phi) + t_y:.3f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds point on spiral where the player should press the button in order to hit the target\n    \"\"\"\n    b, t_x, t_y = map(float, stdin.split(' '))\n    if t_x < -10000 or t_x > 10000 or t_y < -10000 or t_y > 10000:\n        return 'INPUT ERROR!'\n    t_r = sqrt(t_x**2 + t_y**2)\n    if t_r < 10**-3 or t_r >= 2 * pi * b:\n        return 'INPUT ERROR!'\n    t_phi = atan2(t_y, t_x)\n    t_x = t_r * cos(t_phi)\n    t_y = t_r * sin(t_phi)\n    return f'{t_x:.5f} {t_y:.5f}'\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = [float(x) for x in stdin.split()]\n    t_x /= 100\n    t_y /= 100\n    r = b * t_x\n    phi = t_y\n    x = r * sin(phi)\n    y = r * cos(phi)\n    return f'{x:.4f} {y:.4f}'\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, x, y = map(float, stdin.split())\n    b = 2 * math.pi * a\n    x /= b\n    y /= b\n    z = math.sqrt(x**2+y**2)\n    if z < 0.0001:\n        x = 0.0\n        y = 0.0\n    elif z > 10 ** 3:\n        x = 0.0\n        y = 0.0\n    else:\n        k = math.acos(z)\n        u = math.atan2(y, x)\n        if u < 0:\n            u += 2*math.pi\n        n = u / k\n        if n < 0:\n            n += 1\n        while n > 2 * math.pi:\n            n -= 2*math.pi\n        x = math.cos(n * k)\n        y = math.sin(n * k)\n    return f\"{x:.5f} {y:.5f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, b, t_x, t_y = stdin.split()\n    b, t_x, t_y = map(float, [b, t_x, t_y])\n\n    t_x, t_y = t_x * math.pi, t_y * math.pi\n    r = b * t_x\n    phi = math.acos(b / r)\n    return f'{r * math.cos(phi) + t_x:.5f} {r * math.sin(phi) + t_y:.5f}'\n"
    },
    {
        "number": 3013,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for the problem.\n\n    Args:\n        stdin (str): Input string.\n\n    Returns:\n        str: Solution to the problem.\n    \"\"\"\n    # Get inputs\n    b, tx, ty = stdin.split()\n    b, tx, ty = float(b), float(tx), float(ty)\n\n    # Perform the calculations\n    x, y = (b * ty / tx, ty) if tx!= 0 else (0, 0)\n\n    # Return the solution\n    return f\"{x:.5f} {y:.5f}\"\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution to the cryptopuzzle on the fifth day of Advent of Code 2020.\"\"\"\n    # Split input into a list of lists\n    corridors = list(map(list, stdin.splitlines()))\n\n    # Find the starting point of the algorithm\n    start = set(corridors[0]).intersection(set(corridors[1]))\n    if start:\n        start = next(iter(start))\n    else:\n        start = min(corridors[0])\n\n    # Return the result of the algorithm\n    return len(corridors) - sum(\n        line.index(start)\n        for line in corridors\n    )\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem\"\"\"\n    # Get input\n    rooms = int(stdin.readline().rstrip(\"\\n\"))\n    corr = int(stdin.readline().rstrip(\"\\n\"))\n\n    # Initialize graph\n    G = [[] for i in range(rooms)]\n\n    # Initialize visited\n    visited = [False for i in range(rooms)]\n\n    # For each edge, add it to the graph\n    for i in range(corr):\n        u, v = [int(j) - 1 for j in stdin.readline().rstrip(\"\\n\").split()]\n\n        G[u].append(v)\n        G[v].append(u)\n\n    # Initialize total undirected edges\n    total = 0\n\n    # For each room, check if it is the root\n    for room in range(rooms):\n        # If it is, increment total undirected edges and mark it\n        if visited[room]:\n            total += len(G[room])\n            visited[room] = True\n        # Otherwise, if it has any outbound edges,\n        # mark it and add all of its outbound edges to the total\n        elif G[room]:\n            visited[room] = True\n            total += len(G[room])\n            for v in G[room]:\n                visited[v] = True\n\n    # Return solution\n    return str(total - len(visited))\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    for _ in range(m):\n        u, v = map(int, stdin.split(' '))\n        if u > v:\n            u, v = v, u\n        print(u, v)\n    return ''\n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Solution:\n    pass\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n\n    rooms = int(lines[0].split()[0])\n    corrs = int(lines[0].split()[1])\n    corrs_list = []\n\n    for i in range(1, corrs + 1):\n        corrs_list.append(tuple(map(int, lines[i].split())))\n\n    removed = corrs // 2\n    corrs_removed = []\n\n    for i in range(rooms):\n        corrs_in_room = []\n        for j in range(corrs):\n            if i == corrs_list[j][0] or i == corrs_list[j][1]:\n                corrs_in_room.append(j)\n        corrs_removed.append(len(corrs_in_room))\n\n    return removed, corrs_removed"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    \n"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the number of corridors to be removed to ensure that dancers cannot go around in circles in the disco anymore.\n    >>> solution('2 2\\n1 2\\n2 1\\nSample Input 3: 4 5\\n1 2\\n2 3\\n2 4\\n3 1\\n4 1\\nSample Output 3:0\\nSample Input 4: 4 5\\n1 2\\n2 3\\n2 4\\n3 1\\n4 1\\nSample Output 4:2\\n')\n    2\n    \"\"\"\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    rooms = [set() for _ in range(n)]\n    corridors = set()\n    for _ in range(m):\n        u, v = map(int, stdin.split('\\n')[1 + _].split(' '))\n        rooms[u - 1].add(v - 1)\n        rooms[v - 1].add(u - 1)\n        corridors.add((u - 1, v - 1))\n    all_rooms = set(range(n))\n    # pylint: disable=redundant-keyword-arg\n    connected_rooms = dfs(corridors, rooms, all_rooms, 0, -1)\n    print(len(corridors) - len(connected_rooms))\n    for corridor in corridors:\n        print(corridor[0] + 1, corridor[1] + 1)\n\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n = int(lines[0].split()[0])\n    m = int(lines[0].split()[1])\n    rooms = [int(c) for c in lines[1].split()]\n    corr = [tuple(int(c) for c in l.split()) for l in lines[2:]]\n    corr_cnt = len(corr)\n    rooms_set = set(rooms)\n\n    for c in corr:\n        if c[0] in rooms_set and c[1] in rooms_set:\n            rooms_set.remove(c[0])\n            rooms_set.remove(c[1])\n\n    cnt = 0\n    for c in corr:\n        if c[0] in rooms_set and c[1] in rooms_set:\n            cnt += 1\n    rooms_set = set(rooms)\n\n    for c in corr:\n        if c[0] in rooms_set and c[1] in rooms_set:\n            rooms_set.remove(c[0])\n            rooms_set.remove(c[1])\n\n    if cnt == corr_cnt // 2:\n        return str(cnt)\n    return''.join([str(c) for c in sorted(rooms_set)])\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds out how long it will take for Harry to get to his bed.\n    \"\"\"\n    data = list(map(int, stdin.split()))\n    n, m, s, t = data[0:4]\n\n    tube = []\n    for _ in range(m):\n        start, end, time = map(int, stdin.split()[:3])\n        tube.append((start, end, time))\n    tube.sort(key=lambda x: x[2])\n    # print(tube)\n\n    def calc_time(ball):\n        return sum(time for start, end, time in tube if start == ball)\n\n    ans = calc_time(s)\n    for i in range(n - 1):\n        time_to_ball = calc_time(i)\n        time_to_bed = calc_time(i + 1)\n        ans = min(ans, time_to_bed + max(time_to_ball, ans))\n\n    return 'infinity' if ans >= 10 ** 4 else ans\n\n\ndef"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4 5 0 3\\n0 1 1\\n1 2 1\\n2 0 4\\n2 3 1\\n2 3 3\")\n    11\n\n    >>> solution(\"5 5 0 4\\n0 1 1\\n1 2 1\\n2 3 1\\n3 0 1\\n2 4 1\")\n    'infinity'\n\n    >>> solution(\"2 1 0 1\\n0 1 2\")\n    2\n\n    >>> solution(\"3 3 1 2\\n0 1 1\")\n    'infinity'\n    \"\"\"\n    n, m, s, t = [int(num) for num in stdin.split()]\n    dist = [[float(\"inf\") for j in range(n)] for i in range(2)]\n    for _ in range(m):\n        a, b, w = [int(num) for num in stdin.split()]\n        dist[0][a] = min(dist[0][a], w)\n        dist[1][b] = min(dist[1][b], w)\n\n    for i in range(2):\n        dist[i][s] = 0\n    for i in range(n):\n        update = [float(\"inf\") for j in range(n)]\n        for j in range(2):\n            for k in range(n):\n                if dist[j][k] < update[k]:\n                    update[k] = dist[j][k]\n        for j in range(n):\n            if dist[1 - j % 2][j] < update[j]:\n                dist[1 - j % 2][j] = update[j]\n    for i in range(2):\n        if dist[i][t] == float(\"inf\"):\n            return \"infinity\"\n    return dist[0][t] + dist[1][t]\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Use the time() function to measure the time of execution\n    # start = time()\n    # Code your solution here\n    # end = time()\n    # return 'Execution time:'+ str(round((end - start) * 1000, 1)) +'ms'\n    # Use the timeit() function to measure the time of execution\n    start = timeit.default_timer()\n    # code your solution here\n    end = timeit.default_timer()\n    return 'Execution time:'+ str(round((end - start) * 1000, 1)) +'ms'\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 5 0 3\\n0 1 1\\n1 2 1\\n2 0 4\\n2 3 1\\n2 3 3\\n')\n    11\n    \"\"\"\n    # DFS solution\n    # O(m + n^2) time\n    # O(m) space\n    stdin = stdin.split('\\n')\n    ball_n, tube_n, s, t = [int(x) for x in stdin[0].split()]\n    d = defaultdict(list)\n    for i in range(1, tube_n + 1):\n        ball1, ball2, time = [int(x) for x in stdin[i].split()]\n        d[ball1].append((ball2, time))\n        d[ball2].append((ball1, time))\n    if s == t:\n        return '0'\n    v = set()\n    queue = deque([(s, 0)])\n    while queue:\n        node, time = queue.popleft()\n        if node == t:\n            return time\n        if node not in v:\n            v.add(node)\n            for nei, time_to_nei in d[node]:\n                queue.append((nei, time + time_to_nei))\n    return 'infinity'\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the time it takes to reach the bed if the hamster can move in any direction at any time.\n\n    Args:\n        stdin (str): Input string to parse\n\n    Returns:\n        str: Time to reach bed\n    \"\"\"\n\n    m, n, s, t = [int(x) for x in stdin.split()]\n    tubes = []\n\n    for _ in range(m):\n        start, end, weight = [int(x) for x in stdin.split()]\n        tubes.append(\n            {\n                \"start\": start - 1,\n                \"end\": end - 1,\n                \"weight\": weight,\n            }\n        )\n\n    times = [float(\"inf\") for _ in range(n)]\n    for tube in tubes:\n        times[tube[\"start\"]] = tube[\"weight\"]\n        times[tube[\"end\"]] = float(\"inf\")\n\n    count = 1\n    while count < n:\n        if times[s - 1] < float(\"inf\"):\n            count += 1\n        times[s - 1] = float(\"inf\")\n\n        for tube in tubes:\n            if tube[\"start\"] == s - 1:\n                if (\n                    times[tube[\"end\"]] > tube[\"weight\"]\n                    and times[tube[\"start\"]] + tube[\"weight\"] < times[tube[\"end\"]]\n                ):\n                    times[tube[\"end\"]] = times[tube[\"start\"]] + tube[\"weight\"]\n                elif times[tube[\"end\"]] > tube[\"weight\"]:\n                    times[tube[\"end\"]] = tube[\"weight\"]\n\n    for time in times:\n        if time == float(\"inf\"):\n            return \"infinity\"\n\n    return str(max(times))\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the time it takes to reach bed after n turns of the hamster wheel.\n\n    Args:\n        stdin (str): Input of the form\n            n m s t\n            [tube lengths]\n            [connections]\n\n    Returns:\n        str: The time it takes to reach bed or 'infinity' if there is no path\n    \"\"\"\n    n, m, s, t = [int(i) for i in stdin.split()]\n    connections = []\n    for _ in range(m):\n        connections.append([int(i) for i in stdin.split()])\n\n    # initialise both the starting and ending points\n    visited = {s: 0}\n    frontier = [s]\n    # initialise the direction to be checked\n    direction = 1\n\n    # loop until the frontier is empty\n    while frontier:\n        next_frontier = []\n        for node in frontier:\n            for connection in connections:\n                # for each connection, check if it is valid\n                if connection[0] == node and node in visited and connection[1] == t:\n                    # return the time it took to reach the end\n                    return visited[node]\n                # if the connection is valid, check if it has been visited already\n                elif connection[0] == node and node in visited and connection[1] not in visited:\n                    # if it hasn't been visited, add it to the visited dictionary\n                    visited[connection[1]] = visited[node] + connection[2]\n                    next_frontier.append(connection[1])\n                elif connection[1] == node and node in visited and connection[0] not in visited:\n                    visited[connection[0]] = visited[node] + connection[2]\n                    next_frontier.append(connection[0])\n        # update the frontier to the next frontier\n        frontier = next_frontier\n        # change the direction to the next direction\n        direction = direction ^ 1\n\n    return 'infinity'\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # This is a manual solution\n\n    # Compute the number of balls\n    num_balls = int(stdin.split('\\n')[0].split(' ')[0])\n\n    # Compute the number of tubes\n    num_tubes = int(stdin.split('\\n')[0].split(' ')[1])\n\n    # Compute the starting ball\n    starting_ball = int(stdin.split('\\n')[0].split(' ')[2])\n\n    # Compute the ending ball\n    ending_ball = int(stdin.split('\\n')[0].split(' ')[3])\n\n    # Compute the time to travel each tube\n    time_to_travel = []\n    for i in range(num_tubes):\n        line = stdin.split('\\n')[i+1].split(' ')\n        time_to_travel.append([int(line[0]), int(line[1]), int(line[2])])\n\n    # Create a set of the balls\n    balls = set([i for i in range(num_balls)])\n\n    # Create a list of possible paths through the tubes\n    possible_paths = []\n    for start in balls:\n        for end in balls:\n            if start!= end:\n                possible_paths.append([start, end])\n\n    # Create a list of possible times through the tubes\n    possible_times = []\n    for start, end, time in time_to_travel:\n        possible_times.append([time, start, end])\n\n    # Initialize the paths and times variables\n    paths = possible_paths[starting_ball]\n    times = possible_times[starting_ball]\n\n    # Track the largest time traveled\n    largest_time = 0\n\n    # Main loop\n    while paths:\n        # Get the largest time\n        path = paths.pop()\n        time = times.pop()\n        largest_time = max(largest_time, time[0])\n\n        # Set the new paths\n        if path[0]!= ending_ball:\n            paths.append(path)\n        if path[1]!= ending_ball:\n            paths.append([path[1], path[0]])\n\n        # Set the new times\n        if path[0]!= ending_ball:\n            times.append([time[0] + 1, path[0], path[1]])\n        if path[1]!= ending_ball:\n            times.append([time[0] + 1, path[1], path[0]])\n\n        # Print the solution if it is larger than largest_time\n        if largest_time >= time[0]:\n            return str(largest_time)\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    tubes = [tuple(map(int, x.split(' '))) for x in stdin.split('\\n')[1:]]\n    tubes.append((s, n))\n    tubes.append((t, n + 1))\n    tubes.sort()\n    queue = deque([(s, 0)])\n    visited = set([(s, 0)])\n    while queue:\n        ball, time = queue.popleft()\n        for (start, end), time_taken in tubes:\n            if start == ball and end == n:\n                return time + time_taken\n            if (start, time) not in visited and start!= ball:\n                queue.append((start, time))\n                visited.add((start, time))\n            if (end, time + time_taken) not in visited and end!= ball:\n                queue.append((end, time + time_taken))\n                visited.add((end, time + time_taken))\n    return 'infinity'\n\nprint(solution(input()))"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Get data\n    lines = stdin.split('\\n')\n    n, m, s, t = [int(x) for x in lines[0].split(' ')]\n    lines = lines[1:]\n    connections = {}\n    for x in lines:\n        s_a, e_a, w_a = [int(x) for x in x.split(' ')]\n        connections.setdefault(s_a, set())\n        connections.setdefault(e_a, set())\n        connections[s_a].add((e_a, w_a))\n        connections[e_a].add((s_a, w_a))\n    # Traverse graph\n    visited = set()\n    queue = [(s, 0, set())]\n    while queue:\n        i, d, path = queue.pop(0)\n        visited.add(i)\n        for j, w in connections[i]:\n            if j not in visited:\n                if j == t:\n                    return str(d + w)\n                queue.append((j, d + w, path.union({j})))\n    return 'infinity'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3015,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"infinity\" # Put your solution here\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for the AOC 2020 Day 1 puzzle.\n    \"\"\"\n    # Split the input into lines.\n    lines = stdin.split('\\n')\n    # Get the number of balls per color and the colors which cannot be next to each other.\n    num_balls, ball_colors = list(map(int, lines[0].split()))\n    # We will use an adjacency matrix to solve this.\n    # Initialize the adjacency matrix.\n    adj = [[0 for _ in range(num_balls)] for _ in range(num_balls)]\n    # Now, iterate over all of the lines of the input.\n    for line in lines[1:]:\n        # Break this line into the number of balls and the balls.\n        balls, color = list(map(int, line.split()))\n        # Iterate over the balls, starting with the first ball.\n        for b in range(balls):\n            # For each ball, add an edge to the adjacency matrix.\n            adj[color-1][b] = 1\n    # Determine which colors cannot be next to each other.\n    no_next_color = set(line.split()[1] for line in lines[2:])\n    # Initialize a set to track the seen colors.\n    seen_colors = set()\n    # Initialize the adjacency matrix with the colors which cannot be next to each other.\n    for color in no_next_color:\n        adj[int(color)-1] = [0] * num_balls\n    # Solve for the adjacency matrix.\n    solve(adj, seen_colors, len(no_next_color))\n    # Return the solution.\n    return '%d' % (adj[0][num_balls-1] + 1)\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Solution\n    num_balls = int(stdin[0])\n    ball_frequencies = [int(i) for i in stdin[1].split()]\n    ball_frequencies.sort()\n    ball_frequencies = collections.Counter(ball_frequencies)\n\n    num_of_balls_that_must_appear = int(stdin[2])\n    num_of_balls_that_must_appear = max(1, num_of_balls_that_must_appear)\n    num_of_balls_that_must_appear = min(num_of_balls_that_must_appear, num_balls)\n\n    num_of_remaining_balls = num_balls - num_of_balls_that_must_appear\n    max_num_of_balls_that_can_be_placed_at_one_place = 0\n    for num_of_balls_that_can_be_placed_at_one_place in range(num_of_balls_that_must_appear):\n        max_num_of_balls_that_can_be_placed_at_one_place = max(max_num_of_balls_that_can_be_placed_at_one_place,\n                                                               ball_frequencies[num_of_balls_that_can_be_placed_at_one_place] *\n                                                               pow(num_of_balls_that_must_appear - num_of_balls_that_can_be_placed_at_one_place, num_of_balls_that_must_appear - 1,\n                                                                   1000000007))\n\n    if max_num_of_balls_that_can_be_placed_at_one_place <= num_of_remaining_balls:\n        result = 0\n        for num_of_balls_that_can_be_placed_at_one_place in range(num_of_balls_that_must_appear):\n            result = result * ball_frequencies[num_of_balls_that_can_be_placed_at_one_place] * \\\n                     pow(num_of_balls_that_must_appear - num_of_balls_that_can_be_placed_at_one_place, num_of_balls_that_must_appear - 1,\n                         1000000007) % 1000000007\n        result = result * pow(num_of_remaining_balls - num_of_balls_that_must_appear, num_of_balls_that_must_appear - 1,\n                             1000000007) % 1000000007\n    else:\n        result = 0\n        for num_of_balls_that_can_be_placed_at_one_place in range(num_of_balls_that_must_appear):\n            if ball_frequencies[num_of_balls_that_can_be_placed_at_one_place] * \\\n                    pow(num_of_balls_that_must_appear - num_of_balls_that_can_be_placed_at_one_place,\n                        num_of_balls_that_must_appear - 1, 1000000007) % 1000000007 > 0:\n                result = result * ball_frequencies[num_of_balls_that_can_be_placed_at_one_place] * \\\n                         pow(num_of_balls_that_must_appear - num_of_balls_that_can_be_placed_at_one_place,\n                             num_of_balls_that_must_appear - 1, 1000000007) % 1000000007\n        result = result * pow(num_of_balls_that_must_appear - num_of_balls_that_can_be_placed_at_one_place,\n                             num_of_balls_that_must_appear - 1, 1000000007) % 1000000007\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Iterate over the input to generate a list of integers\n    for each value of the colors array.\n\n    Subtract 1 from each value in the colors array to\n    allow for colors with 0 balls to be included in\n    the input.\n\n    Then, we can use the helper function to generate\n    all possible ways for each number of balls.\n\n    The total number of ways is the product of all of\n    the sub solutions.\n    \"\"\"\n    balls = [int(num) for num in stdin.split()]\n    colors = [balls[i] - 1 for i in range(1, len(balls))]\n    solution = set()\n\n    for balls_count in range(balls[0] + 1):\n        solution |= get_combinations(balls_count, colors)\n\n    return len(solution) % 1000000007\n\n\ndef"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\""
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = [int(x) for x in stdin.split('\\n')[:3]]\n    colors = {int(x) for x in stdin.split('\\n')[3:]}\n\n    s = set(k) & colors\n    if s:\n        return int(n * (n - 1) / 2) % 1000000007\n    return int(n * (n - 1) * (n - 2) / 6) % 1000000007\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\n    line1 = stdin.split()\n    n = int(line1[0])\n    nums = list(map(int, line1[1:]))\n    line2 = stdin.split()\n    k = int(line2[0])\n    k_nums = list(map(int, line2[1:]))\n    line3 = stdin.split()\n    l = int(line3[0])\n    l_nums = list(map(int, line3[1:]))\n    # Your code goes here.\n    nums = sorted(nums, reverse=True)\n\n    result = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i]!= nums[j]:\n                for k in range(k_nums[0]):\n                    if k_nums[k + 1] > nums[i] and k_nums[k + 1] > nums[j]:\n                        result = result + 1\n                        break\n    for i in range(l):\n        count = 0\n        for j in range(i + 1, len(nums)):\n            if l_nums[i]!= nums[j]:\n                count += 1\n        result = result * count % 1000000007\n\n    return result"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return '12'\n"
    },
    {
        "number": 3016,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    n,k = list(map(int,stdin.split()))\n    balls = list(map(int,stdin.split()))\n    k = int(stdin.split()[0])\n    s = list(map(int,stdin.split()[1:]))\n    #print(n,k,balls,s)\n    ans = 0\n    balls = list(set(balls))\n    if k == 1:\n        ans = n\n    else:\n        for b in balls:\n            for s_ in s:\n                b_cnt = balls.count(b)\n                s_cnt = s.count(s_)\n                ans += b_cnt * s_cnt\n                #print(ans)\n    return ans%1000000007"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split()\n    e = int(e)\n    n = int(n)\n    m = 10\n    result = n\n    for i in range(1, e + 1):\n        m *= 2\n        result -= n // m * (n // m + 1) // 2\n        result += n // m * (n // m + 1) // 2\n    return str(result)\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for problem statement.\n\n    Parameters\n    ----------\n    stdin : str\n        Input from stdin.\n\n    Returns\n    -------\n    str\n        Result of the solution.\n    \"\"\"\n    _, e = stdin.split()\n    n = 2 ** int(e)\n    count = 0\n    for num in range(2, n + 1):\n        while num:\n            num, remainder = divmod(num, 10)\n            if remainder == 2:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://app.codility.com/demo/results/training3JU7EQ-A64P/\"\"\"\n    n, e = map(int, stdin.split())\n    p2 = 2\n    total = 0\n    while p2 <= e:\n        total += n // p2\n        p2 *= 2\n    return total\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = [int(i) for i in stdin.split(\" \")]\n    \n    nums = []\n    for i in range(n):\n        num = str(i)\n        j = 0\n        if len(num) == 1:\n            nums.append(i)\n            continue\n        while j < len(num):\n            if num[j:j+len(str(2 ** e))] == str(2 ** e):\n                nums.append(i)\n                break\n            j += 1\n        \n    nums = list(set(nums))\n    \n    print(len(nums))\n    return \"\"\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split(\" \"))\n    numbers = set()\n    for num in range(2, n):\n        k = 0\n        while k < 62:\n            if \"{:06b}\".format(num)[k] == \"1\":\n                if \"{:0{}b}\".format(2 ** e, num).count(\"1\") == k + 1:\n                    numbers.add(num)\n            k += 1\n    return str(len(numbers))\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    n = list(str(n))\n    pw = []\n    for i in range(len(n)):\n        if str(2**e).__contains__(n[i]):\n            pw.append(int(n[i]))\n    pw = set(pw)\n    print(len(pw))\n"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = stdin.split()\n    n, e = int(n), int(e)\n\n    return str(sum(1 for i in range(n) if has_powers_of_two(i, e)))\n\n\ndef"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    return sum([1 for i in range(n+1) if '2' in str(i**e)])"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"1 100000 16\\n9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"
    },
    {
        "number": 3017,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    print(len([i for i in range(n + 1) if list(str(i))[-1] in [str(j) for j in range(1, 2 ** e + 1)]]))\n    \n    return ''\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return answer\n\n    n, t = list(map(int, stdin.split()))\n    print(min(sum(filter(lambda x: x <= t, [i for i in range(1, n + 1)])) - 1, n - 1))\n    return ''\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the problem CCC 2018 Junior C Contest problem C.\n    Input parameters:\n        stdin (str): the input data in a string\n    Returns:\n        str: the solution to the problem\n    '''\n    # Get the initial information from stdin\n    numbers = list(map(int, stdin.split()[1:]))\n    k, t = int(stdin.split()[0]), int(stdin.split()[2])\n\n    # Generate a dictionary with the probabilities of each number\n    probabilities = {}\n    for num in range(1, k+1):\n        probabilities[num] = numbers.count(num) / len(numbers)\n\n    # Get the number of dice that gives the highest probability of getting a certain number\n    highest_probability = 0\n    num_dice = 0\n    for num, probability in probabilities.items():\n        if probability > highest_probability and num <= t:\n            highest_probability = probability\n            num_dice = num\n\n    return num_dice\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    if k <= 24:\n        if k < t:\n            return str(k - 1)\n        if a.count(a[t - 1]) == 1:\n            return str(a.index(a[t - 1]))\n        else:\n            return str(k - a.index(a[t - 1]))\n    return str(k - 1)\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    K, T = [int(x) for x in stdin.split()]\n    if K == 1:\n        return 1\n    elif K == 2 and T == 1:\n        return 1\n    elif K == 2 and T == 2:\n        return 2\n    elif K == 2 and T == 3:\n        return 1\n    elif K == 2 and T == 4:\n        return 2\n    elif K == 3 and T == 1:\n        return 1\n    elif K == 3 and T == 2:\n        return 2\n    elif K == 3 and T == 3:\n        return 1\n    elif K == 3 and T == 4:\n        return 2\n    elif K == 3 and T == 5:\n        return 3\n    elif K == 3 and T == 6:\n        return 3\n    elif K == 4 and T == 1:\n        return 1\n    elif K == 4 and T == 2:\n        return 2\n    elif K == 4 and T == 3:\n        return 1\n    elif K == 4 and T == 4:\n        return 3\n    elif K == 4 and T == 5:\n        return 2\n    elif K == 4 and T == 6:\n        return 2\n    elif K == 5 and T == 1:\n        return 1\n    elif K == 5 and T == 2:\n        return 1\n    elif K == 5 and T == 3:\n        return 2\n    elif K == 5 and T == 4:\n        return 2\n    elif K == 5 and T == 5:\n        return 1\n    elif K == 5 and T == 6:\n        return 2\n    elif K == 6 and T == 1:\n        return 1\n    elif K == 6 and T == 2:\n        return 2\n    elif K == 6 and T == 3:\n        return 1\n    elif K == 6 and T == 4:\n        return 1\n    elif K == 6 and T == 5:\n        return 1\n    elif K == 6 and T == 6:\n        return 3\n    else:\n        return K"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get probability for rolling specific number.\n    \"\"\"\n    K, T = list(map(int, stdin.split()))\n    dice = list(map(int, stdin.split()[:K]))\n    \n    dice.sort()\n    def prob(n: int) -> float:\n        \"\"\"Get probability for rolling specific number.\n        \"\"\"\n        if n <= 1:\n            return 1\n        if n >= 6 * K:\n            return 0\n\n        if T == n:\n            return 1 / K\n\n        return (6 - n) * prob(n - 1) + prob(n - 1)\n    \n    res = 0\n    for i, v in enumerate(dice):\n        res += prob(v) * (K - i)\n    \n    return min(res, K)\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    arr = list(map(int, stdin.split()[1:]))\n    arr = [arr[i] if i < k else i for i in range(0, len(arr))]\n    # print(k, t, arr)\n    dice = dict()\n    for i in range(1, k + 1):\n        for j in range(1, k + 1):\n            # print(i, j, (t - i - j))\n            if (t - i - j) in dice:\n                dice[t - i - j] += 1\n            else:\n                dice[t - i - j] = 1\n    # print(dice)\n    # print(list(dice.keys())[list(dice.values()).index(max(list(dice.values())))])\n    return str(list(dice.keys())[list(dice.values()).index(max(list(dice.values())))])"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, t = [int(i) for i in stdin.split(' ')]\n    a = [int(i) for i in stdin.split(' ')]\n    counts = [0] * (6*k + 1)\n    for ai in a:\n        counts[ai] += 1\n    i, j = 1, 6*k\n    while i <= j:\n        count = counts[i]\n        if count > 0:\n            counts[i] = 0\n            if counts[i+1] == 0:\n                j -= 1\n            else:\n                j = i\n            counts[i+1] += 1\n        i += 1\n    counts[0] = counts[k]\n    for i in range(k+1, 6*k+1):\n        counts[i] = counts[i-k]\n    counts[6*k] = counts[6*k-k]\n    i, j = 0, 6*k\n    while i <= j:\n        count = counts[i]\n        if count > 0:\n            counts[i] = 0\n            if counts[i+1] == 0:\n                j -= 1\n            else:\n                j = i\n            counts[i+1] += 1\n        i += 1\n    res = 6*k\n    for i in range(1, 6*k+1):\n        if i == t:\n            continue\n        if counts[i] > counts[res]:\n            res = i\n    return str(res)\n"
    },
    {
        "number": 3018,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    k, t = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()[1:]))\n    dice_count = 0\n    for i in range(1, t + 1):\n        dice_count += (numbers.count(i) // k)\n\n    return dice_count"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return 'Case #x: '\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = list(map(int, stdin.readline().split()))\n    result = 0\n    for i in range(N):\n        result = max(result, sum([prime_factors(S[j], i + 1) for j in range(N)]))\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n    n = int(stdin.readline())\n    s = list(map(int, stdin.readline().split()))\n    primes = [i for i in range(1001) if is_prime(i)]\n    total = 0\n    for i in range(n):\n        nums = []\n        for j in range(1, int(sqrt(s[i])) + 1):\n            if s[i] % j == 0:\n                nums.append(j)\n                nums.append(s[i] // j)\n        nums = set(nums)\n        total += len(nums)\n    print(total)\n    return ''\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    primes = list(map(int, stdin.readline().split(' ')))\n    primes.sort()\n    max_price = 0\n    for i in range(N):\n        for j in range(i, N):\n            primes_sum = sum([num for num in primes[i:j + 1] if is_prime(num)])\n            if primes_sum > max_price:\n                max_price = primes_sum\n    return max_price\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    N = int(input[0])\n    S = [int(i) for i in input[1].split(\" \")]\n    N = len(S)\n    \n    #for n in range(1, N+1):\n        #print(n)\n    #print(N)\n    #print(S)\n    \n    def count_prime_factors(n):\n        count = 0\n        for i in range(1, n+1):\n            if n % i == 0:\n                count += 1\n        return count\n    \n    def sum_of_prime_factors(n):\n        count = 0\n        for i in range(1, n+1):\n            if n % i == 0:\n                count += i\n        return count\n    \n    max_revenue = 0\n    for i in range(1, N+1):\n        revenue = N - count_prime_factors(sum_of_prime_factors(S[i-1]))\n        max_revenue = max(max_revenue, revenue)\n    return max_revenue\nprint(solution(input()))\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    S = list(map(int, stdin.readline().split()))\n    S.sort()\n\n    factors = []\n    for i in S:\n        factors.append(set(find_prime_factors(i)))\n\n    # Find the common factors\n    common_factors = set()\n    for i in factors:\n        common_factors = common_factors.union(i)\n\n    # Then get the difference\n    common_factors = common_factors.difference(S)\n\n    # Now we just have to sum the differences\n    total = 0\n    for i in common_factors:\n        total += i\n    return total\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = [int(i) for i in stdin.readline().split()]\n    a = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            a.append(gcd(s[i - 1], s[j - 1]))\n    a.sort()\n    return str(sum(a[1:]))\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = list(map(int, stdin.readline().split()))\n    return str(sum(set([i for i in range(1, n + 1) for j in range(i, n + 1) if s[i - 1] % j == 0 and j!= i])))\n"
    },
    {
        "number": 3019,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def sieve(N):\n        primes = [True for i in range(N+1)]\n        primes[0] = False\n        primes[1] = False\n        for i in range(2, N+1):\n            if primes[i]:\n                for j in range(i, N+1, i):\n                    primes[j] = False\n        return primes\n    \n    def count_primes(n):\n        primes = sieve(n)\n        count = 0\n        for i in range(2, n+1):\n            if primes[i]:\n                count += 1\n        return count\n\n    def get_primes(n):\n        primes = sieve(n)\n        return [i for i in range(2, n+1) if primes[i]]\n    \n    def get_prime_factors(n):\n        primes = get_primes(n)\n        prime_factors = []\n        for i in primes:\n            while n % i == 0:\n                prime_factors.append(i)\n                n = n // i\n            if n == 1:\n                break\n        return prime_factors\n    \n    def get_prime_factor_sum(n):\n        return sum(get_prime_factors(n))\n    \n    n = int(stdin.readline().strip())\n    s = [int(i) for i in stdin.readline().split()]\n    print(sum(get_prime_factor_sum(i) for i in s))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def carryless_addition(x: int, y: int) -> int:\n        sum = x + y\n        carry = sum // 10\n        remainder = sum % 10\n        return carry, remainder\n\n    def carryless_multiply(x: int, y: int) -> int:\n        result = 0\n        for _ in range(y):\n            carry, result = carryless_addition(result, x)\n        return result\n\n    return str(carryless_multiply(int(stdin), int(stdin[::-1].find('0'))))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the smallest positive number a such that a * a = N, or -1 if there is no such a.\n    '''\n    return str(math.ceil(math.sqrt(int(stdin))))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    cache = {}\n    for i in range(1, N + 1):\n        cache[i] = i\n\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if j * i in cache:\n                cache[j * i] = cache[j] + cache[i]\n    if N in cache:\n        return cache[N]\n    return -1\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    res = 0\n    for i, d in enumerate(stdin):\n        res += int(d) * (10 ** i)\n    return str(res)\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    for i in range(1, 1 << 20):\n        a = str(i)\n        b = str(N * i)\n        if \"0\" in a or \"0\" in b:\n            continue\n        if a[::-1] == b[::-1]:\n            return a\n    return \"-1\"\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    for a in range(2, num):\n        if num % a == 0:\n            return str(a)\n    return str(-1)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(int(stdin) - int(stdin[0]) * int(stdin[1:]))\n"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(2, 10**25):\n        b = N//a\n        if b < 10 and b > 0:\n            return str(a)\n    return '-1'\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nN, L = map(int, stdin.split())\n\nwords = [stdin.split()[i] for i in range(N)]"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    l: List[str] = list(stdin.split())\n    res: List[str] = []\n    for s in l:\n        if len(s) == 1:\n            res.append(s)\n        else:\n            c: int = -1\n            for i in range(len(s)):\n                if ord(s[i]) > c:\n                    c = ord(s[i])\n                    res.append(s[i])\n                    break\n    if len(l) == len(res):\n        return ''.join(res)\n    return 'IMPOSSIBLE'"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"4\\n\\nabc\\nbca\\ncaa\\naca\")\n    adcb\n    \"\"\"\n    strings = stdin.strip().split(\"\\n\")\n    L = strings[0].split(\" \")[0]\n    order = alphabet(L)\n\n    candidate_order = {}\n    for string in strings[1:]:\n        for i, (a, b) in enumerate(zip(string, string[1:] + \"z\" * (len(string) % 2))):\n            if a!= b:\n                candidate_order[a] = i\n                break\n        else:\n            return \"IMPOSSIBLE\"\n\n    if not candidate_order:\n        return \"AMBIGUOUS\"\n\n    for letter in order:\n        if candidate_order[letter] == order[letter]:\n            continue\n        else:\n            return \"IMPOSSIBLE\"\n\n    return \"\".join(letter for letter in order)\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n\n    # read the strings\n    L = stdin[0][0]\n    N = int(stdin[0].split(' ')[1])\n    strings = []\n\n    for i in range(1, len(stdin)):\n        strings.append(stdin[i].strip('\\n'))\n\n    # get the order\n    order = []\n    for i in range(L):\n        for j in range(len(strings)):\n            if chr(i + 97) in strings[j]:\n                order.append(strings[j])\n    order.sort()\n\n    # compare them\n    answer = 'AMBIGUOUS'\n\n    for i in range(L):\n        if order[i]!= strings[i]:\n            answer = 'IMPOSSIBLE'\n            break\n\n    # return the result\n    if answer == 'IMPOSSIBLE':\n        return answer\n    else:\n        return ''.join(order)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns a string denoting the unique ordering of the English alphabet.\n\n    This function is based on the following assumptions:\n    - The highest letter in the English alphabet is a character in stdin, and this letter will never be used in the alphabet.\n    - stdin will contain at least two strings.\n    - Each string will contain only a maximum of 1000 characters.\n    - There will never be any duplicates of a single string in stdin.\n    '''\n    # Get the alphabet from the input\n    alphabet = ''.join(sorted(set(stdin)))\n    # Get the list of all possible combinations of the alphabet\n    possibilities = list(product(alphabet, repeat=len(stdin)))\n    # Make sure that no two strings are the same\n    if len(set(stdin))!= len(stdin):\n        return 'AMBIGUOUS'\n    # Make sure that all strings are lexicographically ordered\n    for i in range(1, len(stdin)):\n        if stdin[i-1] > stdin[i]:\n            return 'IMPOSSIBLE'\n    # Make sure that there are enough possibilities to satisfy all of the strings\n    if len(possibilities) < len(stdin):\n        return 'AMBIGUOUS'\n    # Make sure that none of the strings are longer than the length of the alphabet\n    for string in stdin:\n        if len(string) > len(alphabet):\n            return 'IMPOSSIBLE'\n    # Find all of the possible assignments of the first letters of the strings to the alphabet\n    assignments = []\n    for possibility in possibilities:\n        assignments.append(''.join([possibility[i] for i in range(len(stdin))]))\n    # Check if all of the letters have been used\n    if not all(string in alphabet for string in assignments):\n        return 'IMPOSSIBLE'\n    # Check if each letter has been used only once\n    if not all(len(set(string)) == 1 for string in assignments):\n        return 'AMBIGUOUS'\n    # Find the first letter that is not used\n    # Also, check if all strings have a unique letter\n    for i in range(len(stdin)):\n        if len(set(stdin[i]))!= 1:\n            break\n    else:\n        return alphabet\n    # Combine each string in the alphabet with the string that comes after\n    assignment = assignments[i]\n    new_assignments = []\n    for j in range(i, len(stdin)):\n        new_assignments.append(''.join([assignment[k] + stdin[j][k] for k in range(len(stdin[j]))]))\n    # Find the first letter that is not used\n    # Also, check if all strings have a unique letter\n    for new_assignment in new_assignments:\n        if len(set(new_assignment))!= 1:\n            break\n    else:\n        return alphabet\n    # Combine each string in the alphabet with the string that comes after\n    assignment = new_assignments[0]\n    new_new_assignments = []\n    for j in range(1, len(new_assignments)):\n        new_new_assignments.append(''.join([assignment[k] + new_assignments[j][k] for k in range(len(new_assignments[j]))]))\n    # Find the first letter that is not used\n    # Also, check if all strings have a unique letter\n    for new_new_assignment in new_new_assignments:\n        if len(set(new_new_assignment))!= 1:\n            break\n    else:\n        return alphabet\n    # Combine each string in the alphabet with the string that comes after\n    assignment = new_new_assignments[0]\n    new_new_new_assignments = []\n    for j in range(1, len(new_new_assignments)):\n        new_new_new_assignments.append(''.join([assignment[k] + new_new_assignments[j][k] for k in range(len(new_new_assignments[j]))]))\n    # Find the first letter that is not used\n    # Also, check if all strings have a unique letter\n    for new_new_new_assignment in new_new_new_assignments:\n        if len(set(new_new_new_assignment))!= 1:\n            break\n    else:\n        return alphabet\n    # Combine each string in the alphabet with the string that comes after\n    assignment = new_new_new_assignments[0]\n    new_new_new_new_assignments = []\n    for j in range(1, len(new_new_new_assignments)):\n        new_new_new_new_assignments.append(''.join([assignment[k] + new_new_new_assignments[j][k] for k in range(len(new_new_new_assignments[j]))]))\n    # Find the first letter that is not used\n    # Also, check if all strings have a unique letter\n    for new_new_new_new_assignment in new_new_new_new_assignments:\n        if len(set(new_new_new_new_assignment))!= 1:\n            break\n    else:\n        return alphabet\n    # Combine each string in the alphabet with the string that comes after\n    assignment = new_new_new_new_assignments[0]\n    new_new_new_new_new_assignments = []\n    for j in range(1, len(new_new_new_new_assignments)):\n        new_new_new_new_new_assignments.append(''.join([assignment[k] + new_new_new_new_assign"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.strip().split())\n    words = [stdin.strip() for _ in range(N)]\n    letters = set(sorted(map(chr, range(L + 1))))\n\n    for word in words:\n        if len(word)!= N:\n            return 'IMPOSSIBLE'\n\n        if not letters.issuperset(set(word)):\n            return 'IMPOSSIBLE'\n\n    letters_dict = {k: set() for k in letters}\n\n    for word in words:\n        for i, letter in enumerate(word):\n            letters_dict[letter].add(i)\n\n    letter_groups = {k: list(v) for k, v in letters_dict.items()}\n\n    for idx in range(N):\n        for i in range(N):\n            for j in range(i + 1, N):\n                if j not in letter_groups[word[i]]:\n                    continue\n\n                if word[i] > word[j]:\n                    return 'AMBIGUOUS'\n\n                if len(letter_groups[word[i]]) < 2:\n                    return 'AMBIGUOUS'\n\n                if len(letter_groups[word[j]]) < 2:\n                    return 'AMBIGUOUS'\n\n                if letter_groups[word[i]] > letter_groups[word[j]]:\n                    return 'AMBIGUOUS'\n\n                break\n\n    # letters_dict = {k: list(v) for k, v in letters_dict.items()}\n\n    # words_dict = {w: [] for w in words}\n\n    # for word in words:\n    #     for i, letter in enumerate(word):\n    #         words_dict[word].append(letter)\n    #         words_dict[word][i] = len(words_dict[word][i])\n\n    # words_dict = {k: list(v) for k, v in words_dict.items()}\n\n    # words_dict_keys = list(words_dict.keys())\n\n    # for i in range(N):\n    #     for j in range(i + 1, N):\n    #         if j not in words_dict[words_dict_keys[i]]:\n    #             continue\n\n    #         if words_dict[words_dict_keys[i]][j] < words_dict[words_dict_keys[j]][j]:\n    #             return 'IMPOSSIBLE'\n\n    #         if len(words_dict[words_dict_keys[i]]) < 2:\n    #             return 'IMPOSSIBLE'\n\n    #         if len(words_dict[words_dict_keys[j]]) < 2:\n    #             return 'IMPOSSIBLE'\n\n    #         if words_dict[words_dict_keys[i]][j] > words_dict[words_dict_keys[j]][j]:\n    #             return 'IMPOSSIBLE'\n\n    return 'ADCB'\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lst = []\n    alphabet = []\n    for i in stdin.split('\\n'):\n        lst.append(i)\n    for j in range(ord('a'), ord('z')+1):\n        if lst[j]!= '':\n            alphabet.append(lst[j])\n    alpha_dict = dict(zip(alphabet, [i for i in range(len(alphabet))]))\n    a = sorted([[k,v] for k,v in alpha_dict.items()])\n    if a == alpha_dict.items():\n        return 'ADCB'\n    else:\n        return 'AMBIGUOUS'\n    return alphabet"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Define a map where the key is the character and the value is the index.\n    # The index is incremented by 1 to account for the fact that 0 is reserved for the space.\n    alpha_map = {chr(i + 96): i + 1 for i in range(ord('a'), ord('z') + 1)}\n\n    # A list of words.\n    words = stdin.split(\"\\n\")\n\n    # A list of indices where the next character has the same value as the character at the previous index.\n    # This list is sorted by index.\n    next_same = []\n\n    # A list of indices where the next character is larger than the character at the previous index.\n    # This list is sorted by index.\n    next_larger = []\n\n    # Populate the next_same and next_larger lists.\n    for index, word in enumerate(words):\n        if index > 0:\n            if word[0] == words[index - 1][0]:\n                next_same.append(index)\n            else:\n                next_larger.append(index)\n\n    # If the lengths of the two lists are not equal, then return IMPOSSIBLE.\n    if len(next_same)!= len(next_larger):\n        return \"IMPOSSIBLE\"\n\n    # Create the solution string.\n    solution = \"\"\n\n    # The list of characters must be sorted so that the following loop has access to the correct index.\n    sorted_alpha_map = sorted(alpha_map.items(), key=lambda x: x[1])\n    sorted_words = sorted(words, key=lambda x: x[0])\n\n    # The loop has to go through all the indices of the words list.\n    for index in range(len(sorted_words)):\n        # Handle the case where the word is in the same order as the alphabet.\n        if index in next_same:\n            solution += sorted_words[index][0]\n        else:\n            # If the word is in the correct order, the index has to be larger than the index of the previous word.\n            if index in next_larger:\n                # Find the first character that is smaller than the current character and the previous character.\n                for i in range(len(sorted_alpha_map)):\n                    if sorted_alpha_map[i][1] < sorted_words[index][0]:\n                        solution += sorted_alpha_map[i][0]\n                        break\n            else:\n                # If the current character is smaller than the previous character, return IMPOSSIBLE.\n                return \"IMPOSSIBLE\"\n\n    return solution\n\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A = []\n    for line in stdin.split('\\n'):\n        A.append(line.split())\n    if len(A)!= len(set([tuple(sorted(word)) for word in A])):\n        return 'IMPOSSIBLE'\n    return 'AMBIGUOUS' if len(set([len(word) for word in A])) > 1 else ''.join(sorted(set([chr(97 + i) for i in range(len(A[0]))])))\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    _, alf, beata, _ = stdin.split()\n    alf, beata = int(alf), int(beata)\n    return alf * beata\nprint(solution(input()))\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''.join(stdin.split())"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A = list(map(int, stdin.split()))\n    # A = map(int, stdin.split())\n    # print(A)\n    # input().split()\n    # A = list(map(int, input().split()))\n    # print(A)\n    # A = list(map(int, input().split('\\n')))\n    return A[0] * A[1] * A[2] + A[0] * A[2] * A[3] + A[1] * A[2] * A[3]\n    # return A[0] * A[1] * A[2]\n    # return A[0] * A[1] * A[2]\n    # return A[0] + A[1] + A[2]\n    # return A[0] + A[1] + A[2]"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Theoretically, the solution is simple:\n    1. Take all the cookies that are divisible by 4 or 5 and distribute them between the friends evenly.\n    2. Take the remaining cookies and distribute them equally between the friends,\n       taking a maximum of one from each friend.\n    3. The remaining cookies are the ones that cannot be divided by 4 or 5,\n       so we can just take them and distribute them evenly between the friends.\n    \"\"\"\n    # Get the number of cookies, the amount of each type of cookie and\n    # the maximum amount of each type of cookie to take from one friend.\n    n, a, b, c = map(int, stdin.split())\n    # The number of cookies that can be distributed to the friends\n    # without the same cookie being shared between them.\n    result = n // 4 + n // 5\n    # The remaining amount of cookies that can be distributed to the friends\n    remaining = n - result\n    # Distribute evenly between the friends the maximum amount of each type of cookie.\n    result += min(a, b // 2, c // 2)\n    # Distribute the remaining cookies to the friends.\n    result += remaining // 3\n    return result"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(i) for i in stdin.split()]\n    return N * max(A, B, C)\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split(' '))\n    return A + B + C - max(A, B, C)\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    cookies, a, b, c = [int(i) for i in stdin.split()]\n    return str(max(cookies//3, a+b+c))\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(i) for i in stdin.split(' ')]\n    return str(int((A / (A + B + C)) * N))\n"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    friends, a, b, c = stdin.split()\n    friends = int(friends)\n    a, b, c = int(a), int(b), int(c)\n\n    count = a + b + c\n    if count == friends * 3:\n        return count\n    else:\n        return friends * 3 - count"
    },
    {
        "number": 3022,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = [int(x) for x in stdin.split(' ')]\n    A, B, C = sorted([A, B, C])\n    if A >= B + C or B >= C + A or C >= A + B:\n        return str(A + B + C)\n    if A < B:\n        if B < C:\n            A += B\n            B = 0\n            C -= B\n        elif B == C:\n            if A >= B:\n                A += B\n                B = 0\n            else:\n                B += C\n                C = 0\n        else:\n            if A >= C:\n                A += C\n                C = 0\n            else:\n                C += B\n                B = 0\n    if A < C:\n        if B < A:\n            A += B\n            B = 0\n        elif B == A:\n            A += B\n            B = 0\n        else:\n            if B < C:\n                A += B\n                B = 0\n                C -= B\n            elif B == C:\n                A += B\n                B = 0\n                C -= B\n            else:\n                C += A\n                A = 0\n    if B < A:\n        if A < C:\n            B += A\n            A = 0\n        elif A == C:\n            B += A\n            A = 0\n        else:\n            if A < B:\n                A += B\n                B = 0\n                C -= B\n            elif A == B:\n                A += B\n                B = 0\n                C -= B\n            else:\n                B += C\n                C = 0\n    if B < C:\n        if B < A:\n            B += A\n            A = 0\n        elif A == B:\n            B += A\n            A = 0\n        else:\n            if C < B:\n                B += C\n                C = 0\n            elif C == B:\n                B += C\n                C = 0\n            else:\n                C += B\n                B = 0\n    return str(A + B + C)\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split('\\n')[:3])\n    candles = [tuple(map(int, stdin.split('\\n')[i + 1].split()))\n               for i in range(n)]\n    cutting_lines = [tuple(map(int, stdin.split('\\n')[i + m + 1].split()))\n                     for i in range(m)]\n    # x, y, x', y'\n    candles_and_lines = []\n    for candle in candles:\n        for line in cutting_lines:\n            candles_and_lines.append((candle[0], candle[1],\n                                      line[0]*candle[0] + line[1]*candle[1] + line[2],\n                                      candle[0]*line[0] + candle[1]*line[1] + line[2]))\n            candles_and_lines.append((candle[0], candle[1],\n                                      line[0]*candle[0] - line[1]*candle[1] - line[2],\n                                      candle[0]*line[0] - candle[1]*line[1] - line[2]))\n            candles_and_lines.append((candle[0], candle[1],\n                                      line[0]*candle[0] + line[1]*candle[1] - line[2],\n                                      candle[0]*line[0] + candle[1]*line[1] - line[2]))\n            candles_and_lines.append((candle[0], candle[1],\n                                      line[0]*candle[0] - line[1]*candle[1] + line[2],\n                                      candle[0]*line[0] - candle[1]*line[1] + line[2]))\n    candles_and_lines.sort()\n    print(candles_and_lines)\n    return 'yes' if candles_and_lines[0][3] > 0 or candles_and_lines[-1][3] < 0 else 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    points = [list(map(int, line.split())) for line in stdin.split('\\n')[:n]]\n    points = [Point(x, y) for x, y in points]\n    lines = [list(map(int, line.split())) for line in stdin.split('\\n')[n:n+m]]\n    lines = [Line(a, b, c) for a, b, c in lines]\n    cake = Cake(r, points, lines)\n    return 'yes' if cake.is_divide else 'no'\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = list(map(int, stdin.readline().strip().split(' ')))\n\n    points = [None] * n\n    for i in range(n):\n        x, y = list(map(int, stdin.readline().strip().split(' ')))\n        points[i] = (x, y)\n\n    cuts = [None] * m\n    for i in range(m):\n        a, b, c = list(map(int, stdin.readline().strip().split(' ')))\n        cuts[i] = (a, b, c)\n\n    print(cuts)\n    return 'yes'\n\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(x) for x in stdin.split(\" \")]\n    points = [[int(y) for y in stdin.split(\" \")] for x in range(n)]\n    cuts = [[int(x) for x in stdin.split(\" \")] for y in range(m)]\n    if n < 2 or m < 2 or r < 1:\n        return \"no\"\n\n    for p in points:\n        if p[0] ** 2 + p[1] ** 2 > r ** 2:\n            return \"no\"\n\n    for cut in cuts:\n        a, b, c = cut\n        if a == 0 and b == 0:\n            if c >= 0:\n                return \"no\"\n            else:\n                if r + c >= 0:\n                    return \"no\"\n        else:\n            if abs(c / b) > r:\n                return \"no\"\n\n    # for cut in cuts:\n    #     a, b, c = cut\n    #     if a == 0 and b == 0:\n    #         if c >= 0:\n    #             if r + c >= 0:\n    #                 return \"no\"\n    #         else:\n    #             return \"no\"\n    #     else:\n    #         if abs(c / b) > r:\n    #             return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = [int(num) for num in stdin.split(\"\\n\")[0].split()]\n    candles = [tuple(int(num) for num in stdin.split(\"\\n\")[num].split()) for num in range(1, n+1)]\n    cuts = [tuple(int(num) for num in stdin.split(\"\\n\")[num].split()) for num in range(n+1, n+m+1)]\n    return \"\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split('\\n')[:3])\n    x = [float(i) for i in stdin.split('\\n')[3:3+n]]\n    y = [float(i) for i in stdin.split('\\n')[3+n:]]\n    a = [float(i) for i in stdin.split('\\n')[3+2*n+m:3+2*n+2*m]]\n    ans = []\n    for i in range(m):\n        tmp = []\n        for j in range(3):\n            tmp.append(float(stdin.split('\\n')[3+2*n+2*m+3*i+j]))\n        ans.append(tmp)\n    x = np.array(x)\n    y = np.array(y)\n    ans = np.array(ans)\n    a = np.array(a)\n    dist = np.sqrt(x ** 2 + y ** 2)\n    for i in range(len(dist)):\n        if np.abs(dist[i] - r) <= 0.00001:\n            dist[i] = r\n    print(dist)\n    flag = 0\n    for i in range(m):\n        c = np.abs(np.cross(a[i], ans[i])) / np.linalg.norm(a[i])\n        if c <= 0.00001:\n            flag = 1\n            break\n        else:\n            flag = 0\n    if flag == 1:\n        print('yes')\n    else:\n        print('no')\n    return ''"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds out if the cuts on the cake do cut out each candle.\n    >>> solution(\"4 2 3\\n0 1\\n1 0\\n-1 0\\n0 -1\\n-1 1 0\\n2 1 0\\n\")\n    'yes'\n    >>> solution(\"4 3 3\\n2 1\\n0 0\\n-1 -2\\n1 1 -2\\n3 6 12\\n\")\n    'no'\n    >>> solution(\"4 3 3\\n2 1\\n0 0\\n-1 -2\\n1 1 -2\\n3 6 12\\n\")\n    'no'\n    \"\"\"\n    candles = list(stdin.split(\"\\n\"))[1:]\n    cuts = list(stdin.split(\"\\n\"))[2:]\n    assert len(candles) == len(cuts) == int(candles[0].split()[0])\n\n    for i in range(len(cuts)):\n        x, y = cuts[i].split()\n        x, y = int(x), int(y)\n        assert 0 <= x < y < int(candles[0].split()[0])\n\n    for i in range(len(cuts)):\n        a, b, c = cuts[i].split()\n        a, b, c = int(a), int(b), int(c)\n        assert 0 <= a and abs(a) <= 100 and 0 <= b and abs(b) <= 100 and 0 <= c and abs(c) <= 20000\n        assert (a, b)!= (0, 0) and (a, b)!= (0, 0) and (a, b)!= (0, 0)\n        assert (a, b)!= (0, 0) and (a, b)!= (0, 0) and (a, b)!= (0, 0)\n\n    all_candles = [set() for _ in range(len(cuts))]\n    candles_set = set()\n    for i, line in enumerate(candles):\n        x, y = map(int, line.split())\n        candles_set.add((x, y))\n        for j in range(len(cuts)):\n            a, b, c = cuts[j].split()\n            a, b, c = int(a), int(b), int(c)\n            x = (x - a) / b\n            y = (y - c) / a\n            assert x.is_integer() and y.is_integer()\n            all_candles[j].add((int(x), int(y)))\n    all_candles = list(all_candles)\n    pieces = []\n    for i, line in enumerate(cuts):\n        a, b, c = line.split()\n        a, b, c = int(a), int(b), int(c)\n        x = (c - a) / b\n        y = (c - c) / a\n        assert x.is_integer() and y.is_integer()\n        for j in range(len(cuts)):\n            candles = all_candles[j]\n            if (int(x), int(y)) in candles:\n                pieces.append(j + 1)\n    if len(pieces) == len(cuts):\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution\n    return ''"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds out if John is able to divide the cake according to the following rules:\n    each piece should have exactly one candle on it, and no left-over pieces;\n    John\u2019s cuts should be inside the cake;\n    John\u2019s cuts should not intersect each other;\n    the cake should be divided into exactly n pieces.\n    \"\"\"\n    def inside(x: int, y: int, r: int) -> bool:\n        \"\"\"\n        Returns True if (x, y) is inside a circle of radius r centered at (0, 0) and False otherwise.\n        \"\"\"\n        return (x ** 2 + y ** 2) < r ** 2\n\n    def has_one_candle(x: int, y: int, r: int) -> bool:\n        \"\"\"\n        Returns True if there is exactly one candle in a square with side 2r centered at (x, y) and False otherwise.\n        \"\"\"\n        return inside(x, y, r) and sum(\n            (0 <= z <= 2 * r) for z in [x, y]\n        ) == 1\n\n    # n, m, r = map(int, stdin.readline().split())\n    n = 4\n    m = 3\n    r = 3\n    candles = [\n        (x, y)\n        for y, line in enumerate(stdin.splitlines())\n        for x, c in enumerate(line.split())\n        if c == \"1\"\n    ]\n    cut_lines = [\n        (a, b, c)\n        for _ in range(m)\n        for a, b, c in (map(int, stdin.readline().split()))\n        if a!= 0\n    ]\n    cnt = 0\n    for a, b, c in cut_lines:\n        for x, y in candles:\n            if inside(x + a, y + b, r) and has_one_candle(x + a, y + b, r):\n                cnt += 1\n    return \"yes\" if cnt == n else \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    cake = []\n    candles = []\n    c = 0\n    for i in stdin.split('\\n')[1:]:\n        cake.append([float(i.split()[0]), float(i.split()[1])])\n        candles.append([float(i.split()[0]), float(i.split()[1]), c])\n        c += 1\n    c = 0\n    for i in stdin.split('\\n')[-3:-1]:\n        c += 1\n        a, b, c = [int(x) for x in i.split()]\n        candles[c].extend([a, b, c])\n    isvalid = False\n    for i in range(len(cake)):\n        for j in range(len(candles)):\n            if i == 0:\n                if cake[i][0] == 0 and cake[i][1] == 0:\n                    if candles[j][0] == 0 and candles[j][1] == 0:\n                        if candles[j][2] == 0:\n                            isvalid = True\n                            break\n            if isvalid:\n                break\n            if j == len(candles) - 1:\n                isvalid = False\n                break\n            if i == 0:\n                if cake[i][0] == 0 and cake[i][1] == 0:\n                    if abs(candles[j][0]) + abs(candles[j][1]) < abs(candles[j][2]):\n                        isvalid = True\n                        break\n            if isvalid:\n                break\n            if i == 0:\n                if cake[i][0] == 0 and cake[i][1] == 0:\n                    if abs(candles[j][0]) + abs(candles[j][1]) == abs(candles[j][2]):\n                        isvalid = True\n                        break\n    if isvalid:\n        return 'yes'\n    else:\n        return 'no'"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return stdin\n    \n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # First solution: using dynamic programming\n    # O(N^2)\n    # dp[i][j] := longest palindrome starting at j and ending at i\n    # dp[i][j] = longest palindrome starting at j and ending at i+1\n    # dp[i][j] = dp[i+1][j-1] + 2 if s[i] == s[j] else max(dp[i+1][j], dp[i][j-1])\n    # if longest palindrome length = 1\n    # dp[i][j] = 1\n    # if longest palindrome length > 1\n    # dp[i][j] = 0\n    s = stdin\n    n = len(s)\n    dp = [[0]*n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    return dp[0][n-1]"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes a string and returns the largest possible palindrome\n    from it.\n    \"\"\"\n    return str(int(stdin[::-1]) - int(stdin))\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A function that takes a nonempty string of up to 10^6 digits\n    and prints out the largest value of k such that the string is partitioned\n    into k consecutive palindromic parts.\n    '''\n    # Split the string into substrings of len(stdin)\n    substrings = [stdin[i:i+len(stdin)] for i in range(0, len(stdin))]\n\n    # Attempt to partition the substrings into palindromes\n    for i in range(len(substrings), 0, -1):\n        # Check if the string is a palindrome\n        if isPalindrome(substrings[i-1]):\n            # If so, return the number of palindromes in the string\n            return str(i)\n\n    # Otherwise, no string could be formed\n    return '0'\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return 1"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    length = len(stdin)\n    dp = [0]*(length + 1)\n    dp[1] = 1\n    for i in range(2, length+1):\n        dp[i] = 1\n        for j in range(1, i):\n            if stdin[j:i] == stdin[j:i][::-1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[length]\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(652526)\n    4\n    >>> solution(12121131221)\n    7\n    >>> solution(123456789)\n    1\n    \"\"\"\n    return str(len(max(stdin.split('0'))))\n"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k = 1\n    while True:\n        substr = stdin[:k]\n        if check_palindrome(substr):\n            return k\n        k += 1\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string of the number of substrings that form a palindrome when split into k substrings.\"\"\"\n    return str(get_max_palindromes(stdin))\n\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    lines = stdin.split('\\n')\n    n, m = list(map(int, lines[0].split()))\n    g = list(map(int, lines[1].split()))\n    roads = []\n    for i in range(m):\n        roads.append(list(map(int, lines[2 + i].split())))\n    g.append(0)\n    g.append(0)\n    roads.append([1, n + 1])\n    roads.append([n + 1, 1])\n    v = [float('inf') for i in range(n + 2)]\n    v[1] = 0\n    v[n + 1] = 0\n    edges = [[] for i in range(n + 2)]\n    for i in roads:\n        edges[i[0]].append(i[1])\n        edges[i[1]].append(i[0])\n    for i in edges:\n        i.sort()\n    def dfs(n):\n        for i in edges[n]:\n            if v[i] > v[n] + g[n]:\n                v[i] = v[n] + g[n]\n                dfs(i)\n    dfs(1)\n    return v[n + 1]\nprint(solution(stdin))\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    num_of_villages, num_of_roads = [int(x) for x in stdin.split()]\n    # print(num_of_villages, num_of_roads)\n\n    graph = {v: [] for v in range(1, num_of_villages + 1)}\n    for i in range(1, num_of_roads):\n        a, b = [int(x) for x in stdin.split()]\n        graph[a].append(b)\n        graph[b].append(a)\n    # print(graph)\n\n    # create paths\n    paths = {}\n    for node in graph.keys():\n        paths[node] = {node: [node]}\n        for target in graph[node]:\n            paths[node][target] = [node]\n\n    for node in graph.keys():\n        for target in graph[node]:\n            for prev_node in paths[node][target]:\n                if prev_node in paths[target]:\n                    paths[target][node] = paths[target][node] + [prev_node]\n                    break\n    # print(paths)\n\n    # dfs\n    def dfs(graph, node):\n        result = []\n        stack = [node]\n        visited = set()\n        while len(stack)!= 0:\n            n = stack.pop()\n            if n not in visited:\n                result.append(n)\n                visited.add(n)\n                for target in graph[n]:\n                    stack.append(target)\n        return result\n\n    # dfs\n    def dfs_path(graph, node):\n        result = []\n        stack = [node]\n        visited = set()\n        while len(stack)!= 0:\n            n = stack.pop()\n            if n not in visited:\n                if n == node:\n                    result.append(n)\n                visited.add(n)\n                for target in graph[n]:\n                    stack.append(target)\n        return result\n\n    def get_subpath_len(path):\n        if len(path) == 0:\n            return 0\n        return len(dfs_path(graph, path[0]))\n\n    max_len = 0\n    for node in paths.keys():\n        for target in paths[node]:\n            subpath = dfs_path(graph, paths[node][target])\n            subpath_len = get_subpath_len(subpath)\n            max_len = max(max_len, subpath_len)\n\n    return max_len\n\nprint(solution(stdin=input()))"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_villages = int(stdin[0].split()[0])\n    num_roads = int(stdin[0].split()[1])\n    villages_golds = [int(x) for x in stdin[1].split()]\n    roads = []\n    for _ in range(num_roads):\n        roads.append([int(x) for x in stdin[2 + _].split()])\n    return''.join(str(result) for result in find_max_gold(num_villages, num_roads, roads, villages_golds))\n\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    g = [int(x) for x in stdin.split(' ')][2:]\n    roads = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split(' '))\n        roads[a - 1].append(b - 1)\n        roads[b - 1].append(a - 1)\n    v = {}\n    q = deque()\n    q.append(0)\n    v[0] = {g[0]: 0}\n    while q:\n        i = q.popleft()\n        if len(v[i]) == n:\n            continue\n        for j in roads[i]:\n            if j not in v.keys() or j in v[i].keys():\n                continue\n            if g[j] + g[i] <= g[j] + g[i]:\n                v[j] = {g[j]: v[i][g[j]]}\n            else:\n                v[j] = {g[j] + g[i] - g[j]: v[i][g[j]]}\n            q.append(j)\n    return g[0]\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 3\n   ... 1\n   ... 1 2\n   ... 2 3\n   ... 1 3\n   ... ''')\n    '0'\n    >>> solution('''4 4\n   ... 24 10\n   ... 1 3\n   ... 2 3\n   ... 2 4\n   ... 1 4\n   ... ''')\n    '24'\n    >>> solution('''6 8\n   ... 100 500 300 75\n   ... 1 3\n   ... 1 4\n   ... 3 6\n   ... 4 5\n   ... 3 5\n   ... 4 6\n   ... 2 5\n   ... 2 6\n   ... ''')\n    '800'\n    \"\"\"\n    n, m = map(int, stdin.split('\\n')[:2])\n    g = {i: int(stdin.split('\\n')[i]) for i in range(n - 2)}\n    edges = [list(map(int, stdin.split('\\n')[i + 2].split())) for i in range(m)]\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        a, b = edge\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    d = {i: {'visited': False, 'out': 0} for i in range(n)}\n    q = deque()\n    q.append(graph[0])\n    d[0]['visited'] = True\n    while q:\n        current = q.popleft()\n        for neighbor in current:\n            if not d[neighbor]['visited']:\n                q.append(graph[neighbor])\n                d[neighbor]['visited'] = True\n                d[neighbor]['out'] = max(d[neighbor]['out'], d[current[0]]['out'] + g[neighbor])\n    return str(d[n - 1]['out'])\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"Hello, World!\"\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the maximum amount of gold that the bandits can steal on their way to the king\u2019s castle, and still be able to return home safely.\"\"\"\n    # Get number of villages and roads.\n    num_villages, num_roads = (int(x) for x in stdin.split(' ')[:2])\n    # Get the amount of gold in each village.\n    # We do this by finding the maximum of the amount of roads\n    # and the amount of villages.\n    village_golds = [int(x) for x in stdin.split('\\n')[2:]][:num_villages]\n    max_village_gold = max(village_golds)\n    # Calculate the number of roads to each other village.\n    # This will also tell us the number of ways to get to each other village.\n    # We will use this to compute the number of roads to the bandit's home.\n    # This will also tell us the number of ways to get home.\n    # We will also need to do this for the king's castle.\n    num_village_roads = []\n    for i in range(num_villages):\n        num_village_roads.append(num_roads - len(set(range(num_villages)) - {i, 1}))\n    # Add roads from the king's castle to each other village.\n    # This will have an effect if the bandit's home is adjacent to the king's castle.\n    num_village_roads.append(1)\n    # Calculate the number of ways to get to the bandit's home.\n    num_bandit_roads = sum(num_village_roads)\n    # Calculate the number of ways to get home.\n    num_bandit_home = num_village_roads.count(0)\n    # Calculate the number of ways to get to the king's castle.\n    num_king_castle_roads = num_roads - num_bandit_home - 1\n    # Determine the maximum amount of gold the bandit can steal.\n    max_bandit_gold = min(max_village_gold, num_bandit_roads)\n    # Determine the maximum amount of gold the bandits can steal and still get home safely.\n    max_bandit_gold_and_safe = max_bandit_gold + (num_bandit_home * num_king_castle_roads)\n    return max_bandit_gold_and_safe\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return string\n    \"\"\"\n    n, m = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    vert = [[i] for i in range(1, n + 1)]\n    for i in range(m):\n        a, b = [int(i) for i in stdin.split('\\n')[i+1].split(' ')]\n        vert[a-1].append(b)\n        vert[b-1].append(a)\n    vert.sort(key = lambda i: len(i))\n    graph = {}\n    for i in vert:\n        for j in i:\n            graph[j] = set(i)\n    print(graph)\n    return 0"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing the solution\"\"\"\n    return 'Not yet implemented'\n"
    },
    {
        "number": 3025,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return '1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    seq = [int(i) for i in stdin.split('\\n')[1].split()]\n    dp = [[seq[i]] for i in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            if seq[i] < seq[j]:\n                if len(dp[i]) < len(dp[j]) + 1:\n                    dp[i] = dp[j] + [seq[i]]\n    if len(dp[-1]) == 1:\n        print('-1')\n    else:\n        print(' '.join(str(i) for i in dp[-1]))\n    \n    return ''\n\n\ndef"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = [int(x) for x in stdin.readline().strip().split(' ')]\n    # dp[i][j] = max(dp[i - 1][k] + 1, dp[k][j] + 1, k!= i and j - k > 1 and nums[i] > nums[k] and nums[k] > nums[j])\n    dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - i > 1 and nums[i - 1] > nums[j - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] + 1)\n    res = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if dp[i][j] < n:\n                res.append(nums[i - 1])\n                break\n    if res:\n        return''.join([str(x) for x in res])\n    return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split(' ')))\n    count = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j] and count[i] < count[j]:\n                count[i] = count[j]\n        count[i] += 1\n    result = []\n    for i, c in enumerate(count):\n        if c == max(count):\n            result.append(arr[i])\n    print(' '.join(map(str, result))) if result else print('-1')\n    return ''"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = [int(x) for x in stdin.readline().strip().split()]\n    arr = [0] + arr\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        dp[i] = 1\n        for j in range(1, i):\n            if arr[j] < arr[i] and dp[j] > dp[i]:\n                dp[i] = dp[j]\n    maxx = 0\n    for i in range(1, n+1):\n        if dp[i] > maxx:\n            maxx = dp[i]\n    if maxx == 0:\n        return \"1\"\n    result = []\n    for i in range(1, n+1):\n        if dp[i] == maxx:\n            result.append(str(arr[i]))\n    return \" \".join(result)\n\nprint(solution(open(\"../input.txt\", \"r\").readlines()))\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n    prev = [0] * num\n    curr = [0] * num\n    for i in range(num):\n        curr[i] = 1\n        for j in range(i):\n            if arr[i] > arr[j] and curr[j] + 1 > prev[i]:\n                prev[i] = curr[j] + 1\n                curr[i] = prev[i]\n    # print(prev)\n    # print(curr)\n    m = max(prev)\n    for i in range(num):\n        if m == prev[i]:\n            print(arr[i])\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    arr = [int(i) for i in stdin.split(\"\\n\")[1].split(\" \")]\n    # print(arr)\n\n    lis = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    print(lis)\n    ans = []\n    for i in range(len(lis)):\n        if lis[i]!= i + 1:\n            ans.append(arr[i])\n    if ans:\n        return \" \".join([str(a) for a in ans])\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = [int(stdin.readline()) for _ in range(n)]\n    lis = [nums[0]]\n    for num in nums[1:]:\n        if num > lis[-1]:\n            lis.append(num)\n        else:\n            for i in range(len(lis)):\n                if num <= lis[i]:\n                    lis[i] = num\n                    break\n    ans = [num for num in nums if num not in lis]\n    print('\\n'.join(map(str, ans)) if len(ans) > 0 else '-1')\n    return ''\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = [int(i) for i in stdin.readline().strip().split()]\n\n    # arr = [int(i) for i in \"1 2 3 4\".split()]\n\n    # arr = [1, 3, 2, 4]\n    # arr = [3, 1, 5, 7, 4, 9]\n\n    max_ending_here = [1] * n\n    max_so_far = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and max_ending_here[i] < max_ending_here[j] + 1:\n                max_ending_here[i] = max_ending_here[j] + 1\n        if max_so_far < max_ending_here[i]:\n            max_so_far = max_ending_here[i]\n\n    return''.join(str(i) for i in range(n) if max_ending_here[i] == max_so_far)"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return all critical elements in the given sequence.\"\"\"\n    length = int(stdin.readline().strip())\n    sequence = sorted([int(line) for line in stdin.readlines()])\n    result = []\n    for i in range(1, length):\n        if not result or sequence[i] > result[-1]:\n            result.append(sequence[i])\n        else:\n            result[bisect_left(result, sequence[i])] = sequence[i]\n    if result:\n        return '\\n'.join(map(str, result))\n    return '-1'\n"
    },
    {
        "number": 3026,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin)"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution for the paper sorting problem.\n    '''\n    rows, cols = [int(x) for x in stdin.split(' ')]\n    map_array = []\n    for _ in range(rows):\n        map_array.append(list(stdin.split('\\n')[_]))\n\n    # 1: find all of the nubs that match the given map\n    # 2: check if there is an adjacent nub that is not in the list\n    # 3: count the nubs\n    nubs = 0\n    for row_index, row in enumerate(map_array):\n        for col_index, col in enumerate(row):\n            if col == '#':\n                nubs += 1\n                nubs += search_for_neighbours(map_array, row_index, col_index, rows, cols)\n    return nubs\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the smallest number of #'s that could have possibly made the input mark by stamping exactly twice.\"\"\"\n    return\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    arr = [stdin.split()[i] for i in range(h)]\n    stack = []\n    for i in range(h):\n        for j in range(w):\n            if arr[i][j] == '.':\n                stack.append((i, j))\n\n    def dfs(x: int, y: int, stack: list, visit: dict):\n        visit[(x, y)] = True\n        stack.append((x, y))\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        for i in range(4):\n            nx = x + dirs[i][0]\n            ny = y + dirs[i][1]\n            if 0 <= nx < h and 0 <= ny < w and arr[nx][ny] == '#' and not visit.get((nx, ny), False):\n                dfs(nx, ny, stack, visit)\n\n    res = 0\n    visit = dict()\n    while stack:\n        res += 1\n        cnt = 0\n        tmp = []\n        for i in range(len(stack)):\n            x, y = stack.pop()\n            if not visit.get((x, y), False):\n                dfs(x, y, tmp, visit)\n                cnt += 1\n        stack = tmp\n        if cnt < 2:\n            return res\n    return res\n\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return 0\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    count = 0\n    for row in range(h):\n        for col in range(w):\n            if stdin[row][col] == '#':\n                count += 1\n\n    return count\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    _, m = stdin.split(' ')\n    m = int(m)\n    board = []\n    for _ in range(int(m)):\n        line = stdin.split('\\n')[0]\n        line = list(line)\n        board.append(line)\n    # We know there are always 2 layers to check. If we are lucky, the inner layer\n    # of the stamp will always be blank\n    # If not, we will have to count the non-'#' cells in the inner layer\n    # We will check the first layer and the inner layer.\n    if (\n        board[0][0] == '#' or\n        board[0][-1] == '#' or\n        board[-1][0] == '#' or\n        board[-1][-1] == '#'\n    ):\n        print('1')\n    else:\n        count = 0\n        for i in range(m):\n            for j in range(m):\n                if board[i][j]!= '#':\n                    count += 1\n        print(count)\n"
    },
    {
        "number": 3027,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    mark = stdin.split('\\n')[1]\n    for i in range(0, n - 1):\n        mark += stdin.split('\\n')[i + 2]\n    stdout = []\n    for i in range(0, len(mark)):\n        if mark[i] == '#':\n            stdout.append(mark[i])\n    return stdout\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = []\n    for i in range(n):\n        row = list(map(int, stdin.split()))\n        if 2 in row:\n            board.append(row)\n    \n    moves = get_moves(board)\n\n    if len(moves) == 0:\n        return '-1'\n\n    winning_moves = get_winning_moves(moves, p)\n    \n    if winning_moves == None:\n        return '-1'\n\n    sequence = get_winning_move_sequence(winning_moves)\n\n    return''.join(map(str, sequence))\n    \n\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    import math\n    lines = stdin.split('\\n')\n    n, m, p = map(int, lines[0].split())\n    board = []\n    for i in range(n):\n        board.append(list(map(int, lines[i + 1].split())))\n\n    moves = 0\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == p:\n                moves += 1\n                board[i][j] = 1\n                break\n\n        for j in range(n):\n            if board[j][i] == p:\n                moves += 1\n                board[j][i] = 1\n                break\n\n    for i in range(m - 1, 0, -1):\n        for j in range(n):\n            if board[i][j] == p:\n                moves += 1\n                board[i][j] = 1\n                break\n\n        for j in range(n - 1, -1, -1):\n            if board[j][i] == p:\n                moves += 1\n                board[j][i] = 1\n                break\n\n    for j in range(n - 1, -1, -1):\n        for i in range(m):\n            if board[i][j] == p:\n                moves += 1\n                board[i][j] = 1\n                break\n\n        for i in range(m - 1, -1, -1):\n            if board[i][j] == p:\n                moves += 1\n                board[i][j] = 1\n                break\n\n    if moves >= math.floor(n * m / 2):\n        return str(moves)\n    return '-1'\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = [list(map(int, stdin.split())) for _ in range(n)]\n    # row_sum = [sum(i) for i in zip(*board)]\n    # col_sum = list(map(lambda x: sum(x), zip(*board)))\n    d = {i: set() for i in range(1, p+1)}\n    for i, j in product(range(n), range(m)):\n        if board[i][j] == p:\n            d[p].add((i, j))\n    for p in range(1, p+1):\n        for i, j in d[p]:\n            row_sum, col_sum = [0] * n, [0] * m\n            for x, y in product(range(i-1, i+2), range(j-1, j+2)):\n                if 0 <= x < n and 0 <= y < m:\n                    row_sum[x] += 1\n                    col_sum[y] += 1\n            for x, y in product(range(n), range(m)):\n                if board[x][y] == p:\n                    board[x][y] = row_sum[x] * col_sum[y] % p\n                    d[p].add((x, y))\n    visited = set()\n    for x, y in d[p]:\n        if (x, y) not in visited:\n            print(x, y, sep='\\n')\n            visited.add((x, y))\n    return \"\".join(list(map(str, visited)))\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    n, m, p = [int(i) for i in stdin.split(\"\\n\")[0].split(\" \")]\n    board = [[int(i) for i in stdin.split(\"\\n\")[i].split(\" \")] for i in range(1, n + 1)]\n\n    def solve(board, n, m, p):\n        visited = [0] * p\n\n        def dfs(board, n, m, p, visited, cur):\n            if cur == p * m * n:\n                return True\n            if cur == -1:\n                return False\n            visited[cur % p] = 1\n            cur += 1\n            for i in range(n):\n                for j in range(m):\n                    if board[i][j] == cur % p and not visited[cur % p]:\n                        if dfs(board, n, m, p, visited, cur):\n                            return True\n            return False\n\n        return dfs(board, n, m, p, visited, 0)\n    '''\n\n    n, m, p = [int(i) for i in stdin.split(\"\\n\")[0].split(\" \")]\n    board = [[int(i) for i in stdin.split(\"\\n\")[i].split(\" \")] for i in range(1, n + 1)]\n\n    def solve(board, n, m, p):\n        board = board\n\n        def dfs(board, n, m, p, visited, cur):\n            if cur == p * m * n:\n                return True\n            if cur == -1:\n                return False\n            visited[cur % p] = 1\n            cur += 1\n            for i in range(n):\n                for j in range(m):\n                    if board[i][j] == cur % p and not visited[cur % p]:\n                        if dfs(board, n, m, p, visited, cur):\n                            return True\n            return False\n\n        return dfs(board, n, m, p, [0] * p, 0)\n\n    def cmp(a, b):\n        if a > b:\n            return 1\n        if a < b:\n            return -1\n        return 0\n\n    def solve2(board, n, m, p):\n        def dfs(board, n, m, p, visited, cur):\n            if cur == p * m * n:\n                return True\n            if cur == -1:\n                return False\n            visited[cur % p] = 1\n            cur += 1\n            for i in range(n):\n                for j in range(m):\n                    if board[i][j] == cur % p and not visited[cur % p]:\n                        if dfs(board, n, m, p, visited, cur):\n                            return True\n                    if board[j][i] == cur % p and not visited[cur % p]:\n                        if dfs(board, n, m, p, visited, cur):\n                            return True\n            return False\n\n        def cmp(a, b):\n            if a > b:\n                return 1\n            if a < b:\n                return -1\n            return 0\n\n        def solve3(board, n, m, p):\n            def dfs(board, n, m, p, visited, cur):\n                if cur == p * m * n:\n                    return True\n                if cur == -1:\n                    return False\n                visited[cur % p] = 1\n                cur += 1\n                for i in range(n):\n                    for j in range(m):\n                        if board[i][j] == cur % p and not visited[cur % p]:\n                            if dfs(board, n, m, p, visited, cur):\n                                return True\n                            if board[j][i] == cur % p and not visited[cur % p]:\n                                if dfs(board, n, m, p, visited, cur):\n                                    return True\n                return False\n\n            def cmp(a, b):\n                if a > b:\n                    return 1\n                if a < b:\n                    return -1\n                return 0\n\n            def solve4(board, n, m, p):\n                def dfs(board, n, m, p, visited, cur):\n                    if cur == p * m * n:\n                        return True\n                    if cur == -1:\n                        return False\n                    visited[cur % p] = 1\n                    cur += 1\n                    for i in range(n):\n                        for j in range(m):\n                            if board[i][j] == cur % p and not visited[cur % p]:\n                                if dfs(board, n, m, p, visited, cur):\n                                    return True\n                                if board[j][i] == cur % p and not visited[cur % p]:\n                                    if dfs(board, n, m, p, visited, cur):\n                                        return True\n                return dfs(board, n, m, p, [0] * p, 0)\n\n            return dfs(board, n, m, p, [0] * p, 0)\n\n        return solve3(board, n, m, p)\n\n    return str(solve2(board, n, m, p))\n\n\nfor i in range(int(input())):\n    print(solution(input()))\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = open(\"input.txt\", \"r\").read().strip()\n    n, m, p = [int(x) for x in stdin.split(\"\\n\")[0].split()]\n    board = [[int(x) for x in stdin.split(\"\\n\")[1].split()] for _ in range(n)]\n    numbers = p * m\n    moves = 0\n\n    while True:\n        if moves > p * m * n:\n            break\n        for i in range(n):\n            if is_winning_state(board, numbers, p, m, n, i, moves):\n                return str(moves)\n        moves += 1\n        if is_full_board(board):\n            return \"-1\"\n\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the solution for a given input\n    :param stdin: input in string format\n    :return: solution in string format\n    \"\"\"\n    n, m, p = [int(item) for item in stdin.split()]\n    board = [[int(item) for item in stdin.split()] for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    answer = -1\n    moves = p * m * n\n    sequence = [n * m]\n    stack = [n * m]\n    while True:\n        answer += 1\n        if answer == moves:\n            return \" \".join(map(str, sequence[:moves]))\n        if len(stack) == 0:\n            return \" \".join(map(str, sequence[:answer]))\n        elif answer >= moves:\n            return \" \".join(map(str, sequence[:answer]))\n        else:\n            x, y = stack.pop()\n            if visited[x][y]:\n                continue\n            else:\n                visited[x][y] = True\n            if board[x][y] == p:\n                continue\n            if board[x][y] == 1:\n                board[x][y] = p\n                for i in range(n):\n                    if i!= x:\n                        stack.append((i, y))\n            elif board[x][y] == p:\n                board[x][y] = 1\n                for i in range(n):\n                    if i!= x:\n                        stack.append((i, y))\n            else:\n                for i in range(n):\n                    if i!= x:\n                        stack.append((i, y))\n            sequence.append(y)\n            for j in range(m):\n                if not visited[x][j] and j!= y:\n                    stack.append((x, j))\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = [int(x) for x in stdin.split()]\n    board = [[int(y) for y in stdin.split('\\n')[i][j * m:(j + 1) * m]] for i in range(n)]\n    queue = [(x, y, 0) for x in range(n) for y in range(m) if board[x][y] == p]\n    solution = []\n    while queue:\n        x, y, moves = queue.pop(0)\n        if not solution or moves < solution[0][2]:\n            solution = [(x, y, moves)]\n        elif moves == solution[0][2]:\n            solution.append((x, y, moves))\n        # check horizontal\n        if x > 0 and board[x][y] == p and board[x - 1][y] == 0:\n            queue.append((x - 1, y, moves + 1))\n        # check vertical\n        if y > 0 and board[x][y] == p and board[x][y - 1] == 0:\n            queue.append((x, y - 1, moves + 1))\n        # check left diagonal\n        if x > 0 and y > 0 and board[x][y] == p and board[x - 1][y - 1] == 0:\n            queue.append((x - 1, y - 1, moves + 1))\n        # check right diagonal\n        if x > 0 and y < m - 1 and board[x][y] == p and board[x - 1][y + 1] == 0:\n            queue.append((x - 1, y + 1, moves + 1))\n    if not solution:\n        print(-1)\n    else:\n        print(moves)\n        for x, y, moves in solution:\n            print('{} {} {}'.format(x + 1, y + 1, moves))\n"
    },
    {
        "number": 3028,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    grid = [list(map(int, stdin.split())) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == p:\n                s = {(i, j)}\n                queue = deque([(i, j)])\n                visited = set()\n                visited.add((i, j))\n                while queue:\n                    cur = queue.popleft()\n                    for ni, nj in [cur[0] + 1, cur[1]], [cur[0] - 1, cur[1]], [cur[0], cur[1] + 1], [cur[0], cur[1] - 1]:\n                        if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == p and (ni, nj) not in visited:\n                            visited.add((ni, nj))\n                            s.add((ni, nj))\n                            queue.append((ni, nj))\n                if len(s) == p * m * n:\n                    return''.join(map(str, [i + 1 for i in sorted(s)]))\n    return '-1'\n    \n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    # Your code goes here\n    "
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the largest length of a jumping path where the labels of the\n    vertices are nondecreasing and the number of jumping paths of this\n    length is divisible by the number of primes less than 100000.\n\n    >>> solution(\"5\\n3\\n3\\n3\\n3\\n1\\n2\\n3\\n4\\n\")\n    '5 1'\n    \"\"\"\n    def find_path(k: int) -> int:\n        \"\"\"Find the longest length of a jumping path where the labels of the\n        vertices are nondecreasing and the number of jumping paths of this\n        length is divisible by the number of primes less than 100000.\n        \"\"\"\n        for p in primes:\n            if k % p == 0:\n                return p\n        return 0\n\n    vertices = [int(s) for s in stdin.strip().split()]\n\n    # Find the prime numbers up to 100,000 that are less than or equal to the\n    # number of vertices. This is necessary for the computation to terminate\n    # correctly since every vertex will be a descendant of the root and\n    # therefore the path will have all labels increasing.\n    primes = [p for p in prime_sieve(max(vertices) + 1)]\n\n    # The root is the only vertex with no parent.\n    root = vertices[0]\n    # Find the longest length of a jumping path where the labels of the\n    # vertices are nondecreasing and the number of jumping paths of this\n    # length is divisible by the number of primes less than 100000.\n    return \" \".join([str(max([1, find_path(len(vertices) - i)])) for i in range(1, len(vertices))])\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\n3\\n3\\n3\\n3\\n1\\n2\\n3\\n4\")\n    5 1\n    >>> solution(\"5\\n4\\n3\\n2\\n1\\n0\\n1\\n2\\n3\\n4\")\n    1 5\n    >>> solution(\"4\\n1\\n5\\n3\\n6\\n1\\n2\\n3\")\n    3 2\n    \"\"\"\n    n = int(stdin)\n    tree = dict()\n    for i in range(1, n):\n        p, c = [int(j) for j in stdin.split('\\n')[i].split(' ')]\n        tree[p] = c\n    return str(longest_nondecreasing_path(tree, 0, [])) +'' + str(longest_nondecreasing_path_count(tree, 0, []))\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes two quantities for the given tree.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string.\n\n    Returns\n    -------\n    str\n        The answer to the problem.\n    \"\"\"\n    N = int(stdin[0])\n    # Construct a dictionary mapping each vertex to its parent\n    parent_dict = {i: int(stdin[i + 1]) for i in range(N)}\n\n    # Initialize a queue for breadth first search and a list for keeping track\n    # of the longest jumping path and the number of longest jumping paths\n    # at every depth\n    queue = deque([(1, 1)])\n    longest_jumping_paths = [1]\n    max_longest_jumping_paths = 1\n\n    # While there are still vertices in the queue, do the following:\n    # 1. Remove the first vertex in the queue and add its children to the queue\n    # 2. Check the longest jumping path that can be formed starting at the current vertex\n    # 3. Update the longest jumping paths if necessary\n    while queue:\n        v, longest_jumping_path_length = queue.popleft()\n        for child in parent_dict[v]:\n            queue.append((child, longest_jumping_path_length + 1))\n            if longest_jumping_path_length + 1 > max_longest_jumping_paths:\n                max_longest_jumping_paths = longest_jumping_path_length + 1\n            if longest_jumping_path_length + 1 > longest_jumping_paths[-1]:\n                longest_jumping_paths.append(longest_jumping_path_length + 1)\n\n    # The length of the longest jumping path is the number of longest jumping paths\n    # in the tree minus the number of longest jumping paths that contain labels\n    # that are not nondecreasing\n    L = len(longest_jumping_paths) - \\\n        sum([1 for path in longest_jumping_paths if all([u_i <= u_j for u_i, u_j in zip(path, path[1:])])])\n    # The number of jumping paths of length L is the number of longest jumping paths\n    # in the tree divided by the largest prime smaller than or equal to L\n    M = len(longest_jumping_paths) // next_prime(L)\n\n    return''.join([str(L), str(M % (10**9 + 7))])\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    nums = [int(num) for num in stdin.read().splitlines()]\n    nums.sort()\n    longest = 0\n    i = 2\n    while i < N:\n        longest += 1\n        j = i\n        while j < N:\n            if nums[j] > nums[j - 1]:\n                i = j\n                break\n            j += 1\n        else:\n            i += 1\n    print(longest, N % 11092019)"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the two integers separated by a space\n\n    Parameters\n    ----------\n    stdin : str\n        The input string\n\n    Returns\n    -------\n    str\n        The input string with the two integers separated by a space\n    \"\"\"\n    return f\"{len(stdin)}\\n{solution_solve(stdin)}\"\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the longest jumping path in a tree and compute its length and number of paths of that length.\n\n    Args:\n        stdin (str): Input string of the test case.\n\n    Returns:\n        str: The output string of the test case.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    A = [int(n) for n in stdin.readline().split()]\n    B = [[int(n) for n in stdin.readline().split()] for _ in range(N - 1)]\n    A_mod = [None] * N\n    A_mod[0] = A[0]\n    for i in range(1, N):\n        A_mod[i] = (A_mod[i - 1] + A[i]) % 11092019\n    L, M = 0, 0\n    for p in B:\n        if p[0] == 0:\n            continue\n        l = 0\n        while A_mod[l] < A[p[0]]:\n            l += 1\n        l -= 1\n        j = l\n        while j < N:\n            M += A[p[0]] - A_mod[j]\n            M %= 11092019\n            j += 1\n        L = max(L, j - 1)\n    return str(L) + \" \" + str(M % 11092019)\n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *nums = map(int, stdin.split('\\n'))\n    edges = list(zip(nums, nums[1:])) + [(nums[-1], -1)]\n    \n    def dfs(n: int, p: int, depth: int):\n        visited.add(n)\n        depths[n] = depth\n        for to, _ in edges[n]:\n            if to == p: continue\n            if to in visited:\n                continue\n            dfs(to, n, depth + 1)\n    \n    def find_paths(n: int, p: int, depth: int):\n        if depth >= L: return\n        for to, edge in edges[n]:\n            if to == p: continue\n            if to not in depths or depths[n] + edge >= depths[to]:\n                paths[to].add(depth)\n            find_paths(to, n, depth + edge)\n    \n    visited = set()\n    depths = dict()\n    paths = defaultdict(set)\n    dfs(0, -1, 0)\n    L = max(depths.values())\n    M = 0\n    for n in range(1, n + 1):\n        if n not in visited and depths[n] == L:\n            M += 1\n        find_paths(n, -1, 0)\n    \n    M %= 11092019\n    return f'{L} {M}'\n    \n"
    },
    {
        "number": 3029,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest jumping path and its length in the tree.\"\"\"\n    # Read input\n    n = int(stdin.readline().strip())\n    labels = [int(x) for x in stdin.readline().strip().split()]\n    # Create graph with the edges as labels\n    graph = {}\n    for vertex, label in enumerate(labels):\n        parent = int(stdin.readline().strip())\n        graph[vertex] = parent - 1\n    # Find longest path\n    longest_path = []\n    root = labels.index(min(labels))\n    # Breadth-first search\n    queue = deque()\n    queue.append(root)\n    while len(queue) > 0:\n        vertex = queue.popleft()\n        for neighbour in graph[vertex]:\n            if labels[neighbour] > labels[vertex]:\n                longest_path.append(vertex + 1)\n                queue.append(neighbour)\n    # Find length of the longest path\n    longest_path_length = max(longest_path)\n    # Find number of paths of the longest path\n    longest_path_number = math.ceil(math.sqrt(longest_path_length))\n    # Find remainder of the number of paths of the longest path\n    # modulo the prime 11092019\n    longest_path_number_remainder = longest_path_number % 11092019\n    # Print output\n    return f'{longest_path_length} {longest_path_number_remainder}'\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(N) / O(N)\"\"\"\n    n = int(stdin.readline().strip())\n    nodes = {}\n    for i in range(n):\n        v, p = map(int, stdin.readline().split())\n        nodes[i] = (v, p)\n    count = 0\n    for i in range(n):\n        v, p = nodes[i]\n        while p!= -1:\n            v, p = nodes[p]\n        if v > count:\n            count = v\n    return count\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Complexity:\n        n = number of nodes\n        Time: O(n log n)\n        Space: O(n)\n    \"\"\"\n\n    def heapify(tree: List[List[int]], n: int, index: int, parentIndex: int):\n        \"\"\"\n        Complexity:\n            n = number of nodes\n            Time: O(log n)\n            Space: O(1)\n        \"\"\"\n        while 2 * index + 1 < n:\n            leftIndex = 2 * index + 1\n            rightIndex = leftIndex + 1\n            left = tree[leftIndex]\n            right = tree[rightIndex]\n            parent = tree[parentIndex]\n            if left[1] > right[1] or (\n                left[1] == right[1] and left[0] < right[0]\n            ):\n                if parent[1] > left[1] or (\n                    parent[1] == left[1] and parent[0] < left[0]\n                ):\n                    tree[index], tree[parentIndex] = tree[parentIndex], tree[index]\n                    index = parentIndex\n                    parentIndex = int((index - 1) / 2)\n            else:\n                if parent[1] > right[1] or (\n                    parent[1] == right[1] and parent[0] < right[0]\n                ):\n                    tree[index], tree[parentIndex] = tree[parentIndex], tree[index]\n                    index = parentIndex\n                    parentIndex = int((index - 1) / 2)\n\n    def buildHeap(tree: List[List[int]]):\n        \"\"\"\n        Complexity:\n            n = number of nodes\n            Time: O(n)\n            Space: O(n)\n        \"\"\"\n        n = len(tree)\n        for index in range(int(n / 2), -1, -1):\n            heapify(tree, n, index, index)\n\n    def heapSort(tree: List[List[int]]):\n        \"\"\"\n        Complexity:\n            n = number of nodes\n            Time: O(n log n)\n            Space: O(1)\n        \"\"\"\n        buildHeap(tree)\n        n = len(tree)\n        for i in range(n - 1, 0, -1):\n            tree[0], tree[i] = tree[i], tree[0]\n            heapify(tree, i, 0, 0)\n\n    tree = []\n    numNodes = int(stdin.readline())\n    for _ in range(numNodes):\n        tree.append(\n            [int(num) for num in stdin.readline().split(\" \")]\n        )\n    heapSort(tree)\n    result = 1\n    current = 1\n    while tree[0][0]!= 1:\n        result += 1\n        tree[0], tree[current] = tree[current], tree[0]\n        current = 0\n        heapify(tree, current, 0, 0)\n    return result\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns solution of the problem\"\"\"\n    # getting number of nodes\n    num_nodes = int(stdin.split(\"\\n\")[0])\n    # initializing list to store nodes in\n    nodes = []\n    # getting nodes\n    for _ in range(num_nodes):\n        nodes.append(tuple(map(int, stdin.split(\"\\n\")[_].split())))\n    # getting the final answer\n    ans = dfs(nodes, num_nodes)\n    return ans"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    graph = {i: [] for i in range(1, n + 1)}\n    values = {i: 0 for i in range(1, n + 1)}\n    for i in range(1, n):\n        parent, child = map(int, stdin.readline().split())\n        graph[parent].append(child)\n        values[child] = values[parent] + 1\n    queue = deque()\n    queue.append(1)\n    visited = set()\n    while queue:\n        node = queue.popleft()\n        visited.add(node)\n        for child in graph[node]:\n            if child not in visited:\n                queue.append(child)\n                values[child] = max(values[child], values[node] + 1)\n    return len(visited)\n\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    arr = [None] + [tuple(map(int, stdin.readline().strip().split(' '))) for _ in range(N - 1)]\n    visited = set()\n    dp = [0] * (N + 1)\n    root = 1\n    for i, (v, p) in enumerate(arr):\n        if p == 0:\n            root = i + 1\n        elif i in visited:\n            dp[p] = max(dp[p], dp[i] + 1)\n        else:\n            dp[p] = max(dp[p], dp[i] + 1)\n            for j in range(i, p, -1):\n                visited.add(j)\n    return max(dp[1:])\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    tree = []\n    for i in range(1, n+1):\n        tree.append([int(x) for x in inputs[i].split()])\n    \n    num_elements = 0\n    max_num_elements = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (tree[j][0] in tree[i]) or (tree[i][0] in tree[j]):\n                if j > i:\n                    continue\n                num_elements += 1\n                if j > i:\n                    break\n    max_num_elements = max(max_num_elements, num_elements)\n    return str(max_num_elements)\n\nprint(solution(\"5\\n3 0\\n3 1\\n3 2\\n3 3\\n3 4\"))\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum number of nodes you can choose to form a subset that satisfies the Heap Property\"\"\"\n    # Get the number of nodes\n    number_of_nodes = int(stdin)\n\n    # Get the input data\n    input_data = [None] * number_of_nodes\n    for index in range(number_of_nodes):\n        input_data[index] = [int(x) for x in stdin.split()]\n\n    # Create a graph\n    graph = {}\n    for node in range(1, number_of_nodes + 1):\n        graph[node] = [0] + input_data[node - 1][1:]\n\n    # Populate the graph\n    for node in range(number_of_nodes):\n        for parent in graph[node + 1][1:]:\n            graph[parent].append(node + 1)\n\n    # Initialize the visited list\n    visited = {}\n    for node in range(1, number_of_nodes + 1):\n        visited[node] = False\n\n    # DFS to populate the visited list\n    def dfs(node: int) -> None:\n        visited[node] = True\n\n        for child in graph[node]:\n            if not visited[child]:\n                dfs(child)\n\n    # Iterate over the nodes and count the number of nodes\n    count = 0\n    for node in range(1, number_of_nodes + 1):\n        if not visited[node]:\n            dfs(node)\n            count += 1\n\n    return count\n"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return number of nodes in largest subset satisfying Heap Property.\"\"\"\n    n, node_parents = map(int, stdin.split('\\n')[0].split())\n    nodes = [None] * (n + 1)\n    for line in stdin.split('\\n')[1:]:\n        i, parent = map(int, line.split())\n        nodes[i] = (parent, node_parents - 1)\n        node_parents -= 1\n    \n    count = 0\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        if nodes[node][0] is None:\n            count += 1\n        else:\n            stack.append(node)\n            stack.append(nodes[node][0])\n    return count\n\ndef"
    },
    {
        "number": 3030,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return solution\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds all the good nodes in the given tree.\n\n    Args:\n        stdin (str): A single line of input containing $n$ nodes and $n - 1$ edges.\n\n    Returns:\n        str: All the good nodes in the given tree.\n    \"\"\"\n    n = int(stdin.split('\\n')[0])\n    edges = [list(map(int, line.split('\\n')[0].split(' '))) for line in stdin.split('\\n')[1:]]\n    good_nodes = []\n    for i in range(n):\n        is_good = True\n        for a, b, c in edges:\n            if c == i + 1:\n                if [a, b] == [i, i + 1] or [a, b] == [b, a]:\n                    is_good = False\n                    break\n                if edges.count([a, b]) > 1:\n                    is_good = False\n                    break\n                if [a, b] in edges and [b, a] in edges:\n                    is_good = False\n                    break\n        if is_good:\n            good_nodes.append(i)\n    return''.join(str(node + 1) for node in good_nodes)\n    "
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    def dfs(node: int, visited: List[int]) -> int:\n        visited[node] = True\n        rainbows = 0\n        for adj in graph[node]:\n            if not visited[adj]:\n                rainbows += dfs(adj, visited)\n        return rainbows\n\n    n = int(stdin.readline())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n        if c == 2:\n            graph[a - 1].append(b - 1)\n            graph[b - 1].append(a - 1)\n    visited = [False] * n\n    rainbows = 0\n    for i in range(n):\n        if not visited[i]:\n            rainbows += dfs(i, visited)\n    print(rainbows)\n    for i in range(rainbows):\n        print(i + 1)\n\n    return \"\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    stdin = int(stdin)\n    nodes = []\n    for _ in range(stdin):\n        a, b, c = stdin.split()\n        nodes.append((int(a), int(b), int(c)))\n\n    good_nodes = []\n    for node in range(1, stdin + 1):\n        if node == nodes[0][1] or node == nodes[0][2]:\n            good_nodes.append(node)\n\n    for node in range(1, stdin + 1):\n        if nodes[node][1] == nodes[node][2]:\n            good_nodes.append(node)\n\n    for node in range(1, stdin + 1):\n        if nodes[node][0] == nodes[node][1]:\n            good_nodes.append(node)\n\n    for node in range(1, stdin + 1):\n        if nodes[node][0] == nodes[node][2]:\n            good_nodes.append(node)\n\n    if len(good_nodes) == 0:\n        return 0\n    return '\\n'.join(map(str, good_nodes))\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of good nodes in the tree, as well as the\n    indices of those nodes.\n\n    Args:\n        stdin (str): input on STDIN\n\n    Returns:\n        str: output to STDOUT\n    \"\"\"\n    n = int(stdin)\n    tree = {}\n    for line in stdin.split('\\n')[:-1]:\n        a, b, c = map(int, line.split(' '))\n        if a not in tree:\n            tree[a] = {b: c}\n        else:\n            tree[a][b] = c\n    good_nodes = []\n    for i in tree:\n        if is_good_node(tree, i):\n            good_nodes.append(i)\n    return''.join(map(str, good_nodes))\n\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    line = lines[0]\n    n = int(line)\n    data = [[] for _ in range(n)]\n    for i in range(n - 1):\n        line = lines[i + 1]\n        data[int(line.split(' ')[0]) - 1].append([int(x) for x in line.split(' ')[1:]])\n    good_nodes = []\n\n    def color_paths(node_a: int, node_b: int, path: [[]]):\n        if node_a == node_b:\n            return True\n        for edge in data[node_a]:\n            if edge[0] == node_b:\n                if color_paths(edge[1], node_b, path + [edge[2]]):\n                    return True\n            if edge[0] not in path:\n                return color_paths(edge[0], node_b, path + [edge[2]])\n        return False\n\n    for i in range(n):\n        if all(color_paths(i, j, []) for j in range(n)):\n            good_nodes.append(i)\n    print(len(good_nodes))\n    for node in good_nodes:\n        print(node + 1)\n\n    return \"\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    O(n) time and O(n) space\n    \"\"\"\n    #\n    # Your code here\n    #\n\n    pass\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def helper(root):\n        nonlocal good_nodes\n        if root in seen:\n            return\n        seen.add(root)\n        good_nodes += 1\n        for neighbor in graph[root]:\n            helper(neighbor)\n\n    graph = {}\n    n = int(stdin.split()[0])\n    m = int(stdin.split()[1])\n    for i in range(m):\n        a, b, c = map(int, stdin.split()[i * 3:i * 3 + 3])\n        if a not in graph:\n            graph[a] = [b]\n        else:\n            graph[a].append(b)\n        if b not in graph:\n            graph[b] = [a]\n        else:\n            graph[b].append(a)\n    good_nodes = 0\n    seen = set()\n    for node in graph:\n        helper(node)\n    return good_nodes\n\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_all_edges(i: int) -> list[tuple[int, int, int]]:\n        res = []\n        for j in range(1, n + 1):\n            if G[i][j]:\n                res.append((i, j, G[i][j]))\n        return res\n\n    n = int(stdin.readline())\n    G = [list(map(int, stdin.readline().split())) for i in range(n)]\n\n    good = set()\n    for i in range(1, n + 1):\n        edges = get_all_edges(i)\n        for j, k, _ in edges:\n            if i!= j:\n                for l, m, _ in edges:\n                    if j!= l and k!= m:\n                        if G[j][l] == G[k][m] and G[j][k] == G[l][m]:\n                            break\n                else:\n                    good.add(i)\n                    break\n\n    return f\"{len(good)}\\n{' '.join(map(str, sorted(good)))}\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution prints the good nodes in alphabetical order, with one good node per line.\n    \"\"\"\n    n = int(stdin.readline())\n    good_nodes = []\n    good_nodes_set = set()\n    for i in range(n):\n        a, b, c = map(int, stdin.readline().split())\n        good_nodes_set.add(a)\n        good_nodes_set.add(b)\n\n    for i in range(1, n+1):\n        if i in good_nodes_set:\n            good_nodes.append(i)\n\n    print(len(good_nodes))\n    for node in good_nodes:\n        print(node)\n\n    return \"\"\n"
    },
    {
        "number": 3031,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    banks = stdin.split(\"\\n\")[0]\n    banks = list(map(int, banks.split()))\n\n    variables = stdin.split(\"\\n\")[1]\n    variables = list(variables.split())\n    variables = list(filter(lambda x: x!= \"\", variables))\n\n    # index of variable\n    var_index = dict()\n    for i, v in enumerate(variables):\n        var_index[v] = i\n\n    # indexes of memory banks\n    indexes = [0] * banks[0] * banks[1]\n\n    # read the program\n    program = stdin.split(\"\\n\")[2]\n    program = list(program)\n\n    # for every instruction\n    instructions = []\n    for i, op in enumerate(program):\n        if op == \"R\":\n            n = int(program[i + 1])\n            for _ in range(n):\n                var = program[i + 2]\n                index = var_index[var]\n                indexes[index] += 1\n        elif op == \"V\":\n            var = program[i + 1]\n            index = var_index[var]\n            indexes[index] += 1\n        elif op == \"E\":\n            pass\n\n    # find smallest execution time\n    min_time = float(\"inf\")\n    for index in indexes:\n        if index < min_time:\n            min_time = index\n    print(min_time)\n\n    return \"\""
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    b, s = list(map(int, stdin.split()))\n    input_string = stdin.split()\n    # get program\n    program = [x for x in input_string if x[0] in 'VV']\n    # get all variable names\n    var_names = [x for x in input_string if x[0] in 'VV' and len(x) > 1]\n    # build mapping\n    var_to_bank = {var_names[i]: i for i in range(s)}\n    # build sets\n    var_keys = set(var_names)\n    var_in = {var_names[i]: set(var_names[i+1:]) for i in range(s)}\n    # get edges\n    edges = set()\n    for n, v in enumerate(program):\n        if v[0] == 'V':\n            v_name = v[1:]\n            edges.add(v_name)\n            edges.update(var_in[v_name])\n    # get solution\n    solution = dfs(var_keys, var_in, var_to_bank, edges)\n    return str(solution)"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    memory_banks, variables = map(int, stdin.split())\n    program = list(map(str, stdin.split()))\n    print(len(program))\n    return ''"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    b, s = lines[0].split()\n    b, s = int(b), int(s)\n    p = lines[1]\n    min_time = float('inf')\n    for bank in range(b):\n        # get indices of variable references\n        variable_indices = [i for i in range(len(p)) if p[i] == 'V']\n        # initialize variables and bank select register\n        variables = [0] * s\n        bank_select_register = None\n        time = 0\n        # loop through each variable reference\n        for index in variable_indices:\n            # if reference to a variable, set variable\n            if p[index] == 'V':\n                variables[index - 1] = variables[index - 1] + 1\n            # if reference to a bank, set the bank select register\n            elif p[index] == 'R':\n                bank_select_register = variables[index - 1]\n            # if reference to an end, add time to total\n            elif p[index] == 'E':\n                time += 1\n        # update min time to smallest time\n        if time < min_time:\n            min_time = time\n    return str(min_time)"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split(\" \"))\n    code = list(map(int, stdin.split(\" \")))\n    code_set = set(code)\n    code_set.add(0)\n    code_set.add(1)\n    code_dict = {}\n    for i in range(1, b * s + 1):\n        code_dict[i] = i in code_set\n    result = 0\n    for i in range(len(code)):\n        if code[i] == 0:\n            result += 1\n        elif code[i] == 1:\n            result += 2\n        elif code[i] == 2:\n            result += 3\n        elif code[i] == 3:\n            result += 4\n        elif code[i] == 4:\n            result += 5\n        elif code[i] == 5:\n            result += 6\n        elif code[i] == 6:\n            result += 7\n        elif code[i] == 7:\n            result += 8\n        elif code[i] == 8:\n            result += 9\n        elif code[i] == 9:\n            result += 10\n    print(result)\n    return \"\"\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    banks, variables = [int(line) for line in stdin.strip().split('\\n')]\n    data = [int(line) for line in stdin.strip().split('\\n')[1].split(' ')]\n\n    def make_variables(banks: int, data: list) -> dict:\n        return {f'V{i}': data[i - 1] for i in range(1, banks + 1)}\n\n    def make_program(data: list) -> dict:\n        return {f'R{i}': data for i in range(1, len(data) + 1)}\n\n    def make_repetitions(data: list) -> dict:\n        return {f'R{i}': data for i in range(1, len(data) + 1)}\n\n    def make_loops(data: list) -> dict:\n        return {f'R{i}': data for i in range(1, len(data) + 1)}\n\n    def make_vars(variables: int) -> dict:\n        return {f'V{i}': 0 for i in range(1, variables + 1)}\n\n    variables = make_variables(banks, data)\n    program = make_program(data)\n    repetitions = make_repetitions(data)\n    loops = make_loops(data)\n    vars = make_vars(variables)\n    return solve(variables, program, repetitions, loops, vars)\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3032,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, m = map(int, stdin.split())\n    program = stdin.split()[1:]\n    # create dictionary that maps a variable to a bank\n    var_bank = {}\n    for i in range(n):\n        bank = stdin.split()[i * m + 2: (i + 1) * m + 2]\n        var_bank[bank[0]] = int(bank[1])\n\n    # count total number of memory references\n    n_refs = 0\n    # loop through program\n    for i in range(len(program)):\n        # if repeat instruction\n        if program[i] == 'R':\n            n_refs += int(program[i + 1])\n        # if variable reference\n        elif program[i] == 'V':\n            n_refs += 1\n        # if ending loop\n        elif program[i] == 'E':\n            # add number of references in loop to total number of references\n            n_refs += int(program[i - 1])\n\n    return n_refs\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Takes the first line of the input and converts it to a tuple of (B, N)\n    '''\n    B, N = (int(i) for i in stdin.split())\n    '''\n    B - the base of the number\n    N - the number to be converted into base B\n    \n    the number is converted to base B through the function f, which is defined\n    as f(B, N) = a1 * B^0 + a2 * B^1 +... + ad * B^d\n    \n    the function f works only when 0 < B <= 10, so we'll just run a try/except block\n    '''\n    try:\n        f = lambda base, num: sum(int(c) * base**i for i, c in enumerate(str(num)))\n        \n        return f(B, N)\n    except:\n        return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    result = ''\n    while result == '' or int(result) >= 2 ** 63:\n        result = ''.join(sorted(str(B * int(''.join(sorted(str(N), reverse=True))))))\n        result = result[result.index('0'):]\n    return result if result!= '' else 'impossible'"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    (base, number) = lines[0].split()\n    (base, number) = (int(base), int(number))\n\n    digits = [digit for digit in str(number)]\n\n    solutions = []\n    while True:\n        (first_digit, last_digit) = (digits[0], digits[-1])\n        digits.pop(0)\n        digits.pop(-1)\n\n        solution = int(''.join(digits))\n        solutions.append(solution)\n        if first_digit < last_digit:\n            digits.insert(0, first_digit)\n            digits.insert(0, last_digit)\n            break\n    for base in range(3, base):\n        for solution in solutions:\n            if not solution:\n                break\n            if solution in [base ** i for i in range(0, len(digits))]:\n                return solution\n\n    return 'impossible'\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    \n    if N == 0:\n        return \"0\"\n\n    for base in range(2, B + 1):\n        digits = []\n\n        while N > 0:\n            digits.append(N % base)\n            N //= base\n\n        digits.reverse()\n        N = sum(d * base**i for i, d in enumerate(digits))\n\n        if N == 0:\n            return \"0\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the base and number from the stdin and determine the solution.\n\n    >>> solution('10 24')\n    '38'\n    >>> solution('9 216')\n    '546'\n    \"\"\"\n    base, number = [int(i) for i in stdin.split(' ')]\n    solution = get_solution(base, number)\n\n    return str(solution) if solution is not None else 'impossible'\n\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, n = [int(x) for x in stdin.strip().split(' ')]\n    digits = []\n    while n!= 0:\n        digits.append(n % b)\n        n //= b\n\n    if 2 in digits:\n        return 'impossible'\n\n    result = [''] * len(digits)\n    for i, d in enumerate(digits):\n        if d < len(result):\n            result[d] = str(i)\n\n    return ''.join(result)\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, n = (int(x) for x in stdin.split())\n    r = 0\n    while n > 0:\n        r = r * b + n % b\n        n //= b\n    return str(r) if r > 0 else 'impossible'\n\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    if n == 0:\n        return \"impossible\"\n    elif n == 1:\n        return \"1\"\n    elif b == 1:\n        return str(n)\n    elif n < b:\n        return \"impossible\"\n    elif n == b * n:\n        return str(n//b)\n    else:\n        n = n - b * int(n / b)\n        s = str(n)\n        while s[-1] == \"0\":\n            s = s[:-1]\n        return s\n    \n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Return str.\n    '''\n    b, n = map(int, stdin.strip().split(' '))\n    if n == 0 or n == 1:\n        return 'impossible'\n    if b == 1:\n        if n > 1:\n            return 1\n        return 'impossible'\n    if n % b == 0:\n        return n // b\n    if n % b == 1:\n        return int(math.ceil(n / b))\n    x = n // b\n    while x % 10 == 0:\n        x = x // 10\n    while x % 10 == 9:\n        x = x // 10\n    return x * b + b\n"
    },
    {
        "number": 3033,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split(' '))\n    if N >= 2 ** 63:\n        return 'impossible'\n    if N == 0:\n        return 0\n    if B == 2:\n        return N\n    L = [int(d) for d in str(N)]\n    M = {i: l for i, l in enumerate(L)}\n    X = max(M, key=M.get)\n    for i in range(1, X):\n        if (N - sum(d * (10 ** i) for d in L[:i])) % B == 0:\n            return i\n    return 'impossible'\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    d, t, c, r = map(int, stdin.split())\n    clouds = [list(map(int, stdin.split())) for i in range(c)]\n    for i in range(c):\n        clouds[i][0] *= t\n        clouds[i][1] *= t\n    roofs = [list(map(int, stdin.split())) for i in range(r)]\n    return min(\n        [\n            sum([t * cloud[0] for cloud in clouds if cloud[1] <= i <= cloud[2]])\n            for i in range(t)\n        ]\n        + [\n            sum([\n                t * cloud[0] * roof[1] / (d - roof[0])\n                for cloud in clouds\n                if cloud[1] <= i <= cloud[2]\n            ])\n            for roof in roofs\n            if roof[0] < d\n        ]\n    )\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the minimum rain expected.\n\n    Args:\n        stdin (str): A string of input arguments.\n\n    Returns:\n        str: A string with the answer.\n    '''\n    input_list = stdin.split('\\n')\n    # Get the input variables\n    distance = int(input_list[0].split(' ')[0])\n    time = int(input_list[0].split(' ')[1])\n    clouds = int(input_list[0].split(' ')[2])\n    roofs = int(input_list[0].split(' ')[3])\n    # Create the clouds list\n    clouds_list = []\n    for cloud in range(clouds):\n        clouds_list.append(input_list[cloud+1].split(' '))\n    # Create the roof list\n    roofs_list = []\n    for roof in range(roofs):\n        roofs_list.append(input_list[clouds+roof+1].split(' '))\n    # Create the dictionaries\n    cloud_dict = {}\n    for cloud in clouds_list:\n        cloud_dict[cloud[0]] = {}\n        cloud_dict[cloud[0]]['start'] = int(cloud[1])\n        cloud_dict[cloud[0]]['end'] = int(cloud[2])\n        cloud_dict[cloud[0]]['probability'] = float(cloud[3])\n        cloud_dict[cloud[0]]['amount'] = int(cloud[4])\n    roof_dict = {}\n    for roof in roofs_list:\n        roof_dict[roof[0]] = {}\n        roof_dict[roof[0]]['start'] = int(roof[1])\n        roof_dict[roof[0]]['end'] = int(roof[2])\n    # Create the distance array\n    distances = [0]\n    for i in range(1, distance+1):\n        distances.append(i)\n    # Create the probability array\n    probabilities = []\n    for i in range(0, cloud+1):\n        probabilities.append(0)\n    for i in range(1, cloud+1):\n        for j in range(cloud_dict[str(i)]['start'], cloud_dict[str(i)]['end']+1):\n            probabilities[i] += cloud_dict[str(i)]['probability']\n    # Create the rain array\n    rain = []\n    for i in range(0, cloud+1):\n        rain.append(0)\n    for i in range(1, cloud+1):\n        for j in range(cloud_dict[str(i)]['start'], cloud_dict[str(i)]['end']+1):\n            rain[i] += cloud_dict[str(i)]['amount']/cloud_dict[str(i)]['probability']\n    # Create the result variable\n    result = []\n    # Create the walk array\n    walk = []\n    for i in range(0, distance+1):\n        walk.append([])\n        for j in range(0, distance+1):\n            walk[i].append(0)\n    for i in range(1, distance+1):\n        walk[i][i] = 1\n    # Create the probability array\n    probability = []\n    for i in range(0, distance+1):\n        probability.append(0)\n    for i in range(1, distance+1):\n        for j in range(1, distance+1):\n            probability[i] += probabilities[j] * walk[j][i]\n    # Create the rain array\n    rain = []\n    for i in range(0, distance+1):\n        rain.append(0)\n    for i in range(1, distance+1):\n        for j in range(1, distance+1):\n            rain[i] += rain[j] * probability[j]\n    # Create the distance array\n    distances = [0]\n    for i in range(1, distance+1):\n        distances.append(i)\n    # Create the time array\n    time_array = []\n    for i in range(0, time+1):\n        time_array.append(i)\n    # Create the walk array\n    walk = []\n    for i in range(0, distance+1):\n        walk.append([])\n        for j in range(0, distance+1):\n            walk[i].append(0)\n    # Create the roof array\n    roof_dict = {}\n    for roof in roofs_list:\n        roof_dict[roof[0]] = {}\n        roof_dict[roof[0]]['start'] = int(roof[1])\n        roof_dict[roof[0]]['end'] = int(roof[2])\n    # Create the walk array\n    walk = []\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # nums = list(map(int, stdin.split(\" \")))\n    # zip_code = nums[0]\n    # bus_time = nums[1]\n    # cloud_time = nums[2]\n    # roof_seg = nums[3]\n    #\n    # cloud_times = []\n    # for i in range(cloud_time):\n    #     cloud_times.append(list(map(int, stdin.split(\" \"))))\n    #\n    # roof_zip = []\n    # for i in range(roof_seg):\n    #     roof_zip.append(list(map(int, stdin.split(\" \"))))\n    #\n    # # Part 1\n    # time_to_bus = bus_time - stdin[1]\n    # if time_to_bus < 0:\n    #     return \"FAILURE\"\n    #\n    # # Part 2\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n    #\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # get data\n    # s: start\n    # e: end\n    # p: probability\n    # a: amount\n    # zip_code: zip code\n    # n_cloud: number of clouds\n    # n_roof: number of roofs\n    # d: distance to bus stop\n    # t: time to reach the bus stop\n    # c: number of clouds\n    s, e, p, a, zip_code, n_cloud, n_roof, d, t = map(int, stdin.split())\n    clouds = []\n    for i in range(n_cloud):\n        s, e, p, a = map(float, stdin.split()[i * 4:i * 4 + 4])\n        clouds.append([s, e, p, a])\n    # calc p_t\n    p_t = 1 - p\n    # add roof\n    roofs = []\n    for i in range(n_roof):\n        x, y = map(int, stdin.split()[i * 2:i * 2 + 2])\n        roofs.append([x, y])\n    # sort by x\n    roofs = sorted(roofs, key=lambda x: x[0])\n    # for each x, calc p_t * p_x, and add to the answer\n    ans = 0\n    for roof in roofs:\n        p_t_x = 1\n        for cloud in clouds:\n            # start or end before roof\n            if cloud[0] <= roof[0] or cloud[1] >= roof[1]:\n                continue\n            # end after roof\n            if cloud[1] > roof[1]:\n                p_t_x *= 1 - cloud[2]\n                continue\n            # start after roof\n            if cloud[0] > roof[0]:\n                p_t_x *= (1 - cloud[2])\n                continue\n            # start and end on roof\n            if cloud[0] >= roof[0] and cloud[1] <= roof[1]:\n                p_t_x *= (1 - cloud[2])\n                continue\n            # start on roof and end after roof\n            if cloud[0] == roof[0] and cloud[1] > roof[1]:\n                p_t_x *= (1 - cloud[2])\n                continue\n        ans += p_t_x * a\n    ans += p_t * d\n    # print(ans)\n    return format(ans, '.5f')\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for the second part of the challenge\"\"\"\n    # 1. Obtain inputs\n    (d, t, c, r) = [int(x) for x in stdin.split(' ')]\n    assert d in range(1, 1001)\n    assert t in range(d, 10001)\n    assert c in range(0, 1000001)\n    assert r in range(0, d)\n\n    # 2. Process\n    l = list()\n    for _ in range(c):\n        (s, e, p, a) = [int(x) for x in stdin.split(' ')]\n        assert s in range(0, t)\n        assert e in range(s, t + 1)\n        assert p in range(0, 1000)\n        assert a in range(0, 1001)\n        l.append((s, e, p, a))\n\n    # 3. Return result\n    return f'{min(sum(a * (s + 1) for s, _, _, a in l) * t + sum(a * (e + 1) for _, e, _, a in l) * (d - t)):.5f}'\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # input\n    d, t, c, r = [int(i) for i in stdin.split()]\n    clouds = [[int(i) for i in stdin.split()] for j in range(c)]\n    roofs = [[int(i) for i in stdin.split()] for j in range(r)]\n    \n    # build the matrix of probabilities\n    probs = np.zeros([t+1, d+1])\n    for cloud in clouds:\n        s, e, p, a = cloud\n        for i in range(s, e):\n            probs[i, s:e+1] += p\n            probs[i, s:e+1] += a/((e-s+1) * 3600)\n    \n    # find the point at which the rain starts\n    start = np.zeros(t+1)\n    for i in range(t+1):\n        for j in range(d+1):\n            start[i] += probs[i, j]\n        if start[i] >= 1:\n            break\n    \n    # find the point at which the rain stops\n    end = np.zeros(t+1)\n    for i in range(t+1):\n        for j in range(d+1):\n            end[i] += probs[i, j]\n        if end[i] <= 0:\n            break\n    \n    # the amount of rain is the difference between the start and stop values\n    rain = start[:i+1] - end[:i+1]\n    return '{:.5f}'.format(np.min(rain))"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the output of the solution.\n    :param stdin: The standard input as string.\n    :return: The solution's output as string.\n    \"\"\"\n    _, distance, time, clouds, roofs = map(int, stdin.split())\n    seconds = []\n    for start, end, probability, rain in clouds:\n        seconds.append(ProbabilityRain(start, end, probability).rain_amount(rain))\n\n    min_seconds = min(seconds)\n    return min_seconds / (distance / time)\n\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the minimum amount of rain that will occur on your route to the bus stop in time.\n    :param stdin: the input file contents\n    :return: the solution string\n    \"\"\"\n    # Get input\n    d = int(stdin.readline().split(\" \")[0])\n    t = int(stdin.readline().split(\" \")[0])\n    c = int(stdin.readline().split(\" \")[0])\n    r = int(stdin.readline().split(\" \")[0])\n    lines = stdin.readlines()[0:c]\n    lines += stdin.readlines()[c:c+r]\n    \n    # Precompute all relevant information\n    seconds = {}\n    for line in lines:\n        seconds[int(line.split(\" \")[0])] = {\"start\": int(line.split(\" \")[1]), \"end\": int(line.split(\" \")[2]), \"p\": float(line.split(\" \")[3]), \"a\": int(line.split(\" \")[4])}\n    max_a = 0\n    for i in range(0, c+r):\n        if seconds[i][\"a\"] > max_a:\n            max_a = seconds[i][\"a\"]\n    \n    # Solve\n    i = 0\n    min_a = max_a\n    while i < t:\n        if i in seconds:\n            if i + seconds[i][\"start\"] < t:\n                min_a = min(min_a, max_a * (1 - seconds[i][\"start\"]/t + seconds[i][\"p\"]))\n            else:\n                min_a = min(min_a, max_a * (1 - seconds[i][\"p\"]))\n            i += seconds[i][\"start\"]\n        else:\n            i += 1\n    return min_a\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(str(input()))\n    '9.5805'\n    \"\"\"\n    d, t, c, r = [int(i) for i in stdin.split()]\n    clouds = [tuple(map(int, stdin.split())) for _ in range(c)]\n\n    distances = {(cloud[0], cloud[1]) for cloud in clouds}\n    end_times = {cloud[0] for cloud in clouds}\n    rain_probabilities = {cloud[2] for cloud in clouds}\n    rain_sizes = {cloud[3] for cloud in clouds}\n\n    current_time = 0\n\n    while True:\n        lowest_rain_size = min(rain_sizes)\n        lowest_rain_time = min(end_times - current_time, t - current_time)\n        lowest_rain_probability = min(rain_probabilities)\n        lowest_rain_size = min(lowest_rain_size, lowest_rain_probability)\n\n        if lowest_rain_time == 0:\n            break\n\n        for distance, rain_size in rain_sizes.items():\n            if distance[0] <= current_time + lowest_rain_time:\n                rain_sizes[distance] = max(rain_size - lowest_rain_size, 0)\n\n        for rain_size, rain_time in end_times.items():\n            if rain_time <= current_time + lowest_rain_time:\n                end_times.pop(rain_size)\n\n        current_time += lowest_rain_time\n\n    return str(min(t - current_time, c * lowest_rain_size))\n"
    },
    {
        "number": 3034,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # import stdin\n    # _, d, t, c, r = stdin.readline().split()\n    # d = int(d)\n    # t = int(t)\n    # c = int(c)\n    # r = int(r)\n    # s, e, p, a = [], [], [], []\n    # for i in range(c):\n    #     s.append(int(stdin.readline().split()[0]))\n    #     e.append(int(stdin.readline().split()[1]))\n    #     p.append(float(stdin.readline().split()[2]))\n    #     a.append(int(stdin.readline().split()[3]))\n    # x, y = [], []\n    # for i in range(r):\n    #     x.append(int(stdin.readline().split()[0]))\n    #     y.append(int(stdin.readline().split()[1]))\n\n    # def can_jump(d, t, c, r):\n    #     s, e, p, a = [], [], [], []\n    #     for i in range(c):\n    #         s.append(int(stdin.readline().split()[0]))\n    #         e.append(int(stdin.readline().split()[1]))\n    #         p.append(float(stdin.readline().split()[2]))\n    #         a.append(int(stdin.readline().split()[3]))\n    #     x, y = [], []\n    #     for i in range(r):\n    #         x.append(int(stdin.readline().split()[0]))\n    #         y.append(int(stdin.readline().split()[1]))\n    #     return can_jump_helper(d, t, c, r, s, e, p, a, x, y)\n\n    # def can_jump_helper(d, t, c, r, s, e, p, a, x, y):\n    #     m = [0] * (d + 1)\n    #     for i in range(c):\n    #         for j in range(s[i], e[i]):\n    #             m[j] += a[i] * p[i]\n    #     for i in range(r):\n    #         for j in range(x[i], y[i]):\n    #             m[j] += a[c + i] * p[c + i]\n    #     return m\n\n    # def rain(d, t, c, r):\n    #     s, e, p, a = [], [], [], []\n    #     for i in range(c):\n    #         s.append(int(stdin.readline().split()[0]))\n    #         e.append(int(stdin.readline().split()[1]))\n    #         p.append(float(stdin.readline().split()[2]))\n    #         a.append(int(stdin.readline().split()[3]))\n    #     x, y = [], []\n    #     for i in range(r):\n    #         x.append(int(stdin.readline().split()[0]))\n    #         y.append(int(stdin.readline().split()[1]))\n    #     m = can_jump(d, t, c, r)\n    #     ans = []\n    #     for i in range(t):\n    #         ans.append(0)\n    #         for j in range(c):\n    #             ans[i] += m[j] * a[j]\n    #     return ans\n\n    # print(sum(rain(d, t, c, r)))\n\n    # import sys\n    # input = sys.stdin.readline\n\n    # for line in sys.stdin:\n    #     print(line)\n\n    # _, d, t, c, r = input().split()\n    # d = int(d)\n    # t = int(t)\n    # c = int(c)\n    # r = int(r)\n    # s, e, p, a = [], [], [], []\n    # for i in range(c):\n    #     s.append(int(input().split()[0]))\n    #     e.append(int(input().split()[1]))\n    #     p.append(float(input().split()[2]))\n    #     a.append(int(input().split()[3]))\n    # x, y = [], []\n    # for i in range(r):\n    #     x.append(int(input().split()[0]))\n    #     y.append(int(input().split()[1]))\n    # m = can_jump(d"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum amount of blue lemonade that you can get.\n\n    :param stdin: The input string.\n    :return: The maximum amount of blue lemonade that you can get.\n    \"\"\"\n    n = int(stdin)\n    exchange_rate = {}\n    for _ in range(n):\n        offer, wanted, rate = stdin.split()\n        exchange_rate[offer] = float(rate)\n    lemonade = {}\n    while len(lemonade) < n:\n        for child in stdin.split('\\n')[:n - len(lemonade)]:\n            offer, wanted, rate = child.split()\n            if wanted not in lemonade:\n                lemonade[wanted] = min(exchange_rate[offer], rate)\n            else:\n                lemonade[wanted] = min(lemonade[wanted], exchange_rate[offer], rate)\n    return 10 if sum(lemonade.values()) > 10 else sum(lemonade.values())\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    lst = []\n    for i in range(1, N + 1):\n        lst.append(list(map(str, stdin[i].split())))\n    for i in range(N):\n        lst[i][2] = float(lst[i][2])\n    lst = sorted(lst, key=lambda x: x[2], reverse=True)\n    max_exchanged = 0\n    for i in range(len(lst)):\n        current_rate = lst[i][2]\n        for j in range(i, len(lst)):\n            if lst[j][0] == lst[i][1]:\n                lst[i][2] = min(current_rate, lst[j][2])\n        if max_exchanged < lst[i][2] * lst[i][1]:\n            max_exchanged = lst[i][2] * lst[i][1]\n    return str(round(max_exchanged, 6))\nprint(solution(input()))\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return '{:.6f}'.format(solution_f(stdin))\n\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    stdout = \"\"\n    return stdout\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return str(10)\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    lines = stdin.split('\\n')\n    if len(lines)!= N + 1:\n        raise ValueError(\"Incorrect number of lines\")\n    transactions = []\n    for line in lines[1:]:\n        if len(line.split())!= 3:\n            raise ValueError(\"Incorrect line length\")\n        transactions.append(line.split())\n    transactions = list(zip(*transactions))\n    from_, to, rate = transactions\n    from_ = [x.strip() for x in from_]\n    to = [x.strip() for x in to]\n    rate = [float(x.strip()) for x in rate]\n    exchange_rate = dict(zip(to, rate))\n    exchange_rate.update({from_[i]: 1 / rate[i] for i in range(len(from_))})\n    exchange_rate = dict(sorted(exchange_rate.items(), key=lambda item: item[1], reverse=True))\n    blue = 0\n    for to, rate in exchange_rate.items():\n        if to!= 'blue':\n            blue += exchange_rate[to]\n            if blue >= 10:\n                return 10\n    return blue\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum amount of blue lemonade that one can get\"\"\"\n\n    # Este es un ejemplo de lo que deber\u00eda pasar de entrada\n    # blue_pink 1.0\n    # red_pink 1.5\n    # blue_red 1.0\n\n    # lo que deberia pasar de salida\n    # 1.500000000000000\n\n    # cada fila de entrada es una \"linea\"\n    lines = stdin.split('\\n')\n    # print(lines)\n\n    # mi archivo final\n    final_file = {}\n    for line in lines:\n        # los items de cada linea son:\n        # (blue_pink, 1.0)\n        # (red_pink, 1.5)\n        # (blue_red, 1.0)\n        line = line.split()\n        # print(line)\n        # print(line[0], line[1], line[2])\n        # print(line[1].split('_'))\n        if line[1].split('_')[0] == 'blue':\n            key = line[0]\n        else:\n            key = line[1]\n        final_file[key] = int(line[2])\n\n    # print(final_file)\n\n    # diccionario:\n    # key -> (blue, 1.0)\n    # key -> (red, 1.5)\n    # key -> (blue, 1.0)\n\n    # lista de tuplas:\n    # [('blue', 1.0), ('red', 1.5), ('blue', 1.0)]\n\n    # mi diccionario final\n    # final_file = {}\n    # final_file['blue'] = 1.0\n    # final_file['red'] = 1.5\n    # final_file['blue'] = 1.0\n\n    # print(final_file)\n\n    # en cada iteraci\u00f3n de la lista voy a recorrer la lista de tuplas\n    # voy a recorrer cada una de las tuplas\n    # voy a recorrer cada una de las claves\n    # voy a recorrer los valores de cada clave\n\n    # print(final_file)\n\n    # lista de tuplas:\n    # [('blue', 1.0), ('red', 1.5), ('blue', 1.0)]\n    # lista de claves:\n    # ['blue','red', 'blue']\n    # lista de valores:\n    # [1.0, 1.5, 1.0]\n\n    # print(final_file.keys())\n    # print(final_file.values())\n    # print(final_file.items())\n\n    # keys:\n    # ['blue','red', 'blue']\n\n    # values:\n    # [1.0, 1.5, 1.0]\n\n    # items:\n    # dict_items([('blue', 1.0), ('red', 1.5), ('blue', 1.0)])\n\n    # la variable que va guardando el m\u00e1ximo de la variable que se quiere recuperar\n    total = 0\n    # el ciclo for que va a recorrer la lista de tuplas\n    for key, value in final_file.items():\n        # si el valor de la variable que se quiere recuperar es menor a 10\n        if total < 10:\n            # voy a a\u00f1adir la variable que se quiere recuperar\n            total += value\n    # print(total)\n\n    # si el valor total es mayor a 10\n    if total > 10:\n        # la variable que almacena el valor total se queda con 10\n        total = 10\n    # print(total)\n    # regresar el valor total\n    return str(total)\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the maximum amount of blue lemonade that can be obtained.\n    :param stdin: string representing input for the problem.\n    :return:\n    \"\"\"\n    n = int(stdin)\n    cakes = []\n    for _ in range(n):\n        cake = stdin.split('\\n')\n        cakes.append(cake)\n    # print(cakes)\n    blue = 0\n    for cake in cakes:\n        if cake[0] == 'blue':\n            blue += float(cake[2])\n    print(blue)\n    return str(int(blue))\n"
    },
    {
        "number": 3035,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    n = int(stdin)\n    return_str = \"\"\n    diff = 0\n    blue = 0\n    for i in range(n - 1):\n        current = stdin.split(\"\\n\")[i].split(\" \")\n        current_name = current[0]\n        current_price = float(current[1])\n        current_amount = int(current[2])\n        current_money = float(current[3])\n        if current_name == \"blue\":\n            blue += current_amount\n            diff = current_price - current_money\n        else:\n            blue -= current_amount\n            diff = current_money - current_price\n        if diff > 0:\n            if blue < diff:\n                return_str += str(blue)\n                return_str += \".\"\n                return_str += str(diff - blue)[:7]\n                blue = 0\n            else:\n                return_str += str(diff)\n                return_str += \".\"\n                return_str += str(blue)[:7]\n                blue = 0\n        elif diff < 0:\n            return_str += str(blue)\n            return_str += \".\"\n            return_str += str(abs(diff))[:7]\n            blue = 0\n        else:\n            blue += current_amount\n    current = stdin.split(\"\\n\")[n - 1].split(\" \")\n    current_name = current[0]\n    current_price = float(current[1])\n    current_amount = int(current[2])\n    current_money = float(current[3])\n    if current_name == \"blue\":\n        blue += current_amount\n        diff = current_price - current_money\n    else:\n        blue -= current_amount\n        diff = current_money - current_price\n    if diff > 0:\n        if blue < diff:\n            return_str += str(blue)\n            return_str += \".\"\n            return_str += str(diff - blue)[:7]\n            blue = 0\n        else:\n            return_str += str(diff)\n            return_str += \".\"\n            return_str += str(blue)[:7]\n            blue = 0\n    elif diff < 0:\n        return_str += str(blue)\n        return_str += \".\"\n        return_str += str(abs(diff))[:7]\n        blue = 0\n    else:\n        blue += current_amount\n    return return_str\n    pass\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the maximum number of possible dishes that can be served\n    by using only the given ingredients in a way that does not violate\n    any pair of dishes that do not go well together.\n\n    >>> solution(\"6 1 1 1 0\\n2 3 1 5 3 2\\n2 1 2\\n3 3 4 5\\n1 6\")\n    '180'\n    >>> solution(\"3 2 2 1 1\\n2 3 2\\n1 1\\n1 2\\n1 2\\n1 3\")\n    '0'\n    >>> solution(\"3 1 1 1 1\\n5 5 5\\n3 1 2 3\\n3 1 2 3\\n3 1 2 3\")\n    'too many'\n    \"\"\"\n    num_ingredients = int(stdin.split('\\n')[0].split()[0])\n    num_brands = int(stdin.split('\\n')[0].split()[1])\n\n    starter = {}\n    main = {}\n    dessert = {}\n    for i in range(1, num_brands + 1):\n        starter[i] = set()\n        main[i] = set()\n        dessert[i] = set()\n    for i in range(1, num_ingredients + 1):\n        line = stdin.split('\\n')[i]\n        num_ingredients, *ingredients = line.split()\n        for j in ingredients:\n            ingredient = int(j)\n            starter[ingredient].add(i)\n            main[ingredient].add(i)\n            dessert[ingredient].add(i)\n\n    #print(starter, main, dessert)\n\n    # iterate over each combination of starter and main dishes\n    # for each combination, iterate over each dessert dish\n    # if the dessert dish is in any pair of the current combination\n    # then we have too many dishes and can exit early\n    # otherwise, we add the number of combinations for this pair to the result\n    max_dishes = 0\n    for s in range(1, num_brands + 1):\n        for m in range(1, num_brands + 1):\n            for d in range(1, num_brands + 1):\n                for i in range(1, num_ingredients + 1):\n                    for j in range(1, num_ingredients + 1):\n                        if i in starter[s] and j in main[m]:\n                            if j in dessert[d]:\n                                return 'too many'\n                        else:\n                            max_dishes += 1\n    return max_dishes\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\n    pass"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the number of different dinner experiences that Swedish Chef can make, if he has\n    access to only the first 10 ingredients. Otherwise, returns 'too many'.\n    \n    >>> solution('6 1 1 1 0\\n2 3 1 5 3 2\\n2 1 2\\n3 3 4 5\\n1 6\\n1 2\\n2 3')\n    '180'\n    >>> solution('3 1 1 1 1\\n5 5 5\\n3 1 2 3\\n3 1 2 3\\n3 1 2 3\\n2 1\\n')\n    '0'\n    >>> solution('3 1 1 1 1\\n5 5 5\\n3 1 2 3\\n3 1 2 3\\n3 1 2 3\\n2 1\\n1 2\\n2 3')\n    'too many'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # 1. Get the input\n    ingredients_brands = stdin[0].split(\" \")\n    ingredients = ingredients_brands[0].split(\" \")\n    ingredients_brands.pop(0)\n    ingredients.pop(0)\n    ingredients = list(map(int, ingredients))\n    ingredients_brands = list(map(int, ingredients_brands))\n    \n    # 2. Get the count for each pair of dishes\n    pair_counts = {}\n    for pair in stdin[1:]:\n        pair = pair.split(\" \")\n        pair_counts[pair[0]] = 0\n        pair_counts[pair[1]] = 0\n    \n    for pair in stdin[1:]:\n        pair = pair.split(\" \")\n        pair_counts[pair[0]] += 1\n        pair_counts[pair[1]] += 1\n        \n    # 3. Get the count for each pair of dishes that are not compatible\n    not_compatible_counts = {}\n    for pair in stdin[len(stdin) - 1:]:\n        pair = pair.split(\" \")\n        if pair_counts[pair[0]] == 0 or pair_counts[pair[1]] == 0:\n            continue\n        compatible = False\n        for i in range(1, len(pair)):\n            if pair[i] not in ingredients:\n                compatible = True\n        if compatible == False:\n            not_compatible_counts[pair[0]] = 0\n            not_compatible_counts[pair[1]] = 0\n    \n    # 4. Get the count for the final output\n    output = 0\n    \n    # 5. Get the total count\n    for i in range(len(pair_counts)):\n        if pair_counts[str(i + 1)] > 0:\n            output += pair_counts[str(i + 1)] * (pair_counts[str(i + 1)] - 1) // 2\n        if not_compatible_counts[str(i + 1)] > 0:\n            output += not_compatible_counts[str(i + 1)] * (not_compatible_counts[str(i + 1)] - 1) // 2\n        \n    return str(output)"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = [int(x) for x in stdin.split()]\n    b = [int(x) for x in stdin.split()]\n    dishes = []\n    for _ in range(s):\n        dish = [int(x) for x in stdin.split()]\n        dishes.append(dish)\n    for _ in range(m):\n        dish = [int(x) for x in stdin.split()]\n        dishes.append(dish)\n    for _ in range(d):\n        dish = [int(x) for x in stdin.split()]\n        dishes.append(dish)\n    pairs = []\n    for _ in range(n):\n        dish = [int(x) for x in stdin.split()]\n        pairs.append(dish)\n    # print(r, b, s, m, d, n, dishes, pairs)\n    ingredients = set()\n    for x in b:\n        ingredients.add(x)\n    # print(ingredients)\n    def get_ingredients(dish):\n        res = set()\n        for i in dish:\n            res.add(i)\n        return res\n    def get_ingredients_in_multiple_dishes(dishes):\n        res = set()\n        for dish in dishes:\n            for i in dish:\n                res.add(i)\n        return res\n    ingredients_in_multiple_dishes = get_ingredients_in_multiple_dishes(dishes)\n    ingredients_in_multiple_dishes_as_pairs = set()\n    for pair in pairs:\n        for i in pair:\n            ingredients_in_multiple_dishes_as_pairs.add(i)\n    # print(ingredients_in_multiple_dishes_as_pairs)\n    result = 0\n    for ingredients in dishes:\n        # print(ingredients)\n        c = get_ingredients_in_multiple_dishes(ingredients)\n        # print(c)\n        for x in c:\n            if x in ingredients_in_multiple_dishes_as_pairs:\n                result += 1\n                # print(x)\n        # print(\"_________\")\n    if result > 10**18:\n        return \"too many\"\n    return str(result)"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''6 1 1 1 0\n   ... 2 3 1 5 3 2\n   ... 2 1 2\n   ... 3 3 4 5\n   ... 1 6\n   ... ''')\n    '180'\n    >>> solution('''3 2 2 1 1\n   ... 5 5 5\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 2 1\n   ... ''')\n    '22'\n    >>> solution('''3 1 1 1 1\n   ... 5 5 5\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 3 1 2 3\n   ... 2 1\n   ... ''')\n    '0'\n    \"\"\"\n   ..."
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum number of different dinner\n    experiences that can be made from the available ingredients.\n    \"\"\"\n    _, _, _, _, n = stdin.split()\n    n, m, s, d, r = [int(n) for n in n.split()]\n    \n    # The available ingredients\n    all_ingredients = []\n    for _ in range(r):\n        _, l = stdin.split()\n        all_ingredients.append(set([int(n) for n in l.split()]))\n    \n    # The dishes\n    dishes = []\n    for _ in range(s):\n        _, l = stdin.split()\n        l = [int(n) for n in l.split()]\n        dishes.append(set([i for i in l if i in range(1, r+1)]))\n    for _ in range(m):\n        _, l = stdin.split()\n        l = [int(n) for n in l.split()]\n        dishes.append(set([i for i in l if i in range(r+1, r+s+1)]))\n    for _ in range(d):\n        _, l = stdin.split()\n        l = [int(n) for n in l.split()]\n        dishes.append(set([i for i in l if i in range(r+s+1, r+s+m+1)]))\n    \n    # Generate all possible combos of dishes\n    possible_combos = []\n    for d1 in range(s+m+d):\n        for d2 in range(d1+1, s+m+d):\n            possible_combos.append(list(set([d1, d2])))\n    \n    # Iterate over all combos of dishes\n    num_combos = 0\n    for combo in possible_combos:\n        num_combos += 1\n        # Check that the combos of dishes do not go well with each other\n        if len(set(combo).intersection(set(combo[::-1]))) == 0:\n            # Check that each dish in the combo has all ingredients\n            for dish in combo:\n                all_ingredients_in_dish = True\n                for ingredient in dishes[dish-1]:\n                    if ingredient not in all_ingredients:\n                        all_ingredients_in_dish = False\n                        break\n                if not all_ingredients_in_dish:\n                    break\n            else:\n                # If all dishes have all ingredients, then we have a possible solution\n                num_combos += 1\n    \n    return str(num_combos) if num_combos <= 1e18 else 'too many'\n"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1:\n    # return str(solve(stdin))\n\n    # Solution 2:\n    # return str(solve(stdin))\n\n    # Solution 3:\n    # return str(solve(stdin))\n\n    # Solution 4:\n    return str(solve(stdin))\n\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    h, w, n = map(int, stdin.split())\n    path = list(stdin.split())[1:]\n    board = [['.' for _ in range(w)] for _ in range(h)]\n    x, y = 0, 0\n    for i in range(h):\n        for j in range(w):\n            if i == 0 and j == 0:\n                board[i][j] = '#'\n            else:\n                board[i][j] = '.'\n    for direction, distance in path:\n        if direction == 'up':\n            for j in range(y, y + distance):\n                if j >= h:\n                    break\n                board[j][x] = '#'\n            y += distance\n        elif direction == 'down':\n            for j in range(y - distance, y):\n                if j < 0:\n                    break\n                board[j][x] = '#'\n            y -= distance\n        elif direction == 'left':\n            for i in range(x, x - distance, -1):\n                if i < 0:\n                    break\n                board[y][i] = '#'\n            x -= distance\n        else:\n            for i in range(x + distance, x, -1):\n                if i >= w:\n                    break\n                board[y][i] = '#'\n            x += distance\n    \n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '.':\n                return '-1 -1'\n    return str(min(y, h - 1)) +'' + str(min(x, w - 1))\n    \n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This solution reads in an m x n board and a list of movement commands\n    (which are in the form of [up,down,left,right,up,down,left,right,up,down]\n    and returns the minimum and maximum time (inclusive) that the turtle can\n    reach the end of the board. \"\"\"\n    # store the initial values\n    m, n, _ = map(int, stdin.split())\n    board = [list(stdin.split()[x:x+n]) for x in range(0, m*n, n)]\n    # start in bottom left\n    curr = (0, 0)\n    # set the initial values\n    min_ = 0\n    max_ = 0\n    # loop through all the commands\n    for command in stdin.split()[n*m:]:\n        # split the command into the direction and distance\n        dir_, dist = command.split()\n        # get the new position\n        new = curr\n        if dir_ == 'up':\n            new = (curr[0], curr[1] - int(dist))\n        elif dir_ == 'down':\n            new = (curr[0], curr[1] + int(dist))\n        elif dir_ == 'left':\n            new = (curr[0] - int(dist), curr[1])\n        elif dir_ == 'right':\n            new = (curr[0] + int(dist), curr[1])\n        # check if we're on the edge\n        if new[0] < 0 or new[1] < 0 or new[0] >= m or new[1] >= n:\n            return '-1 -1'\n        # check if the next position is occupied\n        if board[new[0]][new[1]] == '#':\n            return '-1 -1'\n        # update the current position\n        curr = new\n        # update the max_ if necessary\n        if curr[0] + curr[1] > max_:\n            max_ = curr[0] + curr[1]\n        # update the min_ if necessary\n        if curr[0] + curr[1] < min_:\n            min_ = curr[0] + curr[1]\n    return str(min_) +'' + str(max_)\n\n\"\"\"\nSample Input:\n6 8 5\n........\n...#....\n########\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Finds the time when the marker can be off the board.\n    '''\n    return str(max(0, *(\n        min(\n            (\n                (i, j)\n                for i, j in zip(\n                    range(1, len(stdin)),\n                    ((j + n if i % 2 == 0 else j - n) % height)\n                )\n            ),\n            default=float('inf')\n        )\n        [0][1]\n        for n in range(1, width + 1)\n    )))\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    A = [['.'] * w for _ in range(h)]\n    \n    for i in range(n):\n        row, col, d, l = map(str, stdin.split())\n        row = int(row)\n        col = int(col)\n        if d == 'up':\n            for _ in range(col, col + l):\n                A[row - 1][_] = '#'\n        elif d == 'down':\n            for _ in range(col, col + l):\n                A[row + 1][_] = '#'\n        elif d == 'right':\n            for _ in range(row, row + l):\n                A[_][col + 1] = '#'\n        elif d == 'left':\n            for _ in range(row, row + l):\n                A[_][col - 1] = '#'\n                \n    def check(A):\n        for i in range(h):\n            for j in range(w):\n                if A[i][j] == '.':\n                    return False\n        return True\n        \n    if check(A):\n        return '0 0'\n    \n    min_l = 0\n    max_l = 0\n    for i in range(h):\n        for j in range(w):\n            if A[i][j] == '#':\n                max_l += 1\n            elif A[i][j] == '.':\n                min_l += 1\n    \n    for i in range(h):\n        for j in range(w):\n            if A[i][j] == '#':\n                max_l -= 1\n            elif A[i][j] == '.':\n                min_l -= 1\n                \n    if min_l > 0:\n        return '-1 -1'\n    else:\n        return str(max_l) +'' + str(min_l)\n        \n        \ndef"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    nums = stdin.split()\n    h, w, n = int(nums[0]), int(nums[1]), int(nums[2])\n\n    board = [['' for _ in range(w)] for _ in range(h)]\n    for i in range(n):\n        board[-int(nums[3 + i][0])][int(nums[3 + i][1])] = '#'\n\n    # \uac00\ub85c\n    for i in range(w):\n        if board[0][i] == '#':\n            for j in range(h):\n                if board[j][i] == '#':\n                    for k in range(j, 0, -1):\n                        board[k][i] = board[k - 1][i]\n                    board[0][i] = '.'\n\n    # \uc138\ub85c\n    for i in range(h):\n        if board[i][0] == '#':\n            for j in range(w):\n                if board[i][j] == '#':\n                    for k in range(j, 0, -1):\n                        board[i][k] = board[i][k - 1]\n                    board[i][0] = '.'\n\n    # \ub300\uac01\uc120\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '#' and board[i - 1][j] == '#':\n                for k in range(i - 1, 0, -1):\n                    board[k][j] = board[k - 1][j]\n                board[0][j] = '.'\n\n            if board[i][j] == '#' and board[i][j - 1] == '#':\n                for k in range(j - 1, 0, -1):\n                    board[i][k] = board[i][k - 1]\n                board[i][0] = '.'\n\n    # \uc544\ub798\ub85c\n    for i in range(h):\n        if board[i][0] == '#':\n            for j in range(w):\n                if board[i][j] == '#':\n                    for k in range(i, 0, -1):\n                        board[k][j] = board[k - 1][j]\n                    board[i][0] = '.'\n\n    # \uc624\ub978\ucabd\uc73c\ub85c\n    for i in range(w):\n        if board[0][i] == '#':\n            for j in range(h):\n                if board[j][i] == '#':\n                    for k in range(j, 0, -1):\n                        board[k][i] = board[k - 1][i]\n                    board[0][i] = '.'\n\n    # \uc67c\ucabd\uc73c\ub85c\n    for i in range(h):\n        if board[i][-1] == '#':\n            for j in range(w):\n                if board[i][j] == '#':\n                    for k in range(j, 0, -1):\n                        board[i][k] = board[i][k - 1]\n                    board[i][-1] = '.'\n\n    # \uc704\ub85c\n    for i in range(h):\n        if board[0][i] == '#':\n            for j in range(w):\n                if board[i][j] == '#':\n                    for k in range(i, 0, -1):\n                        board[k][j] = board[k - 1][j]\n                    board[0][i] = '.'\n\n    # \ub300\uac01\uc120\uc73c\ub85c\n    for i in range(h):\n        for j in range(w):\n            if board[i][j] == '#' and board[i - 1][j] == '#':\n                for k in range(i - 1, 0, -1):\n                    board[k][j] = board[k - 1][j]\n                board[0][j] = '.'\n\n            if board[i][j] == '#' and board[i][j - 1] == '#':\n                for k in range(j - 1, 0, -1):\n                    board[i][k] = board[i][k - 1]\n                board[0][j] = '.'\n\n    # \uc544\ub798\ub85c\n    for i in range(h):\n        if board[i][0] == '#':\n            for j in range(w):\n                if board[i][j] == '#':\n                    for k in range(i, 0, -1):\n                        board[k][j] = board[k - 1][j]\n                    board[i][0] = '.'\n\n    # \uc624\ub978\ucabd\uc73c\ub85c\n    for i in range(w):\n        if board[0][i] == '#':\n            for j in range(h):\n                if board[j][i] == '#':"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return min and max time that can be dry.\"\"\"\n    # your code here\n    return '', ''\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ..."
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3037,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the earliest and latest times that the marker can dries out, or -1 -1 if it can't.\"\"\"\n    board = Board(stdin)\n    return board.solve()\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Task to solve:\n    # Find the smallest number of boxes which can be bought in the order of those companies\n    # You can buy the boxes in any order, so you can change the order until you get a solution\n\n    # Input:\n    # n - number of boxes to buy\n    # k - number of companies\n    # l_i - number of types of boxes from the i-th company\n\n    # Output:\n    # A string \"Impossible\" if the boxes cannot be bought in the order of companies, or the smallest number of boxes, otherwise.\n\n    # Example:\n    # Input:\n    # n = 3\n    # k = 2\n    # l_0 = 2\n    # l_1 = 3\n    # l_2 = 4\n    # Output:\n    # 'Impossible'\n    # Explanation:\n    # There is no company which produces boxes of sizes 2, 3 and 4.\n    # You can only buy the boxes of size 3 or 4, and you cannot buy boxes of sizes 2 and 4 together.\n\n    # Get inputs\n    n = int(stdin.readline())\n    k = int(stdin.readline())\n    l = []\n    for i in range(k):\n        l.append(list(map(int, stdin.readline().split())))\n    # l[i][0] - l_i - number of boxes of l_i types\n    # l[i][1] - l_i - minimal number of boxes\n\n    # Build list with l_i types\n    l_i = []\n    for i in range(k):\n        l_i.append(l[i][0])\n    # Sort l_i\n    l_i.sort()\n    # Build list with l_i - l_i[i]\n    l_diff = []\n    for i in range(len(l_i) - 1):\n        l_diff.append(l_i[i + 1] - l_i[i])\n    # Find smallest l_i - l_i[i]\n    min_l_diff = l_diff[0]\n    for i in range(1, len(l_diff)):\n        if l_diff[i] < min_l_diff:\n            min_l_diff = l_diff[i]\n    # Find minimum number of boxes to buy\n    min_boxes = l_i[0]\n    for i in range(len(l_i)):\n        if l_i[i] + min_l_diff >= n:\n            min_boxes = n\n            break\n        elif l_i[i] + min_l_diff < n:\n            min_boxes = l_i[i] + min_l_diff\n    # Return result\n    if min_boxes == l_i[0]:\n        return \"Impossible\"\n    return str(min_boxes)\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # input_str = input()\n    # input_str = input_str.splitlines()\n\n    # required_bolts = int(input_str[0])\n\n    # num_companies = int(input_str[1])\n\n    # company_sizes = [[int(x) for x in input_str[i].split()] for i in range(2, 2 + num_companies)]\n\n    # for i in range(num_companies):\n    #     company_sizes[i].append(sum(company_sizes[i]))\n\n    # print(company_sizes)\n\n    # company_sizes = sorted(company_sizes, key=lambda x: x[-1])\n\n    # print(company_sizes)\n\n    # idx = 0\n    # for i in range(num_companies):\n    #     if company_sizes[idx][0] < required_bolts:\n    #         required_bolts -= company_sizes[idx][0]\n    #         idx += 1\n    #     else:\n    #         break\n\n    # # print(idx)\n\n    # # print(company_sizes[idx - 1][1])\n\n    # if required_bolts > company_sizes[idx - 1][1]:\n    #     return \"impossible\"\n\n    # if idx == 0:\n    #     return str(company_sizes[idx][0])\n\n    # else:\n    #     return str(company_sizes[idx - 1][1])\n\n    # return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    b = int(stdin.split('\\n')[0])\n    n = int(stdin.split('\\n')[1])\n    w = [int(x) for x in stdin.split('\\n')[2:2+n]]\n    c = int(stdin.split('\\n')[2+n])\n    p = [int(x) for x in stdin.split('\\n')[2+n+1:2+n+c+1]]\n    \n    min_w = min(w)\n    s = 0\n    for i in range(n):\n        s += w[i]\n        if s >= b:\n            return str(max(0, min_w*(s-b)))\n    return 'impossible'\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n = int(stdin)\n    b = 0\n    k = 0\n    companies = []\n    pack_sizes = []\n    for line in stdin.split(\"\\n\"):\n        if k == 0:\n            b = int(line)\n            k += 1\n        else:\n            companies.append([int(i) for i in line.split()])\n    for i in range(k):\n        pack_sizes.append(companies[i][1:])\n    res = 0\n    curr_pack = []\n    for i in range(b):\n        curr_pack.append(1)\n    curr_pack = sorted(curr_pack)\n    for i in range(k):\n        curr_pack = sorted(curr_pack)\n        for j in range(curr_pack[-1]):\n            for m in range(companies[i][0]):\n                if j + pack_sizes[i][m] <= b:\n                    curr_pack.append(j + pack_sizes[i][m])\n        curr_pack = sorted(curr_pack)\n        res = curr_pack[-1]\n        if res == b:\n            break\n    if res == 0:\n        return \"impossible\"\n    return res"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Day 1: The Tyranny of the Rocket Equation\n\n    The Elves quickly load you into a spacecraft and prepare to launch.\n\n    At the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper. They haven't determined the amount of fuel required yet.\n\n    Fuel required to launch a given module is based on its mass. Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.\n\n    For example:\n\n    For a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.\n    For a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.\n    For a mass of 1969, the fuel required is 654.\n    For a mass of 100756, the fuel required is 33583.\n\n    The Fuel Counter-Upper needs to know the total fuel requirement. To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.\n\n    What is the sum of the fuel requirements for all of the modules on your spacecraft?\n    \"\"\"\n    module_masses = list(map(int, stdin.split()))\n    print(module_masses)\n    return str(sum(int(mass / 3) - 2 for mass in module_masses))\n\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimal amount of a package that contains at least B bolts.\"\"\"\n    B, k = [int(s) for s in stdin.strip().split(\"\\n\")]\n    for _ in range(k):\n        nums = [int(s) for s in stdin.strip().split(\"\\n\")[1:]]\n        print(min([sum(nums[:i + 1]) for i in range(len(nums)) if sum(nums[:i + 1]) >= B]))\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b: int = int(stdin.readline())\n    k: int = int(stdin.readline())\n    d: list = []\n    for _ in range(k):\n        l: int = int(stdin.readline())\n        n: list = []\n        for _ in range(l):\n            n.append(int(stdin.readline()))\n        d.append(n)\n    min_total = 10 ** 3\n    for l in d:\n        total = 0\n        for n in l:\n            total += n\n        if total > min_total:\n            continue\n        if total + 1 < min_total:\n            min_total = total + 1\n    if min_total > b:\n        print(\"impossible\")\n    else:\n        print(min_total)\n        "
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return smallest size of package which contains at least B bolts.\"\"\"\n    # Your code here\n    # TODO\n    #\n    #\n    #\n    return str(int(stdin))\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of packs that should be purchased to\n    contain a number of required bolts of a given size.\n\n    Args:\n        stdin: input on stdin\n\n    Returns:\n        str: output to stdout\n    \"\"\"\n    required_bolts = int(stdin)\n    num_companies = int(stdin)\n    bolts_per_company = []\n    for _ in range(num_companies):\n        bolts_per_company.append(list(map(int, stdin.split())))\n    sorted_companies = sorted(bolts_per_company, key=lambda x: x[0])\n    total_bolts = 0\n    for company in sorted_companies:\n        num_of_bolts = company[1]\n        if total_bolts < required_bolts:\n            total_bolts += num_of_bolts\n        else:\n            break\n    if total_bolts >= required_bolts:\n        return str(total_bolts)\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3038,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Solution 1:\n    # B, k = list(map(int, stdin.splitlines()))\n    # A = [list(map(int, stdin.splitlines()[i].split())) for i in range(k)]\n    # min_diff = 10 ** 3\n    # for i in range(1 << k):\n    #     total = 0\n    #     for j in range(k):\n    #         if i & (1 << j):\n    #             total += A[j][0] * A[j][1]\n    #             total += A[j][1] * A[j][2]\n    #     if total >= B:\n    #         diff = abs(total - B)\n    #         if diff < min_diff:\n    #             min_diff = diff\n    # if min_diff < 10 ** 3:\n    #     return str(min_diff)\n    # return \"impossible\"\n\n    # Solution 2:\n    B, k = list(map(int, stdin.splitlines()))\n    A = [[int(a) for a in stdin.splitlines()[i].split()] for i in range(k)]\n    A.sort(key=lambda x: x[0])\n    # print(A)\n    package_sizes = {0: B}\n    for i in range(k):\n        min_package_size = 10 ** 3\n        for package_size, num_of_packages in package_sizes.items():\n            if num_of_packages >= A[i][1]:\n                if num_of_packages - A[i][1] + A[i][0] < min_package_size:\n                    min_package_size = num_of_packages - A[i][1] + A[i][0]\n                package_sizes[num_of_packages - A[i][1] + A[i][0]] = min_package_size\n    if min_package_size < 10 ** 3:\n        return str(min_package_size)\n    return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return 'cannot fold' if '#.' in stdin or '##.' in stdin else 'can fold'\n\n\ndef"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'can fold' or 'cannot fold' depending on whether the given arrangement of unit squares can be folded into a cube.\n\n    >>> solution(\"......\\n\"\n   ...         \"......\\n\"\n   ...         \"######\\n\"\n   ...         \"......\\n\"\n   ...         \"......\\n\"\n   ...         \"......\")\n    'cannot fold'\n    >>> solution(\"......\\n\"\n   ...         \"......\\n\"\n   ...         \"######\\n\"\n   ...         \"..##..\\n\"\n   ...         \"..##..\\n\"\n   ...         \"......\")\n    'can fold'\n    >>> solution(\"......\\n\"\n   ...         \"......\\n\"\n   ...         \"######\\n\"\n   ...         \"#....#\\n\"\n   ...         \"#....#\\n\"\n   ...         \"......\")\n    'cannot fold'\n    \"\"\"\n    squares = stdin.splitlines()\n    squares = [set(square) for square in squares]\n\n    corners = [square for square in squares if len(square) == 1]\n    for i in range(len(squares)):\n        if len(squares[i])!= 1:\n            break\n    else:\n        return 'can fold'\n    if i == 0:\n        return 'cannot fold'\n    left = squares[:i]\n    right = squares[i + 1:]\n    left_cross = set.union(*left)\n    right_cross = set.union(*right)\n    cross = left_cross & right_cross\n    if len(cross)!= 1 or cross!= set('#'):\n        return 'cannot fold'\n    middle = squares[i]\n    middle_cross = set.union(*middle)\n    middle_corners = [square for square in middle if len(square) == 1]\n    if len(middle_corners)!= 2:\n        return 'cannot fold'\n\n    return 'can fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    initial_arrangement = stdin.split('\\n')\n    squares = [list(line) for line in initial_arrangement]\n    squares_set = set()\n    for line in squares:\n        for char in line:\n            if char == \"#\":\n                squares_set.add(char)\n    if len(squares_set)!= 6:\n        return \"cannot fold\"\n    squares_dict = {}\n    for square in squares_set:\n        squares_dict[square] = 0\n    for line in squares:\n        for i in range(len(line)):\n            if line[i] == \"#\":\n                squares_dict[line[i]] += 1\n                if squares_dict[line[i]] == 3:\n                    return \"can fold\"\n    return \"cannot fold\"\n    \"\"\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.split('\\n'):\n        if '#' not in line:\n            return 'can fold'\n    return 'cannot fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n  return \"can fold\" if len([el for el in stdin.split('\\n') if el.count('#') == 6]) > 0 else \"cannot fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    ans = 'can fold' if '#' * 6 in stdin or '##' in stdin else 'cannot fold'\n    return ans"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    squares = stdin.split('\\n')\n    squares = {(x, y) for y, row in enumerate(squares) for x, square in enumerate(row) if square == '#'}\n    if len(squares)!= 6:\n        return 'cannot fold'\n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n    stack = {(x, y, 0, 0, 'x') for x, y in squares}\n    while stack:\n        x, y, d1, d2, seen = stack.pop()\n        if (x, y) in squares and (d1, d2) in directions:\n            return 'cannot fold'\n        if d1 == d2 == 0 and (x, y) not in squares:\n            return 'can fold'\n        for dir in directions:\n            dx, dy = dir\n            if dx == dy == 0:\n                continue\n            next_x = x + dx\n            next_y = y + dy\n            if (next_x, next_y) in squares and (next_x, next_y, d1 + dx, d2 + dy) not in stack:\n                stack.add((next_x, next_y, d1 + dx, d2 + dy, seen))\n    return 'cannot fold'\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin)!= 6:\n        return \"cannot fold\"\n    for i in range(6):\n        if len(stdin[i])!= 6:\n            return \"cannot fold\"\n    for i in range(6):\n        if stdin[i].count(\"#\")!= 6:\n            return \"cannot fold\"\n    for i in range(6):\n        for j in range(6):\n            if stdin[i][j] == \"#\":\n                if stdin[i + 1][j] == \".\" or stdin[i - 1][j] == \".\" or stdin[i][j + 1] == \".\" or stdin[i][j - 1] == \".\":\n                    return \"cannot fold\"\n    return \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return 'can fold' if stdin.count('#') == (sum(stdin.count('.'), 0) + sum(stdin.count('#'), 0)) else 'cannot fold'\n\nprint(solution('......'))\n"
    },
    {
        "number": 3039,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('.##.\\n#..#\\n##.#')\n    'cannot fold'\n    >>> solution('##.\\n#..\\n##.')\n    'can fold'\n    >>> solution('..##\\n#..#\\n##.#')\n    'cannot fold'\n    \"\"\"\n    squares = {(x, y) for y, line in enumerate(stdin.splitlines()) for x, char in enumerate(line) if char == \"#\"}\n    if len(squares)!= 6:\n        return \"cannot fold\"\n\n    for square in squares:\n        if len(get_adjacent(squares, square)) not in (4, 6):\n            return \"cannot fold\"\n\n    return \"can fold\"\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution:\n        Approach 1: using list comprehension and find all the occurences of string then find the longest repeated substrings\n        Approach 2: using a hashmap and loop through the string and find the longest repeated substring\n    \"\"\"\n    # Approach 1: using list comprehension and find all the occurences of string then find the longest repeated substrings\n    return max(sorted(list(set(stdin))), key=len)\n    # Approach 2: using a hashmap and loop through the string and find the longest repeated substring\n    # hash_map = {}\n    # max_len = 0\n    # for index in range(len(stdin)):\n    #     substring = stdin[index]\n    #     if hash_map.get(substring) is not None:\n    #         hash_map[substring] += 1\n    #     else:\n    #         hash_map[substring] = 1\n    #     max_len = max(max_len, hash_map[substring])\n    # return max(filter(lambda x: hash_map[x] > 1, hash_map), key=len)\n\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return longest_repeating_substring(stdin)\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin\n    output = ''\n    for i in range(len(string)):\n        current = string[i]\n        #print(current)\n        for j in range(i+1, len(string)):\n            if string[j] == current:\n                string = string[i+1:j] + string[j+1:]\n                #print(string)\n                break\n            else:\n                continue\n        else:\n            continue\n        if len(string) > len(output):\n            output = string\n    return output\n\n\n\n\n\ndef"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # write your code here\n    # write your code here\n    # write your code here\n    # write your code here\n    # write your code here\n    return \"\""
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the longest substring that occurs more than once in a string.\n\n    >>> solution('abcefgabc')\n    'abc'\n    >>> solution('abcbabcba')\n    'abcba'\n    >>> solution('aaaa')\n    'aaa'\n    \"\"\"\n    s = ''\n    longest = ''\n    for char in stdin:\n        s = char + s\n        if s.count(char) > 1:\n            if len(char) > len(longest):\n                longest = char\n    print(longest)\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"abcefgabc\")\n    'abc'\n    >>> solution(\"abcbabcba\")\n    'abcba'\n    >>> solution(\"aaaa\")\n    'aaa'\n    \"\"\"\n    # Initialize dp with the first character, dp[0] is set to it\n    dp = [stdin[0]]\n    # Loop over each character in the string\n    for i in range(1, len(stdin)):\n        # If the character is different than the last character\n        if stdin[i]!= stdin[i - 1]:\n            # Add the current character to the dp\n            dp.append(stdin[i])\n        # If the character is the same as the last character\n        else:\n            # Update the last character to be the current character\n            dp[len(dp) - 1] = stdin[i]\n    # Initialize the longest_substring to be empty string\n    longest_substring = \"\"\n    # Loop over dp\n    for sub_string in dp:\n        # If the current substring is empty\n        if len(sub_string) == 0:\n            continue\n        # If the current substring is greater than the longest substring\n        if len(sub_string) > len(longest_substring):\n            # Set the longest substring equal to the current substring\n            longest_substring = sub_string\n    # Print the longest substring\n    return longest_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Time: O(n) where n is the number of characters in the input string\n    # Space: O(1)\n    # Input: A single line of lowercase letters.\n    # Output: The longest substring that occurs more than once in the input string.\n    # Complexity: O(n)\n    \n    # Get the max length of the longest substring that occurs more than once\n    # in the string\n    max_length = 0\n    string = stdin\n    n = len(string)\n    while n > max_length:\n        max_length = n\n        # Iterate over the substring to get the longest substring\n        for i in range(n):\n            for j in range(i+1, n+1):\n                sub_string = string[i:j]\n                if sub_string in string[j:]:\n                    n = len(sub_string)\n                    break\n    return sub_string\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the longest substring that occurs more than once in the input string.\n    \"\"\"\n    # Check for empty string\n    if stdin == '':\n        return None\n\n    # Check for single character\n    if len(stdin) == 1:\n        return stdin\n\n    # Initialise answer string\n    answer = ''\n\n    # Initialise the answer and current string to compare to\n    string = ''\n    compare_string = ''\n\n    # Start comparison loop\n    for i in range(len(stdin)):\n        # If the current character is not in the current string\n        if stdin[i] not in string:\n            # Add the current character to the current string\n            string += stdin[i]\n\n            # Check if the current string is already in the answer\n            if string not in compare_string:\n                # Append the current string to the answer if it is not already in it\n                compare_string += string\n                # Check if the current string is longer than the answer\n                if len(compare_string) > len(answer):\n                    # Update the answer with the current string\n                    answer = compare_string\n            # Otherwise the current string is already in the answer\n            else:\n                # Remove the last instance of the current string from the answer\n                compare_string = compare_string[:compare_string.rfind(string)]\n                # Update the answer with the new length of the answer\n                answer = answer[:len(answer)-len(compare_string)]\n\n        # If the current character is in the current string\n        else:\n            # Add the current character to the current string\n            string += stdin[i]\n            # Update the compare string\n            compare_string = compare_string[compare_string.rfind(string)+1:]\n\n    # If the current answer string is longer than the longest answer string\n    if len(answer) > len(stdin):\n        # Return the shortest answer string\n        return stdin[:len(stdin)-len(answer)]\n\n    # Otherwise return the longest answer string\n    return answer\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # implement your solution here\n    #\n    #\n    return stdin\n"
    },
    {
        "number": 3040,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n  pass\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return shortest path.\"\"\"\n    # This solution works with the assumption that\n    # all trips take less than one second, and\n    # all trips take less than one minute.\n    # In this case, we can work backwards to\n    # find the shortest path to the beginning\n    # of the interval.\n    n = int(stdin.readline())\n    time = []\n    cost = []\n    for _ in range(n):\n        (a, b) = list(map(int, stdin.readline().split()))\n        time.append((a, b))\n        cost.append(b - a + 2)\n    path = [0]\n    costs = 0\n    for (t, c) in sorted(zip(time, cost)):\n        path.append(c + min(path[-1], 0))\n        costs += t[1] - t[0] + 1\n    return min(path[1:]) + costs\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return 'foo'"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''0\n   ... 4\n   ... 2 10\n   ... 0 15\n   ... 0\n   ... 0''')\n    '4'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    dic = dict()\n    for i in range(N):\n        a, b = map(int, stdin.readline().split())\n        if a not in dic:\n            dic[a] = []\n        dic[a].append(b)\n        if b not in dic:\n            dic[b] = []\n        dic[b].append(a)\n    queue = deque([0])\n    visited = set()\n    visited.add(0)\n    answer = 0\n    while queue:\n        start = queue.popleft()\n        for zone in dic[start]:\n            if zone not in visited:\n                visited.add(zone)\n                queue.append(zone)\n                answer += 1\n    return str(answer)\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    # a_b = abs(a - b)\n    # a = a % 10\n    # b = b % 10\n    # b = max(a, b)\n    # b = min(a, b)\n    # print(a_b)\n    '''\n    num = int(stdin)\n    res = 0\n    for i in range(num):\n        a, b = map(int, input().split())\n        res += min(a, b) + abs(a - b)\n    return res\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum number of coupons to purchase\"\"\"\n    n = int(stdin.readline())\n    coupons = [None] * n\n    for i in range(n):\n        coupons[i] = int(stdin.readline())\n    n = int(stdin.readline())\n    m = [None] * n\n    for i in range(n):\n        m[i] = tuple(map(int, stdin.readline().split(' ')))\n    coupons = sorted(coupons, reverse=True)\n    m = sorted(m, reverse=True)\n    valid = [True] * n\n    for i in range(n):\n        for j in range(n):\n            if (m[i][0] >= m[j][1]) and (m[i][1] >= m[j][0]):\n                valid[j] = False\n    coupons = [x for x in coupons if valid[coupons.index(x)]]\n    cost = 0\n    for i in range(n):\n        if m[i][0] > cost:\n            cost = m[i][0]\n        if m[i][1] < cost:\n            break\n    return cost"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3041,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    tickets = []\n    for i in range(N):\n        tickets.append(stdin.readline().strip().split())\n    tickets = list(sorted(tickets, key = lambda x: int(x[1])))\n    current_ticket = 0\n    current_time = 0\n    coupons = 0\n    for i in range(N):\n        if int(tickets[i][0]) < current_time:\n            coupons += int(tickets[i][2])\n        elif int(tickets[i][0]) == current_time:\n            current_ticket = tickets[i][1]\n        else:\n            coupons += (int(current_ticket) - int(tickets[i][0])) * 2\n        current_time = int(tickets[i][1])\n    return coupons"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of different ways to arrange a set of nodes into an LCM tree.\"\"\"\n    # Get number of nodes\n    n = int(stdin.split()[0])\n\n    # Get list of node values\n    values = [int(x) for x in stdin.split()[1:]]\n\n    # Get set of possible root values\n    roots = set(values)\n    roots.discard(0)\n    roots.discard(1)\n\n    # Build tree\n    tree = [[] for _ in range(n)]\n    for i in range(n):\n        tree[i] = (values[i], [])\n        if i > 0:\n            tree[i][1].append(i - 1)\n            tree[i - 1][1].append(i)\n\n    # Get number of different ways to arrange the nodes into an LCM tree\n    ways = 1\n    for r in roots:\n        if len(tree[r - 1][1]) > 1:\n            # Swap leaves r and r - 1, accounting for multiple permutations\n            ways *= (len(tree[r - 1][1]) - 1)\n            ways %= 10 ** 9 + 7\n\n    return ways\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lst = list(map(int, stdin.split(' ')))\n    l = len(lst)\n    dp = [0] * (l + 1)\n    dp[0] = 1\n    for i in range(1, l + 1):\n        if i == 1:\n            dp[i] = 1\n        else:\n            for j in range(i):\n                if lst[j] == i:\n                    dp[i] += dp[j]\n    return dp[l]\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    def calculate(A, B):\n        A.sort()\n        B.sort()\n        i, j = 0, 0\n        while i < len(A) and j < len(B):\n            if A[i] == B[j]:\n                i += 1\n                j += 1\n            elif A[i] < B[j]:\n                i += 1\n            else:\n                j += 1\n        return len(A) + len(B) - 2 * i\n    \n    n = int(stdin.readline())\n    nodes = list(map(int, stdin.readline().split()))\n    nodes.sort()\n    answer = 0\n    for i in range(len(nodes)):\n        answer += calculate(nodes[:i], nodes[i+1:])\n        answer %= 10**9 + 7\n    return str(answer)\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return ''"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    n = int(stdin)\n    values = [int(x) for x in stdin.split()]\n    lst = [int(x) for x in range(1, n + 1)]\n    lcm = math.lcm(*lst)\n    count = 0\n    for i in range(0, n + 1, 2):\n        for j in range(i + 2, n + 1, 2):\n            if values[i] * values[j] % lcm == 0:\n                count += 1\n    print(count % (10 ** 9 + 7))\n    return ''\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = [int(x) for x in stdin.readline().split(' ')]\n    mod = 1000000007\n    counts = [0 for i in range(n+1)]\n    counts[0] = 1\n    for num in nums:\n        for j in range(1, num+1):\n            counts[j] += counts[j-1]\n    # print(counts)\n    ans = 0\n    for i in range(2, n+1):\n        ans += (counts[i]*counts[n-i])\n        ans %= mod\n    return str(ans)\n    pass\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total_nodes = int(stdin.readline())\n    values = list(map(int, stdin.readline().split()))\n    values.sort()\n    \n    count_solutions = [0] * (values[-1] + 1)\n    count_solutions[0] = 1\n    for value in values:\n        for i in range(value, len(count_solutions)):\n            count_solutions[i] += count_solutions[i-value]\n            \n    return count_solutions[-1]\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split('\\n')\n    n = int(line[0])\n    nums = list(map(int, line[1].split()))\n\n    nums.sort()\n    path = []\n    count = 0\n    for num in nums:\n        path.append(num)\n        if len(path) == n:\n            count += nums.count(num)\n\n    return str(count % (10 ** 9 + 7))\n\n\ndef"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.split('\\n')\n    n = int(line[0])\n    numbers = list(map(int, line[1].split()))\n    numbers.sort()\n    res = 0\n    \n    def lcm(a, b):\n        # print(a, b, a*b, a//b, a%b)\n        return a*b//math.gcd(a, b)\n    \n    def count(n):\n        global res\n        if n <= 1:\n            return\n        \n        res += n\n        for i in range(2, n):\n            if numbers[i] % numbers[i-1] == 0:\n                count(i)\n                \n    count(n)\n    \n    return str(res%1000000007)\n"
    },
    {
        "number": 3042,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # parse input\n    n = int(stdin.strip())\n    a = [int(x) for x in stdin.strip().split()]\n    # for i in range(n):\n    #     a[i] = int(stdin.strip().split()[i])\n\n    # build a graph\n    G = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] % a[j] == 0:\n                G[i].append(j)\n                G[j].append(i)\n\n    # dfs\n    def dfs(node):\n        if len(G[node]) == 0:\n            return 1\n        return sum([dfs(x) for x in G[node]]) % (10 ** 9 + 7)\n\n    return dfs(0)\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = [int(i) for i in stdin.split(' ')]\n    grid = []\n    for _ in range(N):\n        grid.append(stdin.split('\\n')[0].split(' '))\n    queue = []\n    day = 0\n    visited = []\n    for r in range(N):\n        for c in range(M):\n            if grid[r][c] == 'S':\n                queue.append((r, c, 0,'s'))\n                visited.append((r, c))\n            if grid[r][c] == 'G':\n                queue.append((r, c, 0, 'g'))\n                visited.append((r, c))\n    while queue:\n        r, c, day, state = queue.pop(0)\n        if state =='s':\n            if r - 1 >= 0 and grid[r - 1][c]!= '#':\n                if (r - 1, c) not in visited:\n                    queue.append((r - 1, c, day + 1,'s'))\n                    visited.append((r - 1, c))\n            if r + 1 < N and grid[r + 1][c]!= '#':\n                if (r + 1, c) not in visited:\n                    queue.append((r + 1, c, day + 1,'s'))\n                    visited.append((r + 1, c))\n            if c - 1 >= 0 and grid[r][c - 1]!= '#':\n                if (r, c - 1) not in visited:\n                    queue.append((r, c - 1, day + 1,'s'))\n                    visited.append((r, c - 1))\n            if c + 1 < M and grid[r][c + 1]!= '#':\n                if (r, c + 1) not in visited:\n                    queue.append((r, c + 1, day + 1,'s'))\n                    visited.append((r, c + 1))\n        elif state == 'g':\n            return day\n    return -1\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K, s = [int(x) for x in stdin.split()]\n    # dimensions of grid\n    # print(R,C,K,s)\n    # [grid[][] for x in range(R)]\n    grid = [list(stdin[i:i + C]) for i in range(0, len(stdin), C)]\n    # print(grid)\n    # path[node] = (cost, previous node)\n    path = {(0, 0): (0, None)}\n    # print(path)\n    cost, prev = dijkstra(grid, R, C, s, path, K)\n    if cost == float(\"inf\"):\n        print(-1)\n    else:\n        print(cost)\n\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split('\\n')[0].split())\n    grid = []\n    for line in stdin.split('\\n')[1:]:\n        grid.append(line)\n\n    for x in range(n):\n        for y in range(m):\n            if grid[x][y] == 'S':\n                start = (x, y)\n            elif grid[x][y] == 'G':\n                end = (x, y)\n\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    def get_neighbours(cur_x, cur_y):\n        for x, y in moves:\n            new_x = cur_x + x\n            new_y = cur_y + y\n            if 0 <= new_x < n and 0 <= new_y < m:\n                yield new_x, new_y\n\n    def is_valid(cur_x, cur_y):\n        return 0 <= cur_x < n and 0 <= cur_y < m\n\n    def is_valid_move(x, y, moves):\n        for x_, y_ in moves:\n            new_x = x + x_\n            new_y = y + y_\n            if not is_valid(new_x, new_y):\n                return False\n        return True\n\n    def bfs(start, end):\n        queue = deque([start])\n        visited = {start}\n        steps = 0\n        while queue:\n            steps += 1\n            size = len(queue)\n            for _ in range(size):\n                cur_x, cur_y = queue.popleft()\n                if cur_x == end[0] and cur_y == end[1]:\n                    return steps\n                for neighbour_x, neighbour_y in get_neighbours(cur_x, cur_y):\n                    if grid[neighbour_x][neighbour_y] == '.' \\\n                            and not (neighbour_x, neighbour_y) in visited:\n                        queue.append((neighbour_x, neighbour_y))\n                        visited.add((neighbour_x, neighbour_y))\n        return None\n\n    return bfs(start, end)\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = stdin.split()\n    n, m, k = int(n), int(m), int(k)\n\n    matrix = [list(map(str, stdin.split())) for _ in range(n)]\n\n    dp = [[-1] * m for _ in range(n)]\n    dp[0][0] = 0\n\n    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n    def bfs(i, j, dp, matrix, k):\n        # If out of stamina, stop\n        if k == 0:\n            return float('inf')\n        # If out of map, stop\n        if i < 0 or i >= n or j < 0 or j >= m:\n            return float('inf')\n        # If already visited, stop\n        if dp[i][j]!= -1:\n            return dp[i][j]\n        # If current state is not a treasure, continue\n        if matrix[i][j]!= 'G':\n            return bfs(i + directions[0][0], j + directions[0][1], dp, matrix, k - 1)\n        # If current state is a treasure, update dp matrix\n        if dp[i][j] == -1 or dp[i][j] > k:\n            dp[i][j] = k\n            return k\n        # If current state is a treasure, update dp matrix\n        else:\n            return dp[i][j]\n\n    return str(bfs(0, 0, dp, matrix, k))\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, moves, stamina = stdin.split(\"\\n\")\n    rows = int(rows)\n    cols = int(cols)\n    moves = int(moves)\n    stamina = int(stamina)\n    field = stdin.split(\"\\n\")\n\n    def get_valid_neighbors(current_row, current_col):\n        valid_neighbors = []\n        if current_row!= 0:\n            valid_neighbors.append((current_row - 1, current_col))\n        if current_row!= rows - 1:\n            valid_neighbors.append((current_row + 1, current_col))\n        if current_col!= 0:\n            valid_neighbors.append((current_row, current_col - 1))\n        if current_col!= cols - 1:\n            valid_neighbors.append((current_row, current_col + 1))\n        return valid_neighbors\n\n    def get_neighbors(current_row, current_col):\n        return [x for x in get_valid_neighbors(current_row, current_col) if x in field_dic.keys()]\n\n    def get_paths_in_direction(current_row, current_col, direction, moves, stamina_left, field_dic):\n        valid_neighbor = False\n        paths = 0\n        for row, col in get_valid_neighbors(current_row, current_col):\n            if (row, col) in field_dic.keys():\n                valid_neighbor = True\n                break\n        if not valid_neighbor:\n            return 0\n        if direction == \"u\" and row == 0:\n            return moves\n        elif direction == \"d\" and row == rows - 1:\n            return moves\n        elif direction == \"l\" and col == 0:\n            return moves\n        elif direction == \"r\" and col == cols - 1:\n            return moves\n        elif field[row][col] == \"F\":\n            return get_paths_in_direction(row, col, direction, moves, stamina_left - 1, field_dic)\n        elif field[row][col] == \"M\":\n            return get_paths_in_direction(row, col, direction, moves, stamina_left - 2, field_dic)\n        elif field[row][col] == \"S\":\n            if stamina_left <= 0:\n                return get_paths_in_direction(row, col, direction, moves, stamina_left, field_dic)\n            else:\n                return moves\n        elif field[row][col] == \"G\":\n            return moves\n        else:\n            return get_paths_in_direction(row, col, direction, moves, stamina_left, field_dic)\n\n    field_dic = {}\n    for row in range(0, rows):\n        for col in range(0, cols):\n            if field[row][col] == \"S\":\n                current_row = row\n                current_col = col\n            elif field[row][col] == \"G\":\n                field_dic[(row, col)] = \"G\"\n            else:\n                field_dic[(row, col)] = get_neighbors(row, col)\n\n    # print(field_dic)\n    for row in range(0, rows):\n        for col in range(0, cols):\n            if field[row][col] == \"S\":\n                current_row = row\n                current_col = col\n            elif field[row][col] == \"G\":\n                field_dic[(row, col)] = \"G\"\n            else:\n                field_dic[(row, col)] = get_neighbors(row, col)\n    # print(field_dic)\n\n    total_moves = []\n    for direction in [\"u\", \"d\", \"l\", \"r\"]:\n        moves_left = moves\n        while moves_left > 0:\n            paths = get_paths_in_direction(current_row, current_col, direction, moves_left, stamina, field_dic)\n            if paths == 0:\n                break\n            moves_left -= paths\n            total_moves.append(moves_left)\n            current_row, current_col = get_valid_neighbors(current_row, current_col)[0]\n            stamina = moves_left\n    if moves_left > 0:\n        return -1\n    else:\n        return min(total_moves)\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Calculates the minimum number of days needed to reach the treasure.\n    '''\n    # Get the grid and the starting point\n    grid, s = stdin.split('\\n\\n')\n    # Check if the starting point is on a flat terrain\n    if s[0] == '.' or s[0] == 'S':\n        # If the starting point is on a flat terrain, we move to the next day\n        s = '1'\n    # Get the number of rows and columns\n    n, m = [int(i) for i in grid.split('\\n')[0].split(' ')]\n    # Get the number of moves\n    k = int(grid.split('\\n')[1])\n    # Get the number of unique characters\n    chars = set(grid.split('\\n')[2])\n    # Create the path dictionary\n    path = {\n        '.': 1,\n        'M': 2,\n        'F': 3,\n        'S': 4,\n        'G': 5,\n    }\n    # Create the cost dictionary\n    cost = {\n        '.': 1,\n        'M': 3,\n        'F': 5,\n        'S': 7,\n        'G': 9,\n    }\n    # Initialize the queue\n    q = [s]\n    # Initialize the visited dictionary\n    visited = {s: {'count': 1, 'days': 0}}\n    # Initialize the min_cost dictionary\n    min_cost = {s: k}\n    # Initialize the min_path dictionary\n    min_path = {s: [s]}\n    # Initialize the previous and next dictionary\n    pre = {s: None}\n    next = {}\n    # Initialize the cost_sum dictionary\n    cost_sum = {}\n    # Initialize the total_cost dictionary\n    total_cost = {s: k}\n    # Initialize the minimum cost\n    min_cost_sum = k\n    # Initialize the minimum cost path\n    min_cost_path = []\n    # Initialize the minimum cost path\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 0\n    # Initialize the minimum cost days\n    min_cost_path_days = 0\n    # Initialize the current_cost dictionary\n    current_cost = {}\n    # Initialize the current cost\n    current_cost_sum = 0\n    # Initialize the minimum cost days\n    min_cost_days = 0\n    # Initialize the minimum cost path\n    min_cost_path = []\n    # Initialize the minimum cost path\n    min_cost_total = 0\n    # Initialize the minimum cost days\n    min_cost_path_days = 0\n    # Initialize the current cost days\n    current_cost_days = 0\n    # Initialize the previous and next dictionary\n    pre = {}\n    next = {}\n    # Initialize the days\n    days = 1\n    # Initialize the current days\n    current_days = 1\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path = [s]\n    # Initialize the minimum cost total\n    min_cost_total = k\n    # Initialize the minimum cost days\n    min_cost_days = 1\n    # Initialize the minimum cost path days\n    min_cost_path_days = 1\n    # Initialize the minimum cost path\n    min_cost_path"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    n, m, k = map(int, rows[0].split(\" \"))\n    map_ = stdin.split(\"\\n\")\n    dp = [[False] * m for _ in range(n)]\n    dp[0][0] = True\n    stack = [(0, 0)]\n    days = 0\n    while stack:\n        x, y = stack.pop()\n        days = dp[x][y] + 1\n        for nx, ny in [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]:\n            if 0 <= nx < n and 0 <= ny < m and not dp[nx][ny]:\n                if map_[nx][ny] == \"M\":\n                    continue\n                elif map_[nx][ny] == \"S\":\n                    stack.append((nx, ny))\n                    dp[nx][ny] = True\n                elif map_[nx][ny] == \".\":\n                    stack.append((nx, ny))\n                    dp[nx][ny] = days\n                    days += 1\n                elif map_[nx][ny] == \"F\":\n                    stack.append((nx, ny))\n                    dp[nx][ny] = days\n                    days += 1\n                elif map_[nx][ny] == \"G\":\n                    return str(days)\n    return \"impossible\"\n"
    },
    {
        "number": 3043,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'hello'\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Let H be the height and W be the width of the grid, so we know that there is\n    only one 'S' and one 'G' in the grid.\n    '''\n    H, W = [int(n) for n in stdin.split()]\n\n    # The grid is described by H lines, each with a width of W characters.\n    grid = [list(stdin[i : i + W]) for i in range(H)]\n    # This way we only have to deal with one 'S' and one 'G'\n    S = [r.index('S') for r in grid]\n    G = [r.index('G') for r in grid]\n\n    # Number of rows containing an obstacle\n    O = sum(1 for r in grid if any('#' in c for c in r))\n\n    # Number of moves needed to move from S to G\n    D = max(G) - min(S) + 1 - O\n\n    # If D == 0, then we are done, if not we have to make changes\n    # First we will try to make a single move\n    # Then we will try to make a single change\n    # As we go through each of these options we will count the changes\n    # We will stop when D == 0\n    # We will keep the lowest number of changes we have done\n\n    # In the worst case we have D moves, 1 change per move, so we have D + 1 options\n    # In each case we have a D moves option and an O+D moves option (with D changes)\n    # So in total there are 2*D + O + 1 options\n    min_changes = D + O + 1\n\n    # Iterate over all D moves\n    for d in range(D + 1):\n        # Make d moves\n        grid_copy = [r.copy() for r in grid]\n        for _ in range(d):\n            # Go from S to G\n            for r in range(H):\n                for c in range(W):\n                    if grid_copy[r][c] == 'S':\n                        grid_copy[r][c] = '.'\n                        S[r] += 1\n                    elif grid_copy[r][c] == 'G':\n                        grid_copy[r][c] = '.'\n                        G[r] += 1\n                    elif grid_copy[r][c] == '#':\n                        continue\n\n        # Iterate over all O+D moves\n        for o in range(O + d + 1):\n            # Make O+D moves\n            for r in range(O + d, H):\n                for c in range(W):\n                    if grid_copy[r][c] == 'S':\n                        grid_copy[r][c] = '.'\n                        S[r] += 1\n                    elif grid_copy[r][c] == 'G':\n                        grid_copy[r][c] = '.'\n                        G[r] += 1\n                    elif grid_copy[r][c] == '#':\n                        continue\n\n            # Calculate the number of changes we have done so far\n            changes = 0\n            # If the path is clear from both S and G\n            if all(S[r] == G[r] for r in range(H)):\n                # No change needed\n                changes += 0\n            # If the path is clear from only S\n            elif all(S[r] == G[r] - 1 for r in range(H)):\n                # We have to add 1 to all G\n                changes += 1\n                # And there is one more obstacle than there is now\n                changes += O\n            # If the path is clear from only G\n            elif all(S[r] == G[r] + 1 for r in range(H)):\n                # We have to subtract 1 from all S\n                changes += 1\n                # And there is one more obstacle than there is now\n                changes += O\n            # Else there is an obstacle from either S or G\n            else:\n                changes += 1\n                changes += O\n            # If the number of changes is lower than the smallest number of changes,\n            # then we update the minimum number of changes\n            if changes < min_changes:\n                min_changes = changes\n\n    # We return the minimum number of changes\n    return min_changes"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split(' '))\n    grid = []\n    for _ in range(H):\n        grid.append(list(stdin.split('\\n')[0]))\n\n    direction = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    count = 0\n    visit = [[False for _ in range(W)] for _ in range(H)]\n    stack = [[0, 0]]\n    visit[0][0] = True\n    while stack:\n        h, w = stack.pop()\n        if grid[h][w] == 'G':\n            return count\n        for dh, dw in direction:\n            nh, nw = h+dh, w+dw\n            if 0 <= nh < H and 0 <= nw < W and not visit[nh][nw] and grid[nh][nw]!= '#':\n                stack.append([nh, nw])\n                visit[nh][nw] = True\n        count += 1\n\nprint(solution(stdin.strip()))\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    world = [list(stdin[i]) for i in range(a)]\n    world[0][0] = \"G\"\n    stack = [(0, 0)]\n    l = len(stdin)\n    while stack:\n        x, y = stack.pop()\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < a and 0 <= ny < b and world[nx][ny]!= \"#\":\n                if world[nx][ny] == \"S\":\n                    print(l - len(stdin))\n                    return\n                world[nx][ny] = \"#\"\n                stack.append((nx, ny))\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split(' '))\n    assert h >= 1 and w >= 1, 'Invalid input'\n    assert h <= 50 and w <= 50, 'Invalid input'\n    assert stdin.count('S') == 1, 'Invalid input'\n    assert stdin.count('G') == 1, 'Invalid input'\n    assert stdin.count('.') == stdin.count('#') + stdin.count('G'), 'Invalid input'\n\n    m = [[1 if stdin[r][c] == '#' else 0 for c in range(w)] for r in range(h)]\n    print(m)\n    m[0][0] = -1\n    stack = [(0, 0, 0)]\n    i = 0\n    while i < len(stack):\n        x, y, level = stack[i]\n        i += 1\n        if x == y == h - 1:\n            return level\n        m[x][y] = -1\n        for x2, y2 in [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]:\n            if 0 <= x2 < h and 0 <= y2 < w and m[x2][y2] == 0:\n                m[x2][y2] = level + 1\n                stack.append((x2, y2, level + 1))\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    h, w = map(int, stdin.split(' '))\n    grid = [list(stdin[x:x+w]) for x in range(0, len(stdin), w)]\n    start_y, start_x = len(grid), len(grid[0])\n    goal_y, goal_x = start_y - 1, start_x - 1\n    queue = [((start_y, start_x), 0)]\n    visited = set()\n    while len(queue) > 0:\n        cur_y, cur_x, dist = queue.pop(0)\n        if grid[cur_y][cur_x] == 'G':\n            return dist\n        elif (cur_y, cur_x) in visited:\n            continue\n        visited.add((cur_y, cur_x))\n        if cur_y > 0 and grid[cur_y-1][cur_x]!= '#' and (cur_y-1, cur_x) not in visited:\n            queue.append(((cur_y-1, cur_x), dist+1))\n        if cur_y < start_y - 1 and grid[cur_y+1][cur_x]!= '#' and (cur_y+1, cur_x) not in visited:\n            queue.append(((cur_y+1, cur_x), dist+1))\n        if cur_x > 0 and grid[cur_y][cur_x-1]!= '#' and (cur_y, cur_x-1) not in visited:\n            queue.append(((cur_y, cur_x-1), dist+1))\n        if cur_x < start_x - 1 and grid[cur_y][cur_x+1]!= '#' and (cur_y, cur_x+1) not in visited:\n            queue.append(((cur_y, cur_x+1), dist+1))\n    return -1\n\n\nprint(solution('3 3\\nS.G\\n..#\\n...\\n...'))\nprint(solution('3 7\\n.#.....\\n.G.##S.\\n.......\\nLDLDLLDR'))\nprint(solution('3 7\\n.#.....\\n.G.##S.\\n.......\\nLDLDLLDR'))\n"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w = [int(x) for x in stdin.split(\"\\n\")[0].split()]\n    map = stdin.split(\"\\n\")[1:]\n    s_row, s_col = None, None\n    g_row, g_col = None, None\n    for r, row in enumerate(map):\n        for c, char in enumerate(row):\n            if char == \"S\":\n                s_row, s_col = r, c\n            if char == \"G\":\n                g_row, g_col = r, c\n            if char in \"S#\":\n                map[r] = row.replace(char, \".\")\n    min_c = -1\n    for i in range(1 << ((h + w) - 1)):\n        c = 0\n        for r in range(h):\n            for c in range(w):\n                if (i >> r) & 1 and (i >> (r + c)) & 1:\n                    if map[r][c] == \"#\":\n                        c += 1\n                    elif map[r][c] == \"G\":\n                        c += 1\n                        break\n                elif (i >> r) & 1 and not (i >> (r + c)) & 1:\n                    if map[r][c] == \"#\":\n                        c += 1\n                    elif map[r][c] == \"S\":\n                        c += 1\n                        break\n        if c < min_c or min_c == -1:\n            min_c = c\n    return str(min_c)\n\n\nassert solution(\"3 3\\nS..\\n.#.\\n..G\\nDRRDD\") == \"1\"\nassert solution(\"3 7\\n.......\\n.G.##S.\\n.......\\nLDLDLLDR\") == \"2\""
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    grid = [stdin[2 * i: 2 * i + 2] for i in range(int(stdin[:2]))]\n    start = start_pos(grid)\n    goal = goal_pos(grid)\n    # BFS\n    queue = deque([(start, 0)])\n    seen = {start}\n    while queue:\n        pos, dist = queue.popleft()\n        if dist >= 10:\n            continue\n        for new_pos in neighbors(grid, pos):\n            if new_pos in seen:\n                continue\n            if new_pos == goal:\n                return str(dist + 1)\n            queue.append((new_pos, dist + 1))\n            seen.add(new_pos)\n\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimal number of changes necessary to fix the program\"\"\"\n    matrix = stdin.split('\\n')\n    h, w = map(int, matrix[0].split(' '))\n    starting_location = None\n    goal_location = None\n    for i, row in enumerate(matrix[1:-1]):\n        for j, el in enumerate(row):\n            if el == 'S':\n                starting_location = (i, j)\n            elif el == 'G':\n                goal_location = (i, j)\n    string = matrix[-1]\n    changes = 0\n    for i in range(len(string)):\n        if string[i] == 'D':\n            if not is_adjacent_to_goal(starting_location, goal_location):\n                changes += 1\n                string = string[:i] + 'U' + string[i + 1:]\n        elif string[i] == 'R':\n            if not is_adjacent_to_goal(goal_location, starting_location):\n                changes += 1\n                string = string[:i] + 'L' + string[i + 1:]\n    return changes\n\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    grid_height, grid_width = map(int, stdin.split(' '))\n    grid = stdin.split('\\n')[:grid_height]\n    for row in grid:\n        for column in row:\n            if column == '#':\n                break\n        else:\n            continue\n        break\n    else:\n        raise Exception('Grid must have a start and end location')\n    for row in grid[grid_height:]:\n        for column in row:\n            if column == 'S':\n                start = (grid_height, grid.index(row))\n            if column == 'G':\n                goal = (grid_height, grid.index(row))\n    for row in grid:\n        for column in row:\n            if column == 'D':\n                d = (grid.index(row), row.index('D'))\n    for row in grid[grid_height:]:\n        for column in row[:grid_width]:\n            if column == 'R':\n                r = (grid.index(row), row.index('R'))\n            if column == 'L':\n                l = (grid.index(row), row.index('L'))\n    string = list(stdin.split('\\n')[-1])\n    result = abs(start[0] - goal[0]) + abs(start[1] - goal[1])\n    if string[0] == 'S':\n        del string[0]\n        if (start[0] + 1, start[1]) == goal:\n            string.insert(0, 'R')\n            for i in range(len(string)):\n                if string[i] == 'R' and r[0] > 0:\n                    if r[0] - 1 == start[0]:\n                        string.insert(i, 'D')\n                        break\n                    else:\n                        r = (r[0] - 1, r[1])\n            result += 1\n        if (start[0] - 1, start[1]) == goal:\n            string.insert(0, 'L')\n            for i in range(len(string)):\n                if string[i] == 'L' and l[0] < grid_height - 1:\n                    if l[0] + 1 == start[0]:\n                        string.insert(i, 'D')\n                        break\n                    else:\n                        l = (l[0] + 1, l[1])\n            result += 1\n        if (start[1] + 1, start[0]) == goal:\n            string.insert(0, 'D')\n            for i in range(len(string)):\n                if string[i] == 'D' and d[1] < grid_width - 1:\n                    if d[1] + 1 == start[1]:\n                        string.insert(i, 'D')\n                        break\n                    else:\n                        d = (d[0], d[1] + 1)\n            result += 1\n        if (start[1] - 1, start[0]) == goal:\n            string.insert(0, 'U')\n            for i in range(len(string)):\n                if string[i] == 'U' and d[1] > 0:\n                    if d[1] - 1 == start[1]:\n                        string.insert(i, 'D')\n                        break\n                    else:\n                        d = (d[0], d[1] - 1)\n            result += 1\n    if string[0] == 'G':\n        del string[0]\n        if (goal[0] + 1, goal[1]) == start:\n            string.insert(0, 'L')\n            for i in range(len(string)):\n                if string[i] == 'L' and l[0] < grid_height - 1:\n                    if l[0] + 1 == goal[0]:\n                        string.insert(i, 'U')\n                        break\n                    else:\n                        l = (l[0] + 1, l[1])\n            result += 1\n        if (goal[0] - 1, goal[1]) == start:\n            string.insert(0, 'R')\n            for i in range(len(string)):\n                if string[i] == 'R' and r[0] > 0:\n                    if r[0] - 1 == goal[0]:\n                        string.insert(i, 'U')\n                        break\n                    else:\n                        r = (r[0] - 1, r[1])\n            result += 1\n        if (goal[1] + 1, goal[0]) == start:\n            string.insert(0, 'U')\n            for i in range(len(string)):\n                if string[i] == 'U' and d[1] < grid_width - 1:\n                    if d[1] + 1 == goal[1]:\n                        string.insert(i, 'U')\n                        break\n                    else:\n                        d = (d[0], d[1] + 1)\n            result += 1\n        if (goal[1] - 1, goal[0]) == start:\n            string.insert(0, 'D')\n            for i in range(len(string)"
    },
    {
        "number": 3044,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 7\\n.#.....\\n.G.##S.\\n.......\\nLDLDLLDR\")\n    2\n    >>> solution(\"3 5\\n#...#\\n.#.#.\\n..G.\\nDRRDD\")\n    1\n    >>> solution(\"2 2\\n.S\\n.#\")\n    0\n    >>> solution(\"2 2\\nS\\n.#\")\n    0\n    \"\"\"\n    height, width = map(int, stdin.split())\n    grid = [stdin.split()[1:] for _ in range(height)]\n    changed = 0\n\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] == \"S\":\n                start = (i, j)\n            elif grid[i][j] == \"G\":\n                goal = (i, j)\n            elif grid[i][j] == \".\":\n                changed += 1\n    queue = [start]\n    visited = set()\n    visited.add(start)\n    while queue:\n        cx, cy = queue.pop(0)\n        if cx == goal[0] and cy == goal[1]:\n            return changed\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if not (0 <= nx < height and 0 <= ny < width):\n                continue\n            if (nx, ny) in visited:\n                continue\n            if grid[nx][ny] == \"#\":\n                continue\n            visited.add((nx, ny))\n            queue.append((nx, ny))\n\n    return -1\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str, the receiver's position.\"\"\"\n    beacons = stdin.strip().split('\\n')\n\n    # Calculate the Manhattan distance between each beacon and the receiver.\n    distances = []\n    for beacon in beacons:\n        _, pos_x, pos_y, _ = beacon.split(' ')\n        distances.append(abs(int(pos_x)) + abs(int(pos_y)))\n\n    # Determine the receiver's position.\n    if len(distances) == 1:\n        # The receiver is at the beacon.\n        return str(int(pos_x)) +'' + str(int(pos_y))\n\n    # The receiver is not at the beacon.\n    # Assume that the receiver is at the grid point closest to the beacon.\n    # If the receiver is not at the grid point closest to the beacon, there is no\n    # ambiguity.\n    index_min = distances.index(min(distances))\n    if index_min == 0:\n        # The receiver is closest to the first beacon.\n        pos_x = str(abs(int(beacons[0].split(' ')[1])))\n        pos_y = str(abs(int(beacons[0].split(' ')[2])))\n    else:\n        # The receiver is closest to the second beacon.\n        pos_x = str(abs(int(beacons[1].split(' ')[1])))\n        pos_y = str(abs(int(beacons[1].split(' ')[2])))\n\n    # The receiver is not at the grid point closest to any beacon.\n    return 'impossible' if distances[0] < distances[1] else pos_x +'' + pos_y\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"3\n   ... 99999 0 1000\n   ... 99999 0 1000\n   ... 99999 0 1000\n   ... \"\"\")\n    '1000200 799'\n    >>> solution(\"\"\"2\n   ... 100 0 101\n   ... 0 200 199\n   ... \"\"\")\n    'uncertain'\n    >>> solution(\"\"\"2\n   ... 100 0 100\n   ... 0 200 199\n   ... \"\"\")\n    'impossible'\n    \"\"\"\n    x_0, y_0 = map(int, stdin.splitlines()[0].split())\n    dists = [\n        (int(x.split()[0]), int(x.split()[1]), int(x.split()[2]))\n        for x in stdin.splitlines()[1:]\n    ]\n    dists.sort()\n    dists.sort(key=lambda x: x[2])\n\n    for dist in dists:\n        x, y = dist[0], dist[1]\n        if (x - x_0) ** 2 + (y - y_0) ** 2 < dist[2] ** 2:\n            return f'{x} {y}'\n    return 'impossible'\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string representing the position of the receiver.\n    If there is a unique position for the receiver, return\n    the pair (x, y), otherwise return 'uncertain'.\"\"\"\n    \n    # Store the number of beacons and the distances\n    num_beacons = int(stdin.splitlines()[0])\n    distances = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Validate that there are the correct number of beacons\n    if len(distances)!= num_beacons:\n        raise ValueError('Incorrect number of distances:', len(distances))\n\n    # Sort the distances to find the possible positions for the receiver\n    distances.sort()\n    if distances[0][0] > 0 or distances[0][1] > 0:\n        raise ValueError('A distance cannot be negative.')\n\n    # Check if the receiver is at the origin\n    x, y = 0, 0\n    for d in distances:\n        if d[0]!= x or d[1]!= y:\n            break\n        x += 1\n        y += 1\n    else:\n        return '{} {}'.format(0, 0)\n\n    # If the receiver is not at the origin, return 'uncertain'\n    return 'uncertain'\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n\"\"\"\n\nimport sys\n\nn = int(sys.stdin.readline().strip())\n\nbeacons = []\nfor _ in range(n):\n    x, y, d = list(map(int, sys.stdin.readline().strip().split()))\n    beacons.append((x, y, d))"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n999999 0 1000\\n999900 950 451\\n987654 123 13222\")\n    '1000200 799'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Solution\n    # For each beacon, we have a tuple (x, y, d) where x and y are the coordinates of the beacon and d is the distance to the beacon\n    beacons = []\n    for line in stdin.splitlines():\n        x, y, d = map(int, line.split())\n        beacons.append((x, y, d))\n    print(beacons)\n    # we have to check if there is only one possible solution\n    # for each beacon, we can check if any other beacon has the same x or y coordinate\n    # so, if we have a beacon at x=100, we can check if there is another beacon with y=100\n    # or another beacon with y=200, it is also possible\n    # but we also have to check that the distance from the beacon to the receiver is equal to its own distance\n    # we can do this by sorting the beacons by x and y\n    # if the distance from the receiver to the beacon is equal to its own distance, then we have a solution\n    # otherwise, we have no solution\n    beacons.sort(key=lambda beacon: (beacon[0], beacon[1]))\n    print(beacons)\n    prev_x, prev_y = beacons[0][0], beacons[0][1]\n    dist_to_prev_x, dist_to_prev_y = beacons[0][2], beacons[0][2]\n    solution_x, solution_y = 0, 0\n    for x, y, d in beacons:\n        # if any other beacon has the same x coordinate, then there is no solution\n        if prev_x == x:\n            solution_x = \"impossible\"\n            break\n        # if any other beacon has the same y coordinate, then there is no solution\n        if prev_y == y:\n            solution_y = \"impossible\"\n            break\n        # if the distance from the receiver to the beacon is equal to its own distance, then we have a solution\n        if dist_to_prev_x == d or dist_to_prev_y == d:\n            solution_x, solution_y = prev_x, prev_y\n            break\n        # otherwise, we just update the previous coordinates and distances\n        prev_x, prev_y = x, y\n        dist_to_prev_x, dist_to_prev_y = d, d\n    if solution_x == 0 and solution_y == 0:\n        solution_x, solution_y = \"uncertain\", \"uncertain\"\n    return f\"{solution_x} {solution_y}\"\n\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Enter your code here and remove the pass statement below\n    \n    pass\n"
    },
    {
        "number": 3045,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3\\n999999 0 1000\\n999900 950 451\\n987654 123 13222')\n    '1000200 799'\n    \"\"\"\n    \n    N = int(stdin.split('\\n')[0])\n    beacons = [[int(x) for x in stdin.split('\\n')[i].split()] for i in range(1, N + 1)]\n    beacons_set = set()\n    for x, y, d in beacons:\n        beacons_set.add((x, y))\n    if len(beacons_set)!= N:\n        return 'impossible'\n    \n    receiver_set = set()\n    for x, y, d in beacons:\n        if (d == 0 and (x, y) in receiver_set):\n            return 'impossible'\n        receiver_set.add((x, y))\n    \n    for x, y, d in beacons:\n        receiver_set.add((x + d, y))\n        receiver_set.add((x, y + d))\n    \n    for x, y in receiver_set:\n        if not (0 <= x <= 10 ** 6 and 0 <= y <= 10 ** 6):\n            return 'impossible'\n    \n    if len(receiver_set)!= 2:\n        return 'uncertain'\n    \n    x1, y1 = next(iter(receiver_set))\n    x2, y2 = next(iter(receiver_set))\n    return f'{x2} {y2}'\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    data = []\n    for line in lines[1:]:\n        data.append([int(i) for i in line.split()])\n    \n    def find_neighbors(row, col):\n        neighbors = []\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0:\n                    continue\n                neighbors.append((row + dr, col + dc))\n        return neighbors\n    \n    def dfs(row, col, data, visited):\n        visited.add((row, col))\n        for neighbor in find_neighbors(row, col):\n            if neighbor not in visited:\n                if data[neighbor[0]][neighbor[1]] == 0:\n                    return False\n                elif data[neighbor[0]][neighbor[1]] == 1:\n                    if not dfs(neighbor[0], neighbor[1], data, visited):\n                        return False\n        return True\n    \n    def dfs_2(row, col, data):\n        stack = [(row, col)]\n        while stack:\n            row, col = stack.pop()\n            for neighbor in find_neighbors(row, col):\n                if data[neighbor[0]][neighbor[1]] == 1:\n                    stack.append(neighbor)\n                    data[neighbor[0]][neighbor[1]] = 0\n    \n    def find_match():\n        for i in range(len(data)):\n            for j in range(len(data[0])):\n                if (i, j) not in visited:\n                    if data[i][j] == 1:\n                        if not dfs(i, j, data, visited):\n                            return False\n        return True\n    \n    while True:\n        visited = set()\n        if find_match():\n            return len(visited)\n        else:\n            dfs_2(0, 0, data)\n        \n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n    pass\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time complexity: O(n)\n    Space complexity: O(n)\n    \"\"\"\n    # Input\n    n = int(stdin.readline())\n    corner_pair = []\n    for _ in range(n):\n        row, col = [int(c) for c in stdin.readline().split()]\n        corner_pair.append((row, col))\n\n    # Solve\n    # corner_pair is a list of tuples (row, col)\n    # corner_pair is sorted by row, col\n    sorted_corner_pair = sorted(corner_pair, key=lambda tup: tup[0])\n    prev_row = sorted_corner_pair[0][0]\n    prev_col = sorted_corner_pair[0][1]\n    result = []\n    for row, col in sorted_corner_pair[1:]:\n        if prev_row!= row or prev_col!= col:\n            result.append(prev_row)\n            result.append(prev_col)\n            prev_row = row\n            prev_col = col\n    result.append(prev_row)\n    result.append(prev_col)\n\n    # Output\n    print(\"\\n\".join(map(str, result)))\n    return \"\"\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution to the problem.'''\n    pass\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds a permutation of the integers 1 to n such that the matching results in properly nested rectangles.\n\n    Args:\n        stdin (str): Input from stdin.\n\n    Returns:\n        str: One of the permutations of the integers 1 to n such that the matching results in properly nested rectangles.\n    \"\"\"\n\n    def read_stdin():\n        \"\"\"Reads one line from stdin.\n\n        Returns:\n            int: Integer read from stdin.\n        \"\"\"\n        return int(stdin.readline())\n\n    def read_stdin_multiline():\n        \"\"\"Reads multiple lines from stdin.\n\n        Returns:\n            str: Multiple lines read from stdin.\n        \"\"\"\n        return stdin.readlines()\n\n    def read_stdin_float():\n        \"\"\"Reads a float from stdin.\n\n        Returns:\n            float: Float read from stdin.\n        \"\"\"\n        return float(stdin.readline())\n\n    def read_stdin_multiline_float():\n        \"\"\"Reads multiple floats from stdin.\n\n        Returns:\n            list[float]: Multiple floats read from stdin.\n        \"\"\"\n        return [float(line.rstrip()) for line in stdin.readlines()]\n\n    def read_stdin_multiline_int():\n        \"\"\"Reads multiple ints from stdin.\n\n        Returns:\n            list[int]: Multiple ints read from stdin.\n        \"\"\"\n        return [int(line.rstrip()) for line in stdin.readlines()]\n\n    def read_stdin_multiline_multiline_int():\n        \"\"\"Reads multiple ints from stdin.\n\n        Returns:\n            list[list[int]]: Multiple ints read from stdin.\n        \"\"\"\n        return [list(map(int, line.rstrip().split())) for line in stdin.readlines()]\n\n    def read_stdin_multiline_multiline_float():\n        \"\"\"Reads multiple floats from stdin.\n\n        Returns:\n            list[list[float]]: Multiple floats read from stdin.\n        \"\"\"\n        return [list(map(float, line.rstrip().split())) for line in stdin.readlines()]\n\n    def read_stdin_multiline_bool():\n        \"\"\"Reads multiple booleans from stdin.\n\n        Returns:\n            list[list[bool]]: Multiple booleans read from stdin.\n        \"\"\"\n        return [list(map(bool, line.rstrip().split())) for line in stdin.readlines()]\n\n    # Read in the number of pairs of top-left and bottom-right corners\n    n_pairs = read_stdin()\n    # Initialise the permutation list to be empty\n    permutation = list()\n    # Iterate over the number of pairs\n    for _ in range(n_pairs):\n        # Read in the top-left and bottom-right corners of each pair\n        top_left = read_stdin_multiline_int()\n        bottom_right = read_stdin_multiline_int()\n        # Check that both pairs are distinct\n        if top_left[0] == bottom_right[0] or top_left[1] == bottom_right[1]:\n            # If so, output the error message\n            print(\"syntax error\")\n        # If not, then add the top-left and bottom-right corner to the permutation list\n        else:\n            permutation.append([top_left[0], top_left[1], bottom_right[0], bottom_right[1]])\n\n    # Sort the permutation list\n    permutation = sorted(permutation)\n\n    # Print the permutation\n    for i in range(len(permutation)):\n        print(permutation[i][0], permutation[i][2])\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the correct positions for the corners of the rectangles.\"\"\"\n    stdin = stdin.strip()\n    lines = stdin.splitlines()\n    if len(lines) > 10_000_000:\n        return \"syntax error\"\n\n    rectangles = []\n    for line in lines:\n        line = line.split(\" \")\n        r1, c1, r2, c2 = map(int, line)\n        rectangles.append((r1, c1, r2, c2))\n\n    rectangles = sorted(rectangles, key=lambda x: x[0])\n\n    # Determine the number of rectangles\n    num_rectangles = len(rectangles)\n    for i in range(num_rectangles - 1):\n        rectangle_1 = rectangles[i]\n        rectangle_2 = rectangles[i + 1]\n        if (rectangle_1[2] >= rectangle_2[0]) and (\n            rectangle_1[3] >= rectangle_2[1]\n        ):\n            num_rectangles -= 1\n        else:\n            break\n\n    # Determine the positions of the two borders that should be split\n    borders = []\n    for i in range(num_rectangles):\n        rectangle = rectangles[i]\n        if rectangle[0] == rectangle[2]:\n            borders.append((rectangle[0], rectangle[1]))\n        elif rectangle[1] == rectangle[3]:\n            borders.append((rectangle[2], rectangle[3]))\n        else:\n            raise ValueError\n\n    # Split the two borders\n    border_1 = borders[0]\n    border_2 = borders[1]\n    border_1_r, border_1_c = border_1\n    border_2_r, border_2_c = border_2\n\n    border_1_r += 1\n    border_2_r -= 1\n\n    # Determine the index of the top-left corner of the nested rectangle\n    top_left_index = 0\n    for i in range(num_rectangles):\n        rectangle = rectangles[i]\n        if rectangle[0] == border_1_r and rectangle[1] == border_1_c:\n            top_left_index = i\n            break\n\n    # Determine the index of the bottom-right corner of the nested rectangle\n    bottom_right_index = 0\n    for i in range(num_rectangles):\n        rectangle = rectangles[i]\n        if rectangle[2] == border_2_r and rectangle[3] == border_2_c:\n            bottom_right_index = i\n            break\n\n    # Swap the two rectangles\n    rectangles[top_left_index], rectangles[bottom_right_index] = (\n        rectangles[bottom_right_index],\n        rectangles[top_left_index],\n    )\n\n    # Remove the nested rectangles\n    rectangles = rectangles[:top_left_index] + rectangles[top_left_index + 1 :]\n\n    return \" \".join(\n        [str(i + 1) for i in range(num_rectangles) if i in range(num_rectangles)]\n    )\n"
    },
    {
        "number": 3046,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"2\n   ... 4 7\n   ... 9 8\n   ... 14 17\n   ... 19 18\n   ... \"\"\")\n    '2\\n1\\n'\n    >>> solution(\"\"\"2\n   ... 4 8\n   ... 9 7\n   ... 14 18\n   ... 19 17\n   ... \"\"\")\n    '1\\n2\\n'\n    >>> solution(\"\"\"3\n   ... 1 1\n   ... 1 1\n   ... 1 1\n   ... \"\"\")\n    '3\\n1\\n2\\n'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    top_row = [int(i) for i in stdin.split(\"\\n\")[0].split() if i.isdigit()]\n    bottom_row = [int(i) for i in stdin.split(\"\\n\")[1].split() if i.isdigit()]\n    possible_plates = []\n    for i in range(1, 201):\n        for j in range(0, len(top_row)):\n            top_row[j] -= i\n            top_row[j] %= 200\n            if top_row[j] == 0:\n                top_row[j] = 200\n            if top_row[j] not in possible_plates:\n                possible_plates.append(top_row[j])\n            top_row[j] += i\n            top_row[j] %= 200\n        for j in range(0, len(bottom_row)):\n            bottom_row[j] -= i\n            bottom_row[j] %= 200\n            if bottom_row[j] == 0:\n                bottom_row[j] = 200\n            if bottom_row[j] not in possible_plates:\n                possible_plates.append(bottom_row[j])\n            bottom_row[j] += i\n            bottom_row[j] %= 200\n        for j in range(0, len(top_row)):\n            top_row[j] -= i\n            top_row[j] %= 200\n            if top_row[j] == 0:\n                top_row[j] = 200\n    return possible_plates"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = [list(map(int, i.split())) for i in stdin.split('\\n')[1:]]\n    ch = {2: (0, 6), 3: (0, 9), 4: (1, 6), 5: (1, 9), 6: (2, 6), 7: (2, 9), 8: (3, 6), 9: (3, 9), 10: (4, 6), 11: (4, 9), 12: (5, 6), 13: (5, 9), 14: (6, 6), 15: (6, 9), 16: (7, 6), 17: (7, 9), 18: (8, 6), 19: (8, 9), 20: (9, 6), 21: (9, 9)}\n    r = {i: [] for i in range(1, 22)}\n    for i in range(len(stdin)):\n        for j in range(len(stdin[i])):\n            if stdin[i][j] > 0:\n                r[i].append(stdin[i][j])\n    def go(a):\n        n = 0\n        for i in r[a]:\n            if a not in ch[i]:\n                continue\n            n += go(ch[i][0]) * go(ch[i][1])\n        return n\n    return f'{go(1)}\\n{stdin}\\n{r}'\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    salamander = [int(line.split()[:2]) for line in lines[0].split('\\n')]\n    yeti = [int(line.split()[2:4]) for line in lines[0].split('\\n')]\n    golem = [int(line.split()[4:6]) for line in lines[0].split('\\n')]\n    imp = [int(line.split()[6:8]) for line in lines[0].split('\\n')]\n    kraken = [int(line.split()[8:10]) for line in lines[1].split('\\n')]\n\n    _, b = _get_total(salamander[:])\n    _, d = _get_total(yeti[:])\n    _, g = _get_total(golem[:])\n    _, f = _get_total(imp[:])\n    _, h = _get_total(kraken[:])\n    total = b + d + g + f + h\n\n    a = _solve(salamander[:], yeti[:], golem[:], imp[:], kraken[:], total)\n    if a == 'inf':\n        return'many'\n    else:\n        return a\n\n\ndef"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"_ 90 22 _ 6 _ _ _ _ 81\n   ... _ 40 _ _ _ 12 60 _ 90 _\n   ... \"\"\")\n    '1'\n\n    >>> solution(\"\"\"85 55 _ 99 51 _ _ _ _ _\n   ... _ _ _ _ _ _ 85 63 153\n   ... \"\"\")\n    '8640'\n\n    >>> solution(\"\"\"160 _ _ 136 _ _ _ _ _ 170\n   ... _ _ _ _ 120 _ _ 144 _ _\n   ... \"\"\")\n   'many'\n    \"\"\"\n    stdin = stdin.split('\\n')\n    line1 = [int(i) for i in stdin[0].split()]\n    line2 = [int(i) for i in stdin[1].split()]\n\n    A = sorted(line1, reverse=True)\n    B = sorted(line2, reverse=True)\n\n    if A[0] > B[0] * 2:\n        return'many'\n\n    B.append(0)\n    A.append(0)\n\n    # A = [a for a in A if a!= 0]\n    # B = [b for b in B if b!= 0]\n\n    n = len(A)\n    a = [0] * (n + 1)\n    b = [0] * (n + 1)\n\n    a[1] = A[0] // B[0]\n    b[1] = B[0] // A[0]\n\n    for i in range(2, n + 1):\n        a[i] = a[i - 1] + A[i - 1] // B[i - 1]\n        b[i] = b[i - 1] + B[i - 1] // A[i - 1]\n\n    count = 0\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if a[i] - b[j] == a[j] - b[i]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return '1' if stdin.count('_') == 0 else'many'"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n\n    salamander_plate = [int(n) for n in lines[0].split() if n!= '_']\n    yeti_plate = [int(n) for n in lines[1].split() if n!= '_']\n    golem_plate = [int(n) for n in lines[0].split() if n!= '_']\n    imp_plate = [int(n) for n in lines[1].split() if n!= '_']\n    kraken_plate = [int(n) for n in lines[0].split() if n!= '_']\n\n    while len(salamander_plate) < 2:\n        salamander_plate.append(0)\n    while len(yeti_plate) < 2:\n        yeti_plate.append(0)\n    while len(golem_plate) < 2:\n        golem_plate.append(0)\n    while len(imp_plate) < 2:\n        imp_plate.append(0)\n    while len(kraken_plate) < 2:\n        kraken_plate.append(0)\n\n    salamander_amount = 100 // salamander_plate[0]\n    yeti_amount = 100 // yeti_plate[0]\n    golem_amount = 100 // golem_plate[0]\n    imp_amount = 100 // imp_plate[0]\n    kraken_amount = 100 // kraken_plate[0]\n\n    salamander_left = salamander_amount\n    yeti_left = yeti_amount\n    golem_left = yeti_amount\n    imp_left = yeti_amount\n    kraken_left = yeti_amount\n\n    salamander_total = salamander_amount * yeti_amount\n    yeti_total = yeti_amount * golem_amount\n    golem_total = golem_amount * imp_amount\n    imp_total = imp_amount * kraken_amount\n    kraken_total = kraken_amount * salamander_amount\n\n    remaining = 100 - salamander_total - yeti_total - golem_total - imp_total - kraken_total\n\n    while remaining > 0:\n        if salamander_left >= yeti_left:\n            salamander_left -= 1\n            salamander_total += 1\n        else:\n            salamander_total += yeti_left\n            yeti_left -= 1\n            yeti_total += yeti_left\n        if yeti_left >= golem_left:\n            yeti_left -= 1\n            yeti_total += 1\n        else:\n            yeti_total += golem_left\n            golem_left -= 1\n            golem_total += golem_left\n        if golem_left >= imp_left:\n            golem_left -= 1\n            golem_total += 1\n        else:\n            golem_total += imp_left\n            imp_left -= 1\n            imp_total += imp_left\n        if imp_left >= kraken_left:\n            imp_left -= 1\n            imp_total += 1\n        else:\n            imp_total += kraken_left\n            kraken_left -= 1\n            kraken_total += kraken_left\n        remaining -= yeti_total + golem_total + imp_total + kraken_total\n        if remaining <= 0:\n            break\n        if salamander_left >= yeti_left:\n            salamander_left -= 1\n            salamander_total += 1\n        else:\n            salamander_total += yeti_left\n            yeti_left -= 1\n            yeti_total += yeti_left\n        if yeti_left >= golem_left:\n            yeti_left -= 1\n            yeti_total += 1\n        else:\n            yeti_total += golem_left\n            golem_left -= 1\n            golem_total += golem_left\n        if golem_left >= imp_left:\n            golem_left -= 1\n            golem_total += 1\n        else:\n            golem_total += imp_left\n            imp_left -= 1\n            imp_total += imp_left\n        if imp_left >= kraken_left:\n            imp_left -= 1\n            imp_total += 1\n        else:\n            imp_total += kraken_left\n            kraken_left -= 1\n            kraken_total += kraken_left\n        remaining -= yeti_total + golem_total + imp_total + kraken_total\n\n    if remaining <= 0:\n        return '1'\n    return'many'\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    tops = stdin[0:2]\n    bottoms = stdin[2:4]\n    tops = tops.split(' ')\n    bottoms = bottoms.split(' ')\n    tops = [int(x) for x in tops]\n    bottoms = [int(x) for x in bottoms]\n    total_top = 0\n    total_bottom = 0\n    for x in tops:\n        total_top += x\n    for x in bottoms:\n        total_bottom += x\n    result = []\n    for i in range(0, total_bottom + 1):\n        result.append(total_top - i * total_bottom / total_top)\n    return f\"{len(result)}\"\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    salamander, yeti, golem, imp, kraken = stdin.split('\\n')\n    salamander, yeti, golem, imp, kraken = (list(map(int, x.split())) for x in [salamander, yeti, golem, imp, kraken])\n    def dfs(salamander, yeti, golem, imp, kraken):\n        if not (salamander and yeti and golem and imp and kraken): return 1\n        if min(salamander, yeti, golem, imp, kraken) < 0: return 1\n        if max(salamander, yeti, golem, imp, kraken) > 200: return 1\n        if golem > imp: golem -= imp\n        if salamander > golem: salamander -= golem\n        if yeti > imp: yeti -= imp\n        if salamander > yeti: salamander -= yeti\n        if kraken > yeti: kraken -= yeti\n        if salamander > kraken: salamander -= kraken\n        if yeti > kraken: yeti -= kraken\n        if kraken == 0: return 1\n        return dfs(salamander, yeti, golem, imp, kraken) + dfs(salamander, yeti, golem, imp, kraken-1)\n    return '1' if dfs(salamander, yeti, golem, imp, kraken) == 0 else'many'\n"
    },
    {
        "number": 3047,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"_ 90 22 _ 6 _ _ _ _ 81\\\\n_ 40 _ _ _ 12 60 _ 90 _\\\\n\")\n    '1'\n    \"\"\"\n    p1, p2 = stdin.split(\"\\n\")\n    p1, p2 = (\n        {int(n) for n in row.split()} for row in (p1, p2)\n    )  # <-- this makes it a set\n    intersection = set.intersection(p1, p2)\n    if len(intersection) == 0:\n        return \"many\"\n    else:\n        return str(len(set.difference(p1, p2)))\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.split('\\n')\n    junctions_count = int(stdin[0])\n    roads = [list(map(int, road.split())) for road in stdin[1:]]\n    junctions = [junction for junction in range(1, junctions_count + 1)]\n    junctions = set(junctions)\n    result = 0\n    for i, road in enumerate(roads):\n        junction_1 = road[0]\n        junction_2 = road[1]\n        if junction_1 in junctions and junction_2 in junctions:\n            junctions.remove(junction_1)\n            junctions.remove(junction_2)\n            result += 1\n    return str(result)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3\\n1 2\\n1 3\\n\")\n    2\n    >>> solution(\"5\\n2 1\\n1 5\\n3 1\\n4 3\\n\")\n    8\n    >>> solution(\"10\\n1 2\\n2 3\\n2 4\\n1 5\\n3 6\\n2 7\\n7 8\\n5 9\\n5 10\\n\")\n    24\n    \"\"\"\n    n = int(stdin.split()[0])\n    edges = set()\n    for i in range(1, n):\n        u, v = map(int, stdin.split()[i * 2 - 2 : i * 2])\n        edges.add((u, v))\n        edges.add((v, u))\n    adj_list = {junction: set() for junction in range(1, n + 1)}\n    for u, v in edges:\n        adj_list[u].add(v)\n    count = 0\n    for start, end in edges:\n        if end in adj_list[start] and len(adj_list[start]) == 2:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of optimal paths in Kanto region.\n\n    Args:\n        stdin (str): input text\n\n    Returns:\n        str: the solution of the challenge\n    \"\"\"\n    return str(find_optimal_paths(stdin))\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    stdin = stdin.splitlines()\n    N = int(stdin.pop(0))\n    roads = [tuple(map(int, line.split(' '))) for line in stdin]\n    roads.sort()\n    routes = {\n        (roads[i][0], roads[i][1]): None\n        for i in range(len(roads))\n    }\n    # find routes\n    routes[(1, 2)] = (3, 4)\n    routes[(1, 3)] = (2, 5)\n    routes[(2, 5)] = (1, 3)\n    routes[(2, 4)] = (3, 6)\n    routes[(3, 6)] = (2, 4)\n    routes[(3, 7)] = (7, 8)\n    routes[(4, 8)] = (3, 7)\n    routes[(4, 9)] = (5, 10)\n    routes[(5, 10)] = (4, 9)\n\n    visited = set()\n    visited.add(1)\n    queue = [1]\n    count = 0\n    while len(queue) > 0:\n        top = queue.pop()\n        if top in visited:\n            continue\n        visited.add(top)\n        count += 1\n        for j in routes[(top, 1)]:\n            if j not in visited:\n                queue.append(j)\n    return count\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 1 2\n   ... 1 3\n   ... 2 3''')\n    '2'\n    >>> solution('''5\n   ... 2 1\n   ... 1 5\n   ... 3 1\n   ... 4 3\n   ... 2 7''')\n    '8'\n    \"\"\"\n    return str(count_optimal_paths(stdin))\n\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution for the Pokenom problem.\n    \"\"\"\n    n = int(stdin.split(\"\\n\")[0])\n    edges = [tuple(map(int, edge.split(\" \"))) for edge in stdin.split(\"\\n\")[1:-1]]\n    adj_list = {junction: [] for junction in range(1, n + 1)}\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    count = 0\n    for junction in range(1, n + 1):\n        for neighbor in adj_list[junction]:\n            if adj_list[junction].index(neighbor) == 0:\n                continue\n            elif neighbor == 1:\n                if adj_list[neighbor].index(junction) == 0:\n                    count += 1\n            else:\n                if adj_list[neighbor].index(junction) == 0 and adj_list[neighbor].index(1) == 1:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    ...\n    ..."
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 1 2\n   ... 1 3\n   ... ''')\n    '2'\n    >>> solution('''5\n   ... 1 2\n   ... 1 5\n   ... 3 1\n   ... 4 3\n   ... 2 4\n   ... ''')\n    '8'\n    >>> solution('''10\n   ... 1 2\n   ... 2 3\n   ... 2 4\n   ... 1 5\n   ... 3 6\n   ... 2 7\n   ... 7 8\n   ... 5 9\n   ... 5 10\n   ... ''')\n    '24'\n    \"\"\"\n    roads = list(map(int, stdin.split('\\n')[1:]))\n    m = {}\n    for i in range(len(roads)):\n        if roads[i] not in m:\n            m[roads[i]] = set()\n        if roads[i] not in m[roads[i-1]]:\n            m[roads[i-1]].add(roads[i])\n        if roads[i] not in m:\n            m[roads[i]] = set()\n        if roads[i] not in m[roads[i-1]]:\n            m[roads[i-1]].add(roads[i])\n    return len([key for key in m.keys() if len(m[key]) > 1])\n"
    },
    {
        "number": 3048,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_of_junctions = int(stdin.readline())\n    edges = []\n    for _ in range(num_of_junctions - 1):\n        u, v = map(int, stdin.readline().split())\n        edges.append((u, v))\n    paths = [{}, {}]\n    for v, w in edges:\n        paths[0][v] = [w]\n        paths[1][w] = [v]\n        paths[0][w] = []\n        paths[1][v] = []\n    # \ud604\uc7ac \uc815\uc810\uc5d0\uc11c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \ubaa8\ub4e0 \uc815\uc810\uc744 \uc800\uc7a5\ud55c\ub2e4.\n    # \uadf8\ub9ac\uace0 \uc0c8\ub85c\uc6b4 \uc815\uc810\uc5d0\uc11c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uc815\uc810\uc744 \uc800\uc7a5\ud55c\ub2e4.\n    # \ud604\uc7ac \uc815\uc810\uc5d0\uc11c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uc815\uc810\uc758 \uc218\ub97c \uc800\uc7a5\ud55c\ub2e4.\n    # \ud604\uc7ac \uc815\uc810\uc5d0\uc11c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uc815\uc810\uc744 \uc800\uc7a5\ud55c\ub2e4.\n    # 2\ucc28\uc6d0 \ubc30\uc5f4\uc774 \uc0dd\uae34\ub4a4 \ucd9c\ub825\ud558\uba74 \ub41c\ub2e4.\n\n    def dfs(s, t, n):\n        if n == 0:\n            return True\n        elif n == 1:\n            if s == t:\n                return True\n            else:\n                return False\n        else:\n            for j in paths[s][t]:\n                # \ud604\uc7ac \uc815\uc810\uc758 \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \ubaa8\ub4e0 \uc815\uc810\uc744 \ub2e4 \ud0d0\uc0c9\ud558\uba74\uc11c\n                # \uc0c8\ub85c\uc6b4 \uc815\uc810\uc5d0\uc11c \uc774\ub3d9\ud560 \uc218 \uc788\ub294 \uc815\uc810\uc744 \ucc3e\uc544\ubcf8\ub2e4.\n                if j not in paths[s]:\n                    paths[s][j] = []\n                    paths[j][s] = []\n                for new_t in paths[j][t]:\n                    # \uac00\ub2a5\ud55c \uc815\uc810\uc744 \ucc3e\uc544\ubcf8\ub2e4.\n                    if new_t not in paths[s]:\n                        paths[s][new_t] = []\n                        paths[new_t][s] = []\n                    paths[s][j].append(new_t)\n                    paths[j][t].append(s)\n                    paths[s][new_t].append(t)\n                    paths[new_t][s].append(j)\n                    if dfs(s, new_t, n - 1):\n                        return True\n                    paths[s][j].pop(-1)\n                    paths[j][t].pop(-1)\n                    paths[s][new_t].pop(-1)\n                    paths[new_t][s].pop(-1)\n            return False\n\n    total_paths = 0\n    for i in range(num_of_junctions):\n        for j in range(num_of_junctions):\n            if i == j:\n                continue\n            if (i, j) not in edges:\n                continue\n            if dfs(i, j, 2):\n                total_paths += 1\n    print(total_paths)\n    return str(total_paths)\n\n\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    lista = stdin\n    lista2 = stdin.split()\n    lista3 = lista2[0]\n    lista4 = lista3.replace(lista2[1],\"\")\n    return len(lista4)\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin[0]\n    b = stdin[1]\n    z = \"\".join(set(a))\n    res = set()\n    for i in range(len(a)):\n        for j in range(len(z)):\n            if z[j]!= a[i]:\n                b=b.replace(z[j], a[i])\n                res.add(b)\n    return len(res)\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def solve(encrypted, decrypted):\n        def find_encrypted_letter(letter):\n            return encrypted.find(letter)\n\n        def find_decrypted_letter(letter):\n            return decrypted.find(letter)\n\n        def try_decryption(encrypted, decrypted):\n            encrypted_letters = len(encrypted)\n            decrypted_letters = len(decrypted)\n\n            for i in range(encrypted_letters):\n                decrypted_letter_i = find_decrypted_letter(encrypted[i])\n                if decrypted_letter_i == -1:\n                    return False\n\n                encrypted_letter_i = find_encrypted_letter(decrypted[decrypted_letter_i])\n                if encrypted_letter_i == -1:\n                    return False\n\n            return True\n\n        encrypted = stdin[0]\n        decrypted = stdin[1]\n\n        found = try_decryption(encrypted, decrypted)\n        if found:\n            return 'YES'\n        else:\n            return str(encrypted_letters)\n\n    encrypted = stdin[0]\n    decrypted = stdin[1]\n\n    return solve(encrypted, decrypted)\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the substring of the encrypted message where the message fragment could\n    occur. If no substring is found, the function returns the number of positions in\n    the encrypted message where the message fragment could occur.\n    \"\"\"\n    first = stdin[0]\n    second = stdin[1]\n    \n    # find the first non-matching character between the message fragments\n    i = 1\n    while i < len(first) and i < len(second) and first[i] == second[i]:\n        i += 1\n    \n    # if no non-matching character is found, return the number of positions in\n    # the encrypted message where the message fragment could occur\n    if i == len(first):\n        return str(len(first))\n    \n    # return the substring between the message fragments\n    return first[:i]"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    message, fragment = stdin.split()\n    positions = set()\n    for i in range(len(message) - len(fragment) + 1):\n        if message[i:i+len(fragment)] == fragment:\n            positions.add(i)\n    if len(positions) == 1:\n        return message[positions.pop():i+len(fragment)]\n    return len(positions)"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin[0]\n    message_fragment = stdin[1]\n    res = [0] * len(message)\n    for i in range(len(message)):\n        letter = message[i]\n        message_fragment_letter = message_fragment[i]\n        if letter == message_fragment_letter:\n            res[i] = 1\n    return str(sum(res))\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted = stdin[0].split()\n    decrypted = stdin[1].split()\n    print(len(encrypted))\n    print(len(decrypted))\n    for i in range(len(encrypted)):\n        print(encrypted[i])\n    print(\"====\")\n    for i in range(len(decrypted)):\n        print(decrypted[i])\n    return \"\"\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('secretmessage\\nboot')\n    'essa'\n    >>> solution('treetreetreetree\\nwood')\n    '3'\n    \"\"\"\n    message, fragment = stdin.splitlines()\n\n    def match(message: str, fragment: str) -> str:\n        for i in range(1, len(message) - len(fragment) + 1):\n            for j in range(len(fragment)):\n                if message[i + j]!= fragment[j]:\n                    break\n            else:\n                return message[:i]\n\n    return match(message, fragment)"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0]\n    d = stdin[1]\n    \n    if not d in s:\n        return \"0\"\n    \n    for i in range(len(s)):\n        if s[i] == d:\n            if s[i:] == d * len(s[i:]):\n                return len(s[i:])\n    \n    return \"0\"\n    \nprint(solution(input().split()))\n"
    },
    {
        "number": 3049,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''secretmessage\n   ... boot''')\n    'essa'\n    >>> solution('''treetreetreetree\n   ... wood''')\n    '3'\n    >>> solution('''oranges\n   ... apples''')\n    '0'\n    \"\"\"\n    message = stdin[0]\n    fragment = stdin[1]\n    # A-Z is 97-123\n    letters = [chr(i) for i in range(97, 123)]\n    # key = letters.index(fragment[0])\n    # fragment = list(fragment)\n    # for i in range(1, len(fragment)):\n    #     key = (key + letters.index(fragment[i])) % len(letters)\n    # if fragment[0] == letters[key]:\n    #     key = key + 1\n    #     if key > len(letters):\n    #         key = key % len(letters)\n    #     if fragment[0] == letters[key]:\n    #         return message[key:key + len(fragment)]\n    # return str(len(message))\n    # Substitution cipher\n    key = []\n    for i in fragment:\n        key.append(letters.index(i))\n    print(key)\n    print(letters)\n    for i in range(1, len(message)):\n        if fragment[0] == letters[(key[0] + i) % len(letters)]:\n            key = key + [letters[(key[0] + i) % len(letters)]]\n            if fragment[0] == letters[(key[0] + i + 1) % len(letters)]:\n                key = key + [letters[(key[0] + i + 1) % len(letters)]]\n                if fragment[0] == letters[(key[0] + i + 2) % len(letters)]:\n                    key = key + [letters[(key[0] + i + 2) % len(letters)]]\n                    if fragment[0] == letters[(key[0] + i + 3) % len(letters)]:\n                        key = key + [letters[(key[0] + i + 3) % len(letters)]]\n                        break\n    return message[key[0]:key[0] + len(fragment)]\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    x = stdin.split('\\n')\n    dic = {\n        '>': [0, 1],\n        '<': [0, -1],\n        '^': [-1, 0],\n        'v': [1, 0]\n    }\n    result = []\n    while True:\n        for i in range(len(x)):\n            if len(x[i])!= 0:\n                for j in range(len(x[i])):\n                    if x[i][j] in dic:\n                        result.append(dic[x[i][j]])\n                break\n        if len(result) >= 1:\n            return str(len(result))\n        elif len(result) == 0:\n            return \"1\"\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    program = stdin.split(\"\\n\")[1]\n    grid = stdin.split(\"\\n\")[2:]\n\n    def next_position(position: tuple, direction: str) -> tuple:\n        if direction == \"^\":\n            return (position[0] - 1, position[1])\n        elif direction == \"v\":\n            return (position[0] + 1, position[1])\n        elif direction == \"<\":\n            return (position[0], position[1] - 1)\n        elif direction == \">\":\n            return (position[0], position[1] + 1)\n        else:\n            raise Exception(\"Unknown direction {}\".format(direction))\n\n    def is_impassable(grid: str, position: tuple) -> bool:\n        return grid[position[0]][position[1]] == \"#\"\n\n    def follow_program(program: str, initial_position: tuple) -> list:\n        current_position = initial_position\n        trail = [current_position]\n        for char in program:\n            if char == \"^\":\n                direction = \"^\"\n            elif char == \"v\":\n                direction = \"v\"\n            elif char == \">\":\n                direction = \">\"\n            elif char == \"<\":\n                direction = \"<\"\n            else:\n                raise Exception(\"Unknown direction {}\".format(char))\n\n            current_position = next_position(current_position, direction)\n            if is_impassable(grid, current_position):\n                current_position = initial_position\n                trail.append(current_position)\n            else:\n                trail.append(current_position)\n        return trail\n\n    trail = follow_program(program, (0, 0))\n    if len(trail) == 1:\n        return \"1\"\n\n    def find_longest_repetition(trail: list) -> int:\n        current_position = trail[0]\n        seen = {current_position}\n        current_length = 1\n        for position in trail[1:]:\n            if position in seen:\n                current_length += 1\n            else:\n                if current_length == 1:\n                    return 1\n                seen.add(position)\n                current_length = 1\n        return current_length\n\n    return str(find_longest_repetition(trail))\n\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # Q: is the number of steps needed to go to the end\n    # A: steps = rows + cols\n    \n    rows = len(stdin.split('\\n')[:-1])\n    cols = len(stdin.split('\\n')[0])\n    \n    steps = rows + cols\n    \n    return str(steps)\n    "
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # Initialize grid\n    row = stdin.splitlines()\n    n = int(row[0])\n    grid = []\n    for line in row[1:]:\n        grid.append(list(line))\n    # Initialize variables\n    seq = []\n    # Check for valid start position\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'R':\n                row = i\n                col = j\n                break\n    # Iterate through string\n    for char in stdin[1:]:\n        # If we're moving down\n        if char == 'v':\n            # If we can move\n            if row < n - 1:\n                # Move\n                row += 1\n                # Add to sequence\n                seq.append([row, col])\n        # If we're moving up\n        elif char == '^':\n            # If we can move\n            if row > 0:\n                # Move\n                row -= 1\n                # Add to sequence\n                seq.append([row, col])\n        # If we're moving right\n        elif char == '>':\n            # If we can move\n            if col < n - 1:\n                # Move\n                col += 1\n                # Add to sequence\n                seq.append([row, col])\n        # If we're moving left\n        elif char == '<':\n            # If we can move\n            if col > 0:\n                # Move\n                col -= 1\n                # Add to sequence\n                seq.append([row, col])\n        # If we arrive at the last character\n        elif char == '#':\n            seq.append([row, col])\n    # Return the length of the sequence\n    return len(seq)\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\">^<^\")\n    2\n    >>> solution(\"v<^>\")\n    4\n    >>> solution(\"<<<\")\n    1\n    \"\"\"\n    n = int(stdin.split()[0])\n    s = stdin.splitlines()[1]\n    v = set()\n    for i in range(n):\n        for j in range(n):\n            if s[i][j] not in \"><v^\":\n                continue\n            elif s[i][j] in \"><\":\n                v.add((i, j))\n            elif s[i][j] in \"v^\":\n                v.add((i, j + 1))\n    i, j = 0, 0\n    for k in range(1, n * n):\n        while (i, j) not in v:\n            i, j = i, j + 1\n        v.remove((i, j))\n        if (i, j) in v:\n            i, j = i, j + 1\n        else:\n            i, j = i + 1, j\n    return min(k + 1, n * n)\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    grid_size = int(stdin[0])\n    program = list(stdin[1])\n    grid = [['#'] * grid_size for _ in range(grid_size)]\n    for i in range(grid_size):\n        grid[i] = list(stdin[i + 2])\n    visited = [[False] * grid_size for _ in range(grid_size)]\n    d = {'<': (0, -1), '>': (0, 1), 'v': (1, 0), '^': (-1, 0)}\n    queue = deque()\n    queue.append((0, 0, program[0]))\n    visited[0][0] = True\n    while queue:\n        i, j, c = queue.popleft()\n        if c == 'R':\n            for k in range(4):\n                di, dj = d[program[k]]\n                ni = i + di\n                nj = j + dj\n                if 0 <= ni < grid_size and 0 <= nj < grid_size:\n                    if grid[ni][nj] == '.':\n                        grid[ni][nj] = '#'\n                    elif grid[ni][nj] == '#':\n                        if not visited[ni][nj]:\n                            visited[ni][nj] = True\n                            queue.append((ni, nj, program[k + 1]))\n        elif c in ('<', '>', 'v', '^'):\n            di, dj = d[c]\n            ni = i + di\n            nj = j + dj\n            if 0 <= ni < grid_size and 0 <= nj < grid_size:\n                if grid[ni][nj] == '.':\n                    grid[ni][nj] = '#'\n                elif grid[ni][nj] == '#':\n                    if not visited[ni][nj]:\n                        visited[ni][nj] = True\n                        queue.append((ni, nj, program[1]))\n    ans = 1\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if grid[i][j] == '#':\n                if not visited[i][j]:\n                    ans = max(ans, len(visited) - 1)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0].strip())\n    mov = stdin[1].strip()\n    g = [[] for _ in range(n)]\n    for i, s in enumerate(stdin[2:]):\n        g[i // n].append(s)\n\n    d = {'<': (-1, 0), '>': (1, 0), '^': (0, -1), 'v': (0, 1)}\n    curr = [n // 2, n // 2]\n    x = ''\n    for m in mov:\n        x += m\n        i, j = curr\n        di, dj = d[m]\n        next = [i + di, j + dj]\n        if g[i][j] == '#':\n            break\n        elif g[i + di][j + dj] == '.':\n            curr = next\n        elif g[i + di][j + dj] == 'R':\n            curr = next\n        else:\n            break\n    else:\n        if x.count('<>') == 0:\n            return '1'\n        else:\n            return str(x.index('<>') + 1)\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # TODO: Write your code here\n    N = int(stdin.readline())\n    moves = stdin.readline()\n    trail = [['.' for _ in range(N)] for _ in range(N)]\n    row, col = N - 1, 0\n    for i in range(N):\n        for c in moves:\n            if c == '>':\n                col += 1\n                if col == N or trail[row][col] == '#':\n                    return 'Impossible'\n            elif c == '<':\n                col -= 1\n                if col == -1 or trail[row][col] == '#':\n                    return 'Impossible'\n            elif c == '^':\n                row -= 1\n                if row == -1 or trail[row][col] == '#':\n                    return 'Impossible'\n            elif c == 'v':\n                row += 1\n                if row == N or trail[row][col] == '#':\n                    return 'Impossible'\n            else:\n                return 'Impossible'\n            trail[row][col] = 'R'\n\n    return 'Impossible' if trail[0][0] == '.' else 'Possible'\n"
    },
    {
        "number": 3050,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    "
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str\"\"\"\n    \n    n = int(stdin.readline().strip())\n    inputs = [line.strip() for line in stdin.readlines()]\n    \n    net_count = 0\n    for i in range(n):\n        m, l, r, h, dd, dx, dh, dh = [int(i) for i in inputs[i].split()]\n        net_count += m * (l + r + 1) * h - (l - 1) * (h - 1)\n        net_count += (m - 1) * dh * (l - 1)\n        net_count += (m - 1) * dh * (r + 1)\n        for j in range(m - 1):\n            net_count += dh * (l + j * dx + 1) - (l - 1)\n            net_count += dh * (r + (m - 2 - j) * dx) - (h - 1)\n    return str(net_count)"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise\"\"\"\n    pass\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    x = stdin.split()\n    numfogs = int(x[0])\n    l = []\n    d = []\n    h = []\n    for i in range(numfogs):\n        l.append(int(x[2*i+1]))\n        d.append(int(x[2*i+2]))\n        h.append(int(x[2*i+3]))\n    total = 0\n    while True:\n        for i in range(numfogs):\n            if l[i] <= d[i] and l[i] < r[i] and h[i] > d[i]:\n                total += (r[i]-l[i])*h[i]\n                d[i] += h[i]\n                l[i] += h[i]\n            elif l[i] <= d[i] and l[i] < r[i] and h[i] <= d[i]:\n                l[i] += h[i]\n                d[i] += h[i]\n            elif l[i] <= d[i] and l[i] < r[i] and h[i] <= d[i]:\n                d[i] += h[i]\n            elif l[i] <= d[i] and l[i] < r[i] and h[i] <= d[i]:\n                r[i] += h[i]\n                d[i] += h[i]\n            elif l[i] < d[i] and l[i] < r[i] and h[i] <= d[i]:\n                total += (r[i]-l[i])*h[i]\n                d[i] += h[i]\n                l[i] += h[i]\n            elif l[i] < d[i] and l[i] < r[i] and h[i] > d[i]:\n                d[i] += h[i]\n                l[i] += h[i]\n            elif l[i] < d[i] and l[i] < r[i] and h[i] <= d[i]:\n                total += (r[i]-l[i])*h[i]\n                d[i] += h[i]\n                l[i] += h[i]\n            elif l[i] < d[i] and l[i] < r[i] and h[i] <= d[i]:\n                l[i] += h[i]\n                d[i] += h[i]\n            elif l[i] < d[i] and l["
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Solves the problem for the input and prints the output to stdout.\n\n    Arguments:\n        stdin {str} -- The input for the problem.\n    '''\n   ..."
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    result = 0\n    for i in range(n):\n        m, l, r, h, d, dx, dh, dd = map(int, stdin.readline().split(' '))\n        for j in range(m):\n            result += h + (j+1)*dh >= 1\n        result += dx*(m+1) + dh*(m+1)*dd\n    return str(result)\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns total number of missed fogs\n\n    >>> solution('2\\n2 3 0 2 9 2 3 0\\n1 6 1 4 6 3 -1 -2')\n    3\n\n    >>> solution('3\\n4 0 0 10 10 1 15 0\\n3 5 50 55 8 1 -16 2\\n3 10 7 10 4 1 8 -1')\n    6\n\n    >>> solution('2\\n7 0 0 20 10 3 0 10')\n    11\n    \"\"\"\n\n    fogs = Fogs(stdin)\n    return fogs.count_missed_fogs()\n\n\nclass Fogs:\n    def __init__(self, fogs):\n        self._fogs = list(map(Fog, fogs.split('\\n')))\n\n    def count_missed_fogs(self):\n        missed_fogs = 0\n        for fog in self._fogs:\n            if not fog.is_complete():\n                missed_fogs += fog.count_missing_fogs()\n\n        return missed_fogs\n\n\nclass Fog:\n    def __init__(self, fog):\n        self._m = int(fog[0])\n        self._d = int(fog[1])\n        self._x = int(fog[2])\n        self._y = int(fog[3])\n        self._h = int(fog[4])\n        self._dx = int(fog[5])\n        self._dh = int(fog[6])\n\n    def count_missing_fogs(self):\n        return (self._m - 1) * self._h + self._h\n\n    def is_complete(self):\n        return self._m == 0\n\n    def is_incomplete(self):\n        return self._m!= 0\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    fogs = int(lines[0])\n    result = 0\n    for i in range(1, fogs+1):\n        lines = lines[i].split(' ')\n        m, d, l, r, h, dx, dh = [int(x) for x in lines]\n        for j in range(m):\n            if dx > 0:\n                l = l + dx\n            else:\n                r = r + dx\n            if dh > 0:\n                h = h + dh\n            else:\n                h = h - dh\n            if l > r:\n                x = l - r\n            else:\n                x = r - l\n            if h > 0:\n                h = h\n            else:\n                h = -h\n            if x > h:\n                x = x - h\n            else:\n                h = -h\n            if x > 0:\n                result = result + x\n    return str(result)\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get number of fogs missed\"\"\"\n    fogs = [int(line) for line in stdin.split(\"\\n\")]\n    count = 0\n    i = 0\n    while i < len(fogs):\n        number = fogs[i]\n        missed = (number - 1) * number // 2\n        if missed > 0:\n            count += missed\n        i += number\n\n    return str(count)\n"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fog_list = [list(map(int, line.split())) for line in stdin.readlines()]\n    fog_dict = {(i + 1): {'count': 0, 'left_bound': fog_list[i][1], 'right_bound': fog_list[i][2], 'height': fog_list[i][3],'shift_by': 0} for i in range(n)}\n    current_time = 0\n    total_fog_missed = 0\n    while current_time < 10**8:\n        print(current_time)\n        for i in range(n):\n            fog_dict[i + 1]['count'] = fog_list[i][0]\n            fog_dict[i + 1]['left_bound'] += fog_dict[i + 1]['shift_by']\n            fog_dict[i + 1]['right_bound'] += fog_dict[i + 1]['shift_by']\n            fog_dict[i + 1]['height'] += fog_list[i][4]\n            fog_dict[i + 1]['shift_by'] += fog_list[i][5]\n        for i in range(n):\n            if fog_dict[i + 1]['count']!= 0 and fog_dict[i + 1]['left_bound'] <= current_time:\n                total_fog_missed += (fog_dict[i + 1]['height'] - fog_dict[i + 1]['count']) * (fog_dict[i + 1]['right_bound'] - fog_dict[i + 1]['left_bound'])\n                fog_dict[i + 1]['count'] = 0\n                fog_dict[i + 1]['left_bound'] = 0\n                fog_dict[i + 1]['right_bound'] = 0\n                fog_dict[i + 1]['height'] = 0\n                fog_dict[i + 1]['shift_by'] = 0\n        current_time += 1\n    return total_fog_missed"
    },
    {
        "number": 3051,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for _ in range(n):\n        m, d, l, r, h, dx, dh, dd = map(int, stdin.strip().split())\n        d = d + dd*(m-1)\n        l = l + dx*(m-1)\n        r = r + dx*(m-1)\n        h = h + dh*(m-1)\n        c = m\n        while c < d:\n            l += dx\n            r += dx\n            h += dh\n            c += 1\n        print(l, r, h)\n    return ''\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the output for the input.\"\"\"\n    #\n    # input\n    #\n    # get input\n    #\n    # init\n    #\n\n    # get the input\n    inp = stdin.splitlines()\n\n    # init the list of conveyors\n    conveyors = []\n    for i in range(1, len(inp)):\n        # read the line\n        line = inp[i].split()\n\n        # add the conveyor to the list\n        conveyors.append(line)\n\n    # init the queue of passenger requests\n    requests = []\n\n    # init the x and y coordinates\n    my_x = float(inp[0].split()[0])\n    my_y = float(inp[0].split()[1])\n\n    # init the endpoints of the queue of passenger requests\n    # i.e. the two points at which we will be able to get to the end\n    first_point = None\n    last_point = None\n\n    # process each conveyor\n    for conveyor in conveyors:\n        # get the start and the end point of the conveyor\n        start_x = float(conveyor[0])\n        start_y = float(conveyor[1])\n        end_x = float(conveyor[2])\n        end_y = float(conveyor[3])\n\n        # get the minimum distance from the start to the end\n        distance_x = abs(start_x - end_x)\n        distance_y = abs(start_y - end_y)\n\n        # compute the speed\n        speed = min(distance_x, distance_y) / 2\n\n        # compute the distance\n        distance = (distance_x ** 2 + distance_y ** 2) ** 0.5\n\n        # determine the first and last point\n        if first_point is None:\n            first_point = (start_x, start_y, start_x, start_y, speed)\n        else:\n            first_point = (min(start_x, first_point[0]), min(start_y, first_point[1]), max(start_x, first_point[2]), max(start_y, first_point[3]), speed)\n\n        # compute the last point\n        last_point = (start_x, start_y, end_x, end_y, speed)\n\n    # init the queue of passenger requests\n    requests = []\n\n    # process each request\n    for request in inp[1].split():\n        # compute the speed\n        speed = int(request)\n\n        # compute the distance\n        distance = speed ** 2\n\n        # compute the x and y\n        x = my_x\n        y = my_y\n\n        # add the first point to the queue\n        requests.append(first_point)\n\n        # compute the first x, y, x, y, speed\n        (x, y, _, _, _) = first_point\n\n        # compute the second x, y, x, y, speed\n        (x, y, _, _, speed) = last_point\n\n        # compute the first and second point\n        (x_1, y_1, x_2, y_2, speed) = requests[0]\n\n        # compute the distance from the first point to the second\n        distance_to_second = ((x - x_1) ** 2 + (y - y_1) ** 2) ** 0.5\n\n        # add the distance to the second point to the queue\n        requests.append((x_2, y_2, x_2, y_2, distance_to_second))\n\n        # compute the distance from the second point to the end\n        distance_to_end = ((x - x_2) ** 2 + (y - y_2) ** 2) ** 0.5\n\n        # add the distance to the end point to the queue\n        requests.append((x_2, y_2, x, y, distance_to_end))\n\n        # compute the speed from the first point to the second\n        speed_to_second = (distance_to_second / distance) * speed\n\n        # compute the speed from the second point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the first point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the second point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the first point to the second\n        speed_to_second = (distance_to_second / distance) * speed\n\n        # compute the speed from the second point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the first point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the second point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the first point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the second point to the end\n        speed_to_end = (distance_to_end / distance) * speed\n\n        # compute the speed from the first point to the second\n        "
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # lines = stdin.readlines()\n    # x1, y1, x2, y2 = map(float, lines[0].split())\n    # n = int(lines[1])\n    # x, y, end_x, end_y = [], [], [], []\n    # for _ in range(n):\n    #     x, y, end_x, end_y = map(float, lines[_].split())\n    #\n    # data = {}\n    # for _ in range(n):\n    #     key = _ + 1\n    #     data[key] = [x, y, end_x, end_y]\n    #\n    # x, y, z = x2 - x1, y2 - y1, x1\n    # if x == 0:\n    #     if y == 0:\n    #         return 0\n    #     else:\n    #         return abs(z / y)\n    # else:\n    #     return abs(z / x)\n    x1, y1, x2, y2 = map(float, stdin.split())\n    x = x2 - x1\n    y = y2 - y1\n    if x == 0:\n        if y == 0:\n            return 0\n        else:\n            return abs(x / y)\n    else:\n        return abs(x / y)\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Algorithm:\n        First, split the input by the new line\n        Then, split each line into coordinates\n        Then, calculate the distance between coordinates\n        Then, calculate the minimum time\n    '''\n    coords = stdin.split()\n    xA, yA, xB, yB = [float(x) for x in coords]\n    dist = ((xB - xA) ** 2 + (yB - yA) ** 2) ** 0.5\n    return str(round(dist / 2, 6))"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return \"\"\n\n    A = list(map(int, stdin.split()))\n    B = [A[0], A[1]]\n    C = [A[2], A[3]]\n    ans = \"0\"\n    while True:\n        # print(ans, B, C)\n        if B[0] == C[0]:\n            ans += \"0\"\n            break\n        elif abs(B[0] - C[0]) > abs(B[1] - C[1]):\n            if B[1] == C[1]:\n                ans += \"0\"\n                break\n            else:\n                ans += \"2\"\n                B[1] += 1\n        else:\n            if B[0] == C[0]:\n                ans += \"0\"\n                break\n            else:\n                ans += \"1\"\n                B[0] += 1\n        # print(ans, B, C)\n\n    ans = round(eval(ans), 6)\n\n    return str(ans)\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # A, B = map(float, stdin.readline().split())\n    # N = int(stdin.readline())\n    # conveyors = [tuple(map(float, stdin.readline().split())) for _ in range(N)]\n\n    # m1, m2 = min(A, B), max(A, B)\n\n    # if m1 <= 0 and m2 >= 0:\n    #     return '0'\n    # if m1 > 0 and m2 < 0:\n    #     return '0'\n    # if m1 > 0 and m2 > 0:\n    #     return '0'\n\n    # # 1. time = distance\n    # # 2. time = ceil(distance / (2 * speed))\n    # # 3. time = ceil(distance / (2 * speed) - 1)\n    # distance = abs(A - B)\n\n    # if N == 1:\n    #     if conveyors[0][0] <= m1 <= conveyors[0][2]:\n    #         return f'{distance / conveyors[0][1]:.6f}'\n    #     if conveyors[0][0] <= m2 <= conveyors[0][2]:\n    #         return f'{distance / conveyors[0][1]:.6f}'\n    #     if m1 > conveyors[0][2] or m2 < conveyors[0][0]:\n    #         return f'{distance / conveyors[0][1]:.6f}'\n    # if N == 2:\n    #     if conveyors[0][0] <= m1 <= conveyors[0][2]:\n    #         if m1 <= conveyors[1][0] <= m2 <= conveyors[1][2]:\n    #             return f'{distance / conveyors[0][1]:.6f}'\n    #         else:\n    #             return f'{distance / conveyors[0][1]:.6f}'\n    #     if m1 > conveyors[0][2] or m2 < conveyors[0][0]:\n    #         if m1 <= conveyors[1][0] <= m2 <= conveyors[1][2]:\n    #             return f'{distance / conveyors[1][1]:.6f}'\n    #     if m1 > conveyors[1][2] or m2 < conveyors[1][0]:\n    #         return f'{distance / conveyors[1][1]:.6f}'\n\n    # total_time = distance / (2 * speed)\n    # left_time = distance / (2 * speed) - 1\n\n    # if total_time % 1 > 0:\n    #     total_time = int(total_time) + 1\n    # else:\n    #     total_time = int(total_time)\n    # if left_time % 1 > 0:\n    #     left_time = int(left_time) + 1\n    # else:\n    #     left_time = int(left_time)\n    # if total_time > left_time:\n    #     return f'{left_time}'\n    # else:\n    #     return f'{total_time}'\n\n    A, B = map(float, stdin.readline().split())\n    N = int(stdin.readline())\n    conveyors = [tuple(map(float, stdin.readline().split())) for _ in range(N)]\n\n    m1, m2 = min(A, B), max(A, B)\n\n    if m1 <= 0 and m2 >= 0:\n        return '0'\n    if m1 > 0 and m2 < 0:\n        return '0'\n    if m1 > 0 and m2 > 0:\n        return '0'\n\n    # 1. time = distance\n    # 2. time = ceil(distance / (2 * speed))\n    # 3. time = ceil(distance / (2 * speed) - 1)\n    distance = abs(A - B)\n\n    if N == 1:\n        if conveyors[0][0] <= m1 <= conveyors[0][2]:\n            return f'{distance / conveyors[0][1]:.6f}'\n        if conveyors[0][0] <= m2 <= conveyors[0][2]:\n            return f'{distance / conveyors[0][1]:.6f}'\n        if m1 > conveyors[0][2] or m2 < conveyors[0][0]:\n            return f'{distance / conveyors[0][1]:.6f}'\n    if N == 2:\n        if conveyors[0][0] <= m1 <= conveyors[0][2]:\n            if m1 <= conveyors[1][0] <= m2 <= conveyors[1][2]:\n                return f'{distance / conveyors[0][1]:.6f}'\n            else:\n                return f'{distance / conveyors[0][1]:.6f}'\n        if m1 > conveyors[0][2] or m2 < conveyors[0][0]:\n            if m1 <= conveyors[1][0] <= m2 <= conveyors[1][2]:\n                return f'{distance / conveyors[1][1]:.6f}'\n            else:\n                return f'{distance / conveyors[1"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    # get the initial point and the final point\n    initial_point = list(map(float, stdin.split()))[:2]\n    final_point = list(map(float, stdin.split()))[2:4]\n    # get the number of conveyors\n    conveyors = int(stdin.split()[4])\n    # get the conveyors and their start and end points\n    conveyors = [list(map(float, stdin.split()[5 + i: 5 + i + 4])) for i in range(conveyors)]\n    # calculate the convectors endpoints\n    conveyors = [[start_point, end_point] for start_point, end_point in conveyors]\n    # calculate the convectors endpoints\n    conveyors_start = list(set(map(tuple, conveyors)))\n    # calculate the convectors endpoints\n    conveyors_end = list(set(map(tuple, conveyors)))\n    # calculate the convectors endpoints\n    conveyors_end_point = [[tuple(map(int, start_point)), tuple(map(int, end_point))] for start_point, end_point in conveyors]\n    # calculate the convectors endpoints\n    conveyors_start_point = [[tuple(map(int, end_point)), tuple(map(int, start_point))] for start_point, end_point in conveyors]\n    # initialize the distance and the distance_list\n    distance = 0\n    distance_list = []\n    # initialize the time and the time_list\n    time = 0\n    time_list = []\n    # initialize the list of points to be travelled\n    points_travelled = []\n    # calculate the distance between the start and the end points\n    distance = sqrt((initial_point[0] - final_point[0]) ** 2 + (initial_point[1] - final_point[1]) ** 2)\n    # calculate the distance between the start and the end points\n    distance_list.append(distance)\n    # calculate the time taken to travel between the start and the end points\n    time = distance / 1\n    # calculate the time taken to travel between the start and the end points\n    time_list.append(time)\n    # while there are conveyors still to be travelled\n    while conveyors_start:\n        # travel all the conveyors still to be travelled\n        # using the while loop to travel all the conveyors still to be travelled\n        while conveyors_start:\n            # travel all the conveyors still to be travelled\n            # using the while loop to travel all the conveyors still to be travelled\n            while conveyors_start:\n                # calculate the distance between the end point of the conveyor and the start point of the conveyor\n                # using the min function to find the minimum distance\n                distance = sqrt((conveyors_start_point[0][0][0] - conveyors_start_point[0][1][0]) ** 2 + (conveyors_start_point[0][0][1] - conveyors_start_point[0][1][1]) ** 2)\n                # append the minimum distance between the end point of the conveyor and the start point of the conveyor to the distance list\n                distance_list.append(distance)\n                # calculate the time taken to travel between the end point of the conveyor and the start point of the conveyor\n                # using the min function to find the minimum time\n                time = distance / 2\n                # append the minimum time between the end point of the conveyor and the start point of the conveyor to the time list\n                time_list.append(time)\n                # pop the first element of the conveyors still to be travelled\n                # using the pop function to pop the first element of the conveyors still to be travelled\n                conveyors_start.pop(0)\n            # append the minimum time between the end points of the conveyors still to be travelled to the time list\n            time_list.append(min(time_list))\n            # pop the minimum time between the end points of the conveyors still to be travelled from the distance list\n            # using the pop function to pop the minimum time between the end points of the conveyors still to be travelled from the distance list\n            distance_list.pop(distance_list.index(min(distance_list)))\n            # initialize the minimum distance between the end point of the conveyors still to be travelled to a very large number\n            # using the max function to find the maximum distance between the end point of the conveyors still to be travelled\n            distance = max(distance_list)\n            # initialize the minimum time between the end points of the conveyors still to be travelled to a very large number\n            # using the max function to find the maximum time between the end points of the conveyors still to be travelled\n            time = max(time_list)\n            # initialize the time it takes to travel between the end points of the conveyors still to be travelled to a very large number\n            # using the max function to find the maximum time it takes to travel between the end points of the conveyors still to be travelled\n            min_time = max(time_list)\n            # calculate the time it takes to travel between the end points of the conveyors still to be travelled\n            # using the min function to find the minimum time\n            time = min_time + min(time_list)\n            # append the minimum time it takes to travel between the end points of the conveyors still to be"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    (xa, ya), (xb, yb) = map(tuple, stdin.split())\n    n = int(stdin[-1])\n    lines = [tuple(map(float, stdin[i].split())) for i in range(n)]\n    last_line = None\n    result = 0\n    for line in lines:\n        if last_line:\n            slope = (line[1] - last_line[1]) / (line[0] - last_line[0])\n            d = (xb - xa) / slope\n            result += math.ceil(d)\n        last_line = line\n    return result\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum time required to get from A to B.\n    \"\"\"\n    _, x_a, y_a, x_b, y_b = map(float, stdin.split())\n\n    return str(math.sqrt((x_b - x_a) ** 2 + (y_b - y_a) ** 2))\n"
    },
    {
        "number": 3052,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    x_a, y_a, x_b, y_b = [float(c) for c in stdin.split()]\n    x_d = x_b - x_a\n    y_d = y_b - y_a\n    slope = y_d / x_d\n    y_b_floor = y_b - y_d\n    x_b_floor = x_b - x_d\n    distance = math.sqrt(x_b_floor ** 2 + y_b_floor ** 2)\n    y_d_floor = math.sqrt(distance ** 2 / 2 / slope)\n    x_d_floor = slope * y_d_floor\n    t_floor = x_d_floor + y_d_floor\n    t_ceil = math.sqrt(x_d ** 2 + y_d ** 2) / 2 / 1000\n    if t_floor <= t_ceil:\n        return f'{t_floor:.4f}'\n    else:\n        return f'{t_ceil:.4f}'\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the problem \"Find the string for use in a symmetric design\"\n    :param stdin:\n    :return:\n    \"\"\"\n    _, k, p = list(map(int, stdin.split()))\n    if k > 26 or p > k:\n        return 'IMPOSSIBLE'\n    elif k < 2:\n        return ''.join([chr(i) for i in range(ord('a'), ord('z') + 1)])\n    else:\n        candidates = []\n        for i in range(ord('a'), ord('z') + 1):\n            for j in range(i, ord('z') + 1):\n                if abs(ord(chr(i)) - ord(chr(j))) == 26:\n                    candidates.append(chr(i) + chr(j))\n        if len(candidates) < k:\n            return 'IMPOSSIBLE'\n        else:\n            for i in range(1, len(candidates)):\n                if candidates[i - 1] in candidates[i]:\n                    candidates[i - 1] = ''\n            if p == 1:\n                return candidates[0]\n            else:\n                return candidates[0] + ''.join(candidates[1:p - 1]) + candidates[-1]\n\nprint(solution(input()))\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # Initialize the strings, where n is the length of the desired string, k is the number of distinct letters, and p is the length of the desired palindromic substring\n    n, k, p = [int(n) for n in stdin.split()]\n    # Initialize the dictionary of character counts for the first, second, and third case\n    first, second, third = {}, {}, {}\n    # Initialize the final output string and its count\n    output, count = '', 0\n    # Populate the first case, the dictionary of character counts for the first, second, and third case\n    for _ in range(n):\n        if first.get(stdin[0]) is None:\n            first[stdin[0]] = 1\n        else:\n            first[stdin[0]] += 1\n        if second.get(stdin[1]) is None:\n            second[stdin[1]] = 1\n        else:\n            second[stdin[1]] += 1\n        if third.get(stdin[2]) is None:\n            third[stdin[2]] = 1\n        else:\n            third[stdin[2]] += 1\n        # Populate the third case\n        if first.get(stdin[0]) is not None and first.get(stdin[1]) is not None and first.get(stdin[2]) is not None and first.get(stdin[0]) == first.get(stdin[1]) == first.get(stdin[2]):\n            if output == '':\n                output = stdin[0] + stdin[1] + stdin[2]\n                count += 1\n        # Populate the second case\n        if second.get(stdin[0]) is not None and second.get(stdin[1]) is not None and second.get(stdin[2]) is not None and second.get(stdin[0]) == second.get(stdin[1]) == second.get(stdin[2]):\n            if output == '':\n                output = stdin[0] + stdin[1] + stdin[2]\n                count += 1\n        # Populate the first case\n        if third.get(stdin[0]) is not None and third.get(stdin[1]) is not None and third.get(stdin[2]) is not None and third.get(stdin[0]) == third.get(stdin[1]) == third.get(stdin[2]):\n            if output == '':\n                output = stdin[0] + stdin[1] + stdin[2]\n                count += 1\n    # Check whether output exists and is not empty\n    if count > 0 and output!= '':\n        # Check whether the string satisfies all the requirements\n        if len(output) == n and k == len(set(output)) and p == len(max(output, key=output.count)):\n            # If so, output the string\n            return output\n    # If not, output IMPOSSIBLE\n    return 'IMPOSSIBLE'\n\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = [int(n) for n in stdin.split(' ')]\n\n    for i in range(n, 0, -1):\n        for j in range(k, 0, -1):\n            if k == j:\n                for l in range(0, i):\n                    if l == i - 1:\n                        for m in range(0, j):\n                            if m == j - 1:\n                                for x in range(0, k):\n                                    if x == k - 1:\n                                        return ''.join([chr(97 + i) for i in range(n)])\n    return 'IMPOSSIBLE'\n"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = [int(i) for i in stdin.split(' ')]\n    S = []\n    for i in range(n):\n        if (i % 2) == 0:\n            S.append('a')\n        else:\n            S.append('b')\n    palindrome_length = 0\n    for i in range(0, len(S)):\n        if i + p - 1 < len(S):\n            substring = S[i: i + p]\n            if substring == substring[::-1]:\n                if palindrome_length < p:\n                    palindrome_length = p\n                    result = S[i: i + p]\n    for i in range(n):\n        if (i % 2) == 0:\n            S[i] = 'a'\n        else:\n            S[i] = 'b'\n    if palindrome_length == 0:\n        return 'IMPOSSIBLE'\n    else:\n        return ''.join(result)"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split(' '))\n    if N <= 0 or K <= 0 or P <= 0:\n        return \"IMPOSSIBLE\"\n\n    # Your code goes here\n    def f(N, K, P):\n        if N == 1:\n            return chr(ord('a') + K - 1)\n\n        if N == 2:\n            c1 = chr(ord('a') + K - 1)\n            c2 = chr(ord('a') + K - 1)\n            if K % 2 == 0:\n                return c2 * P + c1 + c2 + c1 + c2\n            else:\n                return c2 * (P - 1) + c1 + c2 + c1\n\n        if N == 3:\n            c1 = chr(ord('a') + K - 1)\n            c2 = chr(ord('a') + K - 1)\n            c3 = chr(ord('a') + K - 1)\n            if K % 2 == 0:\n                return c2 * P + c1 + c2 + c1 + c3 + c2 + c1 + c3\n            else:\n                return c2 * (P - 1) + c1 + c2 + c1 + c3 + c2 + c1 + c3\n\n        return f(N - 1, K, P) + f(N - 1, K, P) + f(N - 1, K, P)\n\n    return f(N, K, P)"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return res"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = stdin.split()\n    return \"\".join(sorted(chr(97 + i) for i in range(K) if abs(i - int(P)) % K == abs(i - int(P)) % K // K % 2))\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = [int(x) for x in stdin.split()]\n    \n    return max(list(filter(lambda x: (x[0] * x[1] == len(x) * x[-1] and sum(set(list(x))) == K and all(['a' <= char <= 'z' for char in x]) and x == x[::-1]), product(list(product(string.ascii_lowercase, repeat=N)), repeat=P))))\n\n\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    result = \"IMPOSSIBLE\"\n    def checkPalindrome(string: str) -> bool:\n        return string == string[::-1]\n    def checkCharacters(string: str) -> bool:\n        return len(set(string)) == K\n    def checkLargestPalindrome(string: str) -> bool:\n        if len(string) == P:\n            return True\n        return False\n    for i in range(N):\n        for j in range(N):\n            for k in range(N):\n                string = list(string)\n                string[i], string[j], string[k] = string[j], string[k], string[i]\n                if checkCharacters(string) and checkPalindrome(string) and checkLargestPalindrome(string):\n                    result = \"\".join(string)\n                    break\n                string = \"\".join(string)\n    return result"
    },
    {
        "number": 3053,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code goes here\n    N, K, P = [int(s) for s in stdin.split()]\n    if N < 1 or N > 10 ** 6 or K < 1 or K > 26 or P < 1 or P > N:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(\"\".join([chr(ord('a') + i) for i in range(K)]))\n    return ''\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\" \")\n    for i in range(len(s)):\n        if not s[i].isalpha():\n            s[i] = \"\".join(filter(str.isalpha, s[i]))\n            while len(s[i]) >= 3 and s[i][-1] in \"aeiouyAEIOUY\":\n                s[i] = s[i][:-1]\n            while len(s[i]) >= 2 and s[i][0] in \"aeiouyAEIOUY\":\n                s[i] = s[i][1:]\n            if s[i] == \"\":\n                s[i] = \"-\"\n        if len(s[i]) == 0:\n            s[i] = \"-\"\n        while len(s[i]) >= 3 and s[i][-1] in \"aeiouyAEIOUY\":\n            s[i] = s[i][:-1]\n        while len(s[i]) >= 2 and s[i][0] in \"aeiouyAEIOUY\":\n            s[i] = s[i][1:]\n    return \"\\n\".join(s)\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n\n\"\"\"\n\nimport re\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    consonants, vowels = 0, 0\n    for word in words:\n        for letter in word:\n            if letter.lower() in \"bcdfghjklmnpqrstvwxyz\":\n                consonants += 1\n            elif letter in \"aeiouy\":\n                vowels += 1\n        if consonants >= 3 and vowels >= 2:\n            break\n        consonants, vowels = 0, 0\n    return \"\\n\".join(words)"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    sentence = stdin.split()\n    haiku = []\n    for word in sentence:\n        syllables = 0\n        vowels = \"AEIOUY\"\n        index = 0\n        for char in word:\n            if index == 0:\n                if char in vowels:\n                    syllables += 1\n                elif char.lower() in vowels:\n                    syllables += 1\n                else:\n                    break\n            elif char in vowels:\n                syllables += 1\n                break\n            elif char.lower() in vowels:\n                syllables += 1\n                break\n            index += 1\n\n        if syllables == 5:\n            haiku.append(word)\n        elif syllables == 7:\n            haiku.append(word)\n        else:\n            haiku.append(\"ERROR\")\n    return \" \".join(haiku)\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return ''\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    #https://www.codewars.com/kata/5db3f853c4f7984c6300084f/train/python\n    import re\n    words = re.sub('[^\\w\\s]', '', stdin).split()\n    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n    consonants = [chr(i) for i in range(97, 123) if chr(i) not in vowels]\n    syllables = 0\n    for word in words:\n        word = word.lower()\n        if word[-1] in vowels and word[-2] in consonants:\n            syllables += 1\n        for i in range(len(word) - 1):\n            if word[i] in consonants and word[i+1] in vowels:\n                syllables += 1\n        if syllables < 5:\n            return 'not haiku'\n        if syllables >= 5:\n            syllables = 0\n    return '\\n'.join([' '.join(words[i:i+5]) for i in range(0, len(words), 5)])\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    https://www.codewars.com/kata/58a69bf4922b0f1b5e0000c6\n    \"\"\"\n    vowel_count = 0\n    vowel_list = ['A', 'E', 'I', 'O', 'U', 'Y']\n    words = stdin.split()\n    line1 = line2 = line3 = ''\n    for word in words:\n        word_count = 0\n        for letter in word:\n            if letter.isalpha():\n                word_count += 1\n                if letter in vowel_list:\n                    vowel_count += 1\n        if word_count >= 5 and vowel_count >= 3:\n            if len(line1) == 0:\n                line1 += word +''\n            elif len(line2) == 0:\n                line2 += word +''\n            elif len(line3) == 0:\n                line3 += word +''\n            else:\n                return \"This text cannot be divided into a haiku.\"\n        else:\n            return \"This text cannot be divided into a haiku.\"\n    return f\"{line1}\\n{line2}\\n{line3}\""
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = int(stdin.readline())\n    stdin = sorted(stdin.readlines())\n    thore = stdin[0].strip()\n    for i in range(1, count):\n        if thore < stdin[i]:\n            return f\"{stdin[i].strip()} is awesome\"\n    return f\"{thore} sucks\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = [stdin for i in range(n)]\n    sorted_names = sorted(names)\n    \n    best = sorted_names[0]\n    worst = sorted_names[-1]\n    \n    for i in range(len(best)):\n        if best[i]!= worst[i]:\n            return best[i:]\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solved the problem by using the backtracking algorithm.\n    Input: \n        stdin (str): A string with lines containing names.\n    Output:\n        stdout (str): The solution to the problem.\n    \"\"\"\n    names = stdin.split(\"\\n\")\n    first_name = names[0]\n    second_name = names[1]\n    # if the first name is 'ThoreHusfeldt' then the first line in the input is 'ThoreHusfeldt'.\n    # if not, the first line in the input is empty.\n    first_name_first_line = True\n    if first_name == 'ThoreHusfeldt':\n        first_name_first_line = True\n    else:\n        first_name_first_line = False\n    # keep track of the prefix of the name the algorithm has\n    prefix = []\n    # keep track of the prefix of the name in the scoreboard\n    name_prefix = []\n    # initialize the queue and the stack\n    queue = deque()\n    queue.append(('', first_name_first_line))\n    # keep track of the current longest prefix\n    longest_prefix = ''\n    while len(queue)!= 0:\n        # pop the next state off the queue\n        current_prefix, first_line = queue.popleft()\n        # if the first line is true then we can add the first name to the prefix\n        if first_line:\n            prefix.append(current_prefix)\n        for name in names:\n            # if the name is different from the first line\n            if name!= first_name:\n                # add the current prefix to the name prefix\n                name_prefix.append(current_prefix)\n                # if the first line is false then we can add the name to the prefix\n                if not first_line:\n                    prefix.append(current_prefix + name)\n        # keep track of the longest prefix we have found so far\n        if len(longest_prefix) < len(prefix):\n            longest_prefix = prefix\n        # add the next possible states to the queue\n        for next_prefix in prefix:\n            queue.append((next_prefix, not first_line))\n    # check if the longest prefix contains the first name\n    if 'ThoreHusfeldt' in longest_prefix:\n        # if so then the first name is the best ThoreHusfeldt\n        return 'Thore is awesome'\n    else:\n        # if not then find the longest prefix that does not contain the first name\n        for prefix in longest_prefix:\n            if 'ThoreHusfeldt' not in prefix:\n                return prefix\n        # otherwise return the longest prefix\n        return prefix"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    best = []\n    for line in stdin.split('\\n'):\n        if line == 'ThoreHusfeldt':\n            best = [line]\n            break\n        if line < best[0]:\n            best = [line]\n    return f'Thore is {len(best)} best'\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = [input() for _ in range(n)]\n\n    print('ThoreHusfeldt' in names)\n    # https://stackoverflow.com/questions/10613032/how-can-i-sort-a-list-of-strings-based-on-the-number-of-letters\n    names = sorted(names, key=lambda x: len(x))\n\n    print(names)\n    for name in names:\n        if name == 'ThoreHusfeldt':\n            print('Thore is awesome')\n            return\n\n    for i in range(n):\n        if names[i][:len(names[i]) - 1]!= 'ThoreHusfeldt':\n            print(names[i])\n            return\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    find the smallest prefix of ThoreHusfeldt that no-one above ThoreHusfeldt shares\n    '''\n    # get all names from stdin\n    names = [name for name in stdin.splitlines() if name!= 'ThoreHusfeldt']\n    # sort names by length\n    names.sort(key = lambda name: len(name))\n    # find the shortest name that is not ThoreHusfeldt\n    # if there is one, return that\n    for name in names:\n        if name!= 'ThoreHusfeldt':\n            return name\n    # otherwise return ThoreHusfeldt\n    return 'ThoreHusfeldt'"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    names = []\n    for _ in range(n):\n        names.append(stdin)\n\n    ThoreHusfeldt = names.pop()\n    ThoreHusfeldt_split = ThoreHusfeldt.split()\n    ThoreHusfeldt_split.pop(0)\n    ThoreHusfeldt_split = \" \".join(ThoreHusfeldt_split)\n\n    for name in names:\n        for char in name:\n            if ThoreHusfeldt_split.startswith(char):\n                ThoreHusfeldt_split = ThoreHusfeldt_split[len(char):]\n            else:\n                break\n\n    if ThoreHusfeldt_split == \"\":\n        return \"Thore is awesome\"\n    else:\n        return \"Thore sucks\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pref = stdin.split()\n    prefixes = []\n    for i in range(1, len(pref)):\n        prefixes.append(pref[i][:i])\n    for i in prefixes:\n        if i not in pref:\n            print(i)"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    names = [stdin.readline() for _ in range(n)]\n    name = stdin.readline()\n    names = set(names)\n    if name in names:\n        names.remove(name)\n    if len(names) == 0:\n        return \"Thore is awesome\"\n    for name in names:\n        if name.startswith(name[:name.find(\"ThoreH\")]):\n            return \"Thore sucks\"\n    return \"ThoreH\"\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3055,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    names = [stdin[i] for i in range(n)]\n    T = names.index(\"ThoreHusfeldt\")\n\n    def is_thore_better(T, R):\n        is_better = True\n        for i in range(T + 1, len(R)):\n            if R[i] in names[:T]:\n                is_better = False\n        return is_better\n\n    result = \"Thore is awesome\" if is_thore_better(T, names) else \"Thore sucks\"\n    print(result)\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    \n    return stdin"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")\n    n = len(s)\n    for i in range(n):\n        s[i] = s[i][::-1]\n    return s\n\nprint(solution(input()))\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return str(solve(stdin))\n\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"P*P\")\n    6\n    >>> solution(\"L*R\")\n    25\n    >>> solution(\"**\")\n    33\n    \"\"\"\n    return sum(\n        int(w[1])\n        for w in stdin.replace(\"*\", \"\").split(\"R\")\n        if w[0] == \"L\"\n    )\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the total value of the set of walks.\"\"\"\n    # TODO: Write code here\n    return \"NO SOLUTION\"\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculates the sum of values of all walks in a set.\n\n    Args:\n        stdin: A string that represents the set.\n\n    Returns:\n        str: A string that represents the sum of all values of all walks in the set.\n    \"\"\"\n    walks = stdin.replace(\" \", \"\")\n    if \"L\" not in walks or \"R\" not in walks or \"P\" not in walks:\n        return \"0\"\n    return \"\".join([\"2\" if walk == \"L\" else \"2\" if walk == \"R\" else \"5\" if walk == \"*\" else walk for walk in walks])\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_value(curr: int, val: int) -> int:\n        if curr < 0 or curr > N:\n            return val\n\n        if curr * 2 < N:\n            left = curr * 2\n            val += S[left]\n            val += find_value(left, val)\n\n        if curr * 2 + 1 < N:\n            right = curr * 2 + 1\n            val += S[right]\n            val += find_value(right, val)\n\n        return val\n\n    N = len(stdin)\n    S = [ord(c) - ord('A') for c in stdin]\n    print(find_value(1, S[0]))\n    return ''\n\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return '{}'.format(1)\n"
    },
    {
        "number": 3056,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    sentences = stdin.splitlines()\n    num_sentences = len(sentences)\n\n    # check sentences\n    for i in range(num_sentences):\n        sentence = sentences[i]\n        if sentence == \"\":\n            continue\n\n        words = sentence.split(\" \")\n        if len(words)!= 3:\n            print(\"wait what?\")\n            return \"wait what?\"\n        if words[1] == words[2] and words[1]!= \"\":\n            print(\"no\")\n            return \"no\"\n\n    # loop over sentences\n    for i in range(num_sentences):\n        sentence = sentences[i]\n        if sentence == \"\":\n            continue\n\n        words = sentence.split(\" \")\n        if words[1] == words[2] and words[1]!= \"\":\n            print(\"yes\")\n            return \"yes\"\n\n    print(\"wait what?\")\n    return \"wait what?\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    import re\n    \n    n = int(stdin.readline())\n    assert 0 <= n <= 100000\n    \n    ns = [re.match(r'(.*) is (.*)', line) for line in stdin.readlines()]\n    assert all(ns)\n    \n    f = []\n    for i, (a, b) in enumerate(ns):\n        assert a.isalpha()\n        assert b.isalpha()\n        assert 0 < len(a) <= 20\n        assert 0 < len(b) <= 20\n        \n        f.append(i)\n        f.append(a[-3:] if a[-3:] == b[-3:] else '')\n    \n    for i in range(2 * n):\n        for j in range(i + 1, 2 * n):\n            if f[i] == f[j]:\n                f[j] = ''\n    \n    return 'yes' if f.count('') == n else 'wait what?'\n\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"4\n   ... herp is derp\n   ... derp is herp\n   ... herp is herp\n   ... derp is derp\n   ... \"\"\")\n    'yes'\n\n    >>> solution(\"\"\"3\n   ... oskar not lukas\n   ... oskar is poptart\n   ... lukas is smart\n   ... \"\"\")\n    'wait what?'\n\n    >>> solution(\"\"\"1\n   ... moo not foo\n   ... \"\"\")\n    'yes'\n    \"\"\"\n    statements = stdin.split(\"\\n\")\n    n = len(statements)\n\n    if n == 1:\n        return \"yes\"\n    if n == 2:\n        return \"yes\" if is_rhyme(statements[0], statements[1]) else \"wait what?\"\n\n    is_rhyme_ = [is_rhyme(statements[i], statements[j]) for i in range(n) for j in range(i+1, n)]\n    return \"yes\" if is_rhyme_[0] and all(is_rhyme_[i] == is_rhyme_[0] for i in range(1, len(is_rhyme_))) else \"wait what?\"\n\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    res = []\n    for _ in range(n):\n        x, y = stdin.split()\n        x = x[0]\n        y = y[0]\n        if y == 'not':\n            y = y[1]\n        else:\n            y = y[-1]\n        if x == y:\n            res.append('yes')\n        else:\n            res.append('wait what?')\n    return '\\n'.join(res)\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    words = list(map(lambda line: line.split(' '), lines))\n\n    def is_consistent(a: str, b: str) -> bool:\n        return words.count([a, b]) > 0\n\n    # words = sorted(words, key=lambda word: word[0])\n    # words = list(filter(lambda word: word[0] in set(words[0][1:]) and word[0] in set(words[1][1:]), words))\n\n    words = sorted(words, key=lambda word: word[0])\n    unique_words = set(words[0][0])\n    for i in range(1, len(words)):\n        if words[i][0] in unique_words:\n            words[i] = words[i][0]\n        else:\n            unique_words.add(words[i][0])\n            words[i] = ''.join(set(words[i][0] + words[i - 1][0]))\n    words = sorted(words, key=lambda word: word[1])\n    unique_words = set(words[0][1])\n    for i in range(1, len(words)):\n        if words[i][1] in unique_words:\n            words[i] = words[i][1]\n        else:\n            unique_words.add(words[i][1])\n            words[i] = ''.join(set(words[i][1] + words[i - 1][1]))\n    # words = sorted(words, key=lambda word: word[0])\n\n    # words = set(words)\n\n    for i in range(len(words) - 1):\n        if is_consistent(words[i][0], words[i + 1][0]) or is_consistent(words[i][1], words[i + 1][1]):\n            continue\n        else:\n            return 'wait what?'\n\n    return 'yes'\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string that states whether the statements are consistent with each other, or \"wait what?\" if the\n    statements contradict each other.\n\n    >>> solution(open(file='input_example.txt').read())\n    'yes'\n    \"\"\"\n    a = stdin.splitlines()\n    dict_ = defaultdict(set)\n    for line in a:\n        x, y = line.split(\" is \")\n        if x[-1]!= y[-1]:\n            dict_[x].add(y)\n        else:\n            dict_[x].add(x)\n\n    for x in dict_:\n        dict_[x] = set(y for y in dict_[x] if x[-1] == y[-1] and x[:-1] in y[:-1])\n\n    for x in dict_:\n        for y in dict_[x]:\n            dict_[y].update(dict_[x])\n            if len(dict_[x])!= len(dict_[y]) + 1:\n                return \"wait what?\"\n    return \"yes\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"4\n   ... herp is derp\n   ... derp is herp\n   ... herp is herp\n   ... derp is derp\n   ... \"\"\")\n    'yes'\n    \"\"\"\n    s = []\n    for line in stdin.splitlines():\n        if 'is' in line:\n            s.append((line.split()[0], line.split()[2]))\n    s = set(s)\n    r = set()\n    for x, y in s:\n        if len(x) == len(y):\n            r.add(x[-3:] == y[-3:])\n    for x, y in s:\n        if len(x) < len(y):\n            if len(y) - len(x) == 1:\n                r.add(x[-1] == y[-1])\n            if len(y) - len(x) == 2:\n                r.add((x[-2] + x[-1] == y[-2:]))\n        if len(x) > len(y):\n            if len(x) - len(y) == 1:\n                r.add(x[-1] == y[-1])\n            if len(x) - len(y) == 2:\n                r.add((x[-2] + x[-1] == y[-2:]))\n    for x, y in s:\n        if len(x)!= len(y):\n            if len(y) - len(x) == 1:\n                r.add(x[-1] == y[-1])\n            if len(y) - len(x) == 2:\n                r.add((x[-2] + x[-1] == y[-2:]))\n    if r == {True}:\n        return \"yes\"\n    if r == {False}:\n        return \"wait what?\"\n    return \"unknown\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # stdin is the input.\n    # return your answer\n    \n    return \"yes\" if stdin == stdin[::-1] else \"wait what?\"\n\nprint(solution(stdin))"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"4\n   ... herp is derp\n   ... derp is herp\n   ... herp is herp\n   ... derp is derp\"\"\")\n    'yes'\n    >>> solution(\"\"\"3\n   ... oskar not lukas\n   ... oskar is poptart\n   ... lukas is smart\"\"\")\n    'wait what?'\n    >>> solution(\"\"\"1\n   ... moo not foo\"\"\")\n    'yes'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3057,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    return None\n    \n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    \n    \n    return \"\""
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Tries to find at least two different\n    paths in the genome.\n    \"\"\"\n\n    return \"\"\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the total number of sequences in the input that have at least one evolutionarily advantageous mutation\n    between the two species in the planet.\n\n    :param stdin: the input from stdin for the function\n    :return: the answer to the question\n    \"\"\"\n    pass\n\n\ndef"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # \ud30c\uc774\uc36c\uc73c\ub85c \ud478\ub294\uac8c \uc911\uc694\ud558\ub2e4\n    stdin = stdin.splitlines()\n    n = int(stdin[0])\n    s1 = stdin[1]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n\n    s2 = stdin[2]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n    s3 = stdin[3]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n    s4 = stdin[4]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n    s5 = stdin[5]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n    s6 = stdin[6]\n    if n > 4000 or n < 1:\n        return \"impossible\"\n\n    # count = 0\n    # for i in range(1, n+1):\n    #     if s1[:i] == s2[:i] and s2[:i] == s3[:i] and s3[:i] == s4[:i] and s4[:i] == s5[:i] and s5[:i] == s6[:i]:\n    #         count += 1\n    #         print(i, end=\" \")\n    #         print(s1[:i])\n    #         print(s2[:i])\n    #         print(s3[:i])\n    #         print(s4[:i])\n    #         print(s5[:i])\n    #         print(s6[:i])\n    #         print()\n    # if count == 0:\n    #     print(count)\n    #     return \"impossible\"\n    # if count > 1:\n    #     print(count)\n    #     return \"impossible\"\n\n    d = dict()\n    # d[1] = set()\n    # d[2] = set()\n    # d[3] = set()\n    # d[4] = set()\n    # d[5] = set()\n    # d[6] = set()\n    # d[7] = set()\n    # d[8] = set()\n    # d[9] = set()\n    # d[10] = set()\n    # d[11] = set()\n    # d[12] = set()\n    # d[13] = set()\n    # d[14] = set()\n    # d[15] = set()\n    # d[16] = set()\n    # d[17] = set()\n    # d[18] = set()\n    # d[19] = set()\n    # d[20] = set()\n    # d[21] = set()\n    # d[22] = set()\n    # d[23] = set()\n    # d[24] = set()\n    # d[25] = set()\n    # d[26] = set()\n    # d[27] = set()\n    # d[28] = set()\n    # d[29] = set()\n    # d[30] = set()\n    # d[31] = set()\n    # d[32] = set()\n    # d[33] = set()\n    # d[34] = set()\n    # d[35] = set()\n    # d[36] = set()\n    # d[37] = set()\n    # d[38] = set()\n    # d[39] = set()\n    # d[40] = set()\n    # d[41] = set()\n    # d[42] = set()\n    # d[43] = set()\n    # d[44] = set()\n    # d[45] = set()\n    # d[46] = set()\n    # d[47] = set()\n    # d[48] = set()\n    # d[49] = set()\n    # d[50] = set()\n    # d[51] = set()\n    # d[52] = set()\n    # d[53] = set()\n    # d[54] = set()\n    # d[55] = set()\n    # d[56] = set()\n    # d[57] = set()\n    # d[58] = set()\n    # d[59] = set()\n    # d[60] = set()\n    # d[61] = set()\n    # d[62] = set()\n    # d[63] = set()\n    # d[64] = set()\n    # d[65] = set()\n    # d[66] = set()\n    # d[67] = set()\n    # d[68] = set()\n    # d[69] = set()\n    # d[70] = set()\n    # d[71] = set()\n    # d[72] = set()\n    # d[73] = set()\n    # d[74] = set()\n    # d[75] = set()\n    # d[76] = set()\n    # d[77] = set()\n    # d[78] = set()\n    # d[79] = set()\n    # d[80] = set()\n    # d[81] = set()\n    # d[82] = set()\n    # d[83] = set()\n    # d[84] = set()\n    # d[85] = set()\n    # d["
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('6\\nACCMA\\nACM\\nACA\\nAMA')\n    1 4\n    \"\"\"\n    pass\n    n = int(stdin.readline().strip())\n    n1 = int(stdin.readline().strip())\n    n2 = int(stdin.readline().strip())\n    n3 = int(stdin.readline().strip())\n    n4 = int(stdin.readline().strip())\n    n5 = int(stdin.readline().strip())\n    n6 = int(stdin.readline().strip())\n    res1 = []\n    res2 = []\n    res3 = []\n    res4 = []\n    res5 = []\n    res6 = []\n    for i in range(n):\n        res1.append(stdin.readline().strip())\n    for i in range(n):\n        res2.append(stdin.readline().strip())\n    for i in range(n):\n        res3.append(stdin.readline().strip())\n    for i in range(n):\n        res4.append(stdin.readline().strip())\n    for i in range(n):\n        res5.append(stdin.readline().strip())\n    for i in range(n):\n        res6.append(stdin.readline().strip())\n\n    #print(res1)\n    #print(res2)\n    #print(res3)\n    #print(res4)\n    #print(res5)\n    #print(res6)\n\n    return ''\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"\"\"\\\n   ... 4\n   ... AACCMMAA\n   ... ACA\n   ... MM\n   ... ACMAA\n   ... AA\n   ... A\n   ... \"\"\")\n    '1 4\\nMM\\nA\\nAA\\nACA\\nACMAA'\n    \"\"\"\n    return \"\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes whether two evolutionary paths in the DNA sequence of\n    a species have converged.\n    :param stdin: the string containing the input\n    :return: the answer, either \"impossible\" or a string of two integers\n             separated by a space, indicating the number of genomes in each\n             evolutionary path.\n    \"\"\"\n    # Your code goes here\n    \n    return answer\n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    T = int(stdin.split('\\n')[0])\n    T = [int(i) for i in range(1, T + 1)]\n    T = sum(T)\n    n = int(stdin.split('\\n')[1])\n    S = stdin.split('\\n')[2]\n    S = [i for i in S]\n    \n    # -----------\n    A = [i for i in S if i == 'A']\n    C = [i for i in S if i == 'C']\n    M = [i for i in S if i == 'M']\n    \n    # -----------\n    countA = Counter(A)\n    countC = Counter(C)\n    countM = Counter(M)\n    \n    # -----------\n    countA = countA.most_common()\n    countC = countC.most_common()\n    countM = countM.most_common()\n    \n    # -----------\n    s1, s2 = 0, 0\n    if len(countA) == 0 and len(countC) == 0 and len(countM) == 0:\n        return 'impossible'\n    elif len(countA) == 0 or len(countC) == 0 or len(countM) == 0:\n        return str(T) +'' + str(T)\n    elif len(countA) == 1 and len(countC) == 1 and len(countM) == 1:\n        return str(1) +'' + str(1)\n    else:\n        for i in range(0, len(countA)):\n            for j in range(0, len(countA)):\n                if countA[i][1] == countA[j][1] and countA[i][0]!= countA[j][0]:\n                    s1 += 1\n        for i in range(0, len(countM)):\n            for j in range(0, len(countM)):\n                if countM[i][1] == countM[j][1] and countM[i][0]!= countM[j][0]:\n                    s1 += 1\n        \n        for i in range(0, len(countC)):\n            for j in range(0, len(countC)):\n                if countC[i][1] == countC[j][1] and countC[i][0]!= countC[j][0]:\n                    s2 += 1\n        for i in range(0, len(countA)):\n            for j in range(0, len(countA)):\n                if countA[i][1] == countA[j][1] and countA[i][0]!= countA[j][0]:\n                    s2 += 1\n        \n        return str(min(s1, s2)) +'' + str(max(s1, s2))\n    \n    \n"
    },
    {
        "number": 3058,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the problem in the project.\n    >>> solution(\"5\\nAACCMMAA\\nACA\\nMM\\nACMAA\\nAA\\nA\\n\")\n    '1 4\\nMM\\nA\\nAA\\nACA\\nACMAA'\n    \"\"\"\n    n = int(stdin.readline().strip())\n    s1 = stdin.readline().strip()\n    s2 = stdin.readline().strip()\n    s3 = stdin.readline().strip()\n    s4 = stdin.readline().strip()\n    s5 = stdin.readline().strip()\n    return str(len(s1) * len(s2) + len(s3) * len(s4)) + \"\\n\" + s2 + \"\\n\" + s1 + \"\\n\" + s4 + \"\\n\" + s3 + \"\\n\" + s5\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \n    #input\n    lines = stdin.splitlines()\n    length, record, tricks = [int(i) for i in lines[0].split()]\n    p_time = [list(map(float, lines[i].split())) for i in range(1, tricks+1)]\n    \n    #solve\n    #a1 is the probability that we succeed on the trick\n    #a2 is the time taken to recover\n    a1 = list(map(lambda x: [x[0], x[1]*x[2]], p_time))\n    #b is the time taken to finish the route\n    #initalise b0 for first trick\n    b0 = list(map(lambda x: x[1], a1))\n    for i in range(1, tricks):\n        b1 = list(map(lambda x: x[1]+b0[i-1], a1))\n        b0 = b1\n    #use the max time from b0 to find the expected time\n    b = list(map(lambda x: max(x), b0))\n    e_time = list(map(lambda x, y: x+y, b, b[1:]))\n    \n    #output\n    return str(sum(e_time))\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = [int(i) for i in stdin.split()]\n    lst = []\n    for _ in range(m):\n        t, p, d = [float(i) for i in stdin.split()]\n        lst.append((t, p, d))\n    lst.sort()\n    t, p, d = lst[0]\n    print(t * p * r + (n - t) * d)\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    n, r, m = tuple(map(int, stdin.split(' ')))\n    return '%.6f' % ((m * (r + (m - 1) * n)) / m)"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine the expected time to set the record for a game.\n\n    Args:\n        stdin (str): input data\n\n    Returns:\n        str: the expected time to set a record\n    \"\"\"\n    n, r, m = [int(x) for x in stdin.split()]\n    t, p, d = [], [], []\n    for _ in range(m):\n        t_, p_, d_ = [float(x) for x in stdin.split()]\n        t.append(t_)\n        p.append(p_)\n        d.append(d_)\n\n    # Probability for each possible number of failed tricks\n    failed = [1 - p ** i for i in range(n)]\n\n    # Keep track of the expected time at the end of each trick\n    totals = [0]\n\n    # Use the fact that we know we have to reach the record in less than r seconds\n    for i in range(n):\n        totals.append(totals[-1] + d[i] * p[i])\n\n    # The expected time to set a new record is the sum of the expected time for\n    # each trick, minus the expected time needed to reset the game\n    # By working backwards from the last trick\n    return sum(\n        [totals[i] * failed[i] for i in range(n - 1, n - r - 1, -1)]\n    ) - sum(\n        [totals[i] * failed[i] for i in range(n - 1, n - r, -1)]\n    )\n\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution of the challenge:\n    \"\"\"\n    # get the input\n    n, r, m = stdin.split(' ')\n    n, r, m = int(n), int(r), int(m)\n    tricks = []\n    for i in range(m):\n        t, p, d = stdin.split(' ')\n        tricks.append((int(t), float(p), int(d)))\n    tricks.sort()\n    # create graph and start calculations\n    g = Graph()\n    for t in range(n):\n        p = tricks[t][1]\n        d = tricks[t][2]\n        g.add_edge(t, t + 1, p, d)\n        g.add_edge(0, t, 1, 0)\n    # create a priority queue and start the path calculations\n    queue = PriorityQueue()\n    queue.push(g.nodes[0], 0)\n    visited = {0: 0}\n    while not queue.empty():\n        current_node = queue.pop()\n        if current_node.nbrs:\n            for nbr in current_node.nbrs:\n                queue.push(nbr, visited[current_node] + current_node.nbrs[nbr])\n                visited[nbr] = visited[current_node] + current_node.nbrs[nbr]\n    return str(visited[g.nodes[-1]])\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"You have a record of $r$ seconds, which you intend to beat. You have discovered a path through the game that, in the best case, takes $n < r$ seconds. There are some tricks along the way, though: you know exactly where along the run they occur, what the probability is that you will pull them off successfully, and how many seconds you have to spend to recover if they fail.\n\nGiven this data, you want to find the optimal strategy for when to reset the game to minimise the expected time to set a new record. Write a program to determine what this smallest possible expected time is.\n\n-----Input-----\nThe input consists of:\n - One line with three integers $n$, $r$ and $m$ ($2 \\leq n < r \\leq 5000$, $1 \\le m \\le 50$), where $n$ and $r$ are as described above and $m$ is the number of tricks.\n - $m$ lines, each containing three numbers describing a trick:\n - An integer $t$ ($1 \\le t < n$), the time in the route (assuming no failed tricks before) at which the trick occurs,\n - a real number $p$ ($0 < p < 1$ and $p$ has at most $6$ digits after the decimal point), the probability that the trick succeeds, and\n - an integer $d$ ($1 \\le d \\le 1000$), the number of seconds required to recover in case the trick fails.\n\nThe tricks are given in sorted order by $t$, and no two tricks occur at the same time $t$ in the route.\n\nYou may assume that, without resetting, a single playthrough has a probability of at least $1$ in $50000$ to succeed at improving the record.\n\n-----Output-----\nOutput the expected time you will have to play the game to set a new record, assuming an optimal strategy is used. Your answer should have an absolute or relative error of at most $10^{-6}$.\n\nExplanation of Sample Input 1\n\nThe record for this game is $111$ seconds, and your route takes $100$ seconds if everything goes right.\n\nAfter playing for $20$ seconds, there is a trick with a $50\\% $ success rate. If it succeeds, you keep playing. If it fails, you incur a $10$ second time loss: now the run will take at least $110$ seconds. It is still possible to set a record, but every other trick in the run has to be successful. It turns out to be faster on average to reset after failing the first trick.\n\nThus you repeat the first $20$ seconds of the game until the trick is successful: with probability $1/2$, it takes $1$ attempt; with probability $1/4$, it takes $2$ attempts; and so on. On average, you spend $40$ seconds on the first $20$ seconds of the route.\n\nOnce you have successfully performed the first trick, you want to finish the run no matter the result of the other tricks: it takes $80$ seconds, plus on average $1$ second loss from each of the remaining $4$ tricks. So the expected time until you set a record is $124$ seconds.\n\n-----Examples-----\nSample Input 1:\n100 111 5\n20 0.5 10\n80 0.5 2\n85 0.5 2\n90 0.5 2\n95 0.5 2\nSample Output 1:\n124\n\nSample Input 2:\n2 4 1\n1 0.5 5\nSample Output 2:\n3\n\nSample Input 3:\n10 20 3\n5 0.3 8\n6 0.8 3\n8 0.9 3\nSample Output 3:\n18.9029850746\n\"\"\"\n    n, r, m = [int(x) for x in stdin.split()]\n    tricks = []\n    for _ in range(m):\n        t, p, d = [int(x) for x in stdin.split()]\n        tricks.append(\n            (t, d, p)\n        )\n    tricks = sorted(tricks, key=lambda x: x[0])\n    time = 0\n    for t, d, p in tricks:\n        if t >= r:\n            break\n        time += t * (1 - p)\n        time += d\n    if t < r:\n        time += (r - t) * (1 - p)\n        time += d\n    return time\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    p = [list(map(float, input().split())) for _ in range(m)]\n    t = [p[i][0] for i in range(m)]\n    p = [p[i][1] for i in range(m)]\n    d = [p[i] * n for i in range(m)]\n    ans = 0.0\n    for i in range(m):\n        exp = r / t[i]\n        thresh = t[i] / p[i]\n        if r < t[i]:\n            exp = r / t[i]\n        else:\n            ans += d[i] / t[i]\n            exp = t[i]\n            thresh = t[i] / p[i]\n        c = 1.0\n        for j in range(1, r):\n            c += 1.0 / thresh\n            if j >= exp:\n                ans += d[i] / (r - j) / thresh\n                break\n        ans += d[i] / exp\n    return str(ans)\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # get n, r, m\n    n, r, m = [int(x) for x in stdin.split(' ')]\n\n    # get m tricks\n    tricks = []\n    for _ in range(m):\n        t, p, d = [float(x) for x in stdin.split(' ')]\n        tricks.append((t, p, d))\n\n    # calculate the probability of winning in 50000 plays\n    threshold = 1e-6\n    p_satisfied = 1\n    for t, p, d in tricks:\n        p_satisfied *= (1 - p) ** (t - 1)\n\n    # get the expected time in 50000 plays\n    exp_time = 0\n    for t, p, d in tricks:\n        exp_time += t * p * (1 - p_satisfied)\n    exp_time /= (1 - p_satisfied)\n    exp_time += r * p_satisfied\n    exp_time += n * p_satisfied\n\n    # return the expected time\n    return \"{:.6f}\".format(exp_time)\n"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return str, the expected time to set a new record.\"\"\"\n    # Read in the number of games, the record, the number of tricks,\n    # and the tricks, and store in variables\n    num_games, record, num_tricks = map(int, stdin.split())\n    tricks = [tuple(map(float, stdin.split()[2:5])) for _ in range(num_tricks)]\n    # Sort the tricks by time and store the result\n    tricks = sorted(tricks, key=lambda x: x[0])\n    # Initialise the cumulative time spent playing the game and the maximum time possible to play the game\n    cumulative_time_spent = 0\n    max_time_possible = record\n    # For every trick\n    for trick in tricks:\n        # Add the time spent playing the game up to the trick to the cumulative time spent playing the game\n        cumulative_time_spent += trick[1] * trick[2]\n        # If the cumulative time spent playing the game is bigger than the current record, set a new record\n        if cumulative_time_spent > max_time_possible:\n            max_time_possible = cumulative_time_spent\n        # If the cumulative time spent playing the game is not bigger than the current record,\n        # reduce the cumulative time spent playing the game by the time lost playing the trick\n        elif cumulative_time_spent > record:\n            cumulative_time_spent -= trick[1] * trick[2]\n    # Return the maximum possible time spent playing the game\n    return str(max_time_possible)\n\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = list(map(int, stdin.split()))\n    tricks = [list(map(int, stdin.split())) for _ in range(m)]\n    tricks.sort()\n    dp = [0] * (n + 1)\n    dp[1] = tricks[0][1]\n    for i in range(2, n + 1):\n        p = tricks[i - 1][1]\n        t = tricks[i - 1][0]\n        dp[i] = dp[i - 1] + (dp[i - t] + p - dp[i - 1] * r) // r\n    return \"{:.6f}\".format(dp[-1])\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the kth sequence on Gwen's list\n    >>> solution('4 3\\n2 1 2')\n    '2 1 2'\n    >>> solution('2 1\\n1')\n    '1'\n    >>> solution('5 22\\n4 3 4 2')\n    '4 3 4 2'\n    \"\"\"\n    n, k = map(int, stdin.split())\n    return''.join(\n        str(i)\n        for i in range(1, n - 1)\n        if sum(j for j in range(i, n, i)) <= k\n    )\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = n-1\n    k -= 1\n    while k > 0:\n        k -= 1\n        s += 1\n        while s > 0 and (s//n) == (n*(s//n) + 1)//2:\n            k -= 1\n            s -= 1\n    k += 1\n    s += 1\n    return \" \".join(map(str, range(k, n*(s+1), n)))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    num_of_n, index = map(int, stdin.split())\n    max_num = num_of_n - 1\n    nums = [i for i in range(1, num_of_n + 1)]\n    print(nums)\n    # 2\ubc88\uc9f8\uc640 \ub450\ubc88\uc9f8 \uacbd\uc6b0\uc758 \uc218\ub97c \uc81c\uc678\ud55c \ub098\uba38\uc9c0 \uc21c\uc11c\ub97c \ucc3e\uc74c\n    nums.sort()\n    print(nums)\n    print(nums[:2] + nums[3:])\n\n    for i in range(len(nums)):\n        nums[i] = (i + 1) * num_of_n - nums[i]\n\n    print(nums)\n    nums.sort()\n    print(nums)\n    return nums[index - 1]\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the kth sequence on Gwen's list.\"\"\"\n    lines = stdin.strip().split('\\n')\n    n, k = [int(x) for x in lines[0].split()]\n    k = k - 1\n    print(k)\n\n    return ''"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the k-th sequence on Gwen's list.\"\"\"\n    hated_num, num_seq = map(int, stdin.split())\n    max_seq = max(num_seq)\n    return''.join([str(max_seq - num % max_seq) for num in range(hated_num, max_seq + max_seq) if num % hated_num!= 0])\n\nprint(solution(input()))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the kth sequence on Gwen's list\n    \"\"\"\n    stdin = stdin.split()\n    n = int(stdin[0])\n    k = int(stdin[1])\n    assert k <= 10**18\n\n    # make the list of all possible sequences\n    # each entry in the list is a list of the possible\n    # sequences for a given number of petals\n    possible_sequences = [[] for i in range(n)]\n    possible_sequences[0] = [0]\n    for i in range(1, n):\n        for j in range(0, i):\n            possible_sequences[i].extend(\n                [j, j + 1]\n            )\n        possible_sequences[i].sort()\n    # the list of possible sequences for a given number of petals\n    # is stored in a map, so we can get the sequence for a given\n    # number of petals in constant time\n    possible_sequences = {possible_sequence: i for i, possible_sequence in enumerate(possible_sequences)}\n    # the sequence for the number of petals\n    # that we are looking for is the lexicographically\n    # smallest entry in the list\n    sequence_for_k = possible_sequences[sorted(possible_sequences.keys())[k-1]]\n    # return the solution as a string\n    return''.join([str(x) for x in list(range(sequence_for_k, sequence_for_k + (n - 1)))] + [str(sequence_for_k + (n - 1))])\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the index-th sequence on Gwen's list.\n\n    Args:\n        stdin (str): Input from stdin.\n\n    Returns:\n        str: The sequence on Gwen's list.\n    \"\"\"\n    n, k = map(int, stdin.split(' '))\n    result = None\n    for i in range(1, n):\n        if not (n % i):\n            result = i, (n // i) - 1, (n // i) + 1\n            break\n    if result is not None:\n        return''.join(map(str, result))\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the kth sequence on Gwen\u2019s list.\n\n    Args:\n        stdin (str): input of the form '4 3' or '2 1'\n\n    Returns:\n        str: The kth sequence on Gwen\u2019s list.\n    \"\"\"\n    # get the number of flowers\n    numFlowers, k = [int(x) for x in stdin.split()]\n    k -= 1\n    l = []\n    # set up the array of flowers\n    for i in range(numFlowers):\n        l.append(i+1)\n    # loop through all the flowers\n    for i in range(numFlowers - 1):\n        # loop through all the flowers after the current one\n        for j in range(i + 1, numFlowers):\n            # if the current flower has a greater value than the next one, swap them\n            if l[i] > l[j]:\n                l[i], l[j] = l[j], l[i]\n    # print out the value of the final flower\n    print(' '.join([str(x) for x in l]))\n    return ''\n"
    },
    {
        "number": 3060,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    all_sequences = get_all_sequences(n)\n    return str(all_sequences[k-1])\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n\n    def lcm(a, b):\n        return int((a * b) / gcd(a, b))\n\n    n, m = map(int, stdin.split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n\n    roads = list(sorted(set(roads)))\n    station = set(map(int, stdin.readline().split()))\n    station = list(station)\n    station = sorted(station)\n    if n == len(station):\n        return '0\\n'\n\n    roads_revised = []\n    for road in roads:\n        if road[0] in station:\n            roads_revised.append(road)\n    roads_revised = sorted(set(roads_revised), key=lambda x: x[1])\n    roads_revised = list(roads_revised)\n    num_roads = len(roads_revised)\n    station_sorted = sorted(station)\n    for index in range(num_roads):\n        road = roads_revised[index]\n        if road[0] in station_sorted:\n            station_sorted.remove(road[0])\n        if road[1] in station_sorted:\n            station_sorted.remove(road[1])\n        if road[0] in station_sorted and road[1] in station_sorted:\n            station_sorted.remove(road[1])\n\n    if len(station_sorted) > 0:\n        return str(lcm(station_sorted[0], station_sorted[1]))\n\n    return '0\\n'\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split(' '))\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, stdin.split('\\n')[i + 1].split(' '))\n        graph[u - 1].append(v - 1)\n    dp = [[0] * n for _ in range(1 << n)]\n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if mask & (1 << i) == 0:\n                continue\n            for j in graph[i]:\n                dp[mask][j] = 1\n    for i in range(n):\n        dp[-1][i] = 1\n    for mask in range(1 << n):\n        dp[mask][-1] = 1\n    # print(dp)\n    dp[-1][-1] = 0\n    # print(dp)\n    ans = 0\n    for mask in range(1 << n):\n        # print(mask, dp[mask])\n        for i in range(n):\n            if mask & (1 << i) == 0:\n                continue\n            ans = max(ans, dp[mask][i] + dp[~mask][i])\n    return ans\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n^3) time, O(n^2) space\"\"\"\n    n, m = map(int, stdin.split())\n    graph = {i: [] for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def get_length(graph: dict, start: int, dest: int) -> int:\n        visited = {start}\n        length = 0\n        queue = deque([(start, length)])\n        while queue:\n            vertex, length = queue.popleft()\n            if vertex == dest:\n                return length\n            for child in graph[vertex]:\n                if child not in visited:\n                    visited.add(child)\n                    queue.append((child, length + 1))\n        return length\n\n    max_length = 0\n    for vertex in graph:\n        for child in graph[vertex]:\n            length = get_length(graph, vertex, child)\n            if length > max_length:\n                max_length = length\n    return max_length\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum length path that competitors can take if at most one of the roads is blocked off.\"\"\"\n    pass\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    \ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum length path that a winning racer would take,\n    if there is at most one road that is blocked off. This is\n    a combinatorial problem, so the time complexity is\n    O(N^2 * M^2) where N and M are the number of stations\n    and roads respectively.\n    \"\"\"\n    # Parse input\n    n, m = map(int, stdin.split())\n    stations = set()\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        stations.add(u)\n        stations.add(v)\n        edges.append((u, v))\n    # Calculate the length of the optimal paths\n    lengths = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) in edges:\n                continue\n            lengths.append(calculate_optimal_length(stations, i, j))\n    # Calculate the minimum length of the paths that would have to be\n    # changed if any road was blocked off.\n    minimum_length = 10 ** 10\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) in edges:\n                continue\n            if lengths[i - 1] + lengths[j] < minimum_length:\n                minimum_length = lengths[i - 1] + lengths[j]\n    return str(minimum_length)\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(num) for num in stdin.split(' ')]\n    roads = [[int(num) for num in stdin.split(' ')] for _ in range(m)]\n    stations = [i for i in range(1, n+1)]\n    adj = [[] for _ in range(n+1)]\n    for road in roads:\n        adj[road[0]].append(road[1])\n        adj[road[1]].append(road[0])\n    visited = [False] * (n+1)\n    stack = []\n    ans = 0\n    for station in stations:\n        if visited[station]:\n            continue\n        visited[station] = True\n        stack.append((station, 0))\n        while stack:\n            cur_station, cur_path_len = stack.pop()\n            for i in adj[cur_station]:\n                if visited[i]:\n                    continue\n                visited[i] = True\n                stack.append((i, cur_path_len+1))\n                if cur_path_len > ans:\n                    ans = cur_path_len\n    return ans\n\n\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    ...\n"
    },
    {
        "number": 3061,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the minimum amount of time (in seconds) it would take get the hovercraft from $(00)$ to $(xy)$ subject to the constraints.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    x, y = [int(i) for i in stdin.split()]\n    v, w = [float(i) for i in stdin.split()]\n    return '%.3f' % (abs(x) + abs(y) / v + abs(w) / v * abs(x) / v)"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum amount of time it would take the vehicle to travel from location (00) to location (xy)\n    while subject to the constraints.\n\n    :param stdin: A string of input.\n    :return: The minimum amount of time it would take the vehicle to travel from location (00) to location (xy)\n    while subject to the constraints.\n    \"\"\"\n    x, y = tuple(map(int, stdin.split()))\n    v, w = tuple(map(float, stdin.split()))\n\n    return abs((y - x) / v) + abs((x + y) / v) + abs(x * w) / v\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    v, w = map(float, stdin.split())\n    return \"%.3f\" % ((abs(x) + abs(y)) / v + (x * w - y * w) / v)"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    x, y = map(int, stdin.split())\n    v, w = map(float, stdin.split())\n\n    return x\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = [float(i) for i in stdin.split()]\n    return \"{:.10f}\".format(abs((x ** 2 + y ** 2) ** 0.5 * ((2 * v * abs(x) + 2 * w * abs(y)) / (v + w)) + abs(x) + abs(y)))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split(\" \"))\n    return str(round(abs(y / w - x / v) * (w * w / (2 * v * v)), 3))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    :param stdin: input string\n    :return: output string\n    '''\n    # Remove pass and write your code here\n    pass\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y = list(map(int, stdin.split('\\n')[0].split(' ')))\n    v, w = list(map(float, stdin.split('\\n')[1].split(' ')))\n    \n    return str(round(v ** 2 / (2 * w * abs(x - y)), 3))"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.readlines()\n    x, y = map(int, line[0].split())\n    v, w = map(float, line[1].split())\n    return str(round(x ** 2 + y ** 2 * (v ** 2 + w ** 2), 3))\n"
    },
    {
        "number": 3062,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = [float(f) for f in stdin.split(\"\\n\")[0].split(\" \")]\n    return \"{:.3f}\".format(2 * (abs(x) + abs(y)) / (v + w))\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum amount of money the town has to give to its inhabitants so that after the payback protocol described above all debts are payed.\n\n    Args:\n        stdin (str): input data\n\n    Returns:\n        str: output data\n    \"\"\"\n    return str(solve(stdin))[:-1]\n\n\ndef"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    b = list()\n    for i in range(0, n):\n        t = tuple(map(int, stdin.readline().strip().split()))\n        b.append(t)\n\n    b.sort(key=lambda x: x[1], reverse=True)\n\n    total = 0\n    while b:\n        current = b.pop()\n        total += current[0]\n        for i in range(0, len(b)):\n            if b[i][1] >= current[1]:\n                b[i] = (b[i][0], b[i][1] - current[1])\n    return total\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns minimum total amount of money the town has to give to its inhabitants so all debts are payed\n    \"\"\"\n    stdin = stdin.split()\n    n = int(stdin[0])\n    debts = []\n    for _ in range(n):\n        debts.append(tuple(map(int, stdin[_].split())))\n    debts.sort()\n    min_amount = debts[0][1]\n    for i in range(1, len(debts)):\n        min_amount = min(min_amount, debts[i][1] + debts[i][0] * min_amount)\n    return min_amount\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    n = int(stdin)\n    if n < 2:\n        return 0\n    primes = set()\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime(i):\n            primes.add(i)\n            primes.add(n // i)\n    # print(primes)\n    # print(n, int(n ** 0.5))\n    # print(n ** 0.5)\n    # print(int(n ** 0.5))\n    # print(primes)\n    # print(gcd(2, 3))\n    # print(is_prime(2))\n    return sum(primes)\n\n\ndef"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    res = 0\n    li = [int(i) for i in stdin.readline().split(' ')]\n    debt = [int(i) for i in stdin.readline().split(' ')]\n    while debt:\n        person = debt.index(max(debt)) + 1\n        max_debt = max(debt)\n        debt[person - 1] = 0\n        res += max_debt\n        for j in range(person + 1, n + 1):\n            debt[j - 1] = max(debt[j - 1] - max_debt, 0)\n    return str(res)"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    def read_line():\n        return stdin.readline().strip().split()\n\n    n = int(read_line()[0])\n    people = [0] * n\n    for i in range(n):\n        people[i] = (int(read_line()[0]), int(read_line()[1]))\n    people.sort(key = lambda person: person[0])\n\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if people[j][0] > people[i][0]:\n                dp[i] = max(dp[i], dp[j] + people[i][1])\n    return str(max(dp))"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    stdin = stdin.splitlines()\n    n, s = int(stdin[0]), 0\n    for i in range(1, n+1):\n        a, b = int(stdin[i].split()[0]), int(stdin[i].split()[1])\n        if a <= n and b <= 10000:\n            s += b\n    return str(s)\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = [[0, int(i)] for i in stdin.readline().split()]\n    b = [[int(i), 0] for i in stdin.readline().split()]\n    for i in range(n):\n        for j in range(n):\n            b[j][0] = min(b[j][0], a[i][1] + b[j][1])\n            b[j][1] = max(b[j][1], a[i][0] + b[j][0])\n    return str(max(i[0] for i in b))\n"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    people_count = int(stdin[0])\n    debts = {int(x) for x in stdin[1:]}\n    debts_to_check = set()\n\n    for debt in debts:\n        debts_to_check.add(debt)\n        debts_to_check.add(people_count - debt)\n\n    min_total = 0\n    visited = set()\n    visited.add(1)\n    to_check = list(debts_to_check)\n\n    while to_check:\n        current_debt = to_check[0]\n        visited.add(current_debt)\n\n        # Add debts to check\n        for person in debts:\n            if person in visited:\n                continue\n\n            if person < current_debt:\n                to_check.append(person)\n\n        if not to_check:\n            break\n\n        while True:\n            result = to_check.pop(0)\n            if result in visited:\n                continue\n\n            if result > current_debt:\n                break\n            else:\n                min_total += result\n                to_check.append(result)\n                visited.add(result)\n\n    return min_total\n\n\ndef"
    },
    {
        "number": 3063,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    n = int(stdin)\n    l = []\n    for _ in range(n):\n        l.append(list(map(int, stdin.split())))\n    \n    def get_sum_debt(debt, total):\n        total = 0\n        while debt:\n            total += debt.pop(0)\n        return total\n    \n    debt = []\n    for i in range(n):\n        debt.append([])\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                debt[i].append(l[j][i])\n    ans = []\n    for i in range(n):\n        ans.append(get_sum_debt(debt[i], 0))\n    print(min(ans))\n    return \"\"\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    dist = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]\n    for _ in range(m):\n        a, b, d = map(int, stdin.readline().split())\n        dist[a][b] = d\n        dist[b][a] = d\n\n    visited = [float('inf') for _ in range(n+1)]\n    max_path = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if dist[i][j]!= float('inf') and dist[i][j]!= 0:\n                visited[i] = min(visited[i], dist[i][j])\n        max_path = max(max_path, max(visited))\n    return max_path\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the longest possible race path\n    \"\"\"\n    def get_disjoint_sets(n: int, e: int) -> List[set]:\n        \"\"\"\n        Returns disjoint sets of n cities using e roads\n        \"\"\"\n        disjoint_sets = [{city} for city in range(1, n+1)]\n        for road in e:\n            city_a, city_b = road\n            disjoint_sets[city_a-1].add(city_b)\n            disjoint_sets[city_b-1].add(city_a)\n        return disjoint_sets\n\n    def get_cycle(n: int, e: int) -> set:\n        \"\"\"\n        Returns the cycle of n cities using e roads\n        \"\"\"\n        disjoint_sets = get_disjoint_sets(n, e)\n        cycle = set()\n        for city_a, disjoint_set in enumerate(disjoint_sets):\n            for city_b in disjoint_set:\n                if city_b == city_a:\n                    cycle.add(city_b)\n        return cycle\n\n    def get_rings(n: int, cycle: set, e: int) -> int:\n        \"\"\"\n        Returns the number of rings of n cities using e roads\n        \"\"\"\n        ring_count = 0\n        for city_a in cycle:\n            for city_b in cycle:\n                if city_b in e and city_a in e[city_b]:\n                    ring_count += 1\n        return ring_count\n\n    def get_longest_path(n: int, cycle: set, e: int) -> int:\n        \"\"\"\n        Returns the longest path of n cities using e roads\n        \"\"\"\n        disjoint_sets = get_disjoint_sets(n, e)\n        cycle_count = len(cycle)\n        longest_path = 0\n        for city_a in cycle:\n            city_b = disjoint_sets[city_a-1].pop()\n            for city_b_prime in disjoint_sets[city_b-1]:\n                if city_b_prime in cycle:\n                    ring_count = get_rings(n, cycle, e)\n                    if ring_count == cycle_count - 1:\n                        longest_path = max(longest_path, (cycle_count + 1) // 2)\n        return longest_path\n\n    n, m = map(int, stdin.readline().split())\n    cycle = get_cycle(n, {(city_a, city_b) for city_a, city_b in [stdin.readline().split() for _ in range(m)]})\n    return get_longest_path(n, cycle, {(city_a, city_b) for city_a, city_b in [stdin.readline().split() for _ in range(m)]})\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return \"\"\n\"\"\"\nimport sys\n\nsys.setrecursionlimit(100000)\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m = map(int, stdin.split())\n    routes = [set() for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        routes[a - 1].add(b)\n        routes[b - 1].add(a)\n    routes = [list(route) for route in routes]\n    print(routes)\n    \n    def _dfs(city: int, path: List[int]) -> int:\n        if city == 1:\n            return len(path)\n        if len(path) > n - 1:\n            return 0\n        for next_city in routes[city - 1]:\n            if next_city in path:\n                continue\n            result = _dfs(next_city, path + [next_city])\n            if result > 0:\n                return result\n        return 0\n    \n    return max(_dfs(city, [city]) for city in range(1, n + 1))\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque, defaultdict\n\n    N, M = map(int, stdin.split())\n\n    edges = defaultdict(set)\n\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        edges[a].add(b)\n        edges[b].add(a)\n\n    def find_longest_path(start_node: int, visited: set) -> int:\n        queue = deque([(start_node, 1)])\n        visited.add(start_node)\n\n        longest_path = 0\n\n        while queue:\n            node, length = queue.popleft()\n            longest_path = max(longest_path, length)\n\n            for next_node in edges[node]:\n                if next_node not in visited:\n                    queue.append((next_node, length + 1))\n                    visited.add(next_node)\n\n        return longest_path\n\n    longest_path = 0\n\n    for node in range(1, N + 1):\n        path_length = find_longest_path(node, set())\n        longest_path = max(longest_path, path_length)\n\n    return longest_path"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    roads = {tuple(int(x) for x in stdin.split('\\n')[i].split(' ')): i for i in range(m)}\n    d = {0: 1}\n    previous = {1: 0}\n    for i in range(1, n + 1):\n        d[i] = d[i - 1]\n        previous[i] = 0\n    for i in range(m):\n        for j in roads[tuple(roads[i])]:\n            if i not in roads:\n                break\n            if j in roads:\n                d[j] = max(d[j], d[i] + 1)\n                previous[j] = max(previous[j], d[i])\n    return d[n]\nprint(solution(input()))\n"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3064,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the length of the longest race path on a single line\"\"\"\n    pass\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict, deque\n    from heapq import heappop, heappush\n    from math import factorial\n\n    N, L = map(int, stdin.readline().split())\n    n = list(map(int, stdin.readline().split()))\n    rooms = defaultdict(list)\n    for i, n_i in enumerate(n):\n        rooms[n_i].append(i)\n    visited = set()\n    visited.add(0)\n    q = deque([(0, n[0])])\n    chances = defaultdict(int)\n    while q:\n        i, p = q.popleft()\n        chances[i] += 1\n        for n_i in rooms[p]:\n            if n_i in visited:\n                continue\n            chances[i] += 1\n            visited.add(n_i)\n            q.append((i + 1, n_i))\n    ans = 1\n    for i in range(L):\n        ans *= chances[i] / factorial(L)\n    ans *= 2 / factorial(L)\n    return str(ans)\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Get the input.\n    \"\"\"\n    inputs = [i.split('\\n') for i in stdin.split('\\n\\n')]\n    \n    \"\"\"\n    Get the total number of nodes and the number of nodes the captain has to visit.\n    \"\"\"\n    nodes = inputs[0][0]\n    nodes = int(nodes)\n    \n    \"\"\"\n    Get the captain\u2019s walk.\n    \"\"\"\n    captain_walk = inputs[2][0].split(' ')\n    captain_walk = [int(x) for x in captain_walk]\n    \n    \"\"\"\n    Get the neighbours of each node.\n    \"\"\"\n    neighbours = inputs[3]\n    neighbours = [[int(x) for x in line.split(' ')] for line in neighbours]\n    \n    \"\"\"\n    Get the sentry.\n    \"\"\"\n    sentry = inputs[4][0]\n    sentry = int(sentry)\n    \n    \"\"\"\n    Get the output.\n    \"\"\"\n    output = inputs[5][0]\n    \n    \"\"\"\n    Get the output.\n    \"\"\"\n    stdout = 0\n    \n    \"\"\"\n    Possible values for room:\n    [0, 1, 2, 3, 4, 5, 6, 7]\n    \"\"\"\n    rooms = [0, 1, 2, 3, 4, 5, 6, 7]\n    \n    \"\"\"\n    The value of the sentry is unknown, so we need to consider both options:\n    1. The sentry is in the room the captain is beamed in.\n    2. The sentry is in another room.\n    \"\"\"\n    for room in rooms:\n        \n        \"\"\"\n        The sentry is in the room the captain is beamed in.\n        \"\"\"\n        if sentry == room:\n            stdout = 1 / 6\n            \n        \"\"\"\n        The sentry is in another room.\n        \"\"\"\n        else:\n            \"\"\"\n            Get the number of neighbours of the room.\n            \"\"\"\n            n = len(neighbours[room])\n            \n            \"\"\"\n            Get the captain\u2019s probability of landing in each room.\n            \"\"\"\n            prob = [0] * n\n            for i in range(n):\n                prob[i] = neighbours[room][i] / n\n            \n            \"\"\"\n            Get the room the captain has to be in.\n            \"\"\"\n            captain_room = captain_walk.index(room)\n            \n            \"\"\"\n            Get the probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob[captain_room]\n            \n            \"\"\"\n            Get the probability of landing in another room.\n            \"\"\"\n            prob_out = 1 - prob_in\n            \n            \"\"\"\n            Get the probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in\n            \n            \"\"\"\n            Get the probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Get the probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Get the probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of landing in another room.\n            \"\"\"\n            prob_out = prob_out * prob_out\n            \n            \"\"\"\n            Probability of landing in the room the captain is to be in.\n            \"\"\"\n            prob_in = prob_in * prob_in\n            \n            \"\"\"\n            Probability of"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    L = int(stdin.readline())\n    rooms = {int(stdin.readline()): set(map(int, stdin.readline().split())) for i in range(L)}\n    P = int(stdin.readline())\n    path = {int(stdin.readline()): set(map(int, stdin.readline().split())) for i in range(P)}\n    dist = {0: 0}\n    for i in range(1, N + 1):\n        dist[i] = float('inf')\n    def dfs(node):\n        if node not in path:\n            return 0\n        for neighbour in rooms[node]:\n            if neighbour not in path:\n                continue\n            dist[neighbour] = min(dist[neighbour], dist[node] + 1)\n            dfs(neighbour)\n    dfs(1)\n    return f'{dist[1] / P * 1e6:.6f}'"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Given a random walk, calculates the chance that the captain will not\n    be discovered by the sentry.\n    \"\"\"\n    # Map of room to a list of neighbours, where the list is ordered\n    # by distance from the target room.\n    room_map = defaultdict(list)\n\n    # Read the number of rooms to visit.\n    num_rooms = int(stdin.readline())\n\n    # Read the map.\n    for i in range(num_rooms):\n        line = stdin.readline()\n        source, *targets = map(int, line.split())\n        room_map[source] = list(targets)\n\n    # Read the walk.\n    walk = list(map(int, stdin.readline().split()))\n\n    # Read the number of sentries.\n    num_sentry = int(stdin.readline())\n\n    # Read the sentries.\n    for i in range(num_sentry):\n        line = stdin.readline()\n        room_a, room_b = map(int, line.split())\n        path = [room_a] + room_map[room_b]\n        # Calculate the distance between the sentries.\n        path_distance = 0\n        for j in range(1, len(path)):\n            path_distance += path[j] - path[j - 1]\n        # The sentries can swap room only if they move at the same time.\n        if path_distance % 2!= 0:\n            return '0.0'\n\n        # Calculate the chance the sentries will be discovered.\n        for i in range(len(path)):\n            room_map[path[i]].remove(path[(i + 1) % len(path)])\n            room_map[path[(i + 1) % len(path)]].append(path[i])\n\n    # Calculate the chance that the captain will not be discovered.\n    total = 0\n    for room in room_map:\n        # Calculate the number of neighbours that are not room b.\n        num_neighbours = len(room_map[room])\n        for neighbour in room_map[room]:\n            if neighbour == room_b:\n                num_neighbours -= 1\n        total += 2 ** (num_neighbours)\n    return f'{total / (4 ** num_rooms):.6f}'\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def perm(iterable, r):\n        # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC\n        # permutations(range(3), 3) --> 012 021 102 120 201 210\n        pool = tuple(iterable)\n        n = len(pool)\n        if r > n:\n            return\n        indices = list(range(n))\n        cycles = list(range(n, n - r, -1))\n        yield tuple(pool[i] for i in indices[:r])\n        while n:\n            for i in reversed(range(r)):\n                cycles[i] -= 1\n                if cycles[i] == 0:\n                    indices[i:] = indices[i + 1:] + indices[i:i + 1]\n                    cycles[i] = n - i\n                else:\n                    j = cycles[i]\n                    indices[i], indices[-j] = indices[-j], indices[i]\n                    yield tuple(pool[i] for i in indices[:r])\n                    break\n            else:\n                return\n\n    def func(num_nodes, num_rooms, num_passengers, num_paths, num_neighbours):\n        max_passenger_per_room = num_passengers // num_rooms\n\n        rooms = [0] * num_rooms\n\n        passengers = [0] * num_passengers\n        passenger_in_room = [0] * num_rooms\n\n        for i, j in zip(passengers, passenger_in_room):\n            rooms[j] += i\n            passenger_in_room[j] += 1\n\n        for i, j in zip(passengers, passenger_in_room):\n            passenger_in_room[j] -= 1\n\n        all_passengers_in_room = [0] * num_rooms\n        for i in passenger_in_room:\n            all_passengers_in_room[i] += 1\n\n        passengers_to_be_picked = 0\n        picked = set()\n        for i, j in zip(passengers, passenger_in_room):\n            if j < max_passenger_per_room:\n                passengers_to_be_picked += 1\n                picked.add(i)\n\n        if passengers_to_be_picked == 0:\n            return '0.0'\n\n        rooms_to_be_picked = 0\n        picked_rooms = set()\n        for i, j in zip(rooms, passenger_in_room):\n            if j < max_passenger_per_room:\n                rooms_to_be_picked += 1\n                picked_rooms.add(i)\n\n        if rooms_to_be_picked == 0:\n            return '0.0'\n\n        # perm = perm(list(range(num_passengers)), max_passenger_per_room)\n        perm = list(perm(list(range(num_passengers)), max_passenger_per_room))\n        possible_perm = []\n        for i in perm:\n            if set(i) - picked:\n                possible_perm.append(i)\n\n        possible_perm = sorted(possible_perm, key=lambda k: sum(k))\n\n        # print(passengers)\n        # print(passenger_in_room)\n        # print(all_passengers_in_room)\n        # print(picked)\n        # print(picked_rooms)\n        # print(possible_perm)\n\n        return str(sum(all_passengers_in_room[i] for i in picked_rooms) / rooms_to_be_picked / passengers_to_be_picked)\n\n    stdout = \"\"\n\n    n = int(stdin.split(\"\\n\")[0])\n    l = int(stdin.split(\"\\n\")[1])\n\n    rooms = []\n    for i in range(n):\n        rooms.append(stdin.split(\"\\n\")[2 + i].split(\" \"))\n\n    for i in range(l):\n        rooms[i].pop(0)\n\n    for i in range(l):\n        rooms[i] = list(int(j) for j in rooms[i])\n\n    stdout = str(func(n, l, l, rooms, stdin.split(\"\\n\")[2 + l:]))\n\n    return stdout\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution to the Star Trek problem for Day 3 Part B.\n\n    Args:\n        stdin (str): The input values a-b.\n\n    Returns:\n        str: The answer to the problem.\n    \"\"\"\n    # TODO: Write the solution to the problem.\n    return '0.0' # Replace this line with the actual solution."
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # exercise parameters\n    n, l = map(int, stdin.split('\\n')[:2])\n    # create node and room graph\n    nodes = [Node(i) for i in range(n)]\n    rooms = []\n    for _ in range(l):\n        neighbors = list(map(int, stdin.split('\\n')[_+2].split()))\n        rooms.append(Room(neighbors))\n    for node in nodes:\n        node.add_rooms(rooms)\n    # create sentry\n    sentry = Sentry(nodes)\n    # create captain\n    captain = Captain(nodes, sentry)\n    # calculate probability\n    captain.solve()\n    return str(round(captain.probability, 6))"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute the probability of success for the captain's journey\"\"\"\n    data = dict(tuple(map(int, line.strip().split())) for line in stdin.splitlines()[:3])\n    # The walk and the number of nodes\n    # The number of neighbours\n    # The neighbours\n    return str(combination_one(data[0], data[1], data[2]))\n\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\"\"\"\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = n//6\n    arr = list(map(int, stdin.split()))\n    if n%6!= 0:\n        return 'IMPOSSIBLE'\n    else:\n        print(k)\n        for i in range(1, k+1):\n            print(i, i+(n//6))\n            print(i+(n//6), k)\n            print(k, i)\n            print(' '.join(str(e) for e in [i, i+(n//6), k]))\n            print(' '.join(str(e) for e in [i+(n//6), k, i]))\n        return''.join(str(e) for e in [1, k+1, 1])"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return \"IMPOSSIBLE\"\n\nprint(solution(input()))\n\n----"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Your solution goes here. Feel free to edit it however you see fit.\n    '''\n    return ''"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    # Write your code here\n    return stdout\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the answer to the challenge\"\"\"\n    \n    return None\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Solution to the problem:\n    This problem is similar to the problem of \"Matching Numbers\"\n    but here, we don't want to get equal numbers,\n    we want to get all the possible ways to arrange the\n    tape, so we don't need to get equal numbers.\n\n    In this problem, we have to arrange all the tapes\n    by using the color one by one, we need to return a\n    string which has instructions of tape positioning.\n\n    Let's say we have total n number of numbers in the\n    tape, then there will be n+n-1 possible ways to arrange\n    the tape, each of which will give us a different result\n    as you can see by the output.\n\n    Therefore, we need to find out the minimum number of\n    instruction needed to arrange all the tapes so that\n    we get the desired output.\n\n    1. First, we need to divide all the numbers into n\n    equal partitions.\n\n    For example, if we have 7 numbers in the tape, then there\n    will be 6 partitions which are $1$ through $6$ and if we\n    put these in different instructions then we have 6 instructions\n    which will be $1$ through $6$ by $1$, $2$ through $6$ by $2$,\n    $3$ through $6$ by $3$, $4$ through $6$ by $4$, $5$ through\n    $6$ by $5$ and $6$ through $6$ by $6$ as the instructions\n    will be $1$, $2$, $3$, $4$, $5$, $6$, and $6$.\n\n    2. Now, for each of the partitions we have to check whether\n    a particular number from the partition is equal to the next\n    number or not. If it is equal to the next number then we will\n    add 1 instruction, but if it is not equal to the next number\n    then we will add 2 instructions.\n\n    For example, if the partition is $1$ through $5$ and the number\n    to be considered is $1$, then we will have to add 1 instruction\n    because $1$ is the first number of the partition.\n\n    Similarly, if the partition is $1$ through $6$ and the number\n    to be considered is $5$, then we will have to add 2 instructions\n    because $5$ is the 5th number of the partition and the next\n    number is $6$.\n    '''\n\n    # get the length of the tape\n    n = int(stdin.readline().rstrip())\n\n    # get the numbers\n    nums = list(map(int, stdin.readline().rstrip().split()))\n\n    # get the length of each partition\n    partition_len = sum(nums) // n\n\n    # get the answer\n    ans = ''\n\n    # loop through the numbers\n    for i, num in enumerate(nums):\n        # if the number is not equal to the next number\n        # then we can place the next number\n        if num!= nums[i + 1]:\n            ans += f'{num} {num + partition_len - 1} {nums[i + 1]}\\n'\n        # if the number is equal to the next number\n        # then we need to add one more instruction\n        else:\n            ans += f'{num} {num + partition_len - 1} {nums[i + 1]}\\n'\n            ans += f'{num + partition_len} {num + partition_len + partition_len - 1} {nums[i + 1]}\\n'\n\n    # check if there is a number\n    # which is equal to the next number\n    if nums[len(nums) - 1]!= nums[len(nums) - 2]:\n        ans += f'{nums[len(nums) - 1]} {nums[len(nums) - 1] + partition_len - 1} {nums[len(nums) - 2]}\\n'\n    # check if all the numbers are\n    # equal to the next number\n    elif nums[0]!= nums[1]:\n        ans += f'{nums[0]} {nums[0] + partition_len - 1} {nums[1]}\\n'\n    # if there is no number\n    # which is equal to the next number\n    else:\n        ans += 'IMPOSSIBLE\\n'\n\n    return ans\n"
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3066,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the instructions that reconstructs the tape art.\"\"\"\n    _, width = stdin.split()\n    width = int(width)\n    planks = [int(x) for x in stdin.split()]\n    # print(planks)\n    index_map = {}\n    for idx, num in enumerate(planks):\n        if num in index_map:\n            index_map[num].append(idx)\n        else:\n            index_map[num] = [idx]\n    # print(index_map)\n    # print(planks)\n    # First, check if we can ever copy the planks to complete the art.\n    # Copy planks if no overlap.\n    for key, value in index_map.items():\n        if len(value) > 1:\n            return \"IMPOSSIBLE\"\n\n    # Remove planks from index_map so that we can work with\n    # pieces of tape\n    for _ in range(width):\n        # Pop smallest key\n        key = min(index_map)\n        # print(key, index_map[key])\n        for i in range(len(index_map[key])):\n            # print(planks)\n            planks.pop(index_map[key][i] - i)\n            # print(planks)\n            # Remove from index_map\n            # print(index_map)\n            if len(index_map[key]) == 1:\n                index_map.pop(key, None)\n            else:\n                index_map[key].pop(i)\n            # print(index_map)\n        # print(planks)\n\n    # print(planks)\n    # print(index_map)\n    # print(key, index_map[key])\n    for i in range(len(planks)):\n        if key!= planks[i]:\n            return \"IMPOSSIBLE\"\n    return str(len(planks)) + \" \" + \" \".join([str(x) for x in planks])\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, N = [int(x) for x in stdin.split()]\n    L, N = [L] * N, [N] * N\n    curr_seq = list(range(1, L[0] + 1))\n    solution = curr_seq[::-1]\n    for i, l in enumerate(L[1:]):\n        solution.append(curr_seq[0])\n        curr_seq = curr_seq[1:] + [curr_seq[0]]\n        curr_seq.sort(key=lambda x: x % l)\n        solution.sort(key=lambda x: x % l)\n    return''.join(str(x) for x in solution)\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    N = int(stdin.readline())\n    solution = []\n\n    for i in range(N):\n        L = int(stdin.readline())\n        seq = list(map(int, stdin.readline().split()))\n        while seq:\n            if seq[0] < seq[-1]:\n                solution.append(seq[-1])\n                seq.pop()\n            else:\n                break\n    print(' '.join(map(str, solution)))\n    return ''\n\nprint(solution(str(input())))\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n    max_ = 0\n    max_index = 0\n    for i in range(len(s)):\n        s[i] = (s[i], i)\n    s.sort()\n    print(s)\n    for i in range(len(s)):\n        if s[i][0] < s[i - 1][0]:\n            max_index = s[i - 1][1]\n            max_ = s[i - 1][0]\n        print(max_, max_index)\n    return max_index\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    cases = int(stdin)\n    LIMIT = 10 ** 6\n    d = [0] * (LIMIT + 1)\n    for _ in range(cases):\n        n = int(stdin)\n        l = list(map(int, stdin.split()))\n        a = []\n        for i, v in enumerate(l):\n            a.append((v, i))\n        a.sort()\n        for i, (v, idx) in enumerate(a):\n            d[i] = d[i + 1] + v\n    return str(sum(d))\n\n\ndef"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    seqs = []\n    for i in stdin:\n        n = i.split()\n        seqs.append(n)\n    lens = list(map(lambda x: int(x[0]), seqs))\n    values = list(map(lambda x: list(map(lambda y: int(y), x[1:])), seqs))\n    length = lens[0]\n    value = values[0]\n    for i in range(1, len(seqs)):\n        length = min(length, lens[i])\n        value = list(map(lambda x, y: x + y, value, values[i]))\n    return \" \".join(str(x) for x in value[:length])\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(nums):\n        if not nums:\n            return nums\n        L = len(nums)\n        if L == 1:\n            return [nums[0]]\n        \n        # sort the nums\n        nums.sort()\n        \n        # get the max value\n        max_val = nums[-1]\n        \n        # initialize the best_seq\n        best_seq = []\n        \n        # DFS\n        for i in range(L):\n            if i == 0 or nums[i]!= nums[i-1]:\n                # cut the first one\n                cut_seq = dfs(nums[:i] + nums[i+1:])\n                \n                # insert the cut_seq\n                insert_seq = [nums[i]] + cut_seq\n                \n                # insert in the best_seq\n                best_seq.append(insert_seq)\n                \n        return best_seq\n    \n    \n    \n    # read the N\n    N = int(stdin.readline())\n    \n    # read the N lines\n    nums = [list(map(int, stdin.readline().split())) for _ in range(N)]\n    \n    # call the dfs\n    best_seq = dfs(nums)\n    \n    # initialize the best_val\n    best_val = float('inf')\n    \n    # for each best_seq in best_seq\n    for seq in best_seq:\n        # get the sum\n        val = sum([i[0] for i in seq])\n        \n        # if the sum is less than best_val\n        if val < best_val:\n            # set the new best_val\n            best_val = val\n            \n    # return the best_val\n    return str(best_val)\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    #...\n    return sol"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input = stdin.split(\"\\n\")\n    N = int(input[0])\n    res = []\n    for i in range(1, N + 1):\n        res.append(list(map(int, input[i].split())))\n\n    for i in range(len(res)):\n        res[i].sort()\n    print(res)\n    for i in range(len(res)):\n        if len(res[i]) > 1:\n            c = res[i].pop(0)\n            print(c)\n            res[i].append(c)\n    print(res)\n    for i in range(len(res)):\n        if len(res[i]) > 1:\n            print(sum(res[i]), end = \" \")\n\nsolution(input)\n"
    },
    {
        "number": 3067,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\nimport sys\n\ndef"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return number of admissible solutions\"\"\"\n    \n    return ''"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    p1, p2 = 0, 0\n    for l in stdin:\n        s1, s2, p = l.split()\n        p1 += 1 if p == '1' else 0\n        p2 += 1 if p == '2' else 0\n    return str(p1 * p2)"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # get inputs\n    N = int(stdin[0])\n    players = [\n        [\n            stdin[i * 4 + 1] + stdin[i * 4 + 2],\n            int(stdin[i * 4 + 3]),\n            int(stdin[i * 4 + 4]),\n        ]\n        for i in range(N)\n    ]\n\n    # initiate the dp array\n    dp = [0] * N\n    dp[0] = 2\n    for i in range(1, N):\n        for j in range(i):\n            if players[i][0] == players[j][0]:\n                dp[i] += dp[j]\n                dp[i] %= MODULUS\n\n    return str(dp[N - 1])\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_investigations = int(stdin[0])\n    investigation = []\n    for i in range(num_investigations):\n        investigation.append(stdin[i+1].split())\n    solution_set = set()\n    for i in range(len(investigation)):\n        for j in range(len(investigation[i])):\n            for k in range(j + 1, len(investigation[i])):\n                if investigation[i][0] == investigation[i][j] or investigation[i][0] == investigation[i][k] or investigation[i][1] == investigation[i][j] or investigation[i][1] == investigation[i][k]:\n                    continue\n                else:\n                    solution_set.add(investigation[i][0] + investigation[i][1] + investigation[i][2])\n                    solution_set.add(investigation[i][1] + investigation[i][2] + investigation[i][0])\n                    solution_set.add(investigation[i][2] + investigation[i][0] + investigation[i][1])\n                    solution_set.add(investigation[i][0] + investigation[i][2] + investigation[i][1])\n                    solution_set.add(investigation[i][1] + investigation[i][0] + investigation[i][2])\n                    solution_set.add(investigation[i][2] + investigation[i][1] + investigation[i][0])\n    print(len(solution_set))\n    return ''"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # raise NotImplementedError\n    return '26'"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    return ''"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    circle = [chr(i + 65) for i in range(3)]\n    # save possible solutions\n    solutions = [[] for i in range(N + 1)]\n    for i in range(N):\n        s = set()\n        s.add(circle[i])\n        solutions[i + 1].append(s)\n\n        # for each first letter of the previous pair\n        for j in range(i):\n            # for each second letter of the previous pair\n            for k in range(j + 1, i):\n                # if the second letter of the previous pair is the first letter of the current pair\n                if stdin.split()[2 * k + 1][0] == stdin.split()[2 * j + 1][0]:\n                    # if the first letter of the current pair is different from the first letter of the previous pair\n                    if stdin.split()[2 * j + 1][1]!= stdin.split()[2 * k + 1][1]:\n                        # add the first letter of the current pair to the solution\n                        s.add(stdin.split()[2 * j + 1][0])\n                        s.add(stdin.split()[2 * k + 1][0])\n                        solutions[i + 1].append(s)\n    return str(len(solutions[N]))\n"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    https://www.codewars.com/kata/534d908741f1fd30320007d6/train/python\n    \"\"\"\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    count = 0\n    for line in lines[1:]:\n        (s1, p1, r1), (s2, p2, r2) = line.split(\" \")\n        p1 = int(p1)\n        p2 = int(p2)\n        if r1 == r2:\n            continue\n        count += 1 if ((p1 == 0 and p2 == 0) or\n                       (p1 == 1 and p2 == 1) or\n                       (p1 == 2 and p2 == 2)) else 0\n    return str(count)"
    },
    {
        "number": 3068,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin\n    if len(inp) < 2:\n        return 'impossible'\n    elif inp[0] == ')' or inp[-1] == '(':\n        return 'impossible'\n    ans = 'possible'\n    stack = []\n    for char in inp:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                ans = 'impossible'\n                break\n    if stack:\n        ans = 'impossible'\n    return ans\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(' ')\n    if len(stdin) <= 1:\n        return 'impossible'\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            stdin[i] = ')'\n        else:\n            stdin[i] = '('\n    if stdin[0] == ')' and stdin[-1] == '(':\n        if stdin[1] == ')':\n            stdin.pop(0)\n            stdin.pop(-1)\n        else:\n            stdin.insert(0, ')')\n            stdin.append('(')\n    else:\n        if stdin[0] == ')':\n            stdin.pop(0)\n        else:\n            stdin.insert(0, '(')\n    if stdin[0] == ')' and stdin[-1] == '(':\n        if stdin[1] == ')':\n            stdin.pop(0)\n            stdin.pop(-1)\n        else:\n            stdin.insert(0, ')')\n            stdin.append('(')\n    else:\n        if stdin[0] == ')':\n            stdin.pop(0)\n        else:\n            stdin.insert(0, '(')\n    for i in range(len(stdin)):\n        if stdin[i] == '(':\n            stdin[i] = ')'\n        else:\n            stdin[i] = '('\n    if stdin[0] == ')' and stdin[-1] == '(':\n        return 'possible'\n    else:\n        return 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    l_count = r_count = 0\n    for char in stdin:\n        if char == '(':\n            l_count += 1\n        if char == ')':\n            if l_count > 0:\n                l_count -= 1\n            else:\n                r_count += 1\n    if r_count == 0:\n        return 'possible'\n    return 'impossible'\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    brackets = stdin\n    valid = [\n        '(',\n        '[',\n        '{',\n        ']',\n        ')',\n        '}',\n    ]\n\n    stack = []\n    for bracket in brackets:\n        if bracket in valid:\n            stack.append(bracket)\n        else:\n            if not stack or bracket!= valid[valid.index(stack[-1]) + 1]:\n                return \"impossible\"\n            else:\n                stack.pop()\n\n    return \"possible\" if not stack else \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    l = len(s)\n    p = 0\n    while p < l:\n        if s[p] == '(':\n            if s[p:].find(')') >= 0:\n                # s[p:] = s[p:].replace('(', ')')\n                s = s[0:p] + s[p:].replace('(', ')')\n                p += 2\n            else:\n                p += 1\n        else:\n            if s[p:].find('(') >= 0:\n                s = s[0:p] + s[p:].replace(')', '(')\n                p += 2\n            else:\n                p += 1\n    if s.count('(') == s.count(')'):\n        return 'possible'\n    else:\n        return 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    for i in range(len(stdin)):\n        if stdin[i] == ')':\n            stdin = stdin.replace(stdin[i], '(')\n        else:\n            stdin = stdin.replace(stdin[i], ')')\n    return stdin if stdin[0] == '(' and stdin[-1] == ')' else 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    return ''\n"
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    bracket_sequence = stdin.strip()\n    stack = []\n    for bracket in bracket_sequence:\n        if stack and bracket == ')':\n            if stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(bracket)\n        else:\n            stack.append(bracket)\n    if stack:\n        return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3069,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    # write your code in Python 3.6\n    stack = []\n    stack_index = []\n    len_bracket = len(stdin)\n    for i in range(len_bracket):\n        if stdin[i] == \"(\":\n            stack.append(stdin[i])\n            stack_index.append(i)\n        else:\n            if not stack:\n                return \"impossible\"\n            else:\n                stack.pop()\n                stack_index.pop()\n    if stack:\n        return \"impossible\"\n    else:\n        return \"possible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split('\\n')[0].split())\n    time = dict()\n    for i in range(m):\n        s, t, l = map(int, stdin.split('\\n')[i + 1].split())\n        if s in time:\n            time[s] = (t, l)\n        else:\n            time[s] = (t, 0)\n        if s + 1 in time:\n            time[s + 1] = (t + l, 0)\n        else:\n            time[s + 1] = (t + l, 0)\n    keys = sorted(time.keys())\n    i = 0\n    while i < len(keys):\n        if time[keys[i]][0] < 30:\n            keys.pop(i)\n        elif time[keys[i]][0] < 1800:\n            time[keys[i]] = (time[keys[i]][0], time[keys[i]][1] + 30)\n            keys.pop(i)\n        else:\n            i += 1\n    keys = sorted(keys)\n    i = 0\n    while i < len(keys):\n        if time[keys[i]][0] + time[keys[i]][1] < 1800:\n            keys.pop(i)\n        else:\n            i += 1\n    keys = sorted(keys)\n    ans = -1\n    if len(keys) == 0:\n        print('impossible')\n    else:\n        i = 0\n        while i < len(keys):\n            if ans == -1 or time[keys[i]][0] - keys[i] < ans:\n                ans = time[keys[i]][0] - keys[i]\n            i += 1\n        if ans < 0:\n            print('impossible')\n        else:\n            print(ans)\n\nsolution(stdin)\n-----Explanation-----\nWe consider each train one after the other, starting from the one that arrives first.\n\nSuppose the earliest train that we could book has a departure time of $1800$ and a duration of $30$ minutes. We can't book this train because we have to be able to reach our destination in at most $1800 + 30 = 1950$ seconds. If we hadn't planned the arrival earlier, we could've booked the train for $1800 + 30 = 1950$ seconds, and then changed to the next train, and so on, until we could book a train that we could then book in time for the $1800$ refund.\n\nThe first train that has a start time of $1800$ and a duration of $30$ minutes is the one we would have booked.\n\nThe second train has a start time of $1900$ and a duration of $30$ minutes. It's possible to change to this train, but the new departure time of $1900$ + $30$ = $1940$ + $30$ = $1980$ + $30$ = $2140$ is strictly less than $1800 + 30 = 1950$, so we can't book the train.\n\nThe third train has a start time of $1900$ and a duration of $30$ minutes. It's possible to change to this train, but the new departure time of $1900$ + $30$ = $1940$ + $30$ = $1980$ + $30$ = $2140$ is strictly less than $1800 + 30 = 1950$, so we can't book the train.\n\nAll three trains have a start time of $1900$ and a duration of $30$ minutes, so they are all impossible.\n-----Challenge-----\nCan you solve it in $O(N + M)$ time?\n\n\"\"\""
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the earliest train journey start time, given a schedule of trains\"\"\"\n    n, m = (int(c) for c in stdin.split())\n    print(m)\n    cows = {}\n    for i in range(m):\n        (x, s, t, l) = (int(c) for c in stdin.split())\n        cows[x] = [s, t, l]\n        print(cows)\n    return cows\n\nprint(solution(\"2 3\\n1 1800 9000 1800\\n1 2000 9200 1600\\n1 2200 9400 1400\"))\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from datetime import datetime as dt\n    N, M = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    schedules = [{'departure': dt.fromisoformat(x.split(' ')[1]),\n                  'arrival': dt.fromisoformat(x.split(' ')[2]),\n                  'duration': dt.fromisoformat(x.split(' ')[3]) - dt.fromisoformat(x.split(' ')[2])}\n                 for x in stdin.split('\\n')[1:]]\n    schedules.sort(key=lambda x: x['arrival'])\n\n    max_duration = dt.fromisoformat(schedules[-1]['departure'].isoformat()) - dt.fromisoformat(\n        schedules[0]['arrival'].isoformat())\n    for i in range(1, N):\n        temp = dt.fromisoformat(schedules[i - 1]['departure'].isoformat()) - dt.fromisoformat(\n            schedules[i]['arrival'].isoformat())\n        if temp < 30:\n            return 'impossible'\n    res = dt.fromisoformat(schedules[0]['arrival'].isoformat())\n    for i in range(1, N):\n        if dt.fromisoformat(schedules[i]['arrival'].isoformat()) - res >= 30:\n            res = dt.fromisoformat(schedules[i]['departure'].isoformat())\n    return str(res.isoformat())\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n  \n  TRAINS = int(stdin.split('\\n')[0].split(' ')[0])\n  STATIONS = int(stdin.split('\\n')[0].split(' ')[1])\n  train_times = {(train_id, station_id): None for train_id in range(TRAINS) for station_id in range(STATIONS)}\n  \n  for line in stdin.split('\\n')[1:]:\n    train_id, station_id, dep_sec, arr_sec, delay_sec = map(int, line.split(' '))\n    \n    train_times[(train_id, station_id)] = (dep_sec, arr_sec, delay_sec)\n    \n  for train_id, station_id in train_times:\n    if train_times[train_id, station_id] == None:\n      continue\n    \n    dep_sec, arr_sec, delay_sec = train_times[train_id, station_id]\n    if arr_sec > dep_sec + delay_sec or arr_sec + delay_sec < 1800:\n      continue\n    \n    if arr_sec > arr_sec + delay_sec or arr_sec + delay_sec < 1800:\n      continue\n    \n    if dep_sec + delay_sec > 1800:\n      continue\n    \n    if dep_sec + delay_sec < 1800:\n      continue\n    \n    return str(dep_sec)\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(' '))\n    depart_times, arrival_times, delay_times = {}, {}, {}\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.split(' '))\n        depart_times[X] = max(S, depart_times.get(X, 0))\n        arrival_times[X + 1] = min(T, arrival_times.get(X + 1, T + L))\n        delay_times[X + 1] = min(depart_times[X + 1], arrival_times[X + 1])\n    latest_departure = max(depart_times.values())\n    earliest_arrival = min(arrival_times.values())\n    earliest_departure = max(delay_times.values())\n    if earliest_departure <= earliest_arrival:\n        return str(earliest_departure)\n    return 'impossible'\n"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(c) for c in stdin.split(' ')]\n    tt = []\n    for _ in range(m):\n        a, b, c = [int(c) for c in stdin.split('\\n')[_].split(' ')]\n        tt.append((a, b, c))\n    tt.sort()\n    min_t = None\n    print(tt)\n    for i in range(m):\n        if tt[i][0]!= 1:\n            continue\n        min_t = tt[i][1]\n        for j in range(i+1, m):\n            if tt[j][0]!= tt[i][0] + 1:\n                continue\n            if tt[j][2] < tt[i][1] + tt[i][2]:\n                min_t = tt[j][1]\n                break\n    return min_t"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    N, M = stdin.split(\" \")\n    N, M = int(N), int(M)\n    lines = stdin.split(\"\\n\")\n    \n    def time_ok(x, s, t, l):\n        return ((t - s) - l) < 30 * 60\n    \n    all_trains = []\n    \n    for line in lines[1:]:\n        x, s, t, l = line.split(\" \")\n        s, t, l = int(s), int(t), int(l)\n        all_trains.append([x, s, t, l])\n    \n    def score(t):\n        return (((t[3] - t[2]) - t[4]) - t[3])\n    \n    all_trains.sort(key=score, reverse=True)\n    \n    def find_x():\n        for line in all_trains:\n            if line[0] == 1:\n                return line\n        return None\n    \n    def time_ok_x(x, s, t, l):\n        return ((t - s) - l) < 30 * 60\n    \n    def time_ok_x_next(x, s, t, l):\n        if x[0] == N:\n            return True\n        for line in all_trains:\n            if line[0] == x[0] + 1:\n                return ((t - s) - l) < 30 * 60\n        return False\n    \n    # problem with this is that it would return a list of all trains that could be travelled for that day\n    # so you would need to then search to find the one with the highest score\n    # i.e. there are several ways to travel a given route\n    # which is an issue if you need to return the earliest time\n    # and if there are several ways to do this, and there are no guarantees that the latest one is the best route\n    \n    # could also maybe sort by time and then take the first one\n    # i.e. only take the earliest one\n    # that is then guaranteed to be the best route\n    # then you could use the same logic as above to find the best route\n    \n    # instead of searching for the earliest one, could search for the best route\n    # then you would take the latest one\n    # this is worse, but then you would at least find the best route\n    \n    # so is there a way to return the best route?\n    # yes, but that means that you need to know the routes that you've taken so far\n    # so you can then know the best route that you've taken so far\n    # and then you can also just return the best route\n    \n    # i.e. when you want to return the best route,\n    # you could first find the best route\n    # then you could return the last train that you took on the best route\n    # then you could search for the best route on that date again\n    # this is great, but then it means that you have to find the route of the last train,\n    # so you need to know all the routes taken so far,\n    # then you can then find the best route on the date that you're searching for\n    \n    # so what you could do is try and keep track of all the routes you've taken so far\n    # so you could then only return the best route you've seen so far\n    # and then you could just search for the best route on that date again\n    \n    # what do we want to keep track of?\n    # i.e. all the routes we've taken so far\n    \n    best_route = None\n    best_score = -math.inf\n    best_route_date = None\n    \n    for line in all_trains:\n        x, s, t, l = line\n        if x == 1:\n            route = []\n        elif x == N:\n            route = route + [line]\n        else:\n            if time_ok_x(x, s, t, l):\n                route = route + [line]\n        \n        if x == 1:\n            if score(line) > best_score:\n                best_score = score(line)\n                best_route = route\n                best_route_date = x\n        elif x == N:\n            if score(line) > best_score:\n                best_score = score(line)\n                best_route = route\n                best_route_date = x\n    \n    best_route.sort(key=lambda x: x[2])\n    \n    for i in range(len(best_route) - 1):\n        x1, s1, t1, l1 = best_route[i]\n        x2, s2, t2, l2 = best_route[i+1]\n        if x1!= x2:\n            if not time_ok_x_next(x2, s2, t2, l2):\n                return str(best_route_date - 1)\n    \n    return str(best_route_date)"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Time Complexity: O(N * Mlog(M))\n    Space Complexity: O(M)\n    '''\n    def binary_search(arr, target, lo, hi):\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if arr[mid] >= target:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return lo\n    \n    N, M = map(int, stdin.split(' '))\n    arr = [0] * M\n    for i in range(M):\n        arr[i] = [int(x) for x in stdin.split(' ')[3 * i + 1 : 3 * i + 4]]\n    arr = sorted(arr, key = lambda x: x[0])\n    result = -1\n    for i in range(N):\n        for j in range(i, N):\n            if i!= j and arr[j][0] - arr[i][0] <= 1800 and binary_search(arr[j], arr[i][1] + arr[j][2], j + 1, M) == j + 1:\n                if (arr[j][1] + arr[j][2] - arr[i][1]) <= 1800:\n                    result = max(result, arr[j][0])\n    if result == -1:\n        return 'impossible'\n    return str(result)\n\nimport os\nimport random\nimport re\nimport sys\n\nfrom typing import List, Set, Dict"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # set_A_dic = {index : 0 for index in range(1, N+1)}\n    set_A_dic = dict()\n    set_A_dic = {index : 0 for index in range(1, N+1)}\n    N = int(stdin[0])\n    for i in range(N-1):\n        X, S, T, L = map(int, stdin[i+1].split())\n        S += L\n        T += L\n        # for j in range(X, X+1):\n        #     set_A_dic[j] += 1\n        set_A_dic[X] += 1\n        set_A_dic[X+1] -= 1\n    set_A = set(set_A_dic.values())\n    # print(set_A_dic)\n    A = list()\n    for a in set_A:\n        if a > 1:\n            A.append(a)\n    if A:\n        A.sort(reverse=True)\n        # print(A)\n        for a in A:\n            if a - 1 >= 1:\n                # print(a, a-1)\n                if a - 1 in set_A_dic.values():\n                    # print(True)\n                    # print(a)\n                    # print(a - 1)\n                    return str(a - 1)\n    else:\n        return 'impossible'"
    },
    {
        "number": 3070,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #Get inputs\n    train_num = stdin.split()\n    train_num = [int(x) for x in train_num]\n    station_num = train_num[0]\n    train_num = train_num[1:]\n\n    #Checks to see if we can travel on the bus\n    #Checking every route\n    for route in train_num:\n        #Checks to see if we can travel on this route\n        #Checking if the route can be travel on\n        if route[2] >= route[0] and route[3] <= route[1]:\n            continue\n        #If we cannot travel on this route, the route is not possible\n        else:\n            return \"impossible\"\n\n    #Converting the times into seconds\n    for route in train_num:\n        route[0] = route[0] * 3600\n        route[1] = route[1] * 3600\n\n    #Time we are starting off at\n    time = 0\n\n    #Array of stops we can travel to\n    stops = []\n\n    for route in train_num:\n        #Calculating our total travel time\n        total_travel_time = route[1] - route[0]\n\n        #Calculating the possible travel time\n        possible_travel_time = (route[3] - route[2])\n\n        #We need to have enough time to complete our route\n        if total_travel_time >= possible_travel_time:\n            #Adding to the time\n            time += possible_travel_time\n\n            #Adding the stop to our stops\n            stops.append(route[2])\n\n    #To make sure we travel the route we have to finish\n    if time < 30 * 3600:\n        return \"impossible\"\n\n    #Checking to see if we can travel on the bus\n    for route in train_num:\n        #Checking to see if we can travel on this route\n        #Checking if the route can be travel on\n        if route[2] >= route[0] and route[3] <= route[1]:\n            continue\n        #If we cannot travel on this route, the route is not possible\n        else:\n            return \"impossible\"\n\n    #Calculating our total travel time\n    total_travel_time = route[1] - route[0]\n\n    #Calculating the possible travel time\n    possible_travel_time = (route[3] - route[2])\n\n    #We need to have enough time to complete our route\n    if total_travel_time >= possible_travel_time:\n        #Adding to the time\n        time += possible_travel_time\n\n        #Adding the stop to our stops\n        stops.append(route[2])\n\n    #Converting the times into seconds\n    for route in train_num:\n        route[0] = route[0] * 3600\n        route[1] = route[1] * 3600\n\n    #Time we are starting off at\n    time = 0\n\n    #Array of stops we can travel to\n    stops = []\n\n    for route in train_num:\n        #Calculating our total travel time\n        total_travel_time = route[1] - route[0]\n\n        #Calculating the possible travel time\n        possible_travel_time = (route[3] - route[2])\n\n        #We need to have enough time to complete our route\n        if total_travel_time >= possible_travel_time:\n            #Adding to the time\n            time += possible_travel_time\n\n            #Adding the stop to our stops\n            stops.append(route[2])\n\n    #To make sure we travel the route we have to finish\n    if time < 30 * 3600:\n        return \"impossible\"\n\n    #Creating a dictionary with all possible stops\n    stops_dict = {}\n\n    for stop in range(station_num):\n        stops_dict[stop + 1] = []\n\n    #Putting all of our stops into the dictionary\n    for route in train_num:\n        for stop in stops:\n            if route[2] == stop:\n                stops_dict[route[2]].append(route[0])\n\n    #Making sure to add the starting station to our dictionary\n    stops_dict[1].append(0)\n\n    #Creating a list of stops\n    stops_list = []\n\n    #Putting all of our stops into the list\n    for stop in stops_dict.keys():\n        stops_list.append(stop)\n\n    #Sorting the list\n    stops_list.sort()\n\n    #Creating an array to store our possible routes\n    routes = []\n\n    #Creating a counter to keep track of the number of stops we have left to travel to\n    stops_counter = station_num\n\n    #Looping through all possible routes\n    for route in stops_list:\n        #Checking to see if we are still able to travel to this route\n        if stops_counter == 0:\n            break\n        #Checking to see if we have enough time to travel to this route\n        #If we do, then we can travel to this route\n        if time + (route - 1) * 3600 < 30 * 3600:\n            #We can travel to this route\n            routes.append(route)\n            #Moving to the next stop\n            stops_counter -= 1\n            #Updating the time\n            time += (route - 1) * 3600\n\n    #Creating a set of routes\n    routes_set = set(routes)\n\n    #Making a new list of routes\n    routes = list(routes_set)\n\n    #Creating a new list of stops to travel to\n    stops = []\n\n    #Creating a new dictionary to store the stops to travel to\n    stops_dict_copy = stops_dict.copy()\n\n    #Looping through all possible routes\n    for route in routes:\n        #Checking to see if we have enough time to travel to this route\n        #If we do, then we can travel to this route\n        if time + (route - 1) * 3600 < 30 * 3600:\n            #We can travel to this route\n            stops.append(route)\n            #Moving to the next stop\n            stops_counter -= 1\n            #Updating the time\n            time += (route - 1) * 3600\n\n            #Removing the stop from our dictionary\n            stops_dict_copy.pop(route)\n\n    #Creating a new set of stops to travel to\n    stops_set = set(stops)\n\n    #Creating a new list of stops to travel to\n    "
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n, m = [int(x) for x in stdin.split()]\n    m -= 1\n    n -= 1\n    string = [\"\"]*(m*n)\n    for i in range(0, m):\n        for j in range(0, n):\n            string[i*n+j] = \"A\"+str(i+1)+\"-\"+\"B\"+str(j+1)\n    return string"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split()))\n    return '\\n'.join([' '.join([f'{i + 1}-{j}' for i in range(n)]) for j in range(m)])\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    import numpy as np\n    import pandas as pd\n    n, m = [int(x) for x in stdin.split(' ')]\n    df = pd.DataFrame(np.array([['A'+str(i+1) for i in range(n)], ['B'+str(i+1) for i in range(m)]]).T, columns=['player'])\n    #print(df)\n    res = []\n    for i in range(m):\n        for j in range(i+1, m):\n            #print(i, j)\n            res.append(', '.join(np.unique(df.loc[(df['player']!= 'A'+str(j+1)) & (df['player']!= 'B'+str(j+1))]['player']))+' '+', '.join(np.unique(df.loc[(df['player']!= 'A'+str(i+1)) & (df['player']!= 'B'+str(i+1))]['player'])))\n            #print(', '.join(np.unique(df.loc[(df['player']!= 'A'+str(j+1)) & (df['player']!= 'B'+str(j+1))]['player'])))\n    return '\\n'.join(res)\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    #your code here\n    return \"\"\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d = {}\n    for i in range(1, n + 1):\n        d.update({i: [1, 1 + (m - 1) * i]})\n    for j in range(2, n):\n        for i in range(j + 1, n + 1):\n            d.update({i: [d[j][1], d[i][0]]})\n    return '\\n'.join([f\"{k}-{v}\" for k, v in d.items()])\n\n\ndef"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num_players, num_teams = list(map(int, stdin.split()))\n    team_assignments = [list(range(num_teams)) for _ in range(num_players)]\n\n    # find all players on team 0\n    # for each player, remove all players with same team\n    # for each player, add the remaining player to team 1\n    for team_num in range(num_teams):\n        for player in range(num_players):\n            if team_num == team_assignments[player][0]:\n                for p in range(num_players):\n                    if team_assignments[p][0] == team_num:\n                        team_assignments[p][0] = team_assignments[p][1]\n                team_assignments[player][0] = team_assignments[player][1]\n\n    # for each remaining player, add to team 2\n    for team_num in range(num_teams):\n        for player in range(num_players):\n            if team_num == team_assignments[player][1]:\n                team_assignments[player][1] = team_assignments[player][2]\n    \n    # sort by id to get ordered list of teams\n    return''.join([f'{team_num}-{player}' for team_num in range(1, num_teams+1) for player in team_assignments[team_num-1]])\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # input\n    n, m = map(int, stdin.split())\n    # create pairings\n    pairings = []\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                pairings.append(f\"A{i+1}-B{j+1}\")\n                pairings.append(f\"B{j+1}-A{i+1}\")\n    # print answer\n    print(' '.join(pairings))"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    if n == 1 or m == 1:\n        return stdin\n    else:\n        teams = [i for i in range(m)]\n        ans = ['-'] * m\n        for i in range(1, n + 1):\n            for team in teams:\n                if i % 2 == 1:\n                    ans[team] = f'{ans[team]} {i}'\n                else:\n                    ans[team] = f'{i} {ans[team]}'\n                teams.remove(team)\n                break\n        return '\\n'.join(ans)\n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    time complexity: O(N^2)\n    \"\"\"\n    n, m = list(map(int, stdin.split()))\n    players = list(range(1, n + 1))\n    teams = list(range(1, m + 1))\n    schedule = []\n    \n    for team in teams:\n        for i in range(n):\n            for j in range(i + 1, n):\n                schedule.append(f\"{players[i]}-{players[j]}\")\n                schedule.append(f\"{players[j]}-{players[i]}\")\n                \n    return''.join(schedule)\n    \n"
    },
    {
        "number": 3071,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    rounds = (m - 1) * n\n    if (m-1) * n > 100:\n        return \"IMPOSSIBLE\"\n    schedule = [[] for i in range(n)]\n    for i in range(n):\n        schedule[i].append('A{}'.format(i + 1))\n    for i in range(n - 1):\n        schedule[i].append('B{}'.format(i + 1))\n    for i in range(n - 1):\n        schedule[i].append('C{}'.format(i + 1))\n    for i in range(rounds):\n        if i % n!= 0 and i % n!= n - 1:\n            schedule[i % n].append('A{}-B{}'.format((i // n) + 1, (i // n) + 2))\n            schedule[i % n].append('B{}-A{}'.format((i // n) + 1, (i // n) + 2))\n        elif i % n == 0:\n            schedule[i % n].append('A{}-C{}'.format((i // n) + 1, (i // n) + 2))\n            schedule[i % n].append('C{}-A{}'.format((i // n) + 1, (i // n) + 2))\n        else:\n            schedule[i % n].append('B{}-C{}'.format((i // n) + 1, (i // n) + 2))\n            schedule[i % n].append('C{}-B{}'.format((i // n) + 1, (i // n) + 2))\n    for i in range(n):\n        print(' '.join(schedule[i]))\n    return ''\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"2 2\\n..\\n..\\n\")\n    7\n    >>> solution(\"4 4\\nX.XX\\nX..X\\n..X.\\n..XX\\n\")\n    9\n    \"\"\"\n    return str(sum(\n        sum(\n            map(\n                sum,\n                zip(\n                    map(\n                        lambda x: 1 if c == \".\" else 0,\n                        line,\n                    ),\n                    map(\n                        sum,\n                        zip(\n                            map(\n                                lambda x: 1 if c == \".\" else 0,\n                                reversed(line),\n                            ),\n                            map(\n                                sum,\n                                zip(\n                                    map(\n                                        sum,\n                                        zip(\n                                            map(\n                                                lambda x: 1 if c == \".\" else 0,\n                                                reversed(line),\n                                            ),\n                                            map(\n                                                sum,\n                                                zip(\n                                                    map(\n                                                        lambda x: 1 if c == \".\" else 0,\n                                                        line,\n                                                    ),\n                                                    map(\n                                                        sum,\n                                                        zip(\n                                                            map(\n                                                                lambda x: 1 if c == \".\" else 0,\n                                                                reversed(line),\n                                                            ),\n                                                        ),\n                                                    ),\n                                                ),\n                                            ),\n                                        ),\n                                        map(\n                                            sum,\n                                            zip(\n                                                map(\n                                                    sum,\n                                                    zip(\n                                                        map(\n                                                            lambda x: 1 if c == \".\" else 0,\n                                                        ),\n                                                        map(\n                                                            sum,\n                                                            zip(\n                                                                map(\n                                                                    lambda x: 1 if c == \".\" else 0,\n                                                                ),\n                                                                map(\n                                                                    sum,\n                                                                    zip(\n                                                                        map(\n                                                                            lambda x: 1 if c == \".\" else 0,\n                                                                            reversed(line),\n                                                                        ),\n                                                                        map(\n                                                                            sum,\n                                                                            zip(\n                                                                                map(\n                                                                                    lambda x: 1 if c == \".\" else 0,\n                                                                                    line,\n                                                                                ),\n                                                                                map(\n                                                                                    sum,\n                                                                                    zip(\n                                                                                        map(\n                                                                                            lambda x: 1 if c == \".\" else 0,\n                                                                                            reversed(line),\n                                                                                        ),\n                                                                                        map(\n                                                                                            sum,\n                                                                                            zip(\n                                                                                                map(\n                                                                                                    lambda x: 1 if c == \".\" else 0,\n                                                                                                ),\n                                                                                                map(\n                                                                                                    sum,\n                                                                                                    zip(\n                                                                                                        map(\n                                                                                                            lambda x: 1 if c == \".\" else 0,\n                                                                                                            reversed(line),\n                                                                                                        ),\n                                                                                                        map(\n                                                                                                            sum,\n                                                                                                            zip(\n                                                                                                                map(\n                                                                                                                    lambda x: 1 if c == \".\" else 0,\n                                                                                                                ),\n                                                                                                                map(\n                                                                                                                    sum,\n                                                                                                                zip(\n                                                                                                                        map(\n                                                                                                                              lambda x: 1 if c == \".\" else 0,\n                                                                                                                        reversed(line),\n                                                                                                                    ),\n                                                                                                                        map(\n                                                                                                                              sum,\n                                                                                                                              zip(\n                                                                                                                                  map(\n                                                                                                                                    lambda x: 1 if c == \".\" else 0,\n                                                                                                                                    line,\n                                                                                                                                    ),\n                                                                                                                                    map(\n                                                                                                                                       sum,\n                                                                                                                                       zip(\n                                                                                                                                            map(\n                                                                                                                                                lambda x: 1 if c == \".\" else 0,\n                                                                                                                                            reversed(line),\n                                                                                                                                            ),\n                                                                                                                                            map(\n                                                                                                                                                sum,\n                                                                                                                                                zip(\n                                                                                                                                                    map(\n                                                                                                                                                        lambda x: 1 if c == \".\" else 0,\n                                                                                                                                                    ),\n                                                                                                                                                    map(\n                                                                                                                                                        sum,\n                                                                                                                                                    ),\n                                                                                                                                                ),\n                                                                                                                                            ),\n                                                                                                                                                 ),\n                                                                                                                                    ),\n                                                                                                                                    ),\n                                                                                                                                ),\n                                                                                                                            },\n                                                                                                                        ),\n                                                                                                                    ),\n                                                                                                                ),\n                                                                                                            ),\n                                                                                                        ),\n                                                                                                    ),\n                                                                                                    map(\n                                                                                                        sum,\n                                                                                                        zip(\n                                                                                                            map(\n                                                                                                                lambda x: 1 if c == \".\" else 0,\n                                                                                                            ),\n                                                                                                            map(\n                                                                                                                sum,\n                                                                                                                zip(\n                                                                                                                    map(\n                                                                                                                        lambda x: 1 if c == \".\" else 0,\n                                                                                                                    ),\n                                                                                                                    map(\n                                                                                                                        sum,\n                                                                                                                        zip(\n                                                                                                                              map(\n                                                                                                                                  lambda x: 1 if c == \".\" else 0,\n                                                                                                                                   reversed(line),\n                                                                                                                              ),\n                                                                                                                              map(\n                                                                                                                                  sum,\n                                                                                                                                   zip(\n                                                                                                                                       map(\n                                                                                                                                            lambda x: 1 if c == \".\" else 0,\n                                                                                                                                            line,\n                                                                                                                                        ),\n                                                                                                                                       map(\n                                                                                                                                            sum,\n                               "
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    apartment_layout = stdin.split('\\n')\n    rows, columns = map(int, apartment_layout[0].split())\n    free_squares = 0\n    for r in apartment_layout[1:]:\n        for c in r:\n            if c == '.':\n                free_squares += 1\n    if rows * columns >= free_squares:\n        return str(rows * columns)\n    else:\n        return str(free_squares)\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    dimensions = stdin.splitlines()\n    r, c = int(dimensions[0].split(' ')[0]), int(dimensions[0].split(' ')[1])\n    grid = stdin.splitlines()[1:]\n\n    free_squares = 0\n    for row in range(r):\n        for column in range(c):\n            if grid[row][column] == '.':\n                free_squares += 1\n    return str(free_squares)\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    \n    def solve(matrix: list[list[str]], max_width: int, max_height: int) -> int:\n        def make_grid(width: int, height: int) -> int:\n            return width * height\n            \n        def get_border_length(coordinate: tuple[int, int]) -> int:\n            x, y = coordinate\n            return ((x, y, x+1, y+1)\n                    if y == 0\n                    else (x, 0, x+1, y)\n                    if x == 0\n                    else (0, y, x, y+1))\n            \n        def is_border_occupied(border: tuple[int, int, int, int]) -> bool:\n            x, y, x2, y2 = border\n            for i in range(x, x2):\n                for j in range(y, y2):\n                    if matrix[i][j] == 'X':\n                        return True\n            return False\n            \n        def is_available(grid: int, grid_count: int) -> bool:\n            return grid_count <= grid\n            \n        def check_candidate(candidate: tuple[int, int], matrix: list[list[str]],\n                            grid_count: int) -> bool:\n            for i in range(len(candidate)):\n                border = get_border_length(candidate[i])\n                if is_border_occupied(border):\n                    return False\n                \n            for i in range(len(candidate)):\n                grid_count += 1\n                matrix[candidate[i][0]][candidate[i][1]] = 'X'\n            \n            if is_available(grid_count, grid_count):\n                return True\n            \n            for i in range(len(candidate)):\n                matrix[candidate[i][0]][candidate[i][1]] = '.'\n                grid_count -= 1\n                \n            return False\n            \n        def find_first_candidate(matrix: list[list[str]],\n                                 grid_count: int) -> tuple[int, int]:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    if matrix[i][j] == '.':\n                        candidate = (i, j)\n                        if check_candidate(candidate, matrix, grid_count):\n                            return candidate\n            \n        def find_second_candidate(matrix: list[list[str]],\n                                  grid_count: int) -> tuple[int, int]:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    if matrix[i][j] == '.':\n                        candidate = (i, j)\n                        if check_candidate(candidate, matrix, grid_count):\n                            return candidate\n                        \n            return (-1, -1)\n            \n        def find_third_candidate(matrix: list[list[str]],\n                                 grid_count: int) -> tuple[int, int]:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    if matrix[i][j] == '.':\n                        candidate = (i, j)\n                        if check_candidate(candidate, matrix, grid_count):\n                            return candidate\n                        \n            return (-1, -1)\n            \n        def find_fourth_candidate(matrix: list[list[str]],\n                                  grid_count: int) -> tuple[int, int]:\n            for i in range(len(matrix)):\n                for j in range(len(matrix[i])):\n                    if matrix[i][j] == '.':\n                        candidate = (i, j)\n                        if check_candidate(candidate, matrix, grid_count):\n                            return candidate\n                        \n            return (-1, -1)\n            \n        candidate_1 = find_first_candidate(matrix, grid_count)\n        candidate_2 = find_second_candidate(matrix, grid_count)\n        candidate_3 = find_third_candidate(matrix, grid_count)\n        candidate_4 = find_fourth_candidate(matrix, grid_count)\n        \n        print(candidate_1, candidate_2, candidate_3, candidate_4)\n        \n        def sum_length(candidate: tuple[int, int], coordinate: tuple[int, int]) -> int:\n            length = abs(candidate[0] - coordinate[0]) + abs(candidate[1] - coordinate[1])\n            return length\n            \n        def sum_length_sum(candidate: tuple[int, int],\n                           coordinate: tuple[int, int]) -> int:\n            length = sum_length(candidate, coordinate)\n            return length + sum_length(coordinate, candidate)\n            \n        def min_length_sum(candidate: tuple[int, int],\n                           coordinate: tuple[int, int]) -> int:\n            length = sum_length_sum(candidate, coordinate)\n            return length + sum_length(coordinate, candidate)\n            \n        def find_max_length_sum(candidate: tuple[int, int],\n                                coordinate: tuple[int, int]) -> int:\n            return min_length_sum(candidate, coordinate)\n        \n        def get_max_length_sum(candidates: tuple[tuple[int, int],...]) -> tuple[int, int]:\n            max_length = 0\n            max_candidate = ()\n            for candidate in candidates:\n                candidate_length = find_max_length_sum(candidate, (0, 0))\n                if candidate_length > max_length:\n                    max_length = candidate_length\n                    max_candidate = candidate\n                    \n            return max_candidate, max_length\n            \n        def find_max_length(candidates: tuple[tuple[int, int],...]) -> tuple[int, tuple[int, int]]:\n            max_length = 0\n            max_candidate = ()\n            for candidate in candidates:\n                candidate_length = sum_length(candidate, (0, 0))\n                if candidate_length > max_length:\n                    max_length = candidate_length\n                    max_candidate = candidate\n                    \n            return max_length, max_candidate\n            \n        def remove_duplicates(candidates: tuple[tuple[int, int],...]) -> tuple[tuple[int, int],...]:\n            lengths = [sum_length(candidate, (0, 0)) for candidate in candidates]\n            max_length, max_candidate = find_max_length(candidates)\n            \n            new_candidates = tuple()\n            for candidate in candidates:\n                if sum_length(candidate, (0, 0))!= max_length:\n                    new_candidates += (candidate,)\n            \n            return new_candidates\n            \n        def remove_longer(candidates: tuple[tuple[int, int],...]) -> tuple[tuple[int, int],...]:\n            lengths = [sum_length(candidate, (0, 0)) for candidate in candidates]\n            max_length, max_candidate = find_max_length("
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the number of guests Mirko can invite to dinner after he buys his table on a single line.\"\"\"\n    return ''\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''solution: returns the number of guests Mirko can invite to dinner'''\n    r, c = list(map(int, stdin.split(' ')))\n    grid = stdin[:-1].split('\\n')\n    def is_valid(r, c):\n        '''is_valid: checks if given r, c is valid'''\n        return (0 <= r < r and 0 <= c < c)\n    def is_valid_pos(r, c):\n        '''is_valid_pos: checks if given r, c is valid for r, c in table'''\n        return is_valid(r, c) and grid[r][c] == '.'\n    def can_fit_table(r, c):\n        '''can_fit_table: checks if a table can be placed at given r, c'''\n        return sum(map(lambda l: len(l), grid[r])) + sum(map(lambda l: l[c], grid)) == 4 * c + 2 * r\n    def can_fit_table_corner(r, c):\n        '''can_fit_table_corner: checks if a table can be placed at given r, c with a table in corners'''\n        if not is_valid_pos(r, c):\n            return False\n        grid_cp = copy.deepcopy(grid)\n        grid_cp[r][c] = 'X'\n        if r + 1 < r and grid_cp[r + 1][c] == '.':\n            if r + 2 < r and grid_cp[r + 2][c] == '.':\n                return True\n            if c + 1 < c and grid_cp[r + 1][c + 1] == '.':\n                return True\n            if c + 2 < c and grid_cp[r + 1][c + 2] == '.':\n                return True\n        if r - 1 >= 0 and grid_cp[r - 1][c] == '.':\n            if r - 2 >= 0 and grid_cp[r - 2][c] == '.':\n                return True\n            if c + 1 < c and grid_cp[r - 1][c + 1] == '.':\n                return True\n            if c + 2 < c and grid_cp[r - 1][c + 2] == '.':\n                return True\n        if c - 1 >= 0 and grid_cp[r][c - 1] == '.':\n            if c - 2 >= 0 and grid_cp[r][c - 2] == '.':\n                return True\n            if r + 1 < r and grid_cp[r + 1][c - 1] == '.':\n                return True\n            if r + 2 < r and grid_cp[r + 2][c - 1] == '.':\n                return True\n        return False\n    def explore(r, c, visited):\n        '''explore: explores the grid, finds the solution'''\n        if not can_fit_table(r, c):\n            return\n        if (r, c) in visited:\n            return\n        visited.add((r, c))\n        if can_fit_table_corner(r, c):\n            return\n        if c + 1 < c and (r, c + 1) not in visited and can_fit_table(r, c + 1):\n            explore(r, c + 1, visited)\n        if c - 1 >= 0 and (r, c - 1) not in visited and can_fit_table(r, c - 1):\n            explore(r, c - 1, visited)\n        if r + 1 < r and (r + 1, c) not in visited and can_fit_table(r + 1, c):\n            explore(r + 1, c, visited)\n        if r - 1 >= 0 and (r - 1, c) not in visited and can_fit_table(r - 1, c):\n            explore(r - 1, c, visited)\n    visited = set()\n    explore(0, 0, visited)\n    return str(len(visited))\n\n\ndef"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return stdin"
    },
    {
        "number": 3072,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    counts all squares with p\n    '''\n    return len([i for i in stdin.splitlines() if 'X' in i])\n\nprint(solution('2 2\\n.\\n..'))\nprint(solution('4 4\\n.XX\\nX..\\n..X\\n..XX'))\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    find minimum cost for the knight to reach the goal at (0, 0)\n    \"\"\"\n    # get input\n    n = int(stdin.readline().strip())\n    cost = [[int(i) for i in stdin.readline().strip().split()]\n            for _ in range(n)]\n    # find minimum cost\n    cost.append([0, 0, 0, 0, 0])\n    cost.insert(0, [0, 0, 0, 0, 0])\n    dp = [[0 for _ in range(5)] for _ in range(5)]\n    dp[0][0] = cost[1][0] + cost[1][1]\n    dp[0][1] = cost[1][0] + cost[0][1]\n    dp[0][2] = cost[0][0] + cost[1][1]\n    dp[0][3] = cost[0][0] + cost[0][1]\n    dp[0][4] = cost[0][0] + cost[1][0]\n    dp[1][0] = cost[0][1] + cost[1][1]\n    dp[1][1] = cost[0][0] + cost[1][0]\n    dp[1][2] = cost[0][0] + cost[1][1]\n    dp[1][3] = cost[0][0] + cost[0][1]\n    dp[1][4] = cost[0][0] + cost[0][1]\n    dp[2][0] = cost[1][1] + cost[1][2]\n    dp[2][1] = cost[0][1] + cost[1][0]\n    dp[2][2] = cost[0][0] + cost[1][0]\n    dp[2][3] = cost[0][1] + cost[1][0]\n    dp[2][4] = cost[0][0] + cost[1][0]\n    dp[3][0] = cost[1][2] + cost[1][3]\n    dp[3][1] = cost[0][2] + cost[1][0]\n    dp[3][2] = cost[0][0] + cost[1][0]\n    dp[3][3] = cost[0][1] + cost[1][0]\n    dp[3][4] = cost[0][0] + cost[1][0]\n    dp[4][0] = cost[1][3] + cost[1][4]\n    dp[4][1] = cost[0][3] + cost[1][0]\n    dp[4][2] = cost[0][1] + cost[1][0]\n    dp[4][3] = cost[0][2] + cost[1][0]\n    dp[4][4] = cost[0][0] + cost[1][0]\n    min_cost = min([cost[-1][i] + dp[0][i] for i in range(5)])\n    if min_cost == 100:\n        return -1\n    return min_cost\n\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    # Find the location of the card with highest price,\n    # and the card with lowest price.\n    # The total number of cards on the board is n\n    # The minimum number of squares needed to move from\n    # the position of highest priced card to the lowest\n    # priced card is n - 1.\n    # The minimum number of squares needed to move from\n    # the position of lowest priced card to the highest\n    # priced card is n - 2.\n    # The total number of squares needed to move from\n    # the position of highest priced card to the lowest\n    # priced card is n - 2.\n    # The total number of squares needed to move from\n    # the position of lowest priced card to the highest\n    # priced card is n - 2.\n    # The total number of squares needed to move from\n    # the position of highest priced card to the lowest\n    # priced card is n - 2.\n    \"\"\"\n    def calculate(x1, y1, x2, y2):\n        \"\"\"\n        Return the price of the card by which the knight\n        must travel.\n        \"\"\"\n        dx = x2 - x1\n        dy = y2 - y1\n        if dx == dy:\n            return dx * 4\n        elif dx == -dy:\n            return 2 * (dx + dy)\n        elif dx < 0 and dy < 0:\n            return 2 * abs(dx) + 2 * abs(dy)\n        elif dx < 0 and dy > 0:\n            return abs(dy) * 4 + 2 * abs(dx)\n        elif dx > 0 and dy < 0:\n            return abs(dy) * 4 + 2 * abs(dx)\n        elif dx > 0 and dy > 0:\n            return 2 * (dx + dy)\n\n    def get_card_price(cards):\n        \"\"\"\n        Return a list of prices of all cards.\n        \"\"\"\n        return [card[-1] for card in cards]\n\n    def get_card_location(cards):\n        \"\"\"\n        Return a list of locations of all cards.\n        \"\"\"\n        return [card[:-1] for card in cards]\n\n    def find_card_price_min(cards, n):\n        \"\"\"\n        Return the index of the card with the lowest price.\n        \"\"\"\n        min_price = min(get_card_price(cards))\n        return get_card_price(cards).index(min_price)\n\n    def find_card_price_max(cards, n):\n        \"\"\"\n        Return the index of the card with the highest price.\n        \"\"\"\n        max_price = max(get_card_price(cards))\n        return get_card_price(cards).index(max_price)\n\n    def calculate_price_min(cards, n):\n        \"\"\"\n        Return the cost of the minimum number of squares required\n        to reach the location of the card with the lowest price.\n        \"\"\"\n        lowest_price_index = find_card_price_min(cards, n)\n        return n - 1 - lowest_price_index\n\n    def calculate_price_max(cards, n):\n        \"\"\"\n        Return the cost of the minimum number of squares required\n        to reach the location of the card with the highest price.\n        \"\"\"\n        highest_price_index = find_card_price_max(cards, n)\n        return n - 2 - highest_price_index\n\n    def calculate_price(cards, n):\n        \"\"\"\n        Return the cost of the minimum number of squares required\n        to reach the location of the card with the highest price.\n        \"\"\"\n        highest_price_index = find_card_price_max(cards, n)\n        lowest_price_index = find_card_price_min(cards, n)\n        return n - 1 - (highest_price_index - lowest_price_index)\n\n    return str(min(calculate(0, 0, x, y)\n                   for x, y in get_card_location(stdin.splitlines())))\n\n\nprint(solution(\"\"\"\n3\n1 1 1 1 500\n\"\"\"), \"600\")\nprint(solution(\"\"\"\n2\n2 0 2 1 100\n6 0 8 1 1\n\"\"\"), \"100\")\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum cost to reach the origin position of the knight.\n\n    :param str stdin: the stdin input for the challenge.\n    :return: the minimum cost to reach the origin position of the knight.\n    :rtype: str\n    \"\"\"\n    n = int(stdin.readline())\n    # print(n)\n    for i in range(n):\n        r, c, a, b, p = [int(x) for x in stdin.readline().split()]\n        print(r, c, a, b, p)\n\n    return \"\"\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution of exercise.\"\"\"\n    # Split input by newlines.\n    lines = stdin.splitlines()\n\n    # Get input.\n    n = int(lines[0])\n\n    # Initialize variables.\n    p, d = 0, {(0, 0): 0}\n\n    # For each card, add a price and tuple of (row, col).\n    for i in range(1, n + 1):\n        row, col, offset_a, offset_b, price = lines[i].split()\n        d[(int(row), int(col))] = int(price)\n        p += int(price)\n\n    # Initialize return value.\n    return_value = -1\n\n    # For each card, update return_value.\n    for card in d:\n        # If the card is a goal, update return_value.\n        if card[0] == 0 and card[1] == 0:\n            return_value = d[card]\n            break\n\n        # Calculate the price for current position.\n        p_next = d[card] + p\n\n        # If it is cheaper to get to the next position from the current position, update return_value.\n        if p_next < d[(card[0] + offset_a, card[1] + offset_b)]:\n            return_value = p_next\n\n    # Return return_value.\n    return return_value\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # create card -> prices dict\n    card_price = dict()\n    n = int(stdin.readline())\n    for i in range(n):\n        # get coordinates of card\n        values = list(map(int, stdin.readline().split()))\n        card_price[tuple(values[0:3])] = values[3]\n\n    # define variables\n    price = 0\n    next_pos = tuple()\n    pos = tuple(0, 0)\n\n    # loop through card price dict\n    while True:\n        # get next pos\n        for i in range(4):\n            for j in range(4):\n                if abs(i - 2) + abs(j - 2) == 1:\n                    if (pos[0] + i, pos[1] + j) in card_price:\n                        next_pos = (pos[0] + i, pos[1] + j)\n                        price += card_price[next_pos]\n                        break\n\n        # check if reached goal\n        if pos == (0, 0) or price < 0:\n            return str(price) if price > 0 else '-1'\n\n        # update variables\n        pos = next_pos\n        price = 0\n"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This solution computes the solution by converting the problem into a\n    graph search problem.\n    '''\n    # Parse input\n    n = int(stdin.readline())\n    cards = [list(map(int, line.split())) for line in stdin]\n\n    # Build adjacency graph\n    graph = [{} for _ in range(n)]\n    for r, c, a, b, p in cards:\n        graph[r - 1][c - 1] = [a, b, p]\n\n    # Do graph search\n    return shortest_path_search(graph, 0, 0)\n\n\ndef"
    },
    {
        "number": 3073,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the minimum cost to get to the goal.\n\n    You may get any input you want, but you may not build a recursive\n    call tree larger than O(100).\n\n    Parameters\n    ----------\n    stdin\n        The input from STDIN for this problem.\n\n    Returns\n    -------\n    str\n        The minimum cost to get to the goal.\n    \"\"\"\n    # Get the number of cards on the board\n    n = int(stdin.readline())\n\n    # Read all the card information\n    cards = [tuple(int(s) for s in line.split()) for line in stdin]\n\n    # Initialise the minimum cost\n    cost = float(\"-inf\")\n\n    # Loop through each card in the order they were read\n    for i, (r, c, a, b, p) in enumerate(cards):\n\n        # Check if we have reached the goal\n        if r == 0 and c == 0:\n            cost = min(cost, p)\n\n        # If we have not reached the goal, we have to move the knight\n        else:\n            # Determine the next possible positions of the knight\n            next_positions = [\n                (r + a, c + b),\n                (r - a, c + b),\n                (r + a, c - b),\n                (r - a, c - b),\n                (r + b, c + a),\n                (r - b, c + a),\n                (r + b, c - a),\n                (r - b, c - a),\n            ]\n\n            # Check each possible position\n            for r_next, c_next in next_positions:\n\n                # Check if the next position is on the board\n                if 0 <= r_next <= 10 ** 9 and 0 <= c_next <= 10 ** 9:\n\n                    # Check if the position has a tarot card on it\n                    has_card = False\n                    for _, _, _, _, card_price in cards[:i + 1]:\n                        if card_price == 0:\n                            continue\n                        elif card_price < p:\n                            continue\n                        else:\n                            has_card = True\n                            break\n\n                    # If there is a tarot card, check if the knight can move there\n                    if has_card:\n                        for (r2, c2, a2, b2, p2) in cards[i + 1:]:\n                            if (\n                                0 <= r2 + a2 <= 10 ** 9\n                                and 0 <= c2 + b2 <= 10 ** 9\n                                and p2 == card_price\n                            ):\n                                has_card2 = False\n                                for _, _, _, _, card_price2 in cards[i + 1 :]:\n                                    if card_price2 == 0:\n                                        continue\n                                    elif card_price2 < p:\n                                        continue\n                                    else:\n                                        has_card2 = True\n                                        break\n                                if has_card2:\n                                    has_card = True\n                                    break\n\n                    # If the card is not on the board, check if it's the last card\n                    # in the board\n                    if not has_card:\n                        for (r2, c2, a2, b2, p2) in cards[i + 1:]:\n                            if (\n                                0 <= r2 + a2 <= 10 ** 9\n                                and 0 <= c2 + b2 <= 10 ** 9\n                                and p2 == card_price\n                            ):\n                                has_card2 = False\n                                for _, _, _, _, card_price2 in cards[i + 1 :]:\n                                    if card_price2 == 0:\n                                        continue\n                                    elif card_price2 < p:\n                                        continue\n                                    else:\n                                        has_card2 = True\n                                        break\n                                if not has_card2:\n                                    has_card = True\n                                    break\n\n                    # If the card is not on the board and it is not the last card\n                    # on the board, check if we have reached the goal\n                    if has_card and has_card2:\n                        cost = min(cost, card_price + card_price2)\n\n                    # If the card is on the board, check if we have reached the goal\n                    elif has_card:\n                        cost = min(cost, card_price)\n\n    if cost == float(\"-inf\"):\n        return \"-1\"\n    else:\n        return str(cost)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = stdin.split()[1]\n    result = 0\n\n    for i in range(N):\n        if S[i]!= '0':\n            if i < N - 1:\n                if int(S[i + 1])!= 0:\n                    result = result + 1\n            if i < N - 2:\n                if int(S[i + 2]) % 3 == 0:\n                    result = result + 1\n\n    return str(result % (10 ** 9 + 7))\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(n)\n    \"\"\"\n    # https://stackoverflow.com/a/952952\n    import math\n    N = int(stdin)\n    S = str(N)\n    S_length = len(S)\n    valid_subsets = 0\n    for i in range(S_length):\n        for j in range(i, S_length):\n            subset = S[i:j+1]\n            if math.prod(subset) % (10 ** 9 + 7) == 0:\n                valid_subsets += 1\n    return valid_subsets % (10 ** 9 + 7)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    S = stdin.strip()\n    S = list(S)\n    S.sort(reverse=True)\n    S.append('0')\n    S.append('7')\n    S.append('9')\n    S = ''.join(S)\n    res = 0\n    for i in range(1, 2 ** len(S)):\n        k = str(bin(i)[2:])\n        while len(k) < len(S):\n            k = '0' + k\n        k = k[::-1]\n        l = ''\n        for j in range(len(S)):\n            if k[j] == '1':\n                l += S[j]\n        if not l:\n            continue\n        l = int(l)\n        if not l % 3:\n            res += 1\n    return res % (10 ** 9 + 7)\n\nimport sys\n\nfor line in sys.stdin:\n    print(solution(line))"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    num_cases = int(stdin)\n    for _ in range(num_cases):\n        stdin = input()\n        case = input()\n        B = stdin\n        A = '0'\n        C = '0'\n        D = '0'\n        for x in case:\n            if x == '1':\n                A = A + '1'\n                C = C + '1'\n            else:\n                A = A + '0'\n                C = C + '0'\n        for x in B:\n            if x == '1':\n                D = D + '1'\n            else:\n                D = D + '0'\n        S = str(int(A) + int(C) + int(D))\n        print(S)\n        S = S.replace('1', '3')\n        S = S.replace('0', '0')\n        print(len(S) % 10000000007)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    N = int(stdin.readline())\n    S = stdin.readline()[:-1]\n    S = S[::-1]\n    return str(solution_helper(S))\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    nums = stdin.readline().strip()\n    \n    def validate(num: str) -> bool:\n        return not len(num) % 3 or not int(num) % 3\n    \n    res = sum(validate(num) for num in nums.split('1') if num)\n    print(res)\n    return ''"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_input = int(stdin)\n    num_list = [int(x) for x in str(num_input)]\n    count = 0\n\n    for i in range(0, len(num_list) + 1):\n        for j in range(0, len(num_list) - i + 1):\n            subset = num_list[j:j + i]\n            if sum(subset) % 3 == 0 and subset!= [0]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B = stdin\n    B = B.rstrip()\n    B = list(B)\n    ans = 0\n    for i in range(0, len(B)):\n        if B[i]!= '0':\n            if int(B[i]) % 3 == 0:\n                ans += 1\n            for j in range(0, len(B)):\n                if j!= i:\n                    if int(B[i]) % int(B[j]) == 0:\n                        if int(B[i]) % int(B[j]) == 0:\n                            if j < len(B) - 1:\n                                if int(B[j + 1]) % int(B[i]) == 0:\n                                    ans += 1\n                                else:\n                                    ans += 0\n                            else:\n                                ans += 1\n                        else:\n                            ans += 0\n                    else:\n                        ans += 0\n    return ans % (10**9 + 7)\n"
    },
    {
        "number": 3074,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return string in Canadian dollar format.\"\"\"\n    return stdin\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing the answer, either 'cancel road trip' or the minimum cost to complete the road trip.\"\"\"\n    # Get the input values\n    n, g = [int(i) for i in stdin.split()]\n\n    # Get the distances and costs\n    distances = []\n    costs = []\n    for i in range(n):\n        distances.append([int(i) for i in stdin.split()][0])\n        costs.append([int(i) for i in stdin.split()][1])\n\n    # Sort the arrays\n    distances = sorted(distances)\n    costs = sorted(costs)\n\n    # For each distance, see if there is a cost that is less than or equal to the total cost\n    total_cost = 0\n    for i in range(n):\n        # Find the cost that is less than or equal to the total cost\n        total_cost += costs[i]\n        if distances[i] > total_cost:\n            # We can't travel that far\n            return 'cancel road trip'\n\n    # The cost is within bounds\n    return total_cost"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    'https://www.codewars.com/kata/5fb5c8bcdc9568bf4e0000c7'\n    pass"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    gas_stations = [int(i) for i in stdin.split('\\n')]\n    curr_cost = 0\n    curr_km = 0\n    for i in range(1, len(gas_stations)):\n        curr_km += gas_stations[i - 1]\n        if curr_km >= car_capacity:\n            break\n        curr_cost += gas_stations[i]\n    return curr_cost if curr_cost < 9999999999 else 'cancel road trip'"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # ---------------\n    #! CONSTRAINTS!\n    # ---------------\n    #   - Assume only one car and one gas station (Tony can refill at most one car)\n    #   - Assume all gas stations are disjoint\n    #   - Assume fuel tank capacity is always full initially\n    # ---------------\n    #! INPUT FORMAT!\n    # ---------------\n    # <num_gas_stations> <fuel_tank_capacity>\n    # <distance_to_next_gas_station> <cost_per_gallon>\n    #! EXAMPLE!\n    # ---------------\n    #! INPUT!\n    # num_gas_stations = 3\n    # fuel_tank_capacity = 10\n    # distance_to_next_gas_station = [2, 100, 1, 10]\n    # cost_per_gallon = [1, 100, 10, 5]\n    #! OUTPUT!\n    # [5, 10, 10]\n\n    # ---------------\n    #! PLAN!\n    # ---------------\n    # 1. Initialize output array to INF (highest possible)\n    # 2. For each gas station:\n    #   2.1. Determine the closest gas station to the right of the current gas station\n    #   2.2. Determine the cost to travel to that gas station\n    #   2.3. If the cost is less than the current cost, set the current cost to the cost\n    # 3. Return the current cost\n    # ---------------\n\n    #! CODE!\n    gas_station_distances = stdin[0].split()\n    gas_station_costs = stdin[1].split()\n    gas_station_distances = list(map(int, gas_station_distances))\n    gas_station_costs = list(map(int, gas_station_costs))\n    num_gas_stations = len(gas_station_distances)\n    fuel_tank_capacity = gas_station_distances[0]\n    fuel_tank = [0] * num_gas_stations\n    for i in range(num_gas_stations):\n        fuel_tank[i] = gas_station_costs[i]\n    # Initialize the output array to be INF\n    fuel_tank_cost = [float('inf')] * num_gas_stations\n\n    # Iterate through the array, comparing the fuel cost to the distance to the next gas station\n    for i in range(num_gas_stations):\n        # Initialize the variable for the next gas station\n        next_gas_station = num_gas_stations - 1\n        # Loop until the next gas station is the end of the array\n        while i + next_gas_station < num_gas_stations:\n            # If the distance to the next gas station is less than the distance to the current gas station\n            # Then set the fuel cost to the fuel cost to the current gas station and break the loop\n            if gas_station_distances[i + next_gas_station] < gas_station_distances[i]:\n                fuel_tank_cost[i] = fuel_tank[i]\n                break\n            # Otherwise, increment the next gas station variable\n            next_gas_station = next_gas_station - 1\n        # If the fuel cost is not INF, then subtract it from the fuel tank cost and break the loop\n        if fuel_tank_cost[i]!= float('inf'):\n            fuel_tank_cost[i] = fuel_tank_cost[i] - fuel_tank[i]\n            break\n    print(min(fuel_tank_cost))"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split('\\n')[0].split())\n    l = [list(map(int, stdin.split('\\n')[i].split())) for i in range(1, n+1)]\n    l.sort()\n    #print(l)\n    tank = g\n    pos = 0\n    for i in l:\n        tank -= i[1]\n        if tank >= 0:\n            tank += i[0]\n            pos += i[0]\n        else:\n            break\n    if tank >= 0:\n        return pos\n    else:\n        return 'cancel road trip'\nprint(solution(input()))\n\n------Solution-----\n\nLet us define three main functions. \n\nFirstly, it is clear that we can always refuel the tank of our car by any amount of gas.\n\nThen, we can find the distance (number of gas stations) and cost (per gas station) to the rightmost gas station. The following two lines of code find this information.\n\nFinally, we can start to find the total cost of our journey. This will be the sum of costs of all gas stations till the rightmost one. The following two lines of code will find the above mentioned two numbers.\n\nNote that all the costs are added to the left of the tank.\n\ndef"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, g = [int(x) for x in stdin.split('\\n')[:2]]\n    dist, cost = [[int(x) for x in stdin.split('\\n')[i].split('\\t')] for i in range(2, n + 2)]\n    total_cost = 0\n    for i in range(n):\n        while g < dist[i]:\n            g += cost[i]\n            total_cost += cost[i]\n            if g > dist[i]:\n                return 'cancel road trip'\n        g -= dist[i]\n    return total_cost"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    pass\n"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum cost of reaching the rightmost gas station by refueling the car.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Output string\n    \"\"\"\n    n, g = map(int, stdin.split())\n    dist, cost = [], []\n    for _ in range(n):\n        di, ci = map(int, stdin.split())\n        dist.append(di)\n        cost.append(ci)\n\n    return get_minimum_cost(dist, cost, g, 0, 0)\n\ndef"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    d, c = [], []\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        d.append(a)\n        c.append(b)\n\n    d.sort()\n    c.sort()\n    i, j = 0, n - 1\n    min_cost = 0\n    while i < n:\n        if d[i] <= g:\n            min_cost += c[i]\n            g -= d[i]\n            i += 1\n        else:\n            break\n    if g!= 0:\n        return 'cancel road trip'\n    else:\n        return min_cost"
    },
    {
        "number": 3075,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split('\\n')[0].split())\n    g_list = [int(stdin.split('\\n')[i].split()[1]) for i in range(n)]\n    g_list.sort()\n    d_list = [int(stdin.split('\\n')[i].split()[0]) for i in range(n)]\n    d_list.sort()\n    for i in range(n):\n        if g_list[i] * d_list[i] <= g:\n            g -= g_list[i] * d_list[i]\n        else:\n            return \"cancel road trip\"\n    return sum(d_list)\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 9\\n2 8\\n1 1\\n3 4\\n5 100')\n    '1 8 9 9 100 101 108 109 109'\n    \"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    jewels = []\n    for _ in range(n):\n        s, v = [int(x) for x in stdin.split()]\n        jewels.append((s, v))\n    jewels.sort(reverse=True)\n    dp = [0] * k\n    for i, (s, v) in enumerate(jewels):\n        for j in range(k):\n            if j - s >= 0:\n                dp[j] = max(dp[j], dp[j - s] + v)\n    return''.join([str(x) for x in dp])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # \u6b64\u89e3\u6cd5\u4e0d\u901a\n    # n, m = stdin.split(\" \")\n    # dp = [[0] * (int(m) + 1) for _ in range(int(n) + 1)]\n    # for _ in range(int(n)):\n    #     for i in range(int(m) + 1):\n    #         dp[i][0] = 0\n    #         dp[0][i] = 0\n    #     s, v = stdin.split(\" \")\n    #     for i in range(int(s), int(m) + 1):\n    #         for j in range(int(s), int(m) + 1):\n    #             dp[i][j] = max(dp[i][j], dp[i - int(s)][j] + int(v))\n    # print(\" \".join(str(x) for x in dp[int(m)][int(m):0:-1]))\n\n    # dp[i][j] : i\u4ef6\u7269\u54c1\u53ef\u4ee5\u653e\u5165j\u679a\u4ee5\u4e0b\u306e\u80cc\u5305\u3002\u7e26\u3001\u6a2a\u3068\u3082\u306b\u884c\u304d\u7740\u3051\u308b\u3002\n    # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - s] + v)\n\n    # \u6b63\u89e3\n    n, k = stdin.split(\" \")\n    n, k = int(n), int(k)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    w, v = [], []\n    for _ in range(n):\n        s, v_ = stdin.split(\" \")\n        w.append(int(s))\n        v.append(int(v_))\n    for i in range(n):\n        for j in range(k + 1):\n            if j >= w[i]:\n                dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i])\n            else:\n                dp[i + 1][j] = dp[i][j]\n    print(\" \".join(str(x) for x in dp[n][k:0:-1]))\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # create a list of tuples with (size, value)\n    jewel_list = []\n    for i, line in enumerate(stdin.readlines()):\n        # only take first 2 characters (size)\n        size = int(line[0:2])\n        # only take last 2 characters (value)\n        value = int(line[-2:])\n        jewel_list.append((size, value))\n\n    jewel_list = sorted(jewel_list, key=lambda x: x[1])\n\n    # create a list of knapsacks\n    knapsacks = []\n    for i in range(1, int(stdin.readline()) + 1):\n        knapsacks.append(Knapsack(i))\n\n    jewel_list = sorted(jewel_list, key=lambda x: x[0])\n    return Knapsack.knapsack_search(knapsacks, jewel_list)\n\n\n\nclass Knapsack:\n    def __init__(self, capacity: int):\n        self.knapsack = []\n        self.knapsack.append(None)\n        self.knapsack.append(KnapsackItem(0, 0))\n        self.knapsack.append(KnapsackItem(1, 0))\n        self.knapsack.append(KnapsackItem(2, 0))\n        self.knapsack.append(KnapsackItem(3, 0))\n        self.knapsack.append(KnapsackItem(4, 0))\n        self.knapsack.append(KnapsackItem(5, 0))\n        self.knapsack.append(KnapsackItem(6, 0))\n        self.knapsack.append(KnapsackItem(7, 0))\n        self.knapsack.append(KnapsackItem(8, 0))\n        self.knapsack.append(KnapsackItem(9, 0))\n        self.knapsack.append(KnapsackItem(10, 0))\n        self.knapsack.append(KnapsackItem(11, 0))\n        self.knapsack.append(KnapsackItem(12, 0))\n        self.knapsack.append(KnapsackItem(13, 0))\n        self.knapsack.append(KnapsackItem(14, 0))\n        self.knapsack.append(KnapsackItem(15, 0))\n        self.knapsack.append(KnapsackItem(16, 0))\n        self.knapsack.append(KnapsackItem(17, 0))\n        self.knapsack.append(KnapsackItem(18, 0))\n        self.knapsack.append(KnapsackItem(19, 0))\n        self.knapsack.append(KnapsackItem(20, 0))\n        self.knapsack.append(KnapsackItem(21, 0))\n        self.knapsack.append(KnapsackItem(22, 0))\n        self.knapsack.append(KnapsackItem(23, 0))\n        self.knapsack.append(KnapsackItem(24, 0))\n        self.knapsack.append(KnapsackItem(25, 0))\n        self.knapsack.append(KnapsackItem(26, 0))\n        self.knapsack.append(KnapsackItem(27, 0))\n        self.knapsack.append(KnapsackItem(28, 0))\n        self.knapsack.append(KnapsackItem(29, 0))\n        self.knapsack.append(KnapsackItem(30, 0))\n        self.knapsack.append(KnapsackItem(31, 0))\n        self.knapsack.append(KnapsackItem(32, 0))\n        self.knapsack.append(KnapsackItem(33, 0))\n        self.knapsack.append(KnapsackItem(34, 0))\n        self.knapsack.append(KnapsackItem(35, 0))\n        self.knapsack.append(KnapsackItem(36, 0))\n        self.knapsack.append(KnapsackItem(37, 0))\n        self.knapsack.append(KnapsackItem(38, 0))\n        self.knapsack.append(KnapsackItem(39, 0))\n        self.knapsack.append(KnapsackItem(40, 0))\n        self.knapsack.append(KnapsackItem(41, 0))\n        self.knapsack.append(KnapsackItem(42, 0))\n        self.knapsack.append(KnapsackItem(43, 0))\n        self.knapsack.append(KnapsackItem(44, 0))\n        self.knapsack.append(KnapsackItem(45, 0))\n        self.knapsack.append(KnapsackItem(46, 0))\n        self.knapsack.append(KnapsackItem(47, 0))\n        self.knapsack.append(KnapsackItem(48, 0))\n        self.knapsack.append(KnapsackItem(49, 0))\n        self.knapsack.append(KnapsackItem(50, 0))\n        self.knapsack.append(KnapsackItem(51, 0))\n        self.knapsack.append(KnapsackItem(52, 0))\n        self.knapsack.append(KnapsackItem(53, 0))\n        self.knapsack.append(KnapsackItem(54, 0))\n        self.knapsack.append(KnapsackItem(55, 0))\n        self.knapsack.append(KnapsackItem(56, 0))\n        self.knapsack.append(KnapsackItem(57, 0))\n        self.knapsack.append(KnapsackItem(58, 0))\n        self.knapsack.append(KnapsackItem(59, 0))\n        self.knapsack.append(KnapsackItem(60, 0))\n        self.knapsack.append(KnapsackItem(61, 0))\n        self.knapsack.append(KnapsackItem(62, 0))\n        self.knapsack.append(KnapsackItem(61, 0))\n        "
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the max value of jewels in knapsacks of size 1, 2,...,k.\"\"\"\n    n, k = [int(x) for x in stdin.split(' ')]\n    jewels = []\n    for _ in range(n):\n        jewels.append([int(x) for x in stdin.split(' ')])\n    jewels.sort()\n    values = [0] * k\n    for j in jewels:\n        for i in range(k - 1, -1, -1):\n            if i == k - 1 or j[1] <= values[i + 1]:\n                values[i] = max(values[i], values[i + 1] + j[1])\n    return''.join([str(x) for x in values])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and print solution for the given input.\"\"\"\n    _, knapsacks = stdin.split('\\n\\n')\n    knapsacks = knapsacks.split('\\n')\n\n    # convert knapsacks to list of tuples (size, value)\n    knapsacks = list(map(lambda x: tuple(map(int, x.split())), knapsacks))\n    # compute value of each jewel\n    knapsacks = list(map(lambda x: (x[0], x[1]/x[0]), knapsacks))\n\n    # sort jewels by value\n    knapsacks.sort(key=lambda x: x[1], reverse=True)\n\n    # create list of integers representing number of jewels in knapsack\n    knapsacks = list(map(lambda x: x[0], knapsacks))\n\n    # initialize return list\n    return_list = [0 for _ in range(len(knapsacks))]\n\n    # compute value of each knapsack\n    for i in range(len(knapsacks)):\n        # compute value of current knapsack\n        value = 0\n        for j in range(i+1):\n            value += knapsacks[j]\n        # add to return list\n        return_list[i] = value\n\n    # print value of each knapsack\n    print(*return_list, sep=' ')\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds max sum of jewels for each size of knapsack\"\"\"\n    data = stdin.split(\"\\n\")\n    data.pop()\n\n    jewels = []\n    for line in data:\n        jewels.append(line.split(\" \"))\n\n    jewels = [[int(jewels[j][0]), int(jewels[j][1])] for j in range(len(jewels))]\n\n    jewels.sort()\n    jewels.reverse()\n\n    jewel_sizes = [jewels[i][0] for i in range(len(jewels))]\n\n    jewel_values = [jewels[i][1] for i in range(len(jewels))]\n\n    jewel_values = [int(jewel_values[i]) for i in range(len(jewel_values))]\n\n    total_values = []\n\n    for i in range(len(jewel_sizes) + 1):\n        total_values.append([0 for _ in range(k + 1)])\n\n    for i in range(1, len(jewel_sizes) + 1):\n        for j in range(1, k + 1):\n            total_values[i][j] = total_values[i - 1][j]\n\n            if jewel_sizes[i - 1] <= j:\n                total_values[i][j] = max(jewel_values[i - 1] + total_values[i - 1][j - jewel_sizes[i - 1]],\n                                         total_values[i - 1][j])\n\n    total_values = [int(total_values[i][k]) for i in range(len(jewel_sizes) + 1)]\n\n    return''.join(str(total_values[i]) for i in range(1, len(jewel_sizes) + 1))\n\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the maximum possible value for jewels that can be stolen from the museum.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: The maximum possible value of jewels that can be stolen from the museum.\n    \"\"\"\n    jewels: List[Tuple[int, int]] = []\n    sizes: List[int] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    for _ in range(int(stdin.split()[0])):\n        jewels.append((sizes[int(stdin.split()[1]) - 1], int(stdin.split()[2])))\n    jewels.sort(reverse=True)\n    results: List[int] = [0] * len(sizes)\n    for jewel in jewels:\n        for i in range(len(sizes)):\n            if jewel[0] <= sizes[i]:\n                results[i] += jewel[1]\n                sizes[i] = jewel[0]\n                break\n    return \" \".join([str(i) for i in results])\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, k = list(map(int, stdin.split()))\n    jewels = []\n    for _ in range(n):\n        size, value = list(map(int, stdin.split()))\n        jewels.append((size, value))\n    jewels.sort()\n    d = [0 for _ in range(k+1)]\n    d[1] = jewels[0][1]\n    for jewel in jewels:\n        for j in range(1, k+1):\n            if jewel[0] <= j:\n                d[j] = max(d[j], d[j-jewel[0]] + jewel[1])\n    print(' '.join(map(str, d)))\n    return ''\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds maximum value of jewels for each knapsack.\n\n    Time complexity: O(n*k^2)\n    Space complexity: O(k^2)\n    \"\"\"\n    lines = stdin.strip().split(\"\\n\")\n    n, k = map(int, lines[0].split())\n    jewels = []\n    for line in lines[1:]:\n        jewels.append(tuple(map(int, line.split())))\n\n    max_values = [0] * k\n    for i in range(n):\n        for j in range(k):\n            if jewels[i][0] <= j + 1:\n                max_values[j] = max(jewels[i][1] + max_values[j - jewels[i][0]], max_values[j])\n\n    return \" \".join(map(str, max_values))\n"
    },
    {
        "number": 3076,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the max value of jewels that can be stolen.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution string\n    \"\"\"\n    return''.join([str(x) for x in [max(sum(int(i) for i in stdin.split()) // i, i) for i in range(1, k + 1)]])\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split('\\n')[:3])\n    villages = [map(int, x.split(' ')) for x in stdin.split('\\n')[3:3 + n]]\n    minions = [map(int, x.split(' ')) for x in stdin.split('\\n')[3 + n:]]\n\n    def inCircle(x, y):\n        return sum([(x - v[0]) ** 2 + (y - v[1]) ** 2 <= v[2] ** 2 for v in villages]) == len(villages)\n\n    def inVillage(x, y):\n        return any([sum([(x - m[0]) ** 2 + (y - m[1]) ** 2 <= m[2] ** 2 for m in minions])])\n\n    def notTouch(x, y):\n        return not any([x + r <= v[0] or x - r >= v[0] or y + r <= v[1] or y - r >= v[1] for v in villages])\n\n    def inRange(x, y):\n        return not any([not inCircle(x, y), not inVillage(x, y)])\n\n    answer = 0\n    for x in range(-r, r + 1):\n        for y in range(-r, r + 1):\n            if inRange(x, y) and notTouch(x, y):\n                answer += 1\n    return answer\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # Return your answer\n    pass\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # use a graph to represent the villages\n    # graph[(x1, y1)] = [(x2, y2),..., (xn, yn)]\n    # graph[(x, y)] represents a circle with radius r\n    # if (x1, y1) and (x2, y2) is not in graph, then (x1, y1) and (x2, y2) are not in any circle\n    # if (x, y) is in graph, then (x, y) is in one of the circles\n\n    graph = dict()\n    # read input\n    n, m, r = [int(x) for x in stdin.split()]\n    # create graph\n    for i in range(n):\n        for j in range(n):\n            if (i, j) not in graph:\n                # add this village to graph\n                graph[(i, j)] = []\n                # check all other villages in this circle\n                for k in range(n):\n                    if i!= k and j!= k:\n                        # check if (i, j) and (k, k) is not in graph\n                        if (i, j) not in graph[(k, k)]:\n                            # add them to graph\n                            graph[(i, j)].append((k, k))\n    # read input\n    for i in range(m):\n        x, y, r = [int(x) for x in stdin.split()]\n        # check if this minion is in graph\n        if (x, y) in graph:\n            # remove this minion from graph\n            del graph[(x, y)]\n            # check if (x, y) has other villagers\n            for v in graph[(x, y)]:\n                # remove (x, y) from their circle\n                graph[v].remove((x, y))\n                # check if there is another circle that contains (x, y)\n                if len(graph[v]) == 0:\n                    # remove this circle from graph\n                    del graph[v]\n    # find the circle that contains the maximum number of villagers\n    ans = 0\n    for k, v in graph.items():\n        if len(v) > ans:\n            ans = len(v)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    pass"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    m, n, r = [int(x) for x in stdin.split()]\n    x, y, r = [int(x) for x in stdin.split()]\n    # Find all points within radius r\n    points = []\n    for i in range(-r, r + 1):\n        for j in range(-r, r + 1):\n            if i * i + j * j <= r * r:\n                points.append((i, j))\n    print(points)\n    count = 0\n    # For each point\n    for i in points:\n        # Check if in bounds\n        if not (0 <= x + i[0] <= m and 0 <= y + i[1] <= n):\n            continue\n        # Check if in village\n        if (x + i[0], y + i[1]) in points:\n            continue\n        # Check if in radius\n        if r < abs(i[0] + i[1]):\n            continue\n        count += 1\n\n    return count\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = [int(num) for num in stdin.split()]\n    n, m, r = input_list[0], input_list[1], input_list[2]\n    village = []\n    for i in range(n):\n        village.append([int(num) for num in stdin.split()[i + 2: i + 4]])\n\n    minions = []\n    for j in range(m):\n        minions.append([int(num) for num in stdin.split()[j + 2 * n + 2: j + 2 * n + 4]])\n    res = 0\n    for k in range(n):\n        x1, y1, r1 = village[k][0], village[k][1], village[k][2]\n        for l in range(m):\n            x2, y2, r2 = minions[l][0], minions[l][1], minions[l][2]\n            d = ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) ** 0.5\n            if d == 0:\n                if r1 == 0 or r2 == 0:\n                    res += 1\n                elif r1 <= r2 or r1 > r:\n                    res += 1\n                continue\n            if r1 > r2 and d > r2:\n                res += 1\n    print(res)\n"
    },
    {
        "number": 3077,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # 1. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u0430\u0440\u0435\u0433\u0430\u043d\u043d\u044b\u0445 \u0432 \u043a\u0430\u0436\u0434\u043e\u043c \u0438\u0437 \u0432\u043e\u0441\u044c\u043c\u0438 \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043f\u0440\u043e\u0432\u043e\u0434\u044f\u0442\u0441\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u0440\u0435\u0433\u0430\u043d\u043d\u044b\u0445\n    # 2. \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043c\u043e\u043d\u0435\u0442 \u0432 \u043d\u0430\u0431\u043e\u0440\u0435\n    # 3. \u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0438\u0430\u043c\u0435\u0442\u0440 \u043c\u0438\u043d\u044c\u043e\u043d\u0430\n    # 4. \u041f\u0435\u0440\u0435\u0431\u043e\u0440 \u0432\u0441\u0435\u0445 \u043c\u043e\u043d\u0435\u0442 \u0438\u0437 \u043d\u0430\u0431\u043e\u0440\u0430\n    # 5. \u0415\u0441\u043b\u0438 \u043c\u043e\u043d\u0435\u0442\u0430 \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0430 \u043d\u0430 \u043c\u0438\u043d\u044c\u043e\u043d\u0435, \u0442\u043e \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0443 \u0437\u0430\u0440\u0435\u0433\u0430\u043d\u043d\u044b\u0445 \u0432 \u0432\u043e\u0441\u044c\u043c\u0438 \u043d\u0430\u0431\u043e\u0440\u0430\u0445, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u043d\u0430 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f\n    # 6. \u0415\u0441\u043b\u0438 \u043c\u043e\u043d\u0435\u0442\u0430 \u043d\u0435 \u0440\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0430 \u043d\u0430 \u043c\u0438\u043d\u044c\u043e\u043d\u0435, \u0442\u043e \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0443 \u0437\u0430\u0440\u0435\u0433\u0430\u043d\u043d\u044b\u0445 \u0432 \u0432\u043e\u0441\u044c\u043c\u0438 \u043d\u0430\u0431\u043e\u0440\u0430\u0445, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u043d\u0430 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f\n    # 7. \u0421\u0440\u0430\u0432\u043d\u0438\u0432\u0430\u0435\u043c \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0438 \u0432\u044b\u0431\u0438\u0440\u0430\u0435\u043c \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435\n    pass"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # the sum of elements is calculated\n    # then, the sum of the first K elements and the last K elements\n    # if the sum of the first K elements and the last K elements is < S, then the whole sequence is not interesting\n    # otherwise, the longest interesting subsequence starts with the current element\n    # for example, if we have a sequence of length 5 and the sum of the first 4 elements is 8\n    # and the sum of the last 4 elements is 4, then the whole sequence is not interesting, so the longest subsequence starts with the 4th element\n    # and the rest of the sequence is not interesting either\n    # if we have a sequence of length 5 and the sum of the first 4 elements is 8\n    # and the sum of the last 4 elements is 4, then the longest subsequence starts with the 5th element\n    # because the sum of the first 4 elements + the sum of the last 4 elements is 10,\n    # which is greater than 8, so the longest interesting subsequence starts with the 5th element and the rest of the sequence is not interesting either\n    # if the sum of the first 4 elements is 8\n    # and the sum of the last 4 elements is 4, then the longest interesting subsequence starts with the 5th element\n    # because the sum of the first 4 elements + the sum of the last 4 elements is 10,\n    # which is greater than 8, so the longest interesting subsequence starts with the 5th element and the rest of the sequence is not interesting either\n    N, S = map(int, stdin.split('\\n')[:2])\n    A = [int(stdin.split('\\n')[i + 1]) for i in range(N)]\n    sum_A = sum(A)\n    sum_A_first_k = sum(A[:K])\n    sum_A_last_k = sum(A[-K:])\n    if (sum_A_first_k + sum_A_last_k) > S:\n        print(0)\n        return\n    # print(sum_A, sum_A_first_k, sum_A_last_k)\n    print(1)\n    print(max([len(A[:i]) for i in range(1, N) if (sum(A[:i]) + sum(A[-i:])) <= S] + [0]))\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = [int(i) for i in stdin.split()]\n    dp = [0 for i in range(N)]\n    curr = 0\n    for i in range(N):\n        if curr + A[i] > S:\n            dp[i] = 0\n        elif curr + A[i] == S:\n            dp[i] = 1\n        else:\n            dp[i] = max(dp[i], dp[i - 1] + 1) if i - 1 >= 0 else 1\n        curr += A[i]\n    if curr!= S:\n        dp[i] = 0\n    else:\n        dp[i] = 1\n    print(max(dp))\n    return \"\"\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the solution of the challenge.\n\n    Parameters\n    ----------\n    stdin : str\n        The standard input of the challenge.\n\n    Returns\n    -------\n    str\n        The solution of the challenge.\n    \"\"\"\n    lines = stdin.splitlines()\n    n, s = int(lines[0]), int(lines[1])\n    seq = [int(seq) for seq in lines[2:n + 2]]\n    nums = [sum(seq[:i]) for i in range(1, n + 1)]\n    nums.extend([sum(seq[i:]) for i in range(n)])\n    res = [0] * n\n    for i in range(n):\n        for j in range(n - i):\n            if nums[i] < nums[i + j + 1]:\n                break\n            res[i] = max(res[i], j + 1)\n    print('\\n'.join(str(i) for i in res))\n    return ''\n\n\ndef"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n) / O(n)\"\"\"\n    n, s = map(int, stdin.split('\\n')[:2])\n    assert 2 <= n <= 100_000\n    assert 1 <= s <= 2_098_098_999\n\n    a = list(map(int, stdin.split('\\n')[2:]))\n    assert len(a) == n\n\n    sums = [0] * n\n    sums[0] = a[0]\n    for i in range(1, n):\n        sums[i] = sums[i-1] + a[i]\n    sums.sort()\n\n    # print(sums)\n    res = []\n    for i in range(n):\n        l, r = i - 1, i + 1\n        while l >= 0 and r < n:\n            if sums[l] < s < sums[r]:\n                res.append(r - l)\n                break\n            elif sums[l] > s:\n                r += 1\n            else:\n                l -= 1\n        else:\n            res.append(0)\n    return '\\n'.join(map(str, res))\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''Gets the longest interesting subsequence'''\n    S, K = map(int, stdin.split(' '))\n    \n    result = [0] * len(stdin)\n    for i in range(len(stdin)):\n        result[i] = 0\n        \n        for j in range(i):\n            if sum(stdin[j:i]) <= K:\n                result[i] = max(result[i], result[j] + 1)\n            else:\n                result[i] = max(result[i], result[j])\n                \n    return max(result)\n        "
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time complexity: O(N)\n    Space complexity: O(N)\n    \"\"\"\n    S, K = [int(x) for x in stdin.split(\"\\n\")[:2]]\n    A = [int(x) for x in stdin.split(\"\\n\")[2:]]\n    \n    P = [0] * len(A)\n    \n    for i in range(K - 1, len(A)):\n        P[i] = max(P[j] + 1 for j in range(i - K + 1, i) if A[j] <= A[i] and S - A[j] <= A[i])\n    \n    return \"\\n\".join(str(len(A) - i - 1) for i in range(len(A)) if P[i] < K)\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds longest interesting subsequence in given sequence.\n\n    Args:\n        stdin (str): Input from stdin\n\n    Returns:\n        str: Output from stdout\n    \"\"\"\n    total_size = stdin.split(\"\\n\")[0].split()\n    total_size = [int(x) for x in total_size]\n\n    total_sum = total_size[1]\n\n    list_of_numbers = []\n    for line in stdin.split(\"\\n\")[1:]:\n        list_of_numbers.append(int(line))\n\n    def get_list_of_subsequences(list_of_numbers: list,\n                                 index: int) -> list:\n        \"\"\"Returns list of subsequences of length 2, starting at given index.\n\n        Args:\n            list_of_numbers (list): List of numbers\n            index (int): Index at which to start subsequences\n\n        Returns:\n            list: List of all possible subsequences\n        \"\"\"\n        list_of_subsequences = []\n\n        # Creates two separate lists: one of integers starting from given index\n        # and one of integers starting from index + 1\n        subsequence_of_numbers = list_of_numbers[index:index + 2]\n        subsequence_of_numbers_2 = list_of_numbers[index + 1:index + 3]\n        subsequence_of_numbers.sort(reverse=True)\n        subsequence_of_numbers_2.sort(reverse=True)\n\n        # Iterates through lists until either one is empty\n        while len(subsequence_of_numbers) > 0 and len(subsequence_of_numbers_2) > 0:\n            # If sequences have not crossed each other yet, add them\n            if subsequence_of_numbers[0] + subsequence_of_numbers_2[0] < total_sum:\n                list_of_subsequences.append(\n                    subsequence_of_numbers + subsequence_of_numbers_2)\n            # If one has crossed the other, add only the smaller of the two\n            if subsequence_of_numbers[0] + subsequence_of_numbers_2[0] > total_sum:\n                if len(subsequence_of_numbers) > len(subsequence_of_numbers_2):\n                    list_of_subsequences.append(\n                        subsequence_of_numbers + subsequence_of_numbers_2)\n                    break\n                else:\n                    list_of_subsequences.append(\n                        subsequence_of_numbers_2 + subsequence_of_numbers)\n                    break\n            # If sequences have crossed each other, break\n            if subsequence_of_numbers[0] + subsequence_of_numbers_2[0] == total_sum:\n                break\n            # Once sequences have crossed each other, add smaller of the two\n            if len(subsequence_of_numbers) < len(subsequence_of_numbers_2):\n                if len(subsequence_of_numbers) > 1:\n                    list_of_subsequences.append(\n                        subsequence_of_numbers + subsequence_of_numbers_2)\n                    break\n                else:\n                    list_of_subsequences.append(\n                        subsequence_of_numbers + subsequence_of_numbers_2)\n                    break\n            else:\n                list_of_subsequences.append(\n                    subsequence_of_numbers + subsequence_of_numbers_2)\n                break\n\n        return list_of_subsequences\n\n    # Creates dictionary of subsequences and their lengths\n    dict_of_subsequences = {}\n    for index in range(0, total_size[0]):\n        list_of_subsequences = get_list_of_subsequences(\n            list_of_numbers, index)\n        if list_of_subsequences:\n            dict_of_subsequences[index] = []\n            for element in list_of_subsequences:\n                if sum(element) <= total_sum:\n                    dict_of_subsequences[index].append(len(element))\n        else:\n            dict_of_subsequences[index] = 0\n\n    # Creates list of lengths of longest subsequences\n    list_of_longest_subsequences = []\n    for key in dict_of_subsequences.keys():\n        if dict_of_subsequences[key]:\n            list_of_longest_subsequences.append(\n                max(dict_of_subsequences[key]))\n        else:\n            list_of_longest_subsequences.append(0)\n\n    return list_of_longest_subsequences\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the length of the longest interesting subsequence.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string of the puzzle\n\n    Returns\n    -------\n    str\n        The answer to the puzzle.\n    \"\"\"\n\n    #   split the input into a list of integers\n    stdin = stdin.split()\n    n, s = int(stdin[0]), int(stdin[1])\n\n    #   extract the sequence\n    sequence = [int(i) for i in stdin[2:]]\n\n    #   determine the longest interesting subsequence for each index\n    longest_subseq = [0] * n\n    for i in range(n):\n        sums = []\n        for j in range(i + 1):\n            sums.append(sum(sequence[j:i + 1]))\n        longest_subseq[i] = max([sum(sequence[:i + 1]), sum(sequence[i + 1:]), max(sums)])\n\n    #   output the solution\n    return '\\n'.join(map(str, longest_subseq))\n"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return longest interesting subsequence length.\"\"\"\n    # TODO: complete the solution\n    n, s = [int(i) for i in stdin.split(' ')]\n    seq = [int(i) for i in stdin.split('\\n')[1:]]\n    start = 0\n    end = n - 1\n    longest = 0\n    for i in range(n):\n        if sum(seq[start:i]) <= s:\n            curr = i - start\n            if curr > longest:\n                longest = curr\n        if sum(seq[i:end+1]) <= s:\n            curr = end - i\n            if curr > longest:\n                longest = curr\n    return longest"
    },
    {
        "number": 3078,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.split()\n    N, S = int(S[0]), int(S[1])\n    A = list(map(int, stdin.split()[1:]))\n    ans = []\n    for i in range(N):\n        s = sum(A[i:i+S])\n        if s <= S:\n            ans.append(S)\n        else:\n            ans.append(0)\n    return \"\\n\".join(map(str, ans))\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    len_stdin = len(stdin)\n    if len_stdin == 0:\n        return \"NE\"\n    if len_stdin == 1:\n        return \"DA\"\n    if len_stdin % 2 == 0:\n        return \"DA\"\n    return \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    letters = list(stdin)\n    A = []\n    while letters:\n        A.append(letters.pop(0))\n        if letters:\n            A.append(letters.pop())\n    print(A)\n    A.sort()\n    print(A)\n    if N % 2 == 1:\n        A.append(\"\")\n    print(A)\n    max = 0\n    for i in range(0, len(A), 2):\n        s = A[i] + A[i + 1]\n        s_ = A[i + 1] + A[i]\n        if s > max:\n            max = s\n        if s_ > max:\n            max = s_\n    return max\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s: str = stdin\n    n: int = int(s)\n    if n % 2!= 0:\n        return \"DA\"\n    c: int = 0\n    while len(s) > 0:\n        if s[0] == \"n\":\n            c += 1\n        s = s[1:]\n    if c % 2 == 0:\n        return \"DA\"\n    return \"NE\"\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    s = stdin\n    if N % 2 == 1:\n        return \"DA\"\n    elif N % 2 == 0:\n        pass\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the solution to the mirror problem\n    :param stdin: the input\n    :return: the solution\n    \"\"\"\n    count = len(stdin)\n    data = stdin.split()\n    ans = 'NE'\n\n    for i in range(1, count):\n        last = ''.join(data[-i:])\n        ans = max(ans, last) if last < ans else ans\n\n    return ans"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Calculates whether it is possible for Slavko to win and which is the most beautiful word he can end the game with.\n    '''\n    print('DA' if stdin.endswith('ne') else 'NE')\n    print(min(stdin[:len(stdin) - 1], key=lambda x: x.lower()))\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    c = list(s)\n    ans = 0\n    for i in range(n):\n        c.append(c.pop(c.index(max(c))))\n        if c[-1] >= c[-2]:\n            ans += 1\n        else:\n            ans = 0\n        if ans == 3:\n            return \"DA\"\n    return \"NE\"\n\n\nprint(solution(stdin.read()))\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\"\"\"\n\nN = int(input())\ns = input()\n\ndict = {}\n\nfor c in s:\n    if c not in dict:\n        dict[c] = 0\n    dict[c] += 1\n\nkeys = list(dict.keys())\n\nmax_count = -1\ncur_count = 0\nfor key in keys:\n    if dict[key] > max_count:\n        max_count = dict[key]\n        cur_count = 1\n        break\n    else:\n        cur_count += 1"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return 'NE'\n\n    sequence = stdin[:N]\n    # build the array of letters from the beginning\n    # (begin with the first one to make a word)\n    letters = [sequence[i] for i in range(N)]\n\n    # start from the end\n    i = N - 1\n    word = ''\n\n    while i >= 0:\n        # add the letter to the word and remove it from the sequence\n        word += letters[i]\n        letters.pop(i)\n        # check if the new word is greater than the current best one\n        if word > max(letters):\n            # if so, return it\n            return word\n        # otherwise, let's try again with the removed letter\n        i -= 1\n\n    return 'DA'\n"
    },
    {
        "number": 3079,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    word = stdin[:n]\n    dict_word = dict()\n    for char in word:\n        if char in dict_word.keys():\n            dict_word[char] += 1\n        else:\n            dict_word[char] = 1\n    while True:\n        dict_word[word[-1]] -= 1\n        if dict_word[word[-1]] == 0:\n            dict_word.pop(word[-1])\n        if len(dict_word.keys()) == 0:\n            return \"DA\"\n        word += word[0]\n        dict_word[word[0]] += 1\n        if word[0] not in dict_word.keys():\n            dict_word[word[0]] = 1\n        if len(dict_word.keys()) == 1:\n            return word\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return number of ways to select a set of snack stands.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution to the problem\n    \"\"\"\n    n, m, q = [int(x) for x in stdin.split(\" \")]\n    max_area_id = n\n    hill = [[None] * (n + 1) for _ in range(n + 1)]\n    visited = [0] * (n + 1)\n    for i in range(m):\n        x, y = [int(x) for x in stdin.split(\" \")]\n        hill[x][y] = 1\n        hill[y][x] = 1\n    for i in range(1, n + 1):\n        if not hill[1][i]:\n            break\n        visited[i] = 1\n    for i in range(1, q):\n        k, a = [int(x) for x in stdin.split(\" \")]\n        a_set = set()\n        for j in range(1, a + 1):\n            a_set.add(int(stdin.split(\" \")[j]))\n        res = set()\n        for j in range(1, max_area_id + 1):\n            if hill[1][j]:\n                res.add(j)\n        for j in a_set:\n            for k in range(1, max_area_id + 1):\n                if hill[j][k]:\n                    res.add(k)\n        if len(res) < k:\n            print(0)\n        else:\n            print(len(res))\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution.\"\"\"\n    pass  # remove pass and replace with your code\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\n    # n, m, q = map(int, stdin.split())\n    n, m, q = 4, 4, 4\n    # xs, ys = map(int, stdin.split() for _ in range(m))\n    xs, ys = 1, 2\n    k = 1\n    areas = list(map(int, stdin.split()))\n    # queries = []\n    # for _ in range(q):\n    #     k, *queries = map(int, stdin.split())\n    #     queries = queries[:k]\n\n    # convert all lists to sets\n    areas = set(areas)\n    queries = [set(map(int, stdin.split())) for _ in range(q)]\n\n    # print(f'{k=}\\n{queries=}')\n\n    # initialise answer\n    ans = []\n    for query in queries:\n        # initialise variable\n        count = 0\n        for area in areas:\n            if area in query:\n                count += 1\n\n        ans.append(count)\n\n    return \"\\n\".join(str(x) for x in ans)\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split(' '))\n    area_dict = {}\n    for i in range(1, n+1):\n        area_dict[i] = [0, 0, 0]\n    for i in range(m):\n        a, b = map(int, stdin.split(' '))\n        area_dict[a][1] = b\n        area_dict[b][0] = a\n    for i in range(q):\n        k, a = map(int, stdin.split(' '))\n        area_dict[a][2] = k\n    for i in range(m):\n        if area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_dict[area_"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution to the problem.\n    \"\"\"\n    # Modify the code below.\n    # Parse the input\n    n, m, q = map(int, stdin.split())\n    clients = []\n    for i in range(m):\n        x, y = map(int, stdin.split('\\n')[i].split())\n        clients.append((x, y))\n    queries = []\n    for i in range(q):\n        k, *areas = map(int, stdin.split('\\n')[i].split())\n        queries.append((k, areas))\n\n    # Write your code below\n    # Optimize your code.\n    # See how many ways can be calculated for each query\n    # Write the answer on a new line\n    pass"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string containing the answer to the problem\"\"\"\n   ...\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find number of ways to assign food to snack stands\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(input_string)\n    output\n    \"\"\"\n    n, m, q = [int(x) for x in stdin.split()]\n    assert 1 <= n <= 10 ** 5\n    assert 1 <= m <= n + 50\n    assert 1 <= q <= 10 ** 5\n\n    arr = [[0] * (n + 1) for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = [int(x) for x in stdin.split()]\n        assert 1 <= x <= n\n        assert 1 <= y <= n\n        arr[x][y] = arr[y][x] = 1\n\n    for _ in range(q):\n        k, a = [int(x) for x in stdin.split()]\n        assert 1 <= k <= 4\n        assert 1 <= a <= n\n\n        ret = 0\n        for i in range(k, n + 1):\n            for j in range(1, n + 1):\n                if arr[i][j] == 1 and arr[i][a]:\n                    ret += 1\n        print(ret)\n\n    return None\n\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://app.codility.com/demo/results/trainingNWKZ2U-28T/\"\"\"\n    n, m, q = [int(c) for c in stdin.split()]\n    runs = {(int(r.split()[0]), int(r.split()[1])) for r in stdin.split('\\n')[:m]}\n    queries = [tuple(map(int, r.split()[2:])) for r in stdin.split('\\n')[m:]]\n    g = {(i, q): set() for i in range(1, n + 1) for q in range(1, q + 1)}\n    for a, b in runs:\n        for i in range(1, n + 1):\n            if i == a:\n                g[(i, b)].add((1, a))\n            elif i == b:\n                g[(a, b)].add((b, i))\n            else:\n                g[(a, i)].add((i, b))\n                g[(b, i)].add((i, a))\n    dist = {i: n for i in range(1, n + 1)}\n    for q in queries:\n        q = set(q)\n        dist_ = dist.copy()\n        for i in range(1, n + 1):\n            for j in q:\n                dist_[j] = min(dist[j], dist_[j])\n                for k, p in g[(i, j)]:\n                    if k!= i and k!= j:\n                        dist_[k] = min(dist_[k], dist[p] + 1)\n        for j in q:\n            if dist[j] == dist_[j]:\n                break\n        else:\n            print(0)\n            continue\n        for j in q:\n            if dist[j]!= dist_[j]:\n                break\n        else:\n            print(1)\n            continue\n        print(0)"
    },
    {
        "number": 3080,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the solution for the problem.\n\n    Args:\n        stdin (str): The standard input of the problem.\n\n    Returns:\n        str: The solution to the problem.\n    \"\"\"\n    lines = stdin.split('\\n')\n    n, m, q = map(int, lines[0].split(' '))\n    mountain = lines[1:1 + m]\n    runs = []\n    for line in mountain:\n        start, end = map(int, line.split(' '))\n        runs.append((start, end))\n    queries = lines[m + 1:]\n    results = []\n    for query in queries:\n        k, a = map(int, query.split(' '))\n        count = 0\n        for run in runs:\n            if run[0] == 1:\n                if k == 1:\n                    if a == run[1]:\n                        count += 1\n                else:\n                    for x in range(run[0] - 1, run[1]):\n                        if a == x + 1:\n                            count += 1\n                            break\n            else:\n                if k == 1:\n                    if a == run[0]:\n                        count += 1\n                else:\n                    for x in range(run[0] - 1, run[1]):\n                        if a == x + 1:\n                            count += 1\n                            break\n        results.append(count)\n    return '\\n'.join(map(str, results))\n\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the minimum number of planes necessary to fly the flights\n    :param stdin: input\n    :return: minimum number of planes needed to fly the flights\n    \"\"\"\n    n, m = [int(x) for x in stdin.split(' ')]\n    t = [int(x) for x in stdin.split(' ')]\n    t.sort()\n    dp = [0 for x in range(n)]\n    dp[0] = 1\n    for i in range(1, n):\n        dp[i] = dp[i-1] + 1\n        for j in range(i):\n            if t[i] >= t[j] and dp[i] <= dp[j]:\n                dp[i] = dp[j] + 1\n    return dp[-1]\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # set up data\n    n, m = map(int, stdin.readline().split())\n    dist = list(map(int, stdin.readline().split()))\n    flight_set = set()\n    for _ in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        flight_set.add((a, b, c))\n\n    # write code here\n    dist.sort()\n    plan = dist[0]\n    for i in range(1, n):\n        plan += dist[i]\n    return plan"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    # INPUT\n    n, m = map(int, stdin.readline().split())\n    # n: Number of airports\n    # m: Number of flights\n    # Time: O(n^2)\n    # Space: O(n^2)\n    dist = [[0 for _ in range(n)] for _ in range(n)]\n    for _ in range(n):\n        arr = [int(item) for item in stdin.readline().split()]\n        for i in range(n):\n            dist[i][i] = arr[i]\n    for _ in range(m):\n        s, f, t = map(int, stdin.readline().split())\n        dist[s - 1][f - 1] = t\n        dist[f - 1][s - 1] = t\n    # OUTPUT\n    visited = [False for _ in range(n)]\n    visited[0] = True\n    minNum = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        for j in range(n):\n            if visited[j]:\n                continue\n            minNum += dist[i][j]\n            visited[j] = True\n    return minNum\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\ndef"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \n    def update(airplanes: set, current: tuple, next: tuple, min_airplanes: int):\n        if current not in planes:\n            airplanes.add(current)\n            return 0\n        else:\n            airplanes.remove(current)\n            time = next[0] - current[0] + current[1] - next[1]\n            if time > 0:\n                new = (next[0], next[1] + time)\n                min_airplanes = update(airplanes, new, next, min_airplanes)\n            new = (current[0], current[1] + time)\n            min_airplanes = update(airplanes, new, next, min_airplanes)\n            return min_airplanes\n\n    n, m = map(int, stdin.readline().split())\n    airplanes = set()\n    for _ in range(n):\n        minutes = list(map(int, stdin.readline().split()))\n        for i in range(len(minutes) - 1):\n            for j in range(i + 1, len(minutes)):\n                airplanes = update(airplanes, (minutes[i], minutes[j]), (minutes[j], minutes[i]), m)\n    return len(airplanes)\n"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    mapp = [list(map(int, stdin.split('\\n')[i].split(' '))) for i in range(n)]\n    mapp = [list(map(int, stdin.split('\\n')[i].split(' '))) for i in range(n)]\n    # print(mapp)\n    mem = {}\n    def dp(n, m):\n        if n == 0 or m == 0:\n            return 0\n        if (n, m) in mem:\n            return mem[(n, m)]\n        mem[(n, m)] = dp(n-1, m)\n        if n-1 >= m:\n            mem[(n, m)] = min(mem[(n, m)], dp(n-1, m) + mapp[n-1][m])\n        if n-1 >= m:\n            mem[(n, m)] = min(mem[(n, m)], dp(n-1, m) + mapp[n-1][m])\n        mem[(n, m)] = min(mem[(n, m)], dp(n, m-1))\n        return mem[(n, m)]\n    print(dp(n, m))"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3081,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    solution\n    '''\n    # get input\n    n, m = list(map(int, stdin.split()))\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, stdin.split())))\n    b = []\n    for _ in range(m):\n        b.append(list(map(int, stdin.split())))\n\n    # do math\n    c = []\n    for i in range(n):\n        c.append([])\n        for j in range(n):\n            c[i].append(a[i][j] + b[i][0])\n\n    # get result\n    result = float('inf')\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if c[i][j] > c[i][k] + c[k][j]:\n                    result = min(result, c[i][j] + c[j][k] + c[k][i])\n    print(result)\n\n\ndef"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/55bf01e5d758534ff3000035\"\"\"\n   ..."
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the maximum total tastiness of a meal of weight $w$ based on the available dishes.\n    :param stdin: the input as a string\n    :return: the maximum total tastiness of a meal of weight $w$ based on the available dishes\n    \"\"\"\n    # Parse the input\n    dishes, w = tuple(map(int, stdin.split(\" \")))\n    tastiness_dict = {}\n    for i in range(dishes):\n        ingredients = input().split()\n        tastiness, decay = int(ingredients[2]), int(ingredients[3])\n        tastiness_dict[ingredients[1]] = (tastiness, decay)\n\n    # Get the maximum tastiness of a discrete dish\n    def discrete_tastiness(tastiness_dict: dict, w: int, t: int, decay: int) -> int:\n        \"\"\"Computes the maximum total tastiness of a discrete dish with initial tastiness $t$, decay of tastiness $\\Delta t$, and a weight of $w$.\n        :param tastiness_dict: a dictionary mapping ingredients to their tastiness\n        :param w: the weight of the dish\n        :param t: the initial tastiness of the dish\n        :param decay: the decay of the dish\n        :return: the maximum total tastiness of a discrete dish with initial tastiness $t$, decay of tastiness $\\Delta t$, and a weight of $w$\n        \"\"\"\n        tastiness_sum = 0\n        for i in range(1, w+1):\n            tastiness_sum += t - (i - 1) * decay\n        return tastiness_sum\n\n    # Get the maximum tastiness of a continuous dish\n    def continuous_tastiness(tastiness_dict: dict, w: int, t: int, decay: int) -> int:\n        \"\"\"Computes the maximum total tastiness of a continuous dish with initial tastiness $t$, decay of tastiness $\\Delta t$, and a weight of $w$.\n        :param tastiness_dict: a dictionary mapping ingredients to their tastiness\n        :param w: the weight of the dish\n        :param t: the initial tastiness of the dish\n        :param decay: the decay of the dish\n        :return: the maximum total tastiness of a continuous dish with initial tastiness $t$, decay of tastiness $\\Delta t$, and a weight of $w$\n        \"\"\"\n        tastiness_sum = 0\n        for i in range(1, w+1):\n            tastiness_sum += t - i * decay\n        return tastiness_sum\n\n    # Compute the maximum total tastiness\n    max_tastiness = 0\n    for dish, (tastiness, decay) in tastiness_dict.items():\n        if dish[0] == 'D':\n            max_tastiness = max(max_tastiness, discrete_tastiness(tastiness_dict, w, tastiness, decay))\n        else:\n            max_tastiness = max(max_tastiness, continuous_tastiness(tastiness_dict, w, tastiness, decay))\n\n    # Check if the maximum total tastiness is impossible\n    if max_tastiness > w:\n        return \"Impossible\"\n\n    # Return the maximum total tastiness\n    return \"{:.6f}\".format(max_tastiness)\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # \u041f\u0440\u043e\u0432\u0435\u0440\u0438\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043b\u0438 \u0432\u044b\u0431\u043e\u0440\u043a\u0430 \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0430 \u043d\u043e\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n    if '\\n' in stdin:\n        print('Impossible')\n        return\n\n    # \u0421\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0438\n    n, w = [int(x) for x in stdin.split()]\n    # \u0414\u0430\u043b\u044c\u0448\u0435 \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u0432\u0435\u0440\u0441\u0438\u044f \u0431\u0435\u0437 \u0441\u0442\u0440\u043e\u043a\n    assert n == 1\n    # \u0421\u0447\u0438\u0442\u0430\u0435\u043c \u043f\u0435\u0440\u0432\u0443\u044e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e\n    x = int(stdin[0])\n\n    # \u0421\u0447\u0438\u0442\u0430\u0435\u043c \u0432\u0441\u0435 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435\n    values = [int(x) for x in stdin.split() if x!= '\\n']\n\n    # \u041e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c \u044d\u0442\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f\n    values.sort()\n\n    # \u041f\u043e\u0434\u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u0443\u043c\u043c\u0443 \u043f\u0435\u0440\u0432\u044b\u0445 n-1 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439, \u0447\u0442\u043e\u0431\u044b \u043e\u0442\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c\n    # \u041f\u0435\u0440\u0432\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c \u0431\u0443\u0434\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 x, \u0430 \u0432\u0442\u043e\u0440\u044b\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u0443\u043c\u043c\u044b \u043f\u0435\u0440\u0432\u044b\u0445 n-2 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439\n    values[0] += sum(values[:-1])\n    # \u041f\u0435\u0440\u0435\u0439\u0434\u0435\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n    x = values[-1]\n\n    # \u0418\u0449\u0435\u043c \u0440\u0435\u0448\u0435\u043d\u0438\u0435\n    for i in range(len(values)):\n        # \u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043b\u043e \u043d\u0443\u0436\u043d\u043e\u0439 \u0441\u0443\u043c\u043c\u044b, \u0442\u043e \u043f\u0440\u0435\u043a\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0438\u043a\u043b\n        if values[i] > w:\n            print(f'{values[i-1]}')\n            return\n        # \u0414\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0434\u043e\u0441\u0442\u0430\u0435\u043c \u0434\u0440\u0443\u0433\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e\n        x = x + values[i] - w\n        # \u0414\u043b\u044f \u0437\u0430\u0434\u0430\u0447\u0438 \u043d\u0435 \u043d\u0443\u0436\u043d\u0430 \u0432\u0435\u0440\u0441\u0438\u044f \u0441 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438 \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0430 \u043d\u043e\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n        # \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u0432\u0441\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 values\n        values = values + [x]\n    # \u041d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c \u043d\u0430\u0439\u0442\u0438 \u043e\u0442\u0432\u0435\u0442, \u0442\u043e \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430 \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438 \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0435\u0433\u043e\n    print(max(values) if len(values) > 0 else 'Impossible')\n    return\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(nm) time, O(1) space\n    n: dishes\n    m: weight\n    \"\"\"\n    # dishes\n    dishes = list()\n    for _ in range(int(stdin.readline().strip())):\n        dishes.append(tuple(map(int, stdin.readline().strip().split())))\n    # weight\n    weight = int(stdin.readline().strip())\n    # greedy\n    ans = 0\n    for dish in dishes:\n        if dish[0] == 1:\n            ans += (dish[2] * dish[1])\n        else:\n            ans += (dish[1] * dish[2])\n    # ans\n    if ans < weight:\n        return 'impossible'\n    else:\n        return '{:.6f}'.format(ans - weight)\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the maximum possible tastiness of a meal of a certain weight\n    based on the available dishes.\n    \n    Args:\n        stdin (str): The input as a string\n    \n    Returns:\n        str: The solution as a string\n    '''\n    _, weight = map(int, stdin.split())\n    \n    # Read the lines, each one containing a description\n    dishes = []\n    for _ in range(int(stdin.split()[0])):\n        dish = stdin.split('\\n')[1].split()\n        if dish[0] == 'D':\n            # Discrete dish\n            dish = (int(dish[1]), int(dish[2]), int(dish[3]))\n        else:\n            # Continuous dish\n            dish = (int(dish[1]), int(dish[2]))\n        dishes.append(dish)\n    \n    # Compute the maximum possible tastiness of a meal\n    tastiness = 0\n    for dish in dishes:\n        tastiness += (dish[0] * dish[1]) * (dish[0] - 1)\n        tastiness += dish[0] * dish[2]\n    \n    tastiness = max(0, tastiness)\n    if weight >= tastiness:\n        return str(tastiness)\n    return 'impossible'\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the maximum total tastiness of a meal of weight exactly w based on the available dishes.\n\n    >>> solution('''2 15\n   ... D 4 10 1\n   ... C 6 1\n   ... C 9 3\n   ... ''')\n    '49.0'\n    \"\"\"\n    dishes, w = stdin.split('\\n')[:2]\n    dishes = list(map(int, dishes.split()))\n    w = int(w)\n\n    tastinesses = []\n    decay = []\n    for i in range(dishes[0]):\n        dish = stdin.split('\\n')[2*i+2].split()\n        if dish[0] == 'D':\n            tastiness, decay_ = dish[2:]\n            tastinesses.append(tastiness)\n            decay.append(decay_)\n        elif dish[0] == 'C':\n            tastiness = dish[2]\n            tastinesses.append(tastiness)\n            decay.append(1)\n        else:\n            raise ValueError\n\n    def tastiness(i, j):\n        if i == 0:\n            return tastinesses[i]\n        return tastinesses[i] - (j-1)*decay[i]\n\n    possible_tastiness = [[tastiness(i, j) for j in range(i, w+1)] for i in range(w+1)]\n    print(possible_tastiness)\n    return max(sum(row) for row in possible_tastiness)\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum possible total tastiness of a meal of weight $w$ based on the available dishes.\"\"\"\n    dishes = stdin.splitlines()\n    discrete_dishes, continuous_dishes = [], []\n    for line in dishes:\n        ingredients, name = line.split(\" \", 1)\n        if name[0] == 'D':\n            discrete_dishes.append(line)\n        else:\n            continuous_dishes.append(line)\n    def find_amount_discrete(amount, weight):\n        tastiness = 0\n        for dish in discrete_dishes:\n            dish = dish.split(\" \")\n            tastiness += int(dish[2]) - (int(dish[1]) - 1) * int(dish[2])\n            if int(dish[1]) * int(dish[2]) <= amount:\n                amount -= int(dish[1]) * int(dish[2])\n            else:\n                dish_tastiness = int(dish[2]) * int(dish[1]) - int(dish[2])\n                tastiness += dish_tastiness\n                amount -= dish_tastiness\n                amount += int(dish[1]) * int(dish[2])\n                break\n        return tastiness, amount\n    def find_amount_continuous(amount, weight):\n        tastiness = 0\n        for dish in continuous_dishes:\n            dish = dish.split(\" \")\n            tastiness += int(dish[2]) - int(dish[1]) * amount\n            if int(dish[1]) * amount <= int(dish[2]):\n                amount -= int(dish[1]) * amount\n            else:\n                tastiness += int(dish[2]) - int(dish[1]) * amount\n                amount -= int(dish[1]) * amount\n                break\n        return tastiness, amount\n    weight = int(dishes[0].split(\" \")[1])\n    tastiness = 0\n    amount = weight\n    while amount > 0:\n        tastiness_dish, amount = find_amount_discrete(amount, weight)\n        tastiness += tastiness_dish\n        if amount == 0:\n            break\n        tastiness_dish, amount = find_amount_continuous(amount, weight)\n        tastiness += tastiness_dish\n    return f\"{tastiness:.6f}\"\nprint(solution(stdin))\n"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # w = int(stdin.readline())\n    # n = int(stdin.readline())\n    # total_tastiness = 0\n    # for i in range(n):\n    #     line = stdin.readline().strip()\n    #     if line[0] == 'D':\n    #         tastiness, weight, decay = line.split()\n    #         total_tastiness += int(tastiness) * int(weight)\n    #         total_tastiness -= int(weight) * int(weight) * int(decay)\n    #     else:\n    #         tastiness, decay = line.split()\n    #         total_tastiness += int(tastiness)\n    #         total_tastiness -= int(decay)\n    # print(round(total_tastiness, 6))\n    w = int(stdin.readline())\n    n = int(stdin.readline())\n    discrete = []\n    continuous = []\n    for i in range(n):\n        line = stdin.readline().strip()\n        if line[0] == 'D':\n            tastiness, weight, decay = line.split()\n            discrete.append((int(weight), int(tastiness), int(decay)))\n        else:\n            tastiness, decay = line.split()\n            continuous.append((int(tastiness), int(decay)))\n    # print(discrete)\n    # print(continuous)\n\n    dp = [[0 for i in range(w+1)] for j in range(n+1)]\n    dp[0][0] = 0\n    for i in range(1, n+1):\n        for j in range(1, w+1):\n            if j >= discrete[i-1][0]:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-discrete[i-1][0]] + discrete[i-1][1])\n            else:\n                dp[i][j] = dp[i-1][j]\n\n    # print(dp)\n    if dp[n][w] == 0:\n        print('impossible')\n    else:\n        print(dp[n][w])\n    return ''"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"This is the solution function to be called by our driver script.\"\"\"\n    # This is the function we need to pass to the driver script.\n    return f\"{solve(stdin)}\"\n\n\ndef"
    },
    {
        "number": 3082,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    zadanie z ksi\u0105\u017cki:\n    podziel do wielu zada\u0144\n    '''\n    "
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    songs = []\n    for _ in range(int(stdin.split(\"\\n\")[0])):\n        songs.append(stdin.split(\"\\n\")[1])\n    songs.append(stdin.split(\"\\n\")[2])\n    songs.append(stdin.split(\"\\n\")[3])\n    songs.append(stdin.split(\"\\n\")[4])\n    songs.append(stdin.split(\"\\n\")[5])\n    songs.append(stdin.split(\"\\n\")[6])\n    songs.append(stdin.split(\"\\n\")[7])\n    songs.append(stdin.split(\"\\n\")[8])\n    songs.append(stdin.split(\"\\n\")[9])\n    # songs = [a, b, c, d, e, f, g, h, i, j]\n    songs = [[songs[0], songs[1], songs[2], songs[3]], [songs[1], songs[4], songs[5], songs[6]], [songs[2], songs[7], songs[8], songs[9]], [songs[3], songs[6], songs[9], songs[8]], [songs[4], songs[5], songs[8], songs[7]], [songs[5], songs[6], songs[9], songs[8]], [songs[6], songs[7], songs[8], songs[9]], [songs[7], songs[8], songs[9], songs[10]], [songs[8], songs[9], songs[10], songs[11]], [songs[9], songs[10], songs[11], songs[12]]]\n\n    \n    print(songs)\n    result = []\n    for song in songs:\n        for _ in range(int(song[0])):\n            result.append(song[1])\n            result.append(song[2])\n            result.append(song[3])\n    print(result)\n    return''.join(list(map(str, result)))\n\nprint(solution(input()))\n\n------solution 2\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    songs = {}\n    playlist = []\n    for i in range(n):\n        line = stdin.strip().split()\n        song = line[0]\n        plays = int(line[1])\n        playlist.append(plays)\n        songs[song] = plays\n    \n    index = playlist.index(max(playlist))\n    result = []\n    while len(result) < 9:\n        plays = songs[songs.keys()[index]]\n        playlist[index] = -1\n        index = playlist.index(max(playlist))\n        result.append(songs.keys()[index])\n        for i in range(plays):\n            if index+i+1 < len(playlist):\n                result.append(songs.keys()[index+i+1])\n            else:\n                break\n    return \" \".join(str(song) for song in result)\n\n\ndef"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    songs_to_list = stdin.strip().split('\\n')\n    num_of_songs = int(songs_to_list.pop(0))\n    songs_list = []\n    for i in range(num_of_songs):\n        songs_list.append(songs_to_list[i].split())\n    num_of_songs = int(songs_list[num_of_songs - 1][1])\n    songs_list = songs_list[:num_of_songs]\n    \n    print(songs_list)\n    return [5, 3, 8, 2, 1, 10, 4, 9, 6, 7]\n    \n\nprint(solution(\"10\\na 2 10 3\\na 1 6\\nc 2 1 5\\nd 1 9\\ne 1 4\\nf 1 2\\ng 2 6 8\\nh 0\\ni 1 3\\nj 1 7\\n\"))"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    cnt = int(stdin.readline())\n    lines = list(map(lambda x: x.split(), stdin.readlines()[:cnt]))\n    lengths = list(map(lambda x: len(x[0]), lines))\n    if max(lengths) > 15 or min(lengths) < 1:\n        return 'fail'\n    for i in range(len(lines)):\n        if len(lines[i][1]) > 1:\n            return 'fail'\n    l = []\n    for line in lines:\n        for i in range(int(line[1])):\n            l.append(int(line[0]))\n    if len(l)!= len(set(l)):\n        return 'fail'\n    return''.join(map(str, l[:9]))\nprint(solution(stdin))\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\""
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Creates a list of songs and number of songs that can be played after them\n    \"\"\"\n    songs = []\n    n = int(stdin.split()[0])\n    for line in stdin.split()[1:]:\n        songs.append(Song(line.split()[0], int(line.split()[1])))\n\n    possiblesongs = []\n    for song in songs:\n        possiblesongs.append(song)\n    songslist = []\n    while len(possiblesongs) > 1:\n        song1 = possiblesongs.pop(0)\n        for song2 in possiblesongs:\n            if song1.artist!= song2.artist and song1.index + song2.index < n:\n                possiblesongs.append(Song(song1.artist +'' + song2.artist, song1.index + song2.index))\n        songslist.append(song1.index)\n    if len(possiblesongs) == 0:\n        return \"fail\"\n    else:\n        return str(songslist).strip('[]')\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the 9 songs that form a valid playlist\n\n    >>> solution(\"10\\na 2 10 3\\nb 1 6\\nc 2 1 5\\nd 1 9\\ne 1 4\\nf 1 2\\ng 2 6 8\\nh 0\\ni 1 3\\nj 1 7\\n\")\n    '5 4 9 3 1 10 7 6 2'\n    \"\"\"\n    n, song_dict = int(stdin.split()[0]), {}\n\n    for song in stdin.split()[1:]:\n        song_name, after = song.split()\n        after = list(map(int, after.split(',')))\n        song_dict[song_name] = after\n\n    current_song = 1\n    songs_played = []\n\n    while current_song < n + 1:\n        songs_to_play = song_dict[current_song]\n\n        if not songs_to_play:\n            songs_to_play = [current_song]\n\n        for song in songs_to_play:\n            if song in songs_played:\n                songs_to_play.remove(song)\n                songs_played.append(song)\n                break\n\n            songs_played.append(song)\n        else:\n            songs_played.append(current_song)\n\n        current_song = songs_played[-1]\n\n    return \" \".join(map(str, songs_played))\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    song_n = int(stdin.readline())\n    playlist = []\n    i = 0\n    while len(playlist) < 9:\n        song = stdin.readline().split()\n        if int(song[1]) <= song_n:\n            playlist.append(int(song[1]))\n            i += 1\n        else:\n            playlist.append(0)\n        if i == 9:\n            break\n    if i!= 9:\n        return \"fail\"\n    return playlist\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    l = [None] * n\n    for i in range(n):\n        line = lines[i + 1].split()\n        l[i] = (line[0], int(line[1]))\n    l.sort(key=lambda x: x[1])\n    songs = [x[0] for x in l]\n    songs_seen = set()\n    for i in range(len(songs) - 1, -1, -1):\n        if len(songs_seen) == 9:\n            return ''.join(songs[:i + 1])\n        for j in range(i + 1, len(songs)):\n            if songs[j] in songs_seen:\n                continue\n            if j - i < l[i][1]:\n                songs_seen.add(songs[j])\n    return 'fail'\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3083,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n\"\"\"\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Sets the clock to the inputted time and resets it to the original time.\n    Returns the number of different times the clock has been set to.\n    \"\"\"\n    original_time = stdin.split('\\n')[0]\n    current_time = stdin.split('\\n')[1]\n    new_time = []\n    for i in range(len(original_time)):\n        if original_time[i] == '9':\n            new_time.append('9')\n        else:\n            new_time.append('0')\n    new_time.append(current_time)\n\n    times = []\n    for i in range(0, len(new_time), 4):\n        temp = []\n        for j in range(0, 2):\n            temp.append(new_time[i + j])\n        for k in range(0, 2):\n            temp.append(new_time[i + k + 2])\n        times.append(temp)\n\n    count = 1\n    for i in times:\n        if i[0] == i[1]:\n            count += 1\n            print(':'.join(i))\n    return str(count)"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    # '0' <= h < '9' and '0' <= m < '9'\n    # hours = [int(i) for i in stdin[0]]\n    # minutes = [int(i) for i in stdin[1]]\n\n    hours = [int(i) for i in stdin[0][0:2]]\n    minutes = [int(i) for i in stdin[0][3:5]]\n    # for i in range(0, len(hours)):\n    #     for j in range(0, len(minutes)):\n    #         if hours[i] == 0 and minutes[j] == 0:\n    #             hours[i] = 9\n    #             minutes[j] = 9\n    #         elif hours[i] == 9 and minutes[j] == 9:\n    #             hours[i] = 0\n    #             minutes[j] = 0\n\n    # hours.insert(0, 0)\n    # minutes.insert(0, 0)\n    # minutes.append(0)\n\n    # print(hours, minutes)\n\n    # hours_tot = sum(hours)\n    # minutes_tot = sum(minutes)\n    # minutes_tot = minutes[0]\n    # minutes_tot = 0\n\n    # print(hours_tot, minutes_tot)\n\n    # while hours_tot!= hours[0] or minutes_tot!= minutes[0]:\n    #     hours_tot = hours_tot + 1\n    #     minutes_tot = minutes_tot + 1\n    #     if hours_tot == hours[0] and minutes_tot == minutes[0]:\n    #         break\n    #     if hours_tot == hours[0] and minutes_tot > minutes[0]:\n    #         minutes_tot = minutes_tot - 60\n    #         hours_tot = hours_tot + 1\n    #     if hours_tot == hours[0] and minutes_tot < minutes[0]:\n    #         hours_tot = hours_tot - 1\n    #         minutes_tot = minutes_tot + 60\n    #     if hours_tot!= hours[0] or minutes_tot!= minutes[0]:\n    #         hours_tot = hours_tot + 1\n    #         minutes_tot = minutes_tot + 1\n    #     print(hours_tot, minutes_tot)\n\n    # print(hours_tot, minutes_tot)\n\n    def get_clocks_tot(hour, minute):\n        hour = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        minute = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        hours_tot = 0\n        minutes_tot = 0\n        while hour!= hours[0] or minute!= minutes[0]:\n            hours_tot = hours_tot + 1\n            minutes_tot = minutes_tot + 1\n            if hours_tot == hours[0] and minutes_tot == minutes[0]:\n                break\n            if hours_tot == hours[0] and minutes_tot > minutes[0]:\n                minutes_tot = minutes_tot - 60\n                hours_tot = hours_tot + 1\n            if hours_tot == hours[0] and minutes_tot < minutes[0]:\n                hours_tot = hours_tot - 1\n                minutes_tot = minutes_tot + 60\n            if hours_tot!= hours[0] or minutes_tot!= minutes[0]:\n                hours_tot = hours_tot + 1\n                minutes_tot = minutes_tot + 1\n        return hours_tot, minutes_tot\n\n    hours_tot, minutes_tot = get_clocks_tot(hours[0], minutes[0])\n    print(hours_tot, minutes_tot)\n    # for i in range(0, len(hours)):\n    #     for j in range(0, len(minutes)):\n    #         for k in range(0, len(hours)):\n    #             for l in range(0, len(minutes)):\n    #                 if hours[i] == hours[k] and minutes[j] == minutes[l] and hours[k]!= 0 and minutes[j]!= 0:\n    #                     if get_clocks_tot(hours[i], minutes[j])[0] == get_clocks_tot(hours[k], minutes[l])[0] and get_clocks_tot(hours[i], minutes[j])[1] == get_clocks_tot(hours[k], minutes[l])[1]:\n    #                         print(f\"{hours[i]}:{minutes[j]}\")\n    #                         print(f\"{hours[k]}:{minutes[l]}\")\n\n    return 0\n\n\nprint(solution('''\n00:01\n00:02\n00:03\n00:04\n00:05\n'''))\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    hour = stdin[:2]\n    minute = stdin[3:5]\n\n    if int(minute) < int(stdin[3:]):\n        minute = str(int(minute) + 60)\n        hour = str(int(hour) - 1)\n\n    elif int(hour) < int(stdin[:2]):\n        hour = str(int(hour) + 24)\n        minute = str(int(minute) - 60)\n\n    return hour + \":\" + minute\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a string that is the solution of the problem\"\"\"\n    # Your code here\n    return \"The solution is the string that is returned\""
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    list1 = stdin.split(\"\\n\")\n    list1 = [i.split(\":\", 2) for i in list1]\n    list1 = [(int(i[0]), int(i[1])) for i in list1]\n    list2 = stdin.split(\"\\n\")\n    list2 = [i.split(\":\", 2) for i in list2]\n    list2 = [(int(i[0]), int(i[1])) for i in list2]\n    count = 0\n    for i in list1:\n        for j in list2:\n            if i[0] == j[0] and i[1] == j[1]:\n                count += 1\n    print(count)\n    for i in list2:\n        for j in list1:\n            if i[0] == j[0] and i[1] == j[1]:\n                print(f\"{i[0]:02d}:{i[1]:02d}\")"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    clock_time = stdin.split('\\n')[0]\n    new_time = stdin.split('\\n')[1]\n    \n    clock_time_list = []\n    new_time_list = []\n\n    for c in clock_time:\n        clock_time_list.append(c)\n\n    for n in new_time:\n        new_time_list.append(n)\n\n    new_clock_time = []\n\n    for c in clock_time_list:\n        if c == '0':\n            new_clock_time.append('9')\n        else:\n            new_clock_time.append(c)\n\n    new_clock_time = ''.join(new_clock_time)\n\n    count = 0\n\n    for c in new_clock_time:\n        if c!= ':':\n            count += 1\n\n    print(count)\n\n    new_clock_time = new_clock_time.split(':')\n    new_clock_time[0] = new_clock_time[0].replace('0', '')\n    new_clock_time[1] = new_clock_time[1].replace('0', '')\n\n    if len(new_clock_time[1]) == 1:\n        new_clock_time[1] = '0' + new_clock_time[1]\n\n    print(new_clock_time)\n"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    clock = stdin[0].split(':')\n    current = stdin[1].split(':')\n    ans = []\n    for i in range(len(clock)):\n        curr = int(clock[i])\n        curr += (int(current[i]) - int(clock[i]))\n        if curr < 0:\n            curr += 24\n        if curr > 23:\n            curr -= 24\n        ans.append(str(curr))\n    print(len(set(ans)))\n    for x in set(ans):\n        print(f'{x}:{ans.count(x)}')\n    return ''"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return how to set the clock correctly\"\"\"\n    # Get the initial time\n    stdin = stdin.split()\n    initial = stdin[0].split(\":\")\n    initial = [int(initial[0]), int(initial[1])]\n    # Get the current time\n    current = stdin[1].split(\":\")\n    current = [int(current[0]), int(current[1])]\n    # Determine how to set the clock\n    delta = [0, 0]\n    delta[0] = current[0] - initial[0]\n    delta[1] = current[1] - initial[1]\n    if delta[1] < 0:\n        delta[1] += 60\n        delta[0] -= 1\n    if delta[0] < 0:\n        delta[0] += 24\n    print(delta[0])\n    print(delta[1])\n    print(current)\n    print(initial)\n    return \"\""
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return ''"
    },
    {
        "number": 3084,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the minimum amount of time needed to set the clock correctly.\"\"\"\n    # Initilise variables\n    current = stdin.split(\"\\n\")[1].split(\":\")\n    set_time = stdin.split(\"\\n\")[0].split(\":\")\n    result = []\n    \n    # Check if the set time is invalid\n    if set_time[0] < '00' or set_time[0] > '23':\n        result.append(set_time[0] + \":\" + set_time[1])\n    if set_time[1] < '00' or set_time[1] > '59':\n        result.append(set_time[0] + \":\" + set_time[1])\n    \n    # Iterate through all possible times\n    for i in range(0,24):\n        for j in range(0,60):\n            # Set new clock time\n            new_time = str(i) + \":\" + str(j)\n            \n            # Check if clock is valid\n            valid = True\n            \n            # Check if the hour is invalid\n            if new_time[0] < '00' or new_time[0] > '23':\n                valid = False\n            \n            # Check if the minute is invalid\n            if new_time[1] < '00' or new_time[1] > '59':\n                valid = False\n            \n            # If valid, add it to the result\n            if valid:\n                result.append(new_time)\n    \n    # Check how many times we have\n    counter = 0\n    for i in result:\n        if i == stdin.split(\"\\n\")[0]:\n            counter += 1\n    \n    # Return the result\n    return str(counter) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin.strip()\n    brackets = [i for i in range(len(string)) if string[i] in \"()\"]\n    start, end = brackets[0], brackets[1]\n    return str(start)+\",\"+str(end)+\":\"+string[start+1:end]\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nfrom collections import Counter\ndef"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    length = len(stdin)\n    if length < 2:\n        return \"\"\n    if stdin.count('(') == stdin.count(')'):\n        return stdin\n    dp = [[-1 for _ in range(length)] for _ in range(length)]\n    cur = [0, 0]\n    for i in range(length):\n        if stdin[i] == '(':\n            cur[0] += 1\n        else:\n            cur[1] += 1\n        dp[i][i] = 0\n        if cur[0] == cur[1]:\n            cur.reverse()\n            dp[i][i] = 1\n        for j in range(i + 1, length):\n            if stdin[j] == '(':\n                cur[0] += 1\n            else:\n                cur[1] += 1\n            dp[i][j] = dp[i][j - 1]\n            if stdin[i:j + 1] == stdin[i:j + 1][::-1]:\n                dp[i][j] = min(dp[i][j], j - i + 1)\n    start, end = dp[0].index(max(dp[0])), len(stdin) - 1 - dp[-1][::-1].index(max(dp[-1]))\n    return stdin[start:end + 1]\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n  # create a stack to hold all of the brackets\n  stack = []\n  for char in stdin:\n    # check if we are on the first char of the string\n    # if not, we can assume it is a bracket\n    if stack:\n      # if we are on an open bracket, then we can add it to the stack\n      # otherwise, we are on a closed bracket\n      if char == '(':\n        # add it to the stack\n        stack.append('(')\n      else:\n        # check if the top of the stack is the opening bracket\n        if stack[-1] == '(':\n          # remove it from the stack\n          stack.pop()\n        else:\n          # otherwise, we are on a closed bracket\n          stack.append(')')\n\n    else:\n      # we are on the first char of the string, so just add it to the stack\n      stack.append(char)\n\n  # create a string to hold the output\n  output = ''\n\n  # get the output for each section\n  while stack:\n    output += str(len(stack)) + ','\n    stack.pop()\n\n  # return the output\n  return output[:-1]\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    st = stdin.replace(\"(\",\"0\").replace(\")\",\"1\")\n    print(st)\n    return st\n\n\nsolution(\"((((()()(((((())))())))))\")"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return stdin.replace('()', '4,4:')\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(n)\n    \"\"\"\n    length = len(stdin)\n    counter = 0\n    sequence = []\n    for i in range(length):\n        if stdin[i] == '(':\n            counter += 1\n        elif stdin[i] == ')':\n            counter -= 1\n        if counter == 0:\n            sequence.append(f'{i + 1},{i + 1}:')\n        elif counter < 0:\n            return None\n    sequence = ''.join(sequence)\n    return sequence\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    list_of_brackets = []\n    for char in stdin:\n        if char == \"(\":\n            list_of_brackets.append(\"(\")\n        elif char == \")\":\n            list_of_brackets.append(\")\")\n    output = \"\"\n    current_start_index = 0\n    for index in range(len(list_of_brackets)):\n        if list_of_brackets[index] == \"(\" and list_of_brackets[index-1] == \")\":\n            current_start_index = index + 1\n        elif list_of_brackets[index] == \")\" and list_of_brackets[index-1] == \"(\":\n            current_end_index = index\n            substring = stdin[current_start_index:current_end_index]\n            output += str(len(substring) + 1)\n            output += \",\"\n            output += str(len(substring) + 2)\n            output += \":\"\n            output += substring\n            current_start_index = current_end_index + 1\n    output = output[0:-1]\n    return output\n"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n  s = stdin\n  brackets = []\n  for i, char in enumerate(s):\n    if char == '(':\n      brackets.append((i, '('))\n    elif char == ')':\n      if brackets and brackets[-1][1] == '(':\n        brackets.pop()\n      else:\n        brackets.append((i, ')'))\n\n  start, end = brackets[0][0], brackets[-1][0]\n  substring = s[start:end+1]\n  if len(brackets) == 1:\n    return str(start) + ',' + str(end) + ':' + substring\n  else:\n    return str(start) + ',' + str(end+1) + ':' + substring\n\n'''\n\ns = input()\nprint(solution(s))"
    },
    {
        "number": 3085,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the length of the shortest bracket notation\n    for the given string.\n    '''\n    # Your code here\n    return stdin\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().strip().split())\n    planets = {}\n    events = set()\n    for _ in range(n):\n        line = stdin.readline().strip().split()\n        events |= set(line[2:])\n        start = line[:2]\n        end = line[2:]\n        planets[start[0]] = planets.get(start[0], []) + [{'start': int(start[1]), 'end': int(end[0]), 'number': int(end[1])}]\n    events = list(events)\n    events.sort()\n    results = []\n    for event in events:\n        for planet, observations in planets.items():\n            for observation in observations:\n                if observation['number'] == event:\n                    if observation['start'] <= observation['end']:\n                        end_date = observation['start'] + observation['number']\n                    else:\n                        end_date = observation['start'] + observation['number'] - 365\n                    if end_date < observation['end']:\n                        results.append(end_date - observation['start'] + 1)\n    if results:\n        print(' '.join(map(str, results)))\n    else:\n        print(-1)\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    number_of_telescopes, number_of_event_types = [int(x) for x in stdin.split()]\n    events = [int(x) for x in stdin.split()]\n    events = list(zip(events[0::2], events[1::2]))\n    durations = {}\n    for date_start, date_end in events:\n        for _ in range(date_start, date_end):\n            if date_start in durations.keys():\n                durations[date_start] += 1\n            else:\n                durations[date_start] = 1\n    if number_of_event_types == 1:\n        return str(durations[1])\n    return str(-1)\n    \n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    days = int(stdin[0].split()[0])\n    months = int(stdin[0].split()[1])\n    observations = [i.split() for i in stdin[1:]]\n    types = []\n    for i in observations:\n        days += sum(map(int, i[:2]))\n        months += sum(map(int, i[2:]))\n        if days > 31 or months > 12:\n            days -= 31\n            months -= 12\n        elif days > 0:\n            days -= 1\n        months -= 1\n        types.append(i[-1])\n    print(types)\n    return \"\".join(types)\n\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Get input and calculate the answer.\n    :param stdin: str\n    :return: str\n    \"\"\"\n    planets, types = stdin.split('\\n')\n    planets = planets.split('\\n')\n    types = types.split('\\n')\n\n    def get_duration(event_type: int, events: list) -> int:\n        \"\"\"\n        Get the duration of an event type.\n        :param event_type: int\n        :param events: list\n        :return: int\n        \"\"\"\n        for event in events:\n            if event[2] == event_type:\n                return abs((event[0] - event[1]) - 1)\n        return 0\n\n    answer = []\n    for event_type in range(len(types)):\n        answer.append(str(get_duration(event_type, planets)))\n    if len(answer) == 1:\n        print(answer[0])\n    else:\n        print('-1')\n    return '\\n'.join(answer)\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the sum of the even-valued terms in the Fibonacci sequence between 0 and 4,000,000.\n\n    Args:\n        stdin (str): input\n\n    Returns:\n        str: the sum of the even-valued terms in the Fibonacci sequence between 0 and 4,000,000.\n    \"\"\"\n    # Your code here\n    return \"-1\"\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    planet_data = [list(map(int, row.split())) for row in stdin.splitlines()]\n    num_telescopes, num_types = planet_data[0]\n    planet_data = planet_data[1:]\n\n    events = {}\n    for x, y, z in planet_data:\n        events.setdefault(y, {})[x] = z\n    events_list = []\n    for i, v in events.items():\n        total = 0\n        for j, w in v.items():\n            total += w\n        events_list.append([i, total])\n    events_list.sort(key=lambda x: x[1])\n\n    temp_data = []\n    for e in events_list:\n        temp_data.append([e[0], e[1], -1])\n\n    for i, v in enumerate(events_list):\n        for j, w in enumerate(temp_data):\n            if w[1]!= -1:\n                continue\n            temp_data[j][2] = i\n            if temp_data[j][1] == 0:\n                temp_data[j][1] = 0\n                temp_data[j][0] = 0\n                break\n            else:\n                temp_data[j][1] = temp_data[j][1] - events_list[i][1]\n                break\n    for i in temp_data:\n        if i[0]!= 0:\n            print(-1)\n        else:\n            print(i[2] + 1)\n    return \"\""
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    test_case = stdin.split(\"\\n\")\n    n, m = [int(x) for x in test_case[0].split(\" \")]\n    data = []\n    for i in range(n):\n        data.append([int(x) for x in test_case[i + 1].split(\" \")])\n    data = sorted(data, key=lambda x: x[0])\n    count = {}\n    for item in data:\n        if item[1] not in count.keys():\n            count[item[1]] = [item[3]]\n        else:\n            count[item[1]] += [item[3]]\n    print(count)\n    result = []\n    for key in count.keys():\n        x = 0\n        for i in range(len(count[key])):\n            x += count[key][i]\n        result += x,\n    if len(result) > 0:\n        return \" \".join(map(str, result))\n    else:\n        return \"-1\"\n\n\nprint(solution(\"1 1\\n26 02 03 03 1\"))\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    n_list = [map(int, stdin.split()) for i in range(n)]\n    n_list.sort()\n\n    max_h = 0\n    i = 0\n    while i < n:\n        s_d, s_m, e_d, e_m = n_list[i][:4]\n        if s_d == n_list[i + 1][2]:\n            if s_m == n_list[i + 1][3]:\n                max_h += 1\n                n_list.pop(i + 1)\n        else:\n            i += 1\n    return max_h\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3086,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the solution to the problem.\"\"\"\n    num_of_dancers = int(stdin.split()[0])\n    num_of_signals = int(stdin.split()[1])\n    dancers = [int(num) for num in stdin.split()[2:]]\n\n    signals = []\n    for _ in range(num_of_signals):\n        signals.append(list(map(int, stdin.split()[2:])))\n\n    paths = []\n    for signal in signals:\n        paths.append([0] * num_of_dancers)\n\n    path_count = 0\n    for signal in signals:\n        path_count += 1\n        for i in range(num_of_dancers):\n            paths[path_count % num_of_signals][i] = signal[i]\n\n    next_dancer_id = num_of_dancers\n    prev_dancer_id = num_of_dancers - 1\n    while True:\n        path_count += 1\n        for i in range(num_of_dancers):\n            dancers[i] = paths[path_count % num_of_signals][i]\n\n        if dancers == sorted(dancers):\n            break\n\n    return''.join([str(num) for num in dancers])\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    \n    one_to_n = set(range(1, n + 1))\n    dancers = set(a)\n    \n    possible = False\n    for i in range(1, n + 1):\n        if i in dancers:\n            for j in range(1, k + 1):\n                if i in one_to_n - dancers:\n                    possible = True\n                    one_to_n = one_to_n - dancers\n                    dancers.add(i)\n                    break\n                else:\n                    dancers.add(i)\n                    one_to_n = one_to_n - dancers\n                    dancers.remove(i)\n                    i = i + j\n                    if i >= n + 1:\n                        i = i - n\n                    elif i == 0:\n                        i = n\n                    dancers.add(i)\n                    one_to_n = one_to_n - dancers\n                    if j >= k:\n                        break\n    \n    if possible:\n        return''.join(map(str, [i for i in range(1, n + 1) if i not in dancers]))\n    else:\n        return 'Impossible'\n    \n    return ''"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"6 2\\n3 4 5 6 1 2\")\n    '5 6 1 2 3 4'\n    >>> solution(\"4 2\\n3 4 1 2\")\n    '2 3 4 1'\n    \"\"\"\n    start, end = (int(x) for x in stdin.split(\" \"))\n    people = [int(x) for x in stdin.split(\" \")[1].split(\" \")]\n\n    result = solve(start, end, people)\n    if not result:\n        print(\"Impossible\")\n    else:\n        print(*result)\n\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    The first line of the input contains two integers $N$ and $K$, $2 \\le N \\le 10000, 1\\le K \\le 10^9$. The second line of the input contains $N$ space separated integers $a_1, \\dots, a_ N$, denoting that dancer number $i$ ended at the place of dancer number $a_ i$. You may assume that $1 \\le a_ i \\le N$ for all $i$ and every number between $1$ and $N$ inclusive appears exactly once in the sequence.\n    \"\"\"\n    N, K = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n    B = set(range(1, N + 1))\n    for i, num in enumerate(A):\n        if num!= i + 1:\n            B.remove(num)\n    if len(B) > 0:\n        return 'Impossible'\n    elif K > 1:\n        return 'Impossible'\n    return''.join(map(str, A))"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Input:\n        stdin (list): list of input lines as strings\n    Output:\n        str: one-line string\n    \"\"\"\n    # Get data\n    num_dancers = int(stdin[0])\n    num_bars = int(stdin[1])\n    bars = list(map(int, stdin[2].split()))\n\n    # Determine\n    # 1. The number of bar positions (all unique bar positions are distinct)\n    # 2. The number of bar positions that are consecutive (no bar position is consecutive twice)\n    # 3. The number of distinct bar positions that are consecutive (no bar position is consecutive twice)\n    # 4. The number of bar positions that are not consecutive (no bar position is consecutive twice)\n    bar_positions = [i for i in range(1, num_dancers+1) if i not in bars]\n    num_bar_positions = len(bar_positions)\n    num_distinct_bar_positions = len(set(bar_positions))\n    num_consecutive_bar_positions = 0\n    for i in range(1, num_bar_positions):\n        if bar_positions[i] - bar_positions[i - 1] == 1:\n            num_consecutive_bar_positions += 1\n    num_non_consecutive_bar_positions = num_bar_positions - num_consecutive_bar_positions\n\n    # Determine if we can do it\n    if num_bar_positions > num_bars or num_bar_positions < 2 or num_non_consecutive_bar_positions >= 2:\n        return 'Impossible'\n\n    # Determine if we can do it\n    if num_consecutive_bar_positions >= num_bars - 1:\n        return''.join(map(str, bar_positions))\n\n    # Determine if we can do it\n    bar_positions.sort()\n    first_bar_position = bar_positions[0]\n    last_bar_position = bar_positions[-1]\n    bar_positions = bar_positions[1:]\n    while bar_positions:\n        next_bar_position = bar_positions[0]\n        if next_bar_position - first_bar_position == 1:\n            bar_positions = bar_positions[1:]\n            first_bar_position = next_bar_position\n        else:\n            break\n    if next_bar_position == last_bar_position:\n        return 'Impossible'\n\n    # Determine if we can do it\n    if next_bar_position - first_bar_position < num_bars - 1:\n        return 'Impossible'\n\n    # Determine if we can do it\n    num_rows = num_bars\n    num_columns = num_consecutive_bar_positions + 1\n    if num_columns * num_rows < num_dancers:\n        return 'Impossible'\n\n    # Determine if we can do it\n    if num_dancers % num_columns == 0:\n        num_rows = num_dancers // num_columns\n    else:\n        num_columns = num_dancers // num_rows\n    if num_columns == 1:\n        num_columns = 2\n    if num_rows == 1:\n        num_rows = 2\n\n    # Determine if we can do it\n    if num_rows * num_columns!= num_dancers:\n        return 'Impossible'\n\n    # Determine if we can do it\n    if num_columns == 1 or num_columns == 2:\n        num_columns = 3\n\n    # Determine if we can do it\n    if num_rows == 1 or num_rows == 2:\n        num_rows = 3\n\n    # Determine if we can do it\n    if num_rows == num_columns:\n        num_rows = num_columns = 4\n\n    # Determine if we can do it\n    if num_rows * num_columns < num_dancers:\n        return 'Impossible'\n\n    # Print output\n    return''.join(map(str, [i for i in range(1, num_dancers+1) for _ in range(num_rows)]))\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(' '))\n    a = list(map(int, stdin.split(' ')))\n    h = list(set(a))\n    res = [''] * n\n    for i in range(len(h)):\n        count = a.count(h[i])\n        if count % k!= 0:\n            return 'Impossible'\n        else:\n            for j in range(len(a)):\n                if a[j] == h[i]:\n                    res[j] = str(j+1)\n    return''.join(res)\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # get input from stdin\n    n, k = [int(n) for n in stdin.split(' ')]\n    a = [int(n) for n in stdin.split(' ')]\n    d = {}\n\n    # create dict with number and position\n    for i, n in enumerate(a):\n        if n in d:\n            d[n].append(i+1)\n        else:\n            d[n] = [i+1]\n    \n    # create dict with number and position\n    d2 = {}\n    for i, n in enumerate(a):\n        if n in d2:\n            d2[n].append(i+1)\n        else:\n            d2[n] = [i+1]\n    \n    # sort dict by number\n    d = {k: v for k, v in sorted(d.items(), key=lambda item: item[0])}\n    d2 = {k: v for k, v in sorted(d2.items(), key=lambda item: item[0])}\n\n    # check if it is possible to reach 2nd dict by arrows\n    reach = 0\n    for i, n in enumerate(d):\n        if len(d[n]) >= 2:\n            if len(d2[d[n][0]]) >= k:\n                reach = 1\n            else:\n                reach = 0\n                break\n    if not reach:\n        return 'Impossible'\n\n    # find shortest path\n    path = []\n    while i > 0 and len(path) < n:\n        if len(d[a[i-1]]) >= 2:\n            if len(d2[d[a[i-1]][0]]) >= k:\n                path.append(d[a[i-1]][0])\n            else:\n                path.append(d[a[i-1]][1])\n            i -= 1\n        else:\n            path.append(d[a[i-1]][1])\n            i -= 1\n    \n    # return path\n    return''.join([str(n) for n in path])\n"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\n    pass"
    },
    {
        "number": 3087,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the input and return a string as the output\"\"\"\n    n, k = [int(x) for x in stdin.split()]\n    arr = [int(x) for x in stdin.split()[1:]]\n    if sorted(arr)!= arr:\n        return \"Impossible\"\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if abs(arr[j - 1] - arr[i - 1]) >= k:\n                return \"Impossible\"\n    res = {}\n    for i, x in enumerate(arr, 1):\n        res[i] = x\n    return \"\\n\".join([str(res[i]) for i in range(1, n + 1)])"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    number, k = stdin.split()\n    n = int(number)\n    k = int(k)\n    num_list = list(str(n))\n    num_list.reverse()\n    for i in range(0, k):\n        for j in range(0, len(num_list) - 1, 2):\n            if num_list[j] > num_list[j + 1]:\n                num_list[j], num_list[j + 1] = num_list[j + 1], num_list[j]\n    result = int(\"\".join(num_list))\n    return str(result)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = stdin.split(' ')\n    n, k = int(n), int(k)\n    ans = n\n    n_str = str(n)\n    for i in range(k):\n        ans = get_max(ans)\n        n_str = get_max(n_str)\n    return str(ans)\n\n\ndef"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(n) for n in stdin.split(' ')]\n    def swap(n: int, i: int, j: int) -> int:\n        return (n // (10 ** i)) * (10 ** j) + (n // (10 ** j)) * (10 ** i) + (n % (10 ** i)) * (10 ** j) + (n % (10 ** j)) * (10 ** i)\n    def isValid(n: int) -> bool:\n        return str(n)[0]!= '0'\n    def next(n: int) -> int:\n        return n + 1\n    def isValid(n: int) -> bool:\n        return str(n)[0]!= '0'\n    ans = n\n    for i in range(k):\n        ans = next(ans)\n        while not isValid(ans):\n            ans = next(ans)\n    print(ans)"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    k = int(stdin.split(\" \")[1])\n    i = 0\n    ans = list(n)\n    while i < k:\n        max_digit = 0\n        max_digit_index = 0\n        for index, num in enumerate(ans):\n            if num > max_digit:\n                max_digit = num\n                max_digit_index = index\n        if max_digit_index + 1 < len(ans):\n            ans[max_digit_index + 1], ans[max_digit_index] = ans[max_digit_index], ans[max_digit_index + 1]\n        else:\n            ans[max_digit_index - 1], ans[max_digit_index] = ans[max_digit_index], ans[max_digit_index - 1]\n        i += 1\n    return \"\".join(ans)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < 10 ** 6:\n        if k < 20:\n            print(n)\n            return\n        n_str = str(n)\n        n = int(n_str[::-1])\n        moves = 0\n        while moves < k:\n            digits = [int(d) for d in str(n)]\n            moves += 1\n            i = 0\n            while i < len(digits):\n                if digits[i]!= 0 and digits[i] == digits[i + 1] and i!= 0:\n                    digits[i - 1] = digits[i - 1] * 2\n                    digits[i] = 0\n                    digits[i + 1] = 0\n                    moves += 1\n                i += 1\n            if digits[0] == 0:\n                for j in range(len(digits) - 1, 0, -1):\n                    if digits[j] == 0:\n                        digits[j] = digits[j - 1]\n                        digits[j - 1] = 0\n                        moves += 1\n            for d in digits:\n                if d!= 0:\n                    n = int(\"\".join([str(d) for d in digits]))\n                    break\n        print(n)\n    else:\n        print(n)\n    return\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the largest number resulting from applying the given swaps to n.\"\"\"\n    n, k = map(int, stdin.split())\n    # Write your code here\n    result = list(str(n))\n    for _ in range(k):\n        # keep indices of the two digits to be swapped\n        i, j = map(int, input().split())\n        # swap digits\n        result[i], result[j] = result[j], result[i]\n        # reverse the whole number\n        result[0], result[-1] = result[-1], result[0]\n    return int(''.join(result))\n\n\ndef"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = (int(x) for x in stdin.split())\n    cnt = 0\n    while n > 0:\n        if n % 10 == 0:\n            n //= 10\n        else:\n            if n % 10 < n // 10:\n                d = n % 10\n                n //= 10\n                n += d\n                cnt += 1\n            else:\n                n //= 10\n                cnt += 1\n        if cnt >= k:\n            break\n    return str(n)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    n = str(n)\n    temp = n\n    for i in range(0, k):\n        if len(n) % 2 == 0:\n            n = '0' + n\n        else:\n            n = n + '0'\n        n = str(int(n[:int(len(n) / 2)]) + int(n[int(len(n) / 2):]))\n    return n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split()))\n    \n    s = str(n)\n    if k == 0:\n        return str(n)\n    if k < len(s):\n        return \"\".join(sorted(s, reverse=True))[k - 1]\n    return \"9\" * len(s)\n"
    },
    {
        "number": 3088,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(c) for c in stdin.split(' ')]\n    ans = str(n)\n    for i in range(k):\n        ans = swap(ans)\n    return ans\n\n\ndef"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return 'a'"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    if n == 3:\n        return 1\n    points = []\n    for i in range(n):\n        point = stdin.readline().split()\n        point[0] = float(point[0])\n        point[1] = float(point[1])\n        points.append(point)\n    points.sort(key=lambda x: x[0])\n    points.sort(key=lambda x: x[1])\n    x1, y1 = points[0][0], points[0][1]\n    x2, y2 = points[1][0], points[1][1]\n    x3, y3 = points[2][0], points[2][1]\n    x4, y4 = points[3][0], points[3][1]\n    x5, y5 = points[4][0], points[4][1]\n    x6, y6 = points[5][0], points[5][1]\n    dist1 = abs(x5 - x4) + abs(y5 - y4)\n    dist2 = abs(x6 - x1) + abs(y6 - y1)\n    return dist1 + dist2"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the expected distance that a taxi will travel.\n\n    >>> solution(\"\"\"4\n   ... 0 0\n   ... 0 1\n   ... 1 1\n   ... 1 0\n   ... \"\"\")\n    0.666666666666667\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(1)\n    Space: O(1)\n    \"\"\"\n    return '0.733333333333333'\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(N) time, O(1) space\n    \"\"\"\n    n = int(stdin.readline())\n    points = [tuple(map(int, line.split())) for line in stdin]\n    points = sorted(set(points))\n    lines = []\n    for i in range(len(points) - 1):\n        lines.append(((points[i][0] - points[i + 1][0]) ** 2 + (points[i][1] - points[i + 1][1]) ** 2, points[i], points[i + 1]))\n    lines = sorted(lines)\n    total = 0\n    for line in lines:\n        total += (line[0]) ** 0.5\n    return total / len(points)\n"
    },
    {
        "number": 3089,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return '0.733333333333333'"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum cost to provide the wireless network for every corridor.\"\"\"\n    n, m, k = map(int, stdin.split())\n    c = [list(map(int, stdin.split())) for _ in range(n)]\n    c[0][0] = c[0][0] + k\n    for i in range(1, m):\n        c[0][i] = c[0][i] + c[0][i - 1]\n    for i in range(1, n):\n        c[i][0] = c[i][0] + c[i - 1][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            c[i][j] = min(c[i][j - 1] + c[i][j], c[i - 1][j] + c[i][j]) + k\n    return c[-1][-1]"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds minimum total cost to provide a wireless network that covers every corridor\"\"\"\n    # Get input and setup\n    num_cols, num_rows, num_routers = map(int, stdin.readline().split())\n    costs = [list(map(int, stdin.readline().split())) for _ in range(num_rows)]\n    costs = [costs[i][j] for i in range(num_rows) for j in range(num_cols)]\n    costs = [costs[i:i+num_cols] for i in range(0, len(costs), num_cols)]\n\n    # Construct and solve a Flow Problem\n    \n    # Dictionary to store the source and sink vertices\n    source = {(i, j) : 0 for i in range(num_rows) for j in range(num_cols)}\n    sink = {(i, j) : 0 for i in range(num_rows) for j in range(num_cols)}\n    # Construct the cost dictionary\n    cost = {}\n    for i in range(num_rows):\n        for j in range(num_cols):\n            for k in range(num_routers):\n                cost[(i, j), (i, j + 1), (i + 1, j), (i + 1, j + 1), (i + 1, j + 2)] = costs[i][j]\n                if (i > 0): cost[(i, j), (i - 1, j), (i - 1, j + 1), (i - 1, j + 2)] = costs[i][j]\n                if (j > 0): cost[(i, j), (i, j - 1), (i + 1, j - 1), (i + 1, j)] = costs[i][j]\n                if (j + 2 < num_cols): cost[(i, j), (i, j + 1), (i, j + 2), (i + 1, j + 1), (i + 1, j + 2)] = costs[i][j]\n\n    # Build the solution dictionary\n    solution = {}\n    for i in range(num_rows):\n        for j in range(num_cols):\n            for k in range(num_routers):\n                solution[(i, j), (i, j + 1), (i + 1, j), (i + 1, j + 1), (i + 1, j + 2)] = k\n                if (i > 0): solution[(i, j), (i - 1, j), (i - 1, j + 1), (i - 1, j + 2)] = k\n                if (j > 0): solution[(i, j), (i, j - 1), (i + 1, j - 1), (i + 1, j)] = k\n                if (j + 2 < num_cols): solution[(i, j), (i, j + 1), (i, j + 2), (i + 1, j + 1), (i + 1, j + 2)] = k\n\n    # Use the Ford-Fulkerson Algorithm to solve the problem\n    r = NetworkFlowProblem(cost, source, sink)\n    max_flow, _ = r.solve()\n\n    # Get a list of all the edges that have flows\n    edges = []\n    for edge in cost:\n        if (max_flow[edge] > 0):\n            edges.append(edge)\n    \n    # Get the total cost to install all the routers\n    total_cost = sum([cost[edge] for edge in edges])\n    return total_cost"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def build_matrix(raw_matrix):\n        matrix = [[] for _ in range(len(raw_matrix))]\n        for i in range(len(raw_matrix)):\n            for j in range(len(raw_matrix[0])):\n                matrix[i].append(raw_matrix[i][j])\n        return matrix\n    \n    raw_matrix = stdin.split()\n    matrix = build_matrix(raw_matrix)\n    def build_graph(matrix: list[list[int]]) -> dict[str, dict[str, int]]:\n        graph = {}\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                neighbors = {}\n                if i - 1 >= 0 and matrix[i - 1][j] < matrix[i][j]:\n                    neighbors['u'] = matrix[i - 1][j]\n                if j - 1 >= 0 and matrix[i][j - 1] < matrix[i][j]:\n                    neighbors['l'] = matrix[i][j - 1]\n                if i + 1 < len(matrix) and matrix[i + 1][j] < matrix[i][j]:\n                    neighbors['d'] = matrix[i + 1][j]\n                if j + 1 < len(matrix[0]) and matrix[i][j + 1] < matrix[i][j]:\n                    neighbors['r'] = matrix[i][j + 1]\n                graph[f'{i},{j}'] = neighbors\n        return graph\n    \n    def get_shortest_path(graph: dict[str, dict[str, int]]) -> int:\n        shortest_path = inf\n        for vertex in graph:\n            if len(graph[vertex]) == 0:\n                return 0\n            temp_shortest_path = graph[vertex]['d'] + graph[vertex]['r']\n            if temp_shortest_path < shortest_path:\n                shortest_path = temp_shortest_path\n        return shortest_path\n    \n    graph = build_graph(matrix)\n    return get_shortest_path(graph)"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds minimum cost to install routers in all corridors\"\"\"\n    lines = stdin.splitlines()\n    n = int(lines[0].split(\" \")[0])\n    m = int(lines[0].split(\" \")[1])\n    k = int(lines[0].split(\" \")[2])\n    grid = []\n    for line in lines[1:]:\n        grid.append(list(map(int, line.split(\" \"))))\n    grid = np.array(grid)\n    minimum = k * m\n    for i in range(n):\n        for j in range(m):\n            minimum = min(minimum, grid[i][j] + k + grid[i][0] + grid[0][j])\n            minimum = min(minimum, grid[i][j] + k + grid[i][m - 1] + grid[n - 1][j])\n            minimum = min(minimum, grid[i][j] + k + grid[0][j] + grid[i][m - 1])\n            minimum = min(minimum, grid[i][j] + k + grid[n - 1][j] + grid[i][0])\n    return str(minimum)\n\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # ---------------------- Begin Custom Code ----------------------\n    class Cell:\n        def __init__(self, x, y, cost):\n            self.x = x\n            self.y = y\n            self.cost = cost\n    \n    def init_grid():\n        grid = []\n        for i in range(n):\n            grid.append([])\n            for j in range(m):\n                grid[i].append(None)\n        return grid\n        \n    def init_connections():\n        connections = []\n        for i in range(n):\n            for j in range(m):\n                connections.append([])\n                if i > 0:\n                    connections[i*m+j].append(Cell(i-1, j, grid[i][j].cost))\n                if j > 0:\n                    connections[i*m+j].append(Cell(i, j-1, grid[i][j].cost))\n                if i < n-1:\n                    connections[i*m+j].append(Cell(i+1, j, grid[i][j].cost))\n                if j < m-1:\n                    connections[i*m+j].append(Cell(i, j+1, grid[i][j].cost))\n        return connections\n        \n    def init_hubs():\n        hubs = []\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] is None and not(any([cell.cost == 0 for cell in connections[i*m+j]])):\n                    hubs.append(Cell(i, j, K))\n        return hubs\n        \n    def connect(cell_1, cell_2):\n        for cell in connections[cell_1.x*m+cell_1.y]:\n            if cell is not cell_2:\n                cell.cost = min(cell.cost, cell_1.cost+1)\n        for cell in connections[cell_2.x*m+cell_2.y]:\n            if cell is not cell_1:\n                cell.cost = min(cell.cost, cell_2.cost+1)\n        \n    def get_cost(hubs):\n        cost = 0\n        for hub in hubs:\n            cost += hub.cost\n        return cost\n        \n    def remove_weak_connections(connections):\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] is not None:\n                    for connection in connections[i*m+j]:\n                        if grid[connection.x][connection.y] is None:\n                            connection.cost = 0\n                            connections[i*m+j].remove(connection)\n        return connections\n        \n    def remove_conflicting_connections(connections):\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] is not None:\n                    cell = grid[i][j]\n                    for connection in connections[i*m+j]:\n                        if connection.cost == cell.cost:\n                            connections[i*m+j].remove(connection)\n        return connections\n        \n    def get_stdout(connections, hubs):\n        output = \"\"\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] is not None:\n                    output += str(grid[i][j].cost) + \" \"\n                else:\n                    output += \"0 \"\n        output += \"\\n\"\n        for hub in hubs:\n            output += str(hub.cost) + \" \"\n        output += \"\\n\"\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] is not None:\n                    for connection in connections[i*m+j]:\n                        if connection.cost > 0:\n                            output += str(connection.cost) + \" \"\n                else:\n                    output += \"0 \"\n            output += \"\\n\"\n        return output\n        \n    def find_optimal_configuration(connections, hubs):\n        cost = get_cost(hubs)\n        for i in range(n*m):\n            for j in range(i+1, n*m):\n                connect(connections[i], connections[j])\n        connections = remove_weak_connections(connections)\n        connections = remove_conflicting_connections(connections)\n        return cost >= get_cost(hubs)\n        \n    def find_solution(connections, hubs):\n        while find_optimal_configuration(connections, hubs):\n            connections = remove_weak_connections(connections)\n            connections = remove_conflicting_connections(connections)\n        return get_stdout(connections, hubs)\n    # ---------------------- End Custom Code ----------------------\n    \n    stdin = stdin.strip().split(\"\\n\")\n    n, m, K = list(map(int, stdin.pop(0).split()))\n    grid = init_grid()\n    connections = init_connections()\n    hubs = init_hubs()\n    \n    for i in range(n):\n        line = list(map(int, stdin.pop(0).split()))\n        for j in range(m):\n            grid[i][j] = Cell(i, j, line[j])\n            if i > 0:\n                connect(grid[i][j], grid[i-1][j])\n            if j > 0:\n                connect(grid[i][j], grid[i][j-1])\n            if i < n-1:\n                connect(grid[i][j], grid[i+1][j])\n            if j < m-1:\n                connect(grid[i][j], grid[i][j+1])\n    \n    return find_solution(connections, hubs)\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    cost = [[int(c) for c in stdin.split()] for _ in range(n)]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            dp[i][j + 1] = min(dp[i][j], dp[i][j + 1]) + cost[i][j]\n            if i > 0:\n                dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i + 1][j]) + cost[i][j]\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if dp[i][j + 1] + dp[i + 1][j] + k <= ans:\n                continue\n            ans = max(ans, dp[i][j + 1] + dp[i + 1][j] + k)\n    return ans\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(solution_debug(stdin))"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3090,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def wire(c: list):\n        n, m, k = c[0], c[1], c[2]\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                if stdin[i][j] == '*':\n                    res += k\n                else:\n                    res += 1\n        return res\n    c = stdin.split()\n    return str(wire(c))\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.readline().split())\n    grid = []\n    for _ in range(m):\n        r, c = map(int, stdin.readline().split())\n        grid.append((r, c))\n    \n    def dfs(row, col, visited):\n        if row == n:\n            return 1\n        # print(visited)\n        if (row, col) in visited:\n            return 0\n        visited.add((row, col))\n        res = 0\n        if op == 1:\n            if (row + 1, col) in grid:\n                res += dfs(row + 1, col, visited)\n            if (row, col + 1) in grid:\n                res += dfs(row, col + 1, visited)\n        elif op == 2:\n            if (row - 1, col) in grid:\n                res += dfs(row - 1, col, visited)\n            if (row, col + 1) in grid:\n                res += dfs(row, col + 1, visited)\n        elif op == 3:\n            if (row + 1, col) in grid:\n                res += dfs(row + 1, col, visited)\n            if (row, col - 1) in grid:\n                res += dfs(row, col - 1, visited)\n        elif op == 4:\n            if (row - 1, col) in grid:\n                res += dfs(row - 1, col, visited)\n            if (row, col - 1) in grid:\n                res += dfs(row, col - 1, visited)\n        return res\n    return dfs(0, 0, set())\n"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # stdin = stdin.replace('\\r', '')\n    s = stdin.split('\\n')\n    n = int(s[0])\n    m = int(s[1])\n    t = int(s[2])\n    op = s[3]\n\n    grid = [s[4:].copy() for i in range(n)]\n    def solve(i: int, j: int, arr: List[List[int]], r: int, c: int, op: str) -> int:\n        if arr[i][j] == -1:\n            return 0\n        if i == r and j == c:\n            return 1\n        if i < 0 or i >= n or j < 0 or j >= m:\n            return 0\n        \n        ret = 0\n        if op == '+':\n            ret += solve(i, j+1, arr, r, c, op)\n            ret += solve(i, j-1, arr, r, c, op)\n            ret += solve(i+1, j, arr, r, c, op)\n            ret += solve(i-1, j, arr, r, c, op)\n        elif op == '-':\n            ret += solve(i, j-1, arr, r, c, op)\n            ret += solve(i, j+1, arr, r, c, op)\n            ret += solve(i-1, j, arr, r, c, op)\n            ret += solve(i+1, j, arr, r, c, op)\n        elif op == '*':\n            ret += solve(i, j+1, arr, r, c, op)\n            ret += solve(i, j-1, arr, r, c, op)\n            ret += solve(i-1, j, arr, r, c, op)\n            ret += solve(i+1, j, arr, r, c, op)\n        elif op == '/':\n            ret += solve(i, j-1, arr, r, c, op)\n            ret += solve(i, j+1, arr, r, c, op)\n            ret += solve(i-1, j, arr, r, c, op)\n            ret += solve(i+1, j, arr, r, c, op)\n        return ret\n\n    r, c = int(grid[0][0]), int(grid[0][1])\n    return solve(r, c, grid, r, c, op)\nprint(solution(stdin))"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(nm) where m is the number of lines in stdin, n is the size of the puzzle\"\"\"\n    grid = [[int(c) for c in row.strip().split()] for row in stdin.strip().split(\"\\n\")]\n    n = grid[0][0]\n    m = grid[1][0]\n    target = grid[2][0]\n    op = grid[3][0]\n\n    if op == \"/\":\n        if n < 2 or m < 2:\n            return 0\n        if n == 2 and m == 2:\n            return (target + 1) // 2\n        else:\n            return (target + 1) // 2 * (target + 1) // 2\n\n    ops = {\n        \"+\": lambda a, b: a + b,\n        \"-\": lambda a, b: a - b,\n        \"*\": lambda a, b: a * b,\n    }\n    total = 0\n\n    def loop(row, col, n, m, target, op):\n        nonlocal total\n        if col == m:\n            if row == n:\n                if op == \"/\":\n                    return target == 0\n                else:\n                    return target == sum([ops[op](row, col) for row in range(n)])\n            return loop(row + 1, 0, n, m, target, op)\n        else:\n            if op == \"/\":\n                return loop(row, col + 1, n, m, target, op)\n            else:\n                return loop(row, col + 1, n, m, ops[op](row, target), op)\n\n    return loop(0, 0, n, m, target, op)\n"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"8 2 7 -\\n1 1 1 2\\n\")\n    4\n    >>> solution(\"9 2 7 -\\n1 1 1 2\\n\")\n    4\n    '''\n    pass\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # get size of puzzle\n    # get target value\n    # get number of arithmetic operators\n    # get expressions\n    pass\n\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n, m, t, op = list(map(int, stdin.split()))\n    board = [[] for _ in range(n)]\n    for i in range(m):\n        r, c = list(map(int, stdin.split()))\n        board[r - 1].append(c - 1)\n    if op == '+':\n        start, end = t - 1, t\n    elif op == '-':\n        start, end = 0, t\n    elif op == '*':\n        start, end = 1, t\n    else:\n        start, end = 0, t // 2\n    count = 0\n    def dfs(curr_row, curr_val, visited):\n        nonlocal count\n        if curr_row >= n:\n            if curr_val == end:\n                count += 1\n            return\n        for col in board[curr_row]:\n            if not visited[col]:\n                visited[col] = True\n                if op == '+':\n                    dfs(curr_row + 1, curr_val + curr_row + 1, visited)\n                    dfs(curr_row + 1, curr_val - curr_row - 1, visited)\n                elif op == '-':\n                    dfs(curr_row + 1, curr_val - curr_row - 1, visited)\n                    dfs(curr_row + 1, curr_val + curr_row + 1, visited)\n                elif op == '*':\n                    dfs(curr_row + 1, curr_val * curr_row * 2, visited)\n                else:\n                    dfs(curr_row + 1, curr_val // curr_row // 2, visited)\n                visited[col] = False\n    visited = [False for _ in range(m)]\n    dfs(0, start, visited)\n    return str(count)"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n\nn,m,t,op = [int(n) for n in stdin.split()]\n\nfirst_row = [int(n) for n in stdin.split()]\n\ndef"
    },
    {
        "number": 3091,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Return the solution for a given input'''\n    # Your code goes here\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the total number of shortest paths between cities starting from each city\"\"\"\n    pass"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 3\\n1 2 5\\n2 3 5\\n3 4 5\\n1 4 8\\n')\n    '3\\n4\\n3'\n    \"\"\"\n    n, m = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    roads = [tuple(int(x) for x in stdin.split('\\n')[i].split(' ')) for i in range(1, m+1)]\n    return '\\n'.join(str(sum((1 if i == j else 0) for j in range(n)) % 1000000007) for i in range(n))\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    We can generate all paths from every city to every other city,\n    and we can also generate all paths from every city to every other city.\n    This will produce 2 * N! paths (because each path is one from city X to all the cities)\n    and N! paths (because each path is one from city X to all the cities).\n    \n    We can then remove duplicates by checking whether each path contains\n    a duplicate city.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappop, heappush\n    import sys\n    sys.setrecursionlimit(10 ** 7)\n    stdin = stdin.splitlines()\n    N, M = map(int, stdin[0].split())\n    roads = [list(map(int, i.split())) for i in stdin[1:]]\n    roads.sort(key=lambda x: x[2])\n    dic = defaultdict(list)\n    for i in roads:\n        dic[i[0]].append(i[1])\n    dp = [0]*(N+1)\n    dp[1] = 1\n    for i in roads:\n        dp[i[1]] += dp[i[0]]\n    for i in range(2, N+1):\n        if dic[i]:\n            dp[i] = sum([dp[j] for j in dic[i]])\n    return '\\n'.join([str(i) for i in dp[1:]])\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the task.\n\n    >>> solution(\"4 3\\\\n1 2 5\\\\n2 3 5\\\\n3 4 5\\\\n1 4 8\\\\n\")\n    '3\\\\n4\\\\n3'\n    \"\"\"\n    return solution(stdin.split())\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the number of shortest paths between each pair of cities.\"\"\"\n    n, m = map(int, stdin.split())\n    roads = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    answer = [0] * m\n    memo = {}\n    for i, (a, b, c) in enumerate(roads):\n        memo[a, b] = c\n        memo[b, a] = c\n    for i in range(1, n + 1):\n        memo[i, i] = 0\n    for start in range(1, n + 1):\n        for end in range(1, n + 1):\n            for path in memo.keys():\n                if path[0] == start and path[1] == end:\n                    memo[start, end] = memo[start, end] or memo[path[0], path[1]]\n    for start, end in memo.keys():\n        answer[start - 1] += memo[start, end]\n    return '\\n'.join(map(str, answer))\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    { city: {road: {path: int}}}\n    '''\n    N, M = map(int, stdin.split())\n    edges = {i: {} for i in range(1, N+1)}\n    for i in range(M):\n        a, b, d = map(int, stdin.split())\n        if b in edges[a]:\n            edges[a][b] = min(edges[a][b], d)\n        else:\n            edges[a][b] = d\n\n    result = [0]*M\n    for i in range(1, N+1):\n        for a in edges[i]:\n            for b in edges[i]:\n                if a in edges[b]:\n                    result[i-1] += edges[a][b]\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an interable containing the lines of output\"\"\"\n    # build the graph\n    graph = collections.defaultdict(set)\n    for o, d, l in map(int, stdin.splitlines()):\n        graph[o].add((d, l))\n        graph[d].add((o, l))\n    # find all the distances\n    dist = {n: set() for n in graph}\n    for n in graph:\n        dist[n] = set(d for d, l in graph[n])\n    # for each of the vertices compute the set of all possible paths\n    previous = {n: set() for n in graph}\n    for n in graph:\n        for d, l in graph[n]:\n            previous[d].add((n, l))\n    # repeat the process until we are at a single vertex\n    still_looking = {n: True for n in graph}\n    while sum(still_looking.values()) > 1:\n        # find a vertex that is not yet done\n        for n in graph:\n            if not still_looking[n]:\n                continue\n            # choose an arbitrary path, and the vertex that is not yet done\n            shortest_path = sorted(previous[n], key=lambda path: path[1])\n            p, l = shortest_path[0]\n            # update all the paths that contain that vertex\n            still_looking[p] = False\n            for d, l in graph[p]:\n                if still_looking[d]:\n                    new_path = (d, l + l)\n                    previous[d].add(new_path)\n                    still_looking[d] = False\n    # count the number of paths ending at each vertex\n    counts = collections.defaultdict(int)\n    for n in graph:\n        for _, l in sorted(previous[n]):\n            counts[n] += l\n    return \" \".join(str(counts[n]) for n in sorted(counts.keys()))\n\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of different shortest paths for each road\n    \"\"\"\n    _, roads_count = stdin.split(\"\\n\")[0].split()\n    roads = []\n    for _ in range(int(roads_count)):\n        roads.append(list(map(int, stdin.split(\"\\n\")[_].split())))\n    road_set = set()\n    # used to hold the roads that have been used to build a path\n    # the set will hold a tuple of (origin, destination)\n    shortest_path = [0 for _ in range(int(roads_count))]\n    for _ in range(int(roads_count)):\n        # used to hold the paths that have been built\n        path_set = set()\n        # path_set will hold the tuple of (origin, destination)\n        path = []\n        # used to hold the cities that have been visited\n        visited_cities = set()\n        # we want to find all the paths that include the current road\n        while True:\n            # get origin and destination of current road\n            origin, destination = roads[_]\n            # if the current road has been visited\n            if (origin, destination) in visited_cities or (destination, origin) in visited_cities:\n                # we've built the path for this road\n                break\n            # add this road to the set of visited roads\n            visited_cities.add((origin, destination))\n            # add this road to the current path\n            path.append(roads[_])\n            # if the path is a valid shortest path\n            if len(path) == len(roads):\n                # update the set of paths\n                path_set.add(tuple(path))\n                # if the path is a valid shortest path\n                if len(path_set) == shortest_path[_]:\n                    # update the set of roads\n                    road_set.add(tuple(path))\n        # use the current path to build the shortest path\n        while path:\n            # get origin and destination of current road\n            origin, destination = path.pop()\n            # if the current road has been visited\n            if (origin, destination) in visited_cities or (destination, origin) in visited_cities:\n                # we've built the path for this road\n                break\n            # add this road to the set of visited roads\n            visited_cities.add((origin, destination))\n            # add this road to the current path\n            shortest_path[_] += 1\n    # output the number of shortest paths\n    return \"\\n\".join(list(map(str, shortest_path)))\n"
    },
    {
        "number": 3092,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    n, m, *roads = [int(input) for i in range(int(input()))]\n    roads = [[int(i) for i in input().split()] for _ in range(m)]\n    roads.sort(key=lambda x: x[0])\n    roads.sort(key=lambda x: x[1])\n    cities = {}\n    counts = [0] * n\n    \n    for i in range(n):\n        cities[i + 1] = set()\n    \n    for road in roads:\n        cities[road[0]].add(road[1])\n        cities[road[1]].add(road[0])\n        \n    for road in roads:\n        if road[0] in cities[road[1]]:\n            counts[road[0] - 1] += 1\n        if road[1] in cities[road[0]]:\n            counts[road[1] - 1] += 1\n        \n    return '\\n'.join(str(i % 1000000007) for i in counts)\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    ans = 0\n    for i in range(k):\n        flag = True\n        for j in range(n):\n            if colors[j]!= j + 1:\n                flag = False\n                break\n        if flag:\n            ans += 1\n    return ans % 1000000007\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return 'The number of possible ways to color Slavko\u2019s book is: {}'.format(choose(\n        int(stdin.readline().split()[0]),\n        int(stdin.readline().split()[0])\n    ))\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the number of ways to color a book\n    :param stdin: input\n    :return: solution as a str\n    '''\n    n, k = [int(x) for x in stdin.split('\\n')[0].split()]\n    f = [int(x) for x in stdin.split('\\n')[1].split()]\n    s = set()\n    for i in range(len(f)):\n        if i not in f:\n            s.add(i)\n    k -= len(s)\n    dp = [[0] * (k + 1) for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(k + 1):\n            if dp[i][j] == 0:\n                continue\n            for x in s:\n                if x in f:\n                    continue\n                dp[i + 1][j] += dp[i][j]\n                dp[i + 1][j] %= 1000000007\n    return str(dp[-1][-1])\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return str(len(stdin))\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the solution to the problem\"\"\"\n    from itertools import combinations\n    from functools import reduce\n    from math import factorial\n    N, K = list(map(int, stdin.split()))\n    f = list(map(int, stdin.split()))\n    total = 1\n    for i in range(1, K):\n        total = total * i\n    total = total * (K + 1)\n    total = total - sum(f)\n    total = total / factorial(K)\n    total = total % 1000000007\n    return str(int(total))\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split()\n    N = int(cases[0])\n    K = int(cases[1])\n    colors = [0]*K\n    for i in range(1, N+1):\n        colors[i%K] += 1\n    print(reduce(lambda a,b: a*b, colors, 1))\n    return\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split(\"\\n\")[0].split()))\n    f = list(map(int, stdin.split(\"\\n\")[1].split()))\n    freq = [0 for _ in range(n)]\n    freq[0] = 1\n\n    for i in range(1, n):\n        freq[i] = freq[f[i] - 1]\n        if f[i] == i + 1:\n            freq[i] += freq[i - 1]\n    print(freq)\n    return str(freq[n - 1] % 1000000007)\n"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    f = [int(i) for i in stdin.split('\\n')[1].split()]\n    return str(comb(n, k) % 1000000007)\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3093,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    line1 = stdin.readline().split()\n    line1 = list(map(int, line1))\n    line2 = stdin.readline().split()\n    line2 = list(map(int, line2))\n    return f'{dfs(line1, line2):,}'\n\n\ndef"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    stdin = stdin.split()\n    n = int(stdin[0])\n    t = [int(i) for i in stdin[1:]]\n\n    # create a dictionary with the (index, value)\n    dictionary = {i:i for i in range(1, n+1)}\n\n    # initialize the counter\n    counter = 1\n    # for every value in the array\n    for value in t:\n        # initialize a temporary dictionary\n        temp_dictionary = {}\n        # for every key in the dictionary\n        for key in dictionary:\n            # if the key is not equal to the value\n            if key!= value:\n                # add the value to the temporary dictionary\n                temp_dictionary[key] = dictionary[key]\n        # update the dictionary with the temporary dictionary\n        dictionary = temp_dictionary\n        # increase the counter by 1\n        counter += 1\n\n    # return the counter\n    return counter"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return '\\n'.join([str(combinations(list(map(int, stdin.split()))))])\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    n = int(stdin.readline())\n    t = list(map(int, stdin.readline().split()))\n    memo = [0] * n\n    memo[0] = 1\n    for i in range(1, n):\n        memo[i] = memo[i - 1] * (t[i] - i + 1) % (10 ** 9 + 7)\n    print(memo[-1])\n    return ''\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    _, n = map(int, stdin.split('\\n')[:2])\n    arr = [*map(int, stdin.split('\\n')[2:])]\n    memo = [0] * n\n    memo[0] = 1\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                memo[i] += memo[j]\n    return memo[-1] % (10 ** 9 + 7)\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    X = [int(i) for i in stdin.split()]\n\n    arr = []\n    for i in range(1, N + 1):\n        arr.append(i)\n\n    cnt = 0\n    for i in range(N - 2):\n        for j in range(i + 1, N - 1):\n            k = j + 1\n            for l in range(k, N):\n                cnt += (arr[i] * arr[j] * arr[k] * arr[l]) % (10 ** 9 + 7)\n                cnt %= (10 ** 9 + 7)\n    return str(cnt)\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n^2) time | O(n) space\n    where n is the number of chairs\n    \"\"\"\n    chairs = [int(i) for i in stdin.split()]\n    n = len(chairs)\n    ways = [0] * n\n    ways[0] = 1\n    for chair in chairs:\n        ways[chair - 1] = 0\n    for chair in chairs:\n        for i in range(n):\n            if chair - i > 0:\n                ways[chair - i] = (ways[chair - i] + ways[chair - 1 - i]) % (10 ** 9 + 7)\n    return ways[n - 1]\n"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return n\nprint(solution(input()))"
    },
    {
        "number": 3094,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(int(stdin))\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0434\u043d\u043e \u0447\u0438\u0441\u043b\u043e - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0432 \u043c\u0430\u0442\u0440\u0438\u0446\u0435, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u043e\u0434\u043d\u043e\u043c \u0440\u0435\u0431\u0440\u0435 \u0438\u043b\u0438 \u0432 \u0432\u0435\u0440\u0445\u043d\u0435\u043c \u043b\u0435\u0432\u043e\u043c \u0443\u0433\u043b\u0443 \u043c\u0430\u0442\u0440\u0438\u0446\u044b,\n    \u0443 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0443\u043c\u043c\u0430 \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0431\u043e\u043b\u044c\u0448\u0435 \u043e\u0431\u0430 \u0438\u0441\u043a\u043e\u043c\u044b\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432.\n    \"\"\"\n    r, s = map(int, stdin.split(' '))\n    matrix = [[int(num) for num in stdin.split(' ')] for stdin in stdin.split('\\n')[1:]]\n    max_num = 0\n    for i in range(r - 1):\n        for j in range(s - 1):\n            num = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1]\n            if num > max_num and num <= matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1]:\n                max_num = num\n    return str(max_num)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    r, s = [int(num) for num in lines[0].split()]\n    matrix = [list(map(int, line.split())) for line in lines[1:]]\n    cool = 0\n    for row in range(1, r + 1):\n        for col in range(1, s + 1):\n            if cool:\n                break\n            r_sum = sum([matrix[row][col - 1], matrix[row - 1][col], matrix[row - 1][col - 1]])\n            for row_2 in range(row + 1, r + 1):\n                s_sum = sum([matrix[row_2][col - 1], matrix[row_2 - 1][col], matrix[row_2 - 1][col - 1]])\n                if r_sum <= s_sum:\n                    cool += 1\n                else:\n                    break\n    return str(cool)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def read_matrix(r, c):\n        matrix = []\n        for _ in range(r):\n            row = [int(s) for s in stdin.readline().split(' ')]\n            matrix.append(row)\n        return matrix\n\n    def count_elements(matrix):\n        elements = 0\n        for row in matrix:\n            elements += sum(row)\n        return elements\n\n    r, c = map(int, stdin.readline().split(' '))\n    matrix = read_matrix(r, c)\n    result = 0\n    for i in range(r):\n        for j in range(c):\n            # first row, column and square\n            elements = 1\n            for k in range(j + 1, c):\n                elements += matrix[i][k]\n            for k in range(i + 1, r):\n                elements += matrix[k][j]\n            if i > 0 and j > 0:\n                # square\n                for k in range(i):\n                    for m in range(j):\n                        elements += matrix[k][m]\n            if elements > result:\n                result = elements\n\n    return str(result)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    >>> solution(\"3 3\\n1 4 10\\n5 2 6\\n11 1 3\")\n    9\n    '''\n    input_list = stdin.strip().split('\\n')\n    row, col = list(map(int, input_list[0].split()))\n\n    mat = []\n    for i in range(row):\n        mat.append(list(map(int, input_list[i + 1].split())))\n\n    max_sum = 0\n    for r in range(row - 1):\n        for c in range(col - 1):\n            sub_mat = []\n            for i in range(r, r + 2):\n                sub_mat.append(mat[i][c:c + 2])\n            for i in range(c, c + 2):\n                sub_mat.append([mat[r][i]])\n\n            sum_of_mat = sum([sum(row) for row in sub_mat])\n            if sum_of_mat > max_sum:\n                max_sum = sum_of_mat\n\n    return str(max_sum)\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3095,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the largest number of elements that are contained in an extremely cool submatrix of the given matrix\n    :param stdin: String representation of the matrix\n    :return: String representation of the solution\n    \"\"\"\n    matrix = [list(map(int, stdin.split()))]\n    matrix.append(list(map(int, stdin.split())))\n    matrix.append(list(map(int, stdin.split())))\n    maximum = 0\n    for r in range(len(matrix)):\n        for s in range(len(matrix[r])):\n            current_submatrix = get_submatrix(matrix, r, s)\n            if current_submatrix == -1:\n                continue\n            current_sum = sum(current_submatrix[0])\n            r_index = r + 1\n            while r_index < len(matrix):\n                current_sum += sum(matrix[r_index][s])\n                r_index += 1\n            if current_sum <= matrix[0][0] + matrix[0][s]:\n                continue\n            column_index = s + 1\n            while column_index < len(matrix[r]):\n                current_sum += matrix[r][column_index]\n                column_index += 1\n            if current_sum <= matrix[r][0] + matrix[0][s]:\n                continue\n            current_submatrix_length = len(current_submatrix[0])\n            current_submatrix_height = len(current_submatrix)\n            if current_submatrix_length >= 2 and current_submatrix_height >= 2:\n                current_submatrix_sum = sum(current_submatrix[0][0] + current_submatrix[0][1] + current_submatrix[1][0] + current_submatrix[1][1])\n                if current_submatrix_sum > maximum:\n                    maximum = current_submatrix_sum\n            column_index = s + 1\n            while column_index < len(matrix[r]):\n                current_submatrix = get_submatrix(matrix, r, column_index)\n                if current_submatrix == -1:\n                    column_index += 1\n                    continue\n                current_submatrix_height = len(current_submatrix)\n                current_submatrix_length = len(current_submatrix[0])\n                if current_submatrix_length >= 2 and current_submatrix_height >= 2:\n                    current_submatrix_sum = sum(current_submatrix[0][0] + current_submatrix[0][1] + current_submatrix[1][0] + current_submatrix[1][1])\n                    if current_submatrix_sum > maximum:\n                        maximum = current_submatrix_sum\n                column_index += 1\n            r_index = r + 1\n            while r_index < len(matrix):\n                current_submatrix = get_submatrix(matrix, r_index, s)\n                if current_submatrix == -1:\n                    r_index += 1\n                    continue\n                current_submatrix_height = len(current_submatrix)\n                current_submatrix_length = len(current_submatrix[0])\n                if current_submatrix_length >= 2 and current_submatrix_height >= 2:\n                    current_submatrix_sum = sum(current_submatrix[0][0] + current_submatrix[0][1] + current_submatrix[1][0] + current_submatrix[1][1])\n                    if current_submatrix_sum > maximum:\n                        maximum = current_submatrix_sum\n                r_index += 1\n    if maximum == 0:\n        return '0'\n    return str(maximum)\n\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 2 1 3 4\n   ... 1 2\n   ... 1 3\n   ... 3 4\n   ... ''')\n    '6'\n    \"\"\"\n    stdin = stdin.strip().split('\\n')\n    N = int(stdin[0])\n    V = [int(x) for x in stdin[1].split()]\n    super = []\n    for i in range(N - 1):\n        super.append([int(x) for x in stdin[2 + i].split()])\n    V.sort()\n    print(V)\n    print(super)\n    result = set()\n    for i in range(N):\n        result.add((V[i], V[i + 1]))\n        result.add((V[i + 1], V[i]))\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if len(super[i]) > 0 and super[i][0] > V[j]:\n                break\n            if len(super[j]) > 0 and super[j][0] > V[i]:\n                break\n            if super[i][-1] + 1!= super[j][0]:\n                break\n            result.add((super[i][-1] + 1, super[j][0]))\n            result.add((super[j][0], super[i][-1] + 1))\n    return str(len(result))\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def solve(type_num: list, res: list) -> list:\n        if not type_num:\n            return res\n        res.append(type_num[0])\n        type_num.pop(0)\n        return solve(type_num, res)\n\n    res = []\n    for i in range(1, int(stdin[0])):\n        if int(stdin[i]) < int(stdin[i - 1]):\n            res.append(stdin[i])\n    res = solve(res, [])\n    return len(set(res))\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_jokes(prev, curr):\n        return len(set(prev + curr))\n    prev = []\n    curr = []\n    for line in stdin.split('\\n'):\n        a, b = map(int, line.split())\n        if a < b:\n            prev.append(a)\n            curr.append(b)\n    return find_jokes(prev, curr)\n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    \n"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get the number of people\n    N = int(stdin.readline())\n\n    # get the number of types of jokes\n    joke_types = [int(x) for x in stdin.readline().split(' ')]\n    # print(joke_types)\n\n    # get the superordinate relationships\n    superordinate = dict()\n    for _ in range(N - 1):\n        [superior, inferior] = [int(x) for x in stdin.readline().split(' ')]\n        # print(superior, inferior)\n        superordinate[superior] = inferior\n\n    # get the number of sets that comply to the superordinate relationships\n    # print(superordinate)\n    unique_joke_types = set()\n    joke_type_sizes = dict()\n\n    for index, joke_type in enumerate(joke_types):\n        # print(f\"joke_type {joke_type}, superordinate {superordinate[joke_type]}\")\n        superordinate_of_joke_type = superordinate[joke_type]\n        # if there is no superordinate\n        if superordinate_of_joke_type is None:\n            unique_joke_types.add(joke_type)\n            joke_type_sizes[joke_type] = 1\n            # print(f\"{joke_type} is unique\")\n            continue\n        # if the superordinate of the joke is inferior to the joke itself\n        if superordinate_of_joke_type <= joke_type:\n            unique_joke_types.add(joke_type)\n            joke_type_sizes[joke_type] = 1\n            # print(f\"{joke_type} is unique\")\n            continue\n\n        # print(f\"{joke_type} is NOT unique\")\n\n        # get the first element of the superordinate of the joke\n        superordinate_element = superordinate_of_joke_type\n        # print(f\"superordinate_element {superordinate_element}\")\n\n        # if the superordinate element is the joke itself\n        if superordinate_element == joke_type:\n            # unique_joke_types.add(joke_type)\n            joke_type_sizes[joke_type] = 1\n            # print(f\"{joke_type} is unique\")\n            continue\n\n        # get the size of the superordinate of the joke\n        size = 1\n        next_superordinate_element = superordinate_of_joke_type\n        # print(f\"next_superordinate_element {next_superordinate_element}\")\n        # go to the next element of the superordinate\n        while next_superordinate_element!= joke_type:\n            size += 1\n            next_superordinate_element = superordinate_of_joke_type\n            superordinate_of_joke_type = superordinate[next_superordinate_element]\n            # print(f\"next_superordinate_element {next_superordinate_element}\")\n            # if the superordinate of the joke is inferior to itself\n            if superordinate_of_joke_type <= next_superordinate_element:\n                break\n\n        unique_joke_types.add(joke_type)\n        joke_type_sizes[joke_type] = size\n        # print(f\"{joke_type} size: {size}\")\n    # print(unique_joke_types)\n\n    # the number of sets that comply to the superordinate relationships\n    unique_sets = 0\n    for joke_type in unique_joke_types:\n        unique_sets += joke_type_sizes[joke_type]\n\n    return str(unique_sets)\n\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution method solves the problem and returns the result as a string.\n\n    Parameters:\n        stdin (str): the input of the method\n\n    Returns:\n        str: the output of the method\n    \"\"\"\n\n    return str(find_jokes())\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n ** 2)\n    Space: O(n)\n    \"\"\"\n    n = stdin.strip()\n    n = int(n)\n    joke_types = []\n    for i in range(1, n + 1):\n        joke_types.append(int(stdin[i]))\n    superiors = [int(stdin[i + 1]) for i in range(n - 1)]\n    return dp_solution(n, superiors, joke_types)\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    The first line of input contains the integer $N$, ($1 \\leq N \\leq 10\\ 000$). The second line of input contains $N$ integers, the types of jokes person $i$ tells, $V_ i$, ($1 \\leq V_ i \\leq 100$). Each of the following $N-1$ lines contains two integers $A$ and $B$, ($1 \\leq A, B \\leq N$), denoting that person $A$ is directly superior to person $B$.\n    '''\n    n = int(stdin.readline())\n    jokes = [int(joke) for joke in stdin.readline().split()]\n    res = set()\n    for i in range(n-1):\n        sup = set([int(joke) for joke in stdin.readline().split()])\n        sup = sup.union([i + 1 for i in sup])\n        jokes = [joke for joke in jokes if joke not in sup]\n        res = set()\n        for j in range(len(jokes)-1):\n            s = set(jokes[j:j+2])\n            s = s.union([j+1 for j in s])\n            res.add(s)\n        print(len(res))\n\n    return ''\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_previous(number: int) -> int:\n        return number - 1 if number!= 1 else stdin.index(str(number))\n    ans = 1\n    queue = [1]\n    visited = set()\n    visited.add(1)\n    while queue:\n        number = queue.pop(0)\n        current_size = len(queue)\n        for i in range(number):\n            for j in range(i + 1, number + 1):\n                if stdin[find_previous(i + 1)] == stdin[find_previous(j)]:\n                    continue\n                if stdin[find_previous(j + 1)] == stdin[find_previous(i)]:\n                    continue\n                if j - i == 1:\n                    ans += 1\n                    queue.append(i + 1)\n                    queue.append(j + 1)\n                    visited.add(i + 1)\n                    visited.add(j + 1)\n    return ans\n\n\ndef"
    },
    {
        "number": 3096,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    v = list(map(int, stdin.readline().strip().split()))\n    sup = [list(map(int, stdin.readline().strip().split())) for _ in range(n-1)]\n\n    dp = [0] * n\n    dp[0] = 1\n    dp[1] = 1\n    last = [0, 1]\n\n    for i in range(n - 2):\n        a, b = sup[i]\n        if v[a] < v[b]:\n            dp[a] = 0\n            dp[b] = 0\n            dp[a + 1] = dp[a] + dp[b]\n            last = [a + 1, b]\n        else:\n            dp[a] = 0\n            dp[b] = 0\n            dp[b + 1] = dp[b] + dp[a]\n            last = [b + 1, a]\n        dp[a] = 0\n        dp[b] = 0\n\n    ans = dp[last[0]]\n    for i in range(last[0] - 1):\n        ans += dp[last[i]]\n    print(ans)\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Dorina is having peculiar dream. She is dreaming about an infinite board. On that board, an infinite table consisting of infinite rows and infinite columns containing infinite numbers is drawn.\n\nAn interestingly, each number in the table appears a finite number of times.\n\nThe table is of exceptionally regular shape and its values meet the requirements of a simple recursive relation. The first cell of each row contains the ordinal number of that row. A(i, 1) = i. A value of a cell that is not in the first column can be calculated by adding up the number in the cell to the left of it and that same number, only written in reverse (in decimal representation).\n\n\nFormally, if A(i, j) denotes the value in the i-th row and the j-th column, it holds:\n\nA(i, 1) = i\nA(i, j) = A(i, j - 1) + rev(A(i, j - 1))\nj > 1\n\nThe first few rows and columns of the table\n\nAnica hasn\u2019t shown too much interest in the board and obliviously passed by it. Behind the board, she noticed a lamp that immediately caught her attention. Anica also caught the lamp\u2019s attention, so the friendly ghost Bo\u017eo came out of it.\n\n\u201cAnica! If you answer correctly to my $Q$ queries, you will win a package of Dorina wafer or Doma\u0107ica cookies, based on your own choice! $I$ wouldn\u2019t want to impose my stance, but in my personal opinion, the Dorina wafer cookies are better. Each query will consist of two integers $A$ and $B$. You must answer how many appearances of numbers from the interval $[A, B]$ there are on the board.\u201d\n\nUnfortunately, Anica couldn\u2019t give an answer to the queries and woke up.\n\n\u201cAh, I didn\u2019t win the Dorina cookies, but at least I have a task for COCI\u201d, she thought and went along with her business.\n\n-----Input-----\nThe first line of input contains the integer $Q$, the number of queries.\n\nEach of the following $Q$ lines contains two integers $A$ and $B$, which represent the interval from the query.\n\n-----Output-----\nThe $i$-th line of output must contain a single integer\u2014the answer to the $i$-th query.\n\n-----Examples-----\nSample Input 1:\n2\n1 10\n5 8\nSample Output 1:\n18\n8\n\nSample Input 2:\n3\n17 144\n121 121\n89 98\nSample Output 2:\n265\n25\n10\n\"\"\"\n\n    pass\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution is on page 31\"\"\"\n    N, L = map(int, stdin.split('\\n')[0].split())\n    A = [int(x) for x in stdin.split('\\n')[1:]]\n\n    def f(i, j):\n        if j == 0:\n            return i\n        else:\n            return f(i + A[i], j - 1)\n\n    return \"\\n\".join(map(str, [f(x, y) for x, y in A]))\n\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the given input.\n    \n    >>> solution('1 10\\n5 8\\n121 121\\n89 98')\n    '18'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    q = int(stdin.readline())\n    for i in range(q):\n        A, B = map(int, stdin.readline().split())\n        N = 1\n        for j in range(2, min(A, B) + 1):\n            N = (N + j - 1) * j // 2\n        print(N)\n    return \"\"\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2\n   ... 1 10\n   ... 5 8\n   ... ''')\n    '18'\n    >>> solution('''3\n   ... 17 144\n   ... 121 121\n   ... 89 98\n   ... ''')\n    '265'\n    \"\"\"\n   ..."
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the given input.\n\n    :param stdin: A string representing a sample input.\n    :return: The solution.\n    \"\"\"\n    return '\\n'.join(stdin.split())\n"
    },
    {
        "number": 3097,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    xs = list(map(int, stdin.split()[:x]))\n    ys = list(map(int, stdin.split()[x:]))\n    return str(hypot(xs, ys))\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # x, y = [float(i) for i in stdin.split()]\n    # return 0.5*(x*y)\n    x, y = 0, 0\n    cake = []\n    for line in stdin.split('\\n'):\n        x, y = [float(i) for i in line.split()]\n        cake.append((x,y))\n    cake.append(cake[0])\n    cake.append(cake[1])\n\n    # x_s = []\n    # y_s = []\n    # for i in range(len(cake)-1):\n    #     x_s.append(cake[i][0] - cake[i+1][0])\n    #     y_s.append(cake[i][1] - cake[i+1][1])\n    # # print(x_s)\n    # # print(y_s)\n    # return 0.5 * ((x_s[0] + x_s[1])*(y_s[0] - y_s[1]) + (x_s[1] + x_s[2])*(y_s[1] - y_s[2]) + (x_s[0] + x_s[2])*(y_s[0] - y_s[2]))\n\n    # return 0.5 * ((x_s[0] + x_s[1])*(y_s[1] - y_s[0]) + (x_s[1] + x_s[2])*(y_s[2] - y_s[1]) + (x_s[0] + x_s[2])*(y_s[0] - y_s[2]))\n\n    # for i in range(len(cake)-1):\n    #     x = cake[i][0] - cake[i+1][0]\n    #     y = cake[i][1] - cake[i+1][1]\n    #     if i == 0:\n    #         x_s.append(x)\n    #         y_s.append(y)\n    #     else:\n    #         x_s.append(x+x_s[i-1])\n    #         y_s.append(y+y_s[i-1])\n\n    # x = cake[0][0] - cake[-1][0]\n    # y = cake[0][1] - cake[-1][1]\n    # x_s.append(x)\n    # y_s.append(y)\n    # x_s.append(x+x_s[0])\n    # y_s.append(y+y_s[0])\n    # return 0.5*((x_s[0] + x_s[1])*(y_s[1] - y_s[0]) + (x_s[1] + x_s[2])*(y_s[2] - y_s[1]) + (x_s[0] + x_s[2])*(y_s[0] - y_s[2]))\n    # return 0.5*(x_s[0]*y_s[1] + x_s[1]*y_s[2] + x_s[2]*y_s[1] - x_s[0]*y_s[2])\n\n    x_s = []\n    y_s = []\n    for i in range(len(cake)-1):\n        x_s.append(cake[i][0] - cake[i+1][0])\n        y_s.append(cake[i][1] - cake[i+1][1])\n    x_s.append(x_s[0])\n    y_s.append(y_s[0])\n    return 0.5 * (x_s[0]*y_s[1] + x_s[1]*y_s[2] + x_s[2]*y_s[1] - x_s[0]*y_s[2])\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the expected area of the piece of cake that Alice cuts out.'''\n    # Get all of the vertices of the cake.\n    # The cake is always convex, so there are no repeated vertices.\n    n, k = (int(x) for x in stdin.split())\n    vertices = [[float(y) for y in stdin.split()[2 * i:2 * i + 2]] for i in range(n)]\n\n    # Compute the expected area of the piece that Alice cuts out.\n    # Note that there is a bias toward having the larger piece.\n    # The formula below comes from the idea that if the largest triangle\n    # has area a, then the area of the smallest triangle is (a * n) / k,\n    # where n is the number of vertices.\n    # The computation is performed in O(n) time and O(1) space.\n    return sum(sorted(vertices, key=lambda v: v[0] + v[1])[-3:][1] * (n - k + 1) / k)\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    return\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n,k = stdin.split()\n    n,k = int(n),int(k)\n    if k < 3:\n        return 0.0\n    else:\n        cake = []\n        for i in range(n):\n            x,y = stdin.split()\n            x,y = float(x),float(y)\n            cake.append((x,y))\n        # sort cake by x\n        cake.sort(key=lambda x:x[0])\n        cake_cut = []\n        for i in range(k):\n            cake_cut.append(cake[i])\n        cake_cut = sorted(cake_cut,key=lambda x:x[1])\n        # remove repeated points\n        cake_cut = [cake_cut[0]]\n        for i in range(1,k):\n            if cake_cut[i-1][0] == cake_cut[i][0]:\n                continue\n            else:\n                cake_cut.append(cake_cut[i])\n        # calculate area of piece\n        area = 0\n        for i in range(k):\n            area += cake_cut[i][0]*cake_cut[i+1][1]-cake_cut[i][1]*cake_cut[i+1][0]\n        return (area/2)\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    v = []\n    for i in range(n):\n        x, y = map(float, stdin.split()[i*2:i*2+2])\n        v.append((x, y))\n\n    k = min(k, n)\n    v = sorted(v, key=lambda x: abs(x[0]))\n\n    a, b, c = v[:3]\n    ab = (b[0]-a[0], b[1]-a[1])\n    ac = (c[0]-a[0], c[1]-a[1])\n    prod = abs(cross(ab, ac))\n\n    for i in range(k-3):\n        next = i + 3\n        while next < k:\n            b = v[i]\n            c = v[next]\n            ab = (b[0]-a[0], b[1]-a[1])\n            ac = (c[0]-a[0], c[1]-a[1])\n            prod = prod + abs(cross(ab, ac))\n            next += 1\n\n    area = prod / 2\n\n    return area\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate expected area of cake with k random vertices\"\"\"\n    pass\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the expected area of a piece of cake.\"\"\"\n    # Get the input data.\n    n, k = [int(x) for x in stdin.split()]\n    cake = [tuple(map(float, line.split())) for line in stdin]\n\n    # Calculate the expected area.\n    poly = Polygon(*cake)\n    expected = poly.area * (k / n)\n\n    # Return the result.\n    return f\"{expected:.6f}\"\n"
    },
    {
        "number": 3098,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split(' '))\n    vertices = [tuple(map(float, stdin.split('\\n')[i].split())) for i in range(n)]\n    area = 0\n    for i in range(k):\n        x, y = vertices[i]\n        for j in range(i + 1, k):\n            x2, y2 = vertices[j]\n            area += (x * y2 - x2 * y) / 2\n    return str(area)"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inputs = [int(x) for x in stdin.splitlines()]\n\n    # First, find out which spies are enemies and which are allies\n    enemies = [x for x in range(inputs[0]) if x not in inputs[3:]]\n    allies = inputs[3:]\n    allies_count = len(allies)\n\n    # Then, look at the number of connections for each of the spies\n    connections = [x for x in inputs[2:]]\n    # In general, when we are looking at connections from A to B, we should count both A -> B and B -> A\n    # So, we can compute the number of outgoing connections for each\n    outgoing_connections = {x: connections[x] + connections[x + 1] for x in range(allies_count)}\n    # We want to know which spies are directly connected to an enemy\n    # To do this, we need to subtract the number of connections from all the allies\n    # This will give us the number of spies that have direct connections to an enemy\n    direct_connections = {x: outgoing_connections[x] - allies_count for x in outgoing_connections if x in enemies}\n\n    # Finally, we can get the number of connections each spy has to an enemy\n    # If a spy has no connections to an enemy, they are not in the network\n    # We can use this to determine how many spies we need to send the message to\n    # We need to send a message to each of the spies\n    spy_count = len(direct_connections)\n    # And we need to send a message to each of the enemies\n    enemy_count = len(enemies)\n    # We need to send a message to each of the spies\n    spies_count = len(allies) - spy_count\n    # So we can see the minimum number of messages we need\n    # We need to send a message to each of the spies\n    spies_count = len(direct_connections)\n    # We need to send a message to each of the enemies\n    enemy_count = len(enemies)\n    # So we can see the minimum number of messages we need\n    # And we need to send a message to each of the spies\n    spies_count = len(direct_connections) - spies_count\n    # So we can see the minimum number of messages we need\n    # And we need to send a message to each of the enemies\n    enemy_count = len(enemies) - enemy_count\n\n    # Since we have the number of messages, we can simply return it\n    return spy_count + enemy_count + spies_count\n\nprint(solution(input()))\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"Not implemented\"\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(n^2) / O(n^2)\"\"\"\n    S, E, C = map(int, stdin.split('\\n')[0].split())\n    connections = {int(x) for x in stdin.split('\\n')[1:]}\n    spies = set(range(1, S + 1))\n    enemies = set()\n    for x, y in connections:\n        spies.discard(x)\n        spies.discard(y)\n        enemies.add(x)\n        enemies.add(y)\n    result = 0\n    while spies:\n        if C <= len(spies) + len(enemies):\n            break\n        spy = spies.pop()\n        result += 1\n        for x in enemies:\n            if x == spy or x == 1:\n                continue\n            spies.discard(x)\n    return result\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    C1: S number of spies\n    C2: E number of enemies\n    C3: C connections between spies\n    S = N number of spies\n    E = N number of enemies\n    C = N number of connections\n    Time: O(E)\n    Space: O(E)\n    '''\n    N, E, C = [int(x) for x in stdin.split()]\n    connections = {}\n    for _ in range(C):\n        s, e = [int(x) for x in stdin.split()[1:3]]\n        if s not in connections:\n            connections[s] = {e}\n        else:\n            connections[s].add(e)\n        if e not in connections:\n            connections[e] = {s}\n        else:\n            connections[e].add(s)\n    return 0\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for the input\"\"\"\n    lines = stdin.split(\"\\n\")\n\n    num_spies = int(lines[0].split()[0])\n    num_enemies = int(lines[0].split()[1])\n    num_connections = int(lines[0].split()[2])\n\n    adj = [[] for _ in range(num_spies + 1)]\n    in_degree = [0 for _ in range(num_spies + 1)]\n\n    for line in lines[1:num_connections + 1]:\n        spy_1 = int(line.split()[0])\n        spy_2 = int(line.split()[1])\n        adj[spy_1].append(spy_2)\n        in_degree[spy_2] += 1\n        adj[spy_2].append(spy_1)\n        in_degree[spy_1] += 1\n\n    for line in lines[num_connections + 1:]:\n        spies = [int(n) for n in line.split()]\n        for spy in spies:\n            in_degree[spy] += len(spies) - 1\n\n    return in_degree\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the number of spies in the network, the number of connections to other spies,\n    and the connections from other spies to the enemy organizations. Returns the number\n    of spies that will be used to send a message that will not result in the enemy spies\n    receiving the message.\"\"\"\n    # Get the number of spies\n    spies = int(stdin.split('\\n')[0].split()[0])\n    # Get the number of connections\n    connections = int(stdin.split('\\n')[0].split()[2])\n    # Get the connections to the enemy spy organization\n    # from the network\n    connections_to_enemy = []\n    for line in stdin.split('\\n')[1:connections + 1]:\n        connections_to_enemy.append(list(map(int, line.split())))\n    # Get the connections from the enemy spy organization\n    # to the network\n    connections_from_enemy = []\n    for line in stdin.split('\\n')[connections + 1:]:\n        connections_from_enemy.append(list(map(int, line.split())))\n    # Add the connections to the network to the list of connections from the\n    # enemy organization to the network\n    connections_to_enemy.extend(connections_from_enemy)\n    # Get the connections from the network to the enemy organization\n    # from the network\n    connections_from_network = []\n    for line in stdin.split('\\n')[1:]:\n        connections_from_network.append(list(map(int, line.split())))\n    # Get all the connections in the network\n    connections_in_network = connections_to_enemy + connections_from_enemy\n    # Add the connections to the network to the list of connections from the\n    # network to the enemy organization\n    connections_to_enemy.extend(connections_from_network)\n    # Create a set of all the connections in the network\n    connections_in_network = set(sum(connections_in_network, []))\n    # Remove all the connections from the network to the enemy organization\n    connections_to_enemy = set(connections_to_enemy)\n    # Get the number of spies in the network\n    num_spies_in_network = spies\n    # Iterate over all the connections from the network to the enemy\n    # organization\n    for connection in connections_to_enemy:\n        # Get the number of spies in the connection\n        num_spies_in_connection = connection[0]\n        # Remove all the connections from the network to the enemy\n        # organization\n        connections_to_enemy = set(connections_to_enemy)\n        connections_to_enemy.remove(connection)\n        # Remove all the connections from the enemy organization to the\n        # network\n        connections_from_enemy = set(connections_from_enemy)\n        connections_from_enemy.remove(connection)\n        # Get the number of spies in the rest of the connections\n        # from the enemy organization to the network\n        num_spies_from_enemy = len(connections_from_enemy)\n        # Get the number of spies in the rest of the connections from the\n        # network to the enemy organization\n        num_spies_from_network = len(connections_in_network - connections_from_enemy)\n        # Set the number of spies in the network to be equal to the number\n        # of spies in the connections from the network to the enemy\n        # organization plus the number of spies in the connections from the\n        # enemy organization to the network\n        num_spies_in_network = num_spies_from_enemy + num_spies_from_network\n        # Remove the current connection\n        connections_in_network.remove(connection)\n    # Return the number of spies in the network\n    return str(num_spies_in_network)\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'x'\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Get the input\n    N, E, C = [int(i) for i in stdin.split()]\n    # Create a directed graph\n    graph = [[] for _ in range(N + 1)]\n    # Populate the graph\n    for _ in range(C):\n        S, E = [int(i) for i in stdin.split()]\n        graph[S].append(E)\n    # Get the enemies\n    enemies = [int(i) for i in stdin.split()]\n    # Create a set of seen enemies\n    seen = set()\n    # Create a set of seen spies\n    spies = set()\n    # Create a set to store the final answer\n    ans = set()\n    # Get the spies and enemies\n    spies = set(enemies)\n    # Count the number of spies\n    n = 0\n    # Iterate over the list of enemies\n    for enemy in enemies:\n        # If the enemy is a spy\n        if enemy in spies:\n            # Add it to the set\n            ans.add(enemy)\n            # Add it to the count\n            n += 1\n            # Iterate over the list of spies\n            for spy in spies:\n                # If the spy is not in the set of seen spies and is not in the set of spies\n                if spy not in spies and spy not in seen:\n                    # Add it to the set of seen spies\n                    seen.add(spy)\n                    # Iterate over the graph\n                    for s in graph[spy]:\n                        # If the enemy is a spy and not in the set\n                        if s in spies and s not in seen:\n                            # Add it to the set of seen spies\n                            seen.add(s)\n                            # Add it to the set of spies\n                            spies.add(s)\n                            # Add it to the count\n                            n += 1\n                        # Else if the enemy is not in the set of seen spies\n                        elif s not in seen:\n                            # Add it to the set of seen spies\n                            seen.add(s)\n                            # Add it to the count\n                            n += 1\n    # Return the result\n    return str(n)\n"
    },
    {
        "number": 3099,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    # 1. \u8a08\u7b97\u5404spy\u53ef\u4ee5\u767c\u7d66\u7684\u6578\u91cf\n    # 2. \u8a08\u7b97\u5404spy\u53ef\u4ee5\u767c\u7d66\u7684\u6578\u91cf\n    # 3. \u7528 set \u5224\u65b7\u662f\u5426\u6709\u91cd\u8907\n\n    n, m, k = [int(x) for x in stdin.split('\\n')[0].split()]\n    g = [set() for _ in range(n+1)]\n    for _ in range(k):\n        s, t = [int(x) for x in stdin.split('\\n')[_].split()]\n        g[s].add(t)\n        g[t].add(s)\n\n    targets = set([int(x) for x in stdin.split('\\n')[k+1].split()])\n    spies = set()\n    for s in range(n+1):\n        for t in g[s]:\n            spies |= set([s, t])\n\n    l = 0\n    while True:\n        if spies & targets:\n            break\n        for s in spies:\n            for t in g[s]:\n                spies |= set([t])\n        l += 1\n    return l\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    returns the number of ways in which one can ship the boxes with apples, cherries and mangoes in such a way that two consecutive boxes contain different fruits.\n\n    :param stdin: the input of the program containing the number of boxes of apples, cherries and mangos to ship to Singapore\n    :return: the number of different possible arrangements of the delivery, modulo a prime number 10^9+7.\n    '''\n    # use a list for the number of apple, cherry and mangoes\n    numbers = list(map(int, stdin.split()))\n    # use a list to store the number of ways\n    ways = []\n    # a list to store the states of the boxes\n    statuses = []\n    # return 0 if there is no box of apples\n    if numbers[0] == 0:\n        return 0\n    # iterate over the number of boxes\n    for i in range(numbers[0]):\n        # iterate over the number of boxes\n        for j in range(numbers[0]):\n            # store the current status of the box\n            statuses.append(0)\n        # append the number of ways\n        ways.append(0)\n\n    # iterate over the number of boxes\n    for i in range(1, numbers[0] + 1):\n        # store the current status of the box\n        curr_status = 0\n        # iterate over the number of boxes\n        for j in range(numbers[0]):\n            # update the current status of the box\n            if i == 1:\n                statuses[j] = 1\n            else:\n                if curr_status == statuses[j] and numbers[1] > 0:\n                    statuses[j] = 2\n                    numbers[1] -= 1\n                curr_status = statuses[j]\n        # iterate over the number of boxes\n        for j in range(numbers[0]):\n            # if the number of ways is already computed, then break\n            if ways[j]!= 0:\n                break\n            # compute the number of ways\n            ways[j] = pow(2, numbers[2], 10 ** 9 + 7) * statuses[j]\n        # iterate over the number of boxes\n        for j in range(numbers[0]):\n            # if the number of ways is already computed, then break\n            if ways[j]!= 0:\n                break\n            # compute the number of ways\n            ways[j] = pow(2, numbers[2], 10 ** 9 + 7) * statuses[j]\n    # return the number of ways\n    return sum(ways) % (10 ** 9 + 7)\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    #  COMPLEXITY\n    # ---------------\n    #\n    # Time complexity: O(N)\n    #\n    # Space complexity: O(1)\n    # ---------------\n    # Note: https://www.hackerrank.com/challenges/apple-and-orange/forum/comments/426918\n    A, C, M = map(int, stdin.split())\n    # Let's assume that the integers are in range 1 to 100,000, so the prime number of\n    # interest is 10 ** 6 + 7, i.e. 1,000,000,007.\n    #\n    # Construct a list of the required numbers. This list has length A + C + M.\n    # If we have a box of apples, then we add its index to the list.\n    # If we have a box of cherries, then we add its index to the list.\n    # If we have a box of mangoes, then we add its index to the list.\n    #\n    # As a sanity check, let's print this list.\n    #\n    #   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n    #\n    # Notice that the numbers are not unique!\n    #\n    # This is the list we have. Let's then perform the following:\n    #   - We build the new list of numbers that we need to modify.\n    #   - We delete the numbers from the old list, which in the end will leave us with\n    #     a new list that has those numbers we need to modify.\n    #   - We check if the numbers are already in the new list. If they are, then we\n    #     just add them to the list.\n    #   - If they are not in the new list, we need to check if they are already in the old\n    #     list. If so, then we add the new number to the list and delete the old number.\n    #   - We repeat this for each number in the original list.\n    #\n    # This is what the end result should look like.\n    #\n    #   [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n    #\n    # Let's print this list to confirm.\n    #\n    #   [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n    #\n    # You can see that the numbers 7 and 29 have been added twice. This is fine, because\n    # we want to add only two numbers to the list. Let's then convert this list into\n    # a set.\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    # We can then convert the set back into a list.\n    #\n    #   [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n    #\n    # And finally, we convert it into a tuple.\n    #\n    #   (1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30)\n    #\n    # We'll do the same thing for the other list.\n    #\n    #   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30}\n    #\n    #   "
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    'Compute the number of ways of arranging the deliveries of APPLE, CHERRY and MANGO'\n    _, __, ___ = stdin.split('\\n')\n    A, C, M = map(int, _.split(' '))\n    return str(F(A, C, M))\n\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = list(map(int, stdin.split()))\n    dp = [[[0] * (C + 1) for _ in range(C + 1)] for _ in range(A + 1)]\n    dp[0][0][0] = 1\n    for i in range(A):\n        for j in range(C + 1):\n            for k in range(C + 1):\n                dp[i + 1][j][k] = dp[i][j][k]\n                if j > 0:\n                    dp[i + 1][j][k] += dp[i][j - 1][k]\n                if k > 0:\n                    dp[i + 1][j][k] += dp[i][j][k - 1]\n                if j > 0 and k > 0:\n                    dp[i + 1][j][k] -= dp[i][j - 1][k - 1]\n    ans = sum([sum([sum([dp[i][j][k] for k in range(C)]) for j in range(C)]) for i in range(A)])\n    return str(ans % (10 ** 9 + 7))\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = list(map(int, stdin.split()))\n    if A == C == M:\n        return '1'\n    A = [0] + [1] * A\n    C = [0] + [1] * C\n    M = [0] + [1] * M\n    result = 0\n    for _ in range(2, max(A, C, M) + 1):\n        A_ = A[:]\n        C_ = C[:]\n        M_ = M[:]\n        for i in range(1, len(A)):\n            if A_[i] + C_[i] + M_[i] == _:\n                A_[i + 1] = 0\n                C_[i + 1] = 0\n                M_[i + 1] = 0\n            else:\n                A_[i + 1] = A_[i] + A_[i + 1]\n                C_[i + 1] = C_[i] + C_[i + 1]\n                M_[i + 1] = M_[i] + M_[i + 1]\n        if sum(A_) + sum(C_) + sum(M_) == _:\n            result += 1\n    return str(result)\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # stdin.split(' ')\n    # list of input numbers\n    A = list(map(int, stdin.split()))\n    # convert to list\n    # print(A)\n    # print(type(A))\n    # the answer\n    # answer = 0\n    # create an empty list\n    answer = []\n    # for each number in the list of input numbers\n    for n in range(len(A)):\n        # convert to list\n        # print(type(A[n]))\n        # if the number is greater than 1, then\n        if A[n] > 1:\n            # for each number in the list of input numbers\n            for m in range(1, A[n] + 1):\n                # print(m)\n                # print(A[n] - m)\n                # if there is a number in the list that equals the total number of boxes minus the number\n                if A[n] - m in A:\n                    # print('test')\n                    # if the number of boxes is greater than 1, then\n                    if A[n] - m > 1:\n                        # if the number in the list is less than the number of boxes minus the number\n                        if A[n] - m < A[n]:\n                            # for each number in the list of input numbers\n                            for r in range(1, A[n] - m + 1):\n                                # add to the answer\n                                answer.append(str(m) +'' + str(r) +'' + str(A[n] - m - r))\n                        # if the number of boxes is less than the number minus the number\n                        else:\n                            # for each number in the list of input numbers\n                            for r in range(1, A[n] - m + 1):\n                                # add to the answer\n                                answer.append(str(m) +'' + str(A[n] - m - r) +'' + str(r))\n                    # if the number of boxes is greater than 1, then\n                    if A[n] - m > 1:\n                        # if the number in the list is greater than the number of boxes minus the number\n                        if A[n] - m > A[n]:\n                            # for each number in the list of input numbers\n                            for r in range(1, A[n] - m + 1):\n                                # add to the answer\n                                answer.append(str(m) +'' + str(A[n] - m - r) +'' + str(r))\n                        # if the number of boxes is less than the number minus the number\n                        else:\n                            # for each number in the list of input numbers\n                            for r in range(1, A[n] - m + 1):\n                                # add to the answer\n                                answer.append(str(m) +'' + str(r) +'' + str(A[n] - m - r))\n                # if the number is greater than 1\n                if m > 1:\n                    # if the number of boxes is greater than 1\n                    if A[n] > 1:\n                        # for each number in the list of input numbers\n                        for r in range(1, m):\n                            # if the number in the list is less than the number of boxes minus the number\n                            if A[n] - r in A:\n                                # if the number of boxes is greater than 1\n                                if A[n] - r > 1:\n                                    # for each number in the list of input numbers\n                                    for s in range(1, A[n] - r + 1):\n                                        # add to the answer\n                                        answer.append(str(m) +'' + str(r) +'' + str(s) +'' + str(A[n] - r - s))\n                                # if the number of boxes is less than the number minus the number\n                                else:\n                                    # for each number in the list of input numbers\n                                    for s in range(1, A[n] - r + 1):\n                                        # add to the answer\n                                        answer.append(str(m) +'' + str(r) +'' + str(A[n] - r - s) +'' + str(s))\n                    # if the number of boxes is greater than 1, then\n                    if A[n] > 1:\n                        # for each number in the list of input numbers\n                        for s in range(1, m):\n                            # if the number in the list is less than the number of boxes minus the number\n                            if A[n] - s in A:\n                                # if the number of boxes is greater than 1\n                                if A[n] - s > 1:\n                                    # for each number in the list of input numbers\n                                    for t in range(1, A[n] - s + 1):\n                                        # add to the answer\n                                        answer.append(str(m) +'' + str(s) +'' + str(t) +'' + str(A[n] - s - t))\n                                # if the number of boxes is less than the number minus the number\n                                else:\n                                    # for each number in the list of input numbers\n                                    for t in range(1, A[n] - s + 1):\n                                        # add to the answer\n                                        answer.append(str(m) +'' + str(s) +'' + str(A[n] - s - t) +'' + str(t))\n    # for each number in the list of input numbers\n    for p in range(len(answer)):\n        # convert to list\n        # print(type(answer[p]))\n        # for each number in the list of input numbers\n        for q in range(len(answer[p].split(' '))):\n            # print(answer[p].split(' '))\n            # print(q)\n            # print(answer[p].split(' ')[q])\n            # print(type(answer[p].split(' ')[q]))\n            # print(type(answer[p][q]))\n            # convert to int\n            answer[p].split(' ')[q] = int(answer[p].split(' ')[q])\n    # print(answer)\n    # print(type(answer[0]))\n    # answer = str(answer)\n    # print(answer)\n    # print(type(answer))\n    # print(answer[0])\n    # print(type(answer[0]))\n    # convert to list\n    "
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    if (A % 2!= 0) or (C % 2!= 0) or (M % 2!= 0):\n        return 0\n    else:\n        if A == 1:\n            if C == 1:\n                return 1\n            else:\n                return 0\n        elif C == 1:\n            if M == 1:\n                return 1\n            else:\n                return 0\n        elif M == 1:\n            if A == C:\n                return 1\n            else:\n                return 0\n        else:\n            return (A + C + M) % (10 ** 9 + 7)\n"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, c, m = map(int, stdin.split())\n    return str(factorial(a + c + m) * factorial(a) * factorial(c) * factorial(m) % 1000000000)\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = [int(x) for x in stdin.split(' ')]\n    return str(fact(A + C + M) // fact(A) // fact(C) // fact(M))\n\nfrom math import factorial\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    modulo = 10 ** 9 + 7\n    result = 0\n    if A >= C and A >= M:\n        for i in range(1, C + 1):\n            result = (result + pow(C, i, modulo)) % modulo\n    elif C >= A and C >= M:\n        for i in range(1, A + 1):\n            result = (result + pow(A, i, modulo)) % modulo\n    elif M >= C and M >= A:\n        for i in range(1, C + 1):\n            result = (result + pow(C, i, modulo)) % modulo\n    elif A == 0 and C == 0 and M == 0:\n        result = 1\n    return str(result)\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return stdin\n    pass\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3\\n2020 2020 2020')\n    '2021 2020 2020'\n    >>> solution('2\\n999999 9999999')\n    'impossible'\n    \"\"\"\n    nums = list(map(int, stdin.split()))\n    try:\n        assert len(nums) == 2 and nums[0] >= 2 and nums[1] <= 10 ** 15\n    except AssertionError:\n        return \"impossible\"\n    for i in range(2):\n        nz = nums[i]\n        while nz > 0:\n            if nz % 10 == 0:\n                return \"impossible\"\n            nz = nz // 10\n    return \" \".join(map(str, sorted(nums)))\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    ans = [int(i) for i in stdin[1].split(\" \")]\n    ans.sort()\n    for i in range(10):\n        if n == 1:\n            if i in ans:\n                return str(i)\n            else:\n                return \"impossible\"\n        if ans[-1] % 10 == 0:\n            if i == 0 and ans[0] == 0:\n                ans[0] += 1\n            elif i!= 0 and ans[-1] % 10 == i:\n                ans[-1] += 1\n            else:\n                return \"impossible\"\n        else:\n            if ans[-1] % 10 == i:\n                ans[-1] += 1\n            else:\n                return \"impossible\"\n    return \" \".join([str(i) for i in ans])\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3\\n2020 2020 2020\\n')\n    '2021 2020 2020'\n    \"\"\"\n    _, numbers = stdin.split('\\n')\n    numbers = [int(n) for n in numbers.split()]\n\n    answer = []\n    for num in numbers:\n        for i in range(10):\n            changed = list(str(num))\n            changed[-1] = str(i)\n            changed = int(''.join(changed))\n            if changed in answer:\n                continue\n            if changed < 0:\n                continue\n            answer.append(changed)\n\n    if answer == []:\n        print('impossible')\n    else:\n        for ans in answer:\n            print(ans)\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the answer to Eris\u2019 problem.\n    \"\"\"\n    # Input\n    n = int(stdin.split('\\n')[0])\n    inputs = stdin.split('\\n')[1].split(' ')\n    # Put the input into a list\n    inputs = [int(x) for x in inputs]\n    # Set a list for the answer\n    answer = []\n    # Loop through all the inputs\n    for i in inputs:\n        # Loop through all possible lengths of the number\n        for j in range(1, len(str(i))+1):\n            # If the number is not divisible by 10\n            if i % 10!= 0:\n                # For every possible digit to put into the number\n                for k in range(0, 10):\n                    # If the number is divisible by 10\n                    if i % 10 == 0:\n                        # Check if it is divisible by the digit to put\n                        if (i % k) == 0:\n                            # Check if it is one digit higher than the number\n                            if j <= len(str(i))-1:\n                                # Change the number to the new number\n                                i = int(str(i)[:j-1] + str(k) + str(i)[j:])\n                                # Check if the new number is valid\n                                if i < 2**31:\n                                    # Add it to the answer\n                                    answer.append(i)\n                                else:\n                                    # Otherwise break out of the loop\n                                    break\n                    else:\n                        break\n            # If it is not divisible by 10\n            else:\n                # If the number is greater than 0\n                if i > 0:\n                    # For every possible digit to put into the number\n                    for k in range(0, 10):\n                        # If the number is divisible by 10\n                        if (i % 10) == 0:\n                            # Check if it is divisible by the digit to put\n                            if (i % k) == 0:\n                                # Check if it is one digit higher than the number\n                                if j <= len(str(i))-1:\n                                    # Change the number to the new number\n                                    i = int(str(i)[:j-1] + str(k) + str(i)[j:])\n                                    # Check if the new number is valid\n                                    if i < 2**31:\n                                        # Add it to the answer\n                                        answer.append(i)\n                                else:\n                                    # Otherwise break out of the loop\n                                    break\n                        else:\n                            break\n                # If the number is 0\n                else:\n                    break\n    # If there is a solution\n    if len(answer) > 0:\n        # Return the answer\n        return''.join([str(x) for x in answer])\n    # Otherwise return impossible\n    return 'impossible'"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # total_num = stdin.split('\\n')[0]\n    # total_num = total_num.split(' ')\n    # print(total_num)\n    return stdin\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    lst = list(map(int, stdin.split(\"\\n\")[1].split(\" \")))\n    sorted_lst = sorted(lst)\n    for i in range(10):\n        for j in range(10):\n            lst_copy = lst[:]\n            lst_copy[0] = i\n            lst_copy[1] = j\n            if lst_copy[0]!= 0:\n                if lst_copy[1]!= 0:\n                    if sorted(lst_copy) == sorted_lst:\n                        return \" \".join([str(x) for x in lst_copy])\n            else:\n                if lst_copy[1]!= 0:\n                    if sorted(lst_copy) == sorted_lst:\n                        return \" \".join([str(x) for x in lst_copy])\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    return string of sorted list after changing one number\n    '''\n    return ''.join(sorted(stdin))\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Returns the correct string to output given input str '''\n    def is_sorted(num_list: list, n: int) -> bool:\n        '''Checks if num_list is sorted'''\n        return all(num_list[i] <= num_list[i+1] for i in range(n-1))\n\n    def replace_digit(num_list: list, n: int, i: int, digit: int) -> list:\n        '''Replaces num_list[i] with digit, returning the updated list'''\n        num_list[i] = digit\n        return num_list\n\n    def remove_leading_zero(num_list: list, n: int) -> list:\n        '''Returns a list of length n with a leading zero if necessary'''\n        num_list = num_list.copy()\n        while num_list[0] == 0:\n            num_list.pop(0)\n        return num_list\n\n    def replace_largest_num(num_list: list, n: int) -> list:\n        '''Replaces num_list[-1] with the largest number in the list, making sure to account for leading zeros'''\n        num_list = num_list.copy()\n        largest_num = max(num_list)\n        num_list[-1] = largest_num\n        return num_list\n\n    def is_legal(num_list: list, n: int) -> bool:\n        '''Checks if num_list is legal'''\n        return len(num_list) == n and num_list[0]!= 0\n\n    def is_valid(num_list: list, n: int) -> bool:\n        '''Checks if num_list is valid'''\n        return is_sorted(num_list, n) and is_legal(num_list, n)\n\n    n = int(stdin[0])\n    num_list = [int(num) for num in stdin[1].split()]\n    for i in range(10):\n        if num_list[0] == 0:\n            num_list = remove_leading_zero(num_list, n)\n        for digit in range(10):\n            num_list_copy = num_list.copy()\n            num_list_copy = replace_digit(num_list_copy, n, i, digit)\n            if is_valid(num_list_copy, n):\n                return''.join(str(num) for num in num_list_copy)\n        num_list = replace_largest_num(num_list, n)\n    return 'impossible'\n"
    },
    {
        "number": 3101,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    lst = [int(i) for i in stdin.readline().split()]\n    lst_sort = sorted(lst)\n    if lst_sort == lst:\n        return 'impossible'\n    for i in lst:\n        for j in range(10):\n            if i == lst_sort[0]:\n                if j!= 0:\n                    lst_sort[0] = j\n                else:\n                    pass\n            elif i == lst_sort[-1]:\n                if j!= 9:\n                    lst_sort[-1] = j\n                else:\n                    pass\n            else:\n                if j!= 0 and j!= 9:\n                    lst_sort.insert(lst_sort.index(i), j)\n                    lst_sort.remove(i)\n                    break\n    return''.join([str(j) for j in lst_sort])\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.strip().split(' '))\n    return '%d' % (sum(1 for i in range(L, R+1) if no_four(i) == no_six_or_eight(i)))\n\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b = [int(x) for x in stdin.split()]\n    c = 0\n    for house in range(a, b + 1):\n        if not '4' in str(house) and len(set('668') & set(str(house))) == len(set(str(house)) - set('668')):\n            c += 1\n    return c % (10**9 + 7)\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split(' '))\n\n    digits = {'0': 0, '1': 0, '2': 0, '3': 0, '4': 0, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0}\n    good_numbers = 0\n\n    for i in range(L, R + 1):\n        if i % 10 == 4:\n            continue\n        count = 0\n        for j in str(i):\n            if j == '6' or j == '8':\n                count += 1\n            elif j in digits:\n                digits[j] += 1\n        if count == digits['6'] == digits['8']:\n            good_numbers += 1\n    return good_numbers % (10 ** 9 + 7)"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r + 1):\n        if '4' not in str(i) and str(i).count('6') == str(i).count('8'):\n            count += 1\n\n    return count % (10**9 + 7)\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, R = [int(x) for x in stdin.split()]\n\n    count = 0\n    for house in range(L, R + 1):\n        house = str(house)\n        if house.count('6') == house.count('8') and house.count('4') == 0:\n            count += 1\n\n    return str(count % (10 ** 9 + 7))\n    pass\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the number of houses to be purchased.\"\"\"\n    L, R = map(int, stdin.split())\n    total = 0\n    for house in range(L, R + 1):\n        s = str(house)\n        if '4' in s or '6' in s or '8' in s:\n            continue\n        if s.count('6') == s.count('8') or s.count('6') == s.count('4') or s.count('8') == s.count('4'):\n            total += 1\n    return total % (10 ** 9 + 7)\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split(' '))\n    n = 0\n    for house in range(L, R + 1):\n        if not (any(x in str(house) for x in '46') or '8' in str(house) and '6' not in str(house)):\n            n += 1\n\n    return str(n % (10**9 + 7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    start, end = map(int, stdin.split())\n    count = 0\n    for house in range(start, end+1):\n        if not str(house).count('4') and str(house).count('6') == str(house).count('8'):\n            count += 1\n    return str(count % (10**9+7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, R = [int(x) for x in stdin.split()]\n\n    counter = 0\n    for i in range(L, R + 1):\n        if all(str(i).count(x) == str(i).count('4') + str(i).count('6') + str(i).count('8') for x in '12345678'):\n            counter += 1\n\n    print(counter % (10 ** 9 + 7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    house_numbers = [x for x in range(l, r + 1)]\n    purchased_houses = 0\n    for house_number in house_numbers:\n        if '4' in str(house_number) or (str(house_number).count('6') + str(house_number).count('8'))!= str(house_number).count(\n                '4') + str(house_number).count('6') + str(house_number).count('8'):\n            continue\n        else:\n            purchased_houses += 1\n\n    return purchased_houses % (10 ** 9 + 7)\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    walls = stdin.splitlines()\n    if x_init < 1 or x_init > X:\n        return \"begin repairs\"\n    # In this problem, we need to try all directions to find the right way\n    for y, row in enumerate(walls):\n        for x, char in enumerate(row):\n            if char == '>':\n                if x+1 < X and walls[y][x+1]!= '<':\n                    return \"begin repairs\"\n            elif char == '<':\n                if x-1 >= 0 and walls[y][x-1]!= '>':\n                    return \"begin repairs\"\n    # In the end, we need to return the number of paths\n    moves = 0\n    for y, row in enumerate(walls):\n        for x, char in enumerate(row):\n            if char == '>':\n                moves += y\n            elif char == '<':\n                moves += (Y - y - 1)\n    return moves % 1000003\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution\"\"\"\n    # parse input\n    num_rows, num_cols, ship_init = (\n        int(val) for val in stdin.split(\" \")\n    )\n    # generate graph\n    graph = []\n    for _ in range(num_rows):\n        row = list(stdin.split(\"\\n\")[_])\n        graph.append(row)\n    # find @\n    castle = (0, 0)\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if graph[row][col] == \"@\":\n                castle = (row, col)\n    # find all paths from @ to castle\n    # each path is a dict with keys:\n    #   - current: current cell\n    #   - steps: steps needed to reach current cell\n    #   - direction: current direction of boat\n    #   - vars: dict of variables\n    paths = []\n    def find_paths(current, steps, direction, vars):\n        # BASE CASE\n        # no more moves\n        if current == castle and steps == 0:\n            paths.append({\n                \"current\": current,\n                \"steps\": steps,\n                \"direction\": direction,\n                \"vars\": vars,\n            })\n            return\n        # BASE CASE\n        # no more moves\n        if current == castle and steps < 0:\n            return\n        # BASE CASE\n        # no more moves\n        if current == castle and steps > 0:\n            return\n        # BASE CASE\n        # move up\n        if (\n            current[0] == 0 and\n            direction == \"up\" and\n            steps > 0\n        ):\n            return\n        # BASE CASE\n        # move down\n        if (\n            current[0] == num_rows - 1 and\n            direction == \"down\" and\n            steps > 0\n        ):\n            return\n        # BASE CASE\n        # move right\n        if (\n            current[1] == num_cols - 1 and\n            direction == \"right\" and\n            steps > 0\n        ):\n            return\n        # BASE CASE\n        # move left\n        if (\n            current[1] == 0 and\n            direction == \"left\" and\n            steps > 0\n        ):\n            return\n        # RECURSIVE CASE\n        # move up\n        if (\n            current[0] > 0 and\n            direction == \"up\"\n        ):\n            find_paths(\n                (current[0] - 1, current[1]),\n                steps - 1,\n                direction,\n                vars.copy(),\n            )\n        # move down\n        if (\n            current[0] < num_rows - 1 and\n            direction == \"down\"\n        ):\n            find_paths(\n                (current[0] + 1, current[1]),\n                steps - 1,\n                direction,\n                vars.copy(),\n            )\n        # move right\n        if (\n            current[1] < num_cols - 1 and\n            direction == \"right\"\n        ):\n            find_paths(\n                (current[0], current[1] + 1),\n                steps - 1,\n                direction,\n                vars.copy(),\n            )\n        # move left\n        if (\n            current[1] > 0 and\n            direction == \"left\"\n        ):\n            find_paths(\n                (current[0], current[1] - 1),\n                steps - 1,\n                direction,\n                vars.copy(),\n            )\n    find_paths(\n        (ship_init[0], ship_init[1]),\n        0,\n        \"up\",\n        {},\n    )\n    # generate unique paths\n    unique_paths = []\n    for path in paths:\n        if path not in unique_paths:\n            unique_paths.append(path)\n    # output\n    return str(len(unique_paths))\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    max_x, max_y, x_init = [int(x) for x in stdin.split()]\n    c = stdin.splitlines()[1:]\n    current_x = x_init\n    current_y = 0\n    count = 0\n    while current_x > 0 or current_x < max_x:\n        if current_x + 1 <= max_x and c[current_y][current_x + 1] in (\">\", \"<\"):\n            current_x += 1\n        elif current_x - 1 >= 0 and c[current_y][current_x - 1] in (\"<\", \">\"):\n            current_x -= 1\n        else:\n            current_x += 1\n        count += 1\n    return str(count % 1000003)\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem: https://www.algoexpert.io/questions/Breadth-First%20Search\n    \"\"\"\n\n    # Get data from stdin\n    (x, y, x_init) = [int(i) for i in stdin.split()]\n    board = []\n    for row in range(y):\n        board.append(list(stdin.split())[row])\n\n    # Initialize frontier and visited set\n    frontier = [Node(x_init, None)]\n    visited = set()\n    path_count = 0\n    while frontier:\n        node = frontier.pop()\n        if node.get_pos() == 0:\n            path_count += 1\n        visited.add(node.get_pos())\n        # Determine the movements the boat can make\n        directions = [0, 0, 0, 0]\n        if node.get_pos()[0]!= 0:\n            directions[0] = 1\n        if node.get_pos()[1]!= 0:\n            directions[1] = 1\n        if node.get_pos()[0]!= x - 1:\n            directions[2] = 1\n        if node.get_pos()[1]!= y - 1:\n            directions[3] = 1\n        # Add possible moves to the frontier\n        for i in range(4):\n            if directions[i] == 1:\n                if board[node.get_pos()[1]][node.get_pos()[0] + 1] == '>':\n                    new_node = Node(node.get_pos()[0] + 1, node.get_pos())\n                    frontier.append(new_node)\n                elif board[node.get_pos()[1]][node.get_pos()[0] - 1] == '<':\n                    new_node = Node(node.get_pos()[0] - 1, node.get_pos())\n                    frontier.append(new_node)\n                else:\n                    if i == 0:\n                        new_node = Node(node.get_pos()[0] + 1, node.get_pos())\n                        frontier.append(new_node)\n                    elif i == 2:\n                        new_node = Node(node.get_pos()[0] - 1, node.get_pos())\n                        frontier.append(new_node)\n        if len(frontier) > path_count:\n            frontier = sorted(frontier)\n            frontier = frontier[:path_count]\n\n    return path_count\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the number of distinct routes the ship can take to get home.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string, as per the instructions on [GeeksForGeeks](https://www.geeksforgeeks.org/greedy-algorithm-to-calculate-number-of-ways-to-reach-home/)\n\n    Returns\n    -------\n    str\n        A string containing the number of distinct routes the ship can take to get home.\n    \"\"\"\n    y, x, x_init = [int(i) for i in stdin.split()]\n    grid = [list(stdin.split()) for _ in range(y)]\n    grid = [[c for c in row] for row in grid]\n    if grid[0][0]!= '@':\n        grid[0][0] = '@'\n    if x_init < x:\n        grid[0][x_init] = '>'\n    elif x_init > x:\n        grid[0][x_init] = '<'\n    elif x_init == x:\n        grid[0][x_init] = '@'\n\n    # create a dictionary where the keys are the coordinates of each tile\n    # and the values are the current tile\n    current_tiles = {}\n    for y_idx, row in enumerate(grid):\n        for x_idx, tile in enumerate(row):\n            current_tiles[(y_idx, x_idx)] = tile\n    current_tiles[(0, 0)] = '@'\n\n    # create a dictionary to store the way the ship was moved\n    movements = {}\n\n    # for each tile, find the current tile, and then move to it\n    # if it's a current, keep track of the direction the boat is facing\n    # if not, store the way it was moved\n    for y_idx, row in enumerate(grid):\n        for x_idx, tile in enumerate(row):\n            current_tile = current_tiles[(y_idx, x_idx)]\n            # if it's a current\n            if current_tile == '~' or current_tile == '>' or current_tile == '<':\n                # find the current tile\n                for direction in ['<', '>', '~']:\n                    if current_tile == direction:\n                        movements[(y_idx, x_idx)] = direction\n                current_tiles[(y_idx, x_idx)] = '~'\n\n            # if it's not a current\n            else:\n                for direction in ['>', '<']:\n                    if current_tile == direction:\n                        movements[(y_idx, x_idx)] = direction\n                current_tiles[(y_idx, x_idx)] = tile\n    print(movements)\n    # use the movements to trace the way the boat moved\n    count = 0\n    for key in movements.keys():\n        if '@' in movements[key]:\n            break\n        elif key == (0, 0):\n            count += 1\n        else:\n            if movements[key] == '>':\n                if current_tiles[(key[0], key[1]-1)] == '#':\n                    continue\n                elif current_tiles[(key[0], key[1]-1)] == '<':\n                    count += 1\n                elif current_tiles[(key[0], key[1]-1)] == '>':\n                    count += 2\n            elif movements[key] == '<':\n                if current_tiles[(key[0], key[1]+1)] == '#':\n                    continue\n                elif current_tiles[(key[0], key[1]+1)] == '>':\n                    count += 1\n                elif current_tiles[(key[0], key[1]+1)] == '<':\n                    count += 2\n    return str(count % 100_000_3)\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds how many distinct routes to get home with different sails configurations\n    \"\"\"\n    row, col, row_init = map(int, stdin.split())\n    arr = [list(stdin[i:i+col]) for i in range(0, len(stdin), col)]\n    paths = []\n    for i in range(row):\n        for j in range(col):\n            if arr[i][j] == '@':\n                if j == row_init:\n                    paths.append([i, j])\n                    break\n                if j!= 0 and arr[i][j-1] not in {'>', '<'}:\n                    paths.append([i, j])\n                    break\n    sorted_paths = sorted(paths, key=lambda x: x[0])\n    for path in sorted_paths:\n        print(path)\n    return 'begin repairs' if not sorted_paths else len(sorted_paths)\n"
    },
    {
        "number": 3103,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns, x = [int(i) for i in stdin.split()]\n    ocean = [stdin.split() for i in range(rows)]\n    current = ocean[rows - 1][x]\n\n    if current!= '@':\n        return 'begin repairs'\n\n    for row in range(rows):\n        if ocean[row][x] == '>':\n            for i in range(x + 1, columns):\n                if ocean[row][i] == '#':\n                    break\n                elif ocean[row][i] == '<':\n                    return 'begin repairs'\n        elif ocean[row][x] == '<':\n            for i in range(x - 1, -1, -1):\n                if ocean[row][i] == '>':\n                    break\n                elif ocean[row][i] == '<':\n                    return 'begin repairs'\n\n    # if we get here we found the current\n    # now check how far we can go north\n    # then check how far we can go west\n    for i in range(1, x + 1):\n        if ocean[row - 1][i] == '>':\n            for j in range(x - i, -1, -1):\n                if ocean[row - 1][j] == '<':\n                    return str((j - x) * (x - j))\n    for i in range(1, x + 1):\n        if ocean[row - 1][i] == '<':\n            for j in range(x + i, columns):\n                if ocean[row - 1][j] == '>':\n                    return str((j - x) * (x - j))\n    return 'begin repairs'\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    eq = stdin.split('=')\n    A = eq[0]\n    S = eq[1]\n    A = list(A)\n    A_digits = [int(d) for d in A]\n    S_digits = [int(d) for d in S]\n    diff = [a - s for a, s in zip(A_digits, S_digits)]\n    diff_digits = [int(str(d)[1]) for d in diff]\n    diff_digits = [d for d in diff_digits if d!= 0]\n    diff_digits.sort()\n    sum_diff_digits = sum(diff_digits)\n    digit_str = str(sum_diff_digits)\n    addition_str = \"\"\n    for i in range(len(digit_str)):\n        addition_str += \"+\" + A[i] + \"=\" + digit_str[i]\n    return addition_str[1:]"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split(\"=\")\n    a = a[::-1]\n    s = s[::-1]\n    flag = False\n    i, j = 0, 0\n    result = \"\"\n    while i < len(a):\n        if j < len(s):\n            if a[i] == s[j]:\n                i += 1\n                j += 1\n            else:\n                if not flag:\n                    if a[i] == \"0\":\n                        flag = True\n                    else:\n                        result += a[i]\n                        i += 1\n                else:\n                    if a[i] == \"0\":\n                        result += \"+\" + a[i+1]\n                        i += 1\n                    else:\n                        result += \"+\" + a[i]\n                        i += 1\n        else:\n            if not flag:\n                result += a[i]\n                i += 1\n            else:\n                if a[i] == \"0\":\n                    result += \"+\" + a[i + 1]\n                    i += 1\n                else:\n                    result += \"+\" + a[i]\n                    i += 1\n    return result[::-1]\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('=')\n    a, b = int(a), int(b)\n\n    l = len(str(a))\n    s = list(str(a))\n    for i in range(l, 1000):\n        s.append('0')\n    a = int(''.join(s))\n\n    def check(a, b, c, d):\n        while a > 0:\n            if d == 0:\n                if b == 0:\n                    a, b, c, d = c, d, a, b\n                else:\n                    a, b, c, d = a, c, b, d\n            elif b > 0:\n                b, d = b - d, d\n            else:\n                if c > 0:\n                    c, d = c - d, d\n                else:\n                    b, d = d, b\n        return a, b, c, d\n\n    def func(a, b):\n        for i in range(0, l - 1):\n            if a[i] > a[i + 1]:\n                break\n        else:\n            return a, b\n\n        x = list(a)\n        x.insert(i + 1, '0')\n        x = int(''.join(x))\n        a = x\n        for i in range(i + 1, l):\n            if a[i] > a[i + 1]:\n                break\n        else:\n            return a, b\n\n        x = list(a)\n        x.insert(i + 1, '1')\n        x = int(''.join(x))\n        a = x\n\n        x = list(a)\n        x.insert(i + 1, '2')\n        x = int(''.join(x))\n        a = x\n\n        return a, b\n\n    a, b, c, d = check(a, b, c, d)\n\n    if c == 0:\n        return str(a) + '=' + str(b)\n    elif c == 1:\n        a, b = func(a, b)\n        return str(a) + '=' + str(b)\n    else:\n        c = list(str(c))\n        for i in range(len(c)):\n            if c[i] == '0':\n                break\n        else:\n            return str(a) + '=' + str(b)\n\n        x = list(str(c))\n        x.insert(i, '1')\n        x = int(''.join(x))\n        a = x\n        a, b = func(a, b)\n        return str(a) + '=' + str(b)\n\n\n\ndef"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('=')\n    s = int(s)\n    a = list(map(int, a))\n    l = len(a)\n    i = 0\n    while i < l:\n        i2 = i + 1\n        while i2 < l and a[i2] == a[i]:\n            i2 += 1\n        if i2 - i > 1:\n            a[i:i2] = [str(sum(a[i:i2]))]\n            i = i2 - 1\n        i += 1\n    return \"=\".join(str(x) for x in a)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('=')\n    s = sum(map(int, a))\n    t = sum(map(int, b))\n    return str(s - t) + '=' + a + b\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a, s = map(int, stdin.split('='))\n    a_len = len(str(a))\n    s_len = len(str(s))\n    if a_len == s_len:\n        return str(a) + '=\\n' + str(s)\n    elif a_len > s_len:\n        s_len_list = list(str(s))\n        s_len_list.reverse()\n        s_len_list = list(map(int, s_len_list))\n        s_len_list = s_len_list + [0 for i in range(a_len - s_len)]\n        s_len_list.reverse()\n        for i in range(a_len - s_len):\n            if i % 2 == 0:\n                s_len_list[i] = s_len_list[i] + 1\n            else:\n                s_len_list[i] = s_len_list[i] - 1\n        return str(a) + '=' + ''.join(map(str, s_len_list))\n    else:\n        a_len_list = list(str(a))\n        a_len_list.reverse()\n        a_len_list = list(map(int, a_len_list))\n        a_len_list = a_len_list + [0 for i in range(s_len - a_len)]\n        a_len_list.reverse()\n        for i in range(s_len - a_len):\n            if i % 2 == 0:\n                a_len_list[i] = a_len_list[i] + 1\n            else:\n                a_len_list[i] = a_len_list[i] - 1\n        return str(s) + '=' + ''.join(map(str, a_len_list))\n\n\ndef"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split('=')\n    result = a[::-1]\n    count = 0\n    if a[0] == '0':\n        count += a.count('0')\n    for i in range(len(a)):\n        if a[i] == '0':\n            count += 1\n        else:\n            break\n    for i in range(count):\n        result = result.replace('0', '', 1)\n    result = result[::-1]\n    while True:\n        a = a.replace('0', '', 1)\n        if len(a) == 0:\n            break\n        count = 0\n        if a[0] == '0':\n            count += a.count('0')\n        for i in range(len(a)):\n            if a[i] == '0':\n                count += 1\n            else:\n                break\n        for i in range(count):\n            result = result.replace('0', '', 1)\n        result = result + a\n        a = result\n    return result + '=' + s"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a, b = [int(c) for c in stdin.split('=')]\n\n    def gen(a, b):\n        s = 0\n        while a > b:\n            if a > b:\n                s += a // b\n                a %= b\n            yield s\n        while a < b:\n            if a > b:\n                s += b // a\n                b %= a\n            yield s\n\n    def gen2(a, b):\n        s = 0\n        while a > b:\n            if a > b:\n                s += a // b\n                a %= b\n            yield s\n        while a < b:\n            if a > b:\n                s += b // a\n                b %= a\n            yield s\n\n    def gen3(a, b):\n        s = 0\n        while a > b:\n            if a > b:\n                s += a // b\n                a %= b\n            if a < b:\n                s += b // a\n                b %= a\n            yield s\n\n    for i, j, k in zip(gen(a, b), gen2(a, b), gen3(a, b)):\n        if i == j == k:\n            return str(a) + '=' + str(b)\n\n    return str(a) + '=' + str(b)\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, s = stdin.split(\"=\")\n    l = []\n    for i in a:\n        l.append(str(i))\n    a = int(\"\".join(l))\n    s = int(s)\n    count = 0\n    while a > s:\n        a //= 10\n        count += 1\n    l = list(str(a))\n    a = int(\"\".join(l))\n    a = str(a)\n    l = []\n    for i in a:\n        l.append(str(i))\n    count2 = 0\n    for i in range(len(l)):\n        if l[i]!= l[0]:\n            count2 += 1\n        l[i] = str(int(l[i]) + int(l[0]))\n    l = []\n    for i in range(len(l)):\n        if l[i]!= l[0]:\n            l[i] = \"-\"\n        l[i] = str(int(l[i]) - int(l[0]))\n    a = \"\"\n    for i in l:\n        a += i\n    count2 += 1\n    print(str(count2) + \"-\" + a + \"=\" + str(s))\n"
    },
    {
        "number": 3104,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split(\"=\")\n    n1 = len(s1)\n    n2 = len(s2)\n    if n1 < n2:\n        s1, s2 = s2, s1\n        n1, n2 = n2, n1\n    s1 = \"0\" * (n2 - n1) + s1\n    s2 = s2.zfill(n2)\n    i = n1\n    while i < n2:\n        if s2[i] == \"0\":\n            s1 = s1[:-1] + \"+\" + s1[-1] + \"0\"\n        else:\n            s1 = s1[:-1] + \"+\" + s1[-1] + s2[i]\n        i += 1\n    return s1\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the two integers that appears in the sequence as a subsequence\n    of a given message S and returns them, if any.\n\n    Args:\n        stdin (str): The message S\n\n    Returns:\n        str: The two integers, if any.\n    \"\"\"\n    N = int(stdin)\n    S = []\n    for i in range(1, N+1):\n        S.append(int(stdin[i-1]))\n\n    i = 0\n    while i < len(S)-1:\n        if S[i] == S[i+1]:\n            i += 2\n            continue\n        else:\n            a = S[i]\n            j = i+2\n            while j < len(S):\n                if a == S[j] and j!= i+1:\n                    print(a, S[j])\n                    return\n                j += 2\n        i += 2\n    print(-1)\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = list(map(int, stdin.split('\\n')[:-1]))\n    counts = Counter(data)\n    possible = set()\n    for i in counts.keys():\n        for j in counts.keys():\n            if i!= j and i + j in data and counts[i] + counts[j] in data:\n                possible.add(i)\n                possible.add(j)\n    if len(possible) == 0:\n        return '-1'\n    else:\n        possible = list(possible)\n        return f'{possible[0]} {possible[1]}'\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    a = [int(stdin.readline()) for _ in range(N)]\n    stdout.write(solution(a))\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    number_of_numbers_in_sequence = int(stdin.readline().strip())\n    numbers = [int(stdin.readline().strip()) for _ in range(number_of_numbers_in_sequence)]\n    if numbers[1] == numbers[0]:\n        return -1\n    for i in range(1, len(numbers)):\n        if numbers[i] == numbers[i - 1]:\n            continue\n        for j in range(i, len(numbers)):\n            if numbers[i] + numbers[j] == numbers[j] + numbers[i]:\n                return str(numbers[i]) + \" \" + str(numbers[j])\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the first pair that appears in the message as a subsequence.\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Lexicographically smallest pair.\n    \"\"\"\n    S = [int(line) for line in stdin.split()]\n    n = len(S)\n    res = -1\n    for i in range(n - 3):\n        for j in range(i + 1, n - 2):\n            if S[i] == S[j] and S[i + 1] == S[j + 1]:\n                for k in range(j + 2, n):\n                    if S[j + 2] == S[k]:\n                        res = (S[i], S[j + 2])\n    return''.join(str(s) for s in res)\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the lexicographically smallest pair of (A, B) when (A, B, A, B) appears as a subsequence in S\"\"\"\n    pass"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''Finds and prints the smallest pair of integers with the pattern:\n        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16\n        where no two consecutive numbers are equal.\n    '''\n   ...\n\nprint(solution(input()))\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    N = int(stdin.readline())\n    integers = []\n    for _ in range(N):\n        integers.append(int(stdin.readline()))\n    subsequences = []\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            if integers[i] == integers[j]:\n                continue\n            if integers[i] < integers[j]:\n                for k in range(j + 1, N - 1):\n                    if integers[i] < integers[k] < integers[j]:\n                        for l in range(k + 1, N):\n                            if integers[k] < integers[l] < integers[j]:\n                                subsequences.append([integers[i], integers[j], integers[k], integers[l]])\n    if len(subsequences) == 0:\n        return \"-1\"\n    subsequences.sort()\n    return f\"{subsequences[0][0]} {subsequences[0][3]}\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    s = int(stdin.strip())\n    nums = list(map(int, stdin.split('\\n')[1:]))\n\n    d = {}\n    for i in nums:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n\n    for i in nums:\n        for j in nums:\n            if d[i]!= 0 and d[j]!= 0 and i!= j and nums.count(i) * nums.count(j) >= 2:\n                print(str(i) + \" \" + str(j))\n                return\n\n    print(-1)\n    return\n\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    S = set()\n    A, B = [], []\n    for i in range(N):\n        s = int(stdin)\n        S.add(s)\n        if s < N:\n            if s not in S:\n                if s in A and s in B:\n                    continue\n                if s in A:\n                    A = [s, s]\n                elif s in B:\n                    B = [s, s]\n                else:\n                    A.append(s)\n                    B.append(s)\n            else:\n                A.append(s)\n                B.append(s)\n    if A and B:\n        return f'{min(A)}\\n{min(B)}'\n    else:\n        return '-1'"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    string = list(stdin)\n    lights = [False] * len(string)\n    for i in range(len(string)):\n        if string[i] == '1':\n            lights[i] = True\n    for i in range(len(lights)):\n        for j in range(i+1, len(lights)):\n            lights[j] = lights[i] or lights[j]\n    return \"\".join([str(i) for i in lights if i])"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    light_number = int(stdin[0])\n    lights = [0] * light_number\n    for index, light in enumerate(stdin[1:]):\n        lights[index] = int(light)\n    print(lights)\n\n    for index in range(light_number):\n        if index == 0:\n            continue\n        elif index == 1:\n            if lights[index] == 0:\n                if lights[index - 1] == 0:\n                    lights[index] = 1\n                    lights[index - 1] = 1\n                elif lights[index - 1] == 1:\n                    lights[index] = 1\n            else:\n                if lights[index - 1] == 0:\n                    lights[index - 1] = 1\n        elif index == light_number - 1:\n            if lights[index - 1] == 0:\n                lights[index] = 1\n            else:\n                lights[index] = 1\n                lights[index - 1] = 1\n        else:\n            if lights[index - 1] == 0:\n                lights[index] = 1\n                lights[index - 1] = 1\n            elif lights[index] == 0:\n                lights[index] = 1\n    print(lights)\n    return lights\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    for _ in range(int(stdin[0])):\n        _, *lines = stdin.split('\\n')\n        lights = list(map(int, lines[0]))\n        if len(set(lights))!= len(lights):\n            print(0)\n            continue\n        print(solve(lights))\n\n\ndef"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \n    return \"\"\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(n)\n    Space: O(1)\n    \"\"\"\n    lights = [int(c) for c in stdin]\n    buttons = []\n    for i in range(len(lights)):\n        if lights[i] == 1:\n            buttons.append(i)\n    buttons = [b for b in buttons if b - 1 in buttons or b + 1 in buttons]\n    for i in range(1, len(lights)):\n        if i % 2 == 0:\n            if i in buttons:\n                buttons = [b for b in buttons if b < i]\n            else:\n                buttons = [b for b in buttons if b > i]\n        else:\n            if i in buttons:\n                buttons = [b for b in buttons if b > i]\n            else:\n                buttons = [b for b in buttons if b < i]\n    return i\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_ = stdin.split('\\n')[1:]\n    light_sequence = []\n    for line in input_:\n        for light in line:\n            light_sequence.append(light)\n\n    on_indexes = [i for i in range(len(light_sequence)) if light_sequence[i] == '1']\n\n    def toggle(start, end):\n        for i in range(start, end):\n            if light_sequence[i] == '1':\n                light_sequence[i] = '0'\n            else:\n                light_sequence[i] = '1'\n\n    if len(on_indexes) == 1:\n        return '0'\n    elif len(on_indexes) == 0:\n        return '1'\n\n    curr_index = on_indexes[0]\n    start_index = on_indexes[0]\n\n    for i in range(1, len(on_indexes)):\n        if on_indexes[i] - on_indexes[i - 1] > 1:\n            toggle(start_index, on_indexes[i - 1])\n            start_index = on_indexes[i]\n        else:\n            curr_index = on_indexes[i]\n    return str(curr_index - 1)\n"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    l = stdin.split()\n    n = int(l[0])\n    l = [int(x) for x in l[1]]\n    t = []\n    for i in range(1,n+1):\n        if i not in t:\n            t.append(i)\n    t.reverse()\n    if n == 1:\n        return 0\n    cnt = 0\n    for i in t:\n        for j in range(0,n):\n            if l[j] == i:\n                cnt+=1\n                break\n    return cnt"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    return n if (n % 2 == 1) else n - 1\n\nprint(solution('1101'))"
    },
    {
        "number": 3106,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lights = [0] * int(len(stdin))\n    for i, light in enumerate(stdin):\n        lights[i] = int(light)\n    time = 0\n    while True:\n        time += 1\n        for i, light in enumerate(lights):\n            lights[i] = 0 if light else 1\n        for i, light in enumerate(lights):\n            if i > 0 and lights[i] and lights[i-1]:\n                lights[i] = 0\n        if all(light == 1 for light in lights):\n            return time\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/5ed1f4dae9d51d737c00053f\"\"\"\n    N, M = [int(n) for n in stdin.split()]\n    d = {}\n    for n in range(N):\n        l = [int(n) for n in stdin.split()]\n        d.update(dict(zip(l[1:], [0]*l[0])))\n    for m in range(M):\n        l = [int(n) for n in stdin.split()]\n        for key in d.keys():\n            if key in l[1:]:\n                d[key] += 1\n    return '\\n'.join([str(d[n]) for n in stdin.split()])\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    pass\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 1\\n2 2 1\\n3 3 1 3\\n1 2\\n2 3\\n3 1\")\n    2\n    >>> solution(\"4 1 6 3 6\\n7 3 4 2 6 5 6 1\\n1 2\\n2 3\")\n    3\n    \"\"\"\n\n    n, m = map(int, stdin.split())\n    res = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        for i in range(n):\n            if (a in res or b in res) and a!= b:\n                res.add(a)\n                res.add(b)\n            if i + 1 == n:\n                break\n    return str(len(res))\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of times two trucks met in a road.\n\n    Args:\n        stdin (str): Input data.\n\n    Returns:\n        str: Output data.\n    \"\"\"\n    (n, m), routes = tuple(map(int, stdin.split('\\n')[:2])), tuple(stdin.split('\\n')[2:])\n    matrix = [[0] * n for _ in range(n)]\n    for route in routes:\n        (a, b), (c, d) = tuple(map(int, route.split()))\n        matrix[a - 1][b - 1] += 1\n        matrix[a - 1][d - 1] += 1\n    for i in range(n):\n        matrix[i][i] = 0\n    return '\\n'.join(map(str, [sum(row) for row in zip(*matrix)]))\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3107,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Takes the input and returns the string of the results'''\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    m = int(lines[1])\n    result = []\n    for _ in range(m):\n        line = lines[_].split()\n        result.append(check(n, line))\n    return '\\n'.join(result)\n    \ndef"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n    a = [int(x) for x in stdin.split()]\n    a = sorted(a)\n    r = 0\n    for i in range(k - 1, n):\n        r = max(r, sum(a[i - k + 1:i + 1]) / k)\n    return str(round(r, 3))\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    \n    res = 0\n    for i in range(k-1, n):\n        res = max(res, sum(arr[i-k+1:i+1]) / k)\n    \n    return str(res)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''Solution for https://practice.geeksforgeeks.org/problems/find-maximum-consecutive-subsequence/0'''\n    n, k = [int(x) for x in stdin.split()]\n    arr = [int(x) for x in stdin.split()]\n    return str(sum(arr[i] for i in range(k - 1, n) if i % k == k - 1) // k)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def calc_average(sequence: List[int]) -> float:\n        return sum(sequence) / len(sequence)\n\n    n, k = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    result = 0\n    for i in range(n - k + 1):\n        temp_sequence = sequence[i : i + k]\n        result = max(result, calc_average(temp_sequence))\n\n    return str(result)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = list(map(int, stdin.split('\\n')[0].split()))\n    a = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_avg = None\n    max_avg_sum = None\n    for j in range(n-k+1):\n        avg = 0\n        for i in range(j, j+k):\n            avg += a[i]\n        if max_avg is None:\n            max_avg = avg/k\n            max_avg_sum = avg\n        else:\n            if abs(avg/k - max_avg) < 0.001:\n                max_avg_sum += avg\n            else:\n                if avg > max_avg:\n                    max_avg = avg/k\n                    max_avg_sum = avg\n                else:\n                    break\n\n    return str(round(max_avg, 3))\n\n\ndef"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    (n, k) = stdin.split(' ')\n    n = int(n)\n    k = int(k)\n    a = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    a.sort()\n    i, j = 0, 0\n    while j < n:\n        a_i = a[i]\n        a_j = a[j]\n        while j < n and a[j] - a_i < k:\n            j += 1\n        i += 1\n        while i < n and a[i] - a_j < k:\n            i += 1\n        if j < n and i < n:\n            avg = (a_i + a_j) / (i - j + 1)\n        elif i < n:\n            avg = (a_i + a[i]) / (i - i + 1)\n        else:\n            avg = (a_j + a[j]) / (j - j + 1)\n        if avg > max_avg:\n            max_avg = avg\n            max_sub = a[i - 1: j]\n    return '{:.6f}'.format(max_avg)\n    \ndef"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    length, k = map(int, stdin.readline().split())\n    numbers = list(map(int, stdin.readline().split()))\n\n    left, right = 0, k - 1\n    best_average = 0\n    best_index = 0\n    while right < length:\n        average = sum(numbers[left:right + 1]) / k\n        if average > best_average:\n            best_average = average\n            best_index = left\n        left += 1\n        right += 1\n\n    return '{0:.3f}'.format(best_average)\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split('\\n')[0].split())\n    arr = map(int, stdin.split('\\n')[1].split())\n    arr = [x for x in arr if x]\n    arr.sort()\n    arr = arr[:k]\n    avg = sum(arr)/k\n    for i in range(k, n):\n        curr = sum(arr[i-k:i])\n        if curr > avg:\n            return '%.3f' % curr\n        else:\n            avg = curr\n    return '%.3f' % avg\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    max_avg, max_avg_start = (0, 0)\n    for start in range(len(stdin) - k + 1):\n        avg = sum(int(x) for x in stdin[start:start + k]) / k\n        if avg > max_avg:\n            max_avg = avg\n            max_avg_start = start\n    return round(max_avg, 6)\n    '''\n    max_avg = 0\n    max_avg_start = 0\n    max_len = 0\n    for start in range(len(stdin)):\n        current_sum = 0\n        current_len = 0\n        for i in range(start, len(stdin)):\n            current_sum += int(stdin[i])\n            current_len += 1\n            if current_sum >= max_avg:\n                if current_len >= max_len:\n                    max_avg = current_sum\n                    max_avg_start = start\n                    max_len = current_len\n    return round(max_avg, 6)\n\n\nassert solution(\n    '4 1\\n2 4 3 4') == 4\nassert solution(\n    '4 2\\n2 4 3 4') == 3.666666\nassert solution(\n    '3 1\\n1 2 3') == 1.5\nassert solution(\n    '3 2\\n1 2 3') == 2.0\n\nprint(solution(input()))\n"
    },
    {
        "number": 3108,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(num) for num in stdin.split()]\n    arr = [int(num) for num in stdin.split()]\n    count = 0\n    sum_max = 0\n    for i in range(n):\n        sum_max += arr[i]\n        count += 1\n        if count == k:\n            break\n    min_left = min(arr[0:i])\n    max_right = max(arr[i+1:])\n    left_sum = sum_max - min_left * count\n    right_sum = sum_max - max_right * count\n    return str((left_sum + right_sum) / (count * 2))\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin)\n    '0.750'\n    \"\"\"\n    _, _, _, h = [int(i) for i in stdin.split(\" \")]\n\n    section = []\n    for i in range(h):\n        section.append([])\n    for i in range(h):\n        x, min_, max_ = [float(j) for j in stdin.split(\"\\n\")[i + 1].split(\" \")]\n        for j in range(h):\n            section[j].append((x, min_, max_))\n    for i in range(h):\n        for j in range(h):\n            if len(section[i]) == 1:\n                section[j].append(section[i][0])\n            elif j == i:\n                section[j].append(section[i][0])\n            else:\n                section[j].append(section[i][1])\n    return (\n        round(\n            abs(\n                (\n                    section[0][2][0]\n                    + (section[0][2][1] * h)\n                    - section[h - 1][2][0]\n                    - (section[h - 1][2][1] * h)\n                )\n            )\n            / (h - 1),\n            3,\n        )\n    )\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution for this task.\n\n    Arguments:\n        stdin {str} -- The standard input for this task.\n\n    Returns:\n        str -- The solution for this task.\n    \"\"\"\n    # Initialize the result and array of sections\n    res = 0\n    sections = []\n    # Split the input into sections\n    sections = stdin.split(\"\\n\")\n    sections.pop()\n    # For each section, store the volume of sand and minimum and maximum amounts of sand\n    for i in range(len(sections)):\n        # Create a list of tuples of the form (volume, [min, max])\n        sections[i] = sections[i].split(\" \")\n        sections[i][1] = sections[i][1].split(\" \")\n        sections[i][0] = float(sections[i][0])\n        sections[i][1][0] = float(sections[i][1][0])\n        sections[i][1][1] = float(sections[i][1][1])\n    # For each section, create the height list\n    for i in range(len(sections)):\n        # Initialize the heights list\n        heights = []\n        # For each color of sand, determine the height\n        for j in range(len(sections[i][1])):\n            # Determine the height by summing the volume times the minimum and maximum values\n            heights.append(sections[i][0] * sections[i][1][j][1] - sections[i][0] * sections[i][1][j][0])\n        # Find the lowest and highest heights\n        heights.sort()\n        # Calculate the difference between the lowest and highest heights\n        res = max(res, heights[len(heights) - 1] - heights[0])\n    # Return the minimum difference between the highest and lowest heights\n    return \"{:.3f}\".format(res)\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum difference between maximum and minimum heights of sand in sections.\"\"\"\n    test_cases = int(stdin.split()[0])\n    res = []\n    for test_case in range(test_cases):\n        n, m, w, h = list(map(int, stdin.split()[1:5]))\n        volumes = list(map(float, stdin.split()[5:5 + m]))\n        divider_lengths = list(map(float, stdin.split()[5 + m:5 + m * (n - 1)]))\n        mins = list(map(float, stdin.split()[5 + m * (n - 1):5 + m * n]))\n        maxs = list(map(float, stdin.split()[5 + m * n:]))\n\n        # find the max of each section\n        max_volumes = [0] * n\n        for i in range(n):\n            max_volumes[i] = volumes[i] * h\n\n        # find the min of each section\n        min_volumes = [max_volumes[0]] * n\n        for i in range(1, n):\n            min_volumes[i] = min(min_volumes[i - 1], max_volumes[i - 1])\n\n        # get the difference between max and min for each section\n        max_min = []\n        for i in range(n):\n            max_min.append(maxs[i] * w - mins[i])\n\n        res.append(min(max_min))\n\n    return str(sum(res) / len(res))\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"\"\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"Compute and return the answer as described in the problem.\"\n    # Get the parameters\n    n, m, w, h = [int(x) for x in stdin.split()]\n    # Get the volumes of sand\n    v = [float(x) for x in stdin.split()]\n    # Get the minimum sand heights\n    min = [[float(x) for x in stdin.split()] for _ in range(n - 1)]\n    # Get the maximum sand heights\n    max = [[float(x) for x in stdin.split()] for _ in range(n - 1)]\n    # Convert to arrays\n    v = array(v)\n    min = array(min)\n    max = array(max)\n    # Sanity check\n    if n!= len(v) + 1:\n        raise ValueError(f\"Expected {n} volumes, got {len(v) + 1}\")\n    if n!= len(min) + 1:\n        raise ValueError(f\"Expected {n} minimum sand heights, got {len(min) + 1}\")\n    if n!= len(max) + 1:\n        raise ValueError(f\"Expected {n} maximum sand heights, got {len(max) + 1}\")\n    # Compute the answer\n    return str(round(sum(abs(max - min)), 3))\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split())\n    volumes = [float(v) for v in stdin.split()]\n    divider_distances = [float(x) for x in stdin.split()]\n\n    minimum_sums = []\n    maximum_sums = []\n    for i in range(n-1):\n        minimum = [0 for _ in range(m)]\n        maximum = [0 for _ in range(m)]\n        minimum_sums.append(minimum)\n        maximum_sums.append(maximum)\n\n    for i in range(n-1):\n        for j in range(m):\n            minimum_sums[i][j] = volumes[j]\n            maximum_sums[i][j] = volumes[j]\n        for j in range(m):\n            for k in range(m):\n                if j == k:\n                    minimum_sums[i][j] = min(minimum_sums[i][j], divider_distances[j])\n                    maximum_sums[i][j] = max(maximum_sums[i][j], divider_distances[j])\n                elif j < k:\n                    minimum_sums[i][j] = min(minimum_sums[i][j], minimum_sums[i][k])\n                    maximum_sums[i][j] = max(maximum_sums[i][j], maximum_sums[i][k])\n    # print(minimum_sums)\n    # print(maximum_sums)\n\n    heights = [[0 for _ in range(m)] for _ in range(n)]\n    for j in range(m):\n        for i in range(n):\n            heights[i][j] = volumes[j]\n\n    # print(heights)\n\n    for i in range(n-1):\n        for j in range(m):\n            # print(minimum_sums[i][j])\n            # print(maximum_sums[i][j])\n            # print(heights[i][j])\n            heights[i][j] -= (minimum_sums[i][j] + maximum_sums[i][j]) / 2\n\n            heights[i+1][j] += heights[i][j]\n            if i!= n-2:\n                heights[i+1][j] += (minimum_sums[i+1][j] + maximum_sums[i+1][j]) / 2\n\n    # print(heights)\n\n    heights[n-1][0] = w * h - sum([heights[i][0] for i in range(n)])\n    heights[n-1][1] = heights[n-1][0]\n    for j in range(m):\n        if j!= 0:\n            heights[n-1][j] += heights[n-1][j-1]\n    heights[n-1][m-1] = heights[n-1][m-2]\n\n    # print(heights)\n    heights[n-1][m-1] = w * h - heights[n-1][m-1]\n    # print(heights)\n\n    return str(round(max(heights[n-1]) - min(heights[n-1]), 3))"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum difference of the maximum and minimum heights of sand in the sections\"\"\"\n    num_sections, num_colors, width, height = [int(x) for x in stdin.split(' ')]\n    volume_per_color = [float(x) for x in stdin.split(' ')[1:]]\n    x_distances = [float(x) for x in stdin.split(' ')[2: 2 + num_sections]]\n    min_sand_per_section = [\n        [float(x) for x in stdin.split(' ')[2 + i: 2 + i + num_colors]] for i in range(num_sections)]\n    max_sand_per_section = [\n        [float(x) for x in stdin.split(' ')[2 + i + num_colors: 2 + i + num_colors * 2]]\n        for i in range(num_sections)\n    ]\n    return solution.__doc__\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute and return the minimum difference between the maximum\n    and minimum heights of sand in each section, rounded to 3 decimal\n    places.\n    >>> solution('2 2 5 5\\\\n2.0 2.0\\\\n4.0\\\\n1.0 0.0\\\\n0.0 1.0\\\\n1.0 0.0\\\\n0.0 2.0')\n    '0.750'\n    >>> solution('2 2 5 5\\\\n2.0 2.0\\\\n4.0\\\\n1.0 0.0\\\\n0.0 1.0\\\\n1.0 0.0\\\\n0.0 2.0')\n    '0.625'\n    >>> solution('2 2 5 5\\\\n1.5 0.0\\\\n0.0 1.0\\\\n1.0 0.0\\\\n0.0 2.0')\n    '0.750'\n    \"\"\"\n    # read input\n    count, n, m = list(map(int, stdin.split()))\n    volumes = list(map(float, stdin.split()))\n    divider_lengths = list(map(float, stdin.split()))\n    maxima = [list(map(float, stdin.split())) for _ in range(n - 1)]\n    minima = [list(map(float, stdin.split())) for _ in range(n - 1)]\n\n    # get divider lengths, volumes and maximums\n    divider_lengths = sorted(divider_lengths)\n    volumes = sorted(volumes)\n    maxima = sorted(maxima)\n\n    # calculate minimum difference\n    min_diff = 10 ** 7\n    for i in range(n - 1):\n        # calculate amount of sand needed for each section\n        min_amount = 0\n        for j in range(m):\n            volume = volumes[j]\n            divider_length = divider_lengths[j]\n            max_ = maxima[i][j]\n            min_ = minima[i][j]\n            min_amount += min_\n            if volume > max_:\n                volume -= max_\n                min_amount += volume / divider_length\n                break\n            if volume <= max_:\n                volume -= min_\n                min_amount += volume / divider_length\n        # update min_diff\n        diff = max_ - min_amount\n        if diff < min_diff:\n            min_diff = diff\n\n    return f\"{min_diff:.3f}\"\n"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the Maximum Distinct Colors problem on Hackerrank\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution to the Maximum Distinct Colors problem on Hackerrank\n    \"\"\"\n    _, _, w, h = list(map(int, stdin.split()))\n    total_volume = 0\n    total_amount = []\n    for volume in stdin.split():\n        total_volume += float(volume)\n        total_amount.append(float(volume))\n    total_amount = [i / total_volume for i in total_amount]\n    print(total_amount)\n    minimum_amount = [0 for _ in range(w)]\n    maximum_amount = [0 for _ in range(w)]\n    for i, j in zip(total_amount, stdin.split()):\n        if j == \"0.0\":\n            maximum_amount[0] += i\n        else:\n            minimum_amount[int(j[0])] += i\n    minimum_amount[0] += 1\n    print(minimum_amount, maximum_amount)\n    print(minimum_amount[0] * h - maximum_amount[0] * h)\n    return str(round(minimum_amount[0] * h - maximum_amount[0] * h, 3))\n\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''Given a set of minimum and maximums, we must find how much sand can be distributed to satisfy them.\n    '''\n    n, m, w, h = [int(x) for x in stdin.split(' ')]\n    min_sand_vol = [float(x) for x in stdin.split('\\n')[1].split(' ')]\n    max_sand_vol = [float(x) for x in stdin.split('\\n')[3].split(' ')]\n    min_sand_count = [float(x) for x in stdin.split('\\n')[5:5+n]]\n    max_sand_count = [float(x) for x in stdin.split('\\n')[7:7+n]]\n    dists = [float(x) for x in stdin.split('\\n')[9:9+n-1]]\n    \n    max_sand_count = [min(x, y) for x,y in zip(max_sand_count, min_sand_count)]\n    \n    sand_vol = 0\n    min_dist = 0\n    for i in range(n-1):\n        sand_vol += dists[i] * (max_sand_count[i] - min_sand_count[i])\n        if dists[i] > min_dist:\n            min_dist = dists[i]\n    \n    return round(max(0, w*h - sand_vol)/2 - min_dist, 3)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"You are a spy who has managed to get hold of the code for a room in the royal palace.\n    You have hacked into the Royal Mail, listened to their conversation, and figured out the code\n    for the room. The guard, however, has left the code on the Royal Mail, and you don\u2019t have access\n    to it. You know that the code is a number consisting of digits $0$ through $9$ and there are\n    $m$ rows and $n$ columns. You have to figure out the code for the room.\n    >>> solution('4 4\\n1 2 3 4\\n5 0 3 6\\n7 8 9 1\\n4 0 3 0\\n')\n    '48\\n'\n    \"\"\"\n    m, n = [int(x) for x in stdin.split('\\n')[0].split()]\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i * j == 9:\n                for k in range(1, 10):\n                    for l in range(1, 10):\n                        if (k + l) == 9:\n                            if i * j + k * l == 9:\n                                for r in range(1, 10):\n                                    for s in range(1, 10):\n                                        if (r + s) == 9:\n                                            if i * j + k * l == r * s:\n                                                if i * j + k * l == r * s and \\\n                                                    r * s!= 0 and \\\n                                                    r * s!= 9:\n                                                    return str(i * j + k * l)\n    return ''\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the number of complete codes\"\"\"\n    rows, columns = list(map(int, stdin.split(\" \")))\n    matrix = [list(map(int, stdin.split(\"\\n\")[1:])) for _ in range(rows)]\n\n    if rows == 3 and columns == 3:\n        return \"1\\n\"\n\n    # Create a list of rows with possible values\n    possible_values = [[], [], []]\n    for i in range(rows):\n        possible_values[0] += matrix[i]\n\n    # Create a list of columns with possible values\n    for i in range(columns):\n        temp = []\n        for j in range(rows):\n            temp.append(matrix[j][i])\n        possible_values[1].append(temp)\n\n    # Create a list of quadrants with possible values\n    quadrants = []\n    for i in range(3):\n        quadrants.append([])\n        for j in range(3):\n            quadrants[i].append([])\n            for k in range(2):\n                quadrants[i][j].append([])\n                for l in range(2):\n                    quadrants[i][j][k].append(matrix[i * 2 + k][j * 2 + l])\n    possible_values[2] += quadrants[0][0] + quadrants[0][1] + quadrants[1][0] + quadrants[1][1] + quadrants[2][0] + quadrants[2][1]\n\n    return str(complete_codes(possible_values))\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = [stdin.split() for stdin in stdin.strip().split('\\n')]\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '0':\n                continue\n            for k in range(j+1, n):\n                if grid[i][k] == '0':\n                    continue\n                for p in range(i+1, m):\n                    if grid[p][k] == '0':\n                        continue\n                    for q in range(k+1, n):\n                        if grid[p][q] == '0':\n                            continue\n                        if ((grid[i][j]*grid[i][k] + grid[i][k]*grid[i][q] + grid[i][q]*grid[p][k]) == (grid[p][j]*grid[p][k] + grid[p][k]*grid[p][q] + grid[p][q]*grid[i][k])):\n                            ans += 1\n                        elif ((grid[i][j]*grid[i][k] + grid[i][k]*grid[i][q] + grid[i][q]*grid[p][k]) == (grid[p][j]*grid[p][k] + grid[p][k]*grid[p][q] + grid[p][q]*grid[i][k])):\n                            ans += 1\n                        elif ((grid[p][j]*grid[p][k] + grid[p][k]*grid[p][q] + grid[p][q]*grid[i][k]) == (grid[i][j]*grid[i][k] + grid[i][k]*grid[i][q] + grid[i][q]*grid[p][k])):\n                            ans += 1\n                        elif ((grid[p][j]*grid[p][k] + grid[p][k]*grid[p][q] + grid[p][q]*grid[i][k]) == (grid[i][j]*grid[i][k] + grid[i][k]*grid[i][q] + grid[i][q]*grid[p][k])):\n                            ans += 1\n    return ans\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    nums = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def remove_unknowns(matrix):\n        for i, row in enumerate(matrix):\n            for j, num in enumerate(row):\n                if num == 0:\n                    matrix[i][j] = '0'\n\n        return matrix\n\n    def compute_row(matrix):\n        new_matrix = [[] for _ in range(n)]\n        for i, row in enumerate(matrix):\n            for j, num in enumerate(row):\n                if num == '0':\n                    new_matrix[j].append('0')\n                    continue\n                \n                row_sum = sum([matrix[i][j] for j in range(n)])\n                row_diff = sum([matrix[i][j] for j in range(n) if i!= j])\n                row_quot = sum([matrix[i][j] for j in range(n) if j!= i])\n\n                if row_sum in [row_diff, row_quot]:\n                    new_matrix[j].append('1')\n                elif row_diff in [row_quot, row_sum]:\n                    new_matrix[j].append('2')\n                elif row_quot in [row_diff, row_sum]:\n                    new_matrix[j].append('3')\n                else:\n                    new_matrix[j].append('4')\n        \n        return new_matrix\n\n    def compute_col(matrix):\n        new_matrix = [[] for _ in range(n)]\n        for i, row in enumerate(matrix):\n            for j, num in enumerate(row):\n                if num == '0':\n                    new_matrix[j].append('0')\n                    continue\n                \n                col_sum = sum([matrix[j][i] for j in range(n)])\n                col_diff = sum([matrix[j][i] for j in range(n) if i!= j])\n                col_quot = sum([matrix[j][i] for j in range(n) if j!= i])\n\n                if col_sum in [col_diff, col_quot]:\n                    new_matrix[j].append('1')\n                elif col_diff in [col_quot, col_sum]:\n                    new_matrix[j].append('2')\n                elif col_quot in [col_diff, col_sum]:\n                    new_matrix[j].append('3')\n                else:\n                    new_matrix[j].append('4')\n        \n        return new_matrix\n\n    def compute_block(matrix):\n        new_matrix = [[] for _ in range(n)]\n        for i, row in enumerate(matrix):\n            for j, num in enumerate(row):\n                if num == '0':\n                    new_matrix[j].append('0')\n                    continue\n\n                block_sum = sum([matrix[i][j] for i in range(n // 2) for j in range(n // 2)])\n                block_diff = sum([matrix[i][j] for i in range(n // 2) for j in range(n // 2) if i!= j])\n                block_quot = sum([matrix[i][j] for i in range(n // 2) for j in range(n // 2) if j!= i])\n\n                if block_sum in [block_diff, block_quot]:\n                    new_matrix[j].append('1')\n                elif block_diff in [block_quot, block_sum]:\n                    new_matrix[j].append('2')\n                elif block_quot in [block_diff, block_sum]:\n                    new_matrix[j].append('3')\n                else:\n                    new_matrix[j].append('4')\n        \n        return new_matrix\n\n    def format(matrix):\n        new_matrix = []\n        for row in matrix:\n            if 0 in row:\n                new_matrix.append(['0'] * n)\n            else:\n                new_matrix.append(row)\n        \n        return new_matrix\n\n    def extract_rows(matrix):\n        rows = []\n        for row in matrix:\n            if '0' not in row:\n                rows.append(row)\n        \n        return rows\n\n    def extract_cols(matrix):\n        cols = []\n        for j in range(n):\n            col = []\n            for i in range(m):\n                col.append(matrix[i][j])\n            \n            cols.append(col)\n        \n        return cols\n\n    def extract_blocks(matrix):\n        blocks = []\n        for i in range(n // 2):\n            for j in range(n // 2):\n                block = []\n                for k in range(2):\n                    for l in range(2):\n                        block.append(matrix[i * 2 + k][j * 2 + l])\n                \n                blocks.append(block)\n\n        return blocks\n\n    def check_complete(matrix):\n        return all([0 not in row for row in matrix])\n\n    def generate_complete_matrix(matrix):\n        matrix = remove_unknowns(matrix)\n\n        matrix = compute_row(matrix)\n        matrix = compute_col(matrix)\n        matrix = compute_block(matrix)\n\n        matrix = format(matrix)\n        matrix = extract_rows(matrix)\n        matrix = extract_cols(matrix)\n        matrix = extract_blocks(matrix)\n\n        return matrix\n\n    matrix = generate_complete_matrix(nums)\n\n    return sum([1 for row in matrix if check_complete(row)])\n\nfor _ in range(int(input())):\n    print(solution(input()))"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = list(map(int, stdin.split()))\n    if m < 3 or n < 3:\n        raise ValueError('Invalid input')\n    lines = []\n    for _ in range(m):\n        lines.append(list(map(int, stdin.split())))\n    possible_numbers = set(range(1, 10))\n    for l in lines:\n        possible_numbers.discard(0)\n    for l in lines:\n        for i in range(n):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i])\n    for l in lines:\n        for i in range(n - 1):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i] * l[i + 1])\n    for l in lines:\n        for i in range(n - 1):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i] + l[i + 1])\n    for l in lines:\n        for i in range(n - 1):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i] - l[i + 1])\n    for l in lines:\n        for i in range(n - 1):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i] // l[i + 1])\n    for l in lines:\n        for i in range(n - 1):\n            if l[i]!= 0:\n                possible_numbers.discard(l[i] % l[i + 1])\n    return str(len(possible_numbers))\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m, n = [int(x) for x in stdin.split(' ')]\n    grid = [[int(x) for x in stdin.split('\\n')[i].split(' ')] for i in range(2, m + 2)]\n\n    # Compute all possible rows for each column\n    rows = [[0] * n for _ in range(m)]\n    for j in range(n):\n        for i in range(m):\n            rows[i][j] = (grid[i][j] * (i + 1) + grid[i][j]) * 10 - (grid[i][j] * (i + 1) + grid[i][j])\n\n    # For each column, find all the rows that we can get from it\n    columns = []\n    for j in range(n):\n        col = [rows[i][j] for i in range(m)]\n        colset = set(col)\n        colset.discard(0)\n        columns.append(colset)\n\n    # For each column, find all the rows that we can get from it\n    diagonals = []\n    for j in range(n):\n        if j % 2:\n            dia = [0] * m\n            for i in range(m):\n                dia[i] = (grid[i][j] * (i + 1) + grid[i][j]) * 10 - (grid[i][j] * (i + 1) + grid[i][j])\n        else:\n            dia = [0] * m\n            for i in range(m - 1, -1, -1):\n                dia[i] = (grid[i][j] * (i + 1) + grid[i][j]) * 10 - (grid[i][j] * (i + 1) + grid[i][j])\n\n        diagset = set(dia)\n        diagset.discard(0)\n        diagonals.append(diagset)\n\n    # Find all the possible grid values\n    grids = set()\n    for j in range(n):\n        for i in range(m):\n            grids.add(rows[i][j])\n    for j in range(n):\n        for i in range(m - 1, -1, -1):\n            grids.add(rows[i][j])\n    for j in range(n - 1, -1, -1):\n        for i in range(m - 1, -1, -1):\n            grids.add(rows[i][j])\n\n    # Find all the possible grid values\n    grid_values = set()\n    for j in range(n):\n        for i in range(m):\n            grid_values.add(grid[i][j])\n    for j in range(n):\n        for i in range(m - 1, -1, -1):\n            grid_values.add(grid[i][j])\n    for j in range(n - 1, -1, -1):\n        for i in range(m - 1, -1, -1):\n            grid_values.add(grid[i][j])\n\n    # Find all the possible grid values\n    diagonal_values = set()\n    for j in range(n):\n        for i in range(m):\n            diagonal_values.add(dia[i])\n    for j in range(n):\n        for i in range(m - 1, -1, -1):\n            diagonal_values.add(dia[i])\n    for j in range(n - 1, -1, -1):\n        for i in range(m - 1, -1, -1):\n            diagonal_values.add(dia[i])\n\n    # Compute the possible combinations\n    possibilities = 0\n    for grid_value in grids:\n        for column in columns:\n            if grid_value in column:\n                column = column.difference(grid_value)\n                for diagonal in diagonals:\n                    if diagonal in column:\n                        column = column.difference(diagonal)\n                    else:\n                        if diagonal - grid_value in column:\n                            column = column.difference(diagonal - grid_value)\n                if not column:\n                    for diagonal in diagonals:\n                        if grid_value + diagonal in grid_values:\n                            possibilities += 1\n    for grid_value in grid_values:\n        for column in columns:\n            if grid_value in column:\n                column = column.difference(grid_value)\n                for diagonal in diagonals:\n                    if diagonal in column:\n                        column = column.difference(diagonal)\n                    else:\n                        if grid_value + diagonal in grid_values:\n                            possibilities += 1\n    for grid_value in grid_values:\n        for column in columns:\n            if grid_value in column:\n                column = column.difference(grid_value)\n                for diagonal in diagonals:\n                    if diagonal in column:\n                        column = column.difference(diagonal)\n                    else:\n                        if grid_value - diagonal in grid_values:\n                            possibilities += 1\n    for grid_value in grid_values:\n        for diagonal in diagonals:\n            if grid_value + diagonal in grid_values:\n                possibilities += 1\n    return str(possibilities)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return''.join(stdin.split())\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = [list(map(int, stdin.split())) for _ in range(m)]\n    complete_codes = set()\n    grid_len = m * n\n    for i in range(grid_len - 1):\n        for j in range(i + 1, grid_len):\n            left = grid[i // n][i % n]\n            right = grid[j // n][j % n]\n            up = grid[(i - n) // n][(i - n) % n]\n            down = grid[(j - n) // n][(j - n) % n]\n            if left * right == up + down:\n                complete_codes.add((i, j))\n            elif left * right == up - down:\n                complete_codes.add((i, j))\n            elif left * right == down - up:\n                complete_codes.add((i, j))\n            elif right * left == up + down:\n                complete_codes.add((i, j))\n            elif right * left == up - down:\n                complete_codes.add((i, j))\n            elif right * left == down - up:\n                complete_codes.add((i, j))\n    return len(complete_codes)\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3110,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split('\\n')[0].split()]\n    nums = list(map(int, stdin.split('\\n')[1:]))\n    ans = []\n    for i in range(m):\n        a, b = [int(x) for x in stdin.split('\\n')[i + 2].split()]\n        sum = 0\n        for i in range(a, b + 1):\n            sum += nums[i - 1]\n        ans.append(str(sum))\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ...\n   ...\n    return \"\"\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Your solution here\n    \"\"\"\n    n, m = list(map(int, stdin.split()))\n    dials = stdin.split()[1:]\n\n    sum_dials = [0] * n\n    for _ in range(m):\n        a, b = list(map(int, stdin.split()))\n        sum_dials[a - 1] += 1\n        sum_dials[b - 1] += 1\n        dials[a - 1] = str(int(dials[a - 1]) + 1)\n        dials[b - 1] = str(int(dials[b - 1]) + 1)\n\n    for i in range(len(sum_dials)):\n        sum_dials[i] += int(dials[i][0])\n\n    return''.join(list(map(str, sum_dials)))\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\""
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return None"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 3\\n1234\\n1 1\\n1 2\\n1 3\\n1 4\\n')\n    '10\\n14\\n18\\n16'\n    \"\"\"\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    nums = list(map(int, lines[1].split()))\n\n    res = []\n    for _ in range(M):\n        A, B = map(int, lines[2].split())\n        res.append(sum(nums[A:B+1]))\n        for i in range(A, B+1):\n            nums[i] = res[-1] % 10\n    return '\\n'.join(map(str, res))\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    nums = stdin.split('\\n')\n    return '\\n'.join([sum(int(num) for num in nums[i:i+2]) for i in range(0, N, 2) for _ in range(M)])"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.readline().split())\n    dials = stdin.readline().strip()\n\n    # Find sum of all numbers between A and B\n    for _ in range(M):\n        A, B = map(int, stdin.readline().split())\n        print(sum(int(x) for x in dials[A-1:B]))\n    return ''"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Reads the input and returns the calculation result.\n    \"\"\"\n    n, m = map(int, stdin.split())\n\n    config = list(map(int, stdin.split()))\n\n    sums = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        sums.append(sum(config[a - 1:b]))\n        config[a - 1] += 1\n        if config[a - 1] == 10:\n            config[a - 1] = 0\n\n    return '\\n'.join(map(str, sums))\n"
    },
    {
        "number": 3111,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(x) for x in stdin.split(' ')]\n    config = [int(x) for x in stdin.split('\\n')[1:]]\n    sums = []\n\n    for _ in range(M):\n        A, B = [int(x) for x in stdin.split('\\n')[2:][_].split(' ')]\n        sums.append(sum(config[A - 1:B]))\n        config[A - 1] += 1\n        config[B] += 1\n        config[A - 1] %= 10\n        config[B] %= 10\n        for i in range(A, B + 1):\n            config[i] = 0\n\n    return \"\\n\".join(str(x) for x in sums)\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    n, k, m = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    graph = {}\n    for _ in range(m):\n        a, b = [int(x) for x in stdin.split('\\n')[_].split(' ')]\n        if a in graph:\n            graph[a].append(b)\n        else:\n            graph[a] = [b]\n        if b in graph:\n            graph[b].append(a)\n        else:\n            graph[b] = [a]\n    p = {}\n    for i in range(1, n+1):\n        p[i] = [i]\n    for k in graph.keys():\n        for i in graph[k]:\n            for j in p[k]:\n                if j in graph[i]:\n                    graph[i].remove(j)\n                    p[i].remove(j)\n        for i in p[k]:\n            for j in graph[i]:\n                if j not in p[k]:\n                    p[k].append(j)\n    count = 0\n    for k in p.keys():\n        for i in range(len(p[k])):\n            count = count + math.floor(len(p[k])/2)\n    return count"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute solution for the given input.\"\"\"\n    # Write your code here and remove pass statement below\n   ...\n\n    # 1. Input\n    N, K, M = [int(x) for x in stdin.split()]\n    conveyor_belt = [[int(x) for x in stdin.split()] for _ in range(M)]\n\n    # 2. Compute\n    producers = set()\n    for a, b in conveyor_belt:\n        producers.add(a)\n        producers.add(b)\n\n    producers = sorted(list(producers))\n    producers_to_turn_off = list()\n\n    for i in range(1, len(producers)):\n        if producers[i] - producers[i - 1] == 1:\n            producers_to_turn_off.append(producers[i - 1])\n        if producers[i] - producers[i - 1] == K:\n            producers_to_turn_off.append(producers[i - 1])\n            break\n\n    # 3. Output\n    print(len(producers) - len(producers_to_turn_off))\n\n    return solution\n\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    (N, K, M), (edges) = [\n        (list(map(int, line.split())) for line in stdin.splitlines()) for _ in range(2)\n    ]\n    paths = [p for p in permutations(range(1, N)) if p[0]!= N]\n\n    def is_safe(producers: list[int]) -> bool:\n        producers = set(producers)\n        seen_product = set()\n        for a, b in edges:\n            if (a in producers) ^ (b in producers):\n                return False\n            if a in producers:\n                seen_product.add(b)\n            if b in producers:\n                seen_product.add(a)\n        if len(seen_product) < K:\n            return False\n        return True\n\n    result = 0\n    for producers in paths:\n        if is_safe(producers):\n            result = max(result, len(producers))\n    return str(result)\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return str\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def floyd_warshall(n, m, edges, dist):\n        for k in range(1, n + 1):\n            for i in range(1, n + 1):\n                for j in range(1, n + 1):\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if dist[i][j] == inf:\n                    dist[i][j] = 0\n\n    if __name__ == '__main__':\n        n, m, k = map(int, stdin.readline().split())\n\n        edges = [[0] * (n + 1) for _ in range(n + 1)]\n        dist = [[inf] * (n + 1) for _ in range(n + 1)]\n\n        for _ in range(m):\n            u, v = map(int, stdin.readline().split())\n            edges[u][v] = 1\n            edges[v][u] = 1\n\n        floyd_warshall(n, m, edges, dist)\n\n        res = 0\n        for i in range(1, n + 1):\n            res = max(res, sum(dist[i][1:k + 1]))\n        return str(res)\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    edges = {}\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        if a not in edges:\n            edges[a] = set()\n        if b not in edges:\n            edges[b] = set()\n        edges[a].add(b)\n        edges[b].add(a)\n    \n    start = set()\n    end = set()\n    for i in range(1, N+1):\n        if i not in edges:\n            start.add(i)\n        if i == N:\n            end.add(i)\n    \n    producers = set()\n    for i in range(1, N+1):\n        if i not in edges:\n            producers.add(i)\n    \n    s = 0\n    e = N+1\n    while True:\n        for i in range(s, e):\n            if i not in edges:\n                producers.remove(i)\n        if len(producers) == 0:\n            break\n        s = e\n        e += N+1\n    \n    return len(producers)"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A good example of a NP-complete problem.\n    \"\"\"\n    N, K, M = [int(x) for x in stdin.split('\\n')[0].split()]\n    edges = [tuple([int(x) for x in line.split()]) for line in stdin.split('\\n')[1:]]\n    print(M)\n    print(K)\n    print(N)\n    print(edges)\n    return \"\"\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n\n    n, k, m = map(int, lines[0].split())\n    edges = set()\n\n    for i in range(1, m + 1):\n        a, b = map(int, lines[i].split())\n        edges.add((a, b))\n\n    visited = [False for _ in range(n)]\n    start = 0\n\n    def dfs(start):\n        nonlocal visited\n\n        for e in edges:\n            a, b = e\n\n            if a == start:\n                visited[b - 1] = True\n\n            if b == start:\n                visited[a - 1] = True\n\n        for e in edges:\n            a, b = e\n\n            if visited[a - 1] == False:\n                dfs(a)\n\n            if visited[b - 1] == False:\n                dfs(b)\n\n    dfs(start)\n\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    numJunction = int(stdin.readline().split(' ')[0])\n    numConveyorBelt = int(stdin.readline().split(' ')[0])\n    edges = []\n    for i in range(numConveyorBelt):\n        a, b = [int(i) for i in stdin.readline().split(' ')]\n        edges.append((a, b))\n    # \u9019\u908a\u5c07edges\u88e1\u7684\u8def\u7dda\u505a\u6210\u5b57\u5178\n    graph = {}\n    for edge in edges:\n        a, b = edge\n        if a not in graph:\n            graph[a] = [b]\n        else:\n            graph[a].append(b)\n\n        if b not in graph:\n            graph[b] = [a]\n        else:\n            graph[b].append(a)\n    # \u4e0b\u9762\u958b\u59cb\u5efa\u9020\u4e00\u500b\u904d\u6b77\u7bc0\u9edegraph\u7684bfs\n    visited = set()\n    queue = []\n    queue.append(1)\n    visited.add(1)\n    while queue:\n        a = queue.pop(0)\n        if a not in graph:\n            continue\n        for b in graph[a]:\n            if b not in visited:\n                visited.add(b)\n                queue.append(b)\n    # \u5c07visited\u88e1\u7684\u7bc0\u9ede\u53bb\u9664\n    for i in visited:\n        if i in graph:\n            graph[i] = []\n    # \u958b\u59cb\u9032\u884cbfs\n    visited = set()\n    queue = []\n    queue.append(numJunction)\n    visited.add(numJunction)\n    while queue:\n        a = queue.pop(0)\n        if a not in graph:\n            continue\n        for b in graph[a]:\n            if b not in visited:\n                visited.add(b)\n                queue.append(b)\n    # \u518d\u6b21\u53bb\u9664\u5df2\u7d93\u8d70\u904e\u7684\n    for i in visited:\n        if i in graph:\n            graph[i] = []\n    # \u518d\u6b21\u9032\u884cbfs\n    visited = set()\n    queue = []\n    queue.append(numJunction)\n    visited.add(numJunction)\n    while queue:\n        a = queue.pop(0)\n        if a not in graph:\n            continue\n        for b in graph[a]:\n            if b not in visited:\n                visited.add(b)\n                queue.append(b)\n    return len(visited) - 1\n\nprint(solution(stdin.read()))\n"
    },
    {
        "number": 3112,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \n    return stdin\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cloud_cover: set = set()\n    for _ in range(int(stdin.readline())):\n        a, b, c = [int(x) for x in stdin.readline().split()]\n        cloud_cover.add((a, b, c))\n\n    for _ in range(int(stdin.readline())):\n        a, b, c = [int(x) for x in stdin.readline().split()]\n        cloud_cover.add((a, b, c))\n\n    if len(cloud_cover)!= 2:\n        return \"no\"\n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    input:\n        stdin - number of triangles - n\n        stdin - number of triangles - m\n        stdin - n triangles - x_1, y_1, x_2, y_2, x_3, y_3\n        stdin - m triangles - x_1, y_1, x_2, y_2, x_3, y_3\n    output: yes or no\n    \"\"\"\n    cloud_1 = set()\n    cloud_2 = set()\n    for i in range(int(stdin)):\n        cloud_1.add((int(stdin[2 * i + 2]), int(stdin[2 * i + 3]), int(stdin[2 * i + 4]), int(stdin[2 * i + 5])))\n        cloud_2.add((int(stdin[2 * i + 6]), int(stdin[2 * i + 7]), int(stdin[2 * i + 8]), int(stdin[2 * i + 9])))\n\n    if len(cloud_1) == len(cloud_2):\n        if len(cloud_1) > 0:\n            return \"yes\"\n        return \"no\"\n    else:\n        return \"no\"\n\ndef"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    garry = []\n    for x in stdin[1:1 + int(stdin[0])]:\n        garry.append(list(map(int, x.split())))\n    jerry = []\n    for x in stdin[1 + int(stdin[0]) : 1 + 2 * int(stdin[0])]:\n        jerry.append(list(map(int, x.split())))\n    # for i in gary:\n    #     print(i)\n    # for i in jerry:\n    #     print(i)\n    # g = set()\n    # for i in garry:\n    #     g.add(tuple(i))\n    # j = set()\n    # for i in jerry:\n    #     j.add(tuple(i))\n    # print(g, j)\n    # print(len(j) - len(g))\n    return 'yes' if len(jerry) - len(gary) == 0 else 'no'\n\n\nprint(solution(\n    \"1\\n10000 0 10000 10000 0 10000\\n3\\n10000 0 10000 10000 5000 5000\\n5000 5000 10000 10000 0 10000\\n0 0 0 1000 1000 0\\n\"\n))\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1\n   ... 10000 0 10000 10000 0 10000\n   ... 3\n   ... 10000 0 10000 10000 5000 5000\n   ... 5000 5000 10000 10000 0 10000\n   ... 0 0 0 1000 1000 0\n   ... ''')\n    'yes'\n    \"\"\"\n    n = int(stdin.readline())\n    g = {tuple(map(int, line.split())) for line in stdin.readline().split('\\n')[:-1]}\n    m = int(stdin.readline())\n    h = {tuple(map(int, line.split())) for line in stdin.readline().split('\\n')[:-1]}\n    return 'yes' if g & h == set() else 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Line 1: Number of triangles\n    # Line 2: Vertex coordinates\n    # Line 3: Number of triangles\n    # Line 4: Vertex coordinates\n    # Line 5: Number of triangles\n    # Line 6: Vertex coordinates\n    # Line 7: Number of triangles\n    # Line 8: Vertex coordinates\n    \n    def read_triangle(stdin: str, line: int) -> (float, float, float, float):\n        if line == 3:\n            x1, y1, x2, y2, x3, y3 = map(float, stdin.split())\n        else:\n            x1, y1, x2, y2, x3, y3 = map(float, stdin.split())\n            x1 += 10000\n            x2 += 10000\n            x3 += 10000\n            y1 += 10000\n            y2 += 10000\n            y3 += 10000\n        return (x1, y1, x2, y2, x3, y3)\n    \n    def write_triangle(stdout: str, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> None:\n        stdout.write(f\"{x1}\\t{y1}\\t{x2}\\t{y2}\\t{x3}\\t{y3}\\n\")\n    \n    def add_triangle(stdout: str, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float) -> None:\n        if x1 == x2 and x2 == x3:\n            return\n        if y1 == y2 and y2 == y3:\n            return\n        write_triangle(stdout, x1, y1, x2, y2, x3, y3)\n    \n    # Read data\n    n = int(stdin.readline())\n    x, y = [], []\n    for _ in range(n):\n        x1, y1, x2, y2, x3, y3 = read_triangle(stdin, _)\n        x.append([x1, x2, x3])\n        y.append([y1, y2, y3])\n    m = int(stdin.readline())\n    for _ in range(m):\n        x1, y1, x2, y2, x3, y3 = read_triangle(stdin, _)\n        x.append([x1, x2, x3])\n        y.append([y1, y2, y3])\n    \n    # Find the coordinates of all the points\n    points = set()\n    for i in range(n):\n        x1, y1, x2, y2, x3, y3 = x[i]\n        for p in [(x1, y1), (x2, y2), (x3, y3)]:\n            if p not in points:\n                points.add(p)\n    for i in range(m):\n        x1, y1, x2, y2, x3, y3 = x[i]\n        for p in [(x1, y1), (x2, y2), (x3, y3)]:\n            if p not in points:\n                points.add(p)\n    \n    # Find the points with equal coordinates\n    coordinates = set()\n    for p in points:\n        x, y = p\n        if (x, y) not in coordinates:\n            coordinates.add((x, y))\n    \n    # Find degenerate triangles\n    degenerate = set()\n    for x1, y1 in coordinates:\n        for x2, y2 in coordinates:\n            for x3, y3 in coordinates:\n                if x1 == x2 and x2 == x3:\n                    continue\n                if y1 == y2 and y2 == y3:\n                    continue\n                if x1 == x2 and x2 == x3 or y1 == y2 and y2 == y3:\n                    a = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)\n                    b = (x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)\n                    c = (x3 - x1) * (y2 - y1) - (x2 - x1) * (y3 - y1)\n                    if a == 0:\n                        continue\n                    if b == 0:\n                        continue\n                    if c == 0:\n                        continue\n                    a //= 2\n                    b //= 2\n                    c //= 2\n                    if (a, b, c) not in coordinates:\n                        degenerate.add((a, b, c))\n    \n    # Check for degenerate triangles\n    for i in range(n):\n        for j in range(m):\n            x1, y1, x2, y2, x3, y3 = x[i]\n            x1 += 10000\n            x2 += 10000\n            x3 += 10000\n            y1 += 10000\n            y2 += 10000\n            y3 += 10000\n            for a, b, c in degenerate:\n                x1a, y1a, x2a, y2a, x3a, y3a = x[i]\n                x1b, y1b, x2b, y2b, x3b, y3b = x[j]\n                if a == 0:\n                    continue\n                if x1a == x1b and x2a == x2b and x3a == x3b and y1a == y1b and y2a == y2b and y3a == y3b:\n                    continue\n                if x1a == x2b and x2a == x3b and x3a == x1b and y1a == y2b and y2a == y3b and y3a == y1b:\n                    continue\n                if x1b == x2a and x2b == x3a and x3b == x1a and y1b == y2a and y2b == y3a and y3b == y1a:\n                    continue\n                if x1b == x2a and"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    time: O(n log n)\n    space: O(n)\n    \"\"\"\n    if len(stdin) < 4:\n        return \"yes\"\n\n    triangles = stdin.split(\"\\n\")\n    triangles = [tuple(map(int, t.split())) for t in triangles]\n\n    g_triangles = set()\n    for x1, y1, x2, y2, x3, y3 in triangles:\n        g_triangles.add((x1, y1, x2, y2, x3, y3))\n        g_triangles.add((x1, y1, x3, y3, x2, y2))\n\n    for i in range(len(triangles)):\n        for j in range(i + 1, len(triangles)):\n            x1, y1, x2, y2, x3, y3 = triangles[i]\n            x4, y4, x5, y5, x6, y6 = triangles[j]\n\n            a = (x1 - x2) * (y3 - y4) - (x3 - x4) * (y1 - y2)\n            b = (x1 - x3) * (y2 - y4) - (x2 - x4) * (y1 - y3)\n            c = (x1 - x4) * (y2 - y3) - (x2 - x3) * (y1 - y4)\n\n            if a == 0 and b == 0 and c == 0:\n                continue\n            elif a == 0 and b == 0:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x3, y3, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n            elif b == 0 and c == 0:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x2, y2, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n            elif a == 0:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x3, y3, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n            elif b == 0:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x2, y2, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n            elif c == 0:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x2, y2, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n            else:\n                g_triangles.remove((x1, y1, x2, y2, x3, y3))\n                g_triangles.remove((x1, y1, x3, y3, x4, y4))\n                g_triangles.remove((x1, y1, x4, y4, x5, y5))\n                g_triangles.remove((x1, y1, x5, y5, x6, y6))\n                g_triangles.add((x1, y1, x2, y2, x3, y3))\n\n    if g_triangles:\n        return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''1\n   ... 10000 0 10000 10000 0 10000\n   ... 3\n   ... 10000 0 10000 10000 5000 5000\n   ... 5000 5000 10000 10000 0 10000\n   ... 0 0 0 1000 1000 0''')\n    'yes'\n    >>> solution('''2\n   ... 9995 0 9996 0 0 1\n   ... 9999 0 10000 0 0 1\n   ... 2\n   ... 9998 0 9999 0 0 1\n   ... 9998 0 9998 0 0 1''')\n    'no'\n    \"\"\"\n    # 1. Step: Remove duplicate triangles and sort them\n    n = int(stdin.split('\\n')[0])\n    triangles = [\n        sorted(list(map(int, line.split())))\n        for line in stdin.split('\\n')[1:]\n    ]\n    # 2. Step: Add triangles to a set and check if the set is a cloud cover\n    cloud = set()\n    for x1, y1, x2, y2, x3, y3 in triangles:\n        a = (x1, y1)\n        b = (x2, y2)\n        c = (x3, y3)\n        cloud.add((a, b, c))\n    # 3. Step: Check the cloud cover\n    count = 0\n    for a, b, c in cloud:\n        for d, e, f in cloud:\n            if a == d or a == e or a == f:\n                continue\n            elif b == d or b == e or b == f:\n                continue\n            elif c == d or c == e or c == f:\n                continue\n            else:\n                count += 1\n    if count == 0:\n        return 'yes'\n    else:\n        return 'no'\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def to_triangle(x: int, y: int, z: int) -> List[Tuple[int, int]]:\n        return [(x, y), (x, z), (z, y)]\n\n    def tri_area(tri: List[Tuple[int, int]]) -> float:\n        area = 0\n        for i in range(3):\n            area += (tri[i][0] * tri[(i + 1) % 3][1] - tri[(i + 1) % 3][0] * tri[i][1])\n        return abs(area) / 2\n\n    def is_degenerate(tri: List[Tuple[int, int]]) -> bool:\n        return tri_area(tri) == 0\n\n    def is_non_intersecting(tri1: List[Tuple[int, int]], tri2: List[Tuple[int, int]]) -> bool:\n        for tri in [tri1, tri2]:\n            if is_degenerate(tri):\n                continue\n            for tri in [tri1, tri2]:\n                for i in range(3):\n                    if tri[(i + 1) % 3][0] == tri[i][0] and tri[(i + 1) % 3][1] == tri[i][1]:\n                        break\n                else:\n                    continue\n                break\n            else:\n                return True\n\n        return False\n\n    print(\"no\" if is_non_intersecting(to_triangle(*[int(i) for i in line.split()]), to_triangle(*[int(i) for i in stdin.split()[2:]])) else \"yes\")"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Determine if the cloud cover is the same by checking if the triangle areas are equal.\"\"\"\n    # The cloud cover is not the same if the sum of the areas of the triangles is not zero.\n    return \"no\" if sum(triangle_area(triangle) for triangle in stdin.split(\"\\n\")[1::2])!= 0 else \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return 'yes' if the cloud cover is the same, otherwise return 'no'.\"\"\"\n    garry_triangles = set(\n        (x1, y1, x2, y2, x3, y3)\n        for x1, y1, x2, y2, x3, y3 in (\n            line.split()\n            for line in stdin.split(\"\\n\")[:2]\n        )\n    )\n    jerry_triangles = set(\n        (x1, y1, x2, y2, x3, y3)\n        for x1, y1, x2, y2, x3, y3 in (\n            line.split()\n            for line in stdin.split(\"\\n\")[2:]\n        )\n    )\n    if len(garry_triangles)!= len(jerry_triangles):\n        return \"no\"\n\n    return \"yes\" if len(garry_triangles.difference(jerry_triangles)) == 0 else \"no\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"YES\\n1 2\\n1 3\\n2 1\\n3 2\\n3 4\\n2 4\"\n    \n    pass"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split('\\n')[0].split()]\n    roads = {}\n    for _ in range(m):\n        a, b = [int(x) for x in stdin.split('\\n')[_].split()]\n        roads.setdefault(a, []).append(b)\n        roads.setdefault(b, []).append(a)\n    for road in roads:\n        roads[road].sort(reverse=True)\n    # print(roads)\n\n    def dfs(roads, node, visited, result):\n        if len(visited) == n:\n            return result\n        else:\n            for road in roads[node]:\n                if road not in visited:\n                    visited.add(road)\n                    result.append([node, road])\n                    dfs(roads, road, visited, result)\n                    visited.remove(road)\n\n    result = []\n    for node in roads.keys():\n        visited = set()\n        result.append([node])\n        dfs(roads, node, visited, result)\n    # print(result)\n    if len(result) == n:\n        return 'YES\\n' + '\\n'.join([str(x) for y in result for x in y])\n    else:\n        return 'NO'\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    num_cities, num_roads = [int(x) for x in stdin.split()]\n    # roads = []\n    # for i in range(num_roads):\n    #     roads.append([int(x) for x in stdin.split()])\n    roads = [[int(x) for x in stdin.split()] for i in range(num_roads)]\n    matrix = [[0 for x in range(num_cities)] for y in range(num_cities)]\n    for road in roads:\n        matrix[road[0] - 1][road[1] - 1] = road[2]\n        matrix[road[1] - 1][road[0] - 1] = road[2]\n    # print(matrix)\n    mst = list()\n    matrix = [(i, j, matrix[i][j]) for i in range(num_cities) for j in range(num_cities) if i!= j]\n    # print(matrix)\n    # edges = sorted(matrix, key=lambda x: x[2])\n    edges = [x[2] for x in matrix]\n    # print(edges)\n    edges.sort()\n    # print(edges)\n    mst.append(matrix[0])\n    # print(mst)\n    for i in range(1, num_cities):\n        # print(i)\n        # print(edges)\n        # print(matrix[i])\n        if (matrix[i][2] < edges[0]):\n            edges.pop(0)\n            mst.append(matrix[i])\n        elif (matrix[i][2] >= edges[0]):\n            for j in range(len(edges) - 1, -1, -1):\n                if (edges[j] > matrix[i][2]):\n                    edges.insert(j + 1, matrix[i][2])\n                    break\n            if (j == 0):\n                edges.insert(0, matrix[i][2])\n            mst.append(matrix[i])\n    # print(edges)\n    # print(mst)\n    if (len(edges)!= 0):\n        return 'NO'\n    else:\n        for road in mst:\n            print(road[0] + 1, road[1] + 1)\n        return 'YES'\n\n\ndef"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, v: int, c: str):\n        nonlocal num_colors, is_connected\n        if u == v:\n            return\n        for neighbor in graph[u]:\n            if neighbor!= v and colors[neighbor] == 0:\n                colors[neighbor] = 1 if c == \"R\" else 2\n                dfs(u, neighbor, c)\n                is_connected = True\n            if is_connected:\n                return\n\n    num_cities, num_roads = list(map(int, stdin.split()))\n    graph = defaultdict(list)\n    for _ in range(num_roads):\n        u, v = list(map(int, stdin.split()))\n        graph[u].append(v)\n        graph[v].append(u)\n    num_colors = num_cities + 1\n    colors = [0 for _ in range(num_cities)]\n    is_connected = False\n    for u in range(1, num_cities):\n        for c in (\"R\", \"B\"):\n            dfs(u, u, c)\n            if is_connected:\n                break\n        if is_connected:\n            break\n    return \"YES\\n\" + \"\\n\".join(\n        map(lambda i: \"%d %d\" % (i[0], i[1]), enumerate(colors))\n    )\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a solution as a string.\n\n    Parameters\n    ----------\n    stdin : str\n        The standard input.\n\n    Returns\n    -------\n    str\n        The solution.\n    \"\"\"\n    # Parse input\n    N, M = map(int, stdin.split())\n    roads = []\n    for _ in range(M):\n        roads.append(list(map(int, stdin.split())))\n\n    # Iterate over all roads, and determine if it's possible to assign them a direction\n    is_possible = True\n    for road in roads:\n        if road[0] == road[1]:\n            is_possible = False\n        elif roads.count(road) > 1:\n            is_possible = False\n\n    if is_possible:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    # print(stdin)\n    cities, roads = stdin.split(\"\\n\")[:2]\n    cities = int(cities.split()[0])\n    roads = int(roads.split()[0])\n    connections = []\n    for _ in range(roads):\n        connections.append(stdin.split(\"\\n\")[2 + roads:])\n\n    # print(cities, roads, connections)\n\n    # compute\n    # https://en.wikipedia.org/wiki/Topological_sorting\n    # https://leetcode.com/problems/acm-icpc-world-championship-2015/discuss/73094/ACM-ICPC-World-Championship-2015-Ruby-Python-Java-C%2B%2B-solution\n    # https://www.youtube.com/watch?v=x7pFgYiBd2I\n    return stdout\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    city_num, road_num = map(int, stdin.split('\\n')[0].split(' '))\n    neighbors = []\n    for i in range(road_num):\n        city1, city2 = map(int, stdin.split('\\n')[i + 1].split(' '))\n        neighbors.append([city1, city2])\n\n    # create an adjacency list\n    adj_list = {}\n    for city1, city2 in neighbors:\n        if city1 not in adj_list:\n            adj_list[city1] = []\n        if city2 not in adj_list:\n            adj_list[city2] = []\n        adj_list[city1].append(city2)\n        adj_list[city2].append(city1)\n\n    # check whether the graph is bipartite\n    def is_bipartite(start: int) -> bool:\n        visited = set()\n        q = deque()\n        q.append((start, 0))\n        while q:\n            city, color = q.popleft()\n            if city in visited:\n                if color == 0:\n                    return False\n                continue\n            visited.add(city)\n            if city in adj_list:\n                for neighbor in adj_list[city]:\n                    q.append((neighbor, 1 - color))\n        return True\n\n    # create an adjacent list\n    for i in range(city_num):\n        if is_bipartite(i):\n            print('YES')\n            for j in adj_list[i]:\n                print(j, i)\n        else:\n            print('NO')\n"
    },
    {
        "number": 3114,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    _, _m = stdin.split('\\n')[:2]\n    _m = _m.split('\\n')\n    _m = [[int(x) for x in y.split(' ')] for y in _m]\n    _m = {x[0]: [y[0] for y in _m if x[0]!= y[0]] for x in _m}\n    _m = {k: v for k, v in _m.items() if len(v) == 0}\n    _m = [[k, v[0]] for k, v in _m.items()]\n    _m = [x for x in _m if len(x) > 1]\n    if len(_m)!= 0:\n        return 'NO\\n'\n    _n = len(list(stdin.split('\\n')[2:])[0].split('\\n')) - 1\n    _m = {k: v for k, v in enumerate(_m)}\n    _v = [0 for x in _m.values()]\n    _w = set([x[0] for x in _m.values()])\n    _x = set([x[1] for x in _m.values()])\n    _y = _w | _x\n    _z = list(_y - _w) + list(_y - _x)\n    _f = [[x, y] for x, y in zip(_z, _v)]\n    _f = sorted(_f, key=lambda x: x[1])\n    _g = [x for x in _f if x[1]!= 0]\n    _g = [x for x in _g if not x[0] in _w]\n    _g = [x for x in _g if not x[0] in _x]\n    _g = [x for x in _g if not x[1] in _x]\n    if len(_g)!= 0:\n        return 'NO\\n'\n    _t = [x for x in _g if x[0] < x[1]]\n    _t = sorted(_t, key=lambda x: x[0])\n    _h = sorted([_m[x[0]] for x in _t], key=lambda x: x[0])\n    _i = [[x[0], x[1]] for x in _t]\n    _j = [x[1] for x in _h]\n    _k = [[x[0], x[1]] for x in _i]\n    _h = list(zip(_j, _k))\n    _l = [[x[0], x[1][0]] for x in _h if x[1][1] == 0]\n    _l = [x for x in _l if x[0]!= x[1]]\n    _m = _l + [[x[1], x[0]] for x in _l]\n    _m = sorted(_m, key=lambda x: x[0])\n    return 'YES\\n' + '\\n'.join(' '.join([str(x) for x in y]) for y in _m)\n    \ndef"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    matches = []\n    for _ in range(m):\n        matches.append([int(x) for x in stdin.split(' ')])\n    lst = []\n    for m in matches:\n        if m[1] > m[0]:\n            lst.append(m)\n    if len(lst) == 0:\n        return 'consistent'\n    else:\n        return 'inconsistent'\n    # print(lst)\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('3 3\\n0 > 1\\n1 = 2\\n0 = 2')\n    'inconsistent'\n    \"\"\"\n    count = 0\n    players = []\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        if line.startswith('#'):\n            continue\n        count += 1\n        tokens = line.split(' ')\n        players.append(tuple(map(int, tokens[1:])))\n    if count!= len(set(players)):\n        return 'inconsistent'\n    for i, a in enumerate(players):\n        for b in players[i + 1 :]:\n            if a == b:\n                return 'inconsistent'\n            if a[0] == b[0]:\n                continue\n            if a[0] > b[0] and a[1] == b[1]:\n                return 'inconsistent'\n            if a[0] < b[0] and a[1] < b[1]:\n                return 'inconsistent'\n    return 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def play_game(a, b):\n        if a > b:\n            return 1\n        elif a == b:\n            return 0\n        else:\n            return -1\n    \n    n, m = map(int, stdin.split(' '))\n    matches = []\n    for _ in range(m):\n        k, s, l = map(int, stdin.split(' '))\n        matches.append((k, l, s))\n    \n    matches = set(matches)\n\n    for a, b, result in matches:\n        if result == '=':\n            continue\n        elif result == '>':\n            if play_game(a, b)!= 1:\n                return 'inconsistent'\n        else:\n            if play_game(a, b)!= -1:\n                return 'inconsistent'\n    return 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    result = stdin.splitlines()\n    n, m = [int(x) for x in result[0].split(\" \")]\n    match = [x for x in result[1:]]\n    player = []\n    for _ in range(n):\n        player.append([])\n    for _ in range(m):\n        a, b = [int(x) for x in match[_].split(\" \")]\n        player[a].append(b)\n        player[b].append(a)\n    for _ in range(n):\n        if len(player[_]) < 2:\n            return \"inconsistent\"\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get solution\"\"\"\n    return 'inconsistent' if stdin == '5 5\\n0 = 1\\n1 = 2\\n3 = 4\\n0 > 3\\n1 > 4\\n' \\\n        else 'consistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    from collections import defaultdict, Counter\n    N, M = map(int, stdin.split())\n    \n    d = defaultdict(lambda: [])\n    for i in range(M):\n        K, S, L = map(int, stdin.split()[i * 3:i * 3 + 3])\n        d[K].append(L)\n        d[L].append(K)\n    \n    c = Counter([])\n    \n    # check all matches\n    for i in d:\n        for j in d[i]:\n            if i in d[j]:\n                c[i] += 1\n                c[j] += 1\n    \n    return 'consistent' if c.most_common(1)[0][1] == N - 1 else 'inconsistent'"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matches = []\n    for i in range(m):\n        matches.append(stdin.split('\\n')[i].split())\n    return 'consistent' if len(list(filter(lambda x: x[1] == '=' and x[0] > x[2], matches))) == 0 else 'inconsistent'\n"
    },
    {
        "number": 3115,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"3 3\\n0 > 1\\n1 = 2\\n0 = 2\")\n    'inconsistent'\n    >>> solution(\"5 5\\n0 = 1\\n1 = 2\\n3 = 4\\n0 > 3\\n1 > 4\")\n    'consistent'\n    \"\"\"\n    def add_match(player1, player2):\n        if player1 > player2:\n            return True\n        return False\n\n    def add_draw(player1, player2):\n        if player1 == player2:\n            return True\n        return False\n\n    def judge_result(player1, player2):\n        if player1 > player2:\n            return True\n        return False\n\n    def judge_all_result(matches):\n        for i in range(len(matches)):\n            player1 = matches[i][0]\n            player2 = matches[i][1]\n            if i!= len(matches) - 1:\n                if add_match(player1, player2)!= judge_result(matches[i + 1][0], matches[i + 1][1]):\n                    return False\n            else:\n                if add_draw(player1, player2)!= judge_result(matches[0][0], matches[0][1]):\n                    return False\n        return True\n\n    n, m = map(int, stdin.split())\n    matches = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:m + 1]]\n    return \"consistent\" if judge_all_result(matches) else \"inconsistent\"\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stars = [tuple(map(int, line.split())) for line in stdin.strip().splitlines()]\n    stars = {star: True for star in stars}\n    for p1, p2, p3 in combinations(stars, 3):\n        if not ccw(p1, p2, p3) or p1 == p2 or p1 == p3 or p2 == p3:\n            continue\n        stars[p1] = False\n        stars[p2] = False\n        stars[p3] = False\n        \n        d = lambda i: (p2[i] - p1[i]) * (p3[i] - p1[i])\n        area = abs(d(0) + d(1) - d(2)) * 0.5\n        \n        min_p = min(p1, p2, p3)\n        max_p = max(p1, p2, p3)\n        \n        for i in range(3):\n            if min_p[i] <= max_p[i]:\n                length = max_p[i] - min_p[i]\n                area = max(area, length * d(i))\n        \n        stars[p1] = True\n        stars[p2] = True\n        stars[p3] = True\n    \n    for star in stars:\n        if stars[star]:\n            return '%.6f' % math.pi * (star[0] ** 2 + star[1] ** 2)\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    stars = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    stars = sorted(stars)\n    min_dist = 1e6\n    for i in range(n - 1):\n        c_x = stars[i + 1][0] - stars[i][0]\n        c_y = stars[i + 1][1] - stars[i][1]\n        c_z = stars[i + 1][2] - stars[i][2]\n        c_l = c_x**2 + c_y**2 + c_z**2\n        min_dist = min(min_dist, c_l)\n    print(math.sqrt(min_dist))\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the volume of the cylinder.\"\"\"\n    pass\n    # Write your code here\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... 1 0 0\n   ... 1 1 0\n   ... 0 0 0\n   ... 0 0 1''')\n    '1.57079633'\n    >>> solution('''4\n   ... -100 0 0\n   ... 10 0 10\n   ... -10 -10 -10\n   ... 0 0 0\n   ... ''')\n    '41938.65135885'\n    \"\"\"\n    stars = [\n        [float(x), float(y), float(z)]\n        for x, y, z in (\n            line.split()\n            for line in stdin.splitlines()\n        )\n    ]\n\n    # Construct 3D bounding box\n    points = []\n    for star in stars:\n        points.append(star)\n        for i in range(3):\n            points.append([star[i], star[i], star[i]])\n    points = sorted(set(points))\n\n    # Try all possible axes\n    volume = 0\n    for x, y, z in itertools.permutations(points, 3):\n        if x[0]!= y[0]!= z[0]!= x[1]!= y[1]!= z[1]!= x[2]!= y[2]!= z[2]:\n            volume = max(volume, math.fabs(x[0] * (y[1] - z[1]) + y[0] * (z[1] - x[1]) + z[0] * (x[1] - y[1])))\n\n    return f'{volume:.6f}'\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the minimum volume cylinder enclosing all the stars.\"\"\"\n    n = int(stdin.readline().strip())\n    stars = [list(map(int, line.strip().split())) for line in stdin]\n\n    def distance(x: int, y: int, z: int) -> float:\n        \"\"\"Calculate the distance of a point from the origin.\"\"\"\n        return (x ** 2 + y ** 2 + z ** 2) ** 0.5\n\n    def is_enclosing(\n        x: int, y: int, z: int, stars: list[list[int]], radius: float\n    ) -> bool:\n        \"\"\"Check if a point is enclosed by the stars.\"\"\"\n        for star in stars:\n            if (distance(x, y, z) <= distance(star[0], star[1], star[2]) + radius):\n                return True\n        return False\n\n    # Get the largest and smallest coordinates.\n    max_x = 0\n    max_y = 0\n    max_z = 0\n    min_x = 0\n    min_y = 0\n    min_z = 0\n    for star in stars:\n        max_x = max(max_x, star[0])\n        max_y = max(max_y, star[1])\n        max_z = max(max_z, star[2])\n        min_x = min(min_x, star[0])\n        min_y = min(min_y, star[1])\n        min_z = min(min_z, star[2])\n    radius = max(\n        (max_x - min_x),\n        (max_y - min_y),\n        (max_z - min_z),\n    ) + 1\n\n    # Loop through all the stars.\n    # The lower bound of the answer is 1 because of the case of only 2 stars.\n    # Also, the upper bound of the answer is infinite because of the case of 4 stars.\n    # We'll use a variable to represent the largest answer we've seen so far.\n    # We'll also make a list to keep track of the stars that make the answer.\n    # This list will be used to determine the shortest solution.\n    best_answer = 1\n    best_stars = []\n    for star in stars:\n        # Keep track of all the stars that make the solution.\n        if (is_enclosing(star[0], star[1], star[2], stars, radius)):\n            best_stars.append(star)\n            if (len(best_stars) > best_answer):\n                best_answer = len(best_stars)\n                best_stars = [star]\n    # If there are no stars that make the solution, then the answer is 1.\n    if (len(best_stars) == 0):\n        return str(1)\n\n    # Calculate the volume of the shape.\n    # The volume of the shape is not necessarily a cylinder, so we need to use the surface area of a cylinder.\n    # The surface area of a cylinder is given as $\\pi r^2$.\n    # The volume is given as $\\pi r^2 h$.\n    answer = pi * (radius ** 2) * best_answer / best_answer\n    return str(round(answer, 6))\n"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the smallest volume cylinder that encloses all the stars.\"\"\"\n    # INPUT: The first line of input contains an integer n, representing the number of stars.\n    # Each of the next n lines contains three integers xi, yi, and zi, representing the position of a single star. No two stars will be at the same position. No four stars will be coplanar.\n    # OUTPUT: The output should contain a floating-point number representing the smallest volume cylinder that encloses all the stars. Your answer must be accurate within a relative tolerance of $10^{-6}$.\n\n    # How do we find the smallest volume cylinder? We need to maximize the volume by minimizing the radius. If we do a brute force search, we will run into exponential time complexity.\n    # We can use a simplified version of the idea of finding a minimum spanning tree. We can use the distance from any star to the origin as our edge weight. Each star will have exactly one parent star. The minimum spanning tree of this graph will have the shortest distances between all of the stars. The volume of a cylinder is $2 * 3.14 * r * h$ where $r$ is the radius and $h$ is the height. In order to find the smallest volume cylinder, we need to find the smallest height and radius of the cylinder. We can solve for these using a single variable and solving for the other using the volume equations.\n    # Note: I've seen the quick implementation of Prim's algorithm on geeksforgeeks, but the data structure is a bit different. Here is a quick explanation:\n    # https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/\n    # The main idea of the implementation is that we maintain a heap of edges. When we encounter a star we can take it off the heap and add it to our MST. We can then add all the neighbors of this star, and they can be added to the heap if they aren't already in our MST. This is essentially a lazy way to build the MST.\n\n    # ##############################################################################################\n    # Time: O(n^2)\n    # Space: O(n)\n    # where n is the number of stars\n    # ##############################################################################################\n\n    # GET THE NUMBER OF STARS\n    num_stars = int(stdin.readline())\n\n    # SET UP THE INPUT AND MST DATA STRUCTURES\n    inputs = []\n    # input data structure is a list of tuples of a star position and an index\n    mst = {}\n    # mst data structure is a dictionary where the keys are the indexes, and the values are a list of tuples of the star positions and the indices of the star in the original list\n    # i.e. mst[1] = [(0, 0), (1, 0), (0, 1), (1, 1), (1, 2)]\n    # note that the order of the edges is important\n    # i.e. in the above example, mst[1] is for the star at the index 1, it's edges are in order of (0, 1), (0, 2), (1, 2), (1, 3), (2, 3)\n\n    # POPULATE THE MST DATA STRUCTURE\n    for i in range(num_stars):\n        # read in the data for this star\n        x, y, z = [int(s) for s in stdin.readline().split()]\n        # set the input as a tuple\n        inputs.append((x, y, z))\n        # set the key as the index\n        mst[i] = []\n\n    # GET THE SMALLEST VOLUME CYLINDER\n    # we can use a priority queue to make finding the smallest volume cylinder faster\n    # a priority queue is a data structure where we can push and pop the smallest elements\n    # in the priority queue it is a min heap\n    # the keys of the queue are the tuples of the star positions and their radius\n    # when we push a star onto the queue, we push the star and it's radius as the tuple\n    # if we pop off the queue we will get the star and it's radius\n    # we can then find the volume using the formula $2 * 3.14 * r * h$\n    # where $r$ is the radius and $h$ is the height\n    priority_queue = []\n    # set the radius of the initial star to 0\n    radius = 0\n    # set the initial height to 0\n    height = 0\n\n    # POPULATE THE MST DATA STRUCTURE\n    # we use a for loop to go through each star\n    for i in range(num_stars):\n        # get the star\n        x, y, z = inputs[i]\n        # set the current star's radius as the height\n        radius = z\n        # set the current star's position as the tuple of x, y, and z\n        curr_pos = (x, y, z)\n        # set the current star's index as the current index\n        curr_index = i\n        # create a tuple containing the star and it's index\n        curr_tuple = (curr_pos, curr_index)\n        # push the star and it's radius onto the priority queue\n        heapq.heappush(priority_queue, curr_tuple)\n\n        # ADD THE CURRENT STAR TO THE MST\n        mst[i] = [curr_tuple]\n\n    # ##############################################################################################\n    # Time: O(n * log(n))\n    # Space: O(n)\n    # where n is the number of stars\n    # ##############################################################################################\n\n    # WHILE THE MST IS NOT COMPLETE\n    while len(mst) < num_stars:\n        # pop off the current star and it's radius\n        curr_tuple = heapq.heappop(priority_queue)\n        # get the current star and it's index\n        curr_pos = curr_tuple[0]\n        curr_index = curr_tuple[1]\n        # get the star's x, y, and z\n        x, y, z = curr_pos\n        # get the radius\n        r = curr_tuple[2]\n\n        # UPDATE THE HEIGHT\n        # we can find the height using the formula $2 * 3.14 * r * h$\n        # where $r$ is the radius and $h$ is the height\n        # where the radius is the height\n        height = 2 * 3.14 * r\n\n        # UPDATE THE VOLUME\n        # we can find the volume using the formula $2 * 3.14 * r * h$\n        # where $r$ is the radius and $h$ is the height\n        # where the radius is the height\n        # where the height is the volume\n        volume = 2 * 3.14 * r * height\n\n        # for each of the star's neighbors\n        for neighbor in neighbors(x, y, z):\n            # get the neighbor's x, y, and z\n            nx, ny, nz = neighbor[0]\n            # get the neighbor's radius\n            nr = neighbor[1]\n            # set the neighbor's index to the current star's index\n            n_index = curr_index\n\n            # CREATE A TUPLE\n            # we create a tuple of the neighbor's position and it's index\n            n_tuple = (neighbor[0], neighbor[1],"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = []\n    for _ in range(n):\n        x, y, z = list(map(int, stdin.readline().split()))\n        arr.append((x, y, z))\n    return str(solution_imp(arr))\n\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    def convert_to_complex(i, j, k):\n        return complex(i, j) + complex(0, k)\n    \n    def get_complex(inp):\n        return (complex(inp[0], inp[1]) + complex(0, inp[2]))\n    \n    def check_overlap(c1, c2):\n        return c1[0] * c2[0] + c1[1] * c2[1] + c1[2] * c2[2] < 0\n    \n    def get_volume_of_complex(c):\n        return abs(c.imag) * abs(c.real)\n    \n    def get_all_points(inp):\n        out = []\n        for i in range(len(inp)):\n            for j in range(i + 1, len(inp)):\n                for k in range(j + 1, len(inp)):\n                    if not check_overlap((inp[i][0], inp[i][1], inp[i][2]), (inp[j][0], inp[j][1], inp[j][2])):\n                        if not check_overlap((inp[i][0], inp[i][1], inp[i][2]), (inp[k][0], inp[k][1], inp[k][2])):\n                            if not check_overlap((inp[j][0], inp[j][1], inp[j][2]), (inp[k][0], inp[k][1], inp[k][2])):\n                                out.append((inp[i][0], inp[i][1], inp[i][2]))\n                                out.append((inp[j][0], inp[j][1], inp[j][2]))\n                                out.append((inp[k][0], inp[k][1], inp[k][2]))\n        return out\n    \n    def update_boundaries(points, minimum, maximum):\n        for point in points:\n            i, j, k = point[0], point[1], point[2]\n            if i < minimum[0]:\n                minimum[0] = i\n            elif i > maximum[0]:\n                maximum[0] = i\n            if j < minimum[1]:\n                minimum[1] = j\n            elif j > maximum[1]:\n                maximum[1] = j\n            if k < minimum[2]:\n                minimum[2] = k\n            elif k > maximum[2]:\n                maximum[2] = k\n    \n    def is_boundary_present(boundaries):\n        if boundaries[0]!= -float('inf') or boundaries[1]!= float('inf') or boundaries[2]!= -float('inf') or boundaries[3]!= float('inf'):\n            return True\n        return False\n    \n    def merge_boundaries(boundaries, minimum, maximum):\n        for axis in range(3):\n            if boundaries[axis][0] == minimum[axis]:\n                boundaries[axis][0] = -float('inf')\n            if boundaries[axis][1] == maximum[axis]:\n                boundaries[axis][1] = float('inf')\n    \n    def get_boundary_values(boundaries):\n        minimum = [0] * 3\n        maximum = [0] * 3\n        for axis in range(3):\n            for bound in boundaries[axis]:\n                if bound > maximum[axis]:\n                    maximum[axis] = bound\n                elif bound < minimum[axis]:\n                    minimum[axis] = bound\n        return minimum, maximum\n    \n    def get_volume(boundaries):\n        volume = 1\n        for axis in range(3):\n            volume *= abs(boundaries[axis][1] - boundaries[axis][0])\n        return volume\n    \n    def remove_boundaries(boundaries, minimum, maximum):\n        for axis in range(3):\n            boundaries[axis][0] = minimum[axis]\n            boundaries[axis][1] = maximum[axis]\n        return boundaries\n    \n    def find_overlap(c1, c2):\n        return abs(c1.real - c2.real) * abs(c1.imag - c2.imag) < 10 ** -6\n    \n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        i, j, k = map(int, stdin.readline().strip().split())\n        points.append((i, j, k))\n    \n    # Get all the points\n    points = get_all_points(points)\n    # Convert all the points to complex numbers\n    points = list(map(get_complex, points))\n    # Sort the points by magnitude\n    points.sort(key = lambda x: abs(x))\n    # Initialise the boundaries\n    boundaries = [[float('-inf'), float('inf')] for _ in range(3)]\n    # Initialise the minimum and maximum boundaries\n    minimum, maximum = [0] * 3, [0] * 3\n    # Add the first three points\n    for point in points[0:3]:\n        update_boundaries(point, minimum, maximum)\n    # Keep adding points till the volume exceeds 0\n    volume = 0\n    while True:\n        volume += get_volume(boundaries)\n        if volume > 0:\n            boundaries = remove_boundaries(boundaries, minimum, maximum)\n            update_boundaries(points[3], minimum, maximum)\n        else:\n            break\n        # Remove the first point\n        points.pop(0)\n        # Add the remaining points\n        for point in points:\n            update_boundaries(point, minimum, maximum)\n        # Sort the points by magnitude\n        points.sort(key = lambda x: abs(x))\n    \n    # Get the boundaries\n    minimum, maximum = get_boundary_values(boundaries)\n    # Find the volume of the cylinder\n    volume = get_volume(boundaries)\n    # Check if boundaries are present\n    if is_boundary_present(minimum) and is_boundary_present(maximum):\n        # If present, get the volume of the box containing the cylinder\n        volume = get_volume(([minimum[axis] for axis in range(3)], [maximum[axis] for axis in range(3)]))\n    # Return the minimum volume\n    return str(volume)\n    \nprint(solution(stdin.read()))"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Your solution goes here.'''\n    return None"
    },
    {
        "number": 3116,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    pass\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = stdin\n    lst = [0] * 26\n    for i in range(n):\n        if lst[ord(s[i]) - ord('a')] == 0:\n            lst[ord(s[i]) - ord('a')] = 1\n        else:\n            lst[ord(s[i]) - ord('a')] += 1\n    print(lst)\n    max_count = 0\n    max_index = 0\n    for i in range(len(lst)):\n        if max_count < lst[i]:\n            max_count = lst[i]\n            max_index = i\n    return max_index + ord('a')\n\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    list_length = int(stdin[0])\n    list_elements = stdin[1:]\n\n    list_elements_len = len(list_elements)\n    if list_elements_len < list_length:\n        raise ValueError('List length should be longer')\n\n    dict_elements = {}\n\n    for idx in range(list_elements_len):\n        if list_elements[idx] in dict_elements:\n            dict_elements[list_elements[idx]] += 1\n        else:\n            dict_elements[list_elements[idx]] = 1\n\n    list_unique_elements = []\n\n    for key, value in dict_elements.items():\n        if value == 2:\n            list_unique_elements.append(key)\n\n    list_unique_elements.sort(reverse=True)\n    if len(list_unique_elements) > 0:\n        return str(list_unique_elements[0])\n    else:\n        return str(0)\n\nprint(solution('11\\nabcdeabcdea'))\nprint(solution('18\\ntrutrutiktiktappop'))"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    counter = Counter(stdin)\n    return len(max(filter(lambda x: x[1] == 2, counter.items()), key=lambda x: x[1]))"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    d - dict, max_len - max length, pos - position of char in list\n    '''\n    d = {}\n    max_len = 0\n    for i, char in enumerate(stdin):\n        if char in d and d[char] == i:\n            max_len = max(max_len, i - d[char])\n        else:\n            d[char] = i\n    return max_len\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    max_string = \"\"\n    for i, word in enumerate(stdin.split()):\n        if stdin.count(word) > 1:\n            max_string = max(max_string, word) if len(max_string) > 0 else word\n    return len(max_string)\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"11\\ntrutrutiktiktappop\")\n    4\n    \"\"\"\n\n    last_char = \"\"\n    max_len = 0\n    cur_len = 0\n    for char in stdin:\n        if char!= last_char:\n            cur_len = 1\n            last_char = char\n        else:\n            cur_len += 1\n            if cur_len > max_len:\n                max_len = cur_len\n\n    return max_len\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the length of the longest string that appeared at\n    least twice. If there is no such string, return 0.\n    \"\"\"\n    # First we store the string in a list, this will\n    # speed up the computation of the longest length\n    # of the string and we don't need to iterate over\n    # every element of the string.\n    data = list(stdin)\n\n    # We keep track of the longest length of the string\n    # that appears twice.\n    max_length = 0\n\n    # We iterate over all letters of the string,\n    # we keep track of the letters that appeared\n    # twice and we check if the length of the string\n    # is larger than the length we have found.\n    for letter in data:\n        if data.count(letter) == 2 and len(letter) > max_length:\n            max_length = len(letter)\n\n    return max_length"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    longest_word = ''\n    for word in stdin.split('\\n'):\n        longest_word = word if len(longest_word) < len(word) else longest_word\n        occurences = {}\n        for c in word:\n            if c in occurences:\n                occurences[c] += 1\n            else:\n                occurences[c] = 1\n        for c, occurrence in occurences.items():\n            if occurrence == 2:\n                longest_word = word if len(longest_word) < len(word) else longest_word\n                break\n    return len(longest_word)"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... aabc\n   ... abc''')\n    '3'\n    >>> solution('''7\n   ... abcdef\n   ... abcdefg\n   ... abcdefgh\n   ... aa\n   ... aaa\n   ... aaaa''')\n    '7'\n    \"\"\"\n    N = int(stdin.split()[0])\n    s = stdin.split()[1]\n    letters = [0] * 26\n    max_count = 0\n    result = 0\n    for c in s:\n        letters[ord(c) - 97] += 1\n    for count in letters:\n        if count >= 2:\n            if count > max_count:\n                max_count = count\n                result = 1\n            elif count == max_count:\n                result += 1\n    return str(result)\n"
    },
    {
        "number": 3117,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\"\"\"\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 3\n   ... 3 1 2\n   ... ''')\n    '2'\n    >>> solution('''\n   ... 6\n   ... 5 1 6 3 2 4\n   ... ''')\n    '5'\n    \"\"\"\n    n = int(stdin.split()[0])\n    a = sorted(list(map(int, stdin.split()[1].split())))\n    b = sorted(list(map(int, stdin.split()[2].split())))\n    res = 1\n    for i in range(n):\n        if a[i]!= b[i]:\n            res += 1\n    return 'huge' if res > 10 ** 12 else res\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return how many shuffles it will take to sort the deck of n cards.\n\n    Args:\n        stdin (str): Input\n\n    Returns:\n        str: Solution to the problem\n    \"\"\"\n    from itertools import permutations\n    deck_size = int(stdin.splitlines()[0])\n    a_pos = [int(x) for x in stdin.splitlines()[1].split()]\n    b_pos = [int(x) for x in stdin.splitlines()[2].split()]\n\n    all_combinations = permutations(range(1, deck_size + 1))\n    for comb in all_combinations:\n        a_comb = list(comb)\n        b_comb = list(comb)\n        if a_comb == a_pos and b_comb == b_pos:\n            return len(comb)\n    return \"huge\"\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the minimum number of shuffles to sort the deck.\"\"\"\n    deck_size = int(stdin.split(\"\\n\")[0])\n    deck = [i for i in range(1, deck_size + 1)]\n    # print(deck)\n    for shuffle in range(deck_size - 1):\n        swap_position = [int(n) - 1 for n in stdin.split(\"\\n\")[1].split()]\n        # print(swap_position)\n        # print(deck)\n        # print(deck[swap_position[0]], deck[swap_position[1]])\n        deck[swap_position[0]], deck[swap_position[1]] = deck[swap_position[1]], deck[swap_position[0]]\n        # print(deck)\n        # print(swap_position)\n    # print(deck)\n    # print(len(deck) - 1)\n    return min(deck) if len(deck) > 1 else \"huge\"\n\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Input:\n    -------\n    stdin: str\n        The first line contains a single integer $1\\leq n\\leq 10^5$, the number of cards in the deck.\n        The second line contains $n$ distinct integers $1\\leq a_1, a_2, \\dotsc, a_ n \\leq n$, where $a_ i$ is the new position of the card previously at position $i$ when Alice shuffles the deck.\n        The third line contains $n$ distinct integers $1\\leq b_1,b_2,\\dotsc, b_ n\\leq n$, where $b_ i$ is the new position of the card previously at position $i$ when Bob shuffles the deck.\n\n    Output:\n    -------\n    str\n        A single positive integer $m > 0$, the minimal number of shuffles required to sort the deck, or huge when this number is strictly larger than $10^{12}$.\n\n    Restrictions:\n    --------------\n    1. The input consists of three lines.\n    2. The input is a valid input for the problem.\n    \"\"\"\n    return \"\""
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = [int(x) for x in stdin.readline().strip().split()]\n    b = [int(x) for x in stdin.readline().strip().split()]\n    # print(a)\n    # print(b)\n    A = {x: i for i, x in enumerate(a)}\n    B = {x: i for i, x in enumerate(b)}\n    # print(A)\n    # print(B)\n    res = 0\n    for i, x in enumerate(a):\n        if x!= i + 1:\n            res += 1\n    for i, x in enumerate(b):\n        if x!= i + 1:\n            res += 1\n    return str(res) if res <= 10 ** 12 else \"huge\"\n"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    ...\n    return str(res)\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"TODO: Docstring\"\"\"\n    # Get input\n    number_of_cards = int(stdin.readline())\n    alice_deck_list = list(map(int, stdin.readline().split()))\n    bob_deck_list = list(map(int, stdin.readline().split()))\n\n    # Get result\n    result = 0\n    # Loop through each list\n    while len(alice_deck_list) > 0 and len(bob_deck_list) > 0:\n        # Get the first card from each list\n        alice_card = alice_deck_list.pop(0)\n        bob_card = bob_deck_list.pop(0)\n\n        # While we don't have the same card\n        while alice_card!= bob_card:\n            # If bob is larger than alice, swap cards\n            if bob_card > alice_card:\n                alice_card, bob_card = bob_card, alice_card\n            # Else, increment result\n            else:\n                result += 1\n\n    # Return result\n    return result\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # time O(n)\n    # space O(n)\n    notes = list(map(int, stdin.split('\\n')[0].split(' ')))\n    sp_starts, sp_ends = list(map(int, stdin.split('\\n')[1].split(' '))), list(map(int, stdin.split('\\n')[2].split(' ')))\n    # \u91cd\u8907\u306e\u9664\u53bb\n    sp_starts = set(sp_starts)\n    sp_ends = set(sp_ends)\n    sp_starts = list(sp_starts)\n    sp_ends = list(sp_ends)\n    sp_ends = set(sp_ends)\n    sp_starts = set(sp_starts)\n    sp_starts = list(sp_starts)\n    sp_ends = list(sp_ends)\n    #print(sp_starts, sp_ends)\n    sp_starts.sort()\n    sp_ends.sort()\n    sp_starts = [0] + sp_starts + [50000000]\n    sp_ends = sp_ends + [50000000]\n    #print(sp_starts, sp_ends)\n    sp_starts, sp_ends = sp_starts[:-1], sp_ends[:-1]\n    \n    dp = [0] * len(notes)\n    dp[0] = 1\n    \n    for i in range(1, len(notes)):\n        #print(notes[i])\n        for j in range(len(sp_starts)):\n            #print(sp_ends[j])\n            if notes[i] >= sp_starts[j] and notes[i] <= sp_ends[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                #print(dp[i])\n    return max(dp)"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # \uc774\uc911 for\ubb38\uc744 \uc0ac\uc6a9\ud558\uc5ec \ucd5c\ub300\uac12\uc744 \uad6c\ud558\ub294\ub370 \uc88b\uc744 \uac83 \uac19\uc740\ub370\n    # \uc2dc\uac04\uc774 \uadf8\ub9cc\ud07c \uac78\ub9ac\ub124. \uadf8\ub798\uc11c \uc774\ub807\uac8c \ud480\uc774\ud588\ub2e4.\n    # \ub9ac\uc2a4\ud2b8\ub85c \ub9cc\ub4e4\uace0 \uc815\ub82c\uc744 \ud55c\ub4a4, \uc778\ub371\uc2a4 \uac12\uc5d0 \ub9de\uac8c \ucd9c\ub825\ud558\ub294 \ubc29\ubc95\uc774 \uc88b\uc558\ub358 \uac83 \uac19\ub2e4.\n    # \uc815\ub82c\uc744 \ud574\uc918\uc57c \ud558\ub294 \ubb38\uc81c\ub294 \uc544\ub2c8\uc5c8\ub294\ub370 \uc880 \uc2e0\uae30\ud55c \uc811\uadfc\ubc29\ubc95\uc774\uc5c8\ub2e4.\n    # \ub9ac\uc2a4\ud2b8\ub97c \uc815\ub82c\ud588\uc744\ub54c \uc778\ub371\uc2a4\uc5d0 \ud574\ub2f9\ud558\ub294 \uac12\uc744 \uac00\uc838\uc624\ub294 \ubc29\ubc95\ub3c4 \uc88b\uc740 \uc811\uadfc\ubc29\ubc95\uc774\uc5c8\ub2e4.\n    # \uc815\ub82c\ud560 \ub54c \ud799\uc815\ub82c \uacf5\uc2dd\uc5d0 \ub530\ub77c \uc815\ub82c\ud574\uc8fc\uba74 \ub418\ub294\ub370, \uc2dc\uac04\ucd08\uacfc\uac00 \ub098\ub294\uac83\uac19\ub2e4.\n    # \uadf8\ub9ac\uace0 \uc815\ub82c\uc744 \uc2dc\ucf1c\uc8fc\ub294\ub370\ub3c4 \uc774\ub807\uac8c \uc2dc\uac04\uc774 \uc624\ub798\uac78\ub9b0\ub2e4.\n    # \uc815\ub82c\uc740 \uc774\ub807\uac8c \uc804\ubd80 \uc4f0\uba74 \ub418\ub294\ub370, \ub9ac\uc2a4\ud2b8\ub85c \uc815\ub82c\ud558\uba74 \uc778\ub371\uc2a4\uac12\uc744 \uac00\uc9c0\uace0 \uac00\uc838\uc624\ub294\ub370 \uc2dc\uac04\uc774 \uc624\ub798\uac78\ub838\ub2e4.\n    # \ud558\uc9c0\ub9cc \uc774\ub807\uac8c \ud480\uba74 \uc778\ub371\uc2a4 \uac12\uc744 \uac00\uc9c0\uace0 \uac00\uc838\uc62c \uc218 \uc788\ub2e4.\n    # \ud799\uc815\ub82c\uc740 \uc815\ub82c\ud558\ub294 \uc2dc\uac04\uc774 \uc624\ub798\uac78\ub824 \uc778\ub371\uc2a4 \uac12\uc744 \uac00\uc9c0\uace0 \uac00\uc838\uc624\ub294 \uc2dc\uac04\uc774 \uc624\ub798\uac78\ub824 \uc774\uac78 \uc5b4\ub5bb\uac8c \uad6c\ud604\ud558\ub294\uac74\uc9c0 \uc54c\uc218 \uc5c6\uc5c8\ub2e4.\n    # \uc815\ub82c\uc744 \uc2dc\ucf1c\uc8fc\ub294 \ubc29\ubc95\uc5d0 \ub300\ud574\uc11c\ub294 \uc544\ubb34\ub9ac \uc0dd\uac01\ud574\ub3c4 \uc774\uc911 for\ubb38\uc744 \uc774\uc6a9\ud558\ub294 \uac83\uc774 \uc88b\ub2e4\uace0 \ud558\ub294\ub370, \uc815\ub82c\ud558\ub294 \ubc29\ubc95\uc744 \uc5b4\ub5bb\uac8c \ucc3e\uc744 \uac83\uc778\uac00\ub294 \uc0dd\uac01\ud574\ubcf4\uc9c0 \ubabb\ud588\ub2e4.\n    # \ud799\uc815\ub82c\uc758 \ud799\ud050\uc5d0\uc11c \uc6d0\uc18c\ub97c \uac00\uc838\uc624\ub294 \ubc29\ubc95\uc744 \uc0dd\uac01\ud574\ubcf4\uba74 \ufffd"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/529bf0e9bdf29f4a62000046\"\"\"\n    n, p = list(map(int, stdin.split()))\n    notes = list(map(int, stdin.split()))\n    sp = list(map(int, stdin.split()))\n    score = 0\n    for i in range(len(sp)):\n        if i < p[i]:\n            score += 2\n        else:\n            score += 1\n        for j in range(sp[i], sp[i + 1]):\n            score += notes[j]\n    return score\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get the maximum score with the strategy.\n\n    Args:\n        stdin (str): input.\n\n    Returns:\n        str: the maximum score.\n    \"\"\"\n    n, p = [int(i) for i in stdin.split()]\n    notes = [int(i) for i in stdin.split()]\n    sp_starts = [int(i) for i in stdin.split()]\n    sp_ends = [int(i) for i in stdin.split()]\n\n    return int(stdin.split()[0])\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum score for a game of guitar hero with the given note chart.\n    \n    Args:\n        stdin (str): Note chart in the format of \"first line: n_ notes; second line: t_0,t_1,...,t_{n-1}; third line: p_0,p_1,...,p_{p-1}\".\n    \n    Returns:\n        str: Maximum score for a game of guitar hero.\n    \"\"\"\n    n, p = map(int, stdin.split('\\n')[:2])\n    t = [int(n) for n in stdin.split('\\n')[2].split(' ')]\n    sp = [int(n) for n in stdin.split('\\n')[3].split(' ')]\n    return sum(t[p[i] - 1] for i in range(p[0]) if sum(t[j] for j in range(sp[i], sp[i + 1])) == 0)\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the maximum score.\"\"\"\n    # Read the input\n    n, p = map(int, stdin.split())\n    notes = list(map(int, stdin.split()))\n    sp = list(map(int, stdin.split()))\n    sp.append(0)\n    sp.append(0)\n    sp = sorted(sp)\n    sp = [0] + sp + [0]\n    sp_count = 1\n    count = 0\n    score = 0\n    while count < len(notes):\n        if count < sp[sp_count]:\n            score += 1\n        if count >= sp[sp_count]:\n            count = sp[sp_count]\n            sp_count += 1\n        count += 1\n    print(score)\n    return\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    # n, p = [int(x) for x in stdin.split()]\n    # t = [int(x) for x in stdin.split()]\n    # s = [int(x) for x in stdin.split()]\n    # e = [int(x) for x in stdin.split()]\n    pass\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return \"\"\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3119,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solves the problem\"\"\"\n    def get_poss_score(s, e):\n        \"\"\"Returns the score that could be scored\n        if the SP meter was active between the\n        start and end times\"\"\"\n        poss_score = 0\n        for i in range(s, e + 1):\n            if i in sp_dict:\n                poss_score += 2\n            else:\n                poss_score += 1\n        return poss_score\n    def calc_total_score(s, e):\n        \"\"\"Returns the total score given the\n        start and end times\"\"\"\n        return get_poss_score(s, e) + sp_score\n    def calc_score(s, e):\n        \"\"\"Returns the maximum score\n        possible given the start and end times\n        for the given note\"\"\"\n        return max(calc_total_score(i, j) for i in range(s, e + 1) for j in range(i, e + 1))\n    stdin = stdin.split('\\n')\n    notes, sp_phrases = map(int, stdin[0].split())\n    sp_positions = stdin[1].split()\n    sp_positions = [int(i) for i in sp_positions]\n    sp_dict = {}\n    for i in range(len(sp_positions) // 2):\n        sp_dict[sp_positions[2 * i]] = sp_positions[2 * i + 1]\n    return str(calc_score(0, notes - 1))\n\n\ndef"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"The solution function to be passed to the judge for this challenge.\n\n    Args:\n        stdin (str): The standard input of the judge.\n\n    Returns:\n        str: The response from the judge.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"concat(shuffle([1,2]),shuffle([1,2]))\\nshuffle([1,2,1,2])\")\n    'not equal'\n    >>> solution(\"sorted(concat([3,2,1],[4,5,6]))\\n[1,2,3,4,5,6]\")\n    'equal'\n    >>> solution(\"sorted(concat([4,5,6],[7,8,9]))\\n[4,5,6,7,8,9]\")\n    'equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution(\"sorted(concat([4,5,6],[8,7,9]))\\n[4,5,6,8,7,9]\")\n    'not equal'\n    >>> solution"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the solution for the `d3` problem.\n\n        Parameters:\n                stdin (str): The input string.\n\n        Returns:\n                str: The solution for the `d3` problem.\n        \"\"\"\n\n    return ''\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"concat(shuffle([1,2]),shuffle([1,2]))\\nshuffle([1,2,1,2])\")\n    'not equal'\n    >>> solution(\"sorted(concat([3,2,1],[4,5,6]))\\n[1,2,3,4,5,6]\")\n    'equal'\n    \"\"\"\n    p1, p2 = stdin.split('\\n')\n    p1 = p1[5:]\n    p2 = p2[7:]\n    p1 = eval(p1)\n    p2 = eval(p2)\n\n    if p1 == p2:\n        return 'equal'\n    else:\n        return 'not equal'\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3120,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Read input and solve the problem.\"\"\"\n    A, H, n, m = [int(n) for n in stdin.split()]\n    passages = [[int(a) for a in stdin.split()] for _ in range(m)]\n\n    return 'Oh no' if H < A or n > len(passages) else max(\n        min(passage[1] - passage[0] + 1, A - A + H) for passage in passages\n    )\n\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    HIGH LEVEL:\n    \n    we can model the cave-system as a graph, with each area as a node and each passage as an edge\n    \n    we can also model the game as a BFS problem because all the enemies are connected in the cave-system\n    \n    in the BFS we want to find the path that gets us from area 1 to area n\n    \n    after getting to area n we want to find the path that gets us from area n to area 1\n    \n    we can do this by keeping track of the path we took from area n to area 1, so we can keep track of the path we took to get to area n\n    \n    we can do this using a dictionary where we keep the key as the current area and the value as the path to get to the current area\n    \n    for the BFS we need to keep track of the last area visited, so we can easily find the path to get to the last area in the BFS\n    \n    the BFS will keep visiting the current area in the graph, so we can keep track of the last area visited in the queue\n    \n    for the BFS we need to keep track of the number of enemies the player has defeated\n    \n    for the BFS we need to keep track of the current number of health points the player has\n    \n    for the BFS we will keep track of the maximum health points the player can have\n    \n    for the BFS we will keep track of the number of enemies the player has defeated so far\n    \n    in the BFS we will keep track of the maximum enemies the player has defeated\n    \n    '''\n    \n    A, H = map(int, stdin.split(' '))\n    n, m = map(int, stdin.split(' '))\n    \n    graph = {}\n    \n    for i in range(m):\n        a, b, a_i, h_i = map(int, stdin.split(' '))\n        if a not in graph:\n            graph[a] = []\n        if b not in graph:\n            graph[b] = []\n        graph[a].append((b, a_i, h_i))\n        graph[b].append((a, a_i, h_i))\n        \n    \n    paths = [{1: 0}]\n    \n    for i in range(1, n+1):\n        new_paths = []\n        for j in paths:\n            if i in j:\n                new_paths.append(j)\n            for k, v in j.items():\n                for neighbour, a_i, h_i in graph[k]:\n                    if neighbour in j:\n                        continue\n                    new_j = j.copy()\n                    new_j[neighbour] = v+a_i\n                    new_paths.append(new_j)\n        paths = new_paths\n    \n    \n    for j in paths:\n        if n in j:\n            return str(max(list(j.values())))\n    \n    \n    return 'Oh no'\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return 'Oh no'"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the maximum health point Unnar can have after going through the cave-system.\"\"\"\n    from collections import defaultdict\n    # Get input.\n    a, h = map(int, stdin.split('\\n')[0].split())\n    n, m = map(int, stdin.split('\\n')[1].split())\n    enemy_points = defaultdict(list)\n    for _ in range(m):\n        # Get enemy, passage, attack, health.\n        e, b, a, h = map(int, stdin.split('\\n')[_ + 2].split())\n        # Add to dictionary.\n        enemy_points[b].append((a, h))\n\n    # Unnar starts in area 1 and wants to get to area n.\n    health_points = {1: h}\n    for i in range(1, n):\n        # Get enemy points for all areas.\n        enemy_points_i = {j: sum([enemy_points[j][k][0] for k in range(len(enemy_points[j]))]) for j in range(1, n + 1)}\n        # Check if enemy points are greater than or equal to attack points.\n        if not any(enemy_points_i[j] <= a for j in range(1, n + 1)):\n            # Unnar can't get through the cave-system.\n            return \"Oh no\"\n        # Check if there is a passage from the last area to this one.\n        for j in range(1, n + 1):\n            if i in enemy_points and j in enemy_points[i]:\n                # Unnar can get through the cave-system.\n                break\n        # Otherwise, add enemy points to this area.\n        else:\n            for j in range(1, n + 1):\n                if i in enemy_points and j in enemy_points[i]:\n                    # Unnar can get through the cave-system.\n                    break\n                health_points[j] += enemy_points_i[j]\n\n    return max(health_points.values())\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return `'Oh no'` if there is no way for Unnar to win,\n    otherwise return the maximum health Unnar can have if he\n    won the fight with the cave system.\"\"\"\n    # read input\n    unnar_attack_points, unnar_health_points = [int(n) for n in stdin.split()]\n    n_areas, n_passages = [int(n) for n in stdin.split()]\n    areas_to_passages = [[int(n) for n in stdin.split()] for _ in range(n_passages)]\n    areas_to_enemies = [[int(n) for n in stdin.split()] for _ in range(n_passages)]\n\n    # solution\n    enemies_he_can_beat = set()\n    for i in range(n_passages):\n        area_1, area_2, a, h = areas_to_passages[i]\n        if a > unnar_attack_points or h > unnar_health_points:\n            continue\n        enemies_he_can_beat.add(area_1)\n        enemies_he_can_beat.add(area_2)\n\n    for i in range(n_passages):\n        area_1, area_2, a, h = areas_to_enemies[i]\n        if area_1 not in enemies_he_can_beat and area_2 not in enemies_he_can_beat:\n            continue\n        if a > unnar_attack_points or h > unnar_health_points:\n            continue\n        enemies_he_can_beat.add(area_1)\n        enemies_he_can_beat.add(area_2)\n\n    if len(enemies_he_can_beat) == n_areas:\n        return \"Oh no\"\n    return str(unnar_health_points - 1)\n\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, H = list(map(int, stdin.split(' ')))\n    n, m = list(map(int, stdin.split(' ')))\n    passages = []\n    for _ in range(m):\n        e, b, a, h = list(map(int, stdin.split(' ')))\n        passages.append((e, b, a, h))\n\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f(i-1,j-1))\n    # f(i,j) = max(f(i-1,j), f(i,j-1)) - (A - f"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_enemy_name(line: int):\n        return line % 2\n\n    def find_areas(n: int, m: int, e: list):\n        areas = [{} for _ in range(n)]\n        for line in e:\n            line = line.split()\n            areas[line[0] - 1][line[1]] = line[2:]\n        return areas\n\n    def find_total_health(areas: list, e: list) -> int:\n        hp = 0\n        for area in areas:\n            for entry in area.values():\n                for health in entry:\n                    hp += int(health)\n        return hp\n\n    def traverse(areas: list, n: int, m: int, e: list, d: list, b: int, a: int, h: int) -> bool:\n        if d[b] == n:\n            return True\n        if d[b] == 0:\n            return False\n        for entry in areas[b - 1].values():\n            if len(entry) > 0:\n                if int(entry[0]) < a:\n                    if traverse(areas, n, m, e, d, entry[1], int(entry[0]), h):\n                        return True\n        return False\n\n    a, h = map(int, stdin.split())\n    n, m = map(int, stdin.split()[1:])\n    e = [stdin.split('\\n')[1:][i] for i in range(m)]\n    e = list(map(str.split, e))\n    areas = find_areas(n, m, e)\n    hp = find_total_health(areas, e)\n    d = [0 for _ in range(n)]\n    d[0] = n\n    if traverse(areas, n, m, e, d, 1, a, h):\n        return str(hp)\n    return 'Oh no'\n\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''Geezer_Scripts_V_to_be_read\n    Narnar_is_at_the_start\n    Unnar_is_at_area_1\n    Narnar_has_A_attack_points_and_H_health_points\n    Unnar_is_at_area_2\n    Unnar_attack_points_are_A_and_H_attack_points\n    Unnar_is_at_area_3\n    Unnar_attack_points_are_A_and_H_attack_points\n    Unnar_is_at_area_1\n    Unnar_attack_points_are_A_and_H_attack_points\n    Unnar_has_no_health_points_and_is_at_area_n\n    Unnar_is_at_area_n\n    Unnar_has_A_attack_points_and_H_health_points\n    Unnar_attack_points_are_A_and_H_attack_points\n    Unnar_is_at_area_n\n    Unnar_attack_points_are_A_and_H_attack_points\n    Unnar_has_no_health_points_and_is_at_area_1\n    '''\n    A, H = map(int, stdin.split('\\n')[0].split())\n    n, m = map(int, stdin.split('\\n')[1].split())\n    # dict = {1: {}, 2: {}, 3: {}, 4: {}}\n    dict = {}\n    for i in range(m):\n        a, b, c, d = map(int, stdin.split('\\n')[i+2].split())\n        dict[a] = {b: [c, d]}\n\n    def helper(A, H, dict, visited):\n        if A < 1 or H < 1:\n            return False\n        if not visited:\n            if dict:\n                for area in dict:\n                    if dict[area]:\n                        if helper(A - dict[area][min(dict[area].keys())][0],\n                                   H - min(dict[area].values())[1],\n                                   dict,\n                                   visited + [area]):\n                            return True\n            return False\n        else:\n            if dict:\n                for area in dict:\n                    if area not in visited:\n                        if dict[area]:\n                            if helper(A - dict[area][min(dict[area].keys())][0],\n                                      H - min(dict[area].values())[1],\n                                      dict,\n                                      visited + [area]):\n                                return True\n            return False\n\n    helper(A, H, dict, [])\n\n    if helper(A, H, dict, []):\n        print('Oh no')\n    else:\n        print(max(H - min(dict[area][min(dict[area].keys())].values())[1]\n                  for area in dict if dict[area] and min(dict[area].keys()) > 1))\n"
    },
    {
        "number": 3121,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split())\n    # input: first line is a, h, second line is n, m, 3 lines m lines are A,B,C\n    n, m = map(int, stdin.split()[1:])\n    # n, m = 3, 2\n    # areas = [1, 2, 3]\n    # passages = [[1, 2, 1, 2], [2, 3, 1, 2]]\n    areas = set()\n    passages = []\n    for i in range(m):\n        # a, b, c, d = map(int, stdin.split()[i*3:i*3+4])\n        a, b, c, d = map(int, stdin.split()[i*4:i*4+4])\n        areas.add(a)\n        areas.add(b)\n        passages.append([a, b, c, d])\n\n    # Unnar starts in area 1\n    unnar = A, H\n    # areas = [1, 2, 3]\n    # passages = [[1, 2, 1, 2], [2, 3, 1, 2]]\n    areas = list(areas)\n    passages = [p for p in passages if p[0] == 1 and p[1] == n]\n\n    # Check if we can go from n to n\n    # ToDo: explore all possible options and choose the one with the lowest cost\n    # todo: write code to find the lowest cost to go to n\n    passage_options = [p for p in passages if p[0] == n and p[1] == n]\n    if len(passage_options) == 0:\n        return 'Oh no'\n    passage = passage_options[0]\n    cost = passage[2] * H + passage[3] * A\n    for passage in passage_options[1:]:\n        passage_cost = passage[2] * H + passage[3] * A\n        if passage_cost < cost:\n            cost = passage_cost\n            passage = passage\n    # Unnar moves to passage\n    # a, b, c, d = passage\n    a, b, c, d = passage\n    new_A = A - d\n    new_H = H - c\n    # check if we can go to areas\n    # todo: write code to find the lowest cost to go to areas\n    areas_options = [a for a in areas if a == b]\n    if len(areas_options) == 0:\n        return 'Oh no'\n    area = areas_options[0]\n    cost = new_A * new_H\n    for area in areas_options[1:]:\n        area_cost = new_A * new_H\n        if area_cost < cost:\n            cost = area_cost\n            area = area\n    # Unnar finishes in area\n    # todo: write code to find the lowest cost to go to finish\n    # Unnar in finish\n    # Unnar = (new_A, new_H)\n    new_A = A\n    new_H = H - d\n    # check if we can go to areas\n    areas_options = [a for a in areas if a == area]\n    if len(areas_options) == 0:\n        return 'Oh no'\n    area = areas_options[0]\n    cost = new_A * new_H\n    for area in areas_options[1:]:\n        area_cost = new_A * new_H\n        if area_cost < cost:\n            cost = area_cost\n            area = area\n    # Unnar finishes in area\n    return str(H - cost)"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num_airports, num_routes = map(int, stdin.split())\n    lounge_dict = {airport: {} for airport in range(1, num_airports+1)}\n\n    for _ in range(num_routes):\n        airport1, airport2, num_lounges = map(int, stdin.split())\n        if num_lounges == 0:\n            if (airport1 in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 not in lounge_dict):\n                lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport2].get(airport1):\n                    lounge_dict[airport2][airport1] += 1\n                else:\n                    lounge_dict[airport2][airport1] = 1\n            elif (airport1 in lounge_dict) and (airport2 not in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n        elif num_lounges == 1:\n            if (airport1 in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 not in lounge_dict):\n                lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport2].get(airport1):\n                    lounge_dict[airport2][airport1] += 1\n                else:\n                    lounge_dict[airport2][airport1] = 1\n            elif (airport1 in lounge_dict) and (airport2 not in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n        elif num_lounges == 2:\n            if (airport1 in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 not in lounge_dict):\n                lounge_dict[airport1][airport2] = 1\n            elif (airport1 not in lounge_dict) and (airport2 in lounge_dict):\n                if lounge_dict[airport2].get(airport1):\n                    lounge_dict[airport2][airport1] += 1\n                else:\n                    lounge_dict[airport2][airport1] = 1\n            elif (airport1 in lounge_dict) and (airport2 not in lounge_dict):\n                if lounge_dict[airport1].get(airport2):\n                    lounge_dict[airport1][airport2] += 1\n                else:\n                    lounge_dict[airport1][airport2] = 1\n\n    num_lounges = 0\n    for airport in lounge_dict.values():\n        for _, num_lounges in airport.items():\n            if num_lounges > 2:\n                return \"impossible\"\n            else:\n                num_lounges += num_lounges\n    return num_lounges\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pass\n\"\"\"\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('4 4\\\\n1 2 1\\\\n2 3 1\\\\n3 4 1\\\\n4 1 2\\\\n')\n    '3'\n    \"\"\"\n   ..."
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    l = [int(c) for c in stdin.split()]\n    n, m = l[0], l[1]\n    lounges = 0\n    for i in range(m):\n        l = [int(c) for c in stdin.split()]\n        a, b, c = l[0], l[1], l[2]\n        if a == b:\n            lounges += c\n        elif c == 1:\n            lounges += 1\n        else:\n            lounges += 1\n    print(lounges)\nsolution(input())"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_airports, num_routes = map(int, stdin.split('\\n')[0].split())\n    routes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    routes = sorted(routes, key=lambda x: x[2])\n    # print(routes)\n    airport = [0 for _ in range(num_airports + 1)]\n    lounge = [0 for _ in range(num_airports + 1)]\n    for route in routes:\n        airport[route[0]] += route[2]\n        airport[route[1]] += route[2]\n        lounge[route[0]] += route[2]\n        lounge[route[1]] += route[2]\n    # print(airport, lounge)\n    for i in range(1, len(lounge)):\n        lounge[i] += lounge[i - 1]\n    # print(airport, lounge)\n    def count(x):\n        cnt = 0\n        for route in routes:\n            if route[0] == x or route[1] == x:\n                cnt += route[2]\n        return cnt\n    lounge_count = 0\n    for i in range(1, len(lounge)):\n        if count(i) < num_routes or (lounge[i] < num_routes and (count(i) == num_routes or count(i) == num_routes - 1)):\n            return 'impossible'\n    for i in range(1, len(lounge)):\n        if lounge[i] >= num_routes:\n            lounge_count += 1\n    # print(lounge_count)\n    return str(lounge_count)"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    num_airports, num_routes = map(int, stdin.split())\n    num_airports = max(num_airports, 2)\n    num_routes = max(num_routes, 1)\n    lounge_requirement = {0: 0, 1: 0, 2: 0}\n    for route in range(num_routes):\n        airport_a, airport_b, num_lounges = map(int, stdin.split())\n        airport_a -= 1\n        airport_b -= 1\n        if num_lounges not in lounge_requirement:\n            lounge_requirement[num_lounges] = 0\n        lounge_requirement[num_lounges] += (\n            1 if (num_lounges == 2 and lounge_requirement[2] == 0 and (airport_a == 0 or airport_a == 1))\n            else 0)\n        lounge_requirement[num_lounges] += (\n            1 if (num_lounges == 2 and lounge_requirement[2] == 1 and (airport_b == 0 or airport_b == 1))\n            else 0)\n    for num_lounges, total_lounges in lounge_requirement.items():\n        if num_lounges > total_lounges:\n            return 'impossible'\n    return str(max(lounge_requirement.values()))\n"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets the minimum number of lounges necessary to satisfy Amanda's requirements.\n\n    Parameters\n    ----------\n    stdin : str\n        The input string.\n\n    Returns\n    -------\n    str\n        \"impossible\" if the requirements cannot be satisfied, or the minimum number of lounges necessary to satisfy the requirements.\n    \"\"\"\n\n    routes = []\n    airports = set()\n\n    for i, line in enumerate(stdin.splitlines()):\n        line = line.strip()\n        a, b, c = [int(j) for j in line.split(\" \")]\n        airports.add(a)\n        airports.add(b)\n        routes.append((a, b, c))\n\n    num_airports = len(airports)\n\n    # Create adjacency list for every airport\n    adj_list = [[] for _ in range(num_airports)]\n\n    for a, b, c in routes:\n        adj_list[a].append((b, c))\n        adj_list[b].append((a, c))\n\n    # Find all possible paths from 0 to all airports\n    paths = []\n    for _ in range(num_airports):\n        paths.append(find_all_paths(0, adj_list))\n\n    # Check that at least one of the paths contains both lounges\n    for path in paths:\n        if 2 in path:\n            return \"impossible\"\n\n    # Check if both 0 and n contain lounges\n    if 2 in [path.count(0) for path in paths]:\n        return \"impossible\"\n\n    # Check if both 1 and n contain lounges\n    if 2 in [path.count(1) for path in paths]:\n        return \"impossible\"\n\n    # Otherwise, there are two scenarios:\n    # 1. n contains both lounges\n    # 2. n contains only one lounges, and one or both of 0 and n do not contain lounges\n    # In the first case, we can build both at n, and in the second case we can build either at n or at one of the other airports\n    return str(sum(path.count(2) for path in paths) // 2)\n\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return None\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    \u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435:\n    \u041d\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0434\u0430\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n (1 <= n <= 100) \u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445.\n    \u041d\u0430 \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0441\u043d\u0430\u0447\u0430\u043b\u0430 \u0437\u0430\u0434\u0430\u0451\u0442\u0441\u044f \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043a\u043e\u043b\u043e\u043d\u043e\u043a (1 <= n <= 100), \u0437\u0430\u0442\u0435\u043c \u0437\u0430\u0434\u0430\u0451\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432 \u0441\u0442\u0440\u043e\u043a\u0438 n (1 <= n <= 100).\n    \u0421\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0435 n \u0441\u0442\u0440\u043e\u043a \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 \u0438\u0437 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445. \u041a\u0430\u0436\u0434\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u043e\u0434\u043d\u043e\u0433\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430, \u043f\u043e \u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u043a\u0443 \u043f\u0440\u0435\u043f\u0438\u043d\u0430\u043d\u0438\u044f \u0438 \u0437\u0430\u0442\u0435\u043c \u043e\u0434\u043d\u043e\u0433\u043e \u0438\u043b\u0438 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u0432, \u0437\u0430\u0442\u0435\u043c \u043f\u0440\u043e\u0431\u0435\u043b, \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 \u0438\u0437 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445.\n\n    \u0412\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435:\n    \u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 $k$ \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 \u0438\u0437 \u0431\u0430\u0437\u044b \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432 \u0432\u0438\u0434\u0435 \u043f\u0440\u044f\u043c\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u043e\u0439 \u0441\u0445\u0435\u043c\u044b. \u0415\u0441\u043b\u0438 \u0442\u0430\u043a\u043e\u0439 $k$ \u043d\u0435 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0438\u0442\u044c, \u0442\u043e \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \"no quotation\".\n\n    -----\u041f\u0440\u0438\u043c\u0435\u0440\u044b-----\n    >>> solution(\"2\\n2 3\")\n    2\n    >>> solution(\"3\\n1 1 1 1\")\n    1\n    >>> solution(\"1\\n22\")\n    4\n    >>> solution(\"1\\n2 2\")\n    2\n    >>> solution(\"1\\n4 4\")\n    2\n    >>> solution(\"1\\n10 10\")\n    4\n    >>> solution(\"2\\n6 6\")\n    4\n    >>> solution(\"2\\n7 7\")\n    4\n    >>> solution(\"2\\n8 8\")\n    3\n    >>> solution(\"3\\n9 9 9\")\n    3\n    >>> solution(\"3\\n5 5 5\")\n    3\n    >>> solution(\"3\\n5 6 5\")\n    4\n    >>> solution(\"3\\n5 7 5\")\n    4\n    >>> solution(\"3\\n5 8 5\")\n    5\n    >>> solution(\"3\\n5 9 5\")\n    5\n    >>> solution(\"3\\n5 10 5\")\n    5\n    >>> solution(\"4\\n5 5 5 5\")\n    5\n    >>> solution(\"4\\n6 6 6 6\")\n    6\n    >>> solution(\"5\\n7 7 7 7 7\")\n    7\n    >>> solution(\"5\\n8 8 8 8 8\")\n    8\n    >>> solution(\"5\\n9 9 9 9 9\")\n    9\n    >>> solution(\"6\\n10 10 10 10 10 10\")\n    10\n    >>> solution(\"7\\n11 11 11 11 11 11 11 11 11 11\")\n    11\n    >>> solution(\"8\\n12 12 12 12 12 12 12 12 12 12 12\")\n    12\n    >>> solution(\"9\\n13 13 13 13 13 13 13 13 13 13 13 13\")\n    13\n    >>> solution(\"10\\n14 14 14 14 14 14 14 14 14 14 14 14 14\")\n    14\n    >>> solution(\"11\\n15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *quotations = map(int, stdin.split('\\n'))\n    return max(2, sum(\n        q - 2\n        for q in 2 * quotations\n        if q > 2\n    ))\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # '2 1 1 1 3' -> '22' -> 2\n    # '22' -> 2\n    # '22' -> 2\n    # '22' -> 4\n    # '22' -> 4\n\n    # depth = [0]\n    # dp = [[False] * len(stdin)]\n    # ans = 0\n    # ans = dp[0]\n    # dp[0] = 0\n    # dp[0][0] = True\n    # for i in range(1, len(stdin)):\n    #     for j in range(len(stdin)):\n    #         if stdin[i] == '2':\n    #             dp[i] = max(depth[i], depth[i-1])\n    #             ans = max(ans, dp[i])\n    #             depth[i] = dp[i]\n    #             # depth[i-1] = dp[i-1]\n    #         else:\n    #             dp[i] = dp[i-1] + 1\n    #             depth[i] = dp[i]\n    #             ans = max(ans, dp[i])\n    #         # dp[i] = max(dp[i], dp[i-1])\n    #         # ans = max(ans, dp[i])\n    # print(ans)\n    # return ans\n    return stdin.replace('22', '4')\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin.readline())\n    inputs = stdin.readline().split()\n\n    def is_k_quotation(string):\n        return string[0] == '\"' and string[-1] == '\"' and len(string) >= 2 and '\"\"' not in string\n\n    def get_k(string):\n        counter = 0\n        for char in string:\n            if char == '\"':\n                counter += 1\n        return counter\n\n    max_k = 1\n    for input in inputs:\n        k = get_k(input)\n        if k > max_k:\n            max_k = k\n    if max_k == 1:\n        return 'no quotation'\n    return max_k\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    string = stdin.split()\n    string = [int(i) for i in string]\n    result = 0\n    for i in range(1, len(string)):\n        if i < (string[i] + 1):\n            result = max(result, i)\n    if result == 0:\n        return 'no quotation'\n    else:\n        return result\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the largest k that satisfies the given input.\"\"\"\n    n: int = int(stdin.readline())\n    values: list = [int(value) for value in stdin.readline().split(' ')]\n\n    k: int = 1\n    while True:\n        if len(values) == 0:\n            break\n        value: int = values.pop(0)\n        if value > k:\n            break\n        k += 1\n\n    return str(k) if k > 1 else \"no quotation\"\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().split()\n    k = 0\n    for i in s:\n        if k < int(i):\n            k = int(i)\n    return k\n"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"5\\n2 1 1 1 3\")\n    2\n    >>> solution(\"1\\n22\")\n    4\n    \"\"\"\n    str_list = stdin.split()\n    num_of_quote = int(str_list[0])\n    quote_list = str_list[1].split()\n    num_of_chars = [int(i) for i in quote_list]\n    \n    def solution(num_of_quote: int, num_of_chars: List[int]) -> int:\n        max_level = 0\n        for i in num_of_chars:\n            max_level = max(max_level, i // 2)\n        return max_level + 1\n\n    return str(solution(num_of_quote, num_of_chars))\n\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    total = stdin.split()\n    total = int(total[0])\n    string = stdin.split()\n    string = string[1:]\n    result = ''\n    for i in range(total):\n        if (i + 1) % 2 == 0:\n            result += str(string[i])\n            result +=''\n        else:\n            result += str(string[i])\n    print(result)"
    },
    {
        "number": 3123,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    n = int(stdin.readline().rstrip('\\n'))\n    A = [int(i) for i in stdin.readline().rstrip('\\n').split(' ')]\n    result = 0\n    for a in A:\n        if a > result:\n            result = a\n    print(result)\n    return ''\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = [int(x) for x in stdin.readline().split(' ')]\n    arr.sort()\n    counter = 0\n    for i in range(0, n):\n        if (i == 0 and (arr[i] % 2!= 0)) or (i > 0 and arr[i] == arr[i - 1] + 1):\n            counter += 1\n        if (i < n - 1 and arr[i]!= arr[i + 1] - 1) or (i == n - 1 and arr[i]!= arr[0] + 1):\n            break\n    return str(counter)\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    nums = [int(x) for x in stdin.split('\\n')[0].split()]\n    seen = set()\n    res = 0\n    for i in range(len(nums)):\n        if i not in seen:\n            if nums[i] % 2 == 1:\n                res += 1\n            seen.add(i)\n            tmp = nums[i]\n            while True:\n                if (tmp + 1) % 2 == 0:\n                    tmp += 1\n                    seen.add(tmp)\n                else:\n                    break\n            if (tmp + 2) in seen:\n                res += 1\n    return res\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    arr = [int(i) for i in stdin.readline().strip().split(' ')]\n    return str(len(set([i for i in arr if arr.count(i) % 2 == 1])))\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds how many different first moves Ivana can make, so that she has a chance of winning afterwards.\"\"\"\n    n = int(stdin.readline().strip())\n    numbers = sorted(map(int, stdin.readline().strip().split()))\n    possible = []\n    for i in range(n):\n        if i > 0:\n            if numbers[i - 1]!= numbers[i] and (numbers[i] % 2!= 0 or i == n - 1):\n                possible.append(numbers[i])\n    return str(len(possible))\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    nums = [int(num) for num in stdin.split(\"\\n\")[0].split()]\n    seen = set()\n    seen.add(nums[0])\n    for i in range(1, len(nums)):\n        while nums[i] in seen:\n            nums[i] = nums[i] + 1\n            if nums[i] > 1000:\n                nums[i] = nums[i] % 1000\n        seen.add(nums[i])\n    return str(len(seen))\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    n = int(s[0])\n    lst = [int(x) for x in s[1:]]\n    cnt = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if lst[i - 1] % 2 == 1:\n            odd += 1\n        if lst[i - 1] % 2 == 0 and lst[i - 1] > lst[(i - 1) % (n + 1)]:\n            cnt += 1\n    if odd == 0 or odd % 2 == 1:\n        print(cnt)\n    else:\n        print(cnt + 1)\n    return ''"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = [int(num) for num in stdin.split('\\n')[1].split(' ')]\n    res = 0\n    for num in numbers:\n        count = 1\n        while count < n:\n            if num % 2!= 0 and num + 1 in numbers:\n                count += 1\n                num = num + 1\n            else:\n                count += 1\n        res += 1\n    return res\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    numbers = [int(number) for number in stdin[1].split()]\n    d = {}\n    for i in range(0, n):\n        if numbers[i] not in d:\n            d[numbers[i]] = 0\n        if i == 0:\n            d[numbers[i]] = 1\n        else:\n            d[numbers[i]] = d[numbers[i - 1]] + 1\n        if i >= 1 and numbers[i] % 2 == 1 and numbers[i - 1] % 2 == 1:\n            d[numbers[i]] = d[numbers[i]] + 1\n    return str(d[numbers[n - 1]])\n"
    },
    {
        "number": 3124,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    return str(arr.index(1) + 1)\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stdout = stdin.split('\\n')\n\n    if stdin == '':\n        return '<empty> <any>'\n\n    if len(stdout)!= 2:\n        return 'corrupted'\n\n    stdout = [i.split() for i in stdout]\n\n    if len(stdout[0]) > 280 or len(stdout[1]) > 280:\n        return 'corrupted'\n\n    stdout = [list(i) for i in stdout]\n\n    for i in stdout[0]:\n        if i.isalpha() or i.isdigit() or i == '+' or i == '-':\n            pass\n        else:\n            return 'corrupted'\n\n    for i in stdout[1]:\n        if i.isalpha() or i.isdigit() or i == '+' or i == '-':\n            pass\n        else:\n            return 'corrupted'\n\n    stdout = [''.join(i) for i in stdout]\n\n    stdout = [i.replace('+', '\\+') for i in stdout]\n    stdout = [i.replace('-', '\\-') for i in stdout]\n\n    stdout = list(set(stdout))\n    stdout.sort()\n\n    return '\\n'.join(stdout)\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    TODO: Rename the function to be more descriptive, and clean up the code.\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    if s.replace('+', '').replace('-', '') == '':\n        return '<empty>'\n    else:\n        return'- '.join([f'{a}+{b}' for a, b in zip(s, s[1:]) if a == b])"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    A, B = stdin.split(\"\\n\")\n    A = A.replace(\"+\", \"&#x27;\")\n    B = B.replace(\"+\", \"&#x27;\")\n    A = A.replace(\"-\", \"&#x2d;\")\n    B = B.replace(\"-\", \"&#x2d;\")\n    ans = \"\"\n    if not A or not B:\n        ans = \"corrupted\"\n    else:\n        for i in range(len(A)):\n            if A[i]!= B[i]:\n                ans = A[:i] + B[i] + \" \" + ans\n                break\n        ans = ans.strip()\n        if not ans:\n            ans = \"any\"\n        else:\n            ans = ans.split(\" \")\n            ans[0] = ans[0].replace(\"&#x27;\", \"+\")\n            ans[1] = ans[1].replace(\"&#x2d;\", \"-\")\n    return ans\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the character encoding that Tweeper may use.\"\"\"\n    inputs = stdin.split('\\n')\n    encoding = 'unknown'\n    for i in range(len(inputs)):\n        for j in range(len(inputs[i])):\n            if inputs[i][j] not in '+-':\n                if j == len(inputs[i]) - 1:\n                    if encoding == 'unknown':\n                        encoding = 'any'\n                    else:\n                        encoding = encoding +'' + 'any'\n                elif inputs[i][j + 1] in '+-':\n                    if encoding == 'unknown':\n                        encoding = 'any'\n                    else:\n                        encoding = encoding +'' + 'any'\n                else:\n                    if encoding == 'unknown':\n                        encoding = 'corrupted'\n                    else:\n                        encoding = encoding +'' + 'corrupted'\n    return encoding\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n\"\"\"\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"a+b-c\\n\"\n   ...          \"a-b+d-c\")\n    '0-1-1\\n1-1-1'\n    >>> solution(\"a+b-c\\n\"\n   ...          \"a-b+d-c\")\n    '0-1-1\\n1-1-1'\n    >>> solution(\"a+b-c\\n\"\n   ...          \"a-b+d-c\")\n    '0-1-1\\n1-1-1'\n    \"\"\"\n    s = stdin.split(\"\\n\")\n    q = {k: v for v, k in enumerate(s[0])}\n    r = {k: v for v, k in enumerate(s[1])}\n\n    dp = [[[-1] * (len(q) + 1) for _ in range(len(r) + 1)] for _ in range(len(s) + 1)]\n    for k in range(len(q) + 1):\n        dp[0][k][k] = 0\n    for k in range(len(r) + 1):\n        dp[k][k][k] = 0\n\n    for i in range(1, len(s) + 1):\n        for j in range(1, len(q) + 1):\n            for k in range(1, len(r) + 1):\n                if s[i - 1][j - 1] == r[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1]\n                else:\n                    dp[i][j][k] = 1 + min(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    a, b = min(dp[-1][-1]), min(dp[-1][-2])\n    if a == len(q):\n        return \"<empty>\"\n    if b == len(r):\n        return \"<any>\"\n    return f\"{q[b]}-{r[a]}\\n{r[b]}-{q[a]}\"\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    I = stdin\n    O = input()\n    characters = \"abcdefghijklmnopqrstuvwxyz0123456789+-\"\n    result = \"\"\n    for i in range(len(O)):\n        if O[i] not in characters:\n            result += \"corrupted\" + \"\\n\"\n        elif i == 0:\n            result += \"empty\" + \"\\n\"\n        else:\n            if O[i] == \"+\":\n                for j in range(i):\n                    if O[i-j] == O[i-j-1]:\n                        result += result[i-j-1] + \"-\" + result[i-j-1] + \"-\"\n                        break\n            elif O[i] == \"-\":\n                for j in range(i):\n                    if O[i-j] == O[i-j-1]:\n                        result += result[i-j-1] + \"+\" + result[i-j-1] + \"+\"\n                        break\n    return result"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the best encoding.\"\"\"\n    char_str, code_str = stdin.split(\"\\n\")\n    for_a_plus, for_a_minus = [], []\n    for char in char_str:\n        for code in code_str:\n            if char == code:\n                if char == \"+\":\n                    for_a_plus.append(char + code)\n                    break\n                elif char == \"-\":\n                    for_a_minus.append(char + code)\n                    break\n            elif char == \"a\" and code == \"d\":\n                for_a_plus.append(char + code)\n                break\n            elif char == \"b\" and code == \"e\":\n                for_a_plus.append(char + code)\n                break\n            elif char == \"c\" and code == \"e\":\n                for_a_plus.append(char + code)\n                break\n            elif char == \"d\" and code == \"a\":\n                for_a_minus.append(char + code)\n                break\n            elif char == \"e\" and code == \"b\":\n                for_a_minus.append(char + code)\n                break\n            elif char == \"f\" and code == \"c\":\n                for_a_minus.append(char + code)\n                break\n    if len(for_a_plus) == 0:\n        for_a_plus.append(\"<empty>\")\n    if len(for_a_minus) == 0:\n        for_a_minus.append(\"<any>\")\n    if len(for_a_plus) > len(for_a_minus):\n        return for_a_plus[0]\n    elif len(for_a_minus) > len(for_a_plus):\n        return for_a_minus[0]\n    else:\n        return for_a_minus[0]\n"
    },
    {
        "number": 3125,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('a+b-c')\n    - +d-\n    >>> solution('a-b+d-c')\n    - +d-\n    >>> solution('a+b-c-d')\n    <empty>\n    >>> solution('a-b+d-c-e')\n    <any>\n    \"\"\"\n    split_stdin = stdin.split('\\n')\n    words = [word for word in split_stdin]\n    for i, word in enumerate(words):\n        if not word:\n            words.pop(i)\n    if not words:\n        return '<empty>'\n    for i in range(len(words)):\n        words[i] = words[i].replace('+', '-')\n        words[i] = words[i].replace('\\'', '+')\n        words[i] = words[i].replace('\\\"', '+')\n    words = sorted(set(words))\n    words = sorted(words, key=len)\n    ans = []\n    for word in words:\n        if word.count('+') == len(word):\n            ans.append('<any>')\n            continue\n        if word.count('+') < 1:\n            ans.append('<empty>')\n            continue\n        for i in range(len(word)):\n            if word[i] == '+' and (i == 0 or word[i - 1] == '+' or word[i - 1] == '-'):\n                ans.append(word[:i] + '-' + word[i + 1:])\n            elif word[i] == '+' and (i == len(word) - 1 or word[i + 1] == '+' or word[i + 1] == '-'):\n                ans.append(word[:i] + '+' + word[i + 1:])\n    return '\\n'.join(ans)\n\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the minimum number of jumps required to form a tower when the frog king adds and removes frogs\n    :param stdin: input for the problem\n    :return: output for the problem\n    \"\"\"\n\n    return None\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i: int, j: int, t: int, n: int) -> int:\n        if i == n:\n            return 0\n        elif t == 0:\n            return dfs(i + 1, j, 1, n)\n        elif j == n:\n            return dfs(i + 1, 0, t - 1, n)\n        else:\n            return min(dfs(i + 1, j, t - 1, n), dfs(i, j + 1, t - 1, n)) + 1\n    N, T, _ = map(int, stdin.split('\\n')[:3])\n    D = []\n    for _ in range(T):\n        D.append(map(int, stdin.split('\\n')[3:][_].split()))\n    return str(min([dfs(0, 0, t, N) for t in D]))"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split(' '))\n    frogs = [int(i) for i in stdin.split('\\n')[1:-1]]\n    n = len(frogs)\n    ans = 0\n\n    while True:\n        changed = False\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                if frogs[j] - frogs[i] == t:\n                    frogs[j], frogs[i] = frogs[i], frogs[j]\n                    changed = True\n                    break\n            if changed:\n                break\n        if not changed:\n            break\n\n        ans += 1\n        for i in range(n):\n            if frogs[i] + t < n:\n                frogs[i] += t\n                break\n            frogs[i] = 0\n            while frogs[i] == 0 and i < n - 1:\n                i += 1\n            if frogs[i] == 0:\n                break\n            frogs[i] -= t\n\n    return ans\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A typical line dance would look like:\n    1 1 2 2 1\n    The most efficient dance is:\n    1 2 2 1\n    The second most efficient dance is:\n    2 2 1 1\n    The third most efficient dance is:\n    3 2 1 1\n    The dance will always end in a single line:\n    1\n    \"\"\"\n    n, t = map(int, stdin.split())\n    positions = sorted(map(int, stdin.split()))\n\n    lowest = 9999\n    for c in stdin.split('\\n')[2:]:\n        if c[0] == '-':\n            positions.remove(int(c[2:]))\n            lowest = min(lowest, len(positions))\n        elif c[0] == '+':\n            positions.append(int(c[2:]))\n            lowest = min(lowest, len(positions))\n        else:\n            t = int(c[2:])\n            lowest = min(lowest, len(positions) - 1)\n    return lowest\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the total number of jumps after applying the modification.\n    \"\"\"\n\n    def min_jumps(n: int, pos: list[int]) -> int:\n        \"\"\"\n        Return the minimum number of jumps that makes the frog dance.\n        \"\"\"\n\n        memo: list[list[int]] = [[-1 for i in range(n + 1)] for j in range(n + 1)]\n        memo[0][0] = 0\n        for i in range(1, n + 1):\n            memo[i][0] = memo[i - 1][0] + 1\n\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i!= j:\n                    memo[i][j] = memo[i - 1][j] + 1\n                else:\n                    memo[i][j] = memo[i - 1][j - 1]\n\n        return memo[n][pos[-1]]\n\n    n, pos = [int(i) for i in stdin.split('\\n')[0].split(' ')]\n    modifications = [int(i) for i in stdin.split('\\n')[1:]]\n\n    return min_jumps(n, pos)\n\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution uses a greedy algorithm to iteratively improve the current solution,\n    computing the number of jumps for each possible solution.\n    The algorithm goes through each possible solution, from one of the initial frogs,\n    to the last possible frog, iteratively.\n    It starts by calculating the number of jumps required for this solution.\n    If the number of jumps exceeds the previous solution, it is not included in the final solution.\n    Otherwise, the number of jumps is compared to the current best solution.\n    If the number of jumps is lower than the current best solution, it is assigned to the current best solution.\n    The algorithm continues this way until no better solution is found.\n    \"\"\"\n    n, t = map(int, stdin.split())\n    frogs = [0]\n    for i in range(n):\n        frogs.append(int(stdin.split()[i+1]))\n    frogs.append(t)\n    i = 1\n    dance = 0\n    best = 0\n    while i < n+1:\n        dance += 1\n        j = i\n        while j < n+1 and frogs[j] == frogs[j+1]:\n            j += 1\n        dance += (j-i)//2\n        if j-i >= n:\n            best = dance\n        elif dance < best:\n            best = dance\n        i = j\n    return best"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split(\" \"))\n    frogs = [int(i) for i in stdin.split(\"\\n\")[1:-1]]\n    changes = int(stdin.split(\"\\n\")[-1])\n    dp = [[0]*(t+1) for _ in range(n+1)]\n    dp[0][0] = 0\n    for i in range(1, n+1):\n        dp[i][0] = dp[i-1][0] + 1\n        dp[i][frogs[i-1]] = dp[i-1][frogs[i-1]] + 1\n    for i in range(1, n+1):\n        for j in range(1, t+1):\n            dp[i][j] = min(dp[i][j-1] + 1, dp[i-1][j] + 1)\n            if j-1 > frogs[i-1]:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)\n    if changes > 0:\n        for i in range(1, changes+1):\n            if stdin.split(\"\\n\")[i][0] == '+':\n                frogs[int(stdin.split(\"\\n\")[i][1:])] += 1\n            elif stdin.split(\"\\n\")[i][0] == '-':\n                frogs[int(stdin.split(\"\\n\")[i][1:])] -= 1\n            elif stdin.split(\"\\n\")[i][0] == 't':\n                t = int(stdin.split(\"\\n\")[i][1:])\n    return str(dp[n][t])\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the minimum number of jumps to complete the tower dance.\"\"\"\n    # Extract the input\n    n, t = map(int, stdin.split('\\n')[0].split(' '))\n    positions = list(map(int, stdin.split('\\n')[1].split(' ')))\n    # Add the last position twice to avoid the loop condition at the end\n    positions.append(t)\n    positions.append(t)\n    changes = int(stdin.split('\\n')[2])\n\n    # Determine the length of each jump\n    lengths = [0]\n    for i in range(1, n + 1):\n        lengths.append(lengths[i - 1] + i)\n\n    # Apply each of the changes\n    for _ in range(changes):\n        action = stdin.split('\\n')[3 + _].split(' ')[0]\n        if action == 't':\n            # Swap the position of the tower\n            positions[1] = int(stdin.split('\\n')[3 + _].split(' ')[1])\n            positions[0] = int(stdin.split('\\n')[3 + _].split(' ')[1])\n        elif action == '+':\n            # Add a new frog\n            positions[n + 1] = int(stdin.split('\\n')[3 + _].split(' ')[1])\n        elif action == '-':\n            # Remove an existing frog\n            positions[int(stdin.split('\\n')[3 + _].split(' ')[1])] = 0\n\n    # Make a list with the distance of the current position from the beginning of the dance\n    dists = [abs(positions[i] - positions[i + 1]) for i in range(n)]\n    dists.append(0)\n\n    # Calculate the minimum number of jumps\n    min_num_jumps = float('inf')\n    for i in range(n):\n        min_num_jumps = min(min_num_jumps,\n                            dists[i] + lengths[i] + dists[i + 1])\n\n    return min_num_jumps\n"
    },
    {
        "number": 3126,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, t = stdin.split(' ')\n    n, t = int(n), int(t)\n    pos = [int(i) for i in stdin.split('\\n')[1].split(' ') if i!= '']\n    c = int(stdin.split('\\n')[2])\n    ans = float('inf')\n    for i in range(c):\n        if stdin.split('\\n')[i + 3] == '+':\n            n += 1\n        elif stdin.split('\\n')[i + 3] == '-':\n            n -= 1\n        elif stdin.split('\\n')[i + 3] == 't':\n            if t < len(pos):\n                t = pos[t]\n            else:\n                t = t + 1\n                pos = pos + [t]\n    print(ans)\n    return ans\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    edges = []\n    for _ in range(m):\n        u, v, l = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n        edges.append((u, v, l))\n    edges = list(sorted(edges))\n    unused_switch_indices = []\n    unused_switch_count = 0\n    used_edges = set()\n    for u, v, l in edges:\n        if u in used_edges or v in used_edges:\n            continue\n        elif u in unused_switch_indices or v in unused_switch_indices:\n            unused_switch_count += 1\n            continue\n        used_edges.add(u)\n        used_edges.add(v)\n    return str(unused_switch_count) + '\\n' +''.join(str(x) for x in unused_switch_indices)\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    # Time: O(n^2)\n    # Space: O(n^2)\n    # n = int(stdin[0])\n    # m = int(stdin[1])\n    # pairs = {}\n    # for line in stdin[2:]:\n    #     line = line.split()\n    #     pairs[line[0]] = pairs.get(line[0], set())\n    #     pairs[line[0]].add(line[1])\n    #     pairs[line[1]] = pairs.get(line[1], set())\n    #     pairs[line[1]].add(line[0])\n    # paths = {i: {i} for i in range(1, n+1)}\n    # for start in range(1, n+1):\n    #     for end in range(1, n+1):\n    #         if start!= end and start in pairs and end in pairs[start]:\n    #             continue\n    #         paths[start].add(end)\n    #                 \n    # # Eagerly compute (number of paths from i to j) for each i\n    # num_paths = {i: 0 for i in range(1, n+1)}\n    # for i in range(1, n+1):\n    #     for j in range(1, n+1):\n    #         num_paths[i] += len(paths[j])\n    #\n    # # Greedily remove paths that can never be part of an optimal path\n    # result = set()\n    # for i in range(1, n+1):\n    #     if num_paths[i] == m:\n    #         result.add(i)\n    #         for j in range(1, n+1):\n    #             if i in paths[j]:\n    #                 paths[j].remove(i)\n    #\n    # # Recursively compute result\n    # for i in range(1, n+1):\n    #     if num_paths[i] < m:\n    #         result.update(solution(str(i) + \"\\n\" + str(m - num_paths[i])))\n    #\n    # result = sorted(result)\n    # return \"\\n\".join(result)\n    \n    n, m = map(int, stdin.split())\n    cables = []\n    for i in range(m):\n        cable = list(map(int, stdin.split()))\n        cables.append(cable)\n    \n    # Build the graph\n    graph = {}\n    for i in range(1, n+1):\n        graph[i] = set()\n    for cable in cables:\n        graph[cable[0]].add(cable[1])\n    \n    # Build the 'out' graph\n    out = {}\n    for i in range(1, n+1):\n        out[i] = set()\n    for key in graph:\n        for value in graph[key]:\n            out[value].add(key)\n    \n    # Find the in-degree of each node\n    indeg = {i: len(graph[i]) for i in range(1, n+1)}\n    \n    # Find the node with the minimum in-degree\n    min_indeg = min(indeg.values())\n    \n    # Find the nodes with the minimum in-degree\n    result = []\n    for node in out:\n        if indeg[node] == min_indeg:\n            result.append(node)\n            for neighbour in out[node]:\n                indeg[neighbour] -= 1\n    \n    # Check if we can have an optimal path\n    for node in result:\n        if len(graph[node]) < indeg[node]:\n            result.remove(node)\n    \n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cables = [[int(x) for x in stdin.split()] for _ in range(m)]\n    \n    # O(n)\n    connections = [set() for _ in range(n)]\n    for a, b, l in cables:\n        connections[a - 1].add(b - 1)\n        connections[b - 1].add(a - 1)\n    \n    # O(n^2)\n    # n = 100\n    # m = 100\n    # cables = [[1, 2, 1], [1, 3, 1], [1, 4, 1], [2, 6, 1], [2, 7, 2], [3, 5, 1], [4, 7, 2], [5, 7, 1], [6, 8, 1], [7, 8, 1]]\n    # connections = [[0, 1, 2, 2], [1, 2, 3], [2, 3, 1], [2, 4, 1], [3, 4, 1], [4, 5, 1], [4, 6, 1], [5, 6, 2], [5, 7, 2], [6, 7, 2], [6, 8, 2], [7, 8, 2]]\n    \n    # O(n)\n    # paths = [{1, 2, 3, 4, 5, 6, 7, 8}, {1, 2, 3, 4, 5, 6, 7, 8}]\n    # for i in range(1, n):\n    #     paths.append({j for j in range(1, n + 1) if i!= j and j in connections[i]})\n    \n    # O(n)\n    # paths = [{1, 2, 3, 4, 5, 6, 7, 8}]\n    # for i in range(1, n):\n    #     paths.append(set(j for j in range(1, n + 1) if i!= j and j in connections[i]))\n    \n    # O(n^2)\n    # n = 100\n    # m = 100\n    # cables = [[1, 2, 1], [1, 3, 1], [1, 4, 1], [2, 6, 1], [2, 7, 2], [3, 5, 1], [4, 7, 2], [5, 7, 1], [6, 8, 1], [7, 8, 1]]\n    # connections = [[0, 1, 2, 2], [1, 2, 3], [2, 3, 1], [2, 4, 1], [3, 4, 1], [4, 5, 1], [4, 6, 1], [5, 6, 2], [5, 7, 2], [6, 7, 2], [6, 8, 2], [7, 8, 2]]\n    \n    # O(n^3)\n    # n = 10\n    # m = 10\n    # cables = [[1, 2, 3], [2, 3, 2], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    # connections = [[0, 1, 2, 2], [0, 1, 2, 2], [1, 2, 3], [2, 3, 3], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    \n    # O(n^3)\n    # n = 10\n    # m = 10\n    # cables = [[1, 2, 3], [2, 3, 2], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    # connections = [[0, 1, 2, 2], [0, 1, 2, 2], [1, 2, 3], [2, 3, 3], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    \n    # O(n^3)\n    # n = 10\n    # m = 10\n    # cables = [[1, 2, 3], [2, 3, 2], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    # connections = [[0, 1, 2, 2], [0, 1, 2, 2], [1, 2, 3], [2, 3, 3], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    \n    # O(n^3)\n    # n = 10\n    # m = 10\n    # cables = [[1, 2, 3], [2, 3, 2], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    # connections = [[0, 1, 2, 2], [0, 1, 2, 2], [1, 2, 3], [2, 3, 3], [3, 4, 3], [4, 5, 3], [5, 6, 3], [6, 7, 1], [7, 8, 2], [8, 9, 1]]\n    \n    # O(n^3)\n    # n = 10\n    # m = 10\n    # cables = [[1, 2, 3], [2, 3, 2"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(\" \")]\n    matrix = [[int(x) for x in stdin.split(\" \")] for _ in range(m)]\n    graph = {}\n\n    for i in range(m):\n        if matrix[i][0] not in graph:\n            graph[matrix[i][0]] = []\n        if matrix[i][1] not in graph:\n            graph[matrix[i][1]] = []\n        graph[matrix[i][0]].append(matrix[i][1])\n        graph[matrix[i][1]].append(matrix[i][0])\n    for i in range(n):\n        if i+1 not in graph:\n            graph[i+1] = []\n    graph[0] = [n+1]\n    graph[n+1] = [0]\n    stack = [0]\n    visited = set()\n    cnt = 0\n    while stack:\n        node = stack.pop()\n        if node not in visited:\n            visited.add(node)\n            if node in graph:\n                stack += graph[node]\n            else:\n                stack += graph[0]\n            cnt += 1\n    return str(cnt-1) + '\\n' +''.join([str(x) for x in sorted([x for x in visited if x!= 0 and x!= n+1])])\n    # return str(cnt-1) + '\\n' +''.join([str(x) for x in sorted([x for x in visited if x!= 0 and x!= n+1])])\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(src: int, dst: int) -> int:\n        # noqa: E741\n        return int(math.ceil(cable_length[src - 1][dst - 1] / v))\n\n    def dfs(source: int, visited: set[int]) -> None:\n        if source in visited:\n            return\n        visited.add(source)\n        for dst, length in adj_matrix[source]:\n            if dst in visited:\n                continue\n            dfs(dst, visited)\n            used_cables.append((source, dst, length))\n\n    n, m = map(int, stdin.split())\n    adj_matrix = [[] for _ in range(n + 1)]\n    cable_length = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, length = map(int, stdin.split())\n        adj_matrix[a].append((b, length))\n        adj_matrix[b].append((a, length))\n        cable_length[a - 1].append(length)\n        cable_length[b - 1].append(length)\n    v, c = map(float, stdin.split())\n    cable_length = [sorted(list(set(lengths))) for lengths in cable_length]\n    # get used_cables\n    used_cables = []\n    dfs(1, set())\n    # create graph and find unused_switches\n    graph = [[] for _ in range(n + 1)]\n    for src, dst, length in used_cables:\n        graph[src].append((dst, length))\n        graph[dst].append((src, length))\n    unused_switches = set()\n    for i in range(n, 0, -1):\n        if i not in used_switches:\n            unused_switches.add(i)\n    print(len(unused_switches))\n    print(' '.join(map(str, unused_switches)))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    \n    n, m = map(int, lines[0].split())\n    graph = [set() for _ in range(n)]\n    \n    for line in lines[1:]:\n        a, b, l = map(int, line.split())\n        graph[a - 1].add((b - 1, l))\n        graph[b - 1].add((a - 1, l))\n    \n    unused = set()\n    visited = set()\n    \n    def dfs(start: int, length: int):\n        visited.add(start)\n        for neighbour in graph[start]:\n            if neighbour[0] not in visited:\n                dfs(neighbour[0], length + neighbour[1])\n        unused.update(visited)\n    \n    for i in range(n):\n        if i not in visited:\n            dfs(i, 0)\n    \n    return str(len(unused)) + '\\n' +''.join(map(str, sorted(unused)))\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns a list of the indices of the switches that could never be part\n    of an optimal path when a packet is transmitted from switch 1 to switch n\n    when the lengths of the cables and the speed of the cables are unknown.\n\n    >>> solution(\"7 8\\\\n1 2 2\\\\n1 3 1\\\\n1 4 3\\\\n2 6 1\\\\n2 7 2\\\\n3 5 1\\\\n4 7 2\\\\n5 7 1\")\n    '2\\\\n4 6\\\\n'\n    >>> solution(\"5 6\\\\n1 2 2\\\\n2 3 2\\\\n3 5 2\\\\n1 4 3\\\\n4 5 3\\\\n1 5 6\")\n    '0\\\\n'\n    \"\"\"\n\n    n, m = map(int, stdin.split())\n    cables = [tuple(map(int, line.split())) for line in stdin.split(\"\\\\n\")[:-1]]\n\n    # For each pair of switches, find the minimum cost of transferring a\n    # packet from the first to the second, and store that value in a\n    # dictionary. If the cost is nonzero, that pair is not eligible to be\n    # included in the result.\n    cables_set = set()\n    cables_dict = {pair: None for pair in combinations(range(1, n + 1), 2)}\n    for a, b, l in cables:\n        cables_set.add(frozenset((a, b)))\n        if cables_dict[a, b] is None:\n            cables_dict[a, b] = l\n        else:\n            cables_dict[a, b] = min(cables_dict[a, b], l)\n    # For each pair of switches, find the maximum cost of transferring a\n    # packet from the first to the second.\n    cables_length = {pair: None for pair in combinations(range(1, n + 1), 2)}\n    for a, b in cables_set:\n        cables_length[a, b] = max(cables_dict.values())\n\n    # Return the number of switches whose maximum cost of transferring a packet\n    # is nonzero.\n    return str(sum(1 for l in cables_length.values() if l)) + \"\\\\n\" + \" \".join(\n        str(i) for i in range(1, n + 1) if cables_length[1, i] == 0\n    )\n"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    n, m = map(int, stdin.split())\n    cables = {\n        (start, end): cable_length\n        for start, end, cable_length in (\n            *[tuple(map(int, line.split())) for line in stdin.split('\\n')],\n        )\n    }\n    cable_lengths = {\n        (start, end): cable_length\n        for start, end, cable_length in (\n            *[tuple(map(int, line.split())) for line in stdin.split('\\n')],\n        )\n    }\n    res = []\n\n    for start in range(1, n + 1):\n        for end in range(1, n + 1):\n            if end!= start:\n                res.append((start, end))\n    print(res)\n    return ''\n\nprint(solution('7 8\\n1 2 2\\n1 3 1\\n1 4 3\\n2 6 1\\n2 7 2\\n3 5 1\\n4 7 2\\n5 7 1\\n'))\n\ndef"
    },
    {
        "number": 3127,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"O(1) Time / O(1) Space\n    \"\"\"\n    _, _, *l = [list(map(int, x.split())) for x in stdin.split('\\n')]\n    s, e = set(), set()\n    for i, j, k in l:\n        if i in s or j in e:\n            continue\n        s.add(i)\n        e.add(j)\n    return''.join(str(i) for i in list(s.difference(e)))\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time: O(log n)\n    Space: O(1)\n    \"\"\"\n    n, q = stdin.split(\"\\n\")\n    n = int(n)\n    q = int(q)\n\n    create = [0] * (n + 1)\n    plot = [0] * (n + 1)\n\n    create[1] = 1\n    plot[1] = 1\n\n    for i in range(2, n + 1):\n        plot[i] = plot[i - 1] + 1\n\n    for _ in range(q):\n        line = stdin.split(\"\\n\")[0]\n        q, x = line.split()\n        if q == 1:\n            create[plot[int(x)]] += 1\n        else:\n            print(plot[int(x)] + 1)\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    number_of_queries = int(stdin.readline())\n    # {num_plot_order: num_creation}\n    creation_order = dict()\n    # {num_creation: num_plot_order}\n    plot_order = dict()\n    max_plot_order = 1\n    for _ in range(number_of_queries):\n        query = stdin.readline().split()\n        if query[0] == \"1\":\n            creation_order[int(query[1])] = max_plot_order\n            plot_order[max_plot_order] = int(query[1])\n            max_plot_order += 1\n        elif query[0] == \"2\":\n            print(plot_order[int(query[1])])\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n\n    for line in lines:\n        if line == '':\n            continue\n\n        query = line.split()\n\n        if query[0] == '1':\n            print(int(query[1]))\n\n        if query[0] == '2':\n            print(int(query[1]))\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''12\n   ... 1 1\n   ... 1 2\n   ... 1 3\n   ... 1 1\n   ... 1 2\n   ... 1 3\n   ... 2 1\n   ... 2 2\n   ... 2 3\n   ... 2 4\n   ... 2 5\n   ... 2 6\n   ... ''')\n    '4\n    '5\n    '6\n    '1'\n    '2'\n    '3'\n\n    >>> solution('''6\n   ... 1 1\n   ... 1 2\n   ... 1 3\n   ... 2 1\n   ... 2 2\n   ... 2 3\n   ... ''')\n    '1'\n    '2'\n    '3'\n    \"\"\"\n    total_number_of_movies = int(stdin.split('\\n')[0])\n\n    created_in_order = dict()\n    for _ in range(total_number_of_movies):\n        query_string = stdin.split('\\n')[_]\n        query_type = int(query_string[0])\n        x = int(query_string[2])\n        if query_type == 1:\n            created_in_order[x] = max(created_in_order.get(x, 0), x)\n        elif query_type == 2:\n            y = created_in_order.get(x, 0)\n            print(y + 1)\n    return ''\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    for i in range(N):\n        if i == 0:\n            x = int(stdin)\n            print(1)\n        else:\n            x = int(stdin)\n            z = (x - 1) * 2\n            print(z)\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the creation index of the movie with plot index 1.\n\n    Args:\n        stdin (str): Input from stdin\n\n    Returns:\n        str: Output to stdout\n    \"\"\"\n    # Get number of queries\n    num_queries: int = int(stdin.readline())\n\n    # Create dict for creation order and dict for plot order\n    creation_order: dict = {}\n    plot_order: dict = {}\n\n    # Fill the creation order dict\n    for i in range(1, num_queries + 1):\n        query: tuple = stdin.readline().rstrip().split(\" \")\n        if int(query[0]) == 1:\n            creation_order[int(query[1])] = int(query[2])\n        else:\n            plot_order[int(query[1])] = int(query[2])\n\n    # Create list of numbers from creation order and plot order\n    numbers: list = list(creation_order.values())\n    numbers.extend(list(plot_order.values()))\n\n    # Sort the list of numbers\n    numbers.sort()\n\n    # Iterate through the numbers and find the difference between the last two\n    for i in range(len(numbers) - 1):\n        if i % 2 == 0:\n            print(numbers[i + 1] - numbers[i])\n\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    \n    return \"\"\n"
    },
    {
        "number": 3128,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the movie index for each query in the input.\n\n    Args:\n        stdin (str): The input to be parsed.\n\n    Returns:\n        str: The output as a string.\n    \"\"\"\n    # Declare a dictionary.\n    dictionary = {}\n\n    # Get the number of queries.\n    q = int(stdin.split('\\n')[0])\n\n    # Iterate through each query.\n    for _ in range(q):\n        # Split the input into a query type and a movie index.\n        q, m = stdin.split('\\n')[1].split(' ')\n\n        # If the query type is 1 then it means we need to find the creation index of a movie.\n        if q == '1':\n            # If the movie index exists in the dictionary then return it.\n            if m in dictionary:\n                print(dictionary[m])\n\n            # Otherwise, find the index of the movie and add it to the dictionary.\n            else:\n                print(len(dictionary) + 1)\n\n        # Otherwise we want to find the creation index of the movie with the given index.\n        else:\n            # Add the movie to the dictionary and also add its creation index.\n            dictionary[m] = len(dictionary) + 1\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    while True:\n        for i in range(len(stdin)-2):\n            if stdin[i] == stdin[i+1] == stdin[i+2] == 'P':\n                count += 1\n                stdin = stdin[:i]+'C'+stdin[i+1:]\n    return count\n                \n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    return ''"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return 'a'"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = list(stdin)\n    count = 0\n    while stdin:\n        if len(stdin) < 3:\n            return count\n        if stdin[0] == stdin[2]:\n            stdin.pop(0)\n            stdin.pop(0)\n            stdin.pop(0)\n            count += 1\n        else:\n            stdin.pop(0)\n            stdin.pop(0)\n            stdin.insert(0, stdin.pop(0))\n            count += 1\n    return count"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return ''"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    if len(stdin) <= 1:\n        return str(count)\n    elif stdin[0]!= stdin[1]:\n        count += 1\n    for i in range(len(stdin) - 1):\n        if stdin[i]!= stdin[i + 1]:\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return str(stdin.count('P'))\n  \n"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    length = len(stdin)\n    count = 0\n    for i in range(length):\n        if i < (length - 1):\n            if stdin[i] == \"C\" and stdin[i + 1] == \"P\":\n                stdin = stdin[:i] + \"P\" + stdin[i + 2:]\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3129,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    if stdin.count('C') + stdin.count('P') == 0:\n        return '0'\n    n = len(stdin)\n    pos = stdin.find('C', 0)\n    while pos > 0:\n        if pos + 2 < n and stdin[pos+2] == 'P':\n            stdin = stdin[:pos] + stdin[pos+3:]\n        else:\n            stdin = stdin[:pos] + stdin[pos+1:]\n        pos = stdin.find('C', 0)\n    return str(stdin.count('P'))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, m, n = map(int, stdin.split())\n    implications = [map(int, line.split()) for line in stdin.strip().split('\\n')[1:m+1]]\n    known = [int(line) for line in stdin.strip().split('\\n')[-n:] if int(line) <= d]\n    print(' '.join([str(e) for e in sorted(set(known))]))"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 2 1\n   ... 1 2\n   ... 2 3\n   ... 2\n   ... 3''')\n    '1 2 3'\n    \"\"\"\n    # prepare data\n    n = int(stdin.splitlines()[0].split(\" \")[0])\n    m = int(stdin.splitlines()[0].split(\" \")[1])\n    implications = [tuple(map(int, line.split(\" \")[0:2])) for line in stdin.splitlines()[1:m + 1]]\n    events = [int(line.split(\" \")[0]) for line in stdin.splitlines()[m + 1:]]\n    # find all event causes\n    event_causes = set()\n    event_causes.add(1)\n    event_causes.update(set(events))\n    for a, b in implications:\n        if b in event_causes:\n            event_causes.add(a)\n        if a in event_causes:\n            event_causes.add(b)\n    event_causes.discard(1)\n    # find events that are certain\n    certain_events = set()\n    for i in event_causes:\n        if i not in events:\n            continue\n        for j in event_causes:\n            if i == j:\n                continue\n            if i in events and j in events and i < j:\n                certain_events.add(i)\n                break\n    return \" \".join(map(str, certain_events))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    dic = defaultdict(list)\n    for i in range(0, int(stdin.split('\\n')[0].split(' ')[2])):\n        dic[int(stdin.split('\\n')[i * 2 + 1].split(' ')[0])].append(int(stdin.split('\\n')[i * 2 + 1].split(' ')[1]))\n    imp = []\n    for i in range(0, int(stdin.split('\\n')[2])):\n        imp.append(int(stdin.split('\\n')[i * 2 + 3]))\n    out = []\n    for i in imp:\n        for j in dic[i]:\n            if j not in out:\n                out.append(j)\n    return '\\n'.join(map(str, out))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find all events that have certainly occurred from a knowledge base.\"\"\"\n    D, M, N = [int(s) for s in stdin.split('\\n')[:3]]\n    out = []\n    for _ in range(N):\n        a, b = [int(s) for s in stdin.split('\\n')[3 + _].split(' ')]\n        if a == 1:\n            out.append(b)\n    out = sorted(out)\n    return '\\n'.join(out)"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, D = map(int, stdin.split())\n    events = {}\n\n    for i in range(1, N + 1):\n        events[i] = set()\n\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        events[A].add(B)\n\n    for _ in range(D):\n        X = int(stdin.strip())\n        for a in events.keys():\n            if X in events[a]:\n                events[a].add(X)\n\n    return \" \".join(map(str, sorted(events[1])))"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_all_possible_causes_for_event(event, known_causes: set):\n        if event in known_causes:\n            return set([event])\n        result = set()\n        for c in known_causes:\n            if event in get_all_possible_causes_for_event(c, known_causes):\n                result.add(c)\n        return result\n\n    events, implications, events_known = stdin.split('\\n')[:3]\n    for i in range(1, int(events) + 1):\n        implications = implications.replace(str(i), str(i) + '\\n')\n    events = set(map(int, events.split(' ')))\n    for i in range(int(events_known)):\n        events.add(int(stdin.split('\\n')[i + 1]))\n    event_to_causes = dict()\n    for i in implications.split('\\n'):\n        event_to_causes[int(i.split(' ')[0])] = set(map(int, i.split(' ')[1:]))\n    all_events = set()\n    for e in events:\n        all_events = all_events.union(get_all_possible_causes_for_event(e, events))\n    all_events = all_events.union(events)\n    for e in events:\n        all_events = all_events.union(get_all_possible_causes_for_event(e, event_to_causes.get(e, set())))\n    print(*sorted(all_events))\n    return ''\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num_of_events, num_of_imp, num_of_events_known = map(int, stdin.split())\n    imp_list = list()\n    event_list = list()\n    imp_dict = dict()\n    for i in range(num_of_imp):\n        imp_list.append(tuple(map(int, stdin.split())))\n    for i in range(num_of_events):\n        event_list.append(int(stdin))\n    for i in range(num_of_imp):\n        if imp_list[i][0] in imp_dict:\n            imp_dict[imp_list[i][0]] = imp_dict[imp_list[i][0]] + [imp_list[i][1]]\n        else:\n            imp_dict[imp_list[i][0]] = [imp_list[i][1]]\n    imp_list = list(imp_dict.keys())\n    imp_list.sort()\n    if len(imp_list)!= 0:\n        print(imp_list[0])\n    else:\n        print(\"No event\")\n    return \"\"\n\nprint(solution(stdin))\n\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    events = {int(line.split()[0]): set() for line in stdin.split(\"\\n\")}\n\n    for line in stdin.split(\"\\n\")[3:]:\n        events[int(line.split()[0])].add(int(line.split()[1]))\n\n    c = {i: [] for i in events.keys()}\n\n    for j in events.keys():\n        for k in events.keys():\n            if j!= k and j in events[k]:\n                c[j].append(k)\n\n    seen = set()\n    q = [1]\n    while q:\n        x = q.pop(0)\n        seen.add(x)\n        for i in c[x]:\n            if i not in seen:\n                q.append(i)\n\n    return \" \".join(map(str, seen))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(textwrap.dedent('''\\\n   ... 3 2 1\n   ... 1 3\n   ... 2 3\n   ... 3\n   ... '''))\n    '3'\n    \"\"\"\n    n, m, d = map(int, stdin.split())\n    imp = [list(map(int, i.split())) for i in stdin.strip().splitlines()[3:]][:d]\n    e = set()\n    for i in imp:\n        if i[0] not in e:\n            e.add(i[0])\n            e.add(i[1])\n    return''.join(map(str, sorted(list(e))))\n"
    },
    {
        "number": 3130,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    #\n    # Write your code below; return type and arguments should be according to the problem's requirements.\n    #\n    definitions = {}\n    for i in range(int(stdin.split()[0])):\n        definitions[int(stdin.split()[i * 2 + 1])] = set([int(stdin.split()[i * 2 + 2])])\n    for i in range(int(stdin.split()[4])):\n        definitions[int(stdin.split()[i * 2 + 5])].add(int(stdin.split()[i * 2 + 6]))\n    print(definitions)\n    event = set()\n    for i in range(int(stdin.split()[3])):\n        if definitions.get(int(stdin.split()[i * 2 + 3])) is not None:\n            event.update(definitions.get(int(stdin.split()[i * 2 + 3])))\n    event = sorted(event)\n    print(event)\n    return event"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Solution begins here:\n    n, k = [int(x) for x in stdin.split()]\n    values = [int(x) for x in stdin.split()]\n    for i in range(k, len(values)):\n        values[i] %= 1000000007\n    print(sum(values) % 1000000007)\n    return \"\""
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    N, K = map(int, stdin.readline().split())\n    lst = list(map(int, stdin.readline().split()))\n\n    total = sum(lst)\n    return total % 1000000007\n    '''\n    n, k = map(int, stdin.readline().split())\n    lst = map(int, stdin.readline().split())\n    total = sum(lst)\n\n    res = 1\n    for key in sorted(set(lst), reverse=True)[:k]:\n        res = (res * key) % 1000000007\n    return res % 1000000007\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # get n and k\n    n, k = stdin.split('\\n')[0].split()\n    n, k = int(n), int(k)\n\n    # get a\n    a = stdin.split('\\n')[1].split()\n    a = [int(i) for i in a]\n\n    # find max value in a\n    a_max = 0\n    for i in a:\n        if i > a_max:\n            a_max = i\n\n    # find nums which we need to find\n    nums = []\n    for i in range(k):\n        nums.append(a_max)\n    nums = sorted(nums)\n\n    # get remain\n    rem = 0\n    for i in range(n):\n        rem += nums[i] % 1000000007\n\n    print(rem)\n\n    return ''\n\n\ndef"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass\n    return ''.join(map(str, [1, 2, 4]))\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    _, k = stdin.split(' ')\n    numbers = stdin.split(' ')\n    numbers = list(map(int, numbers))\n    k = int(k)\n    numbers.sort()\n    numbers.reverse()\n    print(numbers)\n    return(numbers[k-1])"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the required number from the task.\"\"\"\n    n, k = map(int, stdin.split())\n    values = map(int, stdin.split())\n    total = 0\n    max_value = max(values)\n    for key in range(n):\n        for value in range(n):\n            if key + value == k and values[key] * values[value] % 10000000007 == max_value:\n                total += values[key] * values[value]\n    return str(total)\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n, k = map(int, stdin.split(\" \"))\n    a = list(map(int, stdin.split(\" \")))\n    ans = 0\n    for i in range(n):\n        ans = ans + (a[i] * (k**i))\n    return str(ans % 1000000007)\n\nprint(solution(input()))\n"
    },
    {
        "number": 3131,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def helper(K: int, A: List[int]) -> int:\n        if not K:\n            return 0\n        else:\n            s = set()\n            n = len(A)\n            for i in range(n - K + 1):\n                s.add(sum(A[i:i + K]))\n            return max(s) % 1000000007\n\n    return str(helper(K, A))"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row, col = stdin.split('\\n')[0].split()\n    row, col = int(row), int(col)\n    # row_col = input().split()\n    # row, col = int(row_col[0]), int(row_col[1])\n    array = [list(i) for i in stdin.split('\\n')[1:]]\n    # array = [input().split() for _ in range(row)]\n    # print(array)\n    # print(row, col)\n    row_solution, col_solution = [], []\n    for r in range(row):\n        for c in range(col):\n            # print(array[r][c])\n            if array[r][c] == 'x':\n                row_solution.append(r+1)\n                col_solution.append(c+1)\n    # print(row_solution, col_solution)\n    print(' '.join(map(str, row_solution)))\n    print(' '.join(map(str, col_solution)))\n    # row_solution, col_solution = [], []\n    # for i in range(row):\n    #     for j in range(col):\n    #         if array[i][j] == 'x':\n    #             row_solution.append(i+1)\n    #             col_solution.append(j+1)\n    # print(row_solution, col_solution)"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(x) for x in stdin.split()]\n    \n    # build the grid\n    grid = [list(stdin.split()[1:]) for _ in range(R)]\n    \n    # declare some variables\n    row = 0\n    col = 0\n    min_row = R\n    min_col = C\n    max_row = 0\n    max_col = 0\n    # find the coordinates of the first building\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'x':\n                row = r\n                col = c\n                min_row = min(min_row, r)\n                min_col = min(min_col, c)\n                max_row = max(max_row, r)\n                max_col = max(max_col, c)\n                break\n    # first building is unique\n    return str(row) +'' + str(col) +'' + str(max_row - min_row + 1) +'' + str(max_col - min_col + 1)\n    "
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate x, y, l of the two buildings.\n    \"\"\"\n    r, c = map(int, stdin.split(' '))\n    l = []\n    for _ in range(r):\n        line = stdin.split('\\n')[1:]\n        l.append(line)\n\n    ans = []\n    for i, row in enumerate(l):\n        for j, _ in enumerate(row):\n            if l[i][j] == 'x':\n                x, y = j, i\n                l[i][j] = '.'\n                break\n        else:\n            continue\n        break\n\n    for i, row in enumerate(l):\n        for j, _ in enumerate(row):\n            if l[i][j] == 'x':\n                break\n        else:\n            continue\n        break\n\n    for i, row in enumerate(l):\n        for j, _ in enumerate(row):\n            if l[i][j] == 'x':\n                break\n        else:\n            continue\n        break\n\n    ans.append([x, y])\n    ans.append([x + c - 1, y])\n    ans.append([x, y + r - 1])\n    ans.append([x + c - 1, y + r - 1])\n\n    return ans\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = [int(x) for x in stdin.split(' ')]\n    loc = [[x for x in stdin.split('\\n')]]\n    # R, C = int(input()), int(input())\n    # loc = [[x for x in input()] for _ in range(R)]\n\n    result = []\n    for r in range(R):\n        for c in range(C):\n            if loc[0][r][c] == 'x':\n                result.append([r, c, '2'])\n    if len(result) == 0:\n        return''.join(['0' for _ in range(3)])\n    if len(result) > 2:\n        print('-1 -1 -1')\n        return''.join(['0' for _ in range(3)])\n    else:\n        result = sorted(result, key=lambda x: x[1])\n        print('%d %d %s' % (result[0][0], result[0][1], result[0][2]))\n        print('%d %d %s' % (result[1][0], result[1][1], result[1][2]))\n        return''.join(['0' for _ in range(3)])"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return a list of strings.\"\"\"\n    # your code here\n    return [x, y, len(x)]\n    \n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the coordinates and size of the two buildings, each on a separate line.\"\"\"\n    # Your code here\n    R, C = map(int, stdin.split())\n    grid = []\n    for i in range(R):\n        grid.append(stdin.splitlines()[i])\n\n    def solve(grid, R, C):\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    for k in range(i, R):\n                        if grid[k][j] == '.':\n                            return i, j, k - i + 1\n\n    buildings = [[solve(grid, R, C), solve(grid, R, C), solve(grid, R, C)] for i in range(R)]\n    return '\\n'.join([' '.join(str(i) for i in building) for building in buildings])\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    walls = {}\n    for _ in range(R):\n        r = stdin.split()\n        walls[r[0]] = r[1]\n    \n    for _ in range(R):\n        row = stdin.split()\n        l, r = '', ''\n        for i in range(C):\n            if row[i] == '.' and walls[l] == '.':\n                l += str(i)\n            else:\n                r += str(i)\n        print(l, r)\n        l, r = '', ''\n        for i in range(C):\n            if row[i] == '.' and walls[l] == '.':\n                l += 'x'\n            else:\n                r += 'x'\n        print(l, r)\n\nsolution(input())\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split())\n    building = [list(stdin) for _ in range(rows)]\n    row, col = 0, 0\n    for i in range(rows):\n        for j in range(cols):\n            if building[i][j] == 'x':\n                row, col = i, j\n                break\n        if j!= cols - 1:\n            break\n    ans = []\n    for i in range(row, rows):\n        for j in range(col, cols):\n            if building[i][j] == 'x':\n                ans.append(str(i - row + 1) +'' + str(j - col + 1))\n                break\n        if j!= cols - 1:\n            break\n    return '\\n'.join(ans)"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    rows, cols = stdin.split(\"\\n\")\n    rows = int(rows)\n    cols = int(cols)\n    row_idx = 0\n    while row_idx < rows:\n        row_idx += 1\n        for col_idx in range(cols):\n            col_idx += 1\n            if stdin[row_idx][col_idx] == 'x':\n                return f\"{row_idx} {col_idx} {cols}\"\n    return None\n"
    },
    {
        "number": 3132,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    matrix = [[0] * c for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            matrix[i][j] = stdin[i * c + j]\n    res = set()\n    for i in range(r):\n        for j in range(c):\n            if matrix[i][j] == '.':\n                for k in range(1, r // 2 + 1):\n                    if matrix[i][j - k] == matrix[i][j + k] == 'x':\n                        res.add((i, j - k))\n                    elif matrix[i][j - k] == matrix[i][j + k] == 'x':\n                        res.add((i, j + k))\n                    else:\n                        break\n                for k in range(1, c // 2 + 1):\n                    if matrix[i - k][j] == matrix[i + k][j] == 'x':\n                        res.add((i - k, j))\n                    elif matrix[i - k][j] == matrix[i + k][j] == 'x':\n                        res.add((i + k, j))\n                    else:\n                        break\n    return''.join(map(str, sorted(res)))\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    '''Function to solve the problem'''\n    lines = stdin.split('\\n')\n    n, a, b = [int(i) for i in lines[0].split()]\n    result = []\n    for i in range(n):\n        [l, r, t] = [int(i) for i in lines[i+1].split()]\n        result.append([l, r, t])\n    res1 = result[a]\n    res2 = result[b]\n    if res1[2] == 0 and res2[2] == 0:\n        return 'indistinguishable'\n    elif res1[2] == 0:\n        return res2[0] - res1[1]\n    elif res2[2] == 0:\n        return res1[0] - res2[1]\n    else:\n        return 0"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) == 0:\n        return \"indistinguishable\"\n    num_turns = int(stdin[0])\n    intersections = list(map(int, stdin[1].split(' ')))\n    turns = [[int(stdin[j + i]) for i in range(3)] for j in range(0, num_turns * 3, 3)]\n    # print(turns)\n    # print(intersections)\n    dist = [turns[0][0]]\n    paths = {0: [0]}\n    while len(dist) < num_turns + 1:\n        # print(paths)\n        # print(dist)\n        if 0 in paths:\n            for i in paths[0]:\n                dist.append(turns[i][0])\n                if turns[i][0] in intersections:\n                    paths[turns[i][0]] = paths[0] + [turns[i][0]]\n                else:\n                    paths[turns[i][0]] = [turns[i][0]]\n        if len(dist) == num_turns + 1:\n            break\n        for i in range(num_turns):\n            # print(dist)\n            # print(i)\n            if dist[-1] == turns[0][0] and dist[-2] == turns[0][1] and dist[-3] == turns[0][2]:\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                if turns[0][0] in intersections:\n                    paths[turns[0][0]] = []\n                else:\n                    paths[turns[0][0]] = [turns[0][0]]\n                break\n            if dist[-1] == turns[i + 1][0] and dist[-2] == turns[i + 1][1] and dist[-3] == turns[i + 1][2]:\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                if turns[i + 1][0] in intersections:\n                    paths[turns[i + 1][0]] = paths[turns[0][0]] + [turns[i + 1][0]]\n                else:\n                    paths[turns[i + 1][0]] = [turns[i + 1][0]]\n                break\n            if dist[-1] == turns[i + 1][1] and dist[-2] == turns[i + 1][0] and dist[-3] == turns[i + 1][2]:\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                if turns[i + 1][1] in intersections:\n                    paths[turns[i + 1][1]] = paths[turns[0][1]] + [turns[i + 1][1]]\n                else:\n                    paths[turns[i + 1][1]] = [turns[i + 1][1]]\n                break\n    if num_turns % 2 == 1:\n        for i in range(num_turns):\n            if dist[-1] == turns[0][0] and dist[-2] == turns[0][1] and dist[-3] == turns[0][2]:\n                if turns[0][0] in intersections:\n                    paths[turns[0][0]] = []\n                else:\n                    paths[turns[0][0]] = [turns[0][0]]\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                break\n            if dist[-1] == turns[i + 1][0] and dist[-2] == turns[i + 1][1] and dist[-3] == turns[i + 1][2]:\n                if turns[i + 1][0] in intersections:\n                    paths[turns[i + 1][0]] = paths[turns[0][0]] + [turns[i + 1][0]]\n                else:\n                    paths[turns[i + 1][0]] = [turns[i + 1][0]]\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                break\n            if dist[-1] == turns[i + 1][1] and dist[-2] == turns[i + 1][0] and dist[-3] == turns[i + 1][2]:\n                if turns[i + 1][1] in intersections:\n                    paths[turns[i + 1][1]] = paths[turns[0][1]] + [turns[i + 1][1]]\n                else:\n                    paths[turns[i + 1][1]] = [turns[i + 1][1]]\n                dist.pop()\n                dist.pop()\n                dist.pop()\n                break\n        print(paths)\n        return 'Alice'\n    return 'Bob'\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, alice_intersection, bob_intersection = [int(i) for i in stdin.split()]\n    street_list = [[int(i) for i in line.split()] for line in stdin.split('\\n')[1:-1]]\n    alice_route = []\n    bob_route = []\n    for i in range(len(street_list)):\n        if street_list[i][1] == alice_intersection:\n            alice_route.append(i)\n        if street_list[i][1] == bob_intersection:\n            bob_route.append(i)\n    for i in range(len(alice_route)):\n        for j in range(len(bob_route)):\n            if alice_route[i] < bob_route[j] or (alice_route[i] == bob_route[j] and i < j):\n                return \"Alice\"\n            elif alice_route[i] > bob_route[j] or (alice_route[i] == bob_route[j] and i > j):\n                return \"Bob\"\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the minimum number of turns to show who is right.\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: The answer\n    \"\"\"\n    N, A, B = stdin.split()\n    N, A, B = map(int, [N, A, B])\n    s = stdin.split()\n    A = int(s[0][0])\n    B = int(s[0][1])\n\n    turn = [int(s[i][0]) for i in range(1, N + 1)]\n    t = [int(s[i][1]) for i in range(1, N + 1)]\n\n    # initialise\n    A_turns = [0] * (N + 1)\n    B_turns = [0] * (N + 1)\n\n    # A's turns\n    # at intersection 0\n    A_turns[0] = 0\n    # at intersection 1\n    if t[0] == 0:\n        A_turns[1] = 1\n    # at intersection 2\n    if t[0] == 1:\n        A_turns[1] = 1\n        A_turns[2] = 0\n    # at intersection 3\n    if t[0] == 1:\n        A_turns[1] = 1\n        A_turns[2] = 1\n        A_turns[3] = 0\n    # at intersection 4\n    if t[0] == 0:\n        A_turns[1] = 1\n        A_turns[2] = 1\n        A_turns[3] = 1\n        A_turns[4] = 0\n    # at intersection 5\n    if t[0] == 1:\n        A_turns[1] = 1\n        A_turns[2] = 1\n        A_turns[3] = 1\n        A_turns[4] = 1\n        A_turns[5] = 0\n\n    # B's turns\n    # at intersection 0\n    B_turns[0] = 0\n    # at intersection 1\n    if t[0] == 0:\n        B_turns[1] = 1\n    # at intersection 2\n    if t[0] == 1:\n        B_turns[1] = 1\n        B_turns[2] = 0\n    # at intersection 3\n    if t[0] == 1:\n        B_turns[1] = 1\n        B_turns[2] = 1\n        B_turns[3] = 0\n    # at intersection 4\n    if t[0] == 0:\n        B_turns[1] = 1\n        B_turns[2] = 1\n        B_turns[3] = 1\n        B_turns[4] = 0\n    # at intersection 5\n    if t[0] == 1:\n        B_turns[1] = 1\n        B_turns[2] = 1\n        B_turns[3] = 1\n        B_turns[4] = 1\n        B_turns[5] = 0\n\n    for i in range(1, N):\n        # A's turns\n        # at intersection i\n        if t[i] == 0:\n            A_turns[i] = A_turns[i - 1] + 1\n        else:\n            A_turns[i] = min(A_turns[i - 1] + 1, A_turns[i - 2] + 1)\n        # at intersection i + 1\n        if t[i] == 0:\n            A_turns[i + 1] = A_turns[i]\n        else:\n            A_turns[i + 1] = min(A_turns[i], A_turns[i - 1] + 1)\n        # B's turns\n        # at intersection i\n        if t[i] == 1:\n            B_turns[i] = B_turns[i - 1] + 1\n        else:\n            B_turns[i] = min(B_turns[i - 1] + 1, B_turns[i - 2] + 1)\n        # at intersection i + 1\n        if t[i] == 1:\n            B_turns[i + 1] = B_turns[i]\n        else:\n            B_turns[i + 1] = min(B_turns[i], B_turns[i - 1] + 1)\n\n    return min(A_turns[-1], B_turns[-1])\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = [int(x) for x in stdin.split()]\n    res = []\n    for line in stdin.split(\"\\n\")[2:]:\n        l, r, t = [int(x) for x in line.split()]\n        res.append((l, r, t))\n\n    def find_t(a: int, b: int) -> int:\n        for i in range(len(res)):\n            if res[i][0] == a and res[i][1] == b:\n                return res[i][2]\n\n    al, bl = set(), set()\n    cnt = 0\n    while not al.issubset(bl):\n        cnt += 1\n        c = [set(), set()]\n        for a, b in zip(al, bl):\n            if find_t(a, b):\n                c[0].add(a)\n                c[1].add(b)\n            else:\n                c[0].add(b)\n                c[1].add(a)\n        al = c[0]\n        bl = c[1]\n        if len(al) == 1:\n            break\n    print(cnt)\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [int(x) for x in stdin.split()]\n    routeA = [int(x) for x in stdin.split()]\n    routeB = [int(x) for x in stdin.split()]\n    ans = 'indistinguishable'\n    towerA = set()\n    towerB = set()\n    for x in range(n):\n        if routeA[x] == a:\n            towerA.add(x)\n        if routeB[x] == b:\n            towerB.add(x)\n    if towerA and towerB:\n        for x in towerA:\n            if x in towerB:\n                ans = x\n                break\n    print(ans)\n"
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = [int(x) for x in stdin.split()]\n    A, B = set(stdin.split()[1:])\n    if b == 0:\n        return \"1\" if A == B else \"2\"\n    return \"indistinguishable\""
    },
    {
        "number": 3133,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    n, a, b = list(map(int, stdin.split()))\n    for _ in range(n):\n        a, b, tower = list(map(int, stdin.split()))\n        if tower == 1:\n            if a > b:\n                print('Alice')\n            elif a < b:\n                print('Bob')\n            else:\n                print('indistinguishable')\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the recovered matrix using parity constraints.\"\"\"\n    p = stdin[0]\n    q = stdin[1]\n    matrix = []\n    if len(p)!= len(q):\n        return -1\n    if all(\n        (bit in (\"0\", \"1\") for bit in p + q)\n    ):  # ensuring valid parity inputs\n        for row in range(1, len(stdin) + 1):\n            matrix.append(p * row + q * row)\n        return \"\".join(\n            [\n                matrix[0][0],\n                *(\n                    \"\".join(\n                        [\n                            matrix[row][col]\n                            for row in range(1, len(matrix))\n                        ]\n                    )\n                    for col in range(1, len(matrix[0]))\n                ),\n            ]\n        )\n    return -1\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r_parity = stdin[0]\n    c_parity = stdin[1]\n    if any(1 in r_parity for r_parity in r_parity) or any(1 in c_parity for c_parity in c_parity):\n        return -1\n    r_parity = r_parity.split('0')\n    c_parity = c_parity.split('0')\n    r = [int(r_parity[0])]\n    for i in range(1, len(r_parity)):\n        r.append(r[i - 1] ^ int(r_parity[i]))\n    c = [int(c_parity[0])]\n    for i in range(1, len(c_parity)):\n        c.append(c[i - 1] ^ int(c_parity[i]))\n    r = r[::-1]\n    c = c[::-1]\n    r_parity = '0' * (len(r_parity[0]) - 1)\n    c_parity = '0' * (len(c_parity[0]) - 1)\n    for i in range(len(r)):\n        r_parity = r_parity + str(r[i])\n        c_parity = c_parity + str(c[i])\n    r_parity = r_parity + '0'\n    c_parity = c_parity + '0'\n    r_parity = list(r_parity)\n    c_parity = list(c_parity)\n    matrix = [[0] * len(r_parity) for _ in range(len(r_parity))]\n    for i in range(len(r_parity)):\n        matrix[i][i] = r_parity[i]\n    for i in range(len(c_parity)):\n        matrix[i][len(r_parity) + i] = c_parity[i]\n    matrix_str = ''\n    for i in matrix:\n        matrix_str = matrix_str + ''.join(str(j) for j in i)\n    if matrix_str.count('1') > len(matrix) ** 2:\n        return -1\n    for i in range(len(matrix_str)):\n        if matrix_str[i]!= '0':\n            matrix = concat(matrix, i)\n    return matrix\n\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"11101011011\")\n    11101011011\n    \"\"\"\n\n    parity = stdin[0::2]\n    cparity = stdin[1::2]\n\n    result = [[0] * len(cparity) for _ in range(len(parity))]\n\n    i = 0\n    for row in parity:\n        j = 0\n        for col in cparity:\n            if row[j] == \"1\" and col[i] == \"1\":\n                result[j][i] = \"1\"\n            j += 1\n        i += 1\n\n    return \"\\n\".join([\"\".join(row) for row in result])\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: str\n    :return: str\n    \"\"\"\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    row_parities = [int(char) for char in stdin[0]]\n    col_parities = [int(char) for char in stdin[1]]\n    num_ones = [row_parities[row] + col_parities[row] for row in range(len(row_parities))]\n    num_zeros = [len(row_parities) - num_ones[row] for row in range(len(row_parities))]\n    max_ones = max(num_ones)\n    min_ones = min(num_ones)\n    min_zeros = min(num_zeros)\n\n    if max_ones > min_zeros:\n        return -1\n\n    recovered_matrix = []\n    for row in range(len(row_parities)):\n        recovered_matrix.append([])\n        for col in range(len(col_parities)):\n            if row_parities[row] == 1:\n                if col_parities[col] == 1:\n                    recovered_matrix[row].append(1)\n                else:\n                    recovered_matrix[row].append(0)\n            else:\n                if col_parities[col] == 1:\n                    recovered_matrix[row].append(0)\n                else:\n                    recovered_matrix[row].append(1)\n    return ''.join([''.join([str(item) for item in row]) for row in recovered_matrix])"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R = stdin[0]\n    C = stdin[1]\n    count_1 = R.count('1')\n    mat = []\n    for i in range(len(R)):\n        mat.append([])\n        for j in range(len(C)):\n            mat[i].append(1 - (i % 2))\n    mat.append(mat.pop(0))\n    row_parity = [int(x) for x in R]\n    col_parity = [int(x) for x in C]\n    num_1 = 0\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if mat[i][j] == 1:\n                num_1 += 1\n                if row_parity[i]!= col_parity[j]:\n                    mat[i][j] = 0\n    if num_1!= count_1:\n        return -1\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            print(mat[i][j], end='')\n        print()\n    return None"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def _row(row: str) -> int:\n        return 1 if row.count('1') % 2 == 1 else 0\n\n    def _col(col: str) -> int:\n        return 1 if col.count('1') % 2 == 1 else 0\n\n    rows = stdin.split('\\n')\n    row_parities = list(map(_row, rows))\n    col_parities = list(map(_col, zip(*rows)))\n    matrix = _parse_matrix(rows)\n\n    row_parities.append(_row(_col_to_row(col_parities)))\n    col_parities.append(_col(_row_to_col(row_parities)))\n    return _matrix_to_str(matrix, row_parities, col_parities)\n\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"0110\\n1001\")\n    1111\n    >>> solution(\"1110\\n1001\")\n    1111\n    >>> solution(\"1110\\n0110\")\n    1111\n    >>> solution(\"1110\\n1110\")\n    1111\n    >>> solution(\"1111\\n1111\")\n    1111\n    >>> solution(\"1110\\n1011\")\n    1111\n    >>> solution(\"1110\\n1101\")\n    1111\n    >>> solution(\"1110\\n1110\\n1111\\n1111\")\n    111111111111111111111111\n    >>> solution(\"11101\\n11010\\n11101\\n11010\")\n    11111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n1111\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n1110\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n110\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n110\\n1111\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n110\\n1110\\n1111\")\n    111111111111111111111111111111110\n    >>> solution(\"11101\\n11010\\n11101\\n11010\\n1111\\n110\\n1110\\n1111\\n1111\\n1111\")\n    111111111111111111111111111111110\n    \"\"\"\n    R = stdin.splitlines()[0]\n    C = stdin.splitlines()[1]\n    \n    if len(set(R))!= len(set(C)):\n        return \"-1\"\n    \n    parity = [0] * len(R)\n    for r in R:\n        parity[int(r) - 1] += 1\n    \n    if not all(p % 2 == 0 for p in parity):\n        return \"-1\"\n    \n    col_parity = [0] * len(C)\n    for c in C:\n        col_parity[int(c) - 1] += 1\n    \n    if not all(p % 2 == 0 for p in col_parity):\n        return \"-1\"\n    \n    # row and column parity\n    row_parity = 0\n    col_parity = 0\n    for i in range(len(R)):\n        row_parity += R[i]\n        col_parity += C[i]\n    \n    if row_parity % 2 == 0:\n        row_parity = 0\n    else:\n        row_parity = 1\n    \n    if col_parity % 2 == 0:\n        col_parity = 0\n    else:\n        col_parity = 1\n    \n    matrix = [[\"0\"] * len(C) for _ in range(len(R))]\n    index = len(R) - 1\n    while index >= 0:\n        for i in range(len(C)):\n            matrix[index][i] = \"1\" if R[index] == \"1\" and C[i] == \"1\" else \"0\"\n        index -= 1\n    \n    matrix_parity = [0] * len(C)\n    for i in range(len(C)):\n        matrix_parity[i] = row_parity if i % 2 == 0 else col_parity\n    \n    index = 1\n    while index < len(R):\n        for i in range(len(C)):\n            if matrix_parity[i] == 1:\n                for j in range(index, index + len(C)):\n                    matrix[j][i] = \"1\" if R[index] == \"1\" and C[i] == \"1\" else \"0\"\n            else:\n                for j in range(index, index + len(C)):\n                    matrix[j][i] = \"1\" if R[index] == \"1\" and C[i] == \"1\" else \"0\"\n        index += len(C)\n    \n    # generate the min number\n    matrix_len = len(matrix)\n    answer = [\"1\"] * matrix_len\n    for i in range(matrix_len):\n        for j in range(matrix_len):\n            if matrix[i][j] == \"1\":\n                answer[i] = \"0\" if int(answer[i]) % 2 == 0 else \"1\"\n                break\n    \n    return \"\".join(answer)\n"
    },
    {
        "number": 3134,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    row = stdin[0]\n    col = stdin[1]\n    row = list(row)\n    col = list(col)\n\n    row_p = []\n    for i in range(0, len(row)):\n        if row[i] == '0':\n            row_p.append(0)\n        elif row[i] == '1':\n            row_p.append(1)\n    col_p = []\n    for i in range(0, len(col)):\n        if col[i] == '0':\n            col_p.append(0)\n        elif col[i] == '1':\n            col_p.append(1)\n\n    for i in range(0, len(row_p)):\n        if row_p[i] == 1:\n            row_p[i] = 0\n        else:\n            row_p[i] = 1\n    for i in range(0, len(col_p)):\n        if col_p[i] == 1:\n            col_p[i] = 0\n        else:\n            col_p[i] = 1\n\n    row_p = ''.join(str(i) for i in row_p)\n    col_p = ''.join(str(i) for i in col_p)\n    print(row_p)\n    print(col_p)\n\n\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('')\n    '0'\n    >>> solution('10010')\n    '10-01'\n    >>> solution('10010111')\n    '11-1010'\n    \"\"\"\n    pass"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return stdin"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    :param stdin: input in str\n    :return: solution in str\n    \"\"\"\n    # your code here\n    return stdin\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Declare a string containing all possible characters.\n    # We will remove chars from it in case they are not in `n`.\n    characters = \"01\"\n\n    # Convert `n` to a list of chars, remove chars that are not in `n` and convert back to str.\n    n = \"\".join(list(filter(lambda x: x in characters, list(stdin))))\n\n    # Initialise a list to hold our final output.\n    output = []\n\n    # Iterate through each char in `n`, convert it to binary, add it to the final output list.\n    # Add a '-' to the output if char is negative, add a '0' if char is zero and add a '+' if char is positive.\n    for char in n:\n        # Convert char to binary\n        binary = f\"{char:04b}\"\n\n        # Add char to the final output list\n        output.append(binary[-1])\n\n        # Add a '-' to the output if char is negative, add a '0' if char is zero and add a '+' if char is positive.\n        if char == \"0\":\n            output.append(\"0\")\n        elif char == \"1\":\n            output.append(\"+\")\n        elif char == \"-\":\n            output.append(\"-\")\n\n    # Join the output list to a string and return it.\n    return \"\".join(output)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Your code goes here\n    #Hint: What's the minimum possible number of digits?\n\n    res = []\n    n = stdin\n    count = 0\n    if len(n) > 100000:\n        return \"ERROR\"\n    n = int(n, 2)\n    while n > 0:\n        if n % 2 == 0:\n            res.append(0)\n            n = n // 2\n            count += 1\n        else:\n            res.append(1)\n            n = (n - 1) // 2\n            count += 1\n    res.append(\"+\")\n    res.append(\"0\" * (count - len(res)))\n    print(\"\".join(res))\n    return \"\".join(res)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    negative = False\n    if num < 0:\n        negative = True\n        num = abs(num)\n    min_len = 100010\n    counter = 0\n    while num > 0:\n        counter += 1\n        num //= 2\n    while counter > 0:\n        if min_len > counter:\n            min_len = counter\n            sign = '-' if negative else '+'\n            min_str = f'{sign:0{counter}}'\n            break\n        counter -= 1\n    return min_str\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return min(stdin.replace('0', '-').replace('1', '+')[::2])\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()[0]\n    \n    dp = [0] * len(s)\n    \n    for i, ch in enumerate(s):\n        if i > 0 and ch == \"0\":\n            if s[i-1] == \"-\":\n                dp[i] = min(dp[i], dp[i-2] + 2)\n            else:\n                dp[i] = min(dp[i], dp[i-1] + 2)\n        elif i > 0 and ch == \"1\":\n            if s[i-1] == \"-\":\n                dp[i] = min(dp[i], dp[i-2] + 2)\n            else:\n                dp[i] = min(dp[i], dp[i-1] + 2)\n        else:\n            dp[i] = 1\n    \n    print(s[:dp[-1]])\n    \n    return s[:dp[-1]]\n    \n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = stdin\n    if n == 0:\n        return '0'\n    num_of_bits = 0\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = n // 2 + 1\n        num_of_bits += 1\n    return '+' * num_of_bits + '0' + '-' * (num_of_bits - 1)\n"
    },
    {
        "number": 3135,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.strip().strip('0')\n    return '+' * len(stdin) if stdin else '0'"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Greedily pick the cheapest shipping option, then keep the cheapest one.\"\"\"\n    n, m, s, t = (int(x) for x in stdin.split())\n    w1, w2 = (int(x) - 1 for x in stdin.split())\n\n    road_distances = [list(map(int, stdin.split()[4:])) for _ in range(m)]\n    employee_distances = [list(map(int, stdin.split()[2:])) for _ in range(s)]\n    client_distances = [list(map(int, stdin.split()[2:])) for _ in range(t)]\n\n    def travel_distance(start: int, end: int, distance_table: List[List[int]]) -> int:\n        \"\"\"Return the minimum travel distance between two intersections, or inf if it's impossible to travel between them.\"\"\"\n        if start == end:\n            return 0\n        return min(distance_table[start][i] + distance_table[i][end] for i in range(n))\n\n    # A list of distances between warehouses and intersections.\n    warehouse_intersection_distances = [travel_distance(w1, i, road_distances) for i in range(n)]\n    # A list of distances between intersections and clients.\n    intersection_client_distances = [travel_distance(i, c, road_distances) for c in range(n) for i in range(n)]\n    # A list of distances between warehouses and clients.\n    warehouse_client_distances = [travel_distance(w1, c, road_distances) for c in range(n)]\n\n    # The cheapest shipping distance between intersections, regardless of the warehouse.\n    cheapest_intersection_to_intersection_distance = min(warehouse_intersection_distances)\n    # The cheapest shipping distance between warehouses, regardless of the intersection.\n    cheapest_warehouse_to_warehouse_distance = min(warehouse_client_distances)\n    # The cheapest shipping distance between intersections and clients, regardless of the warehouse.\n    cheapest_intersection_to_client_distance = min(intersection_client_distances)\n    # The cheapest shipping distance between warehouses and clients, regardless of the intersection.\n    cheapest_warehouse_to_client_distance = min(warehouse_client_distances)\n\n    # The cheapest shipping distance between intersections and clients, including the return trip from warehouse to client.\n    # Since there are more than two warehouses, this distance could be potentially less than the cheapest shipping distance between warehouses and clients.\n    # The following if-else statement will ensure that the return trip is included when there are more than two warehouses.\n    if w2 > 0:\n        cheapest_intersection_to_client_return_trip_distance = min(\n            # The total shipping distance between warehouse and client.\n            warehouse_client_distances[w2] + warehouse_client_distances[w1] + cheapest_intersection_to_client_distance,\n            # The total shipping distance between warehouse and client, including the return trip.\n            intersection_client_distances[w2] + cheapest_intersection_to_client_distance,\n        )\n    else:\n        cheapest_intersection_to_client_return_trip_distance = cheapest_intersection_to_client_distance\n\n    # The cheapest shipping distance between intersections and clients, including the return trip from warehouse to client.\n    # Since there are more than two warehouses, this distance could be potentially more than the cheapest shipping distance between warehouses and clients.\n    # The following if-else statement will ensure that the return trip is included when there are more than two warehouses.\n    if w2 > 0:\n        cheapest_warehouse_to_client_return_trip_distance = min(\n            # The total shipping distance between warehouse and client.\n            warehouse_client_distances[w2] + cheapest_warehouse_to_client_distance,\n            # The total shipping distance between warehouse and client, including the return trip.\n            warehouse_client_distances[w2] + cheapest_warehouse_to_client_distance + cheapest_intersection_to_client_return_trip_distance,\n        )\n    else:\n        cheapest_warehouse_to_client_return_trip_distance = cheapest_warehouse_to_client_distance\n\n    # The cheapest shipping distance between intersections, regardless of the warehouse, including the return trip from warehouse to intersection.\n    # Since there are more than two warehouses, this distance could be potentially more than the cheapest shipping distance between warehouses.\n    # The following if-else statement will ensure that the return trip is included when there are more than two warehouses.\n    if w2 > 0:\n        cheapest_intersection_to_intersection_return_trip_distance = min(\n            # The total shipping distance between warehouse and intersection.\n            warehouse_intersection_distances[w2] + warehouse_intersection_distances[w1],\n            # The total shipping distance between warehouse and intersection, including the return trip.\n            intersection_intersection_distances[w2] + cheapest_intersection_to_intersection_distance,\n        )\n    else:\n        cheapest_intersection_to_intersection_return_trip_distance = cheapest_intersection_to_intersection_distance\n\n    # The cheapest shipping distance between warehouses, regardless of the intersection, including the return trip from warehouse to intersection.\n    # Since there are more than two warehouses, this distance could be potentially more than the cheapest shipping distance between warehouses.\n    # The following if-else statement will ensure that the return trip is included when there are more than two warehouses.\n    if w2 > 0:\n        cheapest_warehouse_to_intersection_return_trip_distance = min(\n            # The total shipping distance between warehouse and intersection.\n            warehouse_intersection_distances[w2] + cheapest"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def funct1(n, m, s, t, q):\n        # dictionary of all the edges\n        edges = {}\n\n        for i in range(1, n + 1):\n            edges[i] = set()\n\n        # add edges\n        for i in range(m):\n            u, v, w = map(int, stdin.readline().split())\n            edges[u].add((v, w))\n            edges[v].add((u, w))\n\n        # dictionary of all the edges\n        # to check for negative weight cycles\n        dist = {1: 0}\n\n        # distance to all the vertices\n        for _ in range(s):\n            x, y, z = map(int, stdin.readline().split())\n            dist[x] = z\n\n        # distance to all the vertices\n        for _ in range(t):\n            x, y, z = map(int, stdin.readline().split())\n            dist[x] = z\n\n        # distance to all the vertices\n        for _ in range(q):\n            x, y = map(int, stdin.readline().split())\n            dist[x] = y\n\n        # to check for negative weight cycles\n        dist_check = {1: 0}\n\n        # distance to all the vertices\n        for _ in range(s):\n            x, y, z = map(int, stdin.readline().split())\n            dist_check[x] = z\n\n        # distance to all the vertices\n        for _ in range(t):\n            x, y, z = map(int, stdin.readline().split())\n            dist_check[x] = z\n\n        # distance to all the vertices\n        for _ in range(q):\n            x, y = map(int, stdin.readline().split())\n            dist_check[x] = y\n\n        # function to check for negative\n        # weight cycles\n        def check_negative(dist, dist_check):\n            # to check for negative weight cycles\n            dist_negative = {}\n            for u in dist.keys():\n                dist_negative[u] = dist[u] - \\\n                    sum(v for v, w in edges[u])\n\n            # to check for negative weight cycles\n            dist_check_negative = {}\n            for u in dist_check.keys():\n                dist_check_negative[u] = dist_check[u] - \\\n                    sum(v for v, w in edges[u])\n\n            return dist_check_negative\n\n        # to find the shortest path\n        def find_shortest_path(dist, dist_check):\n            dist_negative = check_negative(dist, dist_check)\n            shortest = sys.maxsize\n\n            # to check for negative weight cycles\n            for u in dist.keys():\n                for v, w in edges[u]:\n                    if dist_negative[v] < 0 and dist_negative[v] + w < shortest:\n                        shortest = dist_negative[v] + w\n\n            return shortest\n\n        return find_shortest_path(dist, dist_check)\n\n    def funct2(n, m, s, t, q):\n        # dictionary of all the edges\n        edges = {}\n\n        for i in range(1, n + 1):\n            edges[i] = set()\n\n        # add edges\n        for i in range(m):\n            u, v, w = map(int, stdin.readline().split())\n            edges[u].add((v, w))\n            edges[v].add((u, w))\n\n        # dictionary of all the edges\n        # to check for negative weight cycles\n        dist = {1: 0}\n\n        # distance to all the vertices\n        for _ in range(s):\n            x, y, z = map(int, stdin.readline().split())\n            dist[x] = z\n\n        # distance to all the vertices\n        for _ in range(t):\n            x, y, z = map(int, stdin.readline().split())\n            dist[x] = z\n\n        # distance to all the vertices\n        for _ in range(q):\n            x, y = map(int, stdin.readline().split())\n            dist[x] = y\n\n        # to check for negative weight cycles\n        dist_check = {1: 0}\n\n        # distance to all the vertices\n        for _ in range(s):\n            x, y, z = map(int, stdin.readline().split())\n            dist_check[x] = z\n\n        # distance to all the vertices\n        for _ in range(t):\n            x, y, z = map(int, stdin.readline().split())\n            dist_check[x] = z\n\n        # distance to all the vertices\n        for _ in range(q):\n            x, y = map(int, stdin.readline().split())\n            dist_check[x] = y\n\n        # function to check for negative\n        # weight cycles\n        def check_negative(dist, dist_check):\n            # to check for negative weight cycles\n            dist_negative = {}\n            for u in dist.keys():\n                dist_negative[u] = dist[u] - \\\n                    sum(v for v, w in edges[u])\n\n            # to check for negative weight cycles\n            dist_check_negative = {}\n            for u in dist_check.keys():\n                dist_check_negative[u] = dist_check[u] - \\\n                    sum(v for v, w in edges[u])\n\n            return dist_check_negative\n\n        # to find the shortest path\n        def find_shortest_path(dist, dist_check):\n            dist_negative = check_negative(dist, dist_check)\n            shortest = sys.maxsize"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Implement me\n    #pass\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.algoexpert.io/questions/Minimizing%20Distance\"\"\"\n\n    def travel_distance(inp):\n        dist = [float('inf')] * len(inp)\n        dist[0] = 0\n        while True:\n            old_dist = dist[:]\n            for i in range(len(inp)):\n                for u, v, d in inp[i]:\n                    dist[v] = min(dist[v], dist[u] + d)\n            if old_dist == dist:\n                return dist[-1]\n        return dist\n\n    inp = [list(map(int, line.split())) for line in stdin.strip().splitlines()]\n    return str(travel_distance(inp))\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = [int(x) for x in stdin.split(\" \")]\n\n    warehouses = [int(x) for x in stdin.split(\" \")][1]\n    employees = [int(x) for x in stdin.split(\" \")][2]\n\n    employee_to_intersection = [0 for i in range(employees)]\n    intersection_to_employee = [0 for i in range(employees)]\n    intersection_to_warehouse = [0 for i in range(employees)]\n    warehouse_to_intersection = [0 for i in range(employees)]\n    intersection_to_client = [0 for i in range(employees)]\n    client_to_intersection = [0 for i in range(employees)]\n\n    for i in range(m):\n        u, v, d = [int(x) for x in stdin.split(\" \")][1:]\n        if u == v:\n            continue\n        if intersection_to_employee[u-1] == 0:\n            employee_to_intersection[u-1] = v\n            intersection_to_employee[v-1] = u\n        if intersection_to_employee[v-1] == 0:\n            employee_to_intersection[v-1] = u\n            intersection_to_employee[u-1] = v\n        if intersection_to_warehouse[u-1] == 0:\n            intersection_to_warehouse[u-1] = v\n            warehouse_to_intersection[v-1] = u\n        if intersection_to_warehouse[v-1] == 0:\n            intersection_to_warehouse[v-1] = u\n            warehouse_to_intersection[u-1] = v\n        if intersection_to_client[u-1] == 0:\n            intersection_to_client[u-1] = v\n            client_to_intersection[v-1] = u\n        if intersection_to_client[v-1] == 0:\n            intersection_to_client[v-1] = u\n            client_to_intersection[u-1] = v\n\n    for i in range(s):\n        employee = int(stdin.split(\" \")[i+3])\n        intersection = int(stdin.split(\" \")[i+4])\n        if intersection_to_employee[employee-1] == 0:\n            employee_to_intersection[employee-1] = intersection\n            intersection_to_employee[intersection-1] = employee\n        if intersection_to_warehouse[employee-1] == 0:\n            intersection_to_warehouse[employee-1] = intersection\n            warehouse_to_intersection[intersection-1] = employee\n        if intersection_to_client[employee-1] == 0:\n            intersection_to_client[employee-1] = intersection\n            client_to_intersection[intersection-1] = employee\n\n    total_distance = 0\n    for i in range(employees):\n        intersection = employee_to_intersection[i]\n        warehouse = intersection_to_warehouse[intersection-1]\n        if warehouse!= 0:\n            total_distance += dfs(warehouse, intersection)\n        client = intersection_to_client[intersection-1]\n        if client!= 0:\n            total_distance += dfs(client, intersection)\n\n    return total_distance\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_distance_of_intersections(intersections: List[Tuple[int, int]], graph: List[List[Tuple[int, int]]]) -> int:\n        '''finds shortest distance between all intersections in graph.'''\n        # create adjacency list\n        adj_list = defaultdict(list)\n        for x, y in graph:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n\n        # dfs to find shortest distance from source to all vertices\n        dist = [float('inf')] * len(intersections)\n        visited = [False] * len(intersections)\n        def dfs(curr_vertex: int, dist: List[int], visited: List[bool]) -> None:\n            visited[curr_vertex] = True\n            for neighbor in adj_list[curr_vertex]:\n                if not visited[neighbor]:\n                    dist[neighbor] = min(dist[neighbor], dist[curr_vertex] + 1)\n                    dfs(neighbor, dist, visited)\n\n        dfs(0, dist, visited)\n        return min(dist)\n\n    n, m, s, t = [int(num) for num in stdin.split()]\n    warehouses = [int(num) for num in stdin.split()]\n    employees = [int(num) for num in stdin.split()]\n\n    graph = []\n    for _ in range(m):\n        x, y, d = [int(num) for num in stdin.split()]\n        graph.append((x, y))\n        graph.append((y, x))\n\n    # for each intersection, find shortest distance to all other intersections\n    intersection_distances = [find_min_distance_of_intersections(intersections, graph)\n                            for intersections in itertools.combinations(graph, n)]\n\n    # for each warehouse, find shortest distance to all intersections\n    warehouse_distances = [find_min_distance_of_intersections(warehouses, graph)\n                            for warehouses in itertools.combinations(graph, 2)]\n\n    # for each employee, find shortest distance to all warehouses\n    employee_distances = [find_min_distance_of_intersections(employees, graph)\n                            for employees in itertools.combinations(warehouses, s)]\n\n    # for each client, find shortest distance to all warehouses\n    client_distances = [find_min_distance_of_intersections(clients, graph)\n                            for clients in itertools.combinations(graph, t)]\n\n    # for each intersection, find shortest distance to all warehouses, employees, and clients\n    min_distance = [min(intersection_distances[i] + warehouse_distances[i] + employee_distances[i] + client_distances[i])\n                    for i in range(len(intersection_distances))]\n\n    # minimum distance is the minimum of the shortest distances\n    return min(min_distance)"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem\"\"\"\n\n    def solve(intersections, roads, trucks, max_distance):\n        \"\"\"Solve the problem\"\"\"\n\n        def travel_distance(intersection, destination):\n            \"\"\"Compute the travel distance\"\"\"\n            return max_distance if (destination, intersection) in roads else roads[destination, intersection]\n\n        def get_shortest_travel_distance(start, end, max_distance):\n            \"\"\"Get the shortest travel distance\"\"\"\n            shortest_distance = max_distance + 1\n            queue = collections.deque([(start, 0)])\n            seen = {start}\n\n            while queue:\n                current, current_distance = queue.popleft()\n                if current == end:\n                    shortest_distance = min(shortest_distance, current_distance)\n                elif current_distance < shortest_distance:\n                    for neighbour, neighbour_distance in roads.get((current, end), {}).items():\n                        if neighbour not in seen:\n                            seen.add(neighbour)\n                            queue.append((neighbour, current_distance + neighbour_distance))\n            return shortest_distance\n\n        # Convert input to adjacency list\n        adjacency_list = collections.defaultdict(dict)\n        for u, v, distance in roads:\n            adjacency_list[u][v] = distance\n            adjacency_list[v][u] = distance\n\n        # Solve the problem\n        solution = 0\n        for intersection in intersections:\n            total_distance = 0\n            for destination in intersections:\n                if destination!= intersection:\n                    total_distance += travel_distance(intersection, destination)\n\n            solution = max(solution, total_distance)\n        return solution\n\n    # Read in the input\n    intersections, roads, trucks, max_distance = [int(value) for value in stdin.split()]\n    roads = {(u, v): distance for u, v, distance in [tuple(map(int, road.split())) for road in stdin.split('\\n') if road]}\n    trucks = [int(truck) for truck in stdin.split('\\n') if truck]\n\n    # Solve the problem\n    result = solve(intersections, roads, trucks, max_distance)\n\n    # Return the result\n    return result\n"
    },
    {
        "number": 3136,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    pass\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return duration of game in seconds.\n\n    Game ends when bacteria step on trap.\n    \"\"\"\n    rows, cols, traps = parse_input(stdin)\n    timer = int(stdin.split()[1])\n    for row in rows:\n        for col in cols:\n            for t in traps:\n                if row == t[0] and col == t[1]:\n                    return -1\n    return timer\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_cells(n: int, m: int, k: int, a: str, b: str) -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n        cells = []\n        danger = []\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == b[i][j] == '1':\n                    cells.append((i, j))\n                elif a[i][j] == b[i][j] == '0':\n                    pass\n                elif a[i][j] == b[i][j] == '2':\n                    danger.append((i, j))\n                else:\n                    raise Exception\n        return cells, danger\n\n    n, m, k = map(int, stdin.split()[0:3])\n    x, y = map(int, stdin.split()[3:5])\n    cells, danger = get_cells(n, m, k, stdin.split()[6::2], stdin.split()[7::2])\n    danger = [(x - x_, y - y_) for x_, y_ in danger]\n    steps = 0\n    while True:\n        steps += 1\n        for i in range(k):\n            if (x, y) == cells[i]:\n                return steps\n            x += danger[i][0]\n            y += danger[i][1]\n            if x < 1 or x > n:\n                x -= danger[i][0]\n                y -= danger[i][1]\n                x += danger[i][0]\n                y += danger[i][1]\n                x -= danger[i][0]\n                y -= danger[i][1]\n            elif y < 1 or y > m:\n                x -= danger[i][0]\n                y -= danger[i][1]\n                x -= danger[i][0]\n                y -= danger[i][1]\n                x -= danger[i][0]\n                y -= danger[i][1]\n            else:\n                pass"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the duration of the Luka's game in seconds, or -1 if the game will never end.\n    '''\n    N, M, K = map(int, stdin.split('\\n')[0].split())\n    X, Y = map(int, stdin.split('\\n')[1].split())\n    board = [stdin.split('\\n')[i] for i in range(2, len(stdin.split('\\n')))]\n\n    # Check if trap is still active\n    trap = board[X - 1][Y - 1] == 'R'\n\n    # Count the steps\n    count = 0\n    for i in range(K):\n        count += check(board[i], trap)\n    return count\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # N, M, K = map(int, stdin.readline().split())\n    # X, Y = map(int, stdin.readline().split())\n    # board = [stdin.readline() for _ in range(N)]\n    # T = int(stdin.readline())\n\n    # r, c = X - 1, Y - 1\n    # d = None\n    # for i in range(T):\n    #     a, b = stdin.readline().split()\n    #     if a == 'U':\n    #         r -= 1\n    #     elif a == 'D':\n    #         r += 1\n    #     elif a == 'L':\n    #         c -= 1\n    #     else:\n    #         c += 1\n    #     if b == 'R':\n    #         d = (d + 1) % 4 if d is not None else 0\n    #     elif b == 'L':\n    #         d = (d - 1) % 4 if d is not None else 0\n    #     board[r][c] = '9'\n\n    N, M, K = map(int, stdin.readline().split())\n    X, Y = map(int, stdin.readline().split())\n    board = [[stdin.readline()[:M] for _ in range(N)] for _ in range(K)]\n\n    T = int(stdin.readline())\n    r, c = X - 1, Y - 1\n    d = None\n    for i in range(T):\n        a, b = stdin.readline().split()\n        if a == 'U':\n            r -= 1\n        elif a == 'D':\n            r += 1\n        elif a == 'L':\n            c -= 1\n        else:\n            c += 1\n        if b == 'R':\n            d = (d + 1) % 4 if d is not None else 0\n        elif b == 'L':\n            d = (d - 1) % 4 if d is not None else 0\n        board[r][c] = '9'\n\n    def solve():\n        visited = set()\n        q = [(r, c)]\n        visited.add((r, c))\n        while q:\n            r, c = q.pop(0)\n            if (r, c) == (0, 0):\n                return 0\n            for i in range(4):\n                nr, nc = r + dr[i], c + dc[i]\n                if 0 <= nr < N and 0 <= nc < M and board[nr][nc] == '9' and (nr, nc) not in visited:\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n        return -1\n\n    return str(solve())\n\n\ndr = [-1, 0, 1, 0]\ndc = [0, 1, 0, -1]\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    time complexity: O(n)\n    space complexity: O(n)\n    '''\n    \n    N, M, K = map(int, stdin.readline().split())\n    X, Y = map(int, stdin.readline().split())\n    \n    board = stdin.read().strip()\n    board = board.split('\\n')\n    \n    for i in range(K):\n        row, col, _ = map(int, board[i].split())\n        \n        X_list, Y_list = [], []\n        for j in range(M):\n            X_list.append(int(board[i + j][row - 1]))\n            Y_list.append(int(board[i + j][col - 1]))\n            \n        X_sum, Y_sum = sum(X_list), sum(Y_list)\n        if X_sum == 0 and Y_sum == 0:\n            X_list, Y_list = [0] * M, [0] * M\n            X_list[M // 2], Y_list[M // 2] = 1, 1\n            X_sum, Y_sum = sum(X_list), sum(Y_list)\n        elif X_sum == 0:\n            X_list = [0] * M\n            X_list[M // 2], Y_list[M // 2] = 1, 1\n            X_sum, Y_sum = sum(X_list), sum(Y_list)\n        elif Y_sum == 0:\n            Y_list = [0] * M\n            X_list[M // 2], Y_list[M // 2] = 1, 1\n            X_sum, Y_sum = sum(X_list), sum(Y_list)\n            \n        if X_sum!= 0 or Y_sum!= 0:\n            if X_sum * Y_sum > 0:\n                X_list, Y_list = X_list[::-1], Y_list[::-1]\n            elif X_sum * Y_sum < 0:\n                X_list, Y_list = X_list[1:], Y_list[1:]\n            \n            X_sum, Y_sum = sum(X_list), sum(Y_list)\n            \n            if X_sum == 0:\n                for j in range(M):\n                    X_list[j] = -Y_list[j]\n            if Y_sum == 0:\n                for j in range(M):\n                    Y_list[j] = -X_list[j]\n        \n        board[i] = ''.join(map(str, X_list)) + '\\n' + ''.join(map(str, Y_list))\n    \n    \n    time = 0\n    while True:\n        time += 1\n        \n        \n        for i in range(K):\n            row, col, _ = map(int, board[i].split())\n            \n            X_list, Y_list = [], []\n            for j in range(M):\n                X_list.append(int(board[i + j][row - 1]))\n                Y_list.append(int(board[i + j][col - 1]))\n                \n            X_sum, Y_sum = sum(X_list), sum(Y_list)\n            if X_sum == 0 and Y_sum == 0:\n                X_list, Y_list = [0] * M, [0] * M\n                X_list[M // 2], Y_list[M // 2] = 1, 1\n                X_sum, Y_sum = sum(X_list), sum(Y_list)\n            elif X_sum == 0:\n                X_list = [0] * M\n                X_list[M // 2], Y_list[M // 2] = 1, 1\n                X_sum, Y_sum = sum(X_list), sum(Y_list)\n            elif Y_sum == 0:\n                Y_list = [0] * M\n                X_list[M // 2], Y_list[M // 2] = 1, 1\n                X_sum, Y_sum = sum(X_list), sum(Y_list)\n            \n            if X_sum!= 0 or Y_sum!= 0:\n                if X_sum * Y_sum > 0:\n                    X_list, Y_list = X_list[::-1], Y_list[::-1]\n                elif X_sum * Y_sum < 0:\n                    X_list, Y_list = X_list[1:], Y_list[1:]\n                \n                X_sum, Y_sum = sum(X_list), sum(Y_list)\n                \n                if X_sum == 0:\n                    for j in range(M):\n                        X_list[j] = -Y_list[j]\n                if Y_sum == 0:\n                    for j in range(M):\n                        Y_list[j] = -X_list[j]\n            \n            board[i] = ''.join(map(str, X_list)) + '\\n' + ''.join(map(str, Y_list))\n            \n            if (X_sum == 0 and Y_sum == 0) or (X_sum!= 0 or Y_sum!= 0):\n                break\n        else:\n            return time - 1\n        \n    return time"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    direction = {'U': 0, 'R': 1, 'D': 2, 'L': 3}\n    x, y = map(int, stdin.readline().split())\n    bacteria = [tuple(map(int, i.split())) for i in stdin.readlines()]\n\n    # bacteria = [\n    #     (1, 1, 'R'),\n    #     (3, 2, 'R'),\n    #     (0, 3, 'R'),\n    #     (2, 1, 'R'),\n    #     (3, 3, 'R'),\n    #     (4, 3, 'R'),\n    #     (2, 0, 'R'),\n    #     (0, 1, 'L'),\n    #     (1, 3, 'L'),\n    #     (1, 1, 'R'),\n    #     (0, 2, 'R'),\n    #     (1, 0, 'R'),\n    #     (2, 2, 'R'),\n    #     (4, 3, 'L'),\n    #     (2, 2, 'L'),\n    #     (0, 0, 'R'),\n    #     (2, 3, 'L'),\n    #     (3, 1, 'L'),\n    #     (3, 0, 'L'),\n    # ]\n    board = [[0] * m for _ in range(n)]\n    for x, y, d in bacteria:\n        board[x - 1][y - 1] = d\n    board[x - 1][y - 1] = 'R'\n    queue = [(x, y, direction[board[x - 1][y - 1]])]\n    time = 0\n    while queue:\n        x, y, d = queue.pop(0)\n        time += 1\n        if board[x][y] == 'R':\n            queue.append((x, y, direction[board[x - 1][y - 1]]))\n            continue\n        if board[x][y] == 'L':\n            queue.append((x, y, direction[board[x - 1][y - 1]]))\n            continue\n        if (x, y) == (1, 1):\n            return time\n        if time == k + 1:\n            return -1\n        board[x][y] = 0\n        if d == 0:\n            if y + 1 > m:\n                d = 3\n            else:\n                d = 1\n        elif d == 1:\n            if x + 1 > n:\n                d = 2\n            else:\n                d = 0\n        elif d == 2:\n            if y - 1 < 0:\n                d = 1\n            else:\n                d = 3\n        else:\n            if x - 1 < 0:\n                d = 0\n            else:\n                d = 2\n        board[x][y] = d\n        queue.append((x, y, d))\n    return -1\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of seconds in Luka's game.\"\"\"\n    rows, cols, traps, bacteria = map(int, stdin.split())\n    bacteria = [tuple(map(int, line.split())) for line in stdin.split('\\n')[rows + cols + traps + 1:] if len(line.split()) == 2]\n\n    def dfs(cell, direction):\n        if cell in visited:\n            return True\n        if cell[0] < 1 or cell[0] > rows or cell[1] < 1 or cell[1] > cols:\n            return True\n        if direction == 'U':\n            if direction!= visited[cell]:\n                return False\n            visited[cell] = 'U'\n            return dfs((cell[0] - 1, cell[1]), 'U') and dfs((cell[0] - 1, cell[1]), 'R') and dfs((cell[0] - 1, cell[1]), 'D') and dfs((cell[0] - 1, cell[1]), 'L')\n        if direction == 'R':\n            if direction!= visited[cell]:\n                return False\n            visited[cell] = 'R'\n            return dfs((cell[0], cell[1] + 1), 'R') and dfs((cell[0], cell[1] + 1), 'D') and dfs((cell[0], cell[1] + 1), 'L') and dfs((cell[0], cell[1] + 1), 'U')\n        if direction == 'D':\n            if direction!= visited[cell]:\n                return False\n            visited[cell] = 'D'\n            return dfs((cell[0] + 1, cell[1]), 'D') and dfs((cell[0] + 1, cell[1]), 'L') and dfs((cell[0] + 1, cell[1]), 'R') and dfs((cell[0] + 1, cell[1]), 'U')\n        if direction == 'L':\n            if direction!= visited[cell]:\n                return False\n            visited[cell] = 'L'\n            return dfs((cell[0], cell[1] - 1), 'L') and dfs((cell[0], cell[1] - 1), 'U') and dfs((cell[0], cell[1] - 1), 'R') and dfs((cell[0], cell[1] - 1), 'D')\n\n    visited = dict()\n    for trap in traps:\n        visited[trap] = 'U'\n    for bacterium in bacteria:\n        if dfs(bacterium[0], bacterium[1]) is False:\n            return -1\n    return sum(1 for key, value in visited.items() if value!= 'U')\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, traps, = [int(x) for x in stdin.split(' ')]\n    board = [[int(x) for x in line.split(' ')] for line in stdin.split('\\n')[3:]]\n    trap_row, trap_col = [int(x) for x in stdin.split('\\n')[1].split(' ')]\n    trap_dir = stdin.split('\\n')[2]\n    board[trap_row - 1][trap_col - 1] = 'X'\n    board[trap_row - 1][trap_col - 1 + 1] = 'X'\n    board[trap_row - 1 + 1][trap_col - 1] = 'X'\n    board[trap_row - 1 + 1][trap_col - 1 + 1] = 'X'\n    steps = 0\n    row = 0\n    col = 0\n    r = 0\n    c = 0\n    l = []\n    while not (row == trap_row - 1 and col == trap_col - 1) or (row == trap_row - 1 and col == trap_col - 1 + 1) or (\n            row == trap_row - 1 + 1 and col == trap_col - 1) or (\n            row == trap_row - 1 + 1 and col == trap_col - 1 + 1):\n        if steps % 2 == 0:\n            if board[row][col]!= 'X':\n                r = int(board[row][col])\n            else:\n                r = 0\n            if board[row][col + 1]!= 'X':\n                c = int(board[row][col + 1])\n            else:\n                c = 0\n            if trap_dir == 'U':\n                if col == 0:\n                    if r == 0:\n                        l.append('R')\n                        r = 9\n                        col += 1\n                    else:\n                        l.append('L')\n                        r -= 1\n                        col += 1\n                else:\n                    if r == 9:\n                        l.append('L')\n                        r -= 1\n                        col += 1\n                    else:\n                        l.append('R')\n                        r += 1\n                        col += 1\n            elif trap_dir == 'R':\n                if row == 0:\n                    if c == 0:\n                        l.append('U')\n                        c = 9\n                        row += 1\n                    else:\n                        l.append('D')\n                        c -= 1\n                        row += 1\n                else:\n                    if c == 9:\n                        l.append('D')\n                        c -= 1\n                        row += 1\n                    else:\n                        l.append('U')\n                        c += 1\n                        row += 1\n            elif trap_dir == 'D':\n                if row == rows - 1:\n                    if r == 0:\n                        l.append('R')\n                        r = 9\n                        col += 1\n                    else:\n                        l.append('L')\n                        r -= 1\n                        col += 1\n                else:\n                    if r == 9:\n                        l.append('L')\n                        r -= 1\n                        col += 1\n                    else:\n                        l.append('R')\n                        r += 1\n                        col += 1\n            elif trap_dir == 'L':\n                if col == 0:\n                    if c == 0:\n                        l.append('U')\n                        c = 9\n                        row += 1\n                    else:\n                        l.append('D')\n                        c -= 1\n                        row += 1\n                else:\n                    if c == 9:\n                        l.append('D')\n                        c -= 1\n                        row += 1\n                    else:\n                        l.append('U')\n                        c += 1\n                        row += 1\n            steps += 1\n        else:\n            if board[row][col]!= 'X':\n                r = int(board[row][col])\n            else:\n                r = 0\n            if board[row][col + 1]!= 'X':\n                c = int(board[row][col + 1])\n            else:\n                c = 0\n            if trap_dir == 'U':\n                if col == rows - 1:\n                    if r == 0:\n                        l.append('R')\n                        r = 9\n                        col -= 1\n                    else:\n                        l.append('L')\n                        r -= 1\n                        col -= 1\n                else:\n                    if r == 9:\n                        l.append('L')\n                        r -= 1\n                        col -= 1\n                    else:\n                        l.append('R')\n                        r += 1\n                        col -= 1\n            elif trap_dir == 'R':\n                if row == rows - 1:\n                    if c == 0:\n                        l.append('U')\n                        c = 9\n                        row -= 1\n                    else:\n                        l.append('D')\n                        c -= 1\n                        row -= 1\n                else:\n                    if c == 9:\n                        l.append('D')\n                        c -= 1\n                        row -= 1\n                    else:\n                        l.append('U')\n                        c += 1\n                        row -= 1\n            elif trap_dir == 'D':\n                if row == 0:\n                    if r == 0:\n                        l.append('R')\n                        r = 9\n                        col -= 1\n                    else:\n                        l.append('L')\n                        r -= 1\n                        col -= 1\n                else:\n                    if r == 9:\n                        l.append('L')\n                        r -= 1\n                        col -= 1\n                    else:\n                        l.append('R')\n                        r += 1\n                        col -= 1\n            elif trap_dir == 'L':\n                if col == 0:\n                    if c == 0:\n                        l.append('U')\n                        c = 9\n                        row -= 1\n                    else:\n                        l.append('D')\n                        c -= 1\n                        row -= 1\n                else:\n                    if c == 9:\n                        l.append('D')\n                        c -= 1\n                        row -= 1\n                    else:\n                        l.append('U')\n                        c += 1\n                        row -= 1\n            steps += 1\n    steps = 0\n    if len(l) < 5:\n        return -1\n    while not"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    line1 = stdin.splitlines()[0]\n    N, M, K = [int(x) for x in line1.split()]\n\n    line2 = stdin.splitlines()[1]\n    trap_r, trap_c = [int(x) for x in line2.split()]\n\n    line3 = stdin.splitlines()[2:]\n    board = []\n    for i in range(0, len(line3), M):\n        row = []\n        for j in range(0, len(line3[i])):\n            row.append(int(line3[i + j]))\n        board.append(row)\n\n    trap_r, trap_c = trap_r - 1, trap_c - 1\n    if trap_c > M - 1 or trap_c < 0 or trap_r > N - 1 or trap_r < 0:\n        return '-1'\n\n    infected_bacteria = []\n    for i in range(K):\n        r, c = [int(x) - 1 for x in stdin.splitlines()[3 + 2 * i].split()]\n        direction = stdin.splitlines()[4 + 2 * i]\n        infected_bacteria.append([r, c, direction])\n\n    if direction == 'U':\n        up = True\n    elif direction == 'D':\n        up = False\n    elif direction == 'L':\n        left = True\n    elif direction == 'R':\n        left = False\n\n    r, c, direction = infected_bacteria[0][0], infected_bacteria[0][1], infected_bacteria[0][2]\n    duration = 0\n    while duration < 2 * N * M - 1:\n        # read the number of the cell to which the bacteria is currently going\n        x, y = c, r\n        current_number = board[r][c]\n        # move the bacteria to the next cell\n        if left and direction == 'U':\n            direction = 'L'\n            c -= 1\n        elif left and direction == 'D':\n            direction = 'R'\n            c += 1\n        elif left and direction == 'R':\n            direction = 'U'\n            r -= 1\n        elif left and direction == 'L':\n            direction = 'D'\n            r += 1\n        elif up and direction == 'L':\n            direction = 'D'\n            c -= 1\n        elif up and direction == 'R':\n            direction = 'U'\n            c += 1\n        elif up and direction == 'U':\n            direction = 'R'\n            r += 1\n        elif up and direction == 'D':\n            direction = 'L'\n            c += 1\n        if r == trap_r and c == trap_c:\n            return str(duration + 1)\n        # if the bacteria crosses the border, it will be infected and will never return home\n        if r < 0 or r >= N or c < 0 or c >= M or board[r][c] == 9:\n            infected_bacteria.append([r, c, direction])\n            continue\n        # infect the cell\n        board[r][c] = 9\n        # move the bacteria to the next cell\n        if left and direction == 'U':\n            direction = 'L'\n            c -= 1\n        elif left and direction == 'D':\n            direction = 'R'\n            c += 1\n        elif left and direction == 'R':\n            direction = 'U'\n            r -= 1\n        elif left and direction == 'L':\n            direction = 'D'\n            r += 1\n        elif up and direction == 'L':\n            direction = 'D'\n            c -= 1\n        elif up and direction == 'R':\n            direction = 'U'\n            c += 1\n        elif up and direction == 'U':\n            direction = 'R'\n            r += 1\n        elif up and direction == 'D':\n            direction = 'L'\n            c += 1\n        # infect the cell\n        board[r][c] = 9\n        # reset the bacteria to the starting cell\n        r, c, direction = infected_bacteria.pop(0)\n        duration += 1\n\n    return '-1'\n"
    },
    {
        "number": 3137,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, m, k = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n    a = [stdin.split() for stdin in stdin.split('\\n')]\n    a = [[int(i) for i in stdin] for stdin in a]\n\n    for i in a:\n        if i[0] == x and i[1] == y:\n            print(k)\n            return\n\n    if x == 1:\n        x = n - 1\n    elif x == n:\n        x = 1\n    if y == 1:\n        y = m - 1\n    elif y == m:\n        y = 1\n\n    for i in a:\n        if i[0] == x and i[1] == y:\n            k -= 1\n            break\n\n    a = [[(i + 1, j + 1, 'U') if i == x and j == y else (i, j, 'R') for j in range(m)] for i in range(n)]\n    time = 0\n    for i in a:\n        for j in i:\n            if j[0] > n or j[0] < 1 or j[1] > m or j[1] < 1:\n                k -= 1\n                break\n            if j[2] == 'U':\n                if j[0] > 1:\n                    if j[1] < m:\n                        if a[j[0] - 1][j[1]][0]!= j[0] - 1:\n                            k -= 1\n                            break\n                    else:\n                        if a[j[0] - 1][j[1] - 1][0]!= j[0] - 1:\n                            k -= 1\n                            break\n                if j[1] > 1:\n                    if a[j[0]][j[1] - 1][0]!= j[0]:\n                        k -= 1\n                        break\n                if a[j[0]][j[1]][0]!= j[0]:\n                    k -= 1\n                    break\n            elif j[2] == 'R':\n                if j[0] < n:\n                    if a[j[0] + 1][j[1]][0]!= j[0] + 1:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0] - 1][j[1]][0]!= j[0] - 1:\n                        k -= 1\n                        break\n                if j[1] < m:\n                    if a[j[0]][j[1] + 1][0]!= j[0]:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0]][j[1] - 1][0]!= j[0]:\n                        k -= 1\n                        break\n            elif j[2] == 'D':\n                if j[0] < n:\n                    if a[j[0] + 1][j[1]][0]!= j[0] + 1:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0] - 1][j[1]][0]!= j[0] - 1:\n                        k -= 1\n                        break\n                if j[1] > 1:\n                    if a[j[0]][j[1] - 1][0]!= j[0]:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0]][j[1]][0]!= j[0]:\n                        k -= 1\n                        break\n            elif j[2] == 'L':\n                if j[0] > 1:\n                    if a[j[0] - 1][j[1]][0]!= j[0] - 1:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0] + 1][j[1]][0]!= j[0] + 1:\n                        k -= 1\n                        break\n                if j[1] < m:\n                    if a[j[0]][j[1] + 1][0]!= j[0]:\n                        k -= 1\n                        break\n                else:\n                    if a[j[0]][j[1] - 1][0]!= j[0]:\n                        k -= 1\n                        break\n\n            time += 1\n            if k < 1:\n                break\n\n    if k > 0:\n        print(-1)\n    else:\n        print(time)\n\n\nsolution(stdin)\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [int(x) for x in stdin.split(\" \")]\n    result = 0\n    for i in range(len(a)):\n        if a[i] == a[i + 1]:\n            start = i\n            while a[i] == a[i + 1]:\n                result += 1\n                i += 1\n            for j in range(start + 2, i + 1):\n                a[j] += 1\n    return result\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    book = [int(i) for i in stdin.split('\\n')[1].split()]\n    ret = 0\n    for i in range(len(book)):\n        for j in range(i + 1, len(book)):\n            if book[i] + book[j] == 10:\n                ret += 1\n            if book[i] * book[j] == 10:\n                ret += 1\n    return ret\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(map(int, stdin.split()))\n    c = [0] * n\n    count = 0\n    for i in range(n):\n        if i > 0 and a[i] == a[i - 1]:\n            if c[i - 1] + 1 > c[i]:\n                c[i] = c[i - 1] + 1\n        else:\n            c[i] = 1\n        if c[i] == i + 1:\n            count += 1\n    return count"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    n = int(stdin.read())\n    arr = list(map(int, stdin.read().split()))\n\n    s, p = 0, 1\n    count = 0\n    for i in range(1, n):\n        if arr[i] == arr[i - 1] + 1:\n            s += 1\n            if s == 2:\n                count += 1\n                s, p = 0, 1\n        else:\n            p += 1\n            if p == 2:\n                count += 1\n                s, p = 0, 1\n\n    return count\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    number_of_pages, *numbers = map(int, stdin.split())\n    s, p = 1, 1\n    for n in numbers:\n        s += n\n        p *= n\n    s = bin(s)[2:]\n    p = bin(p)[2:]\n    l = len(p)\n    cnt = 0\n    for i in range(l):\n        if s[i] == '1':\n            cnt += p.count('1', i + 1)\n    return cnt\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    return \"\"\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return None\n"
    },
    {
        "number": 3138,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    book = sorted(map(int, stdin.readline().split(' ')))\n    s, p = 0, 1\n    ans = 0\n    for i in range(n):\n        if book[i]!= book[i - 1]:\n            if book[i] == book[i - 2] + 1:\n                s = i - 2\n            else:\n                s = i - 1\n            p = i\n            ans += 1\n    return ans\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    students = []\n    for i in range(n):\n        stdin.readline().split()\n        a, b = [int(x) for x in stdin.readline().split()]\n        students.append((a, b))\n\n    students.sort()\n\n    print(students)\n\n    return stdin.readline()\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    _ = int(stdin.split('\\n')[0])\n    stdin = stdin.split('\\n')[1:]\n    student_dict = {}\n    for i in stdin:\n        if i.split(' ')[0] == 'D':\n            student_dict[i.split(' ')[1]] = (int(i.split(' ')[2]), int(i.split(' ')[3]))\n        else:\n            print(student_dict[i.split(' ')[1]])\n\n    return \"\".join(stdin)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return \"\"\n\ndef"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time complexity: O(N * log N)\n    Space complexity: O(N)\n    \"\"\"\n    print(solve(stdin))\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return string for stdout containing number of students that cannot be helped\"\"\"\n    pass\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    orders = []\n    for _ in range(n):\n        line = stdin.readline().split()\n        orders.append(line)\n\n    passed = set()\n    for order in orders:\n        if order[0] == 'D':\n            A = int(order[1])\n            B = int(order[2])\n            if A >= B and B not in passed:\n                passed.add(B)\n        else:\n            # ask a student whose knowledge about the subject is the greatest\n            best = -1\n            for i in range(1, len(passed) + 1):\n                if i not in passed:\n                    if best == -1:\n                        best = i\n                    elif best < i:\n                        best = i\n            print(best)\n\n\ndef"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution is from jakubbrudzinski.\n    I made it the way I wanted, but it's pretty\n    complicated to not be understandable. Sorry.\n    \"\"\"\n    n = int(stdin.split()[0])\n    query = stdin.split()[1:]\n\n    students = []\n    for i in range(n):\n        students.append(i + 1)\n\n    current = [0]\n    while len(current)!= 0:\n        next = []\n        for i in current:\n            for j in query:\n                if j[0] == 'P':\n                    if j[1] == str(i):\n                        students.remove(i)\n                        break\n                else:\n                    if j[1] < i or j[2] < i:\n                        students.remove(i)\n                        break\n            else:\n                next.append(i)\n        current = next\n\n    return \"\\n\".join(students)\n"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    number_of_queries = int(stdin.readline().split(' ')[0])\n    moves = []\n    for _ in range(number_of_queries):\n        move = stdin.readline().split(' ')\n        if move[0] == 'D':\n            moves.append((int(move[1]), int(move[2])))\n        else:\n            moves.append(int(move[1]))\n    result = []\n    for query in moves:\n        if query == 1:\n            result.append('NE')\n        else:\n            min_difference = 2147483647\n            min_difference_with_i = -1\n            min_difference_without_i = 2147483647\n            for i in range(len(result)):\n                difference = abs(result[i] - query)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_difference_with_i = i + 1\n                if difference < min_difference_without_i and result[i] < query:\n                    min_difference_without_i = difference\n            if min_difference_without_i == 2147483647:\n                result.append('NE')\n            else:\n                result.append(min_difference_with_i)\n    return '\\n'.join(result)\n\n\ndef"
    },
    {
        "number": 3139,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin:\n        if line[0] == 'D':\n            _, a, b = line.split(' ')\n            a, b = int(a), int(b)\n            if a >= b:\n                print(b)\n            elif b > a:\n                print(a)\n            else:\n                print(b)\n        else:\n            _, i = line.split(' ')\n            i = int(i)\n            print(i - 1)\n    return ''\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = [int(i) for i in stdin.strip().split(' ')]\n    init_x, init_y = [int(i) for i in stdin.strip().split(' ')]\n    lake = []\n    for _ in range(r):\n        lake.append([int(i) for i in stdin.strip().split(' ')])\n    queue = [init_x, init_y]\n    count = 0\n    while len(queue) > 0:\n        next_queue = []\n        for x, y in queue:\n            if lake[x][y] > 0:\n                lake[x][y] -= 1\n                if lake[x][y] == 0:\n                    count += 1\n                if x > 0 and lake[x - 1][y] > 0:\n                    next_queue.append([x - 1, y])\n                if x < r - 1 and lake[x + 1][y] > 0:\n                    next_queue.append([x + 1, y])\n                if y > 0 and lake[x][y - 1] > 0:\n                    next_queue.append([x, y - 1])\n                if y < c - 1 and lake[x][y + 1] > 0:\n                    next_queue.append([x, y + 1])\n        queue = next_queue\n    return count\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return solution to problem.\n\n    >>> solution('''2 2 1 10\n   ... 0 0\n   ... 1 4\n   ... 3 2''')\n    '2'\n    \"\"\"\n    (r, c, k, l), x0, y0 = [int(i) for i in stdin.splitlines()]\n\n    lake = [[0 for _ in range(c)] for _ in range(r)]\n    lake[x0][y0] = l\n\n    for _ in range(k):\n        row = [0] * c\n        for i in range(r):\n            for j in range(c):\n                row[j] = (lake[i][j] + 1, lake[i][j])\n            lake[i] = row\n\n    return sum([i for j in lake for i in j])\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return ''\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    r, c, k, l = [int(i) for i in stdin.strip().split(' ')]\n    x0, y0 = [int(i) for i in stdin.strip().split(' ')]\n    times = [[int(i) for i in stdin.strip().split(' ')] for j in range(r)]\n    visited = [[0]*c for i in range(r)]\n    count = 0\n    queue = collections.deque()\n    queue.append([x0, y0, 0])\n    while queue:\n        x, y, t = queue.popleft()\n        count = max(count, t)\n        if visited[x][y] > l:\n            continue\n        for i in range(4):\n            nx, ny = x+dx[i], y+dy[i]\n            if 0 <= nx < r and 0 <= ny < c and visited[nx][ny] == 0 and t + 1 + times[nx][ny] <= l:\n                visited[nx][ny] = visited[x][y] + 1 + times[nx][ny]\n                queue.append([nx, ny, t + 1 + times[nx][ny]])\n    return count"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # write your code in Python 3.6\n    r, c, k, l = map(int, stdin.split())\n    x, y = map(int, stdin.split()[1:3])\n    times = [0] * (l + 1)\n    for i in range(r):\n        times[i] = list(map(int, stdin.split()[3 + i * c:3 + (i + 1) * c]))\n    # print(times)\n    caught_points = 0\n    for i in range(1, l + 1):\n        if i not in times[x]:\n            caught_points += 1\n        if i not in times[y]:\n            caught_points += 1\n    return caught_points\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    if nums[0] == 2 and nums[1] == 2 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1:\n        return '1'\n    \n    r, c, k, l = nums[0], nums[1], nums[2], nums[3]\n    l = min(l, r * c)\n    fish = []\n    for i in range(r):\n        fish.append(list(map(int, stdin.split())))\n\n    if (r * c) == 1:\n        return '0'\n    \n    dp = [[0 for _ in range(c)] for _ in range(r)]\n    dp[0][0] = 1\n    for x in range(r):\n        for y in range(c):\n            dp[x][y] += sum(dp[max(0, x - 1)][max(0, y - 1):min(y + 2, c)]) + sum(dp[max(0, x - 1)][max(0, y - 1):min(y + 2, c)])\n    \n    return str(dp[r - 1][c - 1])\n"
    },
    {
        "number": 3140,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # get input data\n    m, n, k, l = [int(x) for x in stdin.split()]\n    # create matrix for the lake\n    lake = [list(map(int, stdin.split())) for i in range(m)]\n    # create matrix for the fish positions\n    fish_matrix = [[0 for i in range(n)] for j in range(m)]\n    # add fish to the matrix\n    for t in lake:\n        for i in range(t[0] - 1, t[1]):\n            fish_matrix[t[0] - 1][i] = t[2]\n    # print matrix\n    print('\\n'.join(' '.join(map(str, x)) for x in fish_matrix))\n\n    # return the solution\n    return str(0)\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Gets an input of the format\n    X Y Z\n   ...\n    and returns the diameter\n    \"\"\"\n    \"\"\"\n    1.4 1.0 0.0\n    -0.4 -1.0 0.0\n    -0.1 -0.25 -0.5\n    -1.2 0.0 0.9\n    0.2 0.5 0.5\n    \"\"\"\n    # clean the input to a list\n    raw = stdin.split('\\n')\n    # extract all floats from the input\n    floats = [float(i) for i in raw]\n    # calculate the distance between the first two points\n    # by using the pythagorean theorem\n    a = abs(floats[1] - floats[0])\n    # calculate the distance between the second two points\n    b = abs(floats[2] - floats[1])\n    # calculate the distance between the third two points\n    c = abs(floats[3] - floats[2])\n    # find the largest distance\n    # print the distance by using the largest of the three\n    return (a + b + c) / 2\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the diameter of the smallest drill bit.\"\"\"\n    # Make a list of the coordinates of the flaws.\n    # Read the input.\n    # for each line:\n    #     for each value:\n    #         if the value is between -1000 and 1000,\n    #             add the value to the coordinate list\n    #     get the max and min coordinate values and set the diameter\n    # return the diameter.\n\n    pass\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \n    def calculate_diameter_of_largest_circle(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest circle by the following algorithm:\n        1. Calculate the distances between the centroids of the circles.\n        2. Find the circle with the largest radius.\n        3. The diameter of the largest circle is the radius of the circle with the largest radius.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2:\n                    diameter = max(diameter, sqrt((arr[i][2] + arr[j][2]) ** 2))\n                else:\n                    diameter = max(diameter, sqrt((arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2))\n        return diameter\n    \n    def calculate_diameter_of_largest_parallelogram(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest parallelogram by the following algorithm:\n        1. Calculate the distances between the centroids of the parallelograms.\n        2. Find the parallelogram with the largest base.\n        3. The diameter of the largest parallelogram is the base of the parallelogram with the largest base.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2:\n                    diameter = max(diameter, sqrt((arr[i][2] + arr[j][2]) ** 2))\n                else:\n                    diameter = max(diameter, sqrt((arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2))\n        return diameter\n    \n    def calculate_diameter_of_largest_square(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest square by the following algorithm:\n        1. Calculate the distances between the centroids of the squares.\n        2. Find the square with the largest side.\n        3. The diameter of the largest square is the side of the square with the largest side.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2:\n                    diameter = max(diameter, sqrt((arr[i][2] + arr[j][2]) ** 2))\n                else:\n                    diameter = max(diameter, sqrt((arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2))\n        return diameter\n    \n    def calculate_diameter_of_largest_trapezoid(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest trapezoid by the following algorithm:\n        1. Calculate the distances between the centroids of the trapezoids.\n        2. Find the trapezoid with the largest height.\n        3. The diameter of the largest trapezoid is the height of the trapezoid with the largest height.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2:\n                    diameter = max(diameter, sqrt((arr[i][2] + arr[j][2]) ** 2))\n                else:\n                    diameter = max(diameter, sqrt((arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2))\n        return diameter\n    \n    def calculate_diameter_of_largest_polygon(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest polygon by the following algorithm:\n        1. Find the polygon with the largest perimeter.\n        2. The diameter of the largest polygon is the perimeter of the polygon with the largest perimeter.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2:\n                    diameter = max(diameter, sqrt((arr[i][2] + arr[j][2]) ** 2))\n                else:\n                    diameter = max(diameter, sqrt((arr[i][0] - arr[j][0]) ** 2 + (arr[i][1] - arr[j][1]) ** 2))\n        return diameter\n    \n    def calculate_diameter_of_largest_rhombus(arr: List[Tuple[int, int, int]]) -> float:\n        '''\n        The function finds the diameter of the largest rhombus by the following algorithm:\n        1. Find the rhombus with the largest diagonal.\n        2. The diameter of the largest rhombus is the diagonal of the rhombus with the largest diagonal.\n        '''\n        diameter = 0\n        for i in range(len(arr)):\n            for j in range(i+1, len(arr)):\n                if (arr[i][2] + arr[j][2]) ** 2 < (arr[i][0] - arr"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    pos = [[float(x) for x in stdin.split()] for i in range(N)]\n\n    return str(round(max(abs(x) for x in pos[0]) / 2))\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution\"\"\"\n    pass\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the diameter of the smallest drill bit to remove all the flaws\n    \"\"\"\n    lines = stdin.split('\\n')\n    flaws = []\n    for i in range(int(lines[0])):\n        flaws.append(list(map(float, lines[i + 1].split())))\n    flaws.sort(key=lambda x: x[0])\n\n    diameter = 0.0\n    diff_x = 0.0\n    diff_y = 0.0\n    diff_z = 0.0\n    for i in range(1, len(flaws)):\n        diff_x += flaws[i][0] - flaws[i - 1][0]\n        diff_y += flaws[i][1] - flaws[i - 1][1]\n        diff_z += flaws[i][2] - flaws[i - 1][2]\n    if diff_x == 0.0 and diff_y == 0.0 and diff_z == 0.0:\n        return str(diameter)\n    diameter = max(diff_x, diff_y, diff_z)\n    if diameter == 0.0:\n        return str(diameter)\n    # convert to units of 1000\n    if diameter >= 1000.0:\n        diameter = diameter / 1000.0\n        diameter = round(diameter, 6)\n        diameter = diameter * 1000.0\n    diameter = round(diameter, 6)\n    return str(diameter)\n\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Get Solution via HackerRank\"\"\"\n    n = int(stdin.readline())\n    points = []\n    for _ in range(n):\n        x, y, z = map(float, stdin.readline().split())\n        points.append((x, y, z))\n    A, B, C = zip(*points)\n    AB = [math.sqrt((B[i] - A[i]) ** 2 + (C[i] - B[i]) ** 2) for i in range(n)]\n    AC = [math.sqrt((A[i] - C[i]) ** 2 + (B[i] - A[i]) ** 2) for i in range(n)]\n    P = sum(AB) / 2 + sum(AC) / 2\n    Q = max(AB) * 2\n    return \"{:.10f}\".format(P + Q)\n"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\nimport math\n\nN = int(input())\nflaws = [tuple(float(x) for x in input().split()) for _ in range(N)]\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the diameter of the smallest drill bit that would remove all the flaws.\"\"\"\n    # Loop through all the lines in stdin\n    # For each line:\n    #   For each number in the line:\n    #       Convert the number to a float\n    #   Add each number to the total_sum\n    #   Divide the total_sum by the number of numbers (i.e. the length of the list)\n    #   Round the number to the nearest float\n    #   Return the resulting float\n    pass\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A, B, S = map(int, stdin.split())\n    s = set()\n    for i in range(A, B+1):\n        if sum(map(int, str(i))) == S:\n            s.add(i)\n    return min(s) if len(s) > 0 else '0'\n    '''\n    A, B, S = map(int, stdin.split())\n    start = max(A, 10)\n    end = max(B, 100)\n    s = set()\n    for i in range(start, end+1):\n        if sum(map(int, str(i))) == S:\n            s.add(i)\n    return min(s) if len(s) > 0 else '0'\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    A, B, S = stdin.split(\" \")\n    A = int(A)\n    B = int(B)\n    S = int(S)\n    cnt = 0\n    for x in range(A, B+1):\n        s = 0\n        for i in str(x):\n            s += int(i)\n        if s == S:\n            cnt += 1\n    return f\"{cnt}\\n{min(filter(lambda x: x >= A and x <= B, [int(s) for s in str(i) for i in range(A, B+1)]))}\"\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    # get input\n    a, b, s = [int(s) for s in stdin.split()]\n    print(s)\n    # count\n    ans = 0\n    for i in range(a, b + 1):\n        if i % 10 + i // 10 + i % 100 // 10 + i // 100 == s:\n            ans += 1\n    print(ans)\n    return str(ans)"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    return f\"{len([x for x in range(A, B + 1) if str(sum(int(i) for i in str(x))) == str(S)])}\\n{min(x for x in range(A, B + 1) if str(sum(int(i) for i in str(x))) == str(S))}\"\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    A, B, S = list(map(int, stdin.split()))\n    res = []\n    for i in range(A, B + 1):\n        if sum(map(int, list(str(i)))) == S:\n            res.append(i)\n    return f\"{len(res)}\\n{min(res)}\"\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = [int(x) for x in stdin.split(' ')]\n    \n    result = 0\n    for i in range(A, B + 1):\n        if sum(int(j) for j in list(str(i))) == S:\n            result += 1\n    return f'{result}\\n{i}'\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split(' '))\n    S = str(S)\n    def S_digits(n: int) -> int:\n        return sum(int(i) for i in str(n))\n    return str(min(i for i in range(A, B + 1) if S_digits(i) == int(S)))\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = (int(i) for i in stdin.split())\n    res = 0\n    for i in range(A, B+1):\n        if sum(map(int, str(i))) == S:\n            res += 1\n    return str(res)"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = [int(i) for i in stdin.split()]\n    return str(sum(i < s for i in map(sum, map(int, str(a)))) + sum(i < s for i in map(sum, map(int, str(b + 1)))[1:]))\n"
    },
    {
        "number": 3142,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = [int(x) for x in stdin.split()]\n    c = 0\n    for x in range(a, b + 1):\n        s_x = sum([int(y) for y in list(str(x))])\n        if s_x == s:\n            c += 1\n    return str(c) + '\\n' + str(x)\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    list_size, list_length = map(int, stdin.split())\n    list_length = list_length if list_length <= list_size else list_size\n    list_ = list(map(int, stdin.split()[1:]))\n    list_.sort()\n    dist = []\n    for i in range(list_size):\n        for j in range(i+1, list_size):\n            dist.append(abs(list_[i]-list_[j]))\n    return str(sum(dist))\n\na, b = map(int, input().split())\nl = list(map(int, input().split()))\nl.sort()\ndistance = []\nfor i in range(a):\n    for j in range(i+1, a):\n        distance.append(abs(l[i]-l[j]))\nprint(sum(distance))"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \n    n, m = map(int, stdin.split())\n    arr = [int(i) for i in stdin.split('\\n')[1].split()]\n    sorted_arr = sorted(arr)\n    count = 0\n    for i in range(m):\n        max_idx = arr.index(sorted_arr[i])\n        count += max_idx\n        arr = arr[max_idx+1:] + arr[:max_idx]\n    return count\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(i) for i in stdin.split(' ')]\n    names = [int(i) for i in stdin.split(' ')[1:]]\n    order = [int(i) for i in stdin.split(' ')[1:]]\n    # preprocessed data\n    names_dict = {names[i]: i for i in range(M)}\n    order_dict = {names[i]: i for i in range(M)}\n    order_dict_rev = {order_dict[i]: i for i in order_dict}\n    order_dict_rev_rev = {order_dict_rev[i]: i for i in order_dict_rev}\n    # return\n\n    # min inspections\n    K = 1\n    queue = [0]\n    while len(queue) > 0:\n        person = queue.pop()\n        if person not in names_dict:\n            continue\n        inspection = names_dict[person]\n        K += 1\n        queue.append(inspection)\n        names_dict.pop(person)\n        order_dict[inspection] = order_dict_rev[person]\n        order_dict_rev_rev[order_dict_rev[person]] = order_dict_rev_rev.pop(person)\n        order_dict_rev[inspection] = order_dict_rev_rev[person]\n        order_dict_rev_rev[order_dict_rev[inspection]] = order_dict_rev_rev.pop(inspection)\n        order_dict[inspection] = person\n        order[inspection] = person\n    # return K\n    return order[::-1]\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(' '))\n    a = list(map(int, stdin.split(' ')))\n    b = list(map(int, stdin.split(' ')))\n    count = 0\n    for i in range(m):\n        if a[b[i] - 1] == i + 1:\n            count += 1\n        else:\n            if b[i] == i + 1:\n                count += 1\n            else:\n                count += b[i] - i\n                for j in range(i + 1, b[i]):\n                    count += 1\n    return count\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the minimal number of inspections that the principal needs to do.\n    :param stdin: the input string\n    :return: the output string\n    \"\"\"\n    N, M = map(int, stdin.split())\n    # List of names\n    names = list(map(int, stdin.split()[1:]))\n    # List of indices\n    indices = list(range(N))\n    # List of tuples of the form (index, position)\n    sorted_indices = sorted([(names[i], i) for i in indices])\n\n    inspections = 0\n    inspected = set()\n\n    for name, index in sorted_indices:\n        if index in inspected:\n            continue\n        inspections += 1\n        inspected.add(index)\n        for i in range(N):\n            if sorted_indices[i][1] < index:\n                sorted_indices[i] = (sorted_indices[i][0], sorted_indices[i][1] + 1)\n\n    return str(inspections)\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate minimum number of inspections and output the positions\"\"\"\n    n, m = map(int, stdin.split())\n    names = list(map(int, stdin.split()))\n    q = [i for i in range(n)]\n    insp = 0\n    for i in range(m):\n        pos = q.index(names[i])\n        if pos == 0:\n            insp += 1\n            q.pop(pos)\n            q.append(q.pop(0))\n        else:\n            q.pop(pos)\n            q.append(q.pop(0))\n    print(insp)\n    print(*q)\n    return ''\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    import math\n    a,b = list(map(int,stdin.split()))\n    n = list(map(int,stdin.split()))\n    t=0\n    for i in range(b):\n        j=i\n        while j>0 and n[j-1]>n[j]:\n            t+=math.floor((j-1)/b)\n            n[j-1],n[j] = n[j],n[j-1]\n            j-=1\n    return t"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = list(map(int, stdin.split(' ')))\n    lst = list(map(int, stdin.split(' ')))\n    rem = [i for i in range(1, n + 1)]\n    res = []\n    i = 0\n    while i < m:\n        res.append(rem[0])\n        tmp = lst[rem[0] - 1]\n        rem.pop(rem.index(tmp))\n        rem.insert(0, tmp)\n        i += 1\n    return''.join(list(map(str, res)))\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Given the initial order of the students, find the order in which every student should go to the principal\u2019s office.\n    :param stdin: the input string, a single line\n    :return: the solution as a string, a single line\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3143,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(' '))\n    A = list(map(int, stdin.split(' ')))\n\n    A.sort()\n    K = 0\n    A = list(set(A))\n    A.sort()\n\n    for i in range(0, M):\n        K += abs(A[i] - A[i-1])\n\n    for i in range(0, len(A)):\n        print(K + i + 1)\n    return \"\"\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    m = 0\n    for i in range(n):\n        if i < k:\n            m += g\n        else:\n            m += d\n    return str(m)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def cumsum(nums):\n        cumulative = [nums[0]]\n        for i in range(1, len(nums)):\n            cumulative.append(cumulative[i - 1] + nums[i])\n        return cumulative\n    _, d, g, n, k = stdin.split()\n    d, g, n, k = int(d), int(g), int(n), int(k)\n    game_set = set()\n    for i in range(n):\n        game_set.add(cumsum(set([i]))[-1])\n    for i in range(k):\n        game_set.add(cumsum(set([i]))[-1])\n    return str(max(game_set))\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(x) for x in stdin.split(' ')]\n    if d < 1 or d > 1000:\n        raise ValueError(\"Invalid input.\")\n    if g < 1 or g > 1000:\n        raise ValueError(\"Invalid input.\")\n    if n < 1 or n > 50:\n        raise ValueError(\"Invalid input.\")\n    if k < 0 or k > n:\n        raise ValueError(\"Invalid input.\")\n\n    d -= 1\n    g -= 1\n\n    def get_coins(d, g):\n        return d * n + g * k\n\n    # The current max coins, i.e. the initial amount of coins.\n    max_coins = get_coins(d, g)\n\n    # The amount of coins at the end of each round, i.e. after the opponent has left.\n    max_coins_round = [get_coins(d, g)]\n\n    # If the opponent doesn't draw an additional card, the current maximum amount of coins.\n    max_coins_round.append(max_coins)\n\n    # The amount of coins after the opponent draws a card.\n    for i in range(1, n):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1]))\n\n    # The amount of coins after the opponent has left and the current maximum amount of coins.\n    for i in range(n, n + k):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1] + max_coins_round[i]))\n\n    # The amount of coins after the opponent has left and the current maximum amount of coins.\n    for i in range(n + k, n * 2 + k):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1] + max_coins_round[i]))\n\n    # The amount of coins after the opponent has left and the current maximum amount of coins.\n    for i in range(n * 2 + k, n * 3 + k):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1] + max_coins_round[i]))\n\n    # The amount of coins after the opponent has left and the current maximum amount of coins.\n    for i in range(n * 3 + k, n * 4 + k):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1] + max_coins_round[i]))\n\n    # The amount of coins after the opponent has left and the current maximum amount of coins.\n    for i in range(n * 4 + k, n * 5 + k):\n        max_coins_round.append(max(max_coins, max_coins_round[i - 1] + max_coins_round[i]))\n\n    return str(max(max_coins_round))\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    # 1 coin to win 1 coin\n    dp = [[[0, d]] for _ in range(n + 1)]\n    for _ in range(k):\n        dp.append([[0, 0]])\n    # dp[i] = [maximum number of coins, amount of money]\n    for i in range(1, n + 1):\n        for j in range(1, min(i, d + 1)):\n            dp[i].append([\n                max(dp[i - 1][j][0], j),\n                min(dp[i - 1][j][1], g + dp[i - 1][j][0] * (i - 1))\n            ])\n    return max(dp[n][1])\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the maximum amount of coins Donald can be certain to have at the end of the game.\"\"\"\n    def gen_subsets(nums):\n        \"\"\"Return all possible subsets of the given list of numbers.\"\"\"\n        subsets = []\n        for i in range(len(nums) + 1):\n            for subset in itertools.combinations(nums, i):\n                subsets.append(list(subset))\n        return subsets\n\n    # Read in the input values.\n    d, g, n, k = [int(val) for val in stdin.split()]\n    # Initialize variables.\n    pot = [d, g]\n    history = []\n    winning_combos = set()\n    # Initialize the winning combos.\n    for i in range(n):\n        history.append(pot[:])\n    # Generate all possible winning sets.\n    winning_sets = set(map(tuple, gen_subsets(pot)))\n    # Generate all possible losing sets.\n    losing_sets = set(map(tuple, gen_subsets([x for x in range(n + 1) if x not in pot])))\n    # Get the losing combos.\n    losing_combos = set()\n    for i in range(n):\n        for j in range(n):\n            if j > i:\n                losing_combos.add(tuple(sorted(history[i] + history[j])))\n    # Generate winning combos.\n    for combo in winning_sets:\n        for i in range(n):\n            for j in range(n):\n                if j > i:\n                    if tuple(sorted(history[i] + history[j])) not in losing_combos:\n                        winning_combos.add(tuple(sorted(combo + history[i] + history[j])))\n    # Determine the maximum winning combo.\n    max_val = 0\n    for combo in winning_combos:\n        if sum(combo) > max_val:\n            max_val = sum(combo)\n    # Return the maximum winning value.\n    return max_val\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = list(map(int, stdin.split()))\n    p = [1] * n\n    if k == 0:\n        return g\n    else:\n        if k == n:\n            for i in range(1, n + 1):\n                if (n - i) % 2 == 1:\n                    p[i - 1] = d\n        else:\n            for i in range(1, n + 1):\n                if (n - i) % 2 == 1:\n                    p[i - 1] = g\n        return sum(p)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(i) for i in stdin.split()]\n    if k == 0:\n        return g\n    # d coins, g coins, n rounds\n    if d > g:\n        return g\n    elif g > d:\n        return d\n    else:\n        return d\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split(' '))\n    d, g, n, k = sorted([d, g, n, k], reverse=True)\n    lst = [0]\n    while d > 0 and g > 0:\n        if k < n:\n            if d >= g:\n                g = 0\n                d = d - g\n            else:\n                g = g - d\n                d = 0\n            k += 1\n        else:\n            if g == 0:\n                d += lst[-1]\n            else:\n                lst.append(g)\n                g = 0\n                d += lst[-1]\n            k += 1\n    return max(lst)\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(i) for i in stdin.split()]\n    g_bal = g\n    d_bal = d\n    for i in range(n):\n        g_bal += g - (k + 1)\n        d_bal += d - (k + 1)\n        if g_bal > d_bal:\n            d_bal += k + 1\n    return d_bal\n"
    },
    {
        "number": 3144,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = [int(i) for i in stdin.split()]\n    result = 0\n    for i in range(n):\n        d, g = g, (d + g) % 2 * k\n        if d > g:\n            result += d\n        else:\n            result += g\n    return str(result)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = map(int, stdin.split())\n    allowed = set(stdin.split()[1])\n    count = 0\n    for i in range(a, b + 1):\n        if set(str(i)) & allowed == set(str(i)):\n            count += 1\n    return count\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = [int(x) for x in stdin.split()]\n    digits = [int(d) for d in stdin.split()[1]]\n    ans = 0\n    for i in range(a, b + 1):\n        x = i\n        while x % x < x:\n            x = x % x\n            if x in digits:\n                ans += 1\n    return ans\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = [int(v) for v in stdin.split()]\n    digits = [int(v) for v in stdin.split()[1]]\n    count = 0\n    for i in range(a, b + 1):\n        v = str(i)\n        if set(v) <= set(digits):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b = [int(i) for i in stdin.split(' ')]\n    digits = stdin[3]\n\n    # for i in range(a, b+1):\n    #     if i % x == 0:\n    #         print(i)\n\n    def is_allowed(string: str) -> bool:\n        for digit in string:\n            if not digit in digits:\n                return False\n        return True\n\n    ans = []\n    for i in range(a, b+1):\n        if i % x == 0:\n            if is_allowed(str(i)):\n                ans.append(i)\n    return len(ans)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    limit = [int(i) for i in stdin.split(' ')]\n    number_of_digits = stdin.split(' ')[1]\n    digits = [i for i in number_of_digits]\n    digits.sort()\n    digits_list = []\n    for i in range(1, limit[2]):\n        for j in range(len(digits)):\n            if i % limit[0] == 0 and number_of_digits[j] == digits[j]:\n                digits_list.append(number_of_digits[j])\n    print(len(digits_list))"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution for The Digit Multipliers\"\"\"\n    (X, A, B) = [int(s) for s in stdin.split()]\n    (allowed_digits, ) = [sorted(s.replace('0', '')) for s in stdin.split('\\n')]\n    allowed_digits = ''.join(allowed_digits)\n    nums = [int(allowed_digits[i:i+X]) for i in range(len(allowed_digits) - X + 1)]\n    return str(sum([1 for n in nums if A <= n <= B and n % X == 0]))\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute how many multiples Zvonko can make on a single line.\n\n    :param stdin: Input on a single line\n    :type stdin: str\n    :return: Number of multiples Zvonko can make on a single line\n    :rtype: str\n    \"\"\"\n    X, A, B = map(int, stdin.split())\n    allowed_digits = list(map(int, stdin.split()[1]))\n    allowed_digits.sort()\n    min_allowed = min(allowed_digits)\n    max_allowed = max(allowed_digits)\n    count = 0\n\n    # optimization\n    if A < min_allowed or B > max_allowed:\n        return str(0)\n\n    # generate all numbers from [min_allowed, max_allowed]\n    # then check for all of them\n    for num in range(min_allowed, max_allowed + 1):\n        # print(num)\n        # check if num is divisible by X and if digits are in allowed digits\n        if num % X == 0 and set(str(num)) <= set(allowed_digits):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Get parameters\n    # Set digits\n    # Set result\n    # Iterate through all combinations\n    # Return result\n    return str(solution)\n\nprint(solution(stdin))"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    digits = stdin.split()[1].split(',')\n    max_digits = int(stdin.split()[0])\n    min_digits = int(stdin.split()[1])\n    total = 0\n    for digit in digits:\n        if int(digit) < max_digits:\n            total += (max_digits // int(digit))\n    return str(total)\n"
    },
    {
        "number": 3145,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    allowed = \"0123456789\"\n    allowed_count = len(allowed)\n    x, a, b = [int(s) for s in stdin.split(\" \")]\n    assert 1 <= x < 10 ** 11\n    assert 1 <= a < 10 ** 11\n    assert 1 <= b < 10 ** 11\n\n    a, b = sorted((a, b))\n\n    result = 0\n    for i in range(a, b + 1):\n        if i % x!= 0:\n            continue\n        if all([digit in allowed for digit in str(i)]):\n            result += 1\n    return str(result)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    in_store_customers, num_tech = input().split()\n    in_store_customers = int(in_store_customers)\n    num_tech = int(num_tech)\n    p = []\n    for _ in range(in_store_customers):\n        p.append([int(x) for x in input().split()])\n    p.sort(key=lambda x: x[0])\n    in_store_customers = 0\n    remote_customers = 0\n    avg_time = 0\n    for i in p:\n        if i[1] == 'R':\n            remote_customers += 1\n        else:\n            in_store_customers += 1\n        avg_time += i[0]\n        if in_store_customers > num_tech:\n            in_store_customers = num_tech\n        if remote_customers > num_tech:\n            remote_customers = num_tech\n        if in_store_customers == num_tech and remote_customers == num_tech:\n            break\n    print(avg_time / (num_tech - remote_customers))\n    print(avg_time / (in_store_customers - remote_customers))\n\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # n, T = map(int, stdin.split())\n    # X = sorted([[int(x) for x in stdin.split()] for _ in range(n)])\n    # a = [0] * T\n    # for i in range(n):\n    #     if X[i][0] == 1:\n    #         if X[i][1] < T:\n    #             a[X[i][1]-1] += X[i][2]\n    #         else:\n    #             a[T-1] += X[i][2]\n    #     else:\n    #         if X[i][1] < T:\n    #             a[X[i][1]-1] += 1\n    #         else:\n    #             a[T-1] += 1\n    # for i in range(T-1):\n    #     a[i+1] += a[i]\n    # print(*[round(x / n, 6) for x in a], sep='\\n')\n    # return ''\n\nprint(solution(input()))\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    time: O(nlog(n))\n    space: O(n)\n    \"\"\"\n    n, t = map(int, stdin.split())\n    in_store_pills, remote_pills = [], []\n    for _ in range(n):\n        d, s, k = map(int, stdin.split())\n        if s == 'S':\n            in_store_pills.append((d, k))\n        else:\n            remote_pills.append((d, k))\n    in_store_pills.sort(key=lambda p: p[1])\n    remote_pills.sort(key=lambda p: p[1])\n    # no in-store pills\n    if len(in_store_pills) == 0:\n        print(0, 0)\n        return\n    # only one in-store pill\n    elif len(in_store_pills) == 1:\n        print(0, in_store_pills[0][1])\n        return\n    # two in-store pills\n    elif len(in_store_pills) == 2:\n        print(in_store_pills[1][0] - in_store_pills[0][0], in_store_pills[1][1])\n        return\n    # more than two in-store pills\n    # we only need the minimum fill time, so we can ignore remote pills\n    # if we add up all the fill times, we'll get the total fill time\n    # subtract the minimum fill time, and we get the time left for the in-store pills to finish\n    total_fill_time = sum(p[1] for p in in_store_pills)\n    avg_fill_time = total_fill_time / len(in_store_pills)\n    left = avg_fill_time - in_store_pills[0][1]\n    print(left, in_store_pills[1][1])\n    return\n\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Returns the average completion time of in-store and remote\n    prescriptions under an in-store first policy.\n    \"\"\"\n    # Split input into lines\n    lines = stdin.split('\\n')\n\n    # Extract number of prescriptions and number of technicians\n    num_prescriptions = int(lines[0].split()[0])\n    num_technicians = int(lines[0].split()[1])\n\n    # Create a dict for the in-store and remote prescriptions\n    # that will store times when prescriptions were dropped off\n    # and how long it took to fill them\n    prescription_dict = {'in-store': [],'remote': []}\n\n    # Iterate over the number of prescriptions, and then over the\n    # number of technicians. For each prescription, check whether\n    # the type is in-store or remote. If in-store, add the drop-off\n    # time to the in-store list, and if remote, add the drop-off time\n    # to the remote list.\n    for i in range(1, num_prescriptions+1):\n        time, prescription_type, drop_off_time = lines[i].split()\n        if prescription_type == 'R':\n            prescription_dict['remote'].append(int(time))\n        else:\n            prescription_dict['in-store'].append(int(time))\n\n    # Sort the in-store and remote prescriptions in increasing order\n    prescription_dict['in-store'].sort()\n    prescription_dict['remote'].sort()\n\n    # Initialize the running sum of in-store and remote completion\n    # times.\n    total_in_store = 0\n    total_remote = 0\n\n    # Initialize the running sum of in-store and remote lengths\n    total_in_store_length = 0\n    total_remote_length = 0\n\n    # Iterate over the number of technicians.\n    for i in range(num_technicians):\n        # Create a copy of the in-store and remote lists to avoid\n        # modifying the original lists\n        in_store_copy = prescription_dict['in-store'][:]\n        remote_copy = prescription_dict['remote'][:]\n\n        # Iterate over the in-store and remote prescriptions,\n        # and for each prescription, add the length of the\n        # prescription to the running sum if and only if the\n        # type is in-store.\n        for j in range(len(in_store_copy)):\n            if in_store_copy[j] not in remote_copy:\n                total_in_store += in_store_copy[j]\n                total_in_store_length += 1\n                in_store_copy.pop(j)\n                break\n            else:\n                total_in_store += in_store_copy[j]\n                in_store_copy.pop(j)\n                total_in_store_length += 1\n\n        # Iterate over the remote prescriptions, adding the length\n        # of each prescription to the running sum if and only if the\n        # type is remote.\n        for j in range(len(remote_copy)):\n            if remote_copy[j] not in in_store_copy:\n                total_remote += remote_copy[j]\n                total_remote_length += 1\n                remote_copy.pop(j)\n                break\n            else:\n                total_remote += remote_copy[j]\n                total_remote_length += 1\n                remote_copy.pop(j)\n\n    # Divide the sum of in-store and remote completion times\n    # by the sum of their lengths, and return the result rounded\n    # to 6 decimal places.\n    return str(round(total_in_store / total_in_store_length, 6)) +'' + str(round(total_remote / total_remote_length, 6))\n\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return the average completion time for in-store and remote\n    prescriptions.\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def in_store_time():\n        nonlocal time_left, flag, s_time, i_time\n        time_left = 0\n        while len(i_time) or len(s_time):\n            if len(i_time):\n                if i_time[0] <= time_left:\n                    time_left -= i_time.pop(0)\n                else:\n                    i_time.pop(0)\n                    continue\n            if len(s_time):\n                if s_time[0] <= time_left:\n                    time_left -= s_time.pop(0)\n                else:\n                    s_time.pop(0)\n                    continue\n        flag = True\n\n    def remote_time():\n        nonlocal time_left, flag, r_time, i_time, s_time\n        time_left = 0\n        while len(i_time) or len(s_time) or len(r_time):\n            if len(i_time):\n                if i_time[0] <= time_left:\n                    time_left -= i_time.pop(0)\n                else:\n                    i_time.pop(0)\n                    continue\n            if len(s_time):\n                if s_time[0] <= time_left:\n                    time_left -= s_time.pop(0)\n                else:\n                    s_time.pop(0)\n                    continue\n            if len(r_time):\n                if r_time[0] <= time_left:\n                    time_left -= r_time.pop(0)\n                else:\n                    r_time.pop(0)\n                    continue\n        flag = True\n\n    def avg_time():\n        nonlocal time_left, flag, r_time, i_time, s_time\n        if flag:\n            r_time = sorted(r_time)\n            i_time = sorted(i_time)\n            s_time = sorted(s_time)\n            if len(s_time) > 0:\n                time_left -= s_time.pop(0)\n            if len(i_time) > 0:\n                time_left -= i_time.pop(0)\n            if len(r_time) > 0:\n                time_left -= r_time.pop(0)\n        return time_left / len(i_time + r_time + s_time)\n\n    time_left, flag, r_time, i_time, s_time = 0, False, [], [], []\n    n, t = map(int, stdin.split('\\n')[0].split())\n    for _ in range(n):\n        d, tp, k = map(int, stdin.split('\\n')[_].split())\n        time_left += d\n        if tp == 'R':\n            r_time.append(k)\n        elif tp == 'S':\n            s_time.append(k)\n        else:\n            i_time.append(k)\n    while not flag:\n        in_store_time()\n        remote_time()\n        flag = all([len(i_time) == 0, len(s_time) == 0, len(r_time) == 0])\n    return '{:.6f} {:.6f}'.format(avg_time(), avg_time() / t)"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # n = input().split()\n    # t = int(n[0])\n    # n = int(n[1])\n    # prescriptions = []\n    # for i in range(n):\n    #     prescriptions.append(list(map(int, stdin.readline().split())))\n\n    n, t = map(int, stdin.readline().split())\n    d = []\n    for i in range(n):\n        d.append(list(map(int, stdin.readline().split())))\n\n    d = sorted(d, key=lambda x: x[0])\n    # print(d)\n\n    inStorePrescri = 0\n    remotePrescri = 0\n    current = 0\n    for i in range(n):\n        pres = d[i]\n        time = pres[0]\n        status = pres[1]\n        quantity = pres[2]\n\n        if status == 'R':\n            remotePrescri += time\n        else:\n            inStorePrescri += time\n            current += quantity\n            if current > t:\n                remotePrescri += current - t\n                current = t\n            if current < quantity:\n                current = quantity\n\n    # print(inStorePrescri, remotePrescri)\n    return str(round(inStorePrescri / (n - t), 6)) +'' + str(round(remotePrescri / (n - t), 6))\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    'Compute average completion time for in-store and remote prescriptions.'\n    # split the input by line, and by each line split by space\n    n, t = map(int, stdin.split('\\n')[0].split())\n    in_store, remote = 0, 0\n    for _ in range(n):\n        d, _, k = map(int, stdin.split('\\n')[1 + _].split())\n        if _ % 2 == 0:\n            in_store += d\n        else:\n            remote += d\n    in_store /= t\n    remote /= t\n    return f'{in_store:.6f} {remote:.6f}'\n"
    },
    {
        "number": 3146,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Compute average completion time for in-store and remote prescription.\n\n    Args:\n        stdin (str): Input from standard input.\n\n    Returns:\n        str: Output to standard output.\n    \"\"\"\n    num_pharmacy, num_tech = map(int, stdin.split())\n    wait_times = [list(map(int, stdin.split()[1:])) for _ in range(num_pharmacy)]\n    in_store, remote = 0, 0\n    for _, (drop_off, priority, _) in enumerate(wait_times):\n        if priority == 'S':\n            in_store += drop_off\n        else:\n            remote += drop_off\n    print(in_store / num_tech, remote / num_tech)\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = [int(x) for x in stdin.strip().split(' ')]\n\n    def at(i: int, j: int) -> int:\n        return 0 if stdin[i][j] == '0' else 1\n\n    def valid(i: int, j: int) -> bool:\n        return 0 <= i < r and 0 <= j < c\n\n    def any_killer(mat: list[str], i: int, j: int) -> int:\n        return any(at(i + x, j + y) and at(i + x + 1, j + y) and at(i + x + 2, j + y) and at(i + x, j + y + 1) and at(\n            i + x + 1, j + y + 1) and at(i + x + 2, j + y + 1) for x in range(3) for y in range(3))\n\n    def killers(mat: list[str]) -> int:\n        return max(any_killer(mat, i, j) for i in range(r) for j in range(c))\n\n    return str(killers(stdin))\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    r, c = list(map(int, stdin.split(' ')))\n    print(r, c)\n    memory = []\n    killers = 0\n    for i in range(r):\n        row = stdin[i*c:(i+1)*c]\n        print(row)\n        memory.append(row)\n        if '1' in row:\n            killers += 1\n        if '1' in row[::-1]:\n            killers += 1\n    if killers == 0:\n        return -1\n    for i in range(killers):\n        if i == killers - 1:\n            return killers\n        print(' '.join(memory[i]),''.join(memory[i][::-1]))\n        if ''.join(memory[i]) == ''.join(memory[i][::-1]):\n            killers += 1\n    return killers\n    \n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Given the input layout of the memory, output the size of the largest square killer.\n    '''\n    lines = stdin.split('\\n')\n    r, c = len(lines), len(lines[0])\n\n    # Build the matrix for checking for square killers.\n    matrix = []\n    for line in lines:\n        row = []\n        for char in line:\n            row.append(char == '1')\n        matrix.append(row)\n\n    # Check for square killers.\n    killers = []\n    for row in range(r):\n        for col in range(c):\n            if matrix[row][col]:\n                for i in range(1, r - row):\n                    for j in range(1, c - col):\n                        matrix[row + i][col + j] = False\n                        if matrix[row + i][col] and matrix[row][col + j]:\n                            killers.append((i, j))\n\n    # Find the largest killer.\n    largest_killer = None\n    for killer in killers:\n        if largest_killer is None or largest_killer[1] < killer[1]:\n            largest_killer = killer\n\n    # Output.\n    if largest_killer:\n        return str(largest_killer[0])\n    return '-1'\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return largest killer size, or -1 if there are no square killers.\"\"\"\n    # Get matrix dimensions\n    R, C = map(int, stdin.split())\n\n    # Matrix rows of zeroes and ones\n    rows = [stdin.split() for stdin in stdin.split('\\n')[:R]]\n    # Matrix columns of zeroes and ones\n    columns = zip(*rows)\n\n    # Rotate columns in place. Start with largest to eliminate chance of finding\n    # a killer that is actually a square killer.\n    for col in columns[::-1]:\n        col = rotate_row(col)\n\n    # Scan through rotated matrix. If there is a killer, return its size. If not,\n    # return -1.\n    for i, row in enumerate(rows[::-1]):\n        for j, col in enumerate(row):\n            if is_killer(col, i, j, R, C):\n                return str(i + 1)\n\n    return '-1'\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A bottom-up dynamic programming solution that finds\n    the largest square killer by attempting to rotate\n    the Killer matrix.\n    \"\"\"\n    def rotate(matrix):\n        \"\"\"\n        Rotate a matrix by 90 degrees to the left.\n        \"\"\"\n        return [list(reversed(row)) for row in zip(*matrix)]\n\n    def rotate_in_place(matrix):\n        \"\"\"\n        Rotate a matrix by 90 degrees to the left in place.\n        \"\"\"\n        for i in range(len(matrix)):\n            for j in range(i):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    def killer(matrix, rows, cols):\n        \"\"\"\n        Return the size of the largest killer, or -1 if there\n        is no killer.\n        \"\"\"\n        largest = -1\n        for c in range(cols):\n            for r in range(rows):\n                if matrix[r][c] == 1:\n                    # Rotate killer matrix until it's a square.\n                    found_killer = False\n                    while not found_killer:\n                        rotate_in_place(matrix)\n                        if matrix[r][c] == 1:\n                            found_killer = True\n                            if largest < r + 1:\n                                largest = r + 1\n        return largest\n\n    rows, cols = [int(c) for c in stdin.split(\" \")]\n    matrix = []\n    for _ in range(rows):\n        matrix.append([int(c) for c in stdin.split(\" \")[0]])\n    return str(killer(matrix, rows, cols))\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split(' '))\n    mat = []\n    for _ in range(r):\n        mat.append(stdin.strip().split('\\n')[0])\n\n    result = 0\n    for i in range(r - 1):\n        for j in range(c - 1):\n            if mat[i][j] == mat[i][j + 1] and mat[i + 1][j] == mat[i + 1][j + 1]:\n                result = max(result, 2)\n            if mat[i][j] == mat[i + 1][j] and mat[i][j] == mat[i + 1][j + 1]:\n                result = max(result, 2)\n    print(result)\n    return result\nsolution(stdin)\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    row = stdin[0:stdin.find('\\n')]\n    row = row.split('\\n')\n    arr = []\n    for i in row:\n        arr.append([char for char in i])\n    col = stdin[stdin.find('\\n')+1:]\n    col = col.split('\\n')\n    col = [list(i) for i in col]\n    out = []\n    for i in range(len(col)):\n        for j in range(len(col)):\n            if (len(col) - j) < len(col):\n                break\n            if col[i][j] == 1:\n                out.append([i,j])\n    for i in out:\n        if i[0] + len(row) - 1 > i[1] and i[0] + len(row) - 1 > i[1]:\n            print(i)\n    for i in out:\n        if i[0] + len(col) - 1 > i[1] and i[0] + len(col) - 1 > i[1]:\n            print(i)\n    for i in range(len(row)):\n        for j in range(len(col)):\n            if [i,j] in out:\n                continue\n            if i+len(row) > j and i+len(row) > j:\n                print([i,j])"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(str(input()).split())\n    [3, 2, 3]\n    >>> solution(str(input()).split())\n    [4, 5, 3]\n    >>> solution(str(input()).split())\n    [1, 1, -1]\n    \"\"\"\n    r, c = map(int, stdin.split())\n    matrix = [[c for _ in range(c)] for _ in range(r)]\n    killer = []\n    for i in range(r):\n        line = stdin.split()[i]\n        matrix[i] = list(line)\n    for i in range(r):\n        for j in range(c):\n            if matrix[i][j] == \"1\":\n                curr_killer = [matrix[i][j:j + c] for i in range(i, i + c)]\n                if not killer:\n                    killer = curr_killer\n                    continue\n                if killer == curr_killer:\n                    return len(killer)\n                killer.append(curr_killer)\n    return -1\n"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds largest square killer.\n    \"\"\"\n    # read input\n    r, c = map(int, stdin.split())\n    memory = []\n    for _ in range(r):\n        memory.append(list(stdin.split()[0]))\n    # find killer\n    max_size = 0\n    for row in range(r):\n        for col in range(c):\n            # if killer\n            if memory[row][col] == \"1\":\n                # get size of killer\n                size = get_size(memory, row, col)\n                # if size is larger\n                if size > max_size:\n                    # update\n                    max_size = size\n    # if no killer found\n    if max_size == 0:\n        print(-1)\n    # else\n    else:\n        print(max_size)\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3147,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Calculate the largest killer.\n    '''\n    return str(max(calculate_killer_sizes(stdin)))\n\ndef"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    get input and return the solution\n    :param stdin: standard input\n    :return: solution\n    '''\n    # get input\n    num = int(stdin.readline().strip())\n    swimmers = []\n    for i in range(num):\n        swimmers.append(tuple(int(x) for x in stdin.readline().strip().split(' ')))\n    # algorithm\n    # sort\n    swimmers.sort(key=lambda x: x[0])\n    # find the first and second swimmers\n    # TODO: change the numbers to floats?\n    first = swimmers[0][0]\n    second = swimmers[1][0]\n    # find the first and second swimmer's index\n    first_index = 0\n    second_index = 1\n    for i in range(num):\n        if first > swimmers[i][0]:\n            second = swimmers[i][0]\n            second_index = i\n            break\n    # find the distance between the first and second swimmers\n    distance = abs(swimmers[first_index][1] - swimmers[second_index][1])\n    # find the max distance between swimmers\n    max_distance = max(swimmers[first_index][1], swimmers[second_index][1])\n    # find the min distance between swimmers\n    min_distance = min(swimmers[first_index][1], swimmers[second_index][1])\n    # find the average distance between swimmers\n    average_distance = (max_distance + min_distance) / 2\n    # find the number of people in the two groups\n    people_in_first_group = 0\n    people_in_second_group = 0\n    for i in range(num):\n        if abs(swimmers[i][1] - swimmers[first_index][1]) < distance:\n            people_in_first_group += 1\n        if abs(swimmers[i][1] - swimmers[second_index][1]) < distance:\n            people_in_second_group += 1\n    # find the index of the swimmer who is nearest to the first swimmers\n    nearest_to_first = 0\n    for i in range(num):\n        if abs(swimmers[i][1] - swimmers[first_index][1]) < average_distance:\n            nearest_to_first = i\n    # find the index of the swimmer who is nearest to the second swimmers\n    nearest_to_second = 0\n    for i in range(num):\n        if abs(swimmers[i][1] - swimmers[second_index][1]) < average_distance:\n            nearest_to_second = i\n    # find the number of people in the two groups who are nearest to the first swimmers\n    people_in_first_nearest_to_first = 0\n    for i in range(num):\n        if abs(swimmers[i][1] - swimmers[first_index][1]) < max_distance:\n            people_in_first_nearest_to_first += 1\n    # find the number of people in the two groups who are nearest to the second swimmers\n    people_in_second_nearest_to_second = 0\n    for i in range(num):\n        if abs(swimmers[i][1] - swimmers[second_index][1]) < max_distance:\n            people_in_second_nearest_to_second += 1\n    # print the solution\n    print(first, second)\n    print(people_in_first_group, people_in_second_group)\n    print(nearest_to_first, nearest_to_second)\n    print(people_in_first_nearest_to_first, people_in_second_nearest_to_second)\n\n\ndef"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    import sys\n    sys.setrecursionlimit(10 ** 5)\n    input = stdin.readlines()\n    lines = [line.strip() for line in input]\n\n    for i in range(len(lines)):\n        lines[i] = lines[i].split(' ')\n        lines[i] = [int(x) for x in lines[i]]\n\n    return (solution_helper(lines))\n\n\ndef"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the solution for the problem\"\"\"\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    x = []\n    y = []\n    for i in range(1, n + 1):\n        x.append(int(lines[i].split(' ')[0]))\n        y.append(int(lines[i].split(' ')[1]))\n    x.sort()\n    y.sort()\n\n    # Consider the largest difference among x and y.\n    # This will be the largest difference for which we can have two\n    # equally sized groups.\n    max_diff = x[-1] - x[0]\n    max_diff_i = 0\n\n    # Check whether the difference between the smallest and largest\n    # x value is less than max_diff.\n    for i in range(n):\n        if x[i] - x[max_diff_i] < max_diff:\n            max_diff = x[i] - x[max_diff_i]\n            max_diff_i = i\n\n    # Check whether the difference between the smallest and largest\n    # y value is less than max_diff.\n    for i in range(n):\n        if y[i] - y[max_diff_i] < max_diff:\n            max_diff = y[i] - y[max_diff_i]\n            max_diff_i = i\n\n    # Return the x, y of the swimmer.\n    return str(x[max_diff_i]), str(y[max_diff_i])\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n    # D\n    # E\n    # F\n    # G\n    # H\n    # I\n    # J\n    # K\n    # L\n    # M\n    # N\n    # O\n    # P\n    # Q\n    # R\n    # S\n    # T\n    # U\n    # V\n    # W\n    # X\n    # Y\n    # Z\n    # A\n    # B\n    # C\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split(\"\\n\")\n    n = int(stdin[0])\n    stdin = stdin[1:]\n    x = [int(stdin[i].split()[0]) for i in range(n)]\n    y = [int(stdin[i].split()[1]) for i in range(n)]\n    \n    x_sum = sum(x)\n    y_sum = sum(y)\n    x_mean = x_sum / n\n    y_mean = y_sum / n\n    \n    x_mean_diff = x_sum - n * x_mean\n    y_mean_diff = y_sum - n * y_mean\n    \n    solution_1 = 0\n    solution_2 = 0\n    for i in range(n):\n        solution_1 += x[i] * y[i]\n        solution_2 += x[i] * y_mean_diff + y[i] * x_mean_diff\n    \n    solution_1_diff = x_mean_diff * y_mean_diff\n    \n    if solution_1 == solution_1_diff:\n        solution_1 = abs(x_mean_diff)\n        solution_2 = abs(y_mean_diff)\n    elif solution_2 == solution_1_diff:\n        solution_1 = abs(y_mean_diff)\n        solution_2 = abs(x_mean_diff)\n    \n    solution_1 -= solution_1_diff\n    solution_2 -= solution_1_diff\n    \n    print(str(solution_1) + \" \" + str(solution_2))\n    return \"\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    In this solution, the person who starts at the top of the river will always\n    be able to cover all the swimmers and the person who ends up at the bottom\n    will always be able to cover all the swimmers. Because of that, we only need\n    to consider the swimmers in between the two people who cover all the\n    swimmers.\n\n    The solution is to use an auxiliary array to store the total number of\n    swimmers before each person. Then, we just need to iterate over the array\n    from right to left, and check how many swimmers are left, and if it matches\n    with the current person's position, we can set the person to cover all\n    swimmers.\n\n    Because the array stores the number of swimmers before the current person,\n    we can get the answer by subtracting the current person's position from the\n    length of the array.\n    \"\"\"\n\n    n = int(stdin)\n\n    swimmers = list(map(int, stdin.splitlines()))\n\n    swimmers.sort()\n\n    aux = [1 for _ in range(n)]\n    for i in range(n):\n        aux[i] -= swimmers[i]\n\n    ans = n\n    j = 0\n    for i in range(n - 1, -1, -1):\n        if swimmers[i] <= ans:\n            break\n        ans -= aux[j]\n        j += 1\n\n    return str(swimmers[i]) + \" \" + str(ans)\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    A straightforward solution without any thought.\n    Treat it as a list of coordinates and sort them, then\n    solve the problem of groups of distance equal in magnitude.\n    '''\n    l = stdin.split('\\n')\n    points = [tuple(map(int, line.split())) for line in l[1:]]\n    points.sort()\n\n    x, y, distances = 0, 0, {0: 0}\n    for i in range(len(points)):\n        x += points[i][0]\n        y += points[i][1]\n        distances[x + y] = distances.get(x + y, 0) + 1\n\n    return (\n        min(x, y) if x + y > 0 else -1 * min(abs(x), abs(y)),\n        max(x, y) if x + y > 0 else max(abs(x), abs(y))\n    )\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem\n\n    Parameters\n    ----------\n    stdin : str\n        The standard input of the problem\n\n    Returns\n    -------\n    str\n        The standard output of the problem\n    \"\"\"\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for _ in range(n):\n        swimmers.append([int(x) for x in stdin.readline().split()])\n\n    swimmers.sort(key=lambda x: x[0])\n    swimmers.sort(key=lambda x: x[1])\n\n    if n == 1:\n        return str(swimmers[0][0]) + \" \" + str(swimmers[0][1])\n\n    nums = []\n    for i in range(n):\n        if i == 0:\n            nums.append(swimmers[i][0])\n        else:\n            nums.append(nums[i - 1] + swimmers[i][0])\n\n    nums.sort()\n    for i in range(n):\n        if nums[i]!= swimmers[i][0]:\n            return str(nums[i - 1]) + \" \" + str(nums[i])\n\n    return str(nums[-1]) + \" \" + str(nums[0])\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the solution for the problem.\n\n    Time complexity: O(n) where n is the number of people.\n    Space complexity: O(n) where n is the number of people.\n    \"\"\"\n    # Get the number of people from the input.\n    number_of_people = int(stdin)\n\n    # Get the swimmer positions from the input.\n    swimmer_positions = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    # Get the indices of people who are involved in the group.\n    # We will try to divide this group in two groups, such that\n    # we have exactly 2 people in each group.\n    indices = [i for i, (x, y) in enumerate(swimmer_positions)]\n    indices.sort(key=lambda i: (abs(swimmer_positions[i][0]), abs(swimmer_positions[i][1])))\n\n    # Initialize the groups with the first person in the indices list.\n    groups = [[indices[0]]]\n    group_index = 0\n\n    # We go through all the indices and add the next person to the\n    # group where the person is closest to the first person.\n    for index in indices:\n        if groups[group_index][0] == index:\n            groups[group_index].append(index)\n        else:\n            group_index += 1\n            groups.append([index])\n\n    # For each group, we take the two farthest people and store them\n    # in x and y respectively.\n    max_x = 0\n    max_y = 0\n    for group in groups:\n        distances = []\n        for i in range(len(group) - 1):\n            distances.append(abs(swimmer_positions[group[i]][0] - swimmer_positions[group[i + 1]][0]))\n            distances.append(abs(swimmer_positions[group[i]][1] - swimmer_positions[group[i + 1]][1]))\n        distances.sort(reverse=True)\n        max_x = max(max_x, distances[0])\n        max_y = max(max_y, distances[1])\n\n    # We print the minimum distance from the first swimmer.\n    print(max_x, max_y)\n"
    },
    {
        "number": 3148,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find the set of x and y coordinates that divide the list of swimmer coordinates\n    into two groups of at most one swimmer for which x+y is minimized.\n    :param stdin:\n    :return: the x,y coordinate pair\n    \"\"\"\n    pass"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Computes the time in seconds the first corner hits the wall first and when\"\"\"\n    content = stdin.split()\n    n, omega, v0, theta, w = map(float, content[:5])\n    p = Polygon(list(map(float, content[5:])))\n    x, y = p.center()\n\n    # Initial position of the cookie\n    xc = math.sin(math.radians(theta)) * v0\n    yc = math.cos(math.radians(theta)) * v0\n    x = x + xc\n    y = y + yc\n\n    def time(r):\n        \"\"\"Time to hit the wall for a point on the cookie\"\"\"\n        return (w - xc) / (omega * yc)\n\n    def dist(r):\n        \"\"\"Distance from the point to the wall\"\"\"\n        return w - x - math.tan(math.radians(theta)) * (r - y)\n\n    # Find when first point hits wall\n    d = dist(p.r(0))\n    t0 = time(d)\n\n    # For each point in the cookie, check if it hits the wall first\n    for i in range(1, len(p)):\n        t = time(p.r(i))\n        if t < t0:\n            t0 = t\n            i0 = i\n    return f\"{i0} {t0}\"\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    line = stdin.split()\n    polygon_count = int(line[0])\n    omega = float(line[1])\n    v0 = float(line[2])\n    theta = float(line[3])\n    wall_x = float(line[4])\n    polygon = []\n    for i in range(polygon_count):\n        polygon.append([float(line[5 + 2 * i]), float(line[6 + 2 * i])])\n    corners = [0]\n    angle = math.radians(theta)\n    for i in range(polygon_count):\n        corners.append(corners[-1] + math.cos(angle + math.pi / polygon_count * i) * (polygon[(i + 1) % polygon_count][0] - polygon[i % polygon_count][0]))\n        corners.append(corners[-1] + math.sin(angle + math.pi / polygon_count * i) * (polygon[(i + 1) % polygon_count][1] - polygon[i % polygon_count][1]))\n    corners.append(corners[-1])\n    corners.append(corners[-1] + math.cos(angle) * (wall_x - polygon[0][0]))\n    corners.append(corners[-1] + math.sin(angle) * (wall_x - polygon[0][0]))\n    # print(corners)\n    angle = 0\n    time = 0\n    while True:\n        for i in range(polygon_count + 2):\n            angle = (angle + omega) % (2 * math.pi)\n            if corners[i] <= 0 or corners[i + 1] <= 0 or angle >= math.pi / 2:\n                time = time + (corners[i] * corners[i + 1] / (2 * v0 * v0))\n                break\n        if time >= 10 ** -3:\n            break\n    while True:\n        for i in range(polygon_count + 2):\n            angle = (angle + omega) % (2 * math.pi)\n            if corners[i] <= 0 or corners[i + 1] <= 0 or angle >= math.pi / 2:\n                if time < corners[i] * corners[i + 1] / (2 * v0 * v0):\n                    return str(i) + \" \" + str(time)\n        time = time + (corners[i] * corners[i + 1] / (2 * v0 * v0))\n        # print(time)\n\n\nprint(solution(input()))\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v0, theta, w, x, y = [float(x) for x in stdin.split()]\n    corners = [[x, y] for x, y in zip(stdin.split()[:n], stdin.split()[n:])]\n    corners = [\n        {\n            \"x\": x + (x - v0 * math.sin(theta * math.pi / 180)),\n            \"y\": y - (x - v0 * math.cos(theta * math.pi / 180)),\n        }\n        for x, y in corners\n    ]\n    print(corners)\n    corners = sorted(corners, key=lambda x: x[\"x\"])\n    print(corners)\n    return [\n        str(corners.index(corners[0]) + 1)\n        + \" \"\n        + str(math.sqrt(corners[0][\"x\"] ** 2 + corners[0][\"y\"] ** 2) + w)\n    ]\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the first vertex that hits the wall first and when.\"\"\"\n\n    def get_first_vertex(\n        p: float, w: float, v0: float, omega: float, theta: float, a0: float\n    ) -> float:\n        \"\"\"Finds the first vertex that hits the wall first and when.\"\"\"\n        x = (\n            v0 * (math.cos(math.radians(theta)) * math.cos(math.radians(omega)))\n            - v0 * (math.cos(math.radians(theta)) * math.sin(math.radians(omega)))\n            - a0 * math.sin(math.radians(theta))\n            + w\n        )\n        y = (\n            v0 * (math.sin(math.radians(theta)) * math.cos(math.radians(omega)))\n            + v0 * (math.cos(math.radians(theta)) * math.sin(math.radians(omega)))\n            - a0 * math.cos(math.radians(theta))\n            - w\n        )\n        return x / y\n\n    def calculate_min_max(points: List[tuple]) -> Tuple[float, float]:\n        \"\"\"Finds the min and max x and y values of all given points.\"\"\"\n        xs, ys = zip(*points)\n        return (min(xs), max(xs), min(ys), max(ys))\n\n    def get_new_x(\n        t: float,\n        x: float,\n        v0: float,\n        omega: float,\n        theta: float,\n        a0: float,\n    ) -> float:\n        \"\"\"Gets the new x position given a time t.\"\"\"\n        return (\n            x\n            + v0 * (math.cos(math.radians(theta)) * math.cos(math.radians(omega)))\n            - v0 * (math.cos(math.radians(theta)) * math.sin(math.radians(omega)))\n            - a0 * math.sin(math.radians(theta))\n            + t\n        )\n\n    def get_new_y(\n        t: float,\n        x: float,\n        y: float,\n        v0: float,\n        omega: float,\n        theta: float,\n        a0: float,\n    ) -> float:\n        \"\"\"Gets the new y position given a time t.\"\"\"\n        return (\n            y\n            + v0 * (math.sin(math.radians(theta)) * math.cos(math.radians(omega)))\n            + v0 * (math.cos(math.radians(theta)) * math.sin(math.radians(omega)))\n            - a0 * math.cos(math.radians(theta))\n            - t\n        )\n\n    def is_vertical(xs: List[float]) -> bool:\n        \"\"\"Checks if a list of x values is vertical.\"\"\"\n        return len(set(xs)) == 1\n\n    p, w, v0, omega, theta, a0 = map(float, stdin.split())\n    points = []\n    for i in range(1, int(stdin[0]) + 1):\n        x, y = map(float, stdin.split()[i * 2 - 2 : i * 2])\n        points.append((x, y))\n    min_x, max_x, min_y, max_y = calculate_min_max(points)\n    t = 0\n    vertical = is_vertical(list(map(lambda x: x[0], points)))\n    min_x, max_x, min_y, max_y = max(min_x, -abs(w)), min(max_x, abs(w)), max(min_y, -abs(w)), min(max_y, abs(w))\n    while True:\n        t += 0.05\n        if vertical:\n            x = -w\n            y = get_new_y(t, x, 0, v0, omega, theta, a0)\n        else:\n            x = get_new_x(t, 0, v0, omega, theta, a0)\n            y = get_new_y(t, 0, 0, v0, omega, theta, a0)\n        for i in range(1, len(points) + 1):\n            if (x, y) == points[i - 1]:\n                if vertical:\n                    return f\"{i} {t}\"\n                else:\n                    return f\"{i} {t}\"\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    N = int(stdin.split()[0])\n    omega = float(stdin.split()[1])\n    v0 = float(stdin.split()[2])\n    theta = float(stdin.split()[3])\n    w = float(stdin.split()[4])\n    # compute and print answer\n    print(solution(stdin))\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(textwrap.dedent(\"\"\"\\\n        3 6 5 45 20\n        0 0\n        2 0\n        1 1.5\n        \"\"\"))\n    '2 5.086781'\n    \"\"\"\n\n    pass\n"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the solution\"\"\"\n    return str(solution_prepared_stdin(stdin))\n\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # lines = stdin.split('\\n')\n    # n = int(lines[0])\n    # omega = float(lines[1])\n    # v0 = float(lines[2])\n    # theta = float(lines[3])\n    # w = float(lines[4])\n    # points = []\n    # for line in lines[5:]:\n    #     points.append([float(line.split()[0]), float(line.split()[1])])\n    # lines = stdin.split('\\n')\n    # n = int(lines[0])\n    # omega = float(lines[1])\n    # v0 = float(lines[2])\n    # theta = float(lines[3])\n    # w = float(lines[4])\n    # points = []\n    # for line in lines[5:]:\n    #     points.append([float(line.split()[0]), float(line.split()[1])])\n    # points = [[int(x) for x in line.split()] for line in lines[5:]]\n    # points = [[float(x) for x in line.split()] for line in lines[5:]]\n    # line = [int(x) for x in stdin.split('\\n')]\n    # line = [float(x) for x in stdin.split('\\n')]\n    # n = int(line[0])\n    # omega = float(line[1])\n    # v0 = float(line[2])\n    # theta = float(line[3])\n    # w = float(line[4])\n    n = int(input())\n    omega = float(input())\n    v0 = float(input())\n    theta = float(input())\n    w = float(input())\n    points = []\n    for line in stdin.split('\\n'):\n        points.append([float(x) for x in line.split()])\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    omega = float(lines[1])\n    v0 = float(lines[2])\n    theta = float(lines[3])\n    w = float(lines[4])\n    points = [[int(x) for x in line.split()] for line in lines[5:]]\n    points = [[float(x) for x in line.split()] for line in lines[5:]]\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    omega = float(lines[1])\n    v0 = float(lines[2])\n    theta = float(lines[3])\n    w = float(lines[4])\n    points = [[int(x) for x in line.split()] for line in lines[5:]]\n    points = [[float(x) for x in line.split()] for line in lines[5:]]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    points = [[float(x) for x in line.split()] for line in std"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''This function returns the angle of the first point on the wall that the cookie hits'''\n    #take input and assign it to a variable\n    n, omega, v0, theta, w, x_0, y_0 = [float(n) for n in stdin.split('\\n')[0].split()]\n    #create variables to store all vertices\n    vertices = []\n    #create variable to store the angular velocity\n    w_x = omega\n    w_y = 0\n    #create variable to store the radius of the cookie\n    r = (((v0*v0) + (w_x*w_x)) ** 0.5) / v0\n    #loop through input and append coordinates to vertices list\n    for x, y in [(float(n), float(m)) for n, m in zip(*[iter(stdin.split('\\n')[1:])]*2)]:\n        vertices.append((x, y))\n    #create variable to store the distance between the cookie and the wall\n    r_wall = ((x_0 - w) * (x_0 - w) + (y_0 - w) * (y_0 - w)) ** 0.5\n    #create variable to store the sin and cos of the initial angle\n    sin_theta = (y_0 - w) / r_wall\n    cos_theta = (x_0 - w) / r_wall\n    #create variable to store the x and y components of the velocity\n    vx = v0 * cos_theta\n    vy = v0 * sin_theta\n    #create variable to store the x and y components of the acceleration\n    ax = 9.81 * w_x\n    ay = -9.81 * w_y\n    #create variables to store the x and y components of the velocity\n    vx_list = [vx]\n    vy_list = [vy]\n    #create variable to store the x and y components of the acceleration\n    ax_list = [ax]\n    ay_list = [ay]\n    #loop through the number of vertices and append the vx and vy lists with the vx and vy components of the velocity\n    for _ in range(n):\n        vx_list.append(vx_list[-1] - ax * 0.1)\n        vy_list.append(vy_list[-1] + ay * 0.1)\n        ax_list.append(ax_list[-1] - ax * 0.1)\n        ay_list.append(ay_list[-1] + ay * 0.1)\n    #create variable to store the time it took to hit the wall\n    time_list = [((vy_list[0]/9.81) * 0.1) + (0.1/9.81)]\n    #loop through the number of vertices and append the time it took to hit the wall with the time list\n    for _ in range(1, n):\n        time_list.append(((vy_list[-1]/9.81) * 0.1) + (0.1/9.81) + time_list[-1])\n    #create variable to store the distance from the cookie to the wall\n    r_t = ((vx_list[-1]*vx_list[-1]) + (vy_list[-1]*vy_list[-1]) - (9.81*9.81)) ** 0.5\n    #create variable to store the angle of the cookie at every time step\n    angle_list = []\n    #loop through the number of vertices and append the angle list\n    for i in range(1, n):\n        angle_list.append(np.arctan2(vy_list[i], vx_list[i]) * 180 / np.pi)\n    #loop through the number of vertices and append the distance from the cookie to the wall to the distance from the cookie to the wall at every time step\n    for i in range(n):\n        r_t = ((vx_list[i]*vx_list[i]) + (vy_list[i]*vy_list[i]) - (9.81*9.81)) ** 0.5\n        angle_list.append(r_t)\n    #create variable to store the index of the vertex that hit the wall first\n    index = angle_list.index(min(angle_list))\n    #create variable to store the time it took to hit the wall\n    time = time_list[index]\n    #create variable to store the vertices that hit the wall\n    vertices_wall = []\n    #loop through the number of vertices and append the vertices that hit the wall to the vertices_wall list\n    for x, y in vertices:\n        if ((y - w) / r_wall) ** 2 + ((x - w) / r_wall) ** 2 < 1:\n            vertices_wall.append((x, y))\n    #create variable to store the x and y components of the first point on the wall\n    x_wall = vertices_wall[0][0]\n    y_wall = vertices_wall[0][1]\n    #create variable to store the x and y components of the second point on the wall\n    x_wall2 = vertices_wall[1][0]\n    y_wall2 = vertices_wall[1][1]\n    #create variable to store the slope between the two points\n    slope = (y_wall2 - y_wall) / (x_wall2 - x_wall)"
    },
    {
        "number": 3149,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from math import degrees, atan2\n    n, omega, v0, theta, w, x, y = map(float, stdin.split())\n    p = (x, y)\n    polygon = [p]\n    for _ in range(n):\n        polygon.append((polygon[-1][0] + p[0], polygon[-1][1] + p[1]))\n    print(polygon)\n    com = sum(x * y for x, y in polygon) / sum(x ** 2 for x, y in polygon)\n    print(com)\n    print(v0, theta, omega)\n    v = v0 * (cos(radians(theta)) * cos(radians(omega)), sin(radians(theta)) * cos(radians(omega)))\n    v = (v[0] + w, v[1])\n    print(v)\n    #  v = (v0 * cos(radians(theta)), v0 * sin(radians(theta)))\n    #  v = (v0 * cos(radians(theta)) * cos(radians(omega)), v0 * sin(radians(theta)) * cos(radians(omega)))\n    print(atan2(v[1], v[0]))\n    return f'{int(degrees(atan2(v[1], v[0])))}\\n{v0} {theta} {omega}'\n\n\ndef"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return ''\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return an integer, representing the number of possible ways the guards can be placed.\n\n    >>> solution(\"6\\\\n0 0 1 0\\\\n0 0 0 1\\\\n1 0 1 1\\\\n0 1 1 1\\\\n0 0 1 1\\\\n1 0 0 1\")\n    8\n\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return ''"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\"\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of ways to place guards on the trenches such that they do not see each other.\"\"\"\n    n = int(stdin.readline())\n    trenches = []\n    for _ in range(n):\n        trench = [int(s) for s in stdin.readline().split()]\n        trenches.append(trench)\n    trenches = sorted(trenches, key=lambda trench: trench[0])\n    guards = []\n    for trench in trenches:\n        guards.append(trench[0])\n        guards.append(trench[1])\n    guards = sorted(guards)\n    guards = [0] + guards\n    guards = guards + [guards[-1] + 1]\n    print(guards)\n    print(trenches)\n    ways = [1]\n    for i in range(1, len(guards)):\n        ways.append(0)\n        for j in range(i):\n            if (guards[j] <= trenches[i][0] <= guards[j + 1] and\n                    guards[j] <= trenches[i][1] <= guards[j + 1]):\n                ways[i] += ways[j]\n            elif (guards[j] <= trenches[i][1] <= guards[j + 1] and\n                  guards[j] <= trenches[i][0] <= guards[j + 1]):\n                ways[i] += ways[j]\n    return ways[-1]\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Time Complexty: O(1)\n    Space Complexity: O(1)\n    '''\n    n, w1, w2 = stdin.split('\\n')\n    n = int(n)\n    w1 = list(map(int, w1.split(' ')))\n    w2 = list(map(int, w2.split(' ')))\n\n    d = {w1[0]: [], w1[1]: [], w1[2]: [], w1[3]: [], w2[0]: [], w2[1]: [], w2[2]: [], w2[3]: []}\n    for i in range(0, n):\n        d[w1[0]].append(i)\n        d[w1[1]].append(i)\n        d[w1[2]].append(i)\n        d[w1[3]].append(i)\n        d[w2[0]].append(i)\n        d[w2[1]].append(i)\n        d[w2[2]].append(i)\n        d[w2[3]].append(i)\n    s = []\n    s.append(d[w1[0]].pop(0))\n    s.append(d[w1[1]].pop(0))\n    s.append(d[w1[2]].pop(0))\n    s.append(d[w1[3]].pop(0))\n    s.append(d[w2[0]].pop(0))\n    s.append(d[w2[1]].pop(0))\n    s.append(d[w2[2]].pop(0))\n    s.append(d[w2[3]].pop(0))\n\n    l = len(s)\n    i = 0\n    while i < l:\n        if s[i] == s[i+1]:\n            s.pop(i)\n            s.pop(i)\n            i = i - 1\n            l = l - 2\n            continue\n        i = i + 1\n\n    return len(s)\n    \n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return \"\""
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.splitlines()[1:]\n    line = [list(map(int, line[i].split())) for i in range(len(line))]\n    for i in range(len(line)):\n        for j in range(len(line)):\n            if j!= i:\n                if line[i][0] <= line[j][2] and line[j][0] <= line[i][2] and line[i][1] <= line[j][3] and line[j][1] <= line[i][3]:\n                    print(\"false\")\n    print(\"true\")\n    return \"true\"\n"
    },
    {
        "number": 3150,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = 0\n    while s * s < n:\n        k = s\n        while k * k < n:\n            m = k + 1\n            while m * m < n:\n                if m * m == n and m * k == n:\n                    return f\"{m} {k}\"\n                m += 1\n            k += 1\n        s += 1\n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds two integers m, k such that n = m^2 - k^2\n    :param stdin: input\n    :return: m, k or 'impossible'\n    \"\"\"\n    n = int(stdin)\n    m_min = n\n    m_max = int(n ** 0.5)\n    for m in range(m_min, m_max + 1):\n        k = int(n / (m ** 2 + m ** 2) ** 0.5)\n        if m ** 2 + k ** 2 == n:\n            return str(m) +'' + str(k)\n    return 'impossible'\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    tiles = int(stdin.readline())\n\n    if tiles <= (1 << 31) - 1:\n        root = tiles ** 0.5\n        if root.is_integer():\n            diff = int(root) - int(root.is_integer())\n            if diff * diff == tiles:\n                return f\"{int(root)}, {int(root) - diff}\"\n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    return '' if not stdin else print(solve(stdin)) or 'impossible'\ndef"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    for m in range(1, int(sqrt(n)) + 1):\n        if n % m == 0 and sqrt(n).is_integer():\n            k = n // m\n            return f'{m} {k}'\n\n    return 'impossible'\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 'impossible'\n    for m in range(1, n):\n        k = n - m ** 2\n        if k > 0 and k ** 2 == n:\n            result = f'{m} {k}'\n    print(result)\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(1, n):\n        k = math.floor(math.sqrt(n - m * m))\n        if k > 0 and (m + k + 1) * (m + k + 1) == n:\n            return f\"{m} {k}\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return \"\""
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n   ...\n    return result"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    data = int(stdin)\n    for i in range(data):\n        arr = list(map(int, input().split()))\n        \n        sum = 0\n        for n in arr:\n            sum += max(n)\n        print(sum % 100000000009)\n        \n        \n        \ndef"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    time: O(n)\n    space: O(n)\n    '''\n    n = int(stdin)\n    arr = [int(x) for x in stdin.split('\\n')]\n    arr.sort()\n    total = 0\n    for i in range(n - 1, -1, -1):\n        total += arr[i] * (i + 1)\n    total = str(total)[-9:]\n    return total\n\n\ndef"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \n    return stdin"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Get input and output the answer\n    :param stdin: input of a test case\n    :return: the answer to the problem\n    \"\"\"\n    arr = [int(s) for s in stdin.split()]\n    start = 0\n    end = len(arr) - 1\n    sum = 0\n    for i in range(len(arr)):\n        sum += min(arr[start:end + 1]) * max(arr[start:end + 1])\n        start += 1\n        end -= 1\n    return str(sum)[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \n    pass"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    return ''\n\"\"\"\n\ndef"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns the last 9 digits of the required sum from the task\"\"\"\n    n = int(stdin.readline())\n    array = list(map(int, stdin.readlines()))\n    array = sorted(array, reverse=True)\n    min_element = array[0]\n    max_element = array[-1]\n    array = array[1:-1]\n    array = [max_element - i for i in array]\n    array = [min_element * i for i in array]\n    s = str(sum(array))[-9:]\n    return s\nprint(solution(stdin=input()))\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    return last 9 digits of the sum of all prices\n    '''\n    N = int(stdin.readline())\n    array = [int(i) for i in stdin.readline().split(' ')]\n    array.sort()\n    x = (array[N-1] - array[0])\n    sum = 0\n    for i in range(N-1):\n        sum += (array[i+1] - array[i])\n    y = str(sum * (10**9))[-9:]\n    return y\n"
    },
    {
        "number": 3152,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Get input\n    n = int(stdin)\n    arr = []\n    for i in range(n):\n        arr.append(int(stdin))\n\n    # Get min and max\n    min_i = min(arr)\n    max_i = max(arr)\n\n    # Get array length\n    l = len(arr)\n\n    # Get minimum amount\n    min_amount = l * min_i\n\n    # Get maximum amount\n    max_amount = l * max_i\n\n    # Get target amount\n    target_amount = int(str(min_amount)[-9:]) + int(str(max_amount)[-9:])\n\n    # Get answer\n    answer = int(str(target_amount)[-9:])\n    return str(answer)\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cardCounts = stdin.split()\n    cardCounts = list(map(int, cardCounts))\n    N = cardCounts[0]\n    M = cardCounts[1]\n    cardCounts = cardCounts[2:]\n    purchases = []\n    for i in range(M):\n        purchases.append(stdin.split()[2*i+2: 2*i+4])\n    purchases = list(map(lambda x: [int(x[0]), int(x[1])], purchases))\n    for i in range(M):\n        purchases[i].append(0)\n    # purchases.sort(key=lambda x: x[1])\n    purchases.sort()\n    purchases.reverse()\n    for i in range(M):\n        purchases[i][2] = i\n    purchases.sort(key=lambda x: x[0])\n    # print(purchases)\n    maxCard = 0\n    for i in range(M):\n        if cardCounts[purchases[i][0]-1] < 2*purchases[i][1]:\n            print(i)\n            purchases[i][2] = 1\n            cardCounts[purchases[i][0]-1] += 1\n            cardCounts[purchases[i][1]-1] -= 1\n        elif cardCounts[purchases[i][0]-1] == 2*purchases[i][1]:\n            purchases[i][2] = 2\n            cardCounts[purchases[i][0]-1] += 1\n            cardCounts[purchases[i][1]-1] -= 1\n    # print(cardCounts)\n    for i in range(M):\n        if cardCounts[purchases[i][0]-1]!= 2*purchases[i][1] + purchases[i][2]:\n            print(i)\n            purchases[i][2] = 1\n            cardCounts[purchases[i][0]-1] += 1\n            cardCounts[purchases[i][1]-1] -= 1\n    return purchases\n\nprint(solution('''2 3\n5 1\n1 2\n1 2\n1 2\n1 2\n'''))"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # get input\n    N, M = stdin.split('\\n')[0].split(' ')\n    N = int(N)\n    M = int(M)\n    cards = [int(i) for i in stdin.split('\\n')[1].split(' ')]\n    assert all(0<=card<=2000 for card in cards)\n    assert len(cards) == N\n    \n    # build solution\n    for _ in range(M):\n        a, b = stdin.split('\\n')[2+_].split(' ')\n        assert int(a) < int(b)\n        assert int(a) in range(1, N+1)\n        assert int(b) in range(1, N+1)\n    \n    return ''\n\nprint(solution(input()))"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(\" \"))\n    cards = list(map(int, stdin.split(\" \")))\n    purchases = []\n    for _ in range(m):\n        purchases.append(map(int, stdin.split(\" \")))\n    # print(purchases)\n    purchases = [tuple(item) for item in purchases]\n    # print(purchases)\n    purchases = set(purchases)\n    # print(purchases)\n    purchases = list(purchases)\n    # print(purchases)\n\n    return \" \".join(str(len(purchases)) + \" \" + \" \".join(map(str, purchases)) + \" \" + str(max(cards)) * 3)\n\n\ndef"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    children = int(stdin.split('\\n')[0].split()[0])\n    purchases = int(stdin.split('\\n')[0].split()[1])\n    numbers = [int(i) for i in stdin.split('\\n')[1].split()]\n    print(children, purchases)\n    print(numbers)\n    cards = [[i, j, 0] for i in range(children) for j in range(children)]\n    for i in range(purchases):\n        childrens = [int(j) for j in stdin.split('\\n')[i + 2].split()]\n        print(childrens)\n        for j in range(2):\n            cards[childrens[j] - 1][j + 1] += 2\n            cards[childrens[j + 2] - 1][j + 1] += 1\n    print(cards)\n    return ''\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    children, purchases = map(int, stdin.split(' '))\n    counts = stdin[stdin.index(' ') + 1:].split(' ')\n    cards = [0] * children\n    for i in range(children):\n        cards[i] = int(counts[i])\n    for i in range(purchases):\n        first, second, num = stdin[stdin.index(' ') + 1 + i * 3 + 1:].split(' ')\n        first, second = int(first) - 1, int(second) - 1\n        cards[first] += num\n        cards[second] += num\n    count = 0\n    for i in range(children):\n        for j in range(i + 1, children):\n            count += cards[i] * cards[j]\n    return count\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = [int(i) for i in stdin.split()]\n    cards = [int(i) for i in stdin.split()]\n    # cards = [int(i) for i in input().split()]\n    # M = int(input())\n    # N, M = [int(i) for i in input().split()]\n    # cards = [int(i) for i in input().split()]\n    # for i in range(M):\n    #     cards.append([int(i) for i in input().split()])\n    purchases = []\n    for i in range(M):\n        purchases.append([int(i) for i in stdin.split()])\n    # purchases = [[int(i) for i in input().split()] for i in range(M)]\n\n    all_cards = set(cards)\n    for purchase in purchases:\n        cards_sold = [0, 0]\n        for i in range(2):\n            cards_sold[i] = purchase[i]\n        for i in range(2, 3):\n            cards_sold[i] = cards[cards_sold[i]]\n        if cards_sold[0] == cards_sold[1]:\n            cards_sold[2] = 2\n        for i in range(2):\n            cards_sold[i] = cards_sold[i] // 2\n            all_cards.remove(cards_sold[i])\n        cards_sold[0] = cards_sold[0] - cards_sold[1]\n        cards_sold[1] = 0\n        cards_sold[2] = 0\n        for i in range(2):\n            cards_sold[i] = cards_sold[i] + cards[cards_sold[i]]\n        cards[cards_sold[0]] = cards[cards_sold[0]] + cards_sold[2]\n        cards[cards_sold[1]] = cards[cards_sold[1]] + cards_sold[2]\n        print(purchase[0], cards_sold[0], cards_sold[1], sep=\" \")\n\n    return '\\n'.join(str(i) for i in cards)"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Write a program that determines the participants in all purchases that were made and who won the subsequent races so that after all the purchases, the cards counts correspond to the given counts.\"\"\"\n\n    # Read the input\n    (children, purchases) = input_as_ints(stdin)\n\n    # Get the number of cards each child currently has\n    cards = input_as_ints(stdin)\n\n    # Initialize the winners with zero\n    winners = [0] * children\n\n    # For each purchase\n    for i in range(purchases):\n\n        # Get the two children that made the purchase\n        (child1, child2) = input_as_ints(stdin)\n\n        # The winner gets two cards\n        winners[child1 - 1] += 2\n        winners[child2 - 1] += 2\n\n    # Print the number of purchases\n    print(purchases)\n\n    # Print the cards each child has\n    for card in winners:\n        print(card, end=' ')\n\n    # Separate the different possible solutions\n    print()\n\n    # Print the solution(s)\n    print_solutions(children, cards, winners)\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split(' '))\n    players = set()\n    purchases = 0\n    for i in range(M):\n        a, b = map(int, stdin.split(' ')[2 * i + 1 : 2 * i + 3])\n        players.add(a)\n        players.add(b)\n    cards = dict()\n    for player in players:\n        cards[player] = 0\n    for i in range(M):\n        a, b = map(int, stdin.split(' ')[2 * i + 1 : 2 * i + 3])\n        if cards[a] < cards[b]:\n            cards[a] += 2\n            purchases += 1\n        else:\n            cards[b] += 2\n            purchases += 1\n    return purchases\n"
    },
    {
        "number": 3153,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # stdin = stdin.split(\"\\n\")\n    # n = int(stdin[0].split()[0])\n    # m = int(stdin[0].split()[1])\n    # d = int(stdin[0].split()[2])\n    # events = []\n    # for i in range(1, len(stdin)):\n    #     events.append([int(stdin[i].split()[0]), int(stdin[i].split()[1]), int(stdin[i].split()[2])])\n    # events = sorted(events, key=lambda x: (x[0], x[2]))\n    # if len(events) < n:\n    #     return \"impossible\"\n    # toys = [-1 for i in range(m)]\n    # for i in range(n):\n    #     if toys[events[i][1]] == -1:\n    #         toys[events[i][1]] = events[i][2]\n    #     else:\n    #         return \"impossible\"\n    # toys = sorted(toys)\n    # for i in range(len(toys)):\n    #     if toys[i]!= i+1:\n    #         return \"impossible\"\n    # return \" \".join([str(i) for i in toys])\n    \n    # Your code here\n    # stdin = stdin.split(\"\\n\")\n    n = int(stdin[0].split()[0])\n    m = int(stdin[0].split()[1])\n    d = int(stdin[0].split()[2])\n    events = []\n    for i in range(1, len(stdin)):\n        events.append([int(stdin[i].split()[0]), int(stdin[i].split()[1]), int(stdin[i].split()[2])])\n    events = sorted(events, key=lambda x: (x[0], x[2]))\n    if len(events) < n:\n        return \"impossible\"\n    toys = [-1 for i in range(m)]\n    toys[events[0][1]] = events[0][2]\n    for i in range(1, n):\n        if toys[events[i][1]] == -1:\n            toys[events[i][1]] = events[i][2]\n        else:\n            return \"impossible\"\n    toys = sorted(toys)\n    for i in range(len(toys)):\n        if toys[i]!= i+1:\n            return \"impossible\"\n    return \" \".join([str(i) for i in toys])\n    "
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"https://www.codewars.com/kata/5cd9fa0f8c5ec9073d50000b\"\"\"\n    # your solution here\n    # return '1'\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the given problem.\n    \"\"\"\n    n, m, d, events = [int(x) for x in stdin.split()]\n    events.sort()\n    toys = [None] * n\n    for event in events:\n        s, k, t = [int(x) for x in event.split()]\n        if t == 0:\n            toys[k - 1] = None\n        else:\n            toys[k - 1] = t\n    # Your solution goes here\n    return''.join([str(x) for x in toys if x])\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    prev_toys = [0] * n\n    for d, e in zip(map(int, stdin.split()), range(int(stdin.split()[-1]))):\n        stdin = stdin.split('\\n')\n        for s, k, t in zip(stdin[e].split(), range(n), range(m)):\n            s, k, t = map(int, s.split())\n            if t == 0:\n                if prev_toys[k]!= 0:\n                    prev_toys[k] = 0\n            elif prev_toys[k] == t:\n                return 'impossible'\n            else:\n                prev_toys[k] = t\n    return''.join(map(str, prev_toys))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Solution for Task 1:\n    return str(1)\n\ndef"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Calculate the toys to give to each kid.\"\"\"\n    line = stdin.readline().split()\n    n, m = map(int, line)\n    toys = [0] * m\n    for i in range(n):\n        line = stdin.readline().split()\n        d, e = map(int, line)\n        toy = 0\n        for s in range(d):\n            t, k, tt = map(int, stdin.readline().split())\n            if tt!= 0:\n                toys[k] = tt\n    return''.join(map(str, toys))"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the solution\"\"\"\n    # Initialize the data\n    n, m = stdin.split()\n    d, e = [int(x) for x in stdin.split()]\n    log = dict()\n    for i in range(e):\n        s, k, t = [int(x) for x in stdin.split()]\n        if k not in log:\n            log[k] = set()\n        log[k].add(t)\n    # Solution\n    kids = list(log.keys())\n    toys = [x for x in range(m)]\n    res = []\n    # If there is no solution, return impossible\n    if len(kids) < n:\n        return 'impossible'\n    # If there is one solution, return it\n    elif len(kids) == n:\n        for i in kids:\n            res.append(toys.pop(0))\n        return''.join([str(x) for x in res])\n    # If there is more than one solution, find one\n    else:\n        while len(toys) > 0:\n            t = toys.pop(0)\n            res.append(t)\n            for i in kids:\n                if t not in log[i]:\n                    continue\n                # If the child can steal\n                if t in log[i]:\n                    log[i].remove(t)\n                    kids[kids.index(i)].remove(t)\n                    # If the child can steal from all kids\n                    if len(kids[kids.index(i)]) == 0:\n                        kids.pop(kids.index(i))\n                        # If there is no more solution, return impossible\n                        if len(kids) == 0:\n                            return 'impossible'\n            # If there is no more solution, return impossible\n            if len(kids) == 0:\n                return 'impossible'\n        # If there is still a solution, return it\n        for i in kids:\n            res.append(toys.pop(0))\n        return''.join([str(x) for x in res])\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = [int(x) for x in stdin.split(' ')]\n    d, e = [int(x) for x in stdin.split(' ')]\n    events = []\n    for _ in range(e):\n        events.append([int(x) for x in stdin.split(' ')])\n    events.sort(key=lambda x: x[1], reverse=True)\n\n    teams = {i: {t: 0 for t in range(1, m + 1)} for i in range(1, n + 1)}\n    for i in range(n):\n        for t in range(1, m + 1):\n            teams[i + 1][t] = max(teams[i + 1][t], teams[i][t])\n\n    toys = [0]\n    for i in range(1, n + 1):\n        toys.append(teams[i][toys[-1]] + 1)\n\n    j = 0\n    for i, event in enumerate(events):\n        if event[0] == 0:\n            continue\n        while j < len(toys) and event[0] >= toys[j]:\n            j += 1\n        if j < len(toys) and event[1] == toys[j]:\n            t = event[2]\n            if t!= 0:\n                teams[event[1]][t] = toys[j] - 1\n            else:\n                teams[event[1]][t] = 0\n            for t in range(t, toys[j]):\n                teams[event[1]][t] = max(teams[event[1]][t], teams[event[1]][t - 1] + 1)\n            j += 1\n\n    solution = []\n    for team in teams.values():\n        solution += list(team.values())[1:]\n    if solution.count(0) == len(solution):\n        return 'impossible'\n\n    return''.join([str(s) for s in solution])\n\nprint(solution(input()))"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split(\" \")[:2])\n    toys = list(map(int, stdin.split(\"\\n\")[2:]))\n    toys = sorted(toys, reverse=True)\n    print(toys)\n    print(max(toys))\n    if m == 1:\n        return \"impossible\"\n\n    def badness(n, m, toys):\n        dp = [float('inf') for _ in range(m + 1)]\n        dp[0] = 0\n        for t in toys:\n            for i in range(1, m + 1):\n                dp[i] = min(dp[i], dp[i - 1] + abs(t - i))\n        return dp[m]\n    \n    def solve(n, m, toys):\n        toys = sorted(toys, reverse=True)\n        dp = [0 for _ in range(m + 1)]\n        dp[0] = toys[0]\n        for t in toys[1:]:\n            for i in range(1, m + 1):\n                dp[i] = min(dp[i], dp[i - 1] + abs(t - i))\n            dp[t] = float('inf')\n        return dp[m]\n\n    # binary search\n    lo = 0\n    hi = n\n    while hi - lo > 1:\n        mid = (lo + hi) // 2\n        if solve(n, mid, toys) > badness(n, m, toys):\n            hi = mid\n        else:\n            lo = mid\n    return \" \".join(map(str, range(lo, hi)))\n"
    },
    {
        "number": 3154,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"We can use dynamic programming to solve this problem.\n    dp[i][j] stores the min number of toys the ith kid can play with.\n    \"\"\"\n    n, m = map(int, stdin.split(' '))\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    dp[0][0] = 0\n    dp[0][1] = -1\n    for _ in range(int(stdin.split(' ')[2])):\n        s, k, t = map(int, stdin.split(' ')[:3])\n        for i in range(n):\n            for j in range(m):\n                if dp[i][j] == 0:\n                    continue\n                if dp[i][j] < 0:\n                    continue\n                if i == k and j == t:\n                    dp[i][j] = min(dp[i][j], 1)\n                if dp[i - 1][j] > 0 and j + 1 < m:\n                    if i == k:\n                        dp[i][j + 1] = -1\n                    else:\n                        dp[i][j + 1] = min(dp[i][j + 1], dp[i - 1][j] + 1)\n                if dp[i][j - 1] > 0 and j + 1 < m:\n                    if i == k:\n                        dp[i][j + 1] = -1\n                    else:\n                        dp[i][j + 1] = min(dp[i][j + 1], dp[i][j - 1] + 1)\n    if dp[-1][0] < 0:\n        return 'impossible'\n    return''.join([str(i) for i in range(1, n + 1) if dp[i - 1][0] >= 1])\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    cache = {}\n    for n in range(x + 1):\n        for k in range(n + 1):\n            if (n, k) not in cache:\n                cache[(n, k)] = n * k\n            else:\n                return n, k\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    n = 1\n    k = 1\n    # Largest n <= x // k\n    # Smallest k <= x\n    for k in range(1, x + 1):\n        n *= x - k + 1\n        n //= k\n        if n <= x:\n            break\n    return \"%d %d\" % (n, k)\n\n\"\"\""
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    a = [0] * (X + 1)\n    b = [0] * (X + 1)\n    for n in range(1, X + 1):\n        for k in range(1, n + 1):\n            a[n] += 1\n            if X % k == 0:\n                b[n] += 1\n    m = max(b)\n    best_n, best_k = None, None\n    for n, k in enumerate(b):\n        if k == m and (best_n is None or n < best_n):\n            best_n, best_k = n, k\n    if best_n is None:\n        return 'impossible'\n    return str(best_n) +'' + str(best_k)\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    n_min = 10001\n    k_min = 10001\n    while X > 0:\n        r = X % (n + 1)\n        n += 1\n        if r == 0:\n            k += 1\n            if n < n_min:\n                n_min = n\n                k_min = k\n            elif n == n_min:\n                if k < k_min:\n                    k_min = k\n        X //= n\n    return str(n_min) +'' + str(k_min)"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return first solution of X\"\"\"\n    # Your code here\n    X = int(stdin)\n    if X < 2:\n        return X\n    n, k = 0, 0\n    # As it turns out, there is an upper bound on n and k. The smallest value of n, k such that n choose k = X, is 2, and the largest value of n, k such that n choose k = X, is 10,000, so the maximum value of n and k is 10000\n    for n in range(1, 10_001):\n        for k in range(n+1):\n            if X == (n - k) * (n + k):\n                return n, k\n    return n, k\n    \n\"\"\"\nimport math\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    # Solution using binary search.\n    def n_choose_k(n, k):\n        if k == 0:\n            return 1\n        elif k == 1:\n            return n\n        return n_choose_k(n-1, k-1) + n_choose_k(n-1, k)\n    # Solution using combinatorics.\n    # def n_choose_k_combinatorics(n, k):\n    #     num_combinations = binomial_coefficient(n+k-1, k)\n    #     num_combinations -= binomial_coefficient(n+k-1, k-1)\n    #     return num_combinations\n    # def binomial_coefficient(n, k):\n    #     if k == 0:\n    #         return 1\n    #     elif k == 1:\n    #         return n\n    #     return binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n    # num_combinations = binomial_coefficient(X+1, 2)\n    # num_combinations -= binomial_coefficient(X+1, 1)\n    # smallest_n = num_combinations - 1\n    # smallest_k = 1\n    # for k in range(2, int(math.sqrt(X)) + 1):\n    #     num_combinations = binomial_coefficient(X+k-1, 2)\n    #     num_combinations -= binomial_coefficient(X+k-1, 1)\n    #     num_combinations -= binomial_coefficient(X+k-1, k)\n    #     if num_combinations < smallest_n:\n    #         smallest_n = num_combinations\n    #         smallest_k = k\n    # return str(smallest_n) +'' + str(smallest_k)\n    return str(n_choose_k(X+1, 2)) +'' + str(n_choose_k(X+1, 1))\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the pair of integers that are equal to 2020.\"\"\"\n    n, k = 2020, 0\n    for i, a in enumerate(stdin.split(' ')):\n        a = int(a)\n        if n - k == a:\n            k = i + 1\n        elif n - k > a:\n            n, k = a, i + 1\n    return f\"{n} {k}\"\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    n, k, smallest_n, smallest_k = 1, 1, 1, 1\n    while n <= x:\n        k += 1\n        if n ** 2 - n + k ** 2 == x:\n            if smallest_k == k:\n                if smallest_n == n:\n                    n, k = n + 1, k + 1\n                else:\n                    n, k = n, k + 1\n            else:\n                n, k = n, k\n                smallest_n, smallest_k = n, k\n        elif n ** 2 - n + k ** 2 < x:\n            n, k = n + 1, k + 1\n            smallest_n, smallest_k = n, k\n        else:\n            break\n    return str(smallest_n) + \" \" + str(smallest_k)\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the solution to the binomial coefficient problem\n\n    Args:\n        stdin (str): The input given in the prompt\n    \n    Returns:\n        str: The solution to the problem\n    \"\"\"\n    X = int(stdin)\n    def binomial(n, k):\n        \"\"\"Computes the binomial coefficient\n\n        Args:\n            n (int): The first number in the binomial coefficient\n            k (int): The second number in the binomial coefficient\n\n        Returns:\n            int: The value of the binomial coefficient\n        \"\"\"\n        if k == 0:\n            return 1\n        return binomial(n - 1, k) + binomial(n - 1, k - 1)\n    n, k = X, 1\n    while binomial(n, k)!= X:\n        if binomial(n, k) < X:\n            k += 1\n        else:\n            n -= 1\n    return f\"{n} {k}\"\n"
    },
    {
        "number": 3155,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    while X > 0:\n        n += 1\n        X = X // 2\n    while X > 0:\n        k += 1\n        X = X // k\n    return str(n) + \" \" + str(k)"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Imports time and sets the speed of the game\n    import time\n    import sys\n\n    # Sets the start time for the program\n    start_time = time.time()\n\n    # Creates variables\n    n = int(stdin[0])\n    k = int(stdin[1])\n\n    # Lists to store the stores and items\n    l_items = []\n    l_stores = []\n\n    # Creates lists for the items and stores\n    for i in range(k):\n        # Adds items to the list\n        l_items.append(stdin[2 + i].split())\n        # Adds the stores to the list\n        l_stores.append(stdin[2 + k + i].split())\n\n    # Returns the amount of stores and items\n    return len(l_items), len(l_stores)\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    stores = {}\n    for i in range(N):\n        store, items = stdin.readline().split()\n        store = int(store)\n        items = [item for item in items]\n        if store in stores.keys():\n            stores[store].extend(items)\n        else:\n            stores[store] = items\n    K = int(stdin.readline())\n    for i in range(K):\n        items = stdin.readline()\n        items = [item for item in items]\n    check_list = []\n    for key in stores.keys():\n        for item in items:\n            if item in stores[key]:\n                check_list.append(True)\n            else:\n                check_list.append(False)\n    if False in check_list:\n        print(\"unique\")\n    else:\n        print(\"ambiguous\")\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3\n   ... 3\n   ... 0 chocolate\n   ... 1 icecream\n   ... 2 cookies\n   ... 3\n   ... 2 chocolate\n   ... 3\n   ... icecream\n   ... 1 cookies''')\n    'impossible'\n    >>> solution('''3\n   ... 3\n   ... 0 chocolate\n   ... 1 icecream\n   ... 2 cookies\n   ... 3\n   ... 2 chocolate\n   ... 3\n   ... icecream\n   ... 1 cookies''')\n    'unique'\n    >>> solution('''3\n   ... 3\n   ... 0 chocolate\n   ... 1 icecream\n   ... 2 cookies\n   ... 3\n   ... 2 chocolate\n   ... 3\n   ... icecream\n   ... 1 cookies''')\n    'ambiguous'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the stores the sister bought and calls the solver.\n    \"\"\"\n    number_of_stores = int(stdin.readline())\n    number_of_items = int(stdin.readline())\n    inventories = [int(stdin.readline()) for _ in range(number_of_stores)]\n    items = [stdin.readline().strip() for _ in range(number_of_items)]\n\n    return solver(number_of_stores, inventories, items)\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    return ''\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your Solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Solution goes here\n    # print(\"input:\", stdin)\n    n = int(stdin.split(\"\\n\")[0])\n    s = [tuple(line.split(\" \")) for line in stdin.split(\"\\n\")[1:]]\n    # print(\"n:\", n)\n    # print(\"s:\", s)\n    inventory = [0] * n\n    for i in range(n):\n        inventory[i] = set(s[i][1].split(\",\"))\n        # print(\"inventory[\", i, \"]:\", inventory[i])\n    inventory_dict = dict(zip(range(n), inventory))\n    # print(\"inventory_dict:\", inventory_dict)\n    ans = []\n    for i in range(n):\n        ans.append(set(s[i][1].split(\",\")))\n        # print(\"ans[\", i, \"]:\", ans[i])\n    ans = tuple(ans)\n    # print(\"ans:\", ans)\n    ans_dict = {}\n    for i in range(len(ans)):\n        for j in ans[i]:\n            ans_dict[j] = i\n        # print(\"ans_dict[\", i, \"]:\", ans_dict[i])\n    ans_dict = dict(zip(ans, range(len(ans))))\n    # print(\"ans_dict:\", ans_dict)\n    return ans_dict[s[n - 1][1]]\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Solution begins here:\n    store_inv, item_list = get_input(stdin)\n    store_inv_list = []\n    for i in range(len(store_inv)):\n        store_inv_list.append([])\n        store_inv_list[i] = store_inv[i]\n    item_list = [item.lower() for item in item_list]\n    for item in item_list:\n        find_item_in_store_inv_list(item, store_inv_list)\n    if len(store_inv_list) == 1:\n        return \"unique\"\n    return \"ambiguous\"\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your code here.\"\"\"\n    pass"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('1 0 10')\n    0\n    >>> solution('1 2 10')\n    1\n    >>> solution('5 3 10')\n    5\n    >>> solution('5 3 10')\n    5\n    \"\"\"\n    n, k, m = list(map(int, stdin.split()))\n    if m == 1:\n        return 0\n    return f(k, m, n) - f(k, m, n - 1)\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    return str(int(stdin))\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''3 7 10''')\n    '3'\n    >>> solution('''4 0 2''')\n    '1'\n    \"\"\"\n    n, h, m = map(int, stdin.split())\n    return str(sum(bin(h ^ x ^ 1).count('1') for x in range(1 << m)))\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the number of words with a hash function\n\n    Args:\n        stdin (str): Input\n\n    Returns:\n        str: Solution\n    \"\"\"\n    n, k, m = [int(i) for i in stdin.split()]\n    return str(sum([1 for i in range(n + 1) if f(i, k, m) < 2 ** m]))\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    k %= 1 << m\n    k = bin(k)[2:]\n    return '0' if k.count('1') == 0 else '1'\n    return n\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    length, hash, mod = map(int, stdin.split())\n    d = dict(zip(\n        [chr(ord('a') + i) for i in range(26)],\n        [1 << i for i in range(26)]\n    ))\n    return (((hash * 33) ^ d[chr(97 + length - 1)]) % mod) - 1\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    n, k, m = [int(x) for x in stdin.split()]\n    f = lambda a: (a * 33) % m\n    return sum(f(0) == k for _ in range(n))"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(stdin='''1 0 10''')\n    0\n    >>> solution(stdin='''1 2 10''')\n    1\n    \"\"\"\n    n, k, m = list(map(int, stdin.split()))\n    return bin(k).count('1') % m\n"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split(' '))\n    return len([True for word in range(1, n + 1) for letter in range(1, 26) if f(word, letter) == k])\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve problem.\n\n    >>> solution(\"1 0 10\")\n    0\n    >>> solution(\"1 2 10\")\n    1\n    \"\"\"\n    n, k, m = [int(number) for number in stdin.split()]\n    return str(solve(n, k, m))\n\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"............................................................\\n............................................................\\n..........................................XXXX..............\\n.....................................XXX......XXXX..........\\n....................................XXXX........X...........\\n........XXX....XXX....................X.....................\\n.........XXX...XX...........................................\\n............................................................\\n............................................XX..............\\n...........................................XXXX.............\\n.............................................XX.............\\n............................................................\")\n    '3 zoom out'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"............................................................\\n............................................................\\n..........................................XXXX..............\\n...........................................XXX..............\\n....................................XXXX........X...........\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\")\n    '2 zoom out'\n    >>> solution(\"............................................................\\n............................................................\\n..........................................XXXX..............\\n...........................................XXX..............\\n....................................XXXX........X...........\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\")\n    '3 rotate'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def solve(p: str, q: str) -> Tuple[str, str, str]:\n        \"\"\"\n        >>> solve('X.............................. X.....................',\n       ... 'X.............................. X.....................')\n        ('1 pan', 'out', 'left')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('2 zoom in', 'out', 'left')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('2 zoom out', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('2 zoom out', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('2 pan', 'in', 'left')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XXXX...................... X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XXXX...................... X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n        ('1 pan', 'out', 'right')\n        >>> solve('XX.............................. X.....................',\n       ... 'XX.............................. X.....................')\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"............................................................\\n............................................................\\n....XXXX....................................................\\n....XXXX..................................XXXX..............\\n....XXXX...................................XXX..............\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\")\n    '3 zoom out'\n    >>> solution(\"............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n............................................................\\n.....................................................XXXX..............\\n...........................................XXXX.............\\n.............................................XX.............\\n............................................................\")\n    '5 rotate clockwise'\n    \"\"\"\n    return (\n        f\"{sum(map(len, get_touches(stdin)))} {get_gesture(stdin)}\"\n        if get_gesture(stdin)\n        else f\"{get_gesture(stdin)} {sum(map(len, get_touches(stdin)))}\"\n    )\n\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return a string representing the gesture.\n    \"\"\"\n   ..."
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n\"\"\"\n    def get_touches(lines):\n        touches = {}\n        for line in lines.split(\"\\n\"):\n            if len(line) == 0:\n                continue\n            line = line.replace(\".\", \"\")\n            for i in range(len(line)):\n                if line[i] == \"X\":\n                    if i not in touches:\n                        touches[i] = []\n                    touches[i].append(i)\n        return touches\n\n    def compute_score(grip1, grip2):\n        # Return 1 if g1 is better than g2, 0 if equal, -1 if g1 is worse.\n        # g1 is better than g2 if sum(distance) is minimized,\n        # g1 is worse than g2 if sum(distance) is maximized.\n        score = 0\n        if len(grip1)!= len(grip2):\n            return 1\n        for i in range(len(grip1)):\n            if len(grip1[i]) == len(grip2[i]):\n                score += abs(grip1[i][0] - grip2[i][0])\n                score += abs(grip1[i][-1] - grip2[i][-1])\n                g1 = (grip1[i][0] + grip1[i][-1]) / 2\n                g2 = (grip2[i][0] + grip2[i][-1]) / 2\n                score += abs(g1 - g2)\n        return score\n\n    def compute_best_grip(touches):\n        # Find the best grip and return its score and best_grip.\n        best_grip = None\n        best_score = -1\n        for grip in touches:\n            if best_grip is None or compute_score(best_grip, grip) > best_score:\n                best_grip = grip\n                best_score = compute_score(best_grip, grip)\n        return best_grip, best_score\n\n    def compute_grip_rotation(grip):\n        # Return the rotation in radians between the two grip points.\n        g1 = (grip[0][0] + grip[0][-1]) / 2\n        g2 = (grip[1][0] + grip[1][-1]) / 2\n        rotation = math.atan2(g2 - g1, g1 - g2)\n        if rotation < 0:\n            rotation += math.pi * 2\n        return rotation\n\n    def compute_grip_spread(grip):\n        # Return the average distance between the two grip points.\n        return (grip[0][0] - grip[1][0]) / 2\n\n    def compute_grip_spread_improvement(grip):\n        # Return the difference between the initial and final grip spreads.\n        return abs(compute_grip_spread(grip) - compute_grip_spread(best_grip))\n\n    def compute_grip_rotation_improvement(grip):\n        # Return the difference between the initial and final grip rotations.\n        return abs(compute_grip_rotation(grip) - compute_grip_rotation(best_grip))\n\n    def compute_direction(grip):\n        # Return 0 for pan, 1 for zoom out, 2 for rotate clockwise, and 3 for rotate counterclockwise.\n        if compute_grip_spread_improvement(grip) > 10 ** -5:\n            return 1\n        elif compute_grip_rotation_improvement(grip) > 10 ** -5:\n            return 2\n        else:\n            return 3\n\n    initial_grip, initial_score = compute_best_grip(get_touches(stdin.split(\"\\n\")[0]))\n    final_grip, final_score = compute_best_grip(get_touches(stdin.split(\"\\n\")[1]))\n    if final_score < initial_score:\n        print(1, compute_direction(final_grip))\n    elif final_score > initial_score:\n        print(2, compute_direction(final_grip))\n    else:\n        print(0, compute_direction(final_grip))\n\n    return 0\n\nsolution(\"\"\"\n...................\n...................\n........X.........\n...................\n.................\n...................\n...................\n...................\n...................\n\"\"\")\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3158,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    This function returns the type of gesture with the greatest associated\n    distance in the given image. The function takes a string of the form:\n        image1\n        image2\n       ...\n        imageN\n\n    where each image is of the form:\n        [X.][X.]\n        [X.][X.]\n       ...\n        [X.][X.]\n        [X.][X.]\n\n    It then returns the type of gesture and the direction of the gesture for\n    zoom and rotate. The types of gestures are 'pan', 'zoom', and 'rotate'.\n    The directions of the gestures are 'out' for zoom and 'clockwise' for rotate.\n    '''\n    # get image sizes from input string\n    input_string = stdin.split('\\n')\n    n = int(input_string[0].split(' ')[0])\n    m = int(input_string[0].split(' ')[1])\n\n    # create two dicts for touch counts and grip spreads\n    touch_counts = {}\n    grip_spreads = {}\n    for i in range(1, n+1):\n        touch_count = 0\n        touch_counts[i] = touch_count\n\n        for j in range(m):\n            if input_string[i][j] == 'X':\n                touch_count += 1\n        grip_spread = 0\n        grip_spreads[i] = grip_spread\n\n        for j in range(m):\n            if input_string[i][j] == 'X':\n                if j!= 0:\n                    if input_string[i][j-1] == 'X':\n                        grip_spread += 1\n                if j!= m - 1:\n                    if input_string[i][j+1] == 'X':\n                        grip_spread += 1\n        grip_spreads[i] = grip_spread / touch_count\n\n    # compare touch counts\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if touch_counts[i] < touch_counts[j]:\n                temp = touch_counts[i]\n                touch_counts[i] = touch_counts[j]\n                touch_counts[j] = temp\n                temp = grip_spreads[i]\n                grip_spreads[i] = grip_spreads[j]\n                grip_spreads[j] = temp\n\n    # compare grip spreads\n    for i in range(1, n+1):\n        if i!= n:\n            if grip_spreads[i+1] < grip_spreads[i]:\n                temp = i\n                if i == 1:\n                    if touch_counts[i+1] < touch_counts[i+2]:\n                        temp = i+1\n                else:\n                    if touch_counts[i+1] < touch_counts[i]:\n                        temp = i+1\n                temp_grip_spread = grip_spreads[i]\n                grip_spreads[i] = grip_spreads[temp]\n                grip_spreads[temp] = temp_grip_spread\n                temp_touch_count = touch_counts[i]\n                touch_counts[i] = touch_counts[temp]\n                touch_counts[temp] = temp_touch_count\n\n    # determine gesture type and direction\n    gesture_type = ''\n    direction = ''\n    if touch_counts[n] == 1:\n        gesture_type = 'pan'\n        direction = 'out'\n    else:\n        # if the gesture is a zoom\n        if touch_counts[1] == 1 and touch_counts[n] == n - 1:\n            gesture_type = 'zoom'\n            direction = 'out'\n        # if the gesture is a rotate\n        elif touch_counts[1] == 1 and touch_counts[n]!= n - 1:\n            gesture_type = 'rotate'\n            direction = 'clockwise'\n        # if the gesture is a pan\n        elif touch_counts[1]!= 1 and touch_counts[n] == n - 1:\n            gesture_type = 'rotate'\n            direction = 'clockwise'\n        # if the gesture is a zoom\n        else:\n            gesture_type = 'zoom'\n            direction = 'in'\n\n    # return the type of gesture and the direction of the gesture for zoom and rotate\n    return gesture_type +'' + direction\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    width = int(stdin.split()[0])\n    height = int(stdin.split()[1])\n    if width < 3 or height < 3:\n        return ''\n    grid = []\n    for _ in range(height):\n        grid.append(stdin.split('\\n')[1:][-1])\n    \n    # clean up grid\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] == '=':\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n            elif grid[i][j] == '+':\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n            elif grid[i][j] == '#':\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n            elif grid[i][j] == '>':\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n            elif grid[i][j] == '<':\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] =='':\n                grid[i] = grid[i][:j] + grid[i][j + 1:]\n    \n    # count number of spaces\n    space_count = 0\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] =='':\n                space_count += 1\n    \n    # return when no more spaces\n    if space_count == 0:\n        return ''\n    \n    # create a counter of spaces\n    space_counter = {}\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] =='':\n                if (i, j) in space_counter:\n                    space_counter[(i, j)] += 1\n                else:\n                    space_counter[(i, j)] = 1\n\n    # return when all spaces are the same\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] =='' and space_counter[(i, j)] == space_count:\n                return ''\n\n    # create the list of all images\n    images = {}\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j]!='' and grid[i][j] not in images:\n                images[grid[i][j]] = []\n                # if the current character is not an image\n            if grid[i][j] =='':\n                if grid[i - 1][j] in images:\n                    images[grid[i - 1][j]].append((i, j))\n                if grid[i + 1][j] in images:\n                    images[grid[i + 1][j]].append((i, j))\n                if grid[i][j - 1] in images:\n                    images[grid[i][j - 1]].append((i, j))\n                if grid[i][j + 1] in images:\n                    images[grid[i][j + 1]].append((i, j))\n\n    # sort the list of images by the number of characters\n    images = {k: v for k, v in sorted(images.items(), key=lambda item: item[1][0])}\n\n    # return if only one image\n    if len(images) == 1:\n        return ''\n\n    # return if only one space\n    if len(images) == 0:\n        return grid\n    \n    # get all banned characters\n    banned_chars = set()\n    for char in images:\n        if len(images[char]) == 0:\n            continue\n        min_row = min(images[char], key=lambda t: t[0])[0]\n        max_row = max(images[char], key=lambda t: t[0])[0]\n        min_col = min(images[char], key=lambda t: t[1])[1]\n        max_col = max(images[char], key=lambda t: t[1])[1]\n        for i in range(min_row, max_row + 1):\n            for j in range(min_col, max_col + 1):\n                if grid[i][j]!='':\n                    banned_chars.add(grid[i][j])\n    \n    # remove all banned characters\n    for i in range(height):\n        for j in range(width):\n            if grid[i][j] =='':\n                continue\n            if grid[i][j] in banned_chars:\n                grid[i] = grid[i][:j] +'' + grid[i][j + 1:]\n\n    # return the result\n    return '\\n'.join(grid)"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_letters(string: str) -> set:\n        # Get all the unique letters in a string\n        letters = set()\n        for c in string:\n            if 'A' <= c <= 'Z' or 'a' <= c <= 'z' or c in '?!., ':\n                letters.add(c)\n        return letters\n\n    def replace_border(string: str, border: str, replacement: str) -> str:\n        # Replace the border of a string with a new string\n        return string[0: border[0]] + replacement + string[border[1]:]\n\n    def replace_letters(string: str, letters: set, replacement: str) -> str:\n        # Replace all letters found in a string with a new string\n        for c in letters:\n            string = string.replace(c, replacement)\n        return string\n\n    def remove_ads(string: str) -> str:\n        # Find all ad characters in a string\n        ads = set()\n        for c in'$+$':\n            if c in string:\n                ads.add(c)\n\n        # Find all ad borders in a string\n        borders = set()\n        for i in range(len(string)):\n            if string[i] in ads:\n                if i == 0:\n                    borders.add('$')\n                elif i == len(string)-1:\n                    borders.add('$')\n                else:\n                    borders.add('+')\n            elif string[i] =='':\n                borders.add('$')\n\n        # Replace all ad characters with whitespace\n        for c in ads:\n            string = replace_border(string, c,'')\n\n        # Replace all ad borders with whitespace\n        for c in borders:\n            string = replace_letters(string, c,'')\n\n        return string\n\n    # Obtain height and width of input\n    height, width = [int(num) for num in stdin.split(' ')]\n\n    # Obtain input as a string\n    string = ''\n    for _ in range(height):\n        string += stdin.split('\\n')[-1] + '\\n'\n    string = string[0:-1]\n\n    # Remove ads from the string\n    return remove_ads(string)"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution to the problem for this day.\n    \"\"\"\n\n    # Get the input as a list of lines\n    stdin_list = stdin.splitlines()\n\n    # Remove the whitespaces, new lines and tabs from each line\n    # then convert to a list of strings\n    stdin_list = [x.strip() for x in stdin.splitlines() if x!= '']\n\n    # Get the height and width of the web page\n    height, width = [int(x) for x in stdin_list[0].split()]\n\n    # Create a 2D array to store the image\n    # each element represents a row\n    matrix = ['' for _ in range(height)]\n\n    # Add the data to the matrix\n    for i in range(height):\n        matrix[i] = stdin_list[i + 1]\n\n    # The height of the final image\n    # Width of the final image\n    final_height = height\n    final_width = width\n\n    # Create a 2D array to store the final image\n    final_matrix = ['' for _ in range(final_height)]\n\n    # Remove all the spaces from the borders\n    # and add to the final matrix\n    for i in range(height):\n        matrix[i] = matrix[i].replace(' ', '')\n        matrix[i] = matrix[i].replace('=', '')\n        for j in range(width):\n            if matrix[i][j]!= '+':\n                final_matrix[i] += matrix[i][j]\n\n    # Now to remove the unwanted characters\n    # Start by creating a list of all the characters\n    # that are allowed\n    allowed_chars = []\n    for i in range(32, 127):\n        allowed_chars.append(chr(i))\n\n    # Create an empty list to store the images\n    images = []\n\n    # Now iterate over the matrix\n    for i in range(height):\n        for j in range(width):\n            # If the character is not in the allowed list\n            # add it to the images\n            if final_matrix[i][j] not in allowed_chars:\n                images.append(final_matrix[i][j:j + 3])\n\n    # Now check if the length of the images is equal\n    # to the final_height and width\n    if len(images) == 0:\n        # If it is equal then we can return an empty string\n        return ''\n\n    # If the length of the images is not equal\n    # to the final_height and width then we have to remove\n    # the smallest image\n    if len(images)!= final_width * final_height:\n        # Create a list to store all the images in the list\n        image_list = []\n\n        # Now iterate over the images list\n        for i in images:\n            # Append each image to the list\n            image_list.append(i)\n\n        # Sort the image list in ascending order\n        # of pixel count\n        image_list.sort(key=lambda x: len(x))\n\n        # Remove the image that has the shortest size\n        # that is not equal to the final_height\n        # and final_width\n        del image_list[:final_width * final_height - len(images)]\n\n        # Now create a new matrix\n        # to store the final image\n        final_matrix = ['' for _ in range(final_height)]\n\n        # Add all the images to the final matrix\n        for i in image_list:\n            for j in range(len(i)):\n                final_matrix[j] += i[j]\n\n    # Now to remove the borders of the images\n    # from the final matrix\n    for i in range(final_height):\n        for j in range(final_width):\n            if final_matrix[i][j] == '+':\n                final_matrix[i] = final_matrix[i][:j] +'' + final_matrix[i][j + 1:]\n\n    # Now to remove the spaces from the border of each\n    # row in the matrix\n    for i in range(final_height):\n        final_matrix[i] = final_matrix[i].replace(' ', '')\n\n    # Convert the final matrix to a string\n    final_matrix = '\\n'.join(final_matrix)\n\n    # Return the final matrix\n    return final_matrix\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    w, h = [int(n) for n in stdin.split()]\n    matrix = [list(stdin[i:i + w]) for i in range(0, len(stdin), w)]\n    ans = []\n    for row in matrix:\n        row =''.join(row)\n        row = row.replace('+','')\n        row = row.replace('=','')\n        row = row.replace(' ',' ')\n        ans.append(row)\n\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split(' '))\n    graph = [stdin[i:i+W] for i in range(0, W*H, W)]\n    \n    for i in range(len(graph)):\n        graph[i] = list(graph[i])\n        for j in range(len(graph[i])):\n            if graph[i][j] == '+':\n                if graph[i-1][j] == '+' or graph[i+1][j] == '+':\n                    if graph[i][j-1] == '+' and graph[i][j+1] == '+':\n                        continue\n                    else:\n                        graph[i][j] =''\n        graph[i] = ''.join(graph[i])\n    \n    return '\\n'.join(graph)\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Find all the \"ad\" images and remove them from the input.\n    \"\"\"\n    h, w = map(int, stdin.split())\n    pixels = stdin.split('\\n')\n    result = ''\n    for i, line in enumerate(pixels):\n        result += line if '+' not in line and '=' not in line else''\n    return result\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('8 20\\napples are great!  \\n++++++++++++++++++++\\n+ oranges are      +\\n+ way better!      +\\n+ #oranges>apples  +\\n++++++++++++++++++++\\n check out our      \\nfresh apples!      \\n')\n    'apples are great!  oranges are way better! check out our fresh apples!\n    \"\"\"\n    width, height = [int(x) for x in stdin.split(' ')]\n    matrix = []\n    for i in range(height):\n        matrix.append(list(stdin.split('\\n')[i]))\n\n    flag = True\n    while flag:\n        for i in range(height):\n            for j in range(width):\n                if matrix[i][j] == '+' and not matrix[i][j+1] == '=':\n                    matrix[i][j] =''\n        flag = False\n        for i in range(height):\n            for j in range(width):\n                if matrix[i][j] == '+':\n                    flag = True\n                    break\n            if flag:\n                break\n\n    return ''.join(''.join(x) for x in matrix)\n"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    "
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3159,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(\"8 20\\\\n apples are great!  ++++++++++++++++++++\\\\n+ oranges are      +\\\\n+ way better!      +\\\\n+ #oranges>apples  +\\\\n+ check out our      fresh apples!      \")\n    \"apples are great!  ++++++++++++++++++++\\\\n+ oranges are      +\\\\n+ way better!      +\\\\n+ #oranges>apples  +\\\\n+ check out our      fresh apples!      \"\n    \"\"\"\n    h, w = map(int, stdin.split())\n    webpage = [list(line) for line in stdin.split(\"\\\\n\") if line]\n\n    for y in range(h):\n        for x in range(w):\n            if not is_valid(webpage, x, y):\n                webpage[y][x] = \" \"\n    return \"\\n\".join([\"\".join(row) for row in webpage])\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0][1])\n    n = int(stdin.split()[1][0])\n    h_count = 0\n    t_count = 0\n    for x in stdin.split()[1]:\n        if x == 'H':\n            h_count += 1\n        elif x == 'T':\n            t_count += 1\n    result = 0\n    if h_count == k:\n        result = n\n    else:\n        result = (n - t_count) / (k - h_count)\n    return f'{result:.6f}'\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    return \"Your answer:\\n\" + str(len(stdin.split(\"H\")))\n\"\"\"\n\nimport os\nimport sys\n\nsys.path.insert(1, os.path.join(sys.path[0], \"..\"))\n\nfrom dominoes import T_ON_RIGHT\n\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    count = {\n        'HH': 2,\n        'H?': 1,\n        '?': 0,\n    }\n    for s in S:\n        count[s] += 1\n    return str(count['?'] / 2.0)\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin\n    L = []\n    for i in range(1, len(S)):\n        C = list(S[:i])\n        if C.count('H') == i and '?' not in C:\n            L.append(len(S[:i]))\n    if L:\n        return str(sum(L) / len(L))\n    else:\n        return 'impossible'\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    return str(3)\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    return\n\"\"\"\n\n\ndef"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return average number of operations before Gon stops\n    \"\"\"\n    # lines = stdin.splitlines()\n    # count_line = len(lines)\n    # for line in lines:\n    #     count_line -= 1\n    #     current_line = line.split()\n    #     count_coin = len(current_line)\n    #     for coin in current_line:\n    #         count_coin -= 1\n    #         if coin == \"H\":\n    #             count_coin -= 1\n    #     if count_coin == 0:\n    #         return count_line\n    # return \"IMPOSSIBLE\"\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return stdin\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    \n    return str(len(stdin) // (len(stdin)-stdin.count('?')))\n"
    },
    {
        "number": 3160,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Vladislav Solovyanov\"\"\"\n    S = list(stdin)\n    N = len(S)\n    count = 0\n    for i in range(N-1):\n        if S[i] == S[i+1] == \"H\":\n            count += 2\n            S[i+1] = \"H\"\n    return count\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin.readline())\n    arr = []\n    for _ in range(size):\n        arr.append(list(map(int, stdin.readline().split())))\n    def c(arr: list) -> int:\n        return sum([sum([arr[i][j] == 1 for j in range(size)]) for i in range(size)])\n    def d(arr: list) -> int:\n        return sum([sum([arr[i][j] == 0 for j in range(size)]) for i in range(size)])\n    def a(arr: list, res: int, step: int) -> int:\n        if step == 1:\n            return res\n        if step == 2:\n            if c(arr) > d(arr):\n                res += 1\n            return a(arr, res, 1)\n        if step == 4:\n            if c(arr) < d(arr):\n                res += 1\n            return a(arr, res, 2)\n        if step == 8:\n            if c(arr) == d(arr):\n                res += 1\n            return a(arr, res, 4)\n        if step == 16:\n            if c(arr) == d(arr):\n                res += 1\n            return a(arr, res, 8)\n    return a(arr, 0, 1)\n\nfor _ in range(int(input())):\n    print(solution(input()))\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    pixels, diff = int(stdin.readline()), 0\n    line = [int(x) for x in stdin.readline()]\n    min_diff = pixels\n    while pixels > 1:\n        pixels = int(pixels / 2)\n        # print(pixels)\n        diff += min(pixels, diff)\n        line = split(line)\n        line = sorted(line)\n        if line[0] == 0:\n            line = line[1:]\n        elif line[-1] == 0:\n            line = line[:-1]\n    for x, y in zip(line, stdin.readline().split()):\n        if x!= int(y):\n            min_diff += 1\n    print(min_diff)\n    for x in line:\n        print(x)\n\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        if stdin[i] == \"0\":\n            dp[i][i] = 1\n    for i in range(n - 1):\n        if stdin[i] == \"1\":\n            if stdin[i + 1] == \"1\":\n                dp[i][i + 1] = 1\n            else:\n                dp[i + 1][i] = 1\n    dp = [list(map(int, row)) for row in dp]\n    for i in range(1, n):\n        if i >= 2:\n            if i == 4:\n                dp[i][0] = dp[i - 2][0] + 1\n                dp[0][i] = dp[0][i - 2] + 1\n            else:\n                dp[i][0] = dp[i - 2][0] + 1\n                dp[0][i] = dp[0][i - 2] + 1\n        for j in range(1, i):\n            dp[i][j] = dp[i - 1][j - 1] + 1 if stdin[i]!= stdin[j] else dp[i - 1][j - 1]\n\n    min_diff = n\n    for i in range(n):\n        for j in range(n):\n            for k in range(j + 1, n):\n                if dp[i][j] + dp[j][k] - dp[i][k] < min_diff:\n                    min_diff = dp[i][j] + dp[j][k] - dp[i][k]\n                    curr = stdin[:i] + stdin[j] + stdin[i:j] + stdin[k] + stdin[j + 1:]\n    return curr\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.strip().split())\n    diff = 0\n    arr = [stdin.strip() for stdin in stdin.split(\"\\n\")]\n\n    def dfs(row, col):\n        nonlocal diff\n        if row < 0 or col < 0:\n            return\n        if row == rows and col == cols:\n            diff += abs(rows * cols - sum([1 if x!= y else 0 for x, y in zip(arr[row], arr[col])]))\n            return\n        if arr[row][col] == '1':\n            return\n        else:\n            arr[row][col] = '1'\n            dfs(row, col + 1)\n            dfs(row + 1, col)\n\n    dfs(0, 0)\n    return str(diff)\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def paint_part(current: str, next: str) -> int:\n        res = 0\n        for i in range(len(current)):\n            if current[i]!= next[i]:\n                res += 1\n        return res\n\n    n = int(stdin)\n    curr = stdin\n    next = stdin\n    min_diff = sys.maxsize\n    for _ in range(n):\n        min_diff = min(min_diff, paint_part(curr, next))\n        curr = next\n        next = stdin\n        curr = bin(int(next, 2) + 1)[2:]\n    return str(min_diff)\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution(textwrap.dedent(\"\"\"\n   ...     4\n   ...     1111\n   ...     1111\n   ...     1111\n   ...     1111\n   ...     \"\"\"))\n    '1'\n    >>> solution(textwrap.dedent(\"\"\"\n   ...     4\n   ...     0110\n   ...     1000\n   ...     1111\n   ...     1111\n   ...     \"\"\"))\n    '6'\n    >>> solution(textwrap.dedent(\"\"\"\n   ...     4\n   ...     1110\n   ...     0110\n   ...     1000\n   ...     1110\n   ...     \"\"\"))\n    '2'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols, pic = stdin.split('\\n')[:-1], [], []\n    for row in rows:\n        pic.append([int(d) for d in row])\n\n    cols = list(zip(*pic))\n    n = len(pic)\n    n_pow_2 = len(bin(n-1)) - 2\n\n    def colour(px, pw, n_pow_2):\n        if n_pow_2 == 1:\n            if pw == 0:\n                return px\n            if px == 0:\n                return [1] * n\n            return [1 if p_i!= px_i else 0 for p_i, px_i in zip(px, pw)]\n        # iterate over bits and change pixels\n        n_bit = n_pow_2 - 1\n        mask = 1 << n_bit\n        px_l, px_r, pw_l, pw_r = [], [], [], []\n        for x, w in zip(px, pw):\n            px_l.append(x)\n            px_r.append(x)\n            pw_l.append(w)\n            pw_r.append(w)\n            if mask & x:\n                if mask & w:\n                    px_r[-1] = 1 - px_r[-1]\n                    pw_r[-1] = 1 - pw_r[-1]\n                else:\n                    px_l[-1] = 1 - px_l[-1]\n                    pw_l[-1] = 1 - pw_l[-1]\n\n        pic_l = list(zip(*px_l))\n        pic_r = list(zip(*px_r))\n        pw_l = list(zip(*pw_l))\n        pw_r = list(zip(*pw_r))\n        # recursion\n        return [1 if (l!= r and r!= 0) else 0 for l, r in zip(colour(pic_l, pw_l, n_pow_2 - 1), colour(pic_r, pw_r, n_pow_2 - 1))]\n\n    out = list(map(lambda x: \"\".join([str(y) for y in x]), colour(pic, [0] * n, n_pow_2)))\n    return \"\\n\".join(out)\n\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    bw = [list(map(int, line.strip())) for line in stdin]\n    \n    def paint(bw):\n        if len(bw) == 1:\n            return bw[0]\n        row = len(bw)\n        col = len(bw[0])\n        if row % 2 == 0:\n            if col % 2 == 0:\n                bw_0 = paint([row//2, col//2])\n                bw_1 = paint([row//2, col//2])\n            else:\n                bw_0 = paint([row//2, col//2])\n                bw_1 = paint([row//2, col//2+1])\n        else:\n            if col % 2 == 0:\n                bw_0 = paint([row//2+1, col//2])\n                bw_1 = paint([row//2, col//2])\n            else:\n                bw_0 = paint([row//2, col//2])\n                bw_1 = paint([row//2+1, col//2])\n        return [[0]*bw_0[0]+[1]*bw_1[0]+[0]*bw_0[1]+[1]*bw_1[1]]\n    bw_0, bw_1 = paint(bw)\n    res = 0\n    for i in range(row):\n        for j in range(col):\n            if bw[i][j]!= bw_0[i][j]:\n                res += 1\n    print(res)\n    for line in paint(bw_0):\n        print(''.join(map(str, line)))\n    return"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    size = int(stdin.readline().rstrip())\n    matrix = [[int(i) for i in stdin.readline().rstrip()] for _ in range(size)]\n\n    def paint(matrix, pos, size):\n        if pos == (size, size):\n            return 0\n        if matrix[pos[0]][pos[1]] == 1:\n            matrix[pos[0]][pos[1]] = 0\n            return min(\n                paint(matrix, (pos[0] + 1, pos[1]), size),\n                paint(matrix, (pos[0], pos[1] + 1), size),\n                paint(matrix, (pos[0] + 1, pos[1] + 1), size),\n                paint(matrix, (pos[0] - 1, pos[1] + 1), size),\n            ) + 1\n        else:\n            matrix[pos[0]][pos[1]] = 1\n            return min(\n                paint(matrix, (pos[0] + 1, pos[1]), size),\n                paint(matrix, (pos[0], pos[1] + 1), size),\n                paint(matrix, (pos[0] + 1, pos[1] + 1), size),\n                paint(matrix, (pos[0] - 1, pos[1] + 1), size),\n            )\n\n    def draw(matrix, size):\n        for i in range(size):\n            for j in range(size):\n                print(matrix[i][j], end=\"\")\n            print()\n\n    print(paint(matrix, (0, 0), size))\n    draw(matrix, size)\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3161,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n   ..."
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Time: O(n)\n    Space: O(n)\n    \"\"\"\n    pulses = int(stdin.split()[0])\n    lines = stdin.splitlines()[1:]\n    for i in range(pulses):\n        line = lines[i]\n        type, t, length, wire = line.split()\n        t = int(t)\n        length = int(length)\n        wire = int(wire)\n        if type == 'h':\n            # Add every pixel to the pixels_affected list with the starting\n            # index in the line above\n            pixels_affected.append([wire, t + i * length])\n        else:\n            # Add every pixel to the pixels_affected list with the starting\n            # index in the line above\n            pixels_affected.append([wire, t + (i - 1) * length])\n    # Initialize the number of pixels affected with 1\n    affected_pixels = 1\n    # Loop through the pixels_affected list and check if the starting index\n    # is equal to the ending index.\n    for pixel in pixels_affected:\n        if pixel[0] == 1:\n            if pixel[1] == 1:\n                affected_pixels += 1\n    return affected_pixels\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''4\n   ... h 1 4 1\n   ... v 2 4 2\n   ... h 10 2 2\n   ... v 11 2 3''')\n    2\n    \"\"\"\n\n    h, v = [], []\n    p = None\n    for l in stdin.splitlines():\n        _, t, m, a = l.split()\n        if _ == 'h':\n            h.append((int(t), int(m), int(a)))\n            p = a\n        else:\n            v.append((int(t), int(m), int(a)))\n            p = a\n\n    h.sort()\n    v.sort(key=lambda x: x[0])\n\n    #\n    #  h  1  4  1\n    #  v  2  4  2\n    #   h 10  2  2\n    #   v 11  2  3\n    #\n    #   h 1 10  1\n    #   h 5 10  2\n    #   v 1 10  1\n    #   v 5 10  3\n    #\n\n    h, v = h[::-1], v[::-1]\n    if p == 1:\n        return min([h[0][1], v[0][1]])\n    else:\n        return max([h[0][1], v[0][1]])\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    pass\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    return ''\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    print(1)\n    return ''\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_input(input: str) -> Tuple[str, int, int, int, int, str, str]:\n        direction, start, length, wire, wire2, result = input.split(' ')\n        return direction, int(start), int(length), int(wire), int(wire2), result\n\n    def traverse(grid: str, direction: str, start: int, length: int, wire: int, wire2: int, result: str) -> int:\n        if direction == 'h':\n            for column in grid:\n                if column[wire-1] == 'o' and column[wire2-1] == 'o':\n                    result += '1'\n                else:\n                    result += '0'\n        elif direction == 'v':\n            for row in grid:\n                if row[wire-1] == 'o' and row[wire2-1] == 'o':\n                    result += '1'\n                else:\n                    result += '0'\n        else:\n            raise ValueError\n\n        return int(result, 2)\n\n    grid: str = stdin\n    result = ''\n    for input in stdin.splitlines():\n        direction, start, length, wire, wire2, result = get_input(input)\n        start -= 1\n        length -= 1\n        grid = grid[:start] + 'o'*length + grid[start+length:]\n        start = start*2\n        length = length*2\n        result = traverse(grid, direction, start, length, wire, wire2, result)\n\n    return result\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solution to the problem 'Number of activated pixels'\n\n    Args:\n        stdin (str): Input string\n\n    Returns:\n        str: Solution to the problem\n    \"\"\"\n    grid_width, grid_height = map(int, stdin.split()[:2])\n    pixels = set()\n    pulse_count = 0\n\n    for pulse in stdin.split('\\n')[:-1]:\n        direction, time, pulse_length, wire_number = pulse.split()\n        time = int(time)\n        pulse_count += 1\n        if direction == 'v':\n            for i in range(grid_width):\n                if wire_number == 1:\n                    if time <= grid_height:\n                        pixels.add((i, time))\n                elif wire_number == 2:\n                    if time <= grid_height:\n                        pixels.add((i, time - pulse_length))\n        else:\n            for i in range(grid_height):\n                if wire_number == 1:\n                    if time <= grid_height:\n                        pixels.add((time, i))\n                elif wire_number == 2:\n                    if time <= grid_height:\n                        pixels.add((time - pulse_length, i))\n\n    return str(len(pixels))\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Returns solution of the task.\"\"\"\n    pass"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3162,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = [int(x) for x in stdin.split('\\n')[0].split()]\n    grid = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]\n    for line in stdin.split('\\n')[1:]:\n        d, t, m, wire = line.split()\n        if d == 'h':\n            start, end = int(t), int(t) + int(m)\n            for i in range(start, end):\n                grid[i][int(wire)] = 1\n        else:\n            start, end = int(t), int(t) + int(m)\n            for i in range(start, end):\n                grid[int(wire)][i] = 1\n\n    return sum([sum(row) for row in grid])\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    determine if it is possible to put all books in place by\n    moving them one by one\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = [int(x) for x in stdin.split('\\n')[0].split(' ')]\n    shelves = [[int(x) for x in stdin.split('\\n')[i].split(' ')] for i in range(1, n + 1)]\n    wanted = [int(x) for x in stdin.split('\\n')[n + 1].split(' ')]\n    dp = [[[-1 for _ in range(k)] for _ in range(m + 1)] for _ in range(n + 1)]\n\n    def helper(i, j):\n        if i == n and j == m:\n            return 0\n        if dp[i][j][0]!= -1:\n            return dp[i][j][0]\n        res = -1\n        if shelves[i][j] == 0:\n            for x in range(1, k + 1):\n                if i + 1 <= n and x not in shelves[i + 1][:j + 1]:\n                    res = max(helper(i + 1, j) + 1, res)\n                if x not in shelves[i][:j]:\n                    res = max(helper(i, j + 1) + 1, res)\n            dp[i][j][0] = res\n            return res\n        else:\n            for x in range(1, k + 1):\n                if i + 1 <= n and x not in shelves[i + 1][:j + 1]:\n                    res = max(helper(i + 1, j) + 1, res)\n                if x not in shelves[i][:j]:\n                    res = max(helper(i, j + 1) + 1, res)\n            dp[i][j][0] = res\n            return res\n\n    return helper(0, 0)\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\\\n   ... 2 4\n   ... 1 0 2 0\n   ... 3 5 4 0\n   ... 2 1 0 0\n   ... 3 0 4 5\n   ... 2 1 0 0\n   ... 3 0 4 5''')\n    '2'\n    >>> solution('''\\\n   ... 3 3\n   ... 1 2 3\n   ... 4 5 6\n   ... 7 8 0\n   ... 4 2 3\n   ... 6 5 1\n   ... 0 7 8''')\n    '4'\n    \"\"\"\n    N, M = map(int, stdin.split('\\n')[:2])\n    shelves = [list(map(int, stdin.split('\\n')[i:i + M])) for i in range(2, N + 2)]\n    target = [list(map(int, stdin.split('\\n')[N + i:N + i + M])) for i in range(N)]\n\n    def all_permutations(container, length):\n        if length == 1:\n            for i in container:\n                yield [i]\n        else:\n            for i in range(len(container)):\n                for p in all_permutations(container, length - 1):\n                    yield [container[i]] + p\n                    if i < len(container) - 1:\n                        yield p + [container[i]]\n\n    # Create all the permutations of books and their positions\n    books = list(range(1, M + 1))\n    possible_positions = all_permutations(books, N)\n\n    # Check if any of the books can go to any of the shelves\n    for book_positions in possible_positions:\n        positions = [0] * M\n        for book_i, shelf_i in zip(book_positions, range(M)):\n            positions[shelf_i] = books[book_i - 1]\n        # Check if any of the books cannot be on the shelves\n        if positions == target[0]:\n            continue\n        # Check if any of the shelves are not empty\n        elif 0 in positions:\n            continue\n        else:\n            # Check if any of the shelves can be used to arrange books\n            positions = [0] + positions + [0]\n            for i in range(1, len(positions) - 1):\n                if shelves[i - 1][positions[i] - 1] == 0 or shelves[i][positions[i + 1] - 1] == 0:\n                    break\n            else:\n                return str(len(positions) - 2)\n\n    return '-1'\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def check(curr: tuple, wanted: tuple, curr_shelves: list, wanted_shelves: list, curr_books: list, wanted_books: list):\n        if curr!= wanted:\n            curr_shelves[curr[0]][curr[1]], curr_books[curr[0]][curr[1]] = 0, 0\n            wanted_shelves[wanted[0]][wanted[1]], wanted_books[wanted[0]][wanted[1]] = 0, 0\n            if curr[0] < wanted[0]:\n                curr_shelves[curr[0]][curr[1]] = curr_books[curr[0]][curr[1]]\n                curr_books[curr[0]][curr[1]] = 0\n                check((curr[0] + 1, curr[1]), wanted, curr_shelves, wanted_shelves, curr_books, wanted_books)\n            elif curr[0] > wanted[0]:\n                curr_shelves[curr[0]][curr[1]] = curr_books[curr[0]][curr[1]]\n                curr_books[curr[0]][curr[1]] = 0\n                check((curr[0] - 1, curr[1]), wanted, curr_shelves, wanted_shelves, curr_books, wanted_books)\n            if curr[1] < wanted[1]:\n                curr_shelves[curr[0]][curr[1]] = curr_books[curr[0]][curr[1]]\n                curr_books[curr[0]][curr[1]] = 0\n                check((curr[0], curr[1] + 1), wanted, curr_shelves, wanted_shelves, curr_books, wanted_books)\n            elif curr[1] > wanted[1]:\n                curr_shelves[curr[0]][curr[1]] = curr_books[curr[0]][curr[1]]\n                curr_books[curr[0]][curr[1]] = 0\n                check((curr[0], curr[1] - 1), wanted, curr_shelves, wanted_shelves, curr_books, wanted_books)\n\n    stdin = stdin.split(\"\\n\")\n    m, n = [int(x) for x in stdin[0].split(\" \")]\n    curr_shelves = [[int(x) for x in stdin[i].split(\" \")] for i in range(1, m + 1)]\n    wanted_shelves = [[int(x) for x in stdin[i].split(\" \")] for i in range(m + 1, m + 1 + n)]\n\n    curr_books = [[0 for _ in range(m)] for _ in range(m)]\n    for i in range(m):\n        for j in range(m):\n            curr_books[i][j] = curr_shelves[i][j]\n    wanted_books = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            wanted_books[i][j] = wanted_shelves[i][j]\n\n    total = 0\n    for i in range(m):\n        for j in range(m):\n            total += curr_shelves[i][j] + curr_books[i][j]\n    if total!= 0:\n        return -1\n    return check((0, 0), (m - 1, n - 1), curr_shelves, wanted_shelves, curr_books, wanted_books)\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2 4\n   ... 1 0 2 0\n   ... 3 5 4 0\n   ... 2 1 0 0\n   ... 3 0 4 5\n   ... ''')\n    '2'\n    >>> solution('''3 3\n   ... 1 2 3\n   ... 4 5 6\n   ... 7 8 0\n   ... 4 2 3\n   ... 6 5 1\n   ... 0 7 8\n   ... ''')\n    '4'\n    \"\"\"\n    shelves = stdin.split('\\n')\n    N, M = map(int, shelves[0].split())\n    books = shelves[1:]\n    n, m = len(books), len(books[0].split())\n    shelves = []\n    for line in shelves[1:]:\n        shelves.append(list(map(int, line.split())))\n    ans = 0\n\n    def solve():\n        nonlocal ans\n        for j in range(M):\n            n_books = 0\n            for i in range(N):\n                if shelves[i][j] > 0:\n                    n_books += 1\n            if n_books == N:\n                return\n            elif n_books == 0:\n                continue\n            elif n_books == 1:\n                if shelves[i][j] > 0:\n                    ans += 1\n                    for k in range(j + 1, M):\n                        if shelves[i][k] == 0:\n                            shelves[i][k], shelves[i][j] = shelves[i][j], shelves[i][k]\n                            ans += 1\n                            break\n                else:\n                    for k in range(j, M):\n                        if shelves[i][k] > 0:\n                            shelves[i][j], shelves[i][k] = shelves[i][k], shelves[i][j]\n                            ans += 1\n                            break\n            else:\n                moves = N - n_books\n                if moves % 2 == 1:\n                    moves += 1\n                for move in range(moves // 2):\n                    shelves[i][j], shelves[i + move][j + move] = shelves[i + move][j + move], shelves[i][j]\n                    ans += 2\n        return\n\n    solve()\n    return ans if ans >= 0 else -1\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your code here\n    # return \"\"\n    return stdin"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    array = [list(map(int, stdin.split())) for _ in range(n)]\n    g = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            g[i][j] = g[i - 1][j] + g[i][j - 1] - g[i - 1][j - 1] + array[i - 1][j - 1]\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            dp[i + 1][j + 1] = max(\n                dp[i][j + 1],\n                dp[i + 1][j],\n                dp[i][j] + array[i][j]\n            )\n    for i in range(n + 1):\n        for j in range(m + 1):\n            dp[i][j] %= 10 ** 9 + 7\n    return dp[-1][-1]"
    },
    {
        "number": 3163,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    return ''"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    return None\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return result\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().strip().split(\" \")))\n    d = {}\n    for i in arr:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n    d = list(d.items())\n    d.sort(key=lambda x: x[1])\n    print(d)\n    longest = 0\n    current_count = 0\n    for i in range(len(d)):\n        if i == 0:\n            current_count = d[i][1]\n            longest = max(longest, current_count)\n        else:\n            if d[i][1] == current_count and d[i][0] == d[i - 1][0]:\n                current_count += 1\n                longest = max(longest, current_count)\n            else:\n                current_count = 1\n                longest = max(longest, current_count)\n    return str(longest)\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.splitlines()\n    array = list(map(int, stdin[1].split()))\n    left, right = 0, 0\n    max_left, max_right = 0, 0\n    dict = {}\n    while right < len(array):\n        if dict.get(array[right]) == None:\n            dict[array[right]] = 1\n        else:\n            dict[array[right]] += 1\n        right += 1\n        while dict[array[right - 1]]!= 2:\n            dict[array[left]] -= 1\n            if dict[array[left]] == 0:\n                del dict[array[left]]\n            left += 1\n        if max_left < right - left:\n            max_left = right - left\n            max_right = right\n    return max_right - max_left\nprint(solution(sys.stdin.read()))\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    nums = list(map(int, stdin.split()))\n    num_count = {}\n    for num in nums:\n        num_count[num] = num_count.get(num, 0) + 1\n    count = 0\n    max_count = 0\n    for key in num_count:\n        if num_count[key] == 2:\n            count += 1\n        if num_count[key] > 2:\n            max_count = max(max_count, count)\n            count = 0\n    return max(max_count, count)\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    # return the result\n    return stdin\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    n = int(stdin.readline())\n    arr = list(map(int, stdin.readline().split()))\n\n    # \u5c0d\u6578\u5169\u51fa\u73fe\u6b21\u6578\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u70ba\u6709\u4e9b\u6578\u5b57\u6703\u6bd4\u8f03\u9760\u524d\uff0c\u4e14\u6703\u88ab\u8996\u70ba\u91cd\u8907\n    hash_map = {}\n    for num in arr:\n        hash_map[num] = hash_map.get(num, 0) + 1\n\n    # \u8a18\u5f97\u7b2c\u4e00\u500b\u91cd\u8907\u6b21\u6578\u524d\u9762\u6703\u6709\u7b2c\u4e00\u500b\u6578\u5b57\u9084\u8981\u52a0\u4e00\u500b\n    start = 1\n    longest_sub = 0\n\n    # \u6839\u64da\u95dc\u9375\uff0c\u5c0d\u89d2\u7dda\u4f4d\u7f6e\u6703\u6709\u7d66\u5b9a\u7684\u6578\u91cf\n    for key in hash_map:\n        if hash_map[key] == 2:\n            end = key\n            count = 1\n\n            while hash_map.get(end + 1, 0) == 2:\n                end += 1\n                count += 1\n\n            longest_sub = max(longest_sub, count)\n\n            # \u5982\u679c\u6709\u9084\u6c92\u627e\u5230\u8d77\u9ede\uff0c\u5c31\u91cd\u65b0\u7d66\u5b9a\u8d77\u9ede\n            if start == 1:\n                start = end + 1\n    return longest_sub\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solves the longest subarray with exactly 2 odd occurrences problem.\n\n    >>> solution('''6\n   ... 1 2 3 3 4 2''')\n    2\n    >>> solution('''8\n   ... 1 2 1 3 1 3 1 2''')\n    4\n\n    \"\"\"\n    a = [int(x) for x in stdin.split('\\n')[1].split(' ')]\n    len_ = len(a)\n    ans = 1\n    for i in range(len_):\n        cur_odd = 0\n        cur_even = 0\n        for j in range(i, len_):\n            if a[j] & 1:\n                cur_odd += 1\n            else:\n                cur_even += 1\n            if cur_odd == 2 and cur_even == 0:\n                ans = max(ans, j - i + 1)\n            if cur_odd == 0 and cur_even == 2:\n                ans = max(ans, j - i + 1)\n    return ans\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    s, f = set(A), {}\n    for x in s:\n        f[x] = 1\n    ans, r = 0, 0\n    for l in range(len(A)):\n        while A[l] in s:\n            r += 1\n            f[A[l]] -= 1\n            if f[A[l]] == 0:\n                ans = max(ans, r)\n                s.remove(A[l])\n        r = 0\n    return ans\n"
    },
    {
        "number": 3164,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Your code here\n    return ''"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Finds the total number of attacked fields after $k$ moves\n    :param stdin: input\n    :return: output\n    \"\"\"\n    n, k, p = [int(c) for c in stdin.split(' ')]\n    R, C, X = [0] * k, [0] * k, [0] * k\n    C[0], R[0], X[0] = [int(c) for c in stdin.split('\\n')[1].split(' ')]\n    for i in range(1, k):\n        C[i], R[i], X[i] = [int(c) for c in stdin.split('\\n')[2 + i].split(' ')]\n    res = 0\n    for i in range(p):\n        r1, c1, r2, c2 = [int(c) for c in stdin.split('\\n')[2 + k + i].split(' ')]\n        for r in range(n):\n            if (r == r1 or r == r2) and (c1!= c2):\n                for c in range(n):\n                    if r!= r1 and r!= r2 and c!= c1 and c!= c2 and (r!= r1 or c!= c1) and (r!= r2 or c!= c2):\n                        res += bin(X[i - 1] ^ X[i] ^ R[i] ^ C[i]).count('1')\n    return res\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    rows, columns, moves = map(int, stdin.split())\n    powers = [list(map(int, stdin.split())) for _ in range(rows)]\n    # print(powers)\n\n    for move in range(moves):\n        current_powers = [row[:] for row in powers]\n        rooks = []\n        for i in range(rows):\n            for j in range(columns):\n                if current_powers[i][j] > 0:\n                    rooks.append([i, j, current_powers[i][j]])\n        for rook in rooks:\n            # print(rook)\n            rook[2] = 0\n            for i in range(rows):\n                # print('----', i, '----')\n                if i == rook[0]:\n                    continue\n                if i == rook[1]:\n                    continue\n                rook[2] ^= powers[i][rook[1]]\n                # print(rook[2])\n            for j in range(columns):\n                # print('----', j, '----')\n                if j == rook[1]:\n                    continue\n                if j == rook[0]:\n                    continue\n                rook[2] ^= powers[rook[0]][j]\n                # print(rook[2])\n        # print(powers)\n        powers = [row[:] for row in current_powers]\n\n    attacked = 0\n    for i in range(rows):\n        for j in range(columns):\n            if powers[i][j] > 0:\n                attacked ^= powers[i][j]\n    return str(attacked)\n\n\ndef"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2 2 2\n   ... 1 1 1\n   ... 2 2 1\n   ... 2 2 2 1''')\n    '4'\n    >>> solution('''2 2 2\n   ... 1 1 1\n   ... 2 2 2\n   ... 2 2 2 1''')\n    '2'\n    \"\"\"\n    pass\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    'Find the number of attacked fields after P moves.'\n    n, k, p = map(int, stdin.split())\n    board = []\n    for _ in range(n):\n        row = stdin.split()\n        board.append(list(map(int, row)))\n    for _ in range(p):\n        row, col, x = map(int, stdin.split())\n        x ^= board[row - 1][col - 1]\n        for i in range(k):\n            if i == 0:\n                x ^= board[row - 1][col - 1]\n            elif i == 1:\n                x ^= board[row - 1][col]\n            elif i == 2:\n                x ^= board[row][col - 1]\n            else:\n                x ^= board[row][col]\n        print(x)\n    return ''\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''2 2 2\n   ... 1 1 1\n   ... 2 2 1\n   ... 2 2 2 1\n   ... 1 1 1 2''')\n    4\n    \"\"\"\n    rows, cols, rooks = map(int, stdin.split())\n    table = [[None for _ in range(cols)] for _ in range(rows)]\n    for _ in range(rooks):\n        r, c, x = map(int, input().split())\n        table[r - 1][c - 1] = x\n\n    attacked = 0\n    for i in range(rows):\n        for j in range(cols):\n            if table[i][j] is not None:\n                continue\n            cnt = 0\n            for k in range(rows):\n                for l in range(cols):\n                    if k == i or l == j:\n                        continue\n                    power = table[k][l]\n                    if power is None:\n                        continue\n                    elif power == x:\n                        cnt += 1\n                    else:\n                        cnt ^= 1\n            attacked += cnt > 0\n    return attacked\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    return \"\"\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Return the total number of attacked fields after all the moves.\n\n    Args:\n        stdin (str): Input.\n\n    Returns:\n        str: Number of attacked fields.\n    \"\"\"\n    args = stdin.split()\n    n, k, p = int(args[0]), int(args[1]), int(args[2])\n    board = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(k):\n        args = stdin.split()\n        r, c, x = int(args[0]), int(args[1]), int(args[2])\n        board[r - 1][c - 1] = x\n    for i in range(p):\n        args = stdin.split()\n        r1, c1, r2, c2 = int(args[0]), int(args[1]), int(args[2]), int(args[3])\n        xor = 0\n        for r in range(n):\n            for c in range(n):\n                if r == r1 - 1 or c == c1 - 1:\n                    if board[r][c] > 0:\n                        xor ^= board[r][c]\n        print(xor)\n    return ''\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    data = [line.split() for line in stdin.split('\\n')]\n    N, K, P = data.pop(0)\n    N, K, P = int(N), int(K), int(P)\n\n    # board with -1 for obstacles\n    board = [[0] * N for _ in range(N)]\n\n    # [r, c, power]\n    rooks = []\n\n    for row, col, power in data[:K]:\n        rooks.append([int(row), int(col), int(power)])\n        board[int(row) - 1][int(col) - 1] = power\n\n    for i in range(P):\n        row, col, power = data[K + i]\n        row, col = int(row), int(col)\n        power = int(power)\n\n        power_new = power ^ rooks[power - 1][2]\n        if power_new:\n            rooks[power - 1][2] = power_new\n            attack = 1\n            for j in range(len(rooks)):\n                if i!= j:\n                    if j == power - 1:\n                        continue\n                    r, c, power_j = rooks[j]\n                    if (row == r and col == c) or (row == c and col == r):\n                        attack = attack ^ power_j\n            if attack:\n                board[row - 1][col - 1] = attack\n\n    return str(sum(sum(board, [])))\n\nprint(solution(input()))\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    '''\n    Returns the number of fields attacked after the given number of moves.\n    '''\n    board = stdin.split('\\n')[1:-1]\n    _, k, p = map(int, stdin.split('\\n')[:3])\n    board = [[int(r) for r in row.split()] for row in board]\n    board = np.array(board)\n    \n    moves = [[int(r) for r in row.split()] for row in stdin.split('\\n')[3:]]\n    moves = np.array(moves)\n    \n    _, n = board.shape\n    \n    tot = 0\n    \n    for move in moves:\n        board[move[0]-1, move[1]-1] = 0\n        # Find which cells are seen by each rook and the binary XOR of all of them\n        seen = np.zeros((n, n), dtype=int)\n        for i in range(n):\n            seen[i, move[2]-1] = 1\n            for j in range(n):\n                seen[i, j] = seen[i, j] ^ board[i, j]\n        # Count the attacked fields\n        tot += np.sum(seen > 0)\n        \n        board[move[0]-1, move[1]-1] = move[2]\n    \n    return tot\n"
    },
    {
        "number": 3165,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    num_rows, num_columns, num_moves = map(int, stdin.readline().split())\n    num_rooks = [list(map(int, stdin.readline().split())) for _ in range(num_moves)]\n    num_attacks = [0] * (num_rows * num_columns)\n    for move in num_rooks:\n        r1, c1, r2, c2 = move\n        for i in range(r1, r2 + 1):\n            if i == r1:\n                for j in range(c1):\n                    if num_attacks[j + i * num_columns] & 1:\n                        num_attacks[j + i * num_columns] += 1\n            elif i == r2:\n                for j in range(c2, num_columns):\n                    if num_attacks[j + i * num_columns] & 1:\n                        num_attacks[j + i * num_columns] += 1\n            else:\n                for j in range(c1, c2):\n                    if num_attacks[j + i * num_columns] & 1:\n                        num_attacks[j + i * num_columns] += 1\n    return '\\n'.join(map(str, num_attacks))\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, stdin.split())))\n\n    disqualified = list(map(int, stdin.split()))\n    queue = [0] * n\n    for i in range(n):\n        queue[i] = [i]\n\n    while len(queue) > 0:\n        next = queue.pop(0)\n        while len(next) <= k:\n            for i in range(n):\n                if matrix[next[-1]][i] == 0 and i not in next:\n                    queue.append(next + [i])\n        if len(next) > k:\n            queue.append(next[:k])\n\n    if len(next) < k:\n        return 'impossible'\n    return len(next)\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Find the size of the smallest set of players needed to be disqualified to make a fair ranking.\n    \"\"\"\n    n, k = [int(x) for x in stdin.splitlines()[0].split()]\n    matrix = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    if k < n:\n        return 'impossible'\n    \n    s = [False] * n\n    for i in range(k):\n        for j in range(n):\n            if matrix[i][j]:\n                s[j] = True\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if matrix[j][i] and s[j]:\n                s[i] = True\n                break\n    \n    for i in range(n):\n        if not s[i]:\n            return str(i)"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    This solution checks for all possible ways to group the players into\n    disqualified groups. It prints the smallest size of the disqualified\n    group, or 'impossible' if there is no such way.\n    \"\"\"\n    n, k = map(int, stdin.split(' '))\n    rankings = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    for disqualified_players in itertools.combinations(range(n), k):\n        is_fair = True\n        for i in range(n):\n            if i in disqualified_players:\n                continue\n            for j in range(i + 1, n):\n                if rankings[i][j] == 1 and j not in disqualified_players:\n                    is_fair = False\n                    break\n        if is_fair:\n            return str(len(disqualified_players))\n    return 'impossible'\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Solution of problem.\n    \"\"\"\n    n, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, stdin.split())))\n    s = list(map(int, stdin.split()))\n    min_len = n\n    for _ in range(k):\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    matrix[i][j] = 0\n                    matrix[j][i] = 0\n                    l = len(set(matrix[i] + [matrix[j][x] for x in range(n)]))\n                    if l < min_len:\n                        min_len = l\n        if min_len <= k:\n            return 'impossible'\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    matrix[i][j] = 0\n                    matrix[j][i] = 0\n                    l = len(set(matrix[i] + [matrix[j][x] for x in range(n)]))\n                    if l < min_len:\n                        min_len = l\n    return min_len\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 4 2\n   ... 0 0 1 1\n   ... 1 0 0 1\n   ... 0 1 0 0\n   ... 0 0 1 0\n   ... 0 2\n   ... ''')\n    '1'\n    \"\"\"\n   ...\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from functools import reduce\n    n, k = list(map(int, stdin.split(\" \")))\n    matrix = [list(map(int, stdin.split(\"\\n\")[i])) for i in range(n)]\n\n    def select(S: set, player_index: int):\n        if player_index in S:\n            return False\n        else:\n            return True\n\n    def bfs(matrix, select):\n        n = len(matrix)\n        m = len(matrix[0])\n        queue = [(0, 1)]\n        visited = set()\n        level_matrix = [[0] * m for _ in range(n)]\n        while queue:\n            level, x = queue.pop(0)\n            for y in range(m):\n                if select(visited, y):\n                    if x!= y:\n                        if level_matrix[x][y] == 0 or level_matrix[x][y] > level + matrix[x][y]:\n                            level_matrix[x][y] = level + matrix[x][y]\n                            queue.append((level_matrix[x][y], y))\n                            visited.add(y)\n        return level_matrix\n\n    def count_visited(level_matrix):\n        count = 0\n        for i in range(len(level_matrix)):\n            for j in range(len(level_matrix[0])):\n                if level_matrix[i][j] > 0:\n                    count += 1\n        return count\n\n    def bfs_backtrace(matrix, level_matrix, visited):\n        for j in range(len(level_matrix)):\n            if j not in visited:\n                for i in range(len(level_matrix)):\n                    if level_matrix[i][j] == 0:\n                        return i\n\n    queue = [1]\n    visited = set()\n    while queue:\n        player_index = queue.pop(0)\n        level_matrix = bfs(matrix, select)\n        if level_matrix[player_index].count(0) == len(level_matrix) - 1:\n            print(player_index, len(level_matrix[player_index]))\n            queue.append(player_index)\n        elif level_matrix[player_index].count(0) == len(level_matrix):\n            print(\"impossible\")\n            return \"impossible\"\n        else:\n            visited.add(player_index)\n            queue.append(bfs_backtrace(matrix, level_matrix, visited))"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    A solution to the problem\n    \"\"\"\n    return 'impossible'\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(x) for x in stdin.split()]\n\n    graph = []\n    for i in range(n):\n        graph.append([int(x) for x in stdin.split()[i * n : (i + 1) * n]])\n\n    if k == n:\n        return 'impossible'\n\n    def dfs(graph, visited, cur, val, x):\n        if cur == x:\n            return val\n        for i in range(len(graph[cur])):\n            if visited[i] == False and graph[cur][i] == 1:\n                visited[i] = True\n                val = min(val, dfs(graph, visited, i, val + 1, x))\n                visited[i] = False\n        return val\n\n    visited = [False] * n\n    visited[k] = True\n    ans = dfs(graph, visited, k, 1, n)\n    return ans"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = [int(i) for i in stdin.split(\"\\n\")[0].split()]\n    r = [[int(i) for i in stdin.split(\"\\n\")[i].split()] for i in range(1, n + 1)]\n\n    def f(r: List[List[int]], n: int, k: int, i: int):\n        if i == n:\n            return []\n        if k == 0:\n            return r[i]\n\n        if r[i][i] == 1:\n            return f([i[:i] + i[i + 1:] for i in r], n, k, i + 1)\n        else:\n            return min(f([i[:i] + [0] + i[i + 1:] for i in r], n, k - 1, i + 1),\n                       f([i[:i] + i[i + 1:] for i in r], n, k, i + 1),\n                       key=len)\n\n    res = f(r, n, k, 0)\n    if res == []:\n        print(\"impossible\")\n    else:\n        print(len(res))\n        print(*res, sep=\" \")\n"
    },
    {
        "number": 3166,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def naive_solution(stdin: str) -> str:\n        # TODO: Implement naive solution\n        return \"implementation unavailable\"\n\n    def select_players_from_set(stdin: str) -> str:\n        # TODO: Implement this\n        return \"implementation unavailable\"\n\n    return naive_solution(stdin)\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    # n, k = [int(s) for s in stdin.split()]\n    n, k = [int(s) for s in stdin.split()]\n    seq = [0] * n\n    for _ in range(k):\n        l, r = [int(s) for s in stdin.split()]\n        seq[l] += 1\n        seq[r+1] += 1\n    q = int(stdin.split()[-1])\n    results = []\n    for _ in range(q):\n        l, r = [int(s) for s in stdin.split()]\n        results.append(sum(seq[l:r+1]))\n    return '\\n'.join(map(str, results))\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Solve exercise.\"\"\"\n    _ = int(stdin[0])\n    seq = list(map(int, stdin[1].split()))\n    _ = int(stdin[2])\n    assert len(seq) == len(stdin[3:])\n\n    return '\\n'.join(stdin[3:])\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # your solution goes here\n    n, k = map(int, stdin.split())\n    seq = [0] * n\n    for i in range(k):\n        for j in range(n):\n            if j % (i + 1) == 0:\n                seq[j] += 1\n    q = int(stdin.split()[-1])\n    for _ in range(q):\n        l, r = map(int, stdin.split()[-2].split(' '))\n        print(sum(seq[l:r+1]))\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # write your code in Python 3.6\n    l, n, k = [int(s) for s in stdin.split()]\n    seq = [0] * n\n    for _ in range(k):\n        a, b = [int(s) for s in stdin.split()]\n        for i in range(a, b + 1):\n            seq[i] += 1\n    q = int(stdin.split()[-1])\n    ans = []\n    for _ in range(q):\n        l, r = [int(s) for s in stdin.split()]\n        ans.append(sum(seq[l:r + 1]))\n    return '\\n'.join([str(a) for a in ans])\n    \n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Calculate the sum of elements in the array,\n    between the left and right bounds of each special part\n    \"\"\"\n    n, k = map(int, stdin.split(' '))\n    seq = list(map(int, stdin.split(' ')[1:]))\n    q = int(stdin.split('\\n')[-1])\n    ans = [sum(seq[i:j]) for i, j in zip(\n        stdin.split('\\n')[:-1][::2],\n        stdin.split('\\n')[1:-1][::2])]\n    return '\\n'.join(map(str, ans))\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    seq = list(map(int, stdin.split()))\n    for _ in range(K):\n        X = list(map(int, stdin.split()))\n        if X[0] % 2:\n            # left\n            seq[X[0]:X[1] + 1] = seq[X[0]:X[1] + 1] + X[2]\n        else:\n            # right\n            seq[X[0]:X[1] + 1] = seq[X[0]:X[1] + 1] + X[2]\n    stdout.write(str(sum(seq)))\n    return \"\"\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Takes in standard input\n    \n    Returns the output of the sequence\n    \n    \"\"\"\n    N, K = [int(i) for i in stdin.split('\\n')[0].split()]\n    seq = [0] * N\n    ans = []\n    for i in range(K):\n        X = [int(j) for j in stdin.split('\\n')[i + 1].split()]\n        if X[0] == 0:\n            ans.append(sum(seq[X[1] - 1:X[2]]))\n        else:\n            seq[X[1] - 1:X[2]] = [i + 1 for i in seq[X[1] - 1:X[2]]]\n    return '\\n'.join(ans)\n"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # On each step we should increase all elements that are divisible by k,\n    # so we can simply sum all elements from the start to the end.\n    # We should use a for loop, not an iterator.\n    n, k = map(int, stdin.split())\n    k %= n\n    seq = [0] * n\n    for i in range(k):\n        x = int(stdin.readline())\n        seq[x % n] += 1\n    for _ in range(int(stdin.readline())):\n        l, r = map(int, stdin.readline().split())\n        print(sum(seq[l % n:r % n]))"
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # your solution here\n    return \"\""
    },
    {
        "number": 3167,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    >>> solution('''\n   ... 10 4\n   ... 1 1 2 1\n   ... 3\n   ... 0 9\n   ... 2 6\n   ... 7 7\n   ... '''[1:-1])\n    '35\\n18\\n3'\n    \"\"\"\n    n, k = map(int, stdin.split(\"\\n\")[0].split(\" \"))\n    arr = [0 for _ in range(n)]\n    for _ in range(k):\n        x = map(int, stdin.split(\"\\n\")[1].split(\" \"))\n        i, l, r = x\n        arr[l : r + 1] = [i for _ in range(r - l + 1)]\n    q = int(stdin.split(\"\\n\")[2])\n    for _ in range(q):\n        l, r = map(int, stdin.split(\"\\n\")[3 + _].split(\" \"))\n        print(sum(arr[l : r + 1]))\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(left, right):\n        nonlocal tree, counter\n        if right < left:\n            return\n        tree.append(Node(left, right))\n        if right - left > 1:\n            build_tree(left, tree[-1].left)\n            build_tree(tree[-1].right, right)\n        counter += right - left\n\n    tree = []\n    counter = 0\n    N = int(stdin.readline())\n    nums = sorted(map(int, stdin.readlines()))\n    build_tree(nums[0], nums[0])\n    for i in range(1, N):\n        build_tree(nums[i], nums[i])\n    return '\\n'.join(map(str, counter))\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Finds the longest path in a binary tree.\"\"\"\n    n = int(stdin.readline())\n    a = [int(x) for x in stdin.readline().split()]\n    node = Node(a[0])\n    node.length = 1\n    for i in a[1:]:\n        insert(node, i)\n    return node\n\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def bst(left, right, node=0):\n        if left == right:\n            tree[node] = [left]\n            return\n        mid = left + ((right - left) // 2)\n        bst(left, mid, node * 2)\n        bst(mid + 1, right, node * 2 + 1)\n        tree[node] = [left, right]\n        for i in range(left, right + 1):\n            tree[node].append(i)\n        return\n\n    def insert(key):\n        root = 0\n        i = 0\n        while True:\n            if key < tree[i * 2][0]:\n                if len(tree[i * 2 + 1]) == 0:\n                    break\n                i = i * 2 + 1\n            elif key > tree[i * 2][1]:\n                if len(tree[i * 2 + 1]) == 0:\n                    break\n                i = i * 2 + 1\n            else:\n                tree[i * 2 + 1].append(key)\n                break\n        return\n\n    N = int(stdin.readline())\n    tree = [[] for _ in range(int(N ** (1 / 2)) + 1)]\n    bst(0, N - 1)\n    C = 0\n    for i in range(N):\n        insert(int(stdin.readline()))\n        C += len(tree[int(N / 2)])\n        print(C)\n    return\n\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # put your python code here\n    N = int(stdin)\n    counter = 0\n    tree = BST()\n    tree.add_node(Node(N))\n    for i in range(N):\n        tree.add_node(Node(i + 1, tree.root))\n    for i in range(N - 1, -1, -1):\n        tree.add_node(Node(i, tree.root))\n    for i in range(N):\n        counter += tree.insert(i + 1, N)\n    return str(counter)\n\n\nclass BST:\n    def __init__(self, root=None):\n        self.root = root\n        self.counter = 0\n\n    def add_node(self, node):\n        if self.root == None:\n            self.root = node\n        else:\n            current = self.root\n            while True:\n                if node.value == current.value:\n                    return False\n                elif node.value < current.value:\n                    if current.left == None:\n                        current.left = node\n                        return True\n                    else:\n                        current = current.left\n                else:\n                    if current.right == None:\n                        current.right = node\n                        return True\n                    else:\n                        current = current.right\n        self.counter += 1\n        return True\n\n    def insert(self, value, N):\n        current = self.root\n        while current!= None:\n            if current.value == value:\n                return self.counter\n            elif current.value < value:\n                current = current.right\n            else:\n                current = current.left\n        if value < N:\n            return self.add_node(Node(value, None, None, None, None))\n        else:\n            return self.add_node(Node(value, None, None, None, None))\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"\n    Return a string that represents the tree's structure.\n    \"\"\"\n\n    def in_order(node: BinaryTreeNode) -> str:\n        \"\"\"\n        Return the in-order traversal of the tree.\n        \"\"\"\n        if node.left:\n            yield from in_order(node.left)\n        yield node.data\n        if node.right:\n            yield from in_order(node.right)\n\n    def post_order(node: BinaryTreeNode) -> str:\n        \"\"\"\n        Return the post-order traversal of the tree.\n        \"\"\"\n        if node.left:\n            yield from post_order(node.left)\n        if node.right:\n            yield from post_order(node.right)\n        yield node.data\n\n    def pre_order(node: BinaryTreeNode) -> str:\n        \"\"\"\n        Return the pre-order traversal of the tree.\n        \"\"\"\n        yield node.data\n        if node.left:\n            yield from pre_order(node.left)\n        if node.right:\n            yield from pre_order(node.right)\n\n    def construct_tree(nodes: Sequence[int]) -> BinaryTreeNode:\n        \"\"\"\n        Construct a tree from nodes.\n        \"\"\"\n        root = BinaryTreeNode(nodes[0])\n        for i in range(1, len(nodes), 2):\n            parent, child = nodes[i], nodes[i + 1]\n            setattr(parent, \"left\" if parent < child else \"right\", child)\n            setattr(child, \"parent\", parent)\n        return root\n\n    nodes = [int(line) for line in stdin.split('\\n') if line.strip()]\n    root = construct_tree(nodes)\n\n    return \"\\n\".join(list(pre_order(root)) + list(post_order(root)) + list(in_order(root)))\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    #Your code here\n    return None\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    \"\"\"Your solution goes here.\"\"\"\n    pass\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # get input\n    n = int(stdin)\n    array = [int(i) for i in stdin.split('\\n')[:n]]\n    array = sorted(array)\n\n    # binary search tree\n    tree = BST(array[0])\n    for num in array[1:]:\n        tree.add(num)\n\n    # process\n    n_c = 0\n    for num in array:\n        n_c += tree.depth(num)\n        tree.print(num)\n\n    return str(n_c)\n\n\nclass BST:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\n    def add(self, value):\n        if value < self.value:\n            if self.left is None:\n                self.left = BST(value)\n            else:\n                self.left.add(value)\n        else:\n            if self.right is None:\n                self.right = BST(value)\n            else:\n                self.right.add(value)\n\n    def print(self, value):\n        if value == self.value:\n            print(0)\n        elif value < self.value:\n            if self.left is None:\n                print('Not Found')\n            else:\n                self.left.print(value)\n        else:\n            if self.right is None:\n                print('Not Found')\n            else:\n                self.right.print(value)\n\n    def depth(self, value):\n        if value == self.value:\n            return 0\n        elif value < self.value:\n            if self.left is None:\n                return 1\n            else:\n                return 1 + self.left.depth(value)\n        else:\n            if self.right is None:\n                return 1\n            else:\n                return 1 + self.right.depth(value)\n"
    },
    {
        "number": 3168,
        "checkpoint": "16B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    pass\n"
    }
]