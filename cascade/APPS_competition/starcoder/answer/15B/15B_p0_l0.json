[
    {
        "number": 3000,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    tokens = stdin.readline().split()\n    stack = []\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            while stack[-1]!= '(':\n                op = stack.pop()\n                if op == '+':\n                    stack[-1] = (stack[-1] + stack[-2]) % (10**9+7)\n                else:\n                    stack[-1] = (stack[-1] * stack[-2]) % (10**9+7)\n            stack.pop()\n        else:\n            stack.append(int(token))\n    return str(stack[0])"
    },
    {
        "number": 3001,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    count = 0\n    while n!= int(str(n)[::-1]):\n        count += 1\n        n = int(str(n)[::-1])\n    return str(count)"
    },
    {
        "number": 3002,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    entries = []\n    for line in stdin.split('\\n'):\n        if line:\n            year, month, odometer = map(int, line.split())\n            entries.append((year, month, odometer))\n\n    # Check if odometer has been tampered with\n    if entries[0][2]!= 0:\n        return \"tampered odometer\"\n\n    # Check if car has been serviced sufficiently often\n    last_service_month = entries[0][1]\n    service_count = 0\n    for year, month, odometer in entries:\n        if month!= last_service_month:\n            service_count += 1\n            last_service_month = month\n        if service_count >= 12:\n            return \"seems legit\"\n    return \"insufficient service\""
    },
    {
        "number": 3003,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    edges = [set(map(int, line.split())) for line in lines[1:]]\n    # build graph\n    graph = [set() for _ in range(n)]\n    for i, edge in enumerate(edges):\n        for j in edge:\n            graph[i].add(j)\n            graph[j].add(i)\n    # find connected components\n    components = []\n    visited = [False] * n\n    def dfs(i):\n        visited[i] = True\n        for j in graph[i]:\n            if not visited[j]:\n                dfs(j)\n    for i in range(n):\n        if not visited[i]:\n            components.append(set())\n            dfs(i)\n    # count colors\n    colors = set()\n    for component in components:\n        colors.update(component)\n    return str(len(colors))"
    },
    {
        "number": 3004,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    offers = []\n    for i in range(1, n+1):\n        color, a, b = lines[i].split()\n        a, b = int(a), int(b)\n        offers.append((color, a, b))\n\n    # Sort offers by section range\n    offers.sort(key=lambda x: x[1])\n\n    # Initialize color count and painted sections\n    color_count = {}\n    painted_sections = set()\n\n    # Iterate over offers and try to paint fence\n    for color, a, b in offers:\n        # Check if color is already used\n        if color in color_count:\n            if color_count[color] >= 3:\n                continue\n        else:\n            color_count[color] = 0\n\n        # Check if section is already painted\n        if a-1 in painted_sections or b in painted_sections:\n            continue\n\n        # Paint section\n        painted_sections.update(range(a-1, b))\n        color_count[color] += 1\n\n        # Check if fence is painted\n        if len(painted_sections) == 10000:\n            return str(len(offers))\n\n    # If no acceptable set of offers found\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3005,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove all non-alphabetic characters from the input string\n    input_string = ''.join(filter(str.isalpha, stdin))\n    # Initialize a dictionary to keep track of the frequency of each substring\n    substring_freq = {}\n    # Initialize a variable to keep track of the length of the longest substring\n    max_substring_length = 0\n    # Iterate over all possible substrings of the input string\n    for i in range(len(input_string)):\n        for j in range(i+1, len(input_string)+1):\n            substring = input_string[i:j]\n            # If the substring is not already in the dictionary, add it with frequency 1\n            if substring not in substring_freq:\n                substring_freq[substring] = 1\n            # If the substring is already in the dictionary, increment its frequency\n            else:\n                substring_freq[substring] += 1\n            # Update the length of the longest substring\n            if len(substring) > max_substring_length:\n                max_substring_length = len(substring)\n    # Initialize a variable to keep track of the weight of the maximal factoring\n    max_weight = 0\n    # Iterate over all possible substrings of the input string\n    for i in range(len(input_string)):\n        for j in range(i+1, len(input_string)+1):\n            substring = input_string[i:j]\n            # If the substring is not already in the dictionary, skip it\n            if substring not in substring_freq:\n                continue\n            # If the substring is already in the dictionary, check if it is a maximal factoring\n            if substring_freq[substring] == 1:\n                # If the substring is a maximal factoring, update the weight\n                weight = len(substring)\n                # Check if the weight is greater than the current maximal weight\n                if weight > max_weight:\n                    max_weight = weight\n    # Return the weight of the maximal factoring\n    return str(max_weight)"
    },
    {
        "number": 3006,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    program1 = []\n    program2 = []\n    for line in stdin.split('\\n'):\n        if line[0] == 'D':\n            program1.append(('D', int(line.split()[1])))\n        elif line[0] == 'I':\n            program1.append(('I', int(line.split()[1]), line.split()[2]))\n        elif line[0] == 'E':\n            break\n    for line in stdin.split('\\n'):\n        if line[0] == 'D':\n            program2.append(('D', int(line.split()[1])))\n        elif line[0] == 'I':\n            program2.append(('I', int(line.split()[1]), line.split()[2]))\n        elif line[0] == 'E':\n            break\n    if program1 == program2:\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 3007,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    bling = b\n    fruits = f\n    for i in range(d):\n        if i % 3 == 2:\n            fruits += t0\n        if i % 3 == 5:\n            fruits += t1\n        if i % 3 == 8:\n            fruits += t2\n        if fruits >= 100:\n            bling += fruits // 100 * 100\n            fruits = fruits % 100\n    return str(bling)"
    },
    {
        "number": 3008,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    ranks = {}\n    for i in range(N):\n        for j in range(i+1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                if (a[i], b[i]) not in ranks:\n                    ranks[(a[i], b[i])] = 1\n                if (a[j], b[j]) not in ranks:\n                    ranks[(a[j], b[j])] = 1\n    return len(ranks)"
    },
    {
        "number": 3009,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lamps = []\n    for i in range(1, n+1):\n        x, y, e = map(int, lines[i].split())\n        lamps.append((x, y, e))\n    # sort lamps by y-coordinate\n    lamps.sort(key=lambda x: x[1])\n    # find the minimum energy lamp\n    min_e = min(lamps, key=lambda x: x[2])[2]\n    # find the maximum energy lamp\n    max_e = max(lamps, key=lambda x: x[2])[2]\n    # find the minimum and maximum y-coordinates\n    min_y = min(lamps, key=lambda x: x[1])[1]\n    max_y = max(lamps, key=lambda x: x[1])[1]\n    # find the minimum and maximum x-coordinates\n    min_x = min(lamps, key=lambda x: x[0])[0]\n    max_x = max(lamps, key=lambda x: x[0])[0]\n    # check if there is a line dividing the positive and negative energy sources\n    for y in range(min_y, max_y+1):\n        for x in range(min_x, max_x+1):\n            # check if this point is a lamp\n            for lamp in lamps:\n                if lamp[0] == x and lamp[1] == y:\n                    # check if this lamp contributes to the positive or negative energy source\n                    if lamp[2] > 0:\n                        # check if the energy source is positive\n                        if lamp[2] > min_e:\n                            # check if the energy source is negative\n                            if lamp[2] < max_e:\n                                # check if there is a line dividing the positive and negative energy sources\n                                if (x, y) in [(lamp[0]-1, lamp[1]), (lamp[0]+1, lamp[1]), (lamp[0], lamp[1]-1), (lamp[0], lamp[1]+1)]:\n                                    return abs(lamp[2])\n                            else:\n                                # check if there is a line dividing the positive and negative energy sources\n                                if (x, y) in [(lamp[0]-1, lamp[1]), (lamp[0]+1, lamp[1]), (lamp[0], lamp[1]-1)]:\n                                    return abs(lamp[2])\n                    else:\n                        # check if the energy source is negative\n                        if lamp[2] < min_e:\n                            # check if the energy source is positive\n                            if lamp[2] > max_e:\n                                # check if there is a line dividing the positive and negative energy sources\n                                if (x, y) in [(lamp[0]-1, lamp[1]), (lamp[0]+1, lamp[1]), (lamp[0], lamp[1]-1), (lamp[0], lamp[1]+1)]:\n                                    return abs(lamp[2])\n                            else:\n                                # check if there is a line dividing the positive and negative energy sources\n                                if (x, y) in [(lamp[0]-1, lamp[1]), (lamp[0]+1, lamp[1]), (lamp[0], lamp[1]+1)]:\n                                    return abs(lamp[2])\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3010,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    points = set()\n    for i in range(1, n+1):\n        x0, y0, x1, y1 = map(int, lines[i].split())\n        if x0 == x1:\n            for y in range(min(y0, y1), max(y0, y1)+1):\n                points.add((x0, y))\n        elif y0 == y1:\n            for x in range(min(x0, x1), max(x0, x1)+1):\n                points.add((x, y0))\n        else:\n            if x0 < x1:\n                xs = range(x0, x1+1)\n            else:\n                xs = range(x1, x0+1)\n            if y0 < y1:\n                ys = range(y0, y1+1)\n            else:\n                ys = range(y1, y0+1)\n            for x, y in zip(xs, ys):\n                points.add((x, y))\n    return str(len(points)) if len(points) > 0 else '-1'"
    },
    {
        "number": 3011,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 10:\n        return -1\n    digits = [int(d) for d in str(n)]\n    if digits[0] > digits[-1]:\n        digits.reverse()\n    count = 0\n    for i in range(len(digits)):\n        if digits[i] > digits[i+1]:\n            count += 1\n    if count == 0:\n        return -1\n    else:\n        return count + 1"
    },
    {
        "number": 3012,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n    dp = [[[0] * (N+1) for _ in range(N+1)] for _ in range(N+1)]\n    dp[0][0][0] = 1\n    for i in range(1, N+1):\n        for j in range(N+1):\n            for k in range(N+1):\n                if j+k > i:\n                    continue\n                dp[i][j][k] = (dp[i-1][j][k] + dp[i-1][j+1][k-1] + dp[i-1][j+1][k] + dp[i-1][j][k-1]) % MOD\n                if j > 0:\n                    dp[i][j][k] = (dp[i][j][k] - dp[i-1][j-1][k] - dp[i-1][j][k-1] - dp[i-1][j-1][k-1]) % MOD\n                if k > 0:\n                    dp[i][j][k] = (dp[i][j][k] - dp[i-1][j][k-2] - dp[i-1][j+1][k-2] - dp[i-1][j+1][k-1]) % MOD\n    ans = 0\n    for i in range(N+1):\n        for j in range(N+1):\n            for k in range(N+1):\n                if dp[N][i][j] > 0:\n                    ans = (ans + dp[N][i][j]) % MOD\n    return str(ans)"
    },
    {
        "number": 3013,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    r = b * 2 * math.pi\n    x = r * math.cos(2 * math.pi * tx / r)\n    y = r * math.sin(2 * math.pi * ty / r)\n    return f\"{x:.5f} {y:.5f}\""
    },
    {
        "number": 3014,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False] * (n+1)\n    def dfs(u, parent):\n        visited[u] = True\n        for v in adj[u]:\n            if v == parent:\n                continue\n            if visited[v]:\n                return True\n            if dfs(v, u):\n                return True\n        return False\n    count = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            if dfs(i, -1):\n                count += 1\n    if count > m//2:\n        return \"IMPOSSIBLE\"\n    corridors = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if not adj[i] or j not in adj[i]:\n                continue\n            if not adj[j] or i not in adj[j]:\n                continue\n            if i in adj[j] and j in adj[i]:\n                continue\n            corridors.append((i, j))\n    corridors.sort(key=lambda x: len(adj[x[0]])+len(adj[x[1]]))\n    result = []\n    for i in range(m//2):\n        result.append(corridors[i][0])\n        result.append(corridors[i][1])\n    return str(m//2) + \"\\n\" + \"\\n\".join(map(str, result))"
    },
    {
        "number": 3015,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n    visited = [False] * n\n    q = [(s, 0)]\n    while q:\n        ball, time = q.pop(0)\n        if ball == t:\n            return str(time)\n        if visited[ball]:\n            continue\n        visited[ball] = True\n        for next_ball, weight in graph[ball]:\n            q.append((next_ball, time + weight))\n    return \"infinity\""
    },
    {
        "number": 3016,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, *balls = map(int, stdin.split())\n    k, *colors = map(int, stdin.readline().split())\n    l, *sequence = map(int, stdin.readline().split())\n\n    # create a list of balls with their colors\n    balls_list = [(i+1, b) for i, b in enumerate(balls)]\n\n    # create a set of colors that cannot be next to each other\n    colors_set = set(colors)\n\n    # create a set of the sequence that must appear as often as possible\n    sequence_set = set(sequence)\n\n    # create a list of all possible arrangements\n    arrangements = []\n    for i in range(1, 2**n):\n        arrangement = []\n        for j in range(n):\n            if i & (1 << j):\n                arrangement.append(balls_list[j])\n        arrangements.append(arrangement)\n\n    # filter out arrangements that violate the conditions\n    filtered_arrangements = []\n    for arrangement in arrangements:\n        # check if balls of certain colors are not next to each other\n        if any(abs(arrangement[i][1] - arrangement[i+1][1]) in colors_set for i in range(n-1)):\n            continue\n\n        # check if the sequence appears as often as possible\n        if all(arrangement.count((s, 1)) >= arrangement.count((s, 0)) for s in sequence_set):\n            filtered_arrangements.append(arrangement)\n\n    # count the number of filtered arrangements\n    count = len(filtered_arrangements)\n\n    # output the result modulo 1000000007\n    return str(count % 1000000007)"
    },
    {
        "number": 3017,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if str(i).count('2'*e):\n            count += 1\n    return count"
    },
    {
        "number": 3018,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split())\n    numbers = list(map(int, stdin.readline().split()))\n    dp = [[0] * (K+1) for _ in range(T+1)]\n    dp[0][0] = 1\n    for i in range(K):\n        dp[numbers[i]][1] = 1\n    for i in range(1, T+1):\n        for j in range(1, K+1):\n            for k in range(1, 7):\n                if i-k >= 0:\n                    dp[i][j] += dp[i-k][j-1]\n    ans = K\n    for i in range(K, 0, -1):\n        if dp[T][i] > 0:\n            ans = i\n            break\n    return str(ans)"
    },
    {
        "number": 3019,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    max_revenue = 0\n    for i in range(n):\n        factors = set()\n        for j in range(len(primes)):\n            while s[i] % primes[j] == 0:\n                factors.add(primes[j])\n                s[i] //= primes[j]\n        max_revenue += len(factors)\n    return str(max_revenue)"
    },
    {
        "number": 3020,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    while True:\n        if a * a == n:\n            return str(a)\n        elif a * a > n:\n            return '-1'\n        a += 1"
    },
    {
        "number": 3021,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L, N = lines[0].split()\n    L = L.lower()\n    words = lines[1:]\n    if len(set(words))!= len(words):\n        return 'AMBIGUOUS'\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] < words[j]:\n                return 'IMPOSSIBLE'\n            if words[i][0] == words[j][0]:\n                return 'AMBIGUOUS'\n            if words[i][0] > words[j][0]:\n                return 'AMBIGUOUS'\n            if words[i][0] == L:\n                return 'AMBIGUOUS'\n            if words[j][0] == L:\n                return 'AMBIGUOUS'\n    return ''.join(chr(ord(L)-i) for i in range(len(words)))"
    },
    {
        "number": 3022,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    cookies = a + b + c\n    if n == 2:\n        return str(cookies)\n    if n == 1:\n        return str(max(a, b, c))\n    if n == 3:\n        return str(min(a, b, c))\n    if n == 4:\n        return str(max(a, b, c))\n    if n == 5:\n        return str(min(a, b, c))\n    if n == 6:\n        return str(max(a, b, c))\n    if n == 7:\n        return str(min(a, b, c))\n    if n == 8:\n        return str(max(a, b, c))\n    if n == 9:\n        return str(min(a, b, c))\n    if n == 10:\n        return str(max(a, b, c))\n    if n == 11:\n        return str(min(a, b, c))\n    if n == 12:\n        return str(max(a, b, c))\n    if n == 13:\n        return str(min(a, b, c))\n    if n == 14:\n        return str(max(a, b, c))\n    if n == 15:\n        return str(min(a, b, c))\n    if n == 16:\n        return str(max(a, b, c))\n    if n == 17:\n        return str(min(a, b, c))\n    if n == 18:\n        return str(max(a, b, c))\n    if n == 19:\n        return str(min(a, b, c))\n    if n == 20:\n        return str(max(a, b, c))\n    if n == 21:\n        return str(min(a, b, c))\n    if n == 22:\n        return str(max(a, b, c))\n    if n == 23:\n        return str(min(a, b, c))\n    if n == 24:\n        return str(max(a, b, c))\n    if n == 25:\n        return str(min(a, b, c))\n    if n == 26:\n        return str(max(a, b, c))\n    if n == 27:\n        return str(min(a, b, c))\n    if n == 28:\n        return str(max(a, b, c))\n    if n == 29:\n        return str(min(a, b, c))\n    if n == 30:\n        return str(max(a, b, c))\n    if n == 31:\n        return str(min(a, b, c))\n    if n == 32:\n        return str(max(a, b, c))\n    if n == 33:\n        return str(min(a, b, c))\n    if n == 34:\n        return str(max(a, b, c))\n    if n == 35:\n        return str(min(a, b, c))\n    if n == 36:\n        return str(max(a, b, c))\n    if n == 37:\n        return str(min(a, b, c))\n    if n == 38:\n        return str(max(a, b, c))\n    if n == 39:\n        return str(min(a, b, c))\n    if n == 40:\n        return str(max(a, b, c))\n    if n == 41:\n        return str(min(a, b, c))\n    if n == 42:\n        return str(max(a, b, c))\n    if n == 43:\n        return str(min(a, b, c))\n    if n == 44:\n        return str(max(a, b, c))\n    if n == 45:\n        return str(min(a, b, c))\n    if n == 46:\n        return str(max(a, b, c))\n    if n == 47:\n        return str(min(a, b, c))\n    if n == 48:\n        return str(max(a, b, c))\n    if n == 49:\n        return str(min(a, b, c))\n    if n == 50:\n        return str(max(a, b, c))\n    if n == 51:\n        return str(min("
    },
    {
        "number": 3023,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    candles = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        candles.append((x, y))\n    cuts = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        cuts.append((a, b, c))\n    # check if all candles are inside the circle\n    for candle in candles:\n        if (candle[0]**2 + candle[1]**2)**0.5 > r:\n            return \"no\"\n    # check if all cuts are valid\n    for cut in cuts:\n        if cut[0] == 0 and cut[1] == 0:\n            return \"no\"\n    # check if all candles are on a cut line\n    for candle in candles:\n        for cut in cuts:\n            if abs(cut[0]*candle[0] + cut[1]*candle[1] + cut[2]) < 1e-6:\n                return \"no\"\n    # check if all cuts divide the cake into n pieces\n    pieces = [[] for _ in range(n)]\n    for candle in candles:\n        for i in range(n):\n            if (candle[0]**2 + candle[1]**2)**0.5 < r/n:\n                pieces[i].append(candle)\n                break\n    for cut in cuts:\n        for i in range(n):\n            if len(pieces[i]) == 0:\n                continue\n            x1, y1 = pieces[i][0]\n            x2, y2 = pieces[(i+1)%n][0]\n            if abs(cut[0]*x1 + cut[1]*y1 + cut[2]) < 1e-6 or abs(cut[0]*x2 + cut[1]*y2 + cut[2]) < 1e-6:\n                return \"no\"\n    return \"yes\""
    },
    {
        "number": 3024,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if stdin[i] == stdin[j]:\n                if j-i == 1 or dp[i+1][j-1]:\n                    dp[i][j] = True\n    for i in range(n):\n        if dp[0][i]:\n            return i+1\n    return 1"
    },
    {
        "number": 3025,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    villages = list(map(int, stdin.readline().split()))\n    roads = []\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        roads.append((a, b))\n    dp = [[0] * n for _ in range(1 << n)]\n    for i in range(n):\n        dp[1 << i][i] = villages[i]\n    for mask in range(1 << n):\n        for i in range(n):\n            if not (mask >> i & 1):\n                continue\n            for j in range(n):\n                if mask >> j & 1:\n                    continue\n                for road in roads:\n                    if road[0] == i + 1 and road[1] == j + 1:\n                        dp[mask][j] = max(dp[mask][j], dp[mask ^ (1 << i)][i] + villages[j])\n    return max(dp[-1])"
    },
    {
        "number": 3026,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    seq = list(map(int, stdin.readline().strip().split()))\n    critical = []\n    for i in range(n):\n        if seq[i] == i+1:\n            continue\n        for j in range(i):\n            if seq[j] < seq[i] and seq[i] < seq[j+1]:\n                critical.append(seq[i])\n                break\n    if len(critical) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical)))"
    },
    {
        "number": 3027,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    mark = stdin.readline().strip()\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                count += 1\n    return count"
    },
    {
        "number": 3028,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = []\n    for i in range(n):\n        board.append(list(map(int, stdin.split())))\n\n    # check if there is a winning sequence\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                # check if there is a winning sequence starting from (i, j)\n                moves = 1\n                queue = [(i, j)]\n                while queue:\n                    x, y = queue.pop(0)\n                    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < n and 0 <= ny < m and board[nx][ny]!= p:\n                            board[nx][ny] += 1\n                            if board[nx][ny] == p:\n                                return moves\n                            queue.append((nx, ny))\n                            moves += 1\n                    board[x][y] += 1\n\n    return -1"
    },
    {
        "number": 3029,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline())\n    labels = list(map(int, stdin.readline().split()))\n    parents = [int(x) for x in stdin.readline().split()]\n    for i in range(2, n):\n        parents[i] -= 1\n\n    # compute longest jumping path\n    longest_path = 0\n    for i in range(n):\n        j = i\n        while j!= 0:\n            if labels[j] > labels[i]:\n                longest_path = max(longest_path, j - i)\n            j = parents[j]\n\n    # count nondecreasing jumping paths\n    count = 0\n    for i in range(n):\n        j = i\n        while j!= 0:\n            if labels[j] > labels[i]:\n                count += 1\n            j = parents[j]\n\n    # compute remainder\n    remainder = count % 11092019\n\n    # print result\n    return f\"{longest_path} {remainder}\""
    },
    {
        "number": 3030,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nodes = []\n    for i in range(n):\n        v, p = map(int, stdin.readline().strip().split())\n        nodes.append((v, p))\n    heap = []\n    for i in range(n):\n        heap.append(i)\n    heapify(heap)\n    count = 0\n    while heap:\n        node = heappop(heap)\n        count += 1\n        if node == 0:\n            break\n        parent = nodes[node][1]\n        if parent!= -1 and nodes[node][0] > nodes[parent][0]:\n            heappush(heap, parent)\n    return count\n\ndef"
    },
    {
        "number": 3031,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for i in range(n-1):\n        a, b, c = map(int, stdin.readline().strip().split())\n        edges.append((a, b, c))\n    good_nodes = []\n    for i in range(1, n+1):\n        is_good = True\n        for j in range(n-1):\n            if edges[j][0] == i or edges[j][1] == i:\n                if edges[j][0] == i and edges[j][1] == i:\n                    continue\n                for k in range(j+1, n-1):\n                    if edges[k][0] == i or edges[k][1] == i:\n                        if edges[k][0] == i and edges[k][1] == i:\n                            continue\n                        if edges[j][2] == edges[k][2]:\n                            is_good = False\n                            break\n                if not is_good:\n                    break\n        if is_good:\n            good_nodes.append(i)\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, good_nodes))"
    },
    {
        "number": 3032,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split(','))\n    program = stdin.split()[1:]\n    memory = [[] for _ in range(b)]\n    bsr = None\n    time = 0\n    for i, op in enumerate(program):\n        if op.startswith('V'):\n            var = int(op[1:])\n            if var > b * s:\n                return 'Error: variable index out of range'\n            if not memory[var % b]:\n                time += 1\n            memory[var % b].append(var)\n        elif op.startswith('R'):\n            n = int(op[1])\n            subprogram = program[i+1:i+n+1]\n            if not subprogram:\n                return 'Error: empty loop body'\n            for _ in range(n):\n                time += solution(subprogram)\n            i += n\n        elif op == 'E':\n            pass\n        elif op == 'BSR':\n            if bsr is None:\n                time += 1\n            bsr = i\n        else:\n            return 'Error: invalid operation'\n    return str(time)"
    },
    {
        "number": 3033,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    if n == 0:\n        return \"0\"\n    if b == 10:\n        return str(n)\n    digits = []\n    while n > 0:\n        digits.append(n % b)\n        n //= b\n    digits.reverse()\n    x = 0\n    for i, digit in enumerate(digits):\n        x += digit * (b ** i)\n    return str(x) if x < 2**63 else \"impossible\""
    },
    {
        "number": 3034,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    d, t, c, r = map(int, stdin.split()[0:4])\n    clouds = []\n    for i in range(c):\n        s, e, p, a = map(float, stdin.split()[4*i:4*i+4])\n        clouds.append((s, e, p, a))\n    roofs = []\n    for i in range(r):\n        x, y = map(int, stdin.split()[4*c+4*i:4*c+4*i+2])\n        roofs.append((x, y))\n\n    # compute minimum rain\n    rain = 0\n    for cloud in clouds:\n        if cloud[0] <= t and t <= cloud[1]:\n            rain += cloud[3] * cloud[2]\n    for roof in roofs:\n        if t >= roof[0] and t < roof[1]:\n            rain += (roof[1]-t) * 10\n    return str(rain)"
    },
    {
        "number": 3035,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    num_children = int(lines[0])\n    children = []\n    for i in range(1, num_children+1):\n        offer, want, rate = lines[i].split()\n        rate = float(rate)\n        children.append((offer, want, rate))\n\n    # Compute maximum amount of blue lemonade\n    blue_lemonade = 0\n    for offer, want, rate in children:\n        if offer == 'blue':\n            blue_lemonade += rate\n        elif want == 'blue':\n            blue_lemonade += 1/rate\n\n    # Cap maximum amount at $10$ litres\n    blue_lemonade = min(blue_lemonade, 10)\n\n    # Output result\n    return f\"{blue_lemonade:.10f}\""
    },
    {
        "number": 3036,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    r, s, m, d, n = map(int, stdin.split()[0:5])\n    brands = list(map(int, stdin.split()[5:5+r]))\n    dishes = []\n    for i in range(s+m+d):\n        k = int(stdin.split()[0])\n        dish = list(map(int, stdin.split()[1:1+k]))\n        dishes.append(dish)\n    incompatible = []\n    for i in range(n):\n        j1, j2 = map(int, stdin.split())\n        incompatible.append((j1-1, j2-1))\n\n    # count number of possible combinations\n    count = 1\n    for i in range(s+m+d):\n        for j in range(i+1, s+m+d):\n            if (i, j) not in incompatible and (j, i) not in incompatible:\n                count *= len(set(dishes[i]).intersection(set(dishes[j])))\n    for i in range(r):\n        count *= brands[i]\n    if count > 10**18:\n        return \"too many\"\n    return str(count)"
    },
    {
        "number": 3037,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(stdin.readline().strip()) for _ in range(h)]\n    commands = [stdin.readline().strip().split() for _ in range(n)]\n    x, y = 0, w - 1\n    min_time, max_time = 0, h * w\n    for command in commands:\n        direction, distance = command\n        if direction == 'up':\n            y = max(0, y - distance)\n        elif direction == 'down':\n            y = min(h - 1, y + distance)\n        elif direction == 'left':\n            x = max(0, x - distance)\n        elif direction == 'right':\n            x = min(w - 1, x + distance)\n        else:\n            raise ValueError('Invalid direction')\n        min_time = max(min_time, y * w + x)\n        max_time = min(max_time, (y + distance) * w + x)\n        if board[y][x] == '#':\n            return f'{min_time} {max_time}'\n    return '-1 -1'"
    },
    {
        "number": 3038,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    B, k = map(int, stdin.split())\n    sizes = []\n    for i in range(k):\n        l, *ns = map(int, stdin.split())\n        sizes.append(ns)\n\n    # Compute minimum package size\n    min_size = float('inf')\n    for i in range(k):\n        for j in range(len(sizes[i])):\n            if sum(sizes[i][:j+1]) >= B:\n                min_size = min(min_size, sizes[i][j])\n                break\n\n    # Check if minimum package size is possible\n    if min_size == float('inf'):\n        return 'impossible'\n    else:\n        return str(min_size)"
    },
    {
        "number": 3039,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    if len(lines)!= 6:\n        return 'Input error: expected 6 lines'\n    for line in lines:\n        if len(line)!= 6:\n            return 'Input error: expected 6 characters per line'\n        if not all(c in '.#' for c in line):\n            return 'Input error: expected only. or # characters'\n    # Check if pattern is valid\n    for i in range(6):\n        if lines[i][i] == '#':\n            return 'cannot fold'\n    # Check if all squares are connected\n    visited = set()\n    stack = [(0, 0)]\n    while stack:\n        x, y = stack.pop()\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if x > 0 and lines[x-1][y] == '#' and (x-1, y) not in visited:\n            stack.append((x-1, y))\n        if x < 5 and lines[x+1][y] == '#' and (x+1, y) not in visited:\n            stack.append((x+1, y))\n        if y > 0 and lines[x][y-1] == '#' and (x, y-1) not in visited:\n            stack.append((x, y-1))\n        if y < 5 and lines[x][y+1] == '#' and (x, y+1) not in visited:\n            stack.append((x, y+1))\n    if len(visited)!= 21:\n        return 'cannot fold'\n    # Check if all squares are unit squares\n    for i in range(6):\n        for j in range(6):\n            if lines[i][j] == '#' and (i, j) not in visited:\n                return 'cannot fold'\n    # Check if all squares are in the same row or column\n    for i in range(6):\n        if lines[i][0] == '#' and lines[i][1] == '#' and lines[i][2] == '#' and lines[i][3] == '#' and lines[i][4] == '#' and lines[i][5] == '#':\n            return 'cannot fold'\n        if lines[0][i] == '#' and lines[1][i] == '#' and lines[2][i] == '#' and lines[3][i] == '#' and lines[4][i] == '#' and lines[5][i] == '#':\n            return 'cannot fold'\n    # Check if all squares are in the same diagonal\n    if lines[0][0] == '#' and lines[1][1] == '#' and lines[2][2] == '#' and lines[3][3] == '#' and lines[4][4] == '#' and lines[5][5] == '#':\n        return 'cannot fold'\n    if lines[0][5] == '#' and lines[1][4] == '#' and lines[2][3] == '#' and lines[3][2] == '#' and lines[4][1] == '#' and lines[5][0] == '#':\n        return 'cannot fold'\n    # Check if all squares are in the same anti-diagonal\n    if lines[0][0] == '#' and lines[1][-1] == '#' and lines[2][-2] == '#' and lines[3][-3] == '#' and lines[4][-4] == '#' and lines[5][-5] == '#':\n        return 'cannot fold'\n    if lines[0][5] == '#' and lines[1][-4] == '#' and lines[2][-3] == '#' and lines[3][-2] == '#' and lines[4][-1] == '#' and lines[5][-0] == '#':\n        return 'cannot fold'\n    # Check if all squares are in the same layer\n    for i in range(2):\n        for j in range(3):\n            if lines[i*3][j*2] == '#' and lines[i*3+1][j*2] == '#' and lines[i*3+2][j*2] == '#' and lines[i*3][j*2+1] == '#' and lines[i*3+1][j*2+1] == '#' and lines[i*3+2][j*2+1] == '#' and lines[i*3][j*2+2] == '#' and lines[i*3+1][j*2+2] == '#' and lines[i*3+2][j*2+2] == '#':\n                return 'cannot fold'\n    # Check if all squares are in the same layer\n    for"
    },
    {
        "number": 3040,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Create a dictionary to store the frequency of each character in the input string\n    freq = {}\n    for char in stdin:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    # Initialize variables to keep track of the longest repeated substring and its length\n    longest_substring = \"\"\n    longest_length = 0\n    \n    # Iterate through the input string and check for repeated substrings\n    for i in range(len(stdin)):\n        for j in range(i+1, len(stdin)+1):\n            substring = stdin[i:j]\n            if substring in freq and freq[substring] > 1:\n                if len(substring) > longest_length:\n                    longest_substring = substring\n                    longest_length = len(substring)\n    \n    return longest_substring"
    },
    {
        "number": 3041,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    trips = []\n    for i in range(1, N+1):\n        zone, time = map(int, lines[i].split())\n        trips.append((zone, time))\n\n    # sort trips by time\n    trips.sort(key=lambda x: x[1])\n\n    # initialize variables\n    coupons = 0\n    prev_zone = 0\n    prev_time = 0\n\n    # iterate through trips\n    for zone, time in trips:\n        # calculate time interval between previous trip and current trip\n        interval = time - prev_time\n\n        # calculate number of coupons for current trip\n        if prev_zone == zone:\n            # if current trip is the same as previous trip, use the same number of coupons\n            num_coupons = coupons\n        else:\n            # if current trip is different from previous trip, use 2 + |A - B| coupons\n            num_coupons = 2 + abs(prev_zone - zone)\n\n        # add time interval and number of coupons to total coupons\n        coupons = coupons + interval * num_coupons\n\n        # update previous trip variables\n        prev_zone = zone\n        prev_time = time\n\n    return str(coupons)"
    },
    {
        "number": 3042,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for length in range(2, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            dp[i][j] = (dp[i+1][j] + dp[i][j-1]) % MOD\n            if values[i] == values[j]:\n                dp[i][j] = (dp[i][j] + dp[i+1][j-1]) % MOD\n    return dp[0][n-1]"
    },
    {
        "number": 3043,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n, m, k = map(int, lines[0].split())\n    grid = lines[1:]\n    # initialize variables\n    stamina = k\n    days = 0\n    visited = set()\n    # define directions\n    directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]\n    # define costs\n    costs = {'F': 2, 'M': 3}\n    # define target\n    target = (n-1, m-1)\n    # define function to check if cell is valid\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and grid[x][y]!= '#'\n    # define function to move to cell\n    def move(x, y):\n        nonlocal stamina, days, visited\n        if (x, y) == target:\n            return True\n        if (x, y) in visited:\n            return False\n        visited.add((x, y))\n        if grid[x][y] in costs:\n            stamina -= costs[grid[x][y]]\n            if stamina < 0:\n                stamina = k\n                days += 1\n        else:\n            stamina -= 1\n            if stamina < 0:\n                stamina = k\n                days += 1\n        for dx, dy in directions:\n            nx, ny = x+dx, y+dy\n            if is_valid(nx, ny) and move(nx, ny):\n                return True\n        stamina = k\n        days += 1\n        return False\n    # start moving\n    if move(0, 0):\n        return str(days)\n    else:\n        return '-1'"
    },
    {
        "number": 3044,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    H, W = map(int, lines[0].split())\n    grid = lines[1:H+1]\n    command = lines[H+1]\n\n    # count number of changes needed\n    changes = 0\n    for i in range(len(command)):\n        if command[i] == 'D' and i == 0:\n            continue\n        if command[i] == 'U' and i == len(command)-1:\n            continue\n        if command[i] == 'L' and i > 0 and command[i-1] == 'D':\n            continue\n        if command[i] == 'R' and i < len(command)-1 and command[i+1] == 'D':\n            continue\n        if command[i] == 'U' and i > 0 and command[i-1] == 'L':\n            continue\n        if command[i] == 'D' and i < len(command)-1 and command[i+1] == 'L':\n            continue\n        changes += 1\n\n    # output result\n    return str(changes)"
    },
    {
        "number": 3045,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    beacons = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y, d = map(int, line.split())\n            beacons.append((x, y, d))\n\n    # Check for impossible case\n    if len(set(b[0] for b in beacons))!= len(beacons):\n        return 'impossible'\n\n    # Check for uncertain case\n    if len(set(b[1] for b in beacons))!= len(beacons):\n        return 'uncertain'\n\n    # Determine receiver position\n    x_r = min(b[0] for b in beacons)\n    y_r = min(b[1] for b in beacons)\n    for b in beacons:\n        x_r += b[2]\n        y_r += b[2]\n    return f'{x_r} {y_r}'"
    },
    {
        "number": 3046,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    corners = []\n    for i in range(n):\n        r1, c1 = map(int, stdin.readline().strip().split())\n        r2, c2 = map(int, stdin.readline().strip().split())\n        corners.append(((r1, c1), (r2, c2)))\n\n    # check for syntax error\n    for i in range(n):\n        for j in range(i+1, n):\n            if corners[i][1] >= corners[j][0]:\n                return \"syntax error\"\n\n    # find matching\n    matching = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            if corners[i][1] == corners[j][0]:\n                matching[i+1] = j+1\n                matching[j+1] = i+1\n\n    # check for valid matching\n    if len(matching)!= n:\n        return \"syntax error\"\n\n    # output matching\n    for i in range(1, n+1):\n        print(matching.get(i, \"syntax error\"))\n\n    return \"\""
    },
    {
        "number": 3047,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    top_row = stdin.split('\\n')[0].split()\n    bottom_row = stdin.split('\\n')[1].split()\n\n    # initialize variables\n    salamander_burger = 0\n    salamander_slop = 0\n    yeti_burger = 0\n    yeti_slop = 0\n    golem_burger = 0\n    golem_drumstick = 0\n    imp_burger = 0\n    imp_slop = 0\n    kraken_burger = 0\n    kraken_drumstick = 0\n\n    # fill in variables\n    for i in range(10):\n        if top_row[i]!= '_':\n            salamander_burger = int(top_row[i])\n        if top_row[i+1]!= '_':\n            yeti_burger = int(top_row[i+1])\n        if top_row[i+2]!= '_':\n            golem_burger = int(top_row[i+2])\n        if top_row[i+3]!= '_':\n            imp_burger = int(top_row[i+3])\n        if top_row[i+4]!= '_':\n            kraken_burger = int(top_row[i+4])\n        if bottom_row[i]!= '_':\n            salamander_slop = int(bottom_row[i])\n        if bottom_row[i+1]!= '_':\n            yeti_slop = int(bottom_row[i+1])\n        if bottom_row[i+2]!= '_':\n            golem_drumstick = int(bottom_row[i+2])\n        if bottom_row[i+3]!= '_':\n            imp_slop = int(bottom_row[i+3])\n        if bottom_row[i+4]!= '_':\n            kraken_drumstick = int(bottom_row[i+4])\n\n    # compute proportions\n    salamander_burger_prop = yeti_burger / salamander_burger\n    golem_drumstick_prop = imp_burger / golem_drumstick\n    salamander_slop_prop = yeti_slop / salamander_slop\n    kraken_drumstick_prop = imp_slop / kraken_drumstick\n\n    # compute number of solutions\n    solutions = 1\n    if salamander_burger_prop!= 1:\n        solutions *= int(200 / salamander_burger_prop)\n    if golem_drumstick_prop!= 1:\n        solutions *= int(200 / golem_drumstick_prop)\n    if salamander_slop_prop!= 1:\n        solutions *= int(200 / salamander_slop_prop)\n    if kraken_drumstick_prop!= 1:\n        solutions *= int(200 / kraken_drumstick_prop)\n\n    # output result\n    if solutions > 1000000:\n        return \"many\"\n    else:\n        return str(solutions)"
    },
    {
        "number": 3048,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    adj = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        u, v = map(int, stdin.split())\n        adj[u].append(v)\n        adj[v].append(u)\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == j:\n                continue\n            if len(adj[i]) == 1 and len(adj[j]) == 1:\n                continue\n            if len(adj[i]) == 1 or len(adj[j]) == 1:\n                count += 1\n                continue\n            visited = [False] * (n+1)\n            visited[i] = True\n            visited[j] = True\n            queue = [(i, 1)]\n            while queue:\n                node, dist = queue.pop(0)\n                if node == j:\n                    if dist == 2:\n                        count += 1\n                    break\n                for nei in adj[node]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        queue.append((nei, dist+1))\n    return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message = stdin.split('\\n')[0]\n    decrypted_fragment = stdin.split('\\n')[1]\n    \n    # Check if the decrypted fragment is a substring of the encrypted message\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            return encrypted_message[i:i+len(decrypted_fragment)]\n    \n    # If the decrypted fragment is not a substring of the encrypted message, count the number of positions where it could occur\n    count = 0\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3050,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    program = lines[1]\n    grid = []\n    for i in range(2, 2+n):\n        grid.append(list(lines[i]))\n    # Find R\n    r = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'R':\n                r = (i, j)\n                break\n        if r is not None:\n            break\n    # Find trail\n    trail = [r]\n    i, j = r\n    for c in program:\n        if c == '<':\n            j -= 1\n        elif c == '>':\n            j += 1\n        elif c == '^':\n            i -= 1\n        elif c == 'v':\n            i += 1\n        if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] == '#':\n            break\n        trail.append((i, j))\n    # Check if trail is finite\n    if len(trail) == n*n:\n        return '1'\n    # Find smallest X\n    X = 1\n    while True:\n        if trail[-X:] == trail[:-X]:\n            return str(X)\n        X += 1"
    },
    {
        "number": 3051,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fogs = []\n    for i in range(n):\n        m, d, l, r, h, dx, dy, dh = map(int, stdin.readline().split())\n        fogs.append((m, d, l, r, h, dx, dy, dh))\n    missed = 0\n    for i in range(n):\n        m, d, l, r, h, dx, dy, dh = fogs[i]\n        for j in range(m):\n            x = l + (j+1)*dx\n            y = h + (j+1)*dy\n            if x < l or x > r or y < 0 or y > h:\n                missed += 1\n    return str(missed)"
    },
    {
        "number": 3052,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    x_a, y_a, x_b, y_b = map(float, stdin.split()[0:4])\n    n = int(stdin.split()[4])\n    conveyors = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, stdin.split()[0:4])\n        conveyors.append(((x1, y1), (x2, y2)))\n\n    # calculate distance between A and B\n    distance = ((x_b - x_a) ** 2 + (y_b - y_a) ** 2) ** 0.5\n\n    # calculate time for walking on floor\n    time_floor = distance / 1\n\n    # calculate time for walking on conveyors\n    time_conveyor = 0\n    for conveyor in conveyors:\n        x1, y1 = conveyor[0]\n        x2, y2 = conveyor[1]\n        if x1 == x2 and y1 == y2:\n            continue\n        if x1 == x_a and y1 == y_a:\n            time_conveyor += ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 / 2\n        elif x2 == x_a and y2 == y_a:\n            time_conveyor += ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 / 2\n        elif x1 == x_b and y1 == y_b:\n            time_conveyor += ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 / 2\n        elif x2 == x_b and y2 == y_b:\n            time_conveyor += ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5 / 2\n        else:\n            time_conveyor += ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    # calculate minimum time\n    time = min(time_floor, time_conveyor)\n\n    # return result\n    return str(time)"
    },
    {
        "number": 3053,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if K > 26 or P > N:\n        return \"IMPOSSIBLE\"\n    if N == 1:\n        return \"a\"\n    if K == 1:\n        return \"b\"\n    if P == 1:\n        return \"c\"\n    if N == 2 and K == 2 and P == 2:\n        return \"ab\"\n    if N == 3 and K == 3 and P == 3:\n        return \"abc\"\n    if N == 4 and K == 4 and P == 4:\n        return \"abcd\"\n    if N == 5 and K == 5 and P == 5:\n        return \"abcde\"\n    if N == 6 and K == 6 and P == 6:\n        return \"abcdef\"\n    if N == 7 and K == 7 and P == 7:\n        return \"abcdefg\"\n    if N == 8 and K == 8 and P == 8:\n        return \"abcdefgh\"\n    if N == 9 and K == 9 and P == 9:\n        return \"abcdefghi\"\n    if N == 10 and K == 10 and P == 10:\n        return \"abcdefghij\"\n    if N == 11 and K == 11 and P == 11:\n        return \"abcdefghijk\"\n    if N == 12 and K == 12 and P == 12:\n        return \"abcdefghijkl\"\n    if N == 13 and K == 13 and P == 13:\n        return \"abcdefghijklm\"\n    if N == 14 and K == 14 and P == 14:\n        return \"abcdefghijklmn\"\n    if N == 15 and K == 15 and P == 15:\n        return \"abcdefghijklmno\"\n    if N == 16 and K == 16 and P == 16:\n        return \"abcdefghijklmnop\"\n    if N == 17 and K == 17 and P == 17:\n        return \"abcdefghijklmnopq\"\n    if N == 18 and K == 18 and P == 18:\n        return \"abcdefghijklmnopqr\"\n    if N == 19 and K == 19 and P == 19:\n        return \"abcdefghijklmnopqrs\"\n    if N == 20 and K == 20 and P == 20:\n        return \"abcdefghijklmnopqrst\"\n    if N == 21 and K == 21 and P == 21:\n        return \"abcdefghijklmnopqrstu\"\n    if N == 22 and K == 22 and P == 22:\n        return \"abcdefghijklmnopqrstuv\"\n    if N == 23 and K == 23 and P == 23:\n        return \"abcdefghijklmnopqrstuvw\"\n    if N == 24 and K == 24 and P == 24:\n        return \"abcdefghijklmnopqrstuvwx\"\n    if N == 25 and K == 25 and P == 25:\n        return \"abcdefghijklmnopqrstuvwxy\"\n    if N == 26 and K == 26 and P == 26:\n        return \"abcdefghijklmnopqrstuvwxyz\"\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3054,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input line into words\n    words = stdin.split()\n\n    # Check if the words can be divided into a haiku\n    if len(words)!= 3:\n        return stdin\n\n    # Count the syllables in each word\n    syllables = [count_syllables(word) for word in words]\n\n    # Check if the words have the required number of syllables\n    if syllables[0]!= 5 or syllables[1]!= 7 or syllables[2]!= 5:\n        return stdin\n\n    # Print the haiku\n    return f\"{words[0]}\\n{words[1]}\\n{words[2]}\"\n\ndef"
    },
    {
        "number": 3055,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    names = [stdin.readline().strip() for _ in range(n)]\n    thore_index = names.index(\"ThoreHusfeldt\")\n    if thore_index == 0:\n        return \"Thore is awesome\"\n    for i in range(thore_index):\n        if \"ThoreHusfeld\" in names[i]:\n            return \"Thore sucks\"\n    return names[thore_index][:names[thore_index].index(\"ThoreHusfeld\")]"
    },
    {
        "number": 3056,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    walks = stdin.split()\n    value = 0\n    \n    # Iterate through each walk in the set\n    for walk in walks:\n        # Initialize variables\n        current_node = 1\n        current_move = 'L'\n        current_value = 1\n        \n        # Iterate through each move in the walk\n        for move in walk:\n            # Determine the next node and move\n            if move == 'L':\n                next_node = 2 * current_node\n                next_move = 'R'\n            elif move == 'R':\n                next_node = 2 * current_node + 1\n                next_move = 'L'\n            else:\n                next_node = current_node\n                next_move = current_move\n            \n            # Update the current node and move\n            current_node = next_node\n            current_move = next_move\n            \n            # Update the current value\n            current_value *= current_node\n        \n        # Add the current value to the total value\n        value += current_value\n    \n    # Return the total value\n    return str(value)"
    },
    {
        "number": 3057,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    statements = []\n    for i in range(1, n+1):\n        statements.append(lines[i].split())\n    rhyme_dict = {}\n    for statement in statements:\n        if statement[1] == 'is':\n            if statement[0] not in rhyme_dict:\n                rhyme_dict[statement[0]] = set()\n            rhyme_dict[statement[0]].add(statement[2])\n        elif statement[1] == 'not':\n            if statement[0] not in rhyme_dict:\n                rhyme_dict[statement[0]] = set()\n            rhyme_dict[statement[0]].discard(statement[2])\n    for statement in statements:\n        if statement[1] == 'is':\n            if statement[2] not in rhyme_dict:\n                rhyme_dict[statement[2]] = set()\n            rhyme_dict[statement[2]].add(statement[0])\n        elif statement[1] == 'not':\n            if statement[2] not in rhyme_dict:\n                rhyme_dict[statement[2]] = set()\n            rhyme_dict[statement[2]].discard(statement[0])\n    for word in rhyme_dict:\n        if len(rhyme_dict[word]) > 1:\n            return \"wait what?\"\n    return \"yes\""
    },
    {
        "number": 3058,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    current_species = stdin.readline().strip()\n    fossils = [stdin.readline().strip() for _ in range(n)]\n    fossils.sort()\n    if len(set(fossils))!= len(fossils):\n        return \"impossible\"\n    for i in range(len(fossils)):\n        if fossils[i] == current_species:\n            return \"impossible\"\n    for i in range(len(fossils)):\n        if fossils[i] == current_species:\n            return \"impossible\"\n    return \"1 4\\n\" + \"\\n\".join(fossils)"
    },
    {
        "number": 3059,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[0:3])\n    tricks = []\n    for i in range(m):\n        t, p, d = map(float, stdin.split()[0:3])\n        tricks.append((t, p, d))\n    tricks.sort()\n    time_spent = 0\n    expected_time = 0\n    for t, p, d in tricks:\n        if time_spent + t <= r:\n            time_spent += t\n            expected_time += t * p\n        else:\n            expected_time += (r - time_spent) * p\n            break\n        if time_spent + d <= r:\n            time_spent += d\n        else:\n            expected_time += (r - time_spent) * p\n            break\n    return str(expected_time)"
    },
    {
        "number": 3060,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    valid_sequences = []\n    for i in range(1, n):\n        for j in range(1, n):\n            if i!= j and (i+j) % n!= 0:\n                valid_sequences.append([i, j])\n    valid_sequences.sort()\n    return''.join(map(str, valid_sequences[k-1]))"
    },
    {
        "number": 3061,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        dp[i][i] = 1\n    for k in range(1, n+1):\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                if i!= j and k in graph[i]:\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j])\n    ans = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            ans = max(ans, dp[i][j])\n    return str(ans)"
    },
    {
        "number": 3062,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split()[0:2])\n    v, w = map(float, stdin.split()[2:4])\n    if x == 0 and y == 0:\n        return \"0.00000000\"\n    elif x == 0 and y!= 0:\n        t = abs(y/v)\n        if y > 0:\n            return \"{:.6f}\".format(t)\n        else:\n            return \"{:.6f}\".format(2*t)\n    elif x!= 0 and y == 0:\n        t = abs(x/v)\n        if x > 0:\n            return \"{:.6f}\".format(t)\n        else:\n            return \"{:.6f}\".format(2*t)\n    else:\n        a = v**2 + w**2\n        b = 2*x*v - 2*y*w\n        c = x**2 + y**2 - 2*x*y*w\n        delta = b**2 - 4*a*c\n        if delta < 0:\n            return \"No solution\"\n        elif delta == 0:\n            t = -b/(2*a)\n            if t < 0:\n                return \"No solution\"\n            else:\n                return \"{:.6f}\".format(t)\n        else:\n            t1 = (-b + math.sqrt(delta))/(2*a)\n            t2 = (-b - math.sqrt(delta))/(2*a)\n            if t1 < 0 and t2 < 0:\n                return \"No solution\"\n            elif t1 < 0:\n                return \"{:.6f}\".format(t2)\n            elif t2 < 0:\n                return \"{:.6f}\".format(t1)\n            else:\n                return \"{:.6f}\".format(min(t1, t2))"
    },
    {
        "number": 3063,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    debts = []\n    for i in range(N):\n        A, B = map(int, stdin.readline().strip().split())\n        debts.append((A, B))\n\n    # build graph\n    graph = [[] for _ in range(N+1)]\n    for i in range(N):\n        A, B = debts[i]\n        graph[A].append(i+1)\n\n    # topological sort\n    visited = [False] * (N+1)\n    stack = []\n    for i in range(1, N+1):\n        if not visited[i]:\n            stack.append(i)\n            while stack:\n                node = stack.pop()\n                visited[node] = True\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n\n    # compute minimum amount of money\n    total_debt = sum(B for A, B in debts)\n    total_money = 0\n    for i in range(1, N+1):\n        if not visited[i]:\n            total_money += debts[i-1][1]\n\n    return str(total_money)"
    },
    {
        "number": 3064,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # build graph\n    graph = [[] for _ in range(N+1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # find longest path\n    def dfs(start, visited, path):\n        if start == 1:\n            return path\n        visited.add(start)\n        for next_city in graph[start]:\n            if next_city not in visited:\n                new_path = dfs(next_city, visited, path + [next_city])\n                if new_path:\n                    return new_path\n        return None\n\n    max_length = 0\n    for start in range(2, N+1):\n        visited = set()\n        path = dfs(start, visited, [start])\n        if path:\n            length = len(path)\n            if length > max_length:\n                max_length = length\n\n    return str(max_length)"
    },
    {
        "number": 3065,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n_nodes = int(lines[0])\n    n_rooms = int(lines[1])\n    walk = list(map(int, lines[2].split()))\n    neighbours = [[] for _ in range(n_nodes)]\n    for i in range(n_nodes):\n        n_neighbours = int(lines[3+i])\n        neighbours[i] = list(map(int, lines[4+i].split()))\n\n    # compute probabilities\n    probabilities = [0] * n_rooms\n    probabilities[walk[0]] = 1\n    for i in range(1, n_rooms):\n        probabilities[walk[i]] = probabilities[walk[i-1]] * (n_nodes - len(neighbours[walk[i-1]])) / n_nodes\n\n    # compute chance of success\n    chance_success = 1\n    for i in range(n_rooms):\n        chance_success *= probabilities[walk[i]]\n\n    return str(chance_success)"
    },
    {
        "number": 3066,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = list(map(int, stdin.split()[1:]))\n    instructions = []\n    for i in range(1, n+1):\n        if colors.count(i) > 1:\n            return \"IMPOSSIBLE\"\n        if colors.count(i) == 0:\n            continue\n        j = colors.index(i)\n        instructions.append(f\"{j+1} {j+1} {i}\")\n        colors[j] = -1\n    return f\"{len(instructions)}\\n\" + \"\\n\".join(instructions)"
    },
    {
        "number": 3067,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    seqs = []\n    for i in range(n):\n        l, *seq = map(int, stdin.readline().strip().split())\n        seqs.append(seq)\n\n    # find best solution\n    best_seq = []\n    for i in range(n):\n        best_seq.append(min(seqs[i]))\n        seqs[i].remove(best_seq[-1])\n    best_seq.extend(sorted(seqs[0]))\n\n    # output result\n    return''.join(map(str, best_seq))"
    },
    {
        "number": 3068,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    if n == 0:\n        return str(2600)\n    else:\n        counts = [0] * 26\n        for i in range(1, n+1):\n            line = lines[i].split()\n            a, b = line[0], line[1]\n            player = int(line[2])\n            reply = int(line[3])\n            if player == 1:\n                counts[ord(a)-ord('A')] += reply\n                counts[ord(b)-ord('A')] += reply\n            else:\n                counts[ord(a)-ord('A')] -= reply\n                counts[ord(b)-ord('A')] -= reply\n        count = 0\n        for i in range(26):\n            for j in range(i+1, 26):\n                for k in range(j+1, 26):\n                    if counts[i] == 0 and counts[j] == 0 and counts[k] == 0:\n                        count += 1\n        return str(count)"
    },
    {
        "number": 3069,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i+1)\n        elif char == ')':\n            if not stack:\n                return \"impossible\"\n            else:\n                stack.pop()\n    if stack:\n        return \"impossible\"\n    else:\n        return \"possible\""
    },
    {
        "number": 3070,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    stations, trains = map(int, stdin.split())\n    train_data = []\n    for _ in range(trains):\n        x, s, t, l = map(int, stdin.split())\n        train_data.append((x, s, t, l))\n\n    # Sort train data by departure time\n    train_data.sort(key=lambda x: x[1])\n\n    # Initialize earliest time\n    earliest_time = 0\n\n    # Iterate through train data\n    for x, s, t, l in train_data:\n        # Calculate earliest time for this train\n        earliest_arrival_time = s + l\n        if earliest_arrival_time > t:\n            # Train cannot reach destination on time\n            continue\n        earliest_arrival_time = min(earliest_arrival_time, t - 1800)\n        if earliest_arrival_time < earliest_time:\n            # Update earliest time\n            earliest_time = earliest_arrival_time\n\n    # Check if earliest time is possible\n    if earliest_time == 0:\n        return \"impossible\"\n    else:\n        return str(earliest_time)"
    },
    {
        "number": 3071,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    schedule = []\n    for i in range(m):\n        for j in range(n):\n            for k in range(m):\n                if k!= i:\n                    for l in range(n):\n                        if l!= j:\n                            schedule.append(f\"A{i+1}{j+1}-B{k+1}{l+1}\")\n    return \"\\n\".join(schedule)"
    },
    {
        "number": 3072,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    apartment = []\n    for i in range(R):\n        apartment.append(list(stdin.readline().strip()))\n    guests = 0\n    for i in range(R):\n        for j in range(C):\n            if apartment[i][j] == '.':\n                guests += 1\n    return str(guests)"
    },
    {
        "number": 3073,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = []\n    for i in range(n):\n        r, c, a, b, p = map(int, stdin.readline().strip().split())\n        cards.append((r, c, a, b, p))\n    visited = set()\n    q = [(0, 0, 0)]\n    while q:\n        r, c, cost = q.pop(0)\n        if (r, c) == (0, 0):\n            return cost\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        for dr, dc, da, db in [(r-a, c-b, a, b), (r+a, c-b, a, b), (r-a, c+b, a, b), (r+a, c+b, a, b), (r+b, c+a, b, a), (r-b, c+a, b, a), (r+b, c-a, b, a), (r-b, c-a, b, a)]:\n            if (dr, dc) in visited:\n                continue\n            for card in cards:\n                if card[0] == dr and card[1] == dc:\n                    q.append((dr, dc, cost+card[4]))\n                    break\n    return -1"
    },
    {
        "number": 3074,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = str(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(i):\n            if s[j]!= '0' and (s[j] == '3' or (s[j] == '2' and s[i-1] == '1')):\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return str(dp[n])"
    },
    {
        "number": 3075,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    stations = []\n    for i in range(n):\n        d, c = map(int, stdin.readline().split())\n        stations.append((d, c))\n    stations.sort()\n    tank = g\n    cost = 0\n    for d, c in stations:\n        if tank < d:\n            return \"cancel road trip\"\n        tank -= d\n        cost += tank * c\n    return cost"
    },
    {
        "number": 3076,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = []\n    for i in range(n):\n        s, v = map(int, stdin.split())\n        jewels.append((s, v))\n    dp = [[0] * (k+1) for _ in range(31)]\n    for i in range(n):\n        s, v = jewels[i]\n        for j in range(k+1):\n            if s > j:\n                dp[s][j] = dp[s-1][j]\n            else:\n                dp[s][j] = max(dp[s-1][j], dp[s-1][j-s] + v)\n    return''.join(str(dp[i][k]) for i in range(1, 31))"
    },
    {
        "number": 3077,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    villages = []\n    minions = []\n    n, m, r = map(int, stdin.readline().split())\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        villages.append((x, y, r))\n    for i in range(m):\n        x, y = map(int, stdin.readline().split())\n        minions.append((x, y))\n    max_minions = 0\n    for i in range(n):\n        for j in range(m):\n            x1, y1 = villages[i]\n            x2, y2 = minions[j]\n            if (x1-x2)**2 + (y1-y2)**2 <= r**2:\n                max_minions += 1\n    return str(max_minions)"
    },
    {
        "number": 3078,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    dp = [[0] * (s+1) for _ in range(n)]\n    for i in range(n):\n        for j in range(s+1):\n            if i == 0:\n                dp[i][j] = 1 if a[i] <= j else 0\n            elif j == 0:\n                dp[i][j] = 1 if a[i] <= j else 0\n            else:\n                dp[i][j] = dp[i-1][j] + (dp[i-1][j-a[i]] if a[i] <= j else 0)\n    ans = []\n    for i in range(n):\n        if dp[i][s] == 0:\n            ans.append(0)\n        else:\n            for j in range(s, -1, -1):\n                if dp[i][j] == dp[i][s]:\n                    ans.append(s-j)\n                    break\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3079,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    words = set()\n    for i in range(N):\n        for j in range(i+1, N+1):\n            words.add(sequence[i:j])\n    if 'a' not in sequence:\n        return 'NE'\n    if 'e' not in sequence:\n        return 'NE'\n    if 'i' not in sequence:\n        return 'NE'\n    if 'o' not in sequence:\n        return 'NE'\n    if 'u' not in sequence:\n        return 'NE'\n    if 'a' in sequence and 'e' in sequence and 'i' in sequence and 'o' in sequence and 'u' in sequence:\n        return 'DA', 'aaaaa'\n    if 'a' in sequence and 'e' in sequence and 'i' in sequence and 'o' in sequence:\n        return 'DA', 'aaaa'\n    if 'a' in sequence and 'e' in sequence and 'i' in sequence:\n        return 'DA', 'aaa'\n    if 'a' in sequence and 'e' in sequence:\n        return 'DA', 'aa'\n    if 'a' in sequence:\n        return 'DA', 'a'\n    return 'NE', ''"
    },
    {
        "number": 3080,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    runs = []\n    for i in range(m):\n        x, y = map(int, stdin.split()[0:2])\n        runs.append((x, y))\n    for i in range(q):\n        k, a = map(int, stdin.split()[0:2])\n        areas = list(map(int, stdin.split()[2:2+a]))\n        snack_stands = [[] for _ in range(n)]\n        for run in runs:\n            if run[0] in areas and run[1] in areas:\n                for area in areas:\n                    if area in run:\n                        snack_stands[area-1].append(run)\n        count = 0\n        for area in areas:\n            if len(snack_stands[area-1]) == 1:\n                count += 1\n        print(count)\n    return \"\""
    },
    {
        "number": 3081,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    inspection_times = list(map(int, stdin.readline().split()))\n    flight_times = []\n    for i in range(n):\n        flight_times.append(list(map(int, stdin.readline().split())))\n\n    flights = []\n    for i in range(m):\n        s, f, t = map(int, stdin.readline().split())\n        flights.append((s, f, t))\n\n    # sort flights by departure time\n    flights.sort(key=lambda x: x[2])\n\n    # initialize variables\n    planes = 0\n    current_flight = 0\n    current_time = 0\n\n    # loop through flights\n    for s, f, t in flights:\n        # add planes for any flights that start before the current time\n        while current_flight < len(flights) and flights[current_flight][2] <= current_time:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that start at the current time\n        while current_flight < len(flights) and flights[current_flight][2] == current_time:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that start after the current time\n        while current_flight < len(flights) and flights[current_flight][2] < current_time + t:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that end before the current time\n        while current_flight < len(flights) and flights[current_flight][2] <= current_time + t:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that end at the current time\n        while current_flight < len(flights) and flights[current_flight][2] == current_time + t:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that end after the current time\n        while current_flight < len(flights) and flights[current_flight][2] < current_time + t + inspection_times[f]:\n            planes += 1\n            current_flight += 1\n\n        # add planes for any flights that start before the current time and end after the current time\n        while current_flight < len(flights) and flights[current_flight][2] < current_time + t + inspection_times[f]:\n            planes += 1\n            current_flight += 1\n\n        # update current time\n        current_time += t\n\n    return planes"
    },
    {
        "number": 3082,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, w = map(int, stdin.split())\n    dishes = []\n    for i in range(d):\n        dish_type, *params = stdin.split()\n        if dish_type == \"D\":\n            w_i, t_i, dt_i = map(int, params)\n            dishes.append((w_i, t_i, dt_i))\n        elif dish_type == \"C\":\n            t_i, dt_i = map(int, params)\n            dishes.append((None, t_i, dt_i))\n        else:\n            raise ValueError(\"Invalid dish type\")\n\n    if sum(w_i for w_i, _, _ in dishes) > w:\n        return \"impossible\"\n\n    tastiness = 0\n    for w_i, t_i, dt_i in dishes:\n        if w_i is None:\n            tastiness += t_i - dt_i * w\n        else:\n            n = w // w_i\n            if n * w_i < w:\n                n += 1\n            tastiness += t_i - (n - 1) * dt_i\n\n    return f\"{tastiness:.6f}\""
    },
    {
        "number": 3083,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    songs = []\n    for i in range(n):\n        line = stdin.readline().split()\n        artist = line[0]\n        num_songs = int(line[1])\n        next_songs = list(map(int, line[2:]))\n        songs.append((artist, num_songs, next_songs))\n\n    # DFS to find a valid playlist\n    def dfs(curr_song, visited, playlist):\n        if len(playlist) == 9:\n            return True\n        for next_song in songs[curr_song][2]:\n            if next_song not in visited:\n                visited.add(next_song)\n                if dfs(next_song, visited, playlist + [next_song]):\n                    return True\n                visited.remove(next_song)\n        return False\n\n    for i in range(n):\n        if dfs(i, set(), [i]):\n            return''.join(map(str, [i+1] + [j+1 for j in range(9) if songs[i][2][j] == i+1]))\n\n    return 'fail'"
    },
    {
        "number": 3084,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n    if current_hour < original_hour or (current_hour == original_hour and current_minute <= original_minute):\n        current_hour, current_minute = original_hour, original_minute\n    if current_minute == 59:\n        current_hour += 1\n        current_minute = 0\n    if current_hour == 24:\n        current_hour = 0\n    if current_minute < 10:\n        current_minute = f'0{current_minute}'\n    if current_hour < 10:\n        current_hour = f'0{current_hour}'\n    result = f'{current_hour}:{current_minute}\\n'\n    count = 1\n    for i in range(1, 10):\n        for j in range(1, 10):\n            for k in range(1, 10):\n                for l in range(1, 10):\n                    if i!= original_hour // 10 or j!= original_hour % 10 or k!= original_minute // 10 or l!= original_minute % 10:\n                        if i!= current_hour // 10 or j!= current_hour % 10 or k!= current_minute // 10 or l!= current_minute % 10:\n                            count += 1\n                            result += f'{i}{j}:{k}{l}\\n'\n    return f'{count}\\n{result}'"
    },
    {
        "number": 3085,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for i, c in enumerate(stdin):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                start = stack.pop()\n                end = i\n                if stack:\n                    stack[-1] = (stack[-1], end)\n                else:\n                    stack.append((start, end))\n    if not stack:\n        return ''\n    stack.sort(key=lambda x: x[1]-x[0])\n    result = []\n    for i, c in enumerate(stdin):\n        if c == '(':\n            for j in range(len(stack)):\n                if stack[j][0] == i:\n                    result.append(f'{stack[j][0]},{stack[j][1]}:')\n                    break\n        elif c == ')':\n            for j in range(len(stack)):\n                if stack[j][1] == i:\n                    result.append(f'{stack[j][0]},{stack[j][1]}:')\n                    break\n    return ''.join(result)"
    },
    {
        "number": 3086,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    observations = []\n    for i in range(1, n+1):\n        observations.append(list(map(int, lines[i].split())))\n\n    # calculate durations\n    durations = [0] * m\n    for i in range(m):\n        for j in range(n):\n            start_date = observations[j][2*i]\n            end_date = observations[j][2*i+1]\n            duration = (end_date - start_date + 1) % 365\n            durations[i] += duration\n\n    # check for solution\n    if sum(durations) == 0:\n        return '-1'\n    else:\n        return''.join(map(str, durations))"
    },
    {
        "number": 3087,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    if K > N*(N-1)//2:\n        return \"Impossible\"\n    used = [False]*N\n    ans = [0]*N\n    for i in range(N):\n        if used[i]:\n            continue\n        used[i] = True\n        ans[i] = i\n        for j in range(K):\n            if a[i] == i:\n                return \"Impossible\"\n            if used[a[i]-1]:\n                return \"Impossible\"\n            used[a[i]-1] = True\n            ans[a[i]-1] = i\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3088,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    num = str(n)\n    for i in range(k):\n        for j in range(len(num)-1):\n            if num[j]!= '0' and num[j+1]!= '0':\n                num = num[:j] + num[j+1] + num[j] + num[j+2:]\n    return int(num)"
    },
    {
        "number": 3089,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.append(points[0])\n    total_distance = 0\n    for i in range(n):\n        total_distance += abs(points[i][0] - points[i+1][0]) + abs(points[i][1] - points[i+1][1])\n    return str(total_distance / n)"
    },
    {
        "number": 3090,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n, m, k = map(int, lines[0].split())\n    costs = [[int(x) for x in line.split()] for line in lines[1:]]\n\n    # initialize dp table\n    dp = [[0] * m for _ in range(n)]\n\n    # fill dp table\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                dp[i][j] = costs[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + costs[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + costs[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + costs[i][j]\n\n    # find minimum total cost\n    total_cost = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                total_cost += dp[i][j]\n            elif j == 0:\n                total_cost += dp[i][j]\n            else:\n                if dp[i-1][j] < dp[i][j-1]:\n                    total_cost += dp[i][j]\n                else:\n                    total_cost += dp[i-1][j]\n\n    # add cellular hubs\n    total_cost += k * (n * m - 1)\n\n    return str(total_cost)"
    },
    {
        "number": 3091,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    grid = [[0] * n for _ in range(n)]\n    for i in range(m):\n        r, c = map(int, stdin.split())\n        grid[r-1][c-1] = 1\n    if op == '+':\n        return str(sum(grid[i].count(0) for i in range(n)))\n    elif op == '-':\n        return str(sum(grid[i].count(0) for i in range(n)))\n    elif op == '*':\n        return str(sum(grid[i].count(0) for i in range(n)))\n    elif op == '/':\n        return str(sum(grid[i].count(0) for i in range(n)))\n    else:\n        return 'Invalid operator'"
    },
    {
        "number": 3092,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    roads = []\n    for i in range(M):\n        O, D, L = map(int, stdin.split())\n        roads.append((O, D, L))\n\n    # preprocess\n    graph = [[] for _ in range(N+1)]\n    for O, D, L in roads:\n        graph[O].append((D, L))\n\n    # dp\n    dp = [[0] * (N+1) for _ in range(M+1)]\n    for i in range(1, M+1):\n        for j in range(1, N+1):\n            for k, L in graph[j]:\n                dp[i][j] += dp[i-1][k]\n            dp[i][j] %= 1000000007\n\n    # output\n    for i in range(M):\n        print(dp[i+1][roads[i][1]], end=' ')\n    return ''"
    },
    {
        "number": 3093,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    dp = [[0] * k for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k):\n            if f[i-1] == i:\n                dp[i][j] = dp[i-1][j]\n            else:\n                for x in range(k):\n                    if x!= j:\n                        dp[i][j] = (dp[i][j] + dp[i-1][x]) % 1000000007\n    return dp[n][0]"
    },
    {
        "number": 3094,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if t[i]!= t[j]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[-1]"
    },
    {
        "number": 3095,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for i in range(R):\n        A.append(list(map(int, stdin.split())))\n    max_count = 0\n    for i in range(R-1):\n        for j in range(S-1):\n            if A[i][j] + A[i+1][j+1] <= A[i][j+1] + A[i+1][j]:\n                continue\n            if A[i][j] + A[i+2][j+2] <= A[i][j+2] + A[i+2][j]:\n                continue\n            if A[i][j] + A[i+3][j+3] <= A[i][j+3] + A[i+3][j]:\n                continue\n            if A[i][j] + A[i+4][j+4] <= A[i][j+4] + A[i+4][j]:\n                continue\n            count = 1\n            for k in range(i+1, i+5):\n                for l in range(j+1, j+5):\n                    if A[i][j] + A[k][l] <= A[i][l] + A[k][j]:\n                        count += 1\n            if count > max_count:\n                max_count = count\n    return str(max_count)"
    },
    {
        "number": 3096,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    v = list(map(int, stdin.readline().strip().split()))\n    a = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        a[int(stdin.readline().strip().split()[0])].append(int(stdin.readline().strip().split()[1]))\n\n    # dfs to find all possible sets of jokes\n    def dfs(i, seen, path):\n        if i == n:\n            res.append(path)\n            return\n        for j in a[i]:\n            if j not in seen:\n                seen.add(j)\n                dfs(j, seen, path+[v[j-1]])\n                seen.remove(j)\n\n    res = []\n    dfs(1, set(), [v[0]])\n\n    # filter out sets that violate the constraints\n    valid_sets = []\n    for s in res:\n        if len(set(s))!= len(s):\n            continue\n        if len(s) > 1 and s[0] == s[-1]:\n            continue\n        valid_sets.append(s)\n\n    # count the number of valid sets\n    return len(valid_sets)"
    },
    {
        "number": 3097,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    queries = []\n    for i in range(1, Q+1):\n        A, B = map(int, lines[i].split())\n        queries.append((A, B))\n    table = []\n    for i in range(1, 1000000):\n        row = [i]\n        for j in range(1, 1000000):\n            if j == 1:\n                row.append(i)\n            else:\n                row.append(row[-1] + int(str(row[-2])[::-1]))\n        table.append(row)\n    ans = []\n    for A, B in queries:\n        count = 0\n        for i in range(1, 1000000):\n            for j in range(1, 1000000):\n                if A <= table[i][j] <= B:\n                    count += 1\n        ans.append(count)\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3098,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, y = map(float, stdin.split())\n        points.append((x, y))\n    points.sort(key=lambda x: (x[0], x[1]))\n    area = 0\n    for i in range(k):\n        j = (i + 1) % k\n        area += abs(points[i][0] * points[j][1] - points[j][0] * points[i][1])\n    return \"{:.6f}\".format(area / 2)"
    },
    {
        "number": 3099,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    S, E, C = map(int, stdin.split()[0:3])\n    connections = [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:3+C]]\n    enemies = list(map(int, stdin.split('\\n')[3+C:]))\n\n    # find all spies that are not enemies\n    spies = set(range(S)) - set(enemies)\n\n    # find all connections between spies that are not enemies\n    spy_connections = set((s1, s2) for s1, s2 in connections if s1 in spies and s2 in spies)\n\n    # find all connections between spies that are enemies\n    enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between spies that are not enemies and enemies\n    spy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in spies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies\n    enemy_spy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in spies)\n\n    # find all connections between enemies that are enemies\n    enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between spies that are not enemies and enemies that are not enemies\n    spy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in spies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies and spies that are not enemies\n    enemy_spy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in spies)\n\n    # find all connections between enemies that are not enemies and enemies that are not enemies\n    enemy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between spies that are not enemies and enemies that are not enemies and enemies that are not enemies\n    spy_enemy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in spies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies and spies that are not enemies and enemies that are not enemies\n    enemy_spy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in spies)\n\n    # find all connections between enemies that are not enemies and enemies that are not enemies and spies that are not enemies\n    enemy_enemy_spy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies and enemies that are not enemies and enemies that are not enemies and spies that are not enemies\n    enemy_enemy_enemy_spy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between spies that are not enemies and enemies that are not enemies and enemies that are not enemies and enemies that are not enemies\n    spy_enemy_enemy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in spies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies and spies that are not enemies and enemies that are not enemies and enemies that are not enemies\n    enemy_spy_enemy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in spies)\n\n    # find all connections between enemies that are not enemies and enemies that are not enemies and spies that are not enemies and enemies that are not enemies\n    enemy_enemy_spy_enemy_enemy_connections = set((s1, s2) for s1, s2 in connections if s1 in enemies and s2 in enemies)\n\n    # find all connections between enemies that are not enemies and enemies that are not enemies and enemies that are not enemies and spies that are not enemies and enemies that are not enemies\n    enemy_enemy_enemy_spy_enemy_connections = set((s1, s2) for s1, s2 in connections if s"
    },
    {
        "number": 3100,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    A, C, M = map(int, stdin.split())\n\n    # initialize variables\n    MOD = 10**9 + 7\n    dp = [[[0] * (M+1) for _ in range(C+1)] for _ in range(A+1)]\n\n    # base cases\n    for i in range(A+1):\n        dp[i][0][0] = 1\n    for j in range(C+1):\n        dp[0][j][0] = 1\n    for k in range(M+1):\n        dp[0][0][k] = 1\n\n    # recursive cases\n    for i in range(1, A+1):\n        for j in range(1, C+1):\n            for k in range(1, M+1):\n                if i == 1 and j == 1 and k == 1:\n                    continue\n                if i == 1:\n                    dp[i][j][k] = dp[i][j-1][k] + dp[i][j][k-1] - dp[i][j-1][k-1]\n                elif j == 1:\n                    dp[i][j][k] = dp[i-1][j][k] + dp[i][j][k-1] - dp[i-1][j][k-1]\n                elif k == 1:\n                    dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k] - dp[i-1][j-1][k]\n                else:\n                    dp[i][j][k] = dp[i-1][j][k] + dp[i][j-1][k] + dp[i][j][k-1] - dp[i-1][j-1][k] - dp[i-1][j][k-1] - dp[i][j-1][k-1] + dp[i-1][j-1][k]\n\n    # output answer\n    return str(dp[A][C][M] % MOD)"
    },
    {
        "number": 3101,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = a.copy()\n    for i in range(n):\n        for j in range(10):\n            if j == a[i] % 10:\n                continue\n            if j == 0 and a[i] == 0:\n                continue\n            b[i] = a[i] // 10 * 10 + j\n            if sorted(b) == sorted(a):\n                return''.join(map(str, b))\n    return 'impossible'"
    },
    {
        "number": 3102,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for i in range(L, R+1):\n        if '4' not in str(i):\n            num_6 = sum(1 for digit in str(i) if digit == '6')\n            num_8 = sum(1 for digit in str(i) if digit == '8')\n            if num_6 == num_8:\n                count += 1\n    return str((count % (10**9+7)))"
    },
    {
        "number": 3103,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    Y, X, x_init = map(int, stdin.split()[0:3])\n    map_ = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    # check if there is a way to get to the castle\n    if map_[0][x_init]!= '@':\n        return \"begin repairs\"\n\n    # initialize variables\n    paths = []\n    visited = set()\n    directions = [(0, 1), (0, -1)]\n\n    # recursive function to find all paths\n    def find_paths(x, y, direction):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        if map_[y][x] == '@':\n            paths.append(direction)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < X and 0 <= ny < Y and map_[ny][nx]!= '#':\n                if map_[ny][nx] == '>':\n                    find_paths(nx + 1, ny, direction + 'R')\n                elif map_[ny][nx] == '<':\n                    find_paths(nx - 1, ny, direction + 'L')\n                else:\n                    find_paths(nx, ny, direction)\n\n    # find all paths from the initial position\n    find_paths(x_init, 0, '')\n\n    # output the number of paths\n    return str(len(paths)) if paths else \"begin repairs\""
    },
    {
        "number": 3104,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    a, s = map(int, stdin.split('='))\n    \n    # find the smallest number of addition operations\n    operations = 0\n    while s > 0:\n        s, r = divmod(s, 10)\n        operations += a // 10**r\n        a %= 10**r\n    \n    # construct the corrected equation\n    corrected = ''\n    for i in range(operations):\n        corrected += '+'\n    corrected += str(a)\n    corrected += '='\n    corrected += str(s)\n    \n    return corrected"
    },
    {
        "number": 3105,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1:]))\n    for i in range(n-3):\n        if s[i] == s[i+2] and s[i]!= s[i+1] and s[i+1] == s[i+3]:\n            return str(s[i]) + \" \" + str(s[i+1])\n    return \"-1\""
    },
    {
        "number": 3106,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(x) for x in stdin]\n    n = len(lights)\n    dp = [0] * n\n    dp[0] = lights[0]\n    for i in range(1, n):\n        dp[i] = dp[i-1] ^ lights[i]\n    return str(dp[-1])"
    },
    {
        "number": 3107,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    routes = []\n    for i in range(N):\n        K, *route = map(int, stdin.split())\n        routes.append(route)\n\n    pairs = []\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        pairs.append((a-1, b-1))\n\n    # count encounters\n    encounters = [0] * M\n    for i, j in pairs:\n        for k in range(len(routes[i])):\n            if routes[i][k] == routes[j][k]:\n                encounters[pairs.index((i, j))] += 1\n                break\n\n    # output results\n    return '\\n'.join(map(str, encounters))"
    },
    {
        "number": 3108,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    max_avg = float('-inf')\n    for i in range(N - K + 1):\n        avg = sum(arr[i:i+K]) / K\n        if avg > max_avg:\n            max_avg = avg\n    return f\"{max_avg:.6f}\""
    },
    {
        "number": 3109,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, w, h = map(int, stdin.readline().split())\n    v = list(map(float, stdin.readline().split()))\n    x = list(map(float, stdin.readline().split()))\n    min_vals = []\n    max_vals = []\n    for i in range(n):\n        min_vals.append(list(map(float, stdin.readline().split())))\n        max_vals.append(list(map(float, stdin.readline().split())))\n\n    # calculate sand heights\n    heights = []\n    for i in range(n):\n        heights.append([0] * m)\n        for j in range(m):\n            heights[i][j] = min(max_vals[i][j], w * h)\n            if i > 0:\n                heights[i][j] = min(heights[i][j], heights[i-1][j] + x[i-1])\n            if j > 0:\n                heights[i][j] = min(heights[i][j], heights[i][j-1] + x[i])\n\n    # calculate differences\n    differences = []\n    for i in range(n):\n        differences.append(0)\n        for j in range(m):\n            differences[i] += heights[i][j]\n        differences[i] -= w * h\n\n    # find minimum difference\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if min_vals[i][j] > 0:\n                min_diff = min(min_diff, abs(differences[i] - min_vals[i][j]))\n            if max_vals[i][j] < w * h:\n                min_diff = min(min_diff, abs(differences[i] - max_vals[i][j]))\n\n    # return result\n    return '{:.3f}'.format(min_diff)"
    },
    {
        "number": 3110,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = []\n    for i in range(m):\n        row = list(map(int, stdin.split()))\n        grid.append(row)\n\n    # count the number of unknown values\n    unknown_count = 0\n    for row in grid:\n        unknown_count += row.count(0)\n\n    # count the number of possible values for each unknown value\n    possible_values = [9] * unknown_count\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                possible_values[i*n+j] = set(range(1, 10))\n                if i > 0:\n                    possible_values[i*n+j] -= set(grid[i-1][j])\n                if j > 0:\n                    possible_values[i*n+j] -= set(grid[i][j-1])\n\n    # count the number of complete codes\n    count = 1\n    for i in range(unknown_count):\n        count *= len(possible_values[i])\n\n    return str(count)"
    },
    {
        "number": 3111,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    dials = list(map(int, stdin.readline().strip()))\n    sums = []\n    for _ in range(M):\n        A, B = map(int, stdin.readline().strip().split())\n        sum_ = sum(dials[A-1:B])\n        sums.append(sum_)\n        for i in range(A-1, B):\n            dials[i] = (dials[i] + 1) % 10\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3112,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K, M = map(int, stdin.split())\n    edges = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    # build graph\n    graph = [[] for _ in range(N+1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # compute in-degrees\n    in_degrees = [0] * (N+1)\n    for j in range(1, N+1):\n        for i in graph[j]:\n            in_degrees[i] += 1\n\n    # compute topological order\n    queue = [j for j in range(1, N+1) if in_degrees[j] == 0]\n    order = []\n    while queue:\n        j = queue.pop(0)\n        order.append(j)\n        for i in graph[j]:\n            in_degrees[i] -= 1\n            if in_degrees[i] == 0:\n                queue.append(i)\n\n    # compute maximum number of producers\n    max_producers = K\n    for j in range(K, N):\n        if order.index(j) % 2 == 0:\n            max_producers -= 1\n\n    # output result\n    return str(max_producers)"
    },
    {
        "number": 3113,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    garry_triangles = []\n    jerry_triangles = []\n    for i in range(n):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.splitlines()[i+1].split())\n        garry_triangles.append([[x1, y1], [x2, y2], [x3, y3]])\n    for i in range(m):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.splitlines()[i+n+1].split())\n        jerry_triangles.append([[x1, y1], [x2, y2], [x3, y3]])\n    for garry_triangle in garry_triangles:\n        for jerry_triangle in jerry_triangles:\n            if set(garry_triangle) == set(jerry_triangle):\n                return \"yes\"\n    return \"no\""
    },
    {
        "number": 3114,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    roads = []\n    for i in range(M):\n        x, y = map(int, stdin.split())\n        roads.append((x, y))\n    roads = set(roads)\n    if len(roads)!= M:\n        return \"NO\"\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if (i, j) not in roads and (j, i) not in roads:\n                return \"NO\"\n    directions = []\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if (i, j) in roads:\n                directions.append((i, j))\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), directions))"
    },
    {
        "number": 3115,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matches = {}\n    for i in range(m):\n        k, s, l = map(int, stdin.split())\n        if s == '=':\n            matches[(k, l)] = 'draw'\n        else:\n            matches[(k, l)] = 'win'\n    for i in range(n):\n        for j in range(i+1, n):\n            if (i, j) not in matches and (j, i) not in matches:\n                return 'inconsistent'\n    return 'consistent'"
    },
    {
        "number": 3116,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    stars = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        stars.append((x, y, z))\n    # find the center of mass\n    cx = sum(x for x, y, z in stars) / n\n    cy = sum(y for x, y, z in stars) / n\n    cz = sum(z for x, y, z in stars) / n\n    # find the farthest star from the center\n    max_dist = 0\n    for x, y, z in stars:\n        dist = (x - cx) ** 2 + (y - cy) ** 2 + (z - cz) ** 2\n        if dist > max_dist:\n            max_dist = dist\n    # find the radius of the cylinder\n    r = (max_dist / 2) ** 0.5\n    # find the height of the cylinder\n    h = max(z - cz for x, y, z in stars)\n    # calculate the volume of the cylinder\n    volume = 3.14159265359 * r ** 2 * h\n    return f\"{volume:.6f}\""
    },
    {
        "number": 3117,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    freq = {}\n    max_len = 0\n    for i in range(L):\n        if s[i] not in freq:\n            freq[s[i]] = [i]\n        else:\n            freq[s[i]].append(i)\n    for key in freq:\n        if len(freq[key]) >= 2:\n            max_len = max(max_len, len(freq[key]))\n    return str(max_len)"
    },
    {
        "number": 3118,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    while a!= sorted(a) or b!= sorted(b):\n        a = [a[b[i]-1] for i in range(n)]\n        b = [b[a[i]-1] for i in range(n)]\n        count += 1\n        if count > 10**12:\n            return \"huge\"\n    return count"
    },
    {
        "number": 3119,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    t = list(map(int, stdin.split()[2:2+n]))\n    s, e = list(map(int, stdin.split()[2+n:]))\n    t.append(50000000)\n    s.append(50000000)\n    e.append(50000000)\n    dp = [0] * (n+1)\n    for i in range(n):\n        dp[i+1] = dp[i] + t[i+1]\n    ans = 0\n    for i in range(p):\n        start, end = s[i], e[i]\n        if start == end:\n            ans = max(ans, dp[start])\n        else:\n            ans = max(ans, dp[start] + dp[end-1])\n    return str(ans)"
    },
    {
        "number": 3120,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    A = stdin.split('\\n')[0]\n    B = stdin.split('\\n')[1]\n\n    # define equivalence function\n    def is_equal(A: str, B: str) -> bool:\n        # define helper function\n        def evaluate(expr: str) -> List[int]:\n            # parse expression\n            if expr[0] == '[':\n                return [int(x) for x in expr[1:-1].split(',')]\n            elif expr[0] == 'c':\n                return evaluate(expr[1:-1].split(',')[0]) + evaluate(expr[1:-1].split(',')[1])\n            elif expr[0] =='s':\n                L = evaluate(expr[1:-1])\n                return random.sample(L, len(L))\n            elif expr[0] == 'o':\n                L = evaluate(expr[1:-1])\n                return sorted(L)\n            else:\n                raise ValueError('Invalid expression')\n\n        # evaluate both programs\n        L1 = evaluate(A)\n        L2 = evaluate(B)\n\n        # check if lists are equal\n        return L1 == L2\n\n    # check if programs are equal\n    if is_equal(A, B):\n        return 'equal'\n    else:\n        return 'not equal'"
    },
    {
        "number": 3121,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split()[0:2])\n    n, m = map(int, stdin.split()[2:4])\n    passages = []\n    for i in range(m):\n        e, b, a, h = map(int, stdin.split()[4*i:4*(i+1)])\n        passages.append((e-1, b-1, a, h))\n    visited = [False] * n\n    def dfs(start, health):\n        if health <= 0:\n            return False\n        if start == n-1:\n            return True\n        visited[start] = True\n        for e, b, a, h in passages:\n            if e == start and not visited[b]:\n                if dfs(b, health-max(0, a-A)):\n                    return True\n        return False\n    if not dfs(0, H):\n        return \"Oh no\"\n    else:\n        return H"
    },
    {
        "number": 3122,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        routes.append((a-1, b-1, c))\n    lounges = [0] * n\n    for a, b, c in routes:\n        if c == 0:\n            continue\n        if lounges[a] == 0 and lounges[b] == 0:\n            lounges[a] = lounges[b] = 1\n        elif lounges[a] == 0 and lounges[b] == 1:\n            lounges[a] = 1\n        elif lounges[a] == 1 and lounges[b] == 0:\n            lounges[b] = 1\n        else:\n            return \"impossible\"\n    return sum(lounges)"
    },
    {
        "number": 3123,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    k = 1\n    while True:\n        if all(a[i] % 2 == 0 for i in range(n)):\n            return str(k)\n        k += 1"
    },
    {
        "number": 3124,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(n):\n        if nums[i] % 2 == 0:\n            continue\n        if i == 0 or nums[i-1] % 2 == 0:\n            count += 1\n        if i == n-1 or nums[i+1] % 2 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3125,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.strip().split('\\n')\n    n = len(input_str)\n    if n == 0:\n        return '<empty>'\n    if '+' not in input_str and '-' not in input_str:\n        return '<any>'\n    if '+' not in output_str and '-' not in output_str:\n        return 'corrupted'\n    a_plus = []\n    a_minus = []\n    for i in range(n):\n        if input_str[i] == '+':\n            a_plus.append(output_str[i])\n        elif input_str[i] == '-':\n            a_minus.append(output_str[i])\n    if len(a_plus) == 0 and len(a_minus) == 0:\n        return 'corrupted'\n    if len(a_plus) == 0:\n        a_plus = ['<empty>']\n    if len(a_minus) == 0:\n        a_minus = ['<empty>']\n    return '\\n'.join([' '.join(a_plus),''.join(a_minus)])"
    },
    {
        "number": 3126,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    p = list(map(int, stdin.readline().split()))\n    c = int(stdin.readline())\n    dp = [float('inf')] * (n+1)\n    dp[0] = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            dp[j] = min(dp[j], dp[i]+j-i)\n    for _ in range(c):\n        op, a = stdin.readline().split()\n        a = int(a)\n        if op == '+':\n            p.append(a)\n            dp.append(float('inf'))\n            for j in range(n+1, len(dp)):\n                dp[j] = min(dp[j], dp[j-1]+j-n)\n        elif op == '-':\n            p.remove(a)\n            dp.pop()\n            for j in range(n, len(dp)):\n                dp[j] = min(dp[j], dp[j-1]+j-n)\n        else:\n            t = a\n    dp[n] = 0\n    for i in range(n):\n        dp[i] = min(dp[i], dp[i+1]+abs(p[i]-p[n]))\n    return str(dp[n])"
    },
    {
        "number": 3127,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cables = []\n    for i in range(m):\n        a, b, l = map(int, stdin.split()[0:3])\n        cables.append((a, b, l))\n    unused = set(range(1, n+1))\n    for c in cables:\n        unused.discard(c[0])\n        unused.discard(c[1])\n    return str(len(unused)) + '\\n' +''.join(map(str, sorted(unused)))"
    },
    {
        "number": 3128,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    movies = [0] * (n+1)\n    for i in range(n):\n        q, x = map(int, stdin.readline().strip().split())\n        if q == 1:\n            movies[x] = i+1\n        else:\n            print(movies[x])\n    return \"\""
    },
    {
        "number": 3129,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input string to list of characters\n    haybales = list(stdin)\n    # Initialize variables\n    operations = 0\n    i = 0\n    # Loop through the list of haybales\n    while i < len(haybales):\n        # Check if the current haybale is infected\n        if haybales[i] == 'P':\n            # Check if the next two haybales are clean\n            if i+1 < len(haybales) and haybales[i+1] == 'C' and i+2 < len(haybales) and haybales[i+2] == 'C':\n                # Move the infected haybale to the back of the sequence\n                haybales[i], haybales[len(haybales)-1] = haybales[len(haybales)-1], haybales[i]\n                # Increment the number of operations\n                operations += 1\n                # Move the pointer to the next haybale\n                i += 1\n            else:\n                # Move the pointer to the next haybale\n                i += 1\n        else:\n            # Move the pointer to the next haybale\n            i += 1\n    # Return the number of operations\n    return str(operations)"
    },
    {
        "number": 3130,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    D, M, N = map(int, stdin.split())\n    implications = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:1+M]]\n    evidence = set(map(int, stdin.split('\\n')[-N:]))\n\n    # build knowledge base\n    knowledge_base = {}\n    for a, b in implications:\n        knowledge_base.setdefault(a, set()).add(b)\n\n    # find all events that have certainly occurred\n    events = set()\n    for event in evidence:\n        events.add(event)\n        for cause in knowledge_base.get(event, set()):\n            events.add(cause)\n\n    # output result\n    return''.join(map(str, sorted(events)))"
    },
    {
        "number": 3131,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    a.sort(reverse=True)\n    return sum(a[:K]) % 1000000007"
    },
    {
        "number": 3132,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    buildings = []\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                buildings.append((i, j))\n    for i, j in buildings:\n        for di in range(-1, 2):\n            for dj in range(-1, 2):\n                if di == dj == 0:\n                    continue\n                if 0 <= i+di < R and 0 <= j+dj < C and grid[i+di][j+dj] == 'x':\n                    building = [(i, j), (i+di, j+dj)]\n                    building.sort()\n                    size = max(abs(building[1][0]-building[0][0]), abs(building[1][1]-building[0][1])) + 1\n                    print(building[0][0], building[0][1], size)\n                    return\n    print(-1, -1, -1)"
    },
    {
        "number": 3133,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    left = [int(x) for x in stdin.split()]\n    right = [int(x) for x in stdin.split()]\n    tower = [int(x) for x in stdin.split()]\n    if left[a] == right[a] or left[b] == right[b]:\n        return \"indistinguishable\"\n    if tower[a] == 1 and tower[b] == 0:\n        return \"Alice\"\n    if tower[a] == 0 and tower[b] == 1:\n        return \"Bob\"\n    if tower[a] == 1 and tower[b] == 1:\n        return \"Alice\" if left[a] < left[b] else \"Bob\"\n    if tower[a] == 0 and tower[b] == 0:\n        return \"Alice\" if left[a] < left[b] else \"Bob\""
    },
    {
        "number": 3134,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = stdin.strip().split('\\n')\n    R = [int(x) for x in R]\n    C = [int(x) for x in C]\n    n = len(R)\n    m = len(C)\n    if n!= m:\n        return '-1'\n    ones = sum(R)\n    if ones > n * m // 2:\n        return '-1'\n    ones_matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if R[i] ^ C[j]:\n                ones_matrix[i][j] = 1\n    ones_count = sum(sum(row) for row in ones_matrix)\n    if ones_count!= ones:\n        return '-1'\n    row_parity = [0] * n\n    col_parity = [0] * m\n    for i in range(n):\n        row_parity[i] = R[i]\n        for j in range(m):\n            col_parity[j] ^= ones_matrix[i][j]\n    for i in range(n):\n        if row_parity[i] == 1:\n            ones_matrix[i] = [1] * m\n        else:\n            ones_matrix[i] = [0] * m\n    for j in range(m):\n        if col_parity[j] == 1:\n            for i in range(n):\n                ones_matrix[i][j] = 1 - ones_matrix[i][j]\n    return '\\n'.join(''.join(str(x) for x in row) for row in ones_matrix)"
    },
    {
        "number": 3135,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"+0\"\n    if n == 1:\n        return \"-0\"\n    if n == -1:\n        return \"+0\"\n    if n > 0:\n        binary = bin(n)[2:]\n        if binary[0] == '1':\n            binary = '0' + binary\n        return '+' + binary\n    else:\n        binary = bin(abs(n))[2:]\n        if binary[0] == '1':\n            binary = '0' + binary\n        return '-' + binary"
    },
    {
        "number": 3136,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[0:4])\n    a, b = map(int, stdin.split()[4:6])\n    x = list(map(int, stdin.split()[6:6+s]))\n    y = list(map(int, stdin.split()[6+s:]))\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v, d = map(int, stdin.split()[i*3:i*3+3])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    dist = [float('inf')] * (n+1)\n    dist[a] = 0\n    visited = [False] * (n+1)\n    for i in range(n):\n        min_dist = float('inf')\n        min_node = -1\n        for j in range(1, n+1):\n            if not visited[j] and dist[j] < min_dist:\n                min_dist = dist[j]\n                min_node = j\n        visited[min_node] = True\n        for j in graph[min_node]:\n            if not visited[j[0]] and dist[min_node] + j[1] < dist[j[0]]:\n                dist[j[0]] = dist[min_node] + j[1]\n    ans = float('inf')\n    for i in range(t):\n        ans = min(ans, dist[x[i%s]] + dist[y[i%t]])\n    return str(ans)"
    },
    {
        "number": 3137,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, k = map(int, stdin.readline().split())\n    x, y = map(int, stdin.readline().split())\n    bacteria = []\n    for i in range(k):\n        x_i, y_i, c_i = map(int, stdin.readline().split())\n        bacteria.append((x_i, y_i, c_i, [list(map(int, stdin.readline().split())) for _ in range(n)]))\n\n    # simulate game\n    directions = {'U': (-1, 0), 'R': (0, 1), 'D': (1, 0), 'L': (0, -1)}\n    board = [[0] * m for _ in range(n)]\n    for b in bacteria:\n        x, y, c, num = b\n        board[x][y] = num[0][0]\n        for _ in range(num[0][0]):\n            c = directions[c][0] * -1 + directions[c][1] * -1\n        for _ in range(num[0][0]):\n            c = directions[c][0] * -1 + directions[c][1] * -1\n        if x + directions[c][0] < 0 or x + directions[c][0] >= n or y + directions[c][1] < 0 or y + directions[c][1] >= m:\n            c = directions[c][0] * -1 + directions[c][1] * -1\n        x += directions[c][0]\n        y += directions[c][1]\n        board[x][y] = num[0][0]\n        if x == x_ and y == y_:\n            return -1\n\n    # count seconds\n    seconds = 0\n    while True:\n        seconds += 1\n        new_board = [[0] * m for _ in range(n)]\n        for x in range(n):\n            for y in range(m):\n                num = board[x][y]\n                if num == 0:\n                    continue\n                for _ in range(num):\n                    c = directions[board[x][y]][0] * -1 + directions[board[x][y]][1] * -1\n                for _ in range(num):\n                    c = directions[c][0] * -1 + directions[c][1] * -1\n                if x + directions[c][0] < 0 or x + directions[c][0] >= n or y + directions[c][1] < 0 or y + directions[c][1] >= m:\n                    c = directions[c][0] * -1 + directions[c][1] * -1\n                x += directions[c][0]\n                y += directions[c][1]\n                new_board[x][y] = num\n                if x == x_ and y == y_:\n                    return seconds\n        board = new_board"
    },
    {
        "number": 3138,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n-1):\n        for j in range(i+2, n):\n            if sum(arr[i:j+1]) == arr[i]*arr[j]:\n                count += 1\n    return count"
    },
    {
        "number": 3139,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    students = []\n    for i in range(1, n+1):\n        line = lines[i]\n        if line.startswith('D '):\n            a, b = map(int, line.split()[1:])\n            students.append((a, b))\n        elif line.startswith('P '):\n            i = int(line.split()[1])\n            help_student = None\n            min_diff = float('inf')\n            for j, (a, b) in enumerate(students):\n                if a >= students[i-1][0] and b >= students[i-1][1]:\n                    diff = abs(students[i-1][1] - b) + abs(students[i-1][0] - a)\n                    if diff < min_diff:\n                        min_diff = diff\n                        help_student = j+1\n            if help_student is None:\n                print('NE')\n            else:\n                print(help_student)\n    return ''"
    },
    {
        "number": 3140,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    r, c, k, l = map(int, stdin.readline().split())\n    x0, y0 = map(int, stdin.readline().split())\n    times = []\n    for i in range(r):\n        times.append(list(map(int, stdin.readline().split())))\n\n    # initialize variables\n    visited = set()\n    queue = [(x0, y0, 1)]\n\n    # bfs\n    while queue:\n        x, y, time = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if time > l:\n            continue\n        if time == l:\n            return len(visited)\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < r and 0 <= ny < c and (nx, ny) not in visited:\n                queue.append((nx, ny, time + 1))\n\n    return len(visited)"
    },
    {
        "number": 3141,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    flaws = []\n    for line in stdin.split('\\n')[1:]:\n        x, y, z = map(float, line.split())\n        flaws.append((x, y, z))\n\n    # find the bounding box of the flaws\n    x_min, x_max = min(x for x, _, _ in flaws), max(x for x, _, _ in flaws)\n    y_min, y_max = min(y for _, y, _ in flaws), max(y for _, y, _ in flaws)\n    z_min, z_max = min(z for _, _, z in flaws), max(z for _, _, z in flaws)\n\n    # find the diameter of the smallest drill bit that can remove all the flaws\n    diameter = 0\n    for x in range(int(x_min), int(x_max) + 1):\n        for y in range(int(y_min), int(y_max) + 1):\n            for z in range(int(z_min), int(z_max) + 1):\n                if all(distance((x, y, z), flaw) > diameter for flaw in flaws):\n                    diameter = max(diameter, distance((x, y, z), (x_min, y_min, z_min)))\n                    diameter = max(diameter, distance((x, y, z), (x_min, y_min, z_max)))\n                    diameter = max(diameter, distance((x, y, z), (x_min, y_max, z_min)))\n                    diameter = max(diameter, distance((x, y, z), (x_min, y_max, z_max)))\n                    diameter = max(diameter, distance((x, y, z), (x_max, y_min, z_min)))\n                    diameter = max(diameter, distance((x, y, z), (x_max, y_min, z_max)))\n                    diameter = max(diameter, distance((x, y, z), (x_max, y_max, z_min)))\n                    diameter = max(diameter, distance((x, y, z), (x_max, y_max, z_max)))\n\n    return f'{diameter:.10f}'\n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    smallest = None\n    for num in range(A, B+1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            if smallest is None or num < smallest:\n                smallest = num\n    return f\"{count}\\n{smallest}\""
    },
    {
        "number": 3143,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+m]))\n    b = list(map(int, stdin.split()[2+m:]))\n\n    # initialize variables\n    k = 0\n    positions = b.copy()\n\n    # loop through the list\n    for i in range(m):\n        # find the position of the current student\n        j = b.index(a[i])\n\n        # if the current student is not at the front of the line,\n        # move him or her to the front of the line\n        if j!= 0:\n            # move the current student to the front of the line\n            positions[0], positions[j] = positions[j], positions[0]\n\n            # increment the number of inspections\n            k += 1\n\n            # ask the student to go to the back of the line\n            positions[0] = b[i]\n\n    # output the number of inspections and the final positions of the students\n    return f\"{k}\\n{' '.join(map(str, positions))}\""
    },
    {
        "number": 3144,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    dp = [0] * (n+1)\n    dp[0] = d\n    dp[1] = g\n    for i in range(2, n+1):\n        if i <= k:\n            dp[i] = max(dp[i-1], dp[i-2])\n        else:\n            dp[i] = max(dp[i-1], dp[i-2] - 1)\n    return str(dp[n])"
    },
    {
        "number": 3145,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split())\n    allowed_digits = set(stdin.split()[1])\n    count = 0\n    for i in range(A, B+1):\n        if set(str(i)) <= allowed_digits and i % X == 0:\n            count += 1\n    return count"
    },
    {
        "number": 3146,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[0:2])\n    prescriptions = []\n    for i in range(n):\n        d, t, k = map(int, stdin.split()[0:3])\n        prescriptions.append((d, t, k))\n    prescriptions.sort()\n    in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n    remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n    in_store_time = 0\n    remote_time = 0\n    in_store_count = 0\n    remote_count = 0\n    for p in prescriptions:\n        if p[1] == 'S':\n            in_store_time += p[2]\n            in_store_count += 1\n        else:\n            remote_time += p[2]\n            remote_count += 1\n        if in_store_count > 0 and remote_count > 0:\n            break\n    if in_store_count == 0:\n        in_store_time = 0\n    if remote_count == 0:\n        remote_time = 0\n    return f\"{in_store_time/in_store_count:.6f} {remote_time/remote_count:.6f}\""
    },
    {
        "number": 3147,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    memory = []\n    for i in range(R):\n        memory.append(list(stdin.readline().strip()))\n    killers = []\n    for i in range(R):\n        for j in range(C):\n            if memory[i][j] == '1':\n                killer = []\n                for k in range(i, R):\n                    for l in range(j, C):\n                        if memory[k][l] == '1':\n                            killer.append((k-i+1, l-j+1))\n                        else:\n                            break\n                    else:\n                        continue\n                    break\n                killers.append(killer)\n    if not killers:\n        return '-1'\n    max_killer = max(killers, key=lambda x: x[0]*x[1])\n    return str(max_killer[0]*max_killer[1])"
    },
    {
        "number": 3148,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    swimmers = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        swimmers.append((x, y))\n    swimmers.sort(key=lambda x: (abs(x[0]) + abs(x[1]), x[0] + x[1]))\n    mid = n // 2\n    if n % 2 == 0:\n        left = swimmers[:mid]\n        right = swimmers[mid:]\n    else:\n        left = swimmers[:mid]\n        right = swimmers[mid+1:]\n    left_x = sum(x for x, y in left) / len(left)\n    left_y = sum(y for x, y in left) / len(left)\n    right_x = sum(x for x, y in right) / len(right)\n    right_y = sum(y for x, y in right) / len(right)\n    return f\"{left_x} {left_y}\\n{right_x} {right_y}\""
    },
    {
        "number": 3149,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v0, theta, w = map(float, stdin.split()[0:5])\n    vertices = []\n    for i in range(int(n)):\n        x, y = map(float, stdin.readline().split())\n        vertices.append((x, y))\n    theta = theta * math.pi / 180\n    g = 9.81\n    t = 0\n    x, y, vx, vy = 0, 0, v0 * math.cos(theta), v0 * math.sin(theta)\n    for i in range(int(n)):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i+1)%n]\n        a = (y2 - y1) / (x2 - x1)\n        b = y1 - a * x1\n        c = -a * w + b\n        if c > 0:\n            t = -b / (2 * a)\n            x = x1 + t * (x2 - x1)\n            y = y1 + t * (y2 - y1)\n            break\n    else:\n        t = float('inf')\n        x, y = float('inf'), float('inf')\n    return f\"{i+1} {t:.6f}\""
    },
    {
        "number": 3150,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    trenches = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        trenches.append(((x1, y1), (x2, y2)))\n\n    # count number of ways to place guards\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                # check if trenches i, j, k form a triangle\n                if (trenches[i][0][0]-trenches[j][0][0])*(trenches[k][1][1]-trenches[j][0][1]) == (trenches[i][1][0]-trenches[j][0][0])*(trenches[k][0][1]-trenches[j][0][1]):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3151,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(int(n**0.5)+1):\n        k = n - m**2\n        if k >= 0 and k**0.5 == int(k**0.5):\n            return f\"{m} {k}\"\n    return \"impossible\""
    },
    {
        "number": 3152,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    arr = [int(line.strip()) for line in stdin]\n\n    # calculate min, max, and length of array\n    min_val = min(arr)\n    max_val = max(arr)\n    arr_len = len(arr)\n\n    # calculate cost of array\n    cost = min_val * max_val * arr_len\n\n    # calculate average price of subsequences\n    subseq_len = 1\n    subseq_cost = 0\n    while subseq_len <= arr_len:\n        for i in range(arr_len - subseq_len + 1):\n            subseq_cost += arr[i] * arr[i+subseq_len-1]\n        subseq_len += 1\n    avg_price = subseq_cost // (arr_len * (arr_len+1) // 2)\n\n    # calculate last 9 digits of sum of prices\n    sum_prices = cost + avg_price * (arr_len * (arr_len+1) // 2)\n    last_9_digits = str(sum_prices)[-9:]\n\n    return last_9_digits"
    },
    {
        "number": 3153,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split()[0:2])\n    cards = list(map(int, stdin.split()[2:2+n]))\n    purchases = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[2+n+2*i:2+n+2*i+2])\n        purchases.append((a, b))\n\n    # initialize variables\n    total_purchases = 0\n    children = {i: 0 for i in range(1, n+1)}\n    races = []\n\n    # simulate purchases\n    for a, b in purchases:\n        total_purchases += 1\n        children[a] += 1\n        children[b] += 1\n        if children[a] == 2:\n            races.append((a, 2))\n        if children[b] == 2:\n            races.append((b, 2))\n        if children[a] == 1 and children[b] == 1:\n            races.append((a, 1))\n            races.append((b, 1))\n\n    # output results\n    print(total_purchases)\n    for a, b in races:\n        print(a, b, children[a])\n\n    return \"\""
    },
    {
        "number": 3154,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    d, e = map(int, stdin.split()[2:4])\n    events = []\n    for i in range(e):\n        s, k, t = map(int, stdin.split()[4*i:4*(i+1)])\n        events.append((s, k, t))\n    events.sort()\n    toys = [[] for _ in range(n)]\n    for s, k, t in events:\n        if t == 0:\n            toys[k-1] = []\n        else:\n            toys[k-1].append(t)\n    for i in range(n):\n        toys[i].sort()\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i] == toys[j]:\n                return \"impossible\"\n    for i in range(n):\n        if len(toys[i]) == 0:\n            return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] < toys[j][-1]:\n                return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] > toys[j][-1]:\n                if toys[i][-1] in toys[j]:\n                    return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] < toys[j][-2]:\n                    return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] > toys[j][-2]:\n                    return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    if toys[i][-3] == toys[j][-3]:\n                        return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    if toys[i][-3] < toys[j][-3]:\n                        return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    if toys[i][-3] > toys[j][-3]:\n                        return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    if toys[i][-3] == toys[j][-3]:\n                        if toys[i][-4] == toys[j][-4]:\n                            return \"impossible\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if toys[i][-1] == toys[j][-1]:\n                if toys[i][-2] == toys[j][-2]:\n                    if toys[i][-3] == toys[j][-3]:\n                        if toys[i][-4] < toys[j][-4]:\n                            return \"impossible\"\n    for i in"
    },
    {
        "number": 3155,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 1\n    k = 1\n    while True:\n        if n * (n - 1) // 2 + k * (k - 1) // 2 == X:\n            return f\"{n} {k}\"\n        elif n * (n - 1) // 2 + k * (k - 1) // 2 < X:\n            n += 1\n        else:\n            k += 1"
    },
    {
        "number": 3156,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    K = int(lines[1])\n    stores = [[] for _ in range(N)]\n    for i in range(2, 2+K):\n        store_id, item = lines[i].strip().split()\n        stores[int(store_id)].append(item)\n    M = int(lines[2+K])\n    items = lines[3+K:]\n\n    # build graph\n    graph = {}\n    for i in range(N):\n        for item in stores[i]:\n            if item not in graph:\n                graph[item] = set()\n            graph[item].add(i)\n\n    # find paths\n    paths = []\n    for i in range(M):\n        item = items[i]\n        if item not in graph:\n            return \"impossible\"\n        for store in graph[item]:\n            if store == 0:\n                continue\n            path = [store]\n            for j in range(i-1, -1, -1):\n                prev_item = items[j]\n                if prev_item not in graph:\n                    return \"impossible\"\n                prev_stores = graph[prev_item]\n                if len(prev_stores)!= 1:\n                    return \"ambiguous\"\n                prev_store = prev_stores.pop()\n                if prev_store not in path:\n                    return \"ambiguous\"\n                path.append(prev_store)\n            paths.append(path)\n\n    # check paths\n    if len(paths) == 0:\n        return \"unique\"\n    if len(paths) == 1:\n        return \"unique\"\n    return \"ambiguous\""
    },
    {
        "number": 3157,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    MOD = 2**m\n    def f(word):\n        if not word:\n            return 0\n        return ((f(word[:-1]) * 33) ^ ord(word[-1])) % MOD\n    count = 0\n    for i in range(2**n):\n        word = bin(i)[2:].zfill(n)\n        if f(word) == k:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3158,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    img1 = lines[0].strip()\n    img2 = lines[1].strip()\n\n    # count touches\n    touches1 = sum(1 for c in img1 if c == 'X')\n    touches2 = sum(1 for c in img2 if c == 'X')\n\n    # check if pan\n    if touches1 == touches2:\n        return f'{touches1} pan'\n\n    # find grip points\n    grip1 = [0, 0]\n    grip2 = [0, 0]\n    for i, c in enumerate(img1):\n        if c == 'X':\n            grip1[0] += i\n            grip1[1] += img1.count('X', i)\n    grip1[0] /= touches1\n    grip1[1] /= touches1\n    for i, c in enumerate(img2):\n        if c == 'X':\n            grip2[0] += i\n            grip2[1] += img2.count('X', i)\n    grip2[0] /= touches2\n    grip2[1] /= touches2\n\n    # find touch vectors\n    touch_vectors1 = []\n    touch_vectors2 = []\n    for i, c in enumerate(img1):\n        if c == 'X':\n            x = i - grip1[0]\n            y = img1.count('X', i) - grip1[1]\n            touch_vectors1.append((x, y))\n    for i, c in enumerate(img2):\n        if c == 'X':\n            x = i - grip2[0]\n            y = img2.count('X', i) - grip2[1]\n            touch_vectors2.append((x, y))\n\n    # find grip rotation\n    grip_rotation = 0\n    for i in range(touches1):\n        j = i\n        while j < touches1 and touch_vectors1[i] == touch_vectors1[j]:\n            j += 1\n        if j < touches1:\n            x1, y1 = touch_vectors1[i]\n            x2, y2 = touch_vectors1[j]\n            grip_rotation += math.atan2(y2 - y1, x2 - x1)\n    grip_rotation /= touches1\n\n    # find rotation distance\n    rotation_distance = abs(grip_rotation) * grip1[0]\n\n    # find zoom distance\n    zoom_distance = abs(grip1[0] - grip2[0])\n\n    # check if zoom\n    if zoom_distance > grip1[0]:\n        return f'{touches1} zoom out'\n    else:\n        return f'{touches1} zoom in'\n\n    # check if rotate\n    if rotation_distance > grip1[0]:\n        return f'{touches1} rotate clockwise'\n    else:\n        return f'{touches1} rotate counter-clockwise'"
    },
    {
        "number": 3159,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    H, W = map(int, lines[0].split())\n    lines = lines[1:]\n    # Initialize ad flag\n    ad_flag = False\n    # Initialize ad list\n    ad_list = []\n    # Initialize image list\n    image_list = []\n    # Initialize image flag\n    image_flag = False\n    # Initialize image border\n    image_border = []\n    # Initialize image border flag\n    image_border_flag = False\n    # Initialize image border count\n    image_border_count = 0\n    # Initialize image border index\n    image_border_index = 0\n    # Initialize image border character\n    image_border_char = ''\n    # Initialize image border character count\n    image_border_char_count = 0\n    # Initialize image border character index\n    image_border_char_index = 0\n    # Initialize image border character list\n    image_border_char_list = []\n    # Initialize image border character list index\n    image_border_char_list_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_max = 0\n    # Initialize image border character list count\n    image_border_char_list_count_min = 0\n    # Initialize image border character list count\n    image_border_char_list_count_sum = 0\n    # Initialize image border character list count\n    image_border_char_list_count_avg = 0\n    # Initialize image border character list count\n    image_border_char_list_count_std = 0\n    # Initialize image border character list count\n    image_border_char_list_count_var = 0\n    # Initialize image border character list count\n    image_border_char_list_count_max_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_min_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_sum_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_avg_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_std_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_var_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_max_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_min_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_sum_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_avg_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_std_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_var_char = ''\n    # Initialize image border character list count\n    image_border_char_list_count_max_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_min_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_sum_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_avg_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_std_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_var_char_index = 0\n    # Initialize image border character list count\n    image_border_char_list_count_max_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_min_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_sum_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_avg_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_std_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_var_char_count = 0\n    # Initialize image border character list count\n    image_border_char_list_count_max_char_count_"
    },
    {
        "number": 3160,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    S = stdin.strip()\n    n = len(S)\n    # count number of unknown states\n    num_unknown = S.count('?')\n    # calculate average value of L(C)\n    total_L = 0\n    for i in range(n):\n        if S[i] == '?':\n            total_L += 1\n        elif S[i] == 'H':\n            total_L += n - i - 1\n    avg_L = total_L / (n - num_unknown)\n    return str(avg_L)"
    },
    {
        "number": 3161,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    target = []\n    for i in range(n):\n        target.append(list(map(int, stdin.readline().strip())))\n\n    def paint(x, y, color):\n        if x == 0 and y == 0:\n            return color\n        if x == 0:\n            return paint(1, y-1, color)\n        if y == 0:\n            return paint(x-1, 1, color)\n        if x == 1:\n            return paint(0, y-1, color)\n        if y == 1:\n            return paint(x-1, 0, color)\n        if x == 2:\n            return paint(1, y-1, color)\n        if y == 2:\n            return paint(x-1, 1, color)\n        if x == 3:\n            return paint(2, y-1, color)\n        if y == 3:\n            return paint(x-1, 2, color)\n        if x == 4:\n            return paint(3, y-1, color)\n        if y == 4:\n            return paint(x-1, 3, color)\n        if x == 5:\n            return paint(4, y-1, color)\n        if y == 5:\n            return paint(x-1, 4, color)\n        if x == 6:\n            return paint(5, y-1, color)\n        if y == 6:\n            return paint(x-1, 5, color)\n        if x == 7:\n            return paint(6, y-1, color)\n        if y == 7:\n            return paint(x-1, 6, color)\n        if x == 8:\n            return paint(7, y-1, color)\n        if y == 8:\n            return paint(x-1, 7, color)\n        if x == 9:\n            return paint(8, y-1, color)\n        if y == 9:\n            return paint(x-1, 8, color)\n        if x == 10:\n            return paint(9, y-1, color)\n        if y == 10:\n            return paint(x-1, 9, color)\n        if x == 11:\n            return paint(10, y-1, color)\n        if y == 11:\n            return paint(x-1, 10, color)\n        if x == 12:\n            return paint(11, y-1, color)\n        if y == 12:\n            return paint(x-1, 11, color)\n        if x == 13:\n            return paint(12, y-1, color)\n        if y == 13:\n            return paint(x-1, 12, color)\n        if x == 14:\n            return paint(13, y-1, color)\n        if y == 14:\n            return paint(x-1, 13, color)\n        if x == 15:\n            return paint(14, y-1, color)\n        if y == 15:\n            return paint(x-1, 14, color)\n        if x == 16:\n            return paint(15, y-1, color)\n        if y == 16:\n            return paint(x-1, 15, color)\n        if x == 17:\n            return paint(16, y-1, color)\n        if y == 17:\n            return paint(x-1, 16, color)\n        if x == 18:\n            return paint(17, y-1, color)\n        if y == 18:\n            return paint(x-1, 17, color)\n        if x == 19:\n            return paint(18, y-1, color)\n        if y == 19:\n            return paint(x-1, 18, color)\n        if x == 20:\n            return paint(19, y-1, color)\n        if y == 20:\n            return paint(x-1, 19, color)\n        if x == 21:\n            return paint(20, y-1, color)\n        if y == 21:\n            return paint(x-1, 20, color)\n        if x == 22:\n            return paint(21, y-1, color)\n        if y == 22:\n            return paint(x-1, 21, color)\n        if x == 23:\n            return paint("
    },
    {
        "number": 3162,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    wires = [[] for _ in range(200001)]\n    for i in range(n):\n        direction, start, length, wire = stdin.readline().strip().split()\n        start, length, wire = int(start), int(length), int(wire)\n        wires[wire].append((direction, start, length))\n    max_wire = max(len(wires[i]) for i in range(1, 200001))\n    activated = [0] * (max_wire + 1)\n    for i in range(1, 200001):\n        for j in range(len(wires[i])):\n            direction, start, length = wires[i][j]\n            if direction == 'h':\n                for k in range(start, start + length):\n                    activated[j] += 1 if k % 2 == 1 else 0\n            else:\n                for k in range(start, start + length):\n                    activated[j] += 1 if k % 2 == 0 else 0\n    return str(activated[-1])"
    },
    {
        "number": 3163,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, M = map(int, stdin.split())\n    initial_state = []\n    for i in range(N):\n        initial_state.append(list(map(int, stdin.split())))\n    final_state = []\n    for i in range(N):\n        final_state.append(list(map(int, stdin.split())))\n\n    # Check if it's possible to arrange the books\n    for i in range(N):\n        for j in range(M):\n            if initial_state[i][j]!= final_state[i][j]:\n                if initial_state[i][j] == 0:\n                    # Move book to the left or right\n                    if j > 0 and initial_state[i][j-1] == 0:\n                        initial_state[i][j-1] = initial_state[i][j]\n                        initial_state[i][j] = 0\n                    elif j < M-1 and initial_state[i][j+1] == 0:\n                        initial_state[i][j+1] = initial_state[i][j]\n                        initial_state[i][j] = 0\n                    else:\n                        return \"-1\"\n                else:\n                    # Take book from the shelf\n                    for k in range(N):\n                        if final_state[k][j] == 0:\n                            final_state[k][j] = initial_state[i][j]\n                            initial_state[i][j] = 0\n                            break\n                    else:\n                        return \"-1\"\n\n    # Count the number of lifts\n    lifts = 0\n    for i in range(N):\n        for j in range(M):\n            if initial_state[i][j]!= final_state[i][j]:\n                lifts += 1\n\n    return str(lifts)"
    },
    {
        "number": 3164,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    # use sliding window to find longest consecutive sub-array\n    left = 0\n    right = 0\n    max_len = 0\n    while right < n:\n        # expand window\n        while right < n and arr[right] % 2 == 0:\n            right += 1\n        # shrink window\n        while left < n and arr[left] % 2 == 1:\n            left += 1\n        # update max length\n        max_len = max(max_len, right - left)\n        # move right pointer\n        right += 1\n\n    return max_len"
    },
    {
        "number": 3165,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K, P = map(int, stdin.split())\n    rooks = []\n    for _ in range(K):\n        R, C, X = map(int, stdin.split())\n        rooks.append((R-1, C-1, X))\n\n    # simulate moves\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, stdin.split())\n        R1, C1, R2, C2 = R1-1, C1-1, R2-1, C2-1\n        for i in range(K):\n            if rooks[i][0] == R1 and rooks[i][1] == C1:\n                rooks[i] = (R2, C2, rooks[i][2])\n\n    # count attacked fields\n    attacked = [0] * N * N\n    for r, c, x in rooks:\n        for i in range(N):\n            for j in range(N):\n                if (i == r or j == c) and (i!= r or j!= c):\n                    attacked[i*N+j] ^= x\n\n    # output result\n    result = []\n    for i in range(P):\n        result.append(str(attacked.count(1)))\n    return '\\n'.join(result)"
    },
    {
        "number": 3166,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = []\n    for i in range(n):\n        matrix.append(list(map(int, stdin.split())))\n    disqualified = list(map(int, stdin.split()))\n    for i in range(k):\n        if disqualified[i] in disqualified[:i]:\n            return \"impossible\"\n    for i in range(k):\n        for j in range(i+1, k):\n            if disqualified[i] in matrix[disqualified[j]]:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(i+1, k):\n            if disqualified[j] in matrix[disqualified[i]]:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 0 and matrix[disqualified[j]][disqualified[i]] == 0:\n                return \"impossible\"\n    for i in range(k):\n        for j in range(k):\n            if matrix[disqualified[i]][disqualified[j]] == 1 and matrix[disqualified[j]][disqualified[i]] == 1:\n                return \""
    },
    {
        "number": 3167,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    X = list(map(int, stdin.split()[2:]))\n    Q = int(stdin.split()[K+2])\n    L = []\n    R = []\n    for i in range(Q):\n        l, r = map(int, stdin.split()[K+3+2*i:K+3+2*i+2])\n        L.append(l)\n        R.append(r)\n    seq = [0] * N\n    for i in range(K):\n        something(X[i])\n    ans = []\n    for i in range(Q):\n        ans.append(sum(seq[L[i]:R[i]+1]))\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3168,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    nums = [int(line.strip()) for line in stdin]\n\n    # create binary search tree\n    root = None\n    for num in nums:\n        root = insert(root, num)\n\n    # traverse tree and count depth\n    depth = 0\n    def traverse(node):\n        nonlocal depth\n        if node is None:\n            return\n        traverse(node.left)\n        depth += 1\n        traverse(node.right)\n    traverse(root)\n\n    # output depths\n    return '\\n'.join(str(depth) for _ in range(n))\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sticks = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        sticks.append(((x1, y1), (x2, y2)))\n    sticks.sort(key=lambda x: x[0][0])\n    result = []\n    for stick in sticks:\n        x1, y1 = stick[0]\n        x2, y2 = stick[1]\n        if x1 == x2:\n            result.append(str(x1))\n        else:\n            result.append(str(x1) + \" \" + str(x2))\n    return \" \".join(result)"
    },
    {
        "number": 3170,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    deck.reverse()\n    theta_cards = deck[:10]\n    friend_cards = deck[10:]\n    theta_score = 0\n    friend_score = 0\n    for i in range(10):\n        if theta_cards[i] == 'A':\n            theta_score += 1\n        elif theta_cards[i] == '2':\n            theta_score += 2\n        elif theta_cards[i] == '3':\n            theta_score += 3\n        elif theta_cards[i] == '4':\n            theta_score += 4\n        elif theta_cards[i] == '5':\n            theta_score += 5\n        elif theta_cards[i] == '6':\n            theta_score += 6\n        elif theta_cards[i] == '7':\n            theta_score += 7\n        elif theta_cards[i] == '8':\n            theta_score += 8\n        elif theta_cards[i] == '9':\n            theta_score += 9\n        elif theta_cards[i] == 'T':\n            theta_score += 10\n        elif theta_cards[i] == 'J':\n            theta_score += 11\n        elif theta_cards[i] == 'Q':\n            theta_score += 12\n        elif theta_cards[i] == 'K':\n            theta_score += 13\n    for i in range(10):\n        if friend_cards[i] == 'A':\n            friend_score += 1\n        elif friend_cards[i] == '2':\n            friend_score += 2\n        elif friend_cards[i] == '3':\n            friend_score += 3\n        elif friend_cards[i] == '4':\n            friend_score += 4\n        elif friend_cards[i] == '5':\n            friend_score += 5\n        elif friend_cards[i] == '6':\n            friend_score += 6\n        elif friend_cards[i] == '7':\n            friend_score += 7\n        elif friend_cards[i] == '8':\n            friend_score += 8\n        elif friend_cards[i] == '9':\n            friend_score += 9\n        elif friend_cards[i] == 'T':\n            friend_score += 10\n        elif friend_cards[i] == 'J':\n            friend_score += 11\n        elif friend_cards[i] == 'Q':\n            friend_score += 12\n        elif friend_cards[i] == 'K':\n            friend_score += 13\n    if theta_score > friend_score:\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3171,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    N, K = map(int, lines[0].split())\n    candidates = [False] * N\n    for i in range(1, K+1):\n        speaker, *tokens = lines[i].split()\n        if tokens[0] == 'truther':\n            candidates[int(tokens[1])-1] = True\n        elif tokens[0] == 'fabulist':\n            candidates[int(tokens[1])-1] = False\n        elif tokens[0] == 'charlatan':\n            candidates[int(tokens[1])-1] = True\n        elif tokens[0] == 'not':\n            candidates[int(tokens[1])-1] = not candidates[int(tokens[2])-1]\n        elif tokens[0] == 'and':\n            candidates[int(tokens[1])-1] = candidates[int(tokens[2])-1] and candidates[int(tokens[3])-1]\n        elif tokens[0] == 'xor':\n            candidates[int(tokens[1])-1] = (candidates[int(tokens[2])-1] and not candidates[int(tokens[3])-1]) or (not candidates[int(tokens[2])-1] and candidates[int(tokens[3])-1])\n    return '\\n'.join(['charlatan' if c else 'fabulist' if not c else 'truther' for c in candidates])"
    },
    {
        "number": 3172,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fruits = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        fruits.append((x, y))\n    max_slices = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(fruits[i][0] - fruits[j][0]) + abs(fruits[i][1] - fruits[j][1]) <= 2:\n                max_slices += 1\n    return str(max_slices)"
    },
    {
        "number": 3173,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    grid = []\n    for i in range(R):\n        row = list(stdin.readline().strip())\n        grid.append(row)\n    scores = list(map(int, stdin.split()))\n    belts = [[None for _ in range(C)] for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'R':\n                belts[i][j] = 'R'\n            elif grid[i][j] == 'L':\n                belts[i][j] = 'L'\n            elif grid[i][j] == '?':\n                belts[i][j] = ['R', 'L']\n    dp = [[0 for _ in range(K+1)] for _ in range(R+1)]\n    dp[R][K] = scores[C-1]\n    for i in range(R-1, -1, -1):\n        for j in range(K, -1, -1):\n            if i == R-1:\n                continue\n            if belts[i][C-1] == 'R':\n                dp[i][j] = max(dp[i][j], dp[i+1][j])\n            elif belts[i][C-1] == 'L':\n                dp[i][j] = max(dp[i][j], dp[i+1][j+1])\n            else:\n                dp[i][j] = max(dp[i][j], dp[i+1][j], dp[i+1][j+1])\n            if grid[i][C-1] == 'X':\n                dp[i][j] = 0\n            elif grid[i][C-1] == '.':\n                dp[i][j] += scores[C-1]\n            elif grid[i][C-1] == 'R':\n                dp[i][j] += dp[i+1][j]\n            elif grid[i][C-1] == 'L':\n                dp[i][j] += dp[i+1][j+1]\n            elif grid[i][C-1] == '?':\n                dp[i][j] += max(dp[i+1][j], dp[i+1][j+1])\n            if dp[i][j] > 10**20:\n                return -1\n    return dp[0][0]"
    },
    {
        "number": 3174,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n, k = map(int, lines[0].split())\n    cities = []\n    for i in range(1, n+1):\n        x, y, k = map(int, lines[i].split())\n        cities.append((x, y, k))\n\n    # sort cities by x-coordinate\n    cities.sort(key=lambda c: c[0])\n\n    # compute distances between cities\n    distances = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            dx = cities[j][0] - cities[i][0]\n            dy = cities[j][1] - cities[i][1]\n            distances[i][j] = distances[j][i] = (dx**2 + dy**2) ** 0.5\n\n    # compute county sizes\n    county_sizes = [0] * n\n    for i in range(n):\n        county_sizes[i] = 1\n        for j in range(i+1, n):\n            if distances[i][j] <= D:\n                county_sizes[i] += 1\n                break\n\n    # compute total residents in each county\n    total_residents = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if distances[i][j] <= D:\n                total_residents[i] += cities[j][2]\n\n    # compute minimal D\n    D_min = float('inf')\n    for i in range(n):\n        if total_residents[i] % k == 0:\n            D_min = min(D_min, distances[i][i+1])\n    return f'{D_min:.3f}'"
    },
    {
        "number": 3175,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    lengths.sort(reverse=True)\n    area = 0\n    for i in range(n):\n        area += lengths[i] * (i + 1)\n    return str(area)"
    },
    {
        "number": 3176,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    plants = []\n    for i in range(1, n+1):\n        x, y, f = map(int, lines[i].split())\n        plants.append((x, y, f))\n\n    # initialize variables\n    energy = 0\n    current_plant = 1\n    visited = set()\n    path = []\n\n    # find first jump\n    for i in range(n):\n        if plants[i][2] > 0:\n            energy += k\n            path.append(i+1)\n            visited.add(i+1)\n            break\n\n    # find remaining jumps\n    while current_plant < n:\n        # find next plant\n        next_plant = None\n        for i in range(n):\n            if i+1 not in visited and plants[i][2] > 0:\n                next_plant = i+1\n                break\n        if next_plant is None:\n            break\n\n        # check if jump is allowed\n        x1, y1, f1 = plants[current_plant-1]\n        x2, y2, f2 = plants[next_plant-1]\n        if (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1):\n            # jump is allowed\n            energy += k\n            path.append(next_plant)\n            visited.add(next_plant)\n            current_plant = next_plant\n        else:\n            # jump is not allowed\n            energy += f1\n            current_plant += 1\n\n    # output result\n    print(energy)\n    print(len(path))\n    for p in path:\n        print(p, end=' ')\n    return ''"
    },
    {
        "number": 3177,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split()[0:2])\n    seq = list(map(int, stdin.split()[2:]))\n    allowed = []\n    for i in range(m):\n        a, b = map(int, stdin.split()[i*2+2:i*2+4])\n        allowed.append((a-1, b-1))\n\n    # find cycles\n    cycles = []\n    for i in range(n):\n        if seq[i]!= i+1:\n            continue\n        cycle = [i]\n        j = i\n        while seq[j]!= i+1:\n            j = seq[j]-1\n            cycle.append(j)\n        cycles.append(cycle)\n\n    # find swaps\n    swaps = []\n    for cycle in cycles:\n        for i in range(len(cycle)-1):\n            j = cycle[i]\n            k = cycle[i+1]\n            if (j, k) not in allowed and (k, j) not in allowed:\n                swaps.append((j, k))\n\n    # count swaps\n    count = 0\n    for swap in swaps:\n        j, k = swap\n        if seq[j] > seq[k]:\n            seq[j], seq[k] = seq[k], seq[j]\n            count += 1\n\n    # output result\n    return str(count)"
    },
    {
        "number": 3178,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        adj[a].append(b)\n        adj[b].append(a)\n    dp = [float('inf')] * (1<<n)\n    dp[0] = 0\n    for mask in range(1<<n):\n        for v in range(1, n+1):\n            if mask & (1<<v-1):\n                continue\n            for u in adj[v]:\n                if mask & (1<<u-1):\n                    continue\n                dp[mask|(1<<v-1)] = min(dp[mask|(1<<v-1)], dp[mask]+1)\n    for i in range(1, n+1):\n        if dp[1<<i-1] == float('inf'):\n            return '-1'\n    return dp[-1]"
    },
    {
        "number": 3179,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n    points.append(points[0])\n    min_side = float('inf')\n    for i in range(n):\n        for j in range(i+2, n+1):\n            x1, y1 = points[i]\n            x2, y2 = points[j-1]\n            side = abs(x2-x1)\n            if side < min_side:\n                min_side = side\n    return '{:.2f}'.format(min_side/k)"
    },
    {
        "number": 3180,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    n, k, m = map(int, lines[0].split())\n    board = [[1 for _ in range(n)] for _ in range(n)]\n    for i in range(1, m+1):\n        cmd = lines[i].split()\n        if cmd[0] == 'PAINT':\n            c, x1, y1, x2, y2 = map(int, cmd[1:])\n            for x in range(x1, x2+1):\n                for y in range(y1, y2+1):\n                    board[x][y] = c\n        elif cmd[0] == 'SAVE':\n            pass\n        elif cmd[0] == 'LOAD':\n            pass\n    return '\\n'.join([' '.join(map(str, row)) for row in board])"
    },
    {
        "number": 3181,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return '-1'\n    seq = list(range(1, n+1))\n    for i in range(k):\n        for j in range(n-k+1):\n            if seq[j] < seq[j+1]:\n                seq[j], seq[j+1] = seq[j+1], seq[j]\n    return''.join(map(str, seq))"
    },
    {
        "number": 3182,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                a = points[i][0] - points[j][0]\n                b = points[j][1] - points[k][1]\n                c = points[k][0] - points[i][0]\n                d = points[i][1] - points[j][1]\n                if a*d - b*c == 0 and a**2 + b**2 == c**2:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 3183,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, s, t = map(int, stdin.split()[0:4])\n    edges = []\n    for i in range(m):\n        u, v, c, w = map(int, stdin.split()[0:4])\n        edges.append((u, v, c, w))\n\n    # initialize flow and cost\n    flow = [0] * n\n    cost = 0\n\n    # BFS to find augmenting path\n    queue = [(s, float('inf'))]\n    visited = [False] * n\n    while queue:\n        u, flow_in = queue.pop(0)\n        if u == t:\n            break\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, c, w in edges:\n            if v == u:\n                continue\n            if flow[u] < c and not visited[v]:\n                queue.append((v, min(flow_in, c - flow[u])))\n\n    # update flow and cost\n    if flow[t] == 0:\n        return '0 0'\n    for u, v, c, w in edges:\n        if flow[u] < c:\n            flow[v] += flow[u]\n            cost += flow[u] * w\n\n    return f'{flow[t]} {cost}'"
    },
    {
        "number": 3184,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    walls = list(range(n+1))\n    cameras = []\n    for i in range(k):\n        a, b = map(int, stdin.split())\n        if a > b:\n            a, b = b, a\n        cameras.append((a, b))\n    for i in range(k):\n        for j in range(i+1, k):\n            if cameras[i][0] <= cameras[j][0] <= cameras[i][1] and cameras[j][0] <= cameras[i][1]:\n                return \"impossible\"\n            if cameras[i][0] <= cameras[j][0] <= cameras[i][1] and cameras[j][0] <= cameras[i][1]:\n                return \"impossible\"\n    return len(cameras)"
    },
    {
        "number": 3185,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fact = 1\n    for i in range(1, n+1):\n        fact *= i\n    return str(fact)"
    },
    {
        "number": 3186,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    dp = [[0] * (K+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1, N+1):\n        for j in range(K+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= M:\n                dp[i][j] += dp[i-1][j-M]\n            dp[i][j] %= MOD\n    return dp[N][K]"
    },
    {
        "number": 3187,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n    min_dist = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            if dist <= d:\n                min_dist = min(min_dist, dist)\n    if min_dist == float('inf'):\n        return \"impossible\"\n    return min_dist"
    },
    {
        "number": 3188,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planets = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        planets.append((x, y, z))\n    tunnel_cost = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            tunnel_cost += min(abs(planets[i][0]-planets[j][0]), abs(planets[i][1]-planets[j][1]), abs(planets[i][2]-planets[j][2]))\n    return str(tunnel_cost)"
    },
    {
        "number": 3189,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    photos = []\n    for i in range(m):\n        photo = stdin.readline().strip()\n        on_switches = [int(x) for x in photo[:n]]\n        on_lights = [int(x) for x in photo[n:]]\n        photos.append((on_switches, on_lights))\n\n    # count the number of possible wirings\n    count = 1\n    for i in range(2**n):\n        on_switches = [int(x) for x in bin(i)[2:].zfill(n)]\n        for j in range(2**n):\n            on_lights = [int(x) for x in bin(j)[2:].zfill(n)]\n            consistent = True\n            for on_switch, on_light in zip(on_switches, on_lights):\n                if on_switch and not on_light:\n                    consistent = False\n                    break\n                if on_light and not on_switch:\n                    consistent = False\n                    break\n            if consistent:\n                count = (count * 2) % 1000003\n\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, a = map(int, stdin.splitlines()[0].split())\n    P = int(stdin.splitlines()[1])\n\n    # count number of subsequences with average price >= P\n    count = 0\n    for i in range(N):\n        if sum(a[:i+1]) / i >= P:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3191,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    if p >= r:\n        return str(n)\n    if n % 2 == 0:\n        return str(n // 2)\n    return str(n // 2 + 1)"
    },
    {
        "number": 3192,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    file_names = stdin.readline().strip().split()\n    sections = []\n    for i in range(n):\n        name = file_names[i]\n        k = int(stdin.readline().strip())\n        dependencies = [d.strip() for d in stdin.readline().strip().split(',')]\n        sections.append((name, k, dependencies))\n\n    # find cycles\n    visited = set()\n    def dfs(name):\n        if name in visited:\n            return True\n        visited.add(name)\n        for section in sections:\n            if section[0] == name:\n                for d in section[2]:\n                    if dfs(d):\n                        return True\n        visited.remove(name)\n        return False\n\n    cycles = []\n    for name in file_names:\n        if dfs(name):\n            cycle = []\n            while name not in cycle:\n                cycle.append(name)\n                for section in sections:\n                    if section[0] == name:\n                        name = section[2][0]\n            cycles.append(cycle)\n\n    # find shortest cycle\n    if not cycles:\n        return \"SHIP IT\"\n    shortest_cycle = min(cycles, key=len)\n    return'-> '.join(shortest_cycle)"
    },
    {
        "number": 3193,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression = stdin.split('\\n')[0]\n    p, m = map(int, stdin.split('\\n')[1].split())\n    x = 0\n    while True:\n        remainder = eval(expression.replace('x', str(x))) % m\n        if remainder == p:\n            return str(x)\n        x += 1"
    },
    {
        "number": 3194,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    times = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        times.append((a, b))\n    times.sort()\n    for i in range(n):\n        if times[i][0] + t > times[i][1]:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3195,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    T_g, T_y, T_r = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    observations = []\n    for i in range(n):\n        t, c = map(int, stdin.readline().split())\n        observations.append((t, c))\n    t_q, c_q = map(int, stdin.readline().split())\n\n    # compute probability of lights being c_q at time t_q\n    t_last_g = 0\n    t_last_y = t_last_g + T_g\n    t_last_r = t_last_y + T_y\n    p_g = 1\n    p_y = 0\n    p_r = 0\n    for t, c in observations:\n        if t < t_last_g:\n            continue\n        elif t < t_last_y:\n            p_g *= 1 - (t - t_last_g) / T_g\n            p_y *= 1 - (t - t_last_g) / T_g\n            p_r *= 1 - (t - t_last_g) / T_g\n        elif t < t_last_r:\n            p_g *= 1 - (t - t_last_g) / T_g\n            p_y *= (t - t_last_g) / T_g\n            p_r *= (t - t_last_g) / T_g\n        else:\n            p_g *= 1 - (t - t_last_g) / T_g\n            p_y *= 1 - (t - t_last_g) / T_g\n            p_r *= 1 - (t - t_last_g) / T_g\n        if c == 'green':\n            p_g *= 1\n            p_y *= 0\n            p_r *= 0\n        elif c == 'yellow':\n            p_g *= 0\n            p_y *= 1\n            p_r *= 0\n        elif c =='red':\n            p_g *= 0\n            p_y *= 0\n            p_r *= 1\n        else:\n            raise ValueError('Invalid color')\n        t_last_g += T_g\n        t_last_y += T_y\n        t_last_r += T_r\n    p = p_g if c_q == 'green' else p_y if c_q == 'yellow' else p_r\n    return str(p)"
    },
    {
        "number": 3196,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        adj[a].append(b)\n        adj[b].append(a)\n    visited = [False] * (n+1)\n    def dfs(curr, prev, count):\n        if curr == n:\n            return count\n        visited[curr] = True\n        for next in adj[curr]:\n            if next!= prev and not visited[next]:\n                count = dfs(next, curr, count+1)\n        visited[curr] = False\n        return count\n    count = dfs(1, -1, 1)\n    if count > 10**9:\n        return \"inf\"\n    return str(count)"
    },
    {
        "number": 3197,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    dp = [0] * (k+1)\n    for i in range(n):\n        for j in range(k, 0, -1):\n            if j >= x[i]:\n                dp[j] = max(dp[j], dp[j-x[i]]+1)\n    return dp[k]"
    },
    {
        "number": 3198,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = set(stdin.readline().strip() for _ in range(n))\n    typos = set()\n    for word in words:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in words:\n                typos.add(word)\n                break\n    if not typos:\n        return \"NO TYPOS\"\n    return \"\\n\".join(typos)"
    },
    {
        "number": 3199,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = 0\n    secure = 0\n    super_secure = 0\n    for i in range(1, L+1):\n        for j in range(-A, B+1):\n            if i % 2 == 1 and j % 2 == 1:\n                continue\n            if i == 1 and j == -A:\n                continue\n            if i == L and j == B:\n                continue\n            if (i, j) == (0, -A) or (i, j) == (0, B):\n                continue\n            if (i, j) == (1, -A) or (i, j) == (L, B):\n                continue\n            if (i, j) == (2, -A) or (i, j) == (L-1, B):\n                continue\n            if (i, j) == (3, -A) or (i, j) == (L-2, B):\n                continue\n            if (i, j) == (4, -A) or (i, j) == (L-3, B):\n                continue\n            if (i, j) == (5, -A) or (i, j) == (L-4, B):\n                continue\n            if (i, j) == (6, -A) or (i, j) == (L-5, B):\n                continue\n            if (i, j) == (7, -A) or (i, j) == (L-6, B):\n                continue\n            if (i, j) == (8, -A) or (i, j) == (L-7, B):\n                continue\n            if (i, j) == (9, -A) or (i, j) == (L-8, B):\n                continue\n            if (i, j) == (10, -A) or (i, j) == (L-9, B):\n                continue\n            if (i, j) == (11, -A) or (i, j) == (L-10, B):\n                continue\n            if (i, j) == (12, -A) or (i, j) == (L-11, B):\n                continue\n            if (i, j) == (13, -A) or (i, j) == (L-12, B):\n                continue\n            if (i, j) == (14, -A) or (i, j) == (L-13, B):\n                continue\n            if (i, j) == (15, -A) or (i, j) == (L-14, B):\n                continue\n            if (i, j) == (16, -A) or (i, j) == (L-15, B):\n                continue\n            if (i, j) == (17, -A) or (i, j) == (L-16, B):\n                continue\n            if (i, j) == (18, -A) or (i, j) == (L-17, B):\n                continue\n            if (i, j) == (19, -A) or (i, j) == (L-18, B):\n                continue\n            if (i, j) == (20, -A) or (i, j) == (L-19, B):\n                continue\n            if (i, j) == (21, -A) or (i, j) == (L-20, B):\n                continue\n            if (i, j) == (22, -A) or (i, j) == (L-21, B):\n                continue\n            if (i, j) == (23, -A) or (i, j) == (L-22, B):\n                continue\n            if (i, j) == (24, -A) or (i, j) == (L-23, B):\n                continue\n            if (i, j) == (25, -A) or (i, j) == (L-24, B):\n                continue\n            if (i, j) == (26, -A) or (i, j) == (L-25, B):\n                continue\n            if (i, j) == (27, -A) or (i, j) == (L-26, B):\n                continue\n            if (i, j) == (28, -A) or (i, j) == (L-27, B):\n                continue\n            if (i, j) == (29, -A) or (i"
    },
    {
        "number": 3200,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lights = []\n    for i in range(n-1):\n        t, g, r = map(int, stdin.split())\n        lights.append((t, g, r))\n    lights.sort(key=lambda x: x[0])\n    t = 0\n    v = 0\n    for light in lights:\n        t += light[1]\n        if t > light[0]:\n            t += light[2]\n        v += 1\n    return v*1.0/2"
    },
    {
        "number": 3201,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K, B, M = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n\n    # calculate all subsequences\n    subsequences = []\n    for i in range(2**N):\n        subsequence = []\n        for j in range(N):\n            if i & (1 << j):\n                subsequence.append(A[j])\n        subsequences.append(subsequence)\n\n    # sort subsequences lexicographically\n    subsequences.sort()\n\n    # calculate hash values\n    hash_values = []\n    for subsequence in subsequences:\n        hash_value = 0\n        for i in range(len(subsequence)):\n            hash_value = (hash_value * B + subsequence[i]) % M\n        hash_values.append(hash_value)\n\n    # output hash values\n    for i in range(K):\n        print(hash_values[i])\n\n    return \"\""
    },
    {
        "number": 3202,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    count = 0\n    i = 0\n    while i < N:\n        if i == N-1 or colors[i]!= colors[i+1]:\n            count += 1\n            i += 1\n        else:\n            j = i + 1\n            while j < N and colors[j] == colors[i]:\n                j += 1\n            if j - i >= K:\n                count += j - i - K + 1\n                i = j\n            else:\n                count += K - (j - i)\n                i = j - K + 1\n    return count"
    },
    {
        "number": 3203,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    probabilities = []\n    for i in range(1, n+1):\n        probabilities.append(list(map(int, lines[i].split())))\n\n    # Calculate probabilities\n    total_prob = 1\n    for i in range(n):\n        total_prob *= probabilities[i][i]\n\n    # Calculate maximum probability\n    max_prob = 0\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                prob = probabilities[i][j] * probabilities[j][i]\n                if prob > max_prob:\n                    max_prob = prob\n\n    # Output result\n    return str(int(max_prob / total_prob * 1000000))"
    },
    {
        "number": 3204,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    t = [int(line) for line in lines[1:]]\n\n    # sort boats by arrival time\n    t.sort()\n\n    # initialize variables\n    bridge_is_raised = True\n    time_since_last_boat = 0\n    total_time_unavailable = 0\n\n    # iterate over boats\n    for i in range(n):\n        # calculate time since last boat\n        time_since_last_boat = t[i] - t[i-1] if i > 0 else 0\n\n        # if bridge is raised and boat arrives within 20 seconds, raise bridge\n        if bridge_is_raised and time_since_last_boat <= 20:\n            bridge_is_raised = False\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is not raised and boat arrives within 20 seconds, wait for bridge to raise\n        elif not bridge_is_raised and time_since_last_boat <= 20:\n            bridge_is_raised = True\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is raised and boat arrives after 20 seconds, wait for bridge to lower\n        elif bridge_is_raised and time_since_last_boat > 20:\n            bridge_is_raised = False\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is not raised and boat arrives after 20 seconds, wait for bridge to raise\n        elif not bridge_is_raised and time_since_last_boat > 20:\n            bridge_is_raised = True\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is raised and boat arrives within 30 seconds, wait for bridge to lower\n        elif bridge_is_raised and time_since_last_boat <= 30:\n            bridge_is_raised = False\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is not raised and boat arrives within 30 seconds, wait for bridge to raise\n        elif not bridge_is_raised and time_since_last_boat <= 30:\n            bridge_is_raised = True\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is raised and boat arrives after 30 seconds, wait for bridge to lower\n        elif bridge_is_raised and time_since_last_boat > 30:\n            bridge_is_raised = False\n            total_time_unavailable += time_since_last_boat\n\n        # if bridge is not raised and boat arrives after 30 seconds, wait for bridge to raise\n        elif not bridge_is_raised and time_since_last_boat > 30:\n            bridge_is_raised = True\n            total_time_unavailable += time_since_last_boat\n\n    # return total time unavailable\n    return str(total_time_unavailable)"
    },
    {
        "number": 3205,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    graph = [[] for _ in range(M)]\n    for _ in range(N):\n        a, b, p = map(int, stdin.readline().split())\n        graph[a].append((b, p))\n        graph[b].append((a, p))\n    visited = [False] * M\n    stack = [(0, 0)]\n    ans = 0\n    while stack:\n        a, b = stack.pop()\n        if visited[a]:\n            continue\n        visited[a] = True\n        for c, p in graph[a]:\n            if c == b:\n                continue\n            stack.append((c, b))\n            ans += 1\n    return ans"
    },
    {
        "number": 3206,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, s = map(int, stdin.split()[0:2])\n    blocks = list(map(int, stdin.split()[2:2+n]))\n    buildings = list(map(int, stdin.split()[2+n:]))\n\n    # sort blocks and buildings\n    blocks.sort()\n    buildings.sort()\n\n    # check if it is possible to build the skyline\n    if sum(blocks) < sum(buildings):\n        return '-1'\n\n    # initialize variables\n    stacks = [[] for _ in range(s)]\n    stack_heights = [0] * s\n    block_index = 0\n\n    # iterate through blocks and buildings\n    for building in buildings:\n        # find the first block that can be used to build the current building\n        while block_index < n and blocks[block_index] < building:\n            block_index += 1\n\n        # if no block can be used, return -1\n        if block_index == n:\n            return '-1'\n\n        # add the block to the first stack that can build the current building\n        for stack_index in range(s):\n            if stack_heights[stack_index] + blocks[block_index] <= building:\n                stacks[stack_index].append(blocks[block_index])\n                stack_heights[stack_index] += blocks[block_index]\n                break\n\n    # output the number of blocks needed to build each building\n    for stack in stacks:\n        print(len(stack), end=' ')\n        print(*stack)\n\n    return ''"
    },
    {
        "number": 3207,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    chameleons = []\n    for i in range(N):\n        d, b, c = map(str, stdin.split())\n        d = int(d)\n        b = int(b)\n        if c == 'L':\n            chameleons.append((d, b, -1))\n        else:\n            chameleons.append((d, b, 1))\n    chameleons.sort()\n    trips = [0] * K\n    for i in range(N):\n        d, b, c = chameleons[i]\n        if c == -1:\n            trips[b] += d\n        else:\n            trips[b] += L - d\n            trips[(b + (b + c) % K) % K] += d\n    return '\\n'.join(map(str, trips))"
    },
    {
        "number": 3208,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Define the set of known words\n    known_words = {\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"}\n    \n    # Define the mapping from encrypted letters to plain text letters\n    mapping = {\n        \"a\": \"b\",\n        \"b\": \"c\",\n        \"c\": \"d\",\n        \"d\": \"e\",\n        \"e\": \"f\",\n        \"f\": \"g\",\n        \"g\": \"h\",\n        \"h\": \"i\",\n        \"i\": \"j\",\n        \"j\": \"k\",\n        \"k\": \"l\",\n        \"l\": \"m\",\n        \"m\": \"n\",\n        \"n\": \"o\",\n        \"o\": \"p\",\n        \"p\": \"q\",\n        \"q\": \"r\",\n        \"r\": \"s\",\n        \"s\": \"t\",\n        \"t\": \"u\",\n        \"u\": \"v\",\n        \"v\": \"w\",\n        \"w\": \"x\",\n        \"x\": \"y\",\n        \"y\": \"z\",\n        \"z\": \" \",\n    }\n    \n    # Define the set of letters in the encrypted text\n    encrypted_letters = set(mapping.keys())\n    \n    # Define the set of letters in the plain text\n    plain_letters = set(mapping.values())\n    \n    # Define the set of letters in the known words\n    known_letters = set(\"\".join(known_words))\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Check if there are any unknown letters in the encrypted text\n    if len(unknown_letters) > 0:\n        return \"Impossible\"\n    \n    # Check if there are any missing letters in the known words\n    if len(missing_letters) > 0:\n        return \"Impossible\"\n    \n    # Check if there are any extra letters in the known words\n    if len(extra_letters) > 0:\n        return \"Impossible\"\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known words that are not in the plain text\n    extra_letters = known_letters - plain_letters\n    \n    # Define the set of letters in the encrypted text that are not in the known words\n    unknown_letters = encrypted_letters - known_letters\n    \n    # Define the set of letters in the known words that are not in the encrypted text\n    missing_letters = known_letters - encrypted_letters\n    \n    # Define the set of letters in the known"
    },
    {
        "number": 3209,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    origin, destination = lines[0].split()\n    n = int(lines[1])\n    connections = []\n    for i in range(2, 2+n):\n        line = lines[i].split()\n        connections.append((line[0], line[1], int(line[2]), int(line[3]), int(line[4]), int(line[5])))\n\n    # compute minimum expected duration\n    total_duration = 0\n    for connection in connections:\n        if connection[0] == origin and connection[1] == destination:\n            # direct connection\n            total_duration += connection[2]\n        elif connection[0] == origin:\n            # indirect connection\n            total_duration += connection[2] + connection[3]\n        elif connection[1] == destination:\n            # indirect connection\n            total_duration += connection[2] + connection[3]\n        else:\n            # no connection\n            return \"IMPOSSIBLE\"\n\n    return str(total_duration)"
    },
    {
        "number": 3210,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    board = [[c for c in line.strip()] for line in stdin.split('\\n')[1:]]\n    moves = 0\n    for i in range(N):\n        for j in range(N):\n            if board[2*i][2*j] == '*':\n                if board[2*i][2*j-1] == '.' and board[2*i+1][2*j] == '.':\n                    board[2*i][2*j-1] = '|'\n                    board[2*i+1][2*j] = '-'\n                    moves += 1\n                elif board[2*i][2*j-1] == '-' and board[2*i+1][2*j] == '.':\n                    board[2*i][2*j-1] = '|'\n                    board[2*i+1][2*j] = '-'\n                    moves += 1\n                elif board[2*i][2*j-1] == '.' and board[2*i+1][2*j] == '|':\n                    board[2*i][2*j-1] = '|'\n                    board[2*i+1][2*j] = '-'\n                    moves += 1\n                elif board[2*i][2*j-1] == '-' and board[2*i+1][2*j] == '|':\n                    board[2*i][2*j-1] = '|'\n                    board[2*i+1][2*j] = '-'\n                    moves += 1\n    return moves"
    },
    {
        "number": 3211,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    tellers = [i for i in range(n) if s[i] == '0']\n    parties = [1 if s[i] == '1' else 2 for i in range(n) if s[i]!= '0']\n    if len(set(parties)) == 1:\n        return \"impossible\"\n    points = [0, 0]\n    for i in range(n):\n        if s[i] == '0':\n            if parties[i] == 1:\n                points[0] += 1\n            else:\n                points[1] += 1\n        else:\n            if parties[i] == 1:\n                points[0] += 1\n            else:\n                points[1] += 1\n    if points[0] > points[1]:\n        return \"impossible\"\n    swaps = 0\n    for i in range(n):\n        if s[i] == '0':\n            continue\n        if i == 0 and s[i+1] == '0':\n            continue\n        if i == n-1 and s[i-1] == '0':\n            continue\n        if s[i-1] == '0' and s[i+1] == '0':\n            continue\n        if s[i-1] == '0' and s[i+1]!= '0':\n            s = s[:i+1] + s[i] + s[i+1] + s[i+2:]\n            swaps += 1\n        elif s[i+1] == '0' and s[i-1]!= '0':\n            s = s[:i-1] + s[i] + s[i-1] + s[i:]\n            swaps += 1\n    if points[0] > points[1]:\n        return \"impossible\"\n    return swaps"
    },
    {
        "number": 3212,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    snakes = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y, d = map(int, line.split())\n            snakes.append((x, y, d))\n\n    # Check if Bill can make the trip\n    for i in range(len(snakes)):\n        for j in range(i+1, len(snakes)):\n            if snakes[i][0] < snakes[j][0] and snakes[i][1] < snakes[j][1]:\n                # Bill can enter the field from the southwest corner\n                # and leave it from the northeast corner\n                if snakes[i][2] >= snakes[j][0] - snakes[i][0]:\n                    # Bill can enter the field from the southwest corner\n                    # and leave it from the southeast corner\n                    if snakes[i][2] >= snakes[j][1] - snakes[i][1]:\n                        # Bill can enter the field from the southwest corner\n                        # and leave it from the northwest corner\n                        if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                            # Bill can enter the field from the southwest corner\n                            # and leave it from the southwest corner\n                            if snakes[i][2] >= snakes[j][0] - snakes[i][1]:\n                                # Bill can enter the field from the southwest corner\n                                # and leave it from the northeast corner\n                                if snakes[i][2] >= snakes[j][1] + snakes[i][0] - snakes[j][0]:\n                                    # Bill can enter the field from the southwest corner\n                                    # and leave it from the northwest corner\n                                    if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                        # Bill can enter the field from the southwest corner\n                                        # and leave it from the southeast corner\n                                        if snakes[i][2] >= snakes[j][1] - snakes[i][0]:\n                                            # Bill can enter the field from the southwest corner\n                                            # and leave it from the northwest corner\n                                            if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                # Bill can enter the field from the southwest corner\n                                                # and leave it from the southwest corner\n                                                if snakes[i][2] >= snakes[j][1] - snakes[i][0]:\n                                                    # Bill can enter the field from the southwest corner\n                                                    # and leave it from the northeast corner\n                                                    if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                        # Bill can enter the field from the southwest corner\n                                                        # and leave it from the northwest corner\n                                                        if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                            # Bill can enter the field from the southwest corner\n                                                            # and leave it from the southeast corner\n                                                            if snakes[i][2] >= snakes[j][1] - snakes[i][0]:\n                                                                # Bill can enter the field from the southwest corner\n                                                                # and leave it from the northwest corner\n                                                                if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                                    # Bill can enter the field from the southwest corner\n                                                                    # and leave it from the southwest corner\n                                                                    if snakes[i][2] >= snakes[j][1] - snakes[i][0]:\n                                                                        # Bill can enter the field from the southwest corner\n                                                                        # and leave it from the northeast corner\n                                                                        if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                                            # Bill can enter the field from the southwest corner\n                                                                            # and leave it from the northwest corner\n                                                                            if snakes[i][2] >= snakes[j][0] + snakes[i][1] - snakes[j][1]:\n                                                                                # Bill can enter the field from the southwest corner\n                                                                                # and leave it from the southeast corner\n                                                                                if snakes[i][2] >= snakes[j][1] - snakes"
    },
    {
        "number": 3213,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    steps = stdin.strip().split()\n    power = 1\n    for i in range(M):\n        if steps[i] == '+':\n            power += 1\n        elif steps[i] == 'x':\n            power *= 2\n        if power > S:\n            power = S\n        power = power % (2**S)\n    return ''.join(['o' if step == '+' else step for step in steps])"
    },
    {
        "number": 3214,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read in paragraphs of text\n    paragraphs = stdin.strip().split(\"\\n***\\n\")\n    # create a set of all words in the text\n    words = set()\n    for paragraph in paragraphs:\n        for line in paragraph.split(\"\\n\"):\n            for word in line.split():\n                words.add(word.lower())\n    # create a dictionary of all word cores to their similarly spelled word cores\n    similar_words = {}\n    for word in words:\n        core = \"\".join(c for c in word if c.isalpha()).lower()\n        if core not in similar_words:\n            similar_words[core] = set()\n        for other_word in words:\n            if other_word!= word:\n                other_core = \"\".join(c for c in other_word if c.isalpha()).lower()\n                if core!= other_core and is_similar(core, other_core):\n                    similar_words[core].add(other_core)\n    # print the results\n    results = []\n    for core, similar_cores in sorted(similar_words.items()):\n        if similar_cores:\n            results.append(f\"{core}: {' '.join(sorted(similar_cores))}\")\n    if not results:\n        results.append(\"***\")\n    return \"\\n\".join(results)\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = map(int, stdin.splitlines()[0].split())\n    count = 0\n    while cards!= list(range(1, n+1)):\n        count += 1\n        cards = [cards[i:i+2] for i in range(0, n, 2)]\n        cards = [card for sublist in cards for card in sublist]\n    return str(count)"
    },
    {
        "number": 3216,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    numerator, denominator = stdin.split()\n    numerator = numerator.replace(\".\", \"\")\n    denominator = int(denominator)\n    numerator = int(numerator[:denominator])\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3217,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cells = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        cells.append((x, y, z))\n    # sort cells by z-coordinate\n    cells.sort(key=lambda x: x[2])\n    # find the minimum number of panels required to contain the defective cells\n    panels = 0\n    for i in range(n):\n        x, y, z = cells[i]\n        # check if there are any cells with the same z-coordinate\n        j = i + 1\n        while j < n and cells[j][2] == z:\n            j += 1\n        # calculate the number of panels required for this group of cells\n        num_panels = (j - i) * 6\n        # add the number of panels required for this group of cells to the total\n        panels += num_panels\n    return str(panels)"
    },
    {
        "number": 3218,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = []\n    for i in range(n):\n        row = list(map(int, stdin.readline().strip().split()))\n        a.append(row)\n\n    # check if a valid coloring exists\n    def valid_coloring(a):\n        # check condition 1\n        for i in range(n):\n            for j in range(n):\n                if a[i][j]!= -1 and a[i][j]!= sum(1 for k in range(6) if a[i][j] & (1 << k)):\n                    return False\n        # check condition 2\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == -1:\n                    continue\n                for k in range(6):\n                    if a[i][j] & (1 << k):\n                        # check if edge (i, j) -> (i+1, j+k) is colored\n                        if a[i+1][j+k] == -1:\n                            return False\n                        # check if edge (i, j) -> (i+1, j-k) is colored\n                        if i > 0 and a[i-1][j-k] == -1:\n                            return False\n                        # check if edge (i, j) -> (i+1, j+k) is part of a loop\n                        if a[i+1][j+k] & (1 << k):\n                            return False\n                        # check if edge (i, j) -> (i+1, j-k) is part of a loop\n                        if i > 0 and a[i-1][j-k] & (1 << k):\n                            return False\n        return True\n\n    # count valid colorings\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if a[i][j]!= -1:\n                continue\n            a[i][j] = 0\n            if valid_coloring(a):\n                count += 1\n            a[i][j] = -1\n    return count"
    },
    {
        "number": 3219,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 0\n    for i in range(2**n.bit_length()):\n        if bin(i).count('1') == n.bit_length() and bin(i).count('2') == 1:\n            count += 1\n    return str(count % 1000000009)"
    },
    {
        "number": 3220,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    if n == 1:\n        return \"L\"\n    if n == 2:\n        return \"LR\" if p[0] == p[1] else \"RL\"\n    if n == 3:\n        return \"LLR\" if p[0] == p[1] == p[2] else \"LRL\" if p[0] == p[2] else \"RLL\"\n    if n == 4:\n        return \"LLRL\" if p[0] == p[1] == p[2] == p[3] else \"LRLR\" if p[0] == p[1] == p[3] else \"RLLR\" if p[1] == p[2] == p[3] else \"LLRR\" if p[0] == p[2] == p[3] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p[1] == p[2] else \"LLRR\" if p[0] == p[2] else \"RLRL\" if p[0] == p[1] else \"LRRL\" if p[0] == p[2] else \"RLLR\" if p"
    },
    {
        "number": 3221,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M, alpha = map(int, stdin.readline().split())\n    roads = []\n    for i in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        roads.append((u, v, c))\n\n    # build graph\n    graph = [[] for _ in range(N+1)]\n    for u, v, c in roads:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    # bfs to find shortest path\n    visited = [False] * (N+1)\n    visited[1] = True\n    queue = [(1, 0)]\n    while queue:\n        u, dist = queue.pop(0)\n        for v, c in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append((v, dist+c))\n\n    # check if there is a route satisfying the condition\n    if not visited[N]:\n        return \"Poor girl\"\n\n    # calculate energy\n    L = max(c for _, _, c in roads)\n    K = sum(1 for visited_ in visited if visited_)\n    return str(L**2 + alpha * K)"
    },
    {
        "number": 3222,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        f, t = map(int, stdin.split())\n        adj[f].append(t)\n        adj[t].append(f)\n    visited = [False] * N\n    stack = [0]\n    trips = []\n    while stack:\n        if len(trips) > 0 and len(trips[-1]) == N:\n            break\n        curr = stack.pop()\n        if visited[curr]:\n            continue\n        visited[curr] = True\n        trips[-1].append(curr)\n        for nei in adj[curr]:\n            if not visited[nei]:\n                stack.append(nei)\n    if len(trips) == N:\n        return \"Yeah!\"\n    else:\n        return \"\\n\".join(str(len(trip)) + \"\\n\" + \" \".join(map(str, trip)) for trip in trips)"
    },
    {
        "number": 3223,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    V, *degrees = map(int, stdin.split())\n\n    # Check if it is possible to construct a forest\n    if any(d % 2 == 1 for d in degrees):\n        return \"IMPOSSIBLE\"\n\n    # Construct a forest\n    forest = []\n    for i in range(V):\n        for j in range(i+1, V):\n            if degrees[i] > 0 and degrees[j] > 0:\n                forest.append((i+1, j+1))\n                degrees[i] -= 1\n                degrees[j] -= 1\n\n    # Check if the forest is connected\n    if len(forest)!= V-1:\n        return \"IMPOSSIBLE\"\n\n    # Output the forest\n    return \"POSSIBLE\\n\" + \"\\n\".join(map(str, forest))"
    },
    {
        "number": 3224,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.split('\\n'):\n        if line:\n            x, y, z = map(float, line.split())\n            points.append((x, y, z))\n\n    # find the centroid of the four points\n    centroid = (sum(x for x, y, z in points) / 4,\n                sum(y for x, y, z in points) / 4,\n                sum(z for x, y, z in points) / 4)\n\n    # find the radius of the sphere that touches all four points\n    radius = 0\n    for x, y, z in points:\n        radius = max(radius, ((x - centroid[0]) ** 2 + (y - centroid[1]) ** 2 + (z - centroid[2]) ** 2) ** 0.5)\n\n    # find the coordinates of the centre of the sphere\n    x_c = centroid[0] + radius\n    y_c = centroid[1]\n    z_c = centroid[2]\n\n    return f\"{x_c} {y_c} {z_c}\""
    },
    {
        "number": 3225,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    values = list(map(int, stdin.readline().strip().split()))\n    queue = values.copy()\n    minutes = 0\n    while len(queue) > 1:\n        new_queue = []\n        for i in range(len(queue)):\n            if i == 0:\n                if queue[i] > queue[i+1]:\n                    new_queue.append(queue[i+1])\n                else:\n                    new_queue.append(queue[i])\n            elif i == len(queue)-1:\n                if queue[i] > queue[i-1]:\n                    new_queue.append(queue[i-1])\n                else:\n                    new_queue.append(queue[i])\n            else:\n                if queue[i] > queue[i-1] and queue[i] > queue[i+1]:\n                    new_queue.append(queue[i-1])\n                elif queue[i] > queue[i-1]:\n                    new_queue.append(queue[i-1])\n                elif queue[i] > queue[i+1]:\n                    new_queue.append(queue[i+1])\n                else:\n                    new_queue.append(queue[i])\n        queue = new_queue\n        minutes += 1\n    return f\"{minutes}\\n{' '.join(map(str, queue))}\\n{' '.join(map(str, values))}\""
    },
    {
        "number": 3226,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, e = map(int, stdin.split()[0:3])\n    roads = []\n    for i in range(m):\n        a, b, l = map(int, stdin.split()[0:3])\n        roads.append((a, b, l))\n    exits = list(map(int, stdin.split()))\n    start, end = map(int, stdin.split())\n\n    # build graph\n    graph = [[] for _ in range(n+1)]\n    for a, b, l in roads:\n        graph[a].append((b, l))\n        graph[b].append((a, l))\n\n    # bfs to find shortest path from start to exit\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        curr, dist = queue.pop(0)\n        if curr in visited:\n            continue\n        visited.add(curr)\n        if curr in exits:\n            return str(dist)\n        for neighbor, length in graph[curr]:\n            if neighbor not in visited:\n                queue.append((neighbor, dist+length))\n\n    # no path to exit\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3227,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split())\n    roads = []\n    for i in range(E):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n    chains = [set() for _ in range(N+1)]\n    for a, b in roads:\n        chains[a].add(b)\n        chains[b].add(a)\n    for i in range(1, N+1):\n        if len(chains[i]) == 1:\n            for j in range(1, N+1):\n                if j!= i and j not in chains[i]:\n                    chains[j].add(i)\n    for i in range(E):\n        a, b = roads[i]\n        if len(chains[a]) == 1 and len(chains[b]) == 1:\n            if chains[a].intersection(chains[b]):\n                return \"0\"\n            else:\n                chains[a].add(b)\n                chains[b].add(a)\n        elif len(chains[a]) == 1:\n            chains[a].add(b)\n        elif len(chains[b]) == 1:\n            chains[b].add(a)\n        else:\n            return \"0\"\n    result = []\n    for i in range(E):\n        a, b = roads[i]\n        if chains[a].intersection(chains[b]):\n            result.append(\"1\")\n        else:\n            result.append(\"2\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3228,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, t, g = map(int, stdin.split())\n    arrival_times = list(map(int, stdin.split()))\n\n    # Sort arrival times\n    arrival_times.sort()\n\n    # Initialize variables\n    waiting_times = [0] * n\n    current_gondola = 0\n    current_time = 0\n\n    # Iterate through arrival times\n    for i in range(n):\n        # Calculate time to reach next gondola\n        time_to_gondola = arrival_times[i] - current_time\n\n        # If there are no gondolas available, wait until the next one is available\n        if current_gondola >= g:\n            time_to_gondola = max(time_to_gondola, arrival_times[i] - (arrival_times[current_gondola] + t))\n\n        # Add waiting time to current skier\n        waiting_times[i] = time_to_gondola\n\n        # Update current time and gondola\n        current_time = arrival_times[i]\n        current_gondola += 1\n\n    # Calculate total waiting time\n    total_waiting_time = sum(waiting_times)\n\n    # Return result\n    return str(total_waiting_time)"
    },
    {
        "number": 3229,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = [list(map(int, stdin.split())) for _ in range(m)]\n    scores.sort(key=lambda x: sum(sorted(x)[-4:]), reverse=True)\n    rank = 1\n    for i in range(m):\n        if i == 0 or sum(scores[i]) > sum(scores[i-1]):\n            rank += 1\n    return rank"
    },
    {
        "number": 3230,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    layout = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    explosions = 0\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == 'X':\n                explosions += 1\n                for x in range(max(0, i-1), min(R, i+2)):\n                    for y in range(max(0, j-1), min(C, j+2)):\n                        if layout[x][y] == 'L':\n                            layout[x][y] = '.'\n    return explosions"
    },
    {
        "number": 3231,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[0:3])\n    m = [int(stdin.readline().split()[0]) for _ in range(n)]\n    g = [[] for _ in range(n)]\n    for i in range(n):\n        for j in map(int, stdin.readline().split()):\n            g[i].append(j)\n            g[j].append(i)\n    for i in range(n):\n        g[i].sort()\n    for i in range(n):\n        g[i] = list(set(g[i]))\n    for i in range(n):\n        g[i].sort()\n    for i in range(n):\n        g[i] = [j for j in g[i] if j!= i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i] = [j for j in g[i] if j < i]\n    for i in range(n):\n        g[i"
    },
    {
        "number": 3232,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    s = stdin.strip()\n    n = len(s)\n    if n % 2!= 0:\n        return \"-1\"\n\n    # Find all substrings of length n/2\n    substrings = set()\n    for i in range(n):\n        for j in range(i+n//2, n, n//2):\n            substrings.add(s[i:j])\n\n    # Check if all substrings are different\n    if len(substrings) == n//2+1:\n        return s\n\n    # Rearrange the letters\n    result = \"\"\n    for i in range(n//2):\n        result += s[i]\n        result += s[n//2+i]\n    return result"
    },
    {
        "number": 3233,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarr = arr[i:j]\n            if len(subarr) % 2 == 0:\n                continue\n            subarr.sort()\n            if subarr[0] == subarr[len(subarr)//2]:\n                count += 1\n    return count"
    },
    {
        "number": 3234,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    # calculate the minimum number of squares needed to pack n widgets\n    # using 2D bin packing algorithm\n    # https://en.wikipedia.org/wiki/Bin_packing_problem\n    # https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/\n    # https://www.youtube.com/watch?v=8LusJS5-AGo\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://www.youtube.com/watch?v=L3hda49XcDE\n    # https://www.youtube.com/watch?v=fO7KJj_L1os\n    # https://www.youtube.com/watch?v=v1VgT-z46ow\n    # https://www.youtube.com/watch?v=yGKZOwzGePY\n    # https://www.youtube.com/watch?v=a9xAKttWgP4\n    # https://"
    },
    {
        "number": 3235,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    ledger = [0] * n\n    for i in range(m):\n        a, b, c = map(int, stdin.split()[0:3])\n        ledger[a] -= c\n        ledger[b] += c\n    cycles = []\n    for i in range(n):\n        if ledger[i]!= 0:\n            cycles.append(find_cycle(i, ledger))\n    for cycle in cycles:\n        cancel_cycle(cycle, ledger)\n    p = sum(map(lambda x: x > 0, ledger))\n    result = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if ledger[i] > 0 and ledger[j] > 0:\n                result.append(str(i) + \" \" + str(j) + \" \" + str(min(ledger[i], ledger[j])))\n                ledger[i] -= min(ledger[i], ledger[j])\n                ledger[j] -= min(ledger[i], ledger[j])\n    return str(p) + \"\\n\" + \"\\n\".join(result)\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    heights = list(map(int, stdin.readline().split()))\n    roads = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        roads[a-1].append(b-1)\n        roads[b-1].append(a-1)\n    dp = [[0]*n for _ in range(1<<n)]\n    for i in range(n):\n        dp[1<<i][i] = 1\n    for mask in range(1, 1<<n):\n        for i in range(n):\n            if not (mask >> i & 1):\n                continue\n            for j in roads[i]:\n                if not (mask >> j & 1):\n                    continue\n                dp[mask][i] = max(dp[mask][i], dp[mask^(1<<i)][j]+1)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, dp[(1<<n)-1][i])\n    return str(ans) if ans else '0'"
    },
    {
        "number": 3237,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    factors = [int(x) for x in stdin.strip().split()]\n    # calculate minimum cost\n    cost = 0\n    for i in range(len(factors)):\n        cost += factors[i] * (i+1)\n    # print minimum cost modulo 10^9+7\n    return str((cost % (10**9+7)))"
    },
    {
        "number": 3238,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    image = [stdin.readline().strip() for _ in range(n)]\n    folds = []\n    for i in range(n):\n        for j in range(m):\n            if image[i][j] == '#':\n                folds.append((i, j))\n    if len(folds) == 0:\n        return \"No folds found\"\n    folds.sort()\n    r1, c1 = folds[0]\n    r2, c2 = folds[-1]\n    if r1 == r2:\n        return f\"{r1} {c1} {r2} {c2}\"\n    elif c1 == c2:\n        return f\"{r1} {c1} {r2} {c2}\"\n    elif abs(r1 - r2) == abs(c1 - c2):\n        return f\"{r1} {c1} {r2} {c2}\"\n    elif r1 < r2:\n        return f\"{r1} {c1} {r2} {c2}\"\n    elif c1 < c2:\n        return f\"{r1} {c1} {r2} {c2}\"\n    else:\n        return f\"{r1} {c1} {r2} {c2}\""
    },
    {
        "number": 3239,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    money = 0\n    for i in range(N):\n        if P == 1:\n            money += 100\n        else:\n            money += 100 * (1 - P) ** i\n    return str(money)"
    },
    {
        "number": 3240,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split())\n    p = []\n    b = []\n    for i in range(v-1):\n        p_i, b_i = map(float, stdin.split())\n        p.append(p_i)\n        b.append(b_i)\n    b_v = 0\n    for i in range(k):\n        if b_v & (1 << i):\n            continue\n        expected_positions = 0\n        for j in range(v-1):\n            if b[j] & (1 << i):\n                expected_positions += p[j]\n        if expected_positions > 0.5:\n            b_v |= (1 << i)\n    return str(b_v)"
    },
    {
        "number": 3241,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    a = [int(line.split()[0]) for line in lines[1:n+1]]\n    b = [int(line.split()[1]) for line in lines[1:n+1]]\n\n    # check if the required order can be achieved\n    if sum(b) == 0:\n        return '-1'\n\n    # calculate the total amount of ham to distribute\n    total_ham = sum(a)\n    total_b = sum(b)\n    ham_per_person = total_ham / total_b\n\n    # check if the required amount of ham can be distributed\n    if ham_per_person < 1:\n        return '-1'\n\n    # calculate the required amount of ham\n    required_ham = total_ham\n    for i in range(n):\n        required_ham -= a[i]\n        if required_ham < ham_per_person:\n            return '-1'\n        a[i] += ham_per_person\n\n    # output the required amount of ham\n    return str(required_ham)"
    },
    {
        "number": 3242,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    N, P = map(float, lines[0].split())\n    boxes = []\n    for i in range(1, len(lines)):\n        e, p = map(float, lines[i].split())\n        boxes.append((e, p))\n\n    # sort boxes by probability\n    boxes.sort(key=lambda x: x[1])\n\n    # initialize variables\n    energy = 0\n    prob = 0\n\n    # iterate over boxes\n    for e, p in boxes:\n        # check if probability is enough\n        if prob + p >= P:\n            return str(energy)\n        # add energy and probability\n        energy += e\n        prob += p\n\n    # return -1 if no solution found\n    return '-1'"
    },
    {
        "number": 3243,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    c = list(map(int, stdin.readline().split()))\n    g = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        g[u].append(v)\n        g[v].append(u)\n    visited = [False] * n\n    q = [0]\n    visited[0] = True\n    for _ in range(k):\n        if len(q) == 0:\n            return \"no\"\n        u = q.pop(0)\n        for v in g[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append(v)\n    for i in range(1, n):\n        if not visited[i]:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3244,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    ring = [int(x) for x in stdin.readline().strip().split()]\n    for i in range(n):\n        ring.append(ring[i-1] + ring[i+1])\n    ring = ring[n:] + ring[:n]\n    return '\\n'.join(str(x) for x in ring)"
    },
    {
        "number": 3245,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    commands = lines[1:]\n    history = []\n    for command in commands:\n        if command.startswith('^'):\n            if len(history) > 0:\n                command = history[-1] + command[1:]\n        else:\n            history.append(command)\n    return '\\n'.join(history)"
    },
    {
        "number": 3246,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    sentence, n = stdin.strip().split('\\n')\n    words = set(stdin.strip().split('\\n')[1:])\n\n    # shuffle sentence\n    shuffled_sentence = ''.join(random.sample(sentence, len(sentence)))\n\n    # remove spaces\n    shuffled_sentence = shuffled_sentence.replace(' ', '')\n\n    # check if sentence is decipherable\n    if len(words) == len(shuffled_sentence):\n        # check if sentence is uniquely decipherable\n        if len(set(shuffled_sentence)) == len(shuffled_sentence):\n            # decipher sentence\n            deciphered_sentence = ''\n            for letter in shuffled_sentence:\n                if letter in words:\n                    deciphered_sentence += letter\n            return deciphered_sentence\n        else:\n            return 'ambiguous'\n    else:\n        return 'impossible'"
    },
    {
        "number": 3247,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 9\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n            dp[i][j] %= MOD\n    return dp[n-1][m-1]"
    },
    {
        "number": 3248,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, street = map(int, stdin.readline().split())\n    street = stdin.readline().strip()\n    M = int(stdin.readline())\n    patterns = []\n    for i in range(M):\n        L, pattern = map(int, stdin.readline().split())\n        patterns.append(pattern)\n\n    # count untileable cells\n    untileable = 0\n    for i in range(N):\n        if street[i] not in patterns[0]:\n            untileable += 1\n        for j in range(M):\n            if i+L <= N and street[i:i+L] == patterns[j]:\n                break\n        else:\n            untileable += 1\n\n    return str(untileable)"
    },
    {
        "number": 3249,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    c, n = map(int, stdin.split())\n    vertices = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        vertices.append((x, y))\n\n    # sort vertices by x-coordinate\n    vertices.sort(key=lambda v: v[0])\n\n    # find maximum number of bulkheads\n    max_bulkheads = 1\n    for i in range(1, n):\n        if vertices[i][0] - vertices[i-1][0] > c:\n            max_bulkheads += 1\n\n    # find bulkhead placements\n    bulkheads = []\n    for i in range(max_bulkheads):\n        bulkhead_x = (i+1) * c\n        bulkhead_y = min(v[1] for v in vertices)\n        bulkheads.append((bulkhead_x, bulkhead_y))\n\n    # output result\n    print(max_bulkheads)\n    for x, y in bulkheads:\n        print(x)\n\n    return \"\""
    },
    {
        "number": 3250,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    for m in range(1, 2*d):\n        if (b**m - 1) % d == 0:\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 3251,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.split('\\n'):\n        if line:\n            a, b = map(int, line.split())\n            intervals.append((a, b))\n\n    intervals.sort()\n    n = len(intervals)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if intervals[i][0] > intervals[j][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    max_len = max(dp)\n    result = []\n    for i in range(n - 1, -1, -1):\n        if dp[i] == max_len:\n            result.append(intervals[i])\n            max_len -= 1\n\n    result.reverse()\n    return f\"{len(result)}\\n\" + '\\n'.join(f\"{a} {b}\" for a, b in result)"
    },
    {
        "number": 3252,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = []\n    for i in range(n):\n        w, h, q = map(int, stdin.readline().split())\n        cards.append((w, h, q))\n    envelopes = [144] * k\n    for w, h, q in cards:\n        min_area = float('inf')\n        for i in range(k):\n            if envelopes[i] >= w * h:\n                min_area = min(min_area, envelopes[i])\n        if min_area == float('inf'):\n            return 'No solution'\n        for i in range(k):\n            if envelopes[i] == min_area:\n                envelopes[i] -= w * h\n                break\n    waste = sum(envelopes)\n    return waste"
    },
    {
        "number": 3253,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    S = int(lines[0])\n    state_data = []\n    for i in range(1, S+1):\n        D, C, F, U = map(int, lines[i].split())\n        state_data.append((D, C, F, U))\n\n    # Calculate minimum number of voters to convince to secure a victory\n    total_delegates = sum(D for D, _, _, _ in state_data)\n    total_constituents = sum(C for _, C, _, _ in state_data)\n    total_federals = sum(F for _, _, F, _ in state_data)\n    total_undecided = sum(U for _, _, _, U in state_data)\n\n    if total_constituents + total_undecided < total_federals:\n        return \"impossible\"\n\n    min_delegates = min(D for D, _, _, _ in state_data)\n    max_delegates = max(D for D, _, _, _ in state_data)\n    min_constituents = min(C for _, C, _, _ in state_data)\n    max_constituents = max(C for _, C, _, _ in state_data)\n    min_federals = min(F for _, _, F, _ in state_data)\n    max_federals = max(F for _, _, F, _ in state_data)\n    min_undecided = min(U for _, _, _, U in state_data)\n    max_undecided = max(U for _, _, _, U in state_data)\n\n    if min_delegates + min_constituents + min_federals + min_undecided < max_delegates + max_constituents + max_federals + max_undecided:\n        return \"impossible\"\n\n    # Calculate minimum number of voters to convince to secure a victory\n    min_voters = 0\n    for D, C, F, U in state_data:\n        if D == min_delegates:\n            min_voters += C\n        elif D == max_delegates:\n            min_voters += F\n        else:\n            min_voters += (C + F + U) // 2\n\n    return min_voters"
    },
    {
        "number": 3254,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n    while ones + twos + threes + fours + fives < P:\n        if ones + twos + threes + fours + fives + 1 <= P:\n            ones += 1\n        elif ones + twos + threes + fours + fives + 2 <= P:\n            twos += 1\n        elif ones + twos + threes + fours + fives + 3 <= P:\n            threes += 1\n        elif ones + twos + threes + fours + fives + 4 <= P:\n            fours += 1\n        else:\n            fives += 1\n    return f\"{ones} {twos} {threes} {fours} {fives}\""
    },
    {
        "number": 3255,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, m = map(int, stdin.split()[0:3])\n    arr = list(map(int, stdin.split()[3:]))\n    visited = set()\n    max_len = 0\n    for i in range(n):\n        if i in visited:\n            continue\n        visited.add(i)\n        curr_len = 1\n        j = i + 1\n        while j < n and arr[j] - arr[i] <= m and j - i <= d:\n            visited.add(j)\n            curr_len += 1\n            j += 1\n        if curr_len > max_len:\n            max_len = curr_len\n    return str(max_len)"
    },
    {
        "number": 3256,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = a[i]\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            dp[i][j] = dp[i+1][j-1] & a[j]\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if dp[i][j] > ans:\n                ans = dp[i][j]\n    return ans"
    },
    {
        "number": 3257,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    if area.is_integer():\n        return str(int(area))\n    else:\n        return str(area)"
    },
    {
        "number": 3258,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    mice = []\n    for i in range(n):\n        x, y, s = map(int, stdin.splitlines()[i+1].split())\n        mice.append((x, y, s))\n    m = float(stdin.splitlines()[n+1])\n    x, y = 0, 0\n    v = 0\n    for i in range(n):\n        x1, y1, s = mice[i]\n        if x1 == x and y1 == y:\n            continue\n        d = ((x1-x)**2 + (y1-y)**2)**0.5\n        t = d/v\n        if t > s:\n            return \"IMPOSSIBLE\"\n        x, y = x1, y1\n        v *= m\n    return v"
    },
    {
        "number": 3259,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    boxes = [0] * n\n    total_stones = 0\n    for i in range(q):\n        query = stdin.readline().strip().split()\n        if query[0] == '1':\n            l, r, a, b = map(int, query[1:])\n            for j in range(l, r+1):\n                boxes[j] = (a * (j-l+1)) % b\n                total_stones += boxes[j]\n        else:\n            l, r = map(int, query[1:])\n            print(sum(boxes[l:r+1]))\n    return str(total_stones)"
    },
    {
        "number": 3260,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    MOD = p\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n            if j >= 2 and i-j >= 1:\n                dp[i][j] = (dp[i][j] - dp[i-j-1][j-2]) % MOD\n    return dp[n][k]"
    },
    {
        "number": 3261,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    K = int(stdin.split()[1])\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if (i+j) % 2 == 0:\n                if (i & j) == 0:\n                    count += 1\n            else:\n                if (i & j)!= 0:\n                    count += 1\n    return count"
    },
    {
        "number": 3262,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M, C = map(int, stdin.split()[0:3])\n    clients = list(map(int, stdin.split()[3:3+C]))\n    streets = []\n    for i in range(M):\n        u, v, w = map(int, stdin.split()[i*3+3:i*3+6])\n        streets.append((u, v, w))\n\n    # build graph\n    graph = [[] for _ in range(N)]\n    for u, v, w in streets:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # find shortest paths from warehouse to clients\n    dist = [float('inf')] * N\n    dist[0] = 0\n    visited = [False] * N\n    queue = [(0, 0)]\n    while queue:\n        d, u = queue.pop(0)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                queue.append((dist[v], v))\n\n    # find minimum number of vehicles required\n    trucks = 1\n    for c in clients:\n        if dist[c] > dist[0] + dist[c]:\n            trucks += 1\n\n    return str(trucks)"
    },
    {
        "number": 3263,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split()[0:2])\n    P = list(map(int, stdin.split()[2:2+M]))\n    R = list(map(int, stdin.split()[2+M:2+2*M]))\n    T = []\n    for i in range(N):\n        C, t = map(int, stdin.split()[2+2*M+i*2:2+2*M+i*2+2])\n        T.append((C, t))\n\n    # sort customers by arrival time\n    T.sort(key=lambda x: x[1])\n\n    # initialize variables\n    clothing = -1\n    time = 0\n    count = 0\n\n    # iterate through customers\n    for C, t in T:\n        # if customer is wearing different clothing, put on new clothing\n        if C!= clothing:\n            # if not ready to put on clothing, skip customer\n            if time + P[C-1] > t:\n                continue\n            # put on clothing\n            clothing = C\n            time += P[C-1]\n        # if customer is ready to leave, remove clothing\n        if time + R[C-1] > t:\n            continue\n        # remove clothing\n        clothing = -1\n        time += R[C-1]\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 3264,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 1\n    for i in range(2, n+1):\n        count = (count * i) % 1000000000\n    return str(count)"
    },
    {
        "number": 3265,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, L = map(int, stdin.split())\n    connections = []\n    for i in range(N):\n        row = list(map(int, stdin.readline().split()))\n        connections.append(row)\n\n    # find valid T\n    T = 0\n    while True:\n        # check if Alice and Bob are in B-ville with 95% probability\n        if (T >= L and (T - L) % 2 == 0) or (T < L and (T + L) % 2 == 0):\n            if (T - L) % 2 == 0:\n                T -= L\n            else:\n                T += L\n            if T >= L and (T - L) % 2 == 0:\n                return str(T)\n        # increment T\n        T += 1\n        # check if T exceeds L + 9\n        if T > L + 9:\n            return \"-1\""
    },
    {
        "number": 3266,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[0:4])\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, c = map(int, stdin.split()[0:3])\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    flow = 0\n    while True:\n        parent = [-1] * n\n        queue = [(s, float('inf'))]\n        while queue:\n            u, capacity = queue.pop(0)\n            if u == t:\n                break\n            for v, c in graph[u]:\n                if capacity > 0 and c > 0 and parent[u]!= v:\n                    queue.append((v, min(capacity, c)))\n                    parent[v] = u\n        if parent[t] == -1:\n            break\n        f = float('inf')\n        v = t\n        while v!= s:\n            u = parent[v]\n            f = min(f, graph[u][graph[u].index((v, 0))][1])\n            v = u\n        flow += f\n        v = t\n        while v!= s:\n            u = parent[v]\n            index = graph[u].index((v, 0))\n            graph[u][index] = (v, graph[u][index][1] - f)\n            graph[v][graph[v].index((u, 0))] = (u, graph[v][graph[v].index((u, 0))][1] + f)\n            v = u\n    used_edges = 0\n    for u in range(n):\n        for v, c in graph[u]:\n            if c > 0:\n                used_edges += 1\n    return f\"{n} {flow} {used_edges}\\n\" + \"\\n\".join(f\"{u} {v} {x}\" for u in range(n) for v, x in graph[u] if x > 0) + \"\\n\""
    },
    {
        "number": 3267,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = []\n    for i in range(R):\n        board.append(list(stdin.strip()))\n\n    mirko_king_count = 0\n    slavko_king_count = 0\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == 'M':\n                mirko_king_count += 1\n            elif board[i][j] == 'S':\n                slavko_king_count += 1\n\n    mirko_spread = 0\n    slavko_spread = 0\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == 'M':\n                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1), (i+1, j+1), (i+1, j-1), (i-1, j+1), (i-1, j-1)]:\n                    if 0 <= x < R and 0 <= y < C and board[x][y] == 'S':\n                        mirko_spread += 1\n            elif board[i][j] == 'S':\n                for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1), (i+1, j+1), (i+1, j-1), (i-1, j+1), (i-1, j-1)]:\n                    if 0 <= x < R and 0 <= y < C and board[x][y] == 'M':\n                        slavko_spread += 1\n\n    return f\"{mirko_spread} {slavko_spread}\""
    },
    {
        "number": 3268,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3269,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    MOD = 1000000007\n    ans = 0\n    for i in range(A, B+1):\n        for j in range(i+1, B+1):\n            dist = 0\n            a, b = str(i), str(j)\n            if len(a) < len(b):\n                a = '0'*(len(b)-len(a)) + a\n            elif len(b) < len(a):\n                b = '0'*(len(a)-len(b)) + b\n            for k in range(len(a)):\n                dist += abs(int(a[k]) - int(b[k]))\n            ans += dist\n            ans %= MOD\n    return str(ans)"
    },
    {
        "number": 3270,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, start, end = map(str.strip, stdin.split('\\n'))\n    n = int(n)\n    words = set(map(str.strip, stdin.split('\\n'))[1:])\n\n    # check if start and end are in dictionary\n    if start not in words or end not in words:\n        return '0\\n-1'\n\n    # initialize variables\n    queue = [(start, 0)]\n    visited = set()\n\n    # bfs\n    while queue:\n        word, steps = queue.pop(0)\n        if word == end:\n            return f'{word}\\n{steps}'\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c!= word[i]:\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in words and new_word not in visited:\n                        queue.append((new_word, steps+1))\n                        visited.add(new_word)\n\n    # no solution found\n    return '0\\n-1'"
    },
    {
        "number": 3271,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    MOD = 1000000007\n    dp = [[0] * (C+1) for _ in range(N+1)]\n    dp[1][1] = 1\n    for i in range(2, N+1):\n        for j in range(1, C+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n    return dp[N][C]"
    },
    {
        "number": 3272,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    gargoyles = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] in ['V', 'H']:\n                gargoyles.append((i, j))\n    if not gargoyles:\n        return -1\n    visited = set()\n    def dfs(i, j, k):\n        if (i, j, k) in visited:\n            return False\n        visited.add((i, j, k))\n        if k == len(gargoyles):\n            return True\n        for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= ni < n and 0 <= nj < m and grid[ni][nj]!= '#':\n                if grid[ni][nj] in ['V', 'H']:\n                    if dfs(ni, nj, k+1):\n                        return True\n                elif grid[ni][nj] in ['/', '\\\\']:\n                    if dfs(ni, nj, k):\n                        return True\n        return False\n    for i, j in gargoyles:\n        if dfs(i, j, 1):\n            return len(gargoyles) - 1\n    return -1"
    },
    {
        "number": 3273,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fragments = [stdin.readline().strip() for _ in range(n)]\n    fragments = sorted(fragments, key=len, reverse=True)\n    for i in range(n):\n        for j in range(i+1, n):\n            if fragments[i].endswith(fragments[j][:5]):\n                fragments[i] = fragments[i][:len(fragments[i])-len(fragments[j][:5])] + fragments[j]\n                fragments[j] = ''\n    fragments = [f for f in fragments if f]\n    if len(fragments) == 1:\n        return fragments[0]\n    else:\n        return \"AMBIGUOUS\""
    },
    {
        "number": 3274,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    ships = []\n    for i in range(m):\n        x1, x2, y = map(int, stdin.split()[0:3])\n        ships.append((x1, x2, y))\n    ships.sort(key=lambda x: x[1])\n    torpedo = [(0, 0)]\n    for i in range(n):\n        new_torpedo = []\n        for x, y in torpedo:\n            for dx, dy in [(1, 1), (0, 1), (-1, 1)]:\n                new_x, new_y = x + dx, y + dy\n                for ship in ships:\n                    if ship[0] <= new_x <= ship[1] and ship[2] == new_y:\n                        return \"impossible\"\n                new_torpedo.append((new_x, new_y))\n        torpedo = new_torpedo\n    return \"\".join([\"-\" if i % 2 == 0 else \"+\" for i in range(n)])"
    },
    {
        "number": 3275,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, C = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    changes = []\n    for _ in range(Q):\n        P, a_P, b_P = map(int, stdin.readline().split())\n        changes.append((P-1, a_P, b_P))\n\n    # compute answer\n    MOD = 10**9 + 7\n    dp = [[0] * (C+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(N):\n        for j in range(C+1):\n            dp[i+1][j] = dp[i][j]\n            if j >= a[i]:\n                dp[i+1][j] += dp[i][j-a[i]]\n            if j >= b[i]:\n                dp[i+1][j] += dp[i][j-b[i]]\n            dp[i+1][j] %= MOD\n\n    ans = []\n    for P, a_P, b_P in changes:\n        dp_P = [[0] * (C+1) for _ in range(N+1)]\n        dp_P[0][0] = 1\n        for i in range(N):\n            for j in range(C+1):\n                dp_P[i+1][j] = dp_P[i][j]\n                if j >= a_P:\n                    dp_P[i+1][j] += dp_P[i][j-a_P]\n                if j >= b_P:\n                    dp_P[i+1][j] += dp_P[i][j-b_P]\n                dp_P[i+1][j] %= MOD\n        ans.append(dp_P[N][C] - dp[N][C])\n\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3276,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m = map(int, stdin.split())\n    board = []\n    for i in range(n):\n        board.append(list(stdin.readline().strip()))\n\n    # Check if stamp can be placed\n    for i in range(n-2):\n        for j in range(m-2):\n            if board[i][j:j+3] == ['W', 'W', 'W'] and board[i+1][j:j+3] == ['W', 'W', 'W'] and board[i+2][j:j+3] == ['W', 'W', 'W']:\n                return \"YES\"\n            if board[i][j:j+3] == ['R', 'R', 'R'] and board[i+1][j:j+3] == ['R', 'R', 'R'] and board[i+2][j:j+3] == ['R', 'R', 'R']:\n                return \"YES\"\n            if board[i][j:j+3] == ['G', 'G', 'G'] and board[i+1][j:j+3] == ['G', 'G', 'G'] and board[i+2][j:j+3] == ['G', 'G', 'G']:\n                return \"YES\"\n            if board[i][j:j+3] == ['B', 'B', 'B'] and board[i+1][j:j+3] == ['B', 'B', 'B'] and board[i+2][j:j+3] == ['B', 'B', 'B']:\n                return \"YES\"\n\n    # Check if stamp can be placed with rotation\n    for i in range(n-2):\n        for j in range(m-2):\n            if board[i][j:j+3] == ['W', 'W', 'W'] and board[i+1][j:j+3] == ['W', 'W', 'W'] and board[i+2][j:j+3] == ['W', 'W', 'W']:\n                return \"YES\"\n            if board[i][j:j+3] == ['R', 'R', 'R'] and board[i+1][j:j+3] == ['R', 'R', 'R'] and board[i+2][j:j+3] == ['R', 'R', 'R']:\n                return \"YES\"\n            if board[i][j:j+3] == ['G', 'G', 'G'] and board[i+1][j:j+3] == ['G', 'G', 'G'] and board[i+2][j:j+3] == ['G', 'G', 'G']:\n                return \"YES\"\n            if board[i][j:j+3] == ['B', 'B', 'B'] and board[i+1][j:j+3] == ['B', 'B', 'B'] and board[i+2][j:j+3] == ['B', 'B', 'B']:\n                return \"YES\"\n            if board[i][j:j+3] == ['W', 'W', 'W'] and board[i+1][j+1:j+4] == ['W', 'W', 'W'] and board[i+2][j+2:j+5] == ['W', 'W', 'W']:\n                return \"YES\"\n            if board[i][j:j+3] == ['R', 'R', 'R'] and board[i+1][j+1:j+4] == ['R', 'R', 'R'] and board[i+2][j+2:j+5] == ['R', 'R', 'R']:\n                return \"YES\"\n            if board[i][j:j+3] == ['G', 'G', 'G'] and board[i+1][j+1:j+4] == ['G', 'G', 'G'] and board[i+2][j+2:j+5] == ['G', 'G', 'G']:\n                return \"YES\"\n            if board[i][j:j+3] == ['B', 'B', 'B'] and board[i+1][j+1:j+4] == ['B', 'B', 'B'] and board[i+2][j+2:j+5] == ['B', 'B', 'B']:\n                return \"YES\"\n            if board[i][j:j+3] == ['W', 'W', 'W'] and board[i+1][j+2"
    },
    {
        "number": 3277,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K, S = map(int, stdin.split())\n    A = list(map(int, stdin.readline().split()))\n\n    # initialize variables\n    count = 0\n    i = 0\n    j = K - 1\n\n    # loop through array\n    while j < N:\n        # calculate sum of current set\n        curr_sum = sum(A[i:j+1])\n\n        # if sum is not S, increment count and change element\n        if curr_sum!= S:\n            count += 1\n            A[j] = S - (curr_sum - A[j])\n\n        # move window\n        i += 1\n        j += 1\n\n    # return count\n    return count"
    },
    {
        "number": 3278,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    positions = []\n    distances = []\n    for i in range(n):\n        x, d = map(int, stdin.readline().strip().split())\n        positions.append(x)\n        distances.append(d)\n    positions.sort()\n    distances.sort()\n    max_tower_size = 1\n    max_tower_position = positions[0]\n    for i in range(n):\n        if positions[i] + distances[i] > max_tower_position:\n            max_tower_size += 1\n            max_tower_position = positions[i] + distances[i]\n    return f\"{max_tower_position} {max_tower_size}\""
    },
    {
        "number": 3279,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    row_spec = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n    col_spec = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    # Check if there is a valid solution\n    for i in range(n):\n        if sum(row_spec[i]) > n:\n            return \"\"\n    for j in range(n):\n        if sum(col_spec[j]) > n:\n            return \"\"\n\n    # Initialize the solution matrix\n    solution = [[0 for _ in range(n+1)] for _ in range(n+1)]\n\n    # Mark the vertical borders\n    for i in range(n):\n        if sum(row_spec[i]) == 0:\n            continue\n        j = 0\n        while j < n+1:\n            if j == n or row_spec[i][j] == 0:\n                j += 1\n                continue\n            solution[i][j] = 1\n            j += row_spec[i][j]\n\n    # Mark the horizontal borders\n    for j in range(n):\n        if sum(col_spec[j]) == 0:\n            continue\n        i = 0\n        while i < n+1:\n            if i == n or col_spec[j][i] == 0:\n                i += 1\n                continue\n            solution[i][j] = 1\n            i += col_spec[j][i]\n\n    # Convert the solution matrix to a string\n    solution_str = \"\"\n    for i in range(n+1):\n        for j in range(n+1):\n            solution_str += str(solution[i][j])\n\n    return solution_str"
    },
    {
        "number": 3280,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    shows = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        shows.append((x, y))\n    shows.sort()\n    count = 0\n    i = 0\n    while i < n:\n        j = i\n        while j < n and shows[j][0] <= shows[i][1]:\n            j += 1\n        count += (j - i) // k\n        i = j\n    return str(count)"
    },
    {
        "number": 3281,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    J, R, D = map(int, stdin.split()[0:3])\n    junctions = []\n    for i in range(J):\n        x, y = map(int, stdin.split()[0:2])\n        junctions.append((x, y))\n    roads = []\n    for i in range(R):\n        a, b = map(int, stdin.split()[0:2])\n        roads.append((a-1, b-1))\n\n    # calculate distances\n    distances = [[float('inf') for _ in range(J)] for _ in range(J)]\n    for i in range(J):\n        distances[i][i] = 0\n    for a, b in roads:\n        distances[a][b] = distances[b][a] = abs(junctions[a][0] - junctions[b][0]) + abs(junctions[a][1] - junctions[b][1])\n\n    # calculate angles\n    angles = [[float('inf') for _ in range(J)] for _ in range(J)]\n    for i in range(J):\n        for j in range(J):\n            if i == j:\n                continue\n            for k in range(J):\n                if k == i or k == j:\n                    continue\n                if distances[i][j] == float('inf') or distances[j][k] == float('inf') or distances[k][i] == float('inf'):\n                    continue\n                angle = abs(math.degrees(math.atan2(junctions[j][1]-junctions[i][1], junctions[j][0]-junctions[i][0]) - math.atan2(junctions[k][1]-junctions[i][1], junctions[k][0]-junctions[i][0])))\n                if angle > angles[i][j]:\n                    angles[i][j] = angle\n\n    # find optimal route\n    max_angle = 0\n    for i in range(J):\n        for j in range(J):\n            if i == j:\n                continue\n            if angles[i][j] > max_angle:\n                max_angle = angles[i][j]\n    if max_angle == float('inf'):\n        return \"Impossible\"\n    return \"{:.6f}\".format(max_angle)"
    },
    {
        "number": 3282,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    P = int(stdin)\n\n    # initialize variables\n    count = 0\n    bills = set()\n\n    # generate all possible bills\n    for beverage in range(1, P):\n        for main_dish in range(beverage + 1, P):\n            total = beverage + main_dish\n            if total % 10!= beverage % 10 and total % 10!= main_dish % 10:\n                bills.add((beverage, main_dish))\n\n    # count number of free desserts\n    for bill in bills:\n        if bill[0] + bill[1] == P:\n            count += 1\n\n    # output result\n    if count == 0:\n        return \"No free desserts possible.\"\n    else:\n        result = f\"{count}\\n\"\n        for bill in sorted(bills):\n            result += f\"{bill[0]} {bill[1]}\\n\"\n        return result[:5000] + \"\\n...\" if len(bills) > 5000 else result"
    },
    {
        "number": 3283,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    a.sort(reverse=True)\n    res = sum(a[:r])\n    return str(res)"
    },
    {
        "number": 3284,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for i in range(a, b+1):\n        for j in range(c, d+1):\n            if gcd(i, j) == 1:\n                count += 1\n    return count\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, m = map(int, stdin.split())\n    A = [r]\n    d = 1\n    while True:\n        A.append(A[-1] + d)\n        if A[-1] > m:\n            break\n        d += 1\n    for i in range(len(A)):\n        if A[i] == m or (i > 0 and A[i] == A[i-1] + 1):\n            return str(i+1)\n    return \"0\""
    },
    {
        "number": 3286,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input to list of characters\n    password = list(stdin)\n\n    # Count number of possible passwords\n    count = 0\n    for i in range(len(password)):\n        # Check if current character is a vowel\n        if password[i] in ['a', 'e', 'i', 'o', 'u']:\n            # If it is, skip it\n            continue\n        # Check if previous character is a vowel\n        if i > 0 and password[i-1] in ['a', 'e', 'i', 'o', 'u']:\n            # If it is, skip it\n            continue\n        # Check if next character is a vowel\n        if i < len(password)-1 and password[i+1] in ['a', 'e', 'i', 'o', 'u']:\n            # If it is, skip it\n            continue\n        # If none of the above conditions are met, count the password\n        count += 1\n\n    # Return count modulo 1000009\n    return str(count % 1000009)"
    },
    {
        "number": 3287,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *x = map(int, stdin.split())\n    x = [0] + x\n    dp = [0] * (1 << k)\n    dp[0] = 0\n    for i in range(1, 1 << k):\n        for j in range(k):\n            if i & (1 << j):\n                dp[i] = (dp[i] + dp[i ^ (1 << j)] + x[j]) % (10**9 + 7)\n    return dp[-1]"
    },
    {
        "number": 3288,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k == 1:\n        return 'a' * n\n    if k == 2:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 2\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 2\n    if k == 3:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 3\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 3\n    if k == 4:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 4\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 4\n    if k == 5:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 5\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 5\n    if k == 6:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 6\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 6\n    if k == 7:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 7\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 7\n    if k == 8:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 8\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 8\n    if k == 9:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 9\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 9\n    if k == 10:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 10\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 10\n    if k == 11:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 11\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 11\n    if k == 12:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 12\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 12\n    if k == 13:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 13\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 13\n    if k == 14:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 14\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 14\n    if k == 15:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 15\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 15\n    if k == 16:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 16\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 16\n    if k == 17:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 17\n        else:\n            return chr(ord('a') + (n - 1) % 26) * 17\n    if k == 18:\n        if n <= 26:\n            return chr(ord('a') + n - 1) * 18\n        else:\n            return chr(ord('a')"
    },
    {
        "number": 3289,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = [int(x.strip()) for x in stdin.readline().strip().split()]\n    b = [int(x.strip()) for x in stdin.readline().strip().split()]\n    c = [int(x.strip()) for x in stdin.readline().strip().split()]\n\n    max_cluster_size = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if c[i] == 1 and c[j] == 1 and c[k] == 1:\n                    cluster_size = k-i+1\n                    if cluster_size > max_cluster_size:\n                        max_cluster_size = cluster_size\n\n    return str(max_cluster_size)"
    },
    {
        "number": 3290,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, e, d = map(int, stdin.split()[0:3])\n    exploding_kittens = list(map(int, stdin.split()[3:3+e]))\n    defuse_cards = list(map(int, stdin.split()[3+e:]))\n\n    # initialize variables\n    deck = [0] * (e + d)\n    hands = [[] for _ in range(n)]\n    turn = 0\n    winner = -1\n\n    # simulate game\n    while True:\n        # draw card\n        card = deck.pop(0)\n\n        # check if card is exploding kitten\n        if card < e:\n            # check if defuse card is in hand\n            if any(c == d for c in hands[turn]):\n                # discard both cards\n                deck.append(card)\n                deck.append(d)\n                hands[turn].remove(d)\n            else:\n                # leave game\n                winner = turn\n                break\n        else:\n            # add card to hand\n            hands[turn].append(card)\n\n        # check if hand has more than 5 cards\n        if len(hands[turn]) > 5:\n            # discard cards until hand has 5 cards\n            while len(hands[turn]) > 5:\n                deck.append(hands[turn].pop(0))\n\n        # check if all cards have been drawn\n        if not deck:\n            break\n\n        # alternate turns\n        turn = (turn + 1) % n\n\n    # return winner\n    return str(winner) if winner!= -1 else \"-1\""
    },
    {
        "number": 3291,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.readline().split())\n    n = 0\n    while a > 0 and b > 0:\n        if a >= c:\n            a -= c\n            n += 1\n        else:\n            b -= a\n            n += 1\n    while b > 0:\n        n += 1\n        b -= c\n    while a > 0:\n        n += 1\n        a -= d\n    if n > 200:\n        return \"Too many splitters\"\n    res = [0] * n\n    res[0] = -2\n    res[-1] = -1\n    for i in range(1, n-1):\n        if i % 2 == 1:\n            res[i] = i-1\n        else:\n            res[i] = i+1\n    return f\"{n}\\n{' '.join(map(str, res))}\""
    },
    {
        "number": 3292,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    names = [stdin.readline().strip() for _ in range(n)]\n\n    # count number of possible orderings\n    count = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if names[i][:len(names[j])] == names[j][:len(names[i])]:\n                count *= 2\n\n    # return result\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3293,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    snacks = []\n    for i in range(n):\n        f, p, m, s = map(int, stdin.readline().strip().split())\n        snacks.append((f, p, m, s))\n    snacks.sort(key=lambda x: x[0])\n    max_profit = 0\n    for i in range(n):\n        f, p, m, s = snacks[i]\n        if s == 0:\n            continue\n        profit = p * s\n        for j in range(i+1, n):\n            f2, p2, m2, s2 = snacks[j]\n            if f2 <= f:\n                break\n            if s2 == 0:\n                continue\n            profit += p2 * s2\n        max_profit = max(max_profit, profit - p * s)\n    return str(max_profit)"
    },
    {
        "number": 3294,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    contours = []\n    for i in range(1, n+1):\n        h0, h1, m = map(int, lines[i].split())\n        contour = []\n        for j in range(m):\n            x, y = map(int, lines[i+j+1].split())\n            contour.append((x, y))\n        contours.append((h0, h1, contour))\n    # find the closest slanted distance from the surface to the target\n    min_dist = float('inf')\n    for h0, h1, contour in contours:\n        for i in range(len(contour)):\n            for j in range(i+1, len(contour)):\n                x1, y1 = contour[i]\n                x2, y2 = contour[j]\n                if x1 == x2:\n                    continue\n                slope = (y2-y1)/(x2-x1)\n                b = y1 - slope*x1\n                dist = abs(slope*0 - b)/math.sqrt(1+slope**2)\n                if dist < min_dist:\n                    min_dist = dist\n    return str(min_dist)"
    },
    {
        "number": 3295,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    Q = int(lines[0])\n    games = []\n    for i in range(1, Q+1):\n        K, L, M = map(int, lines[i].split())\n        games.append((K, L, M))\n\n    # Solve each game\n    for i, (K, L, M) in enumerate(games, 1):\n        # Initialize array\n        array = [j for j in range(1, K+1)]\n\n        # Check if there are enough happy numbers\n        happy_count = 0\n        for j in range(K):\n            if array[j] <= M or is_prime(array[j]):\n                happy_count += 1\n            if happy_count == L:\n                break\n        else:\n            # No solution found\n            print(f\"Case #{i}: -1\")\n            continue\n\n        # Print array\n        print(f\"Case #{i}: {array[0]}\")\n\n    return \"\"\n\ndef"
    },
    {
        "number": 3296,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return 1\n    if k == 2:\n        return n\n    if k == 3:\n        return n * (n - 1) // 2\n    if k == 4:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 5:\n        return n * (n - 1) * (n - 2) * (n - 3) // 20\n    if k == 6:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 72\n    if k == 7:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 252\n    if k == 8:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 900\n    if k == 9:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) // 362880\n    if k == 10:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) // 12902400\n    if k == 11:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) // 537824000\n    if k == 12:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) // 20922789888000\n    if k == 13:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) // 871782912000000\n    if k == 14:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) * (n - 12) // 41334304000000000\n    if k == 15:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) * (n - 12) * (n - 13) // 2139095040000000000\n    if k == 16:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10"
    },
    {
        "number": 3297,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    puzzle = stdin.strip()\n    words = puzzle.split('=')\n    if len(words)!= 2:\n        return \"Invalid puzzle\"\n    left, right = words\n    left_words = left.split('+')\n    if len(left_words)!= len(set(left_words)):\n        return \"Invalid puzzle\"\n    if len(right)!= len(left):\n        return \"Invalid puzzle\"\n    digits = [str(i) for i in range(10)]\n    for word in left_words:\n        for letter in word:\n            if letter in digits:\n                return \"Invalid puzzle\"\n    for letter in set(left):\n        if letter == '0':\n            return \"Invalid puzzle\"\n    replacements = {}\n    for letter in set(left):\n        replacements[letter] = digits.pop(0)\n    result = ''\n    for letter in right:\n        if letter in replacements:\n            result += replacements[letter]\n        else:\n            result += letter\n    return result"
    },
    {
        "number": 3298,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    MOD = 10**9 + 9\n    count = 1\n    for i in range(n):\n        count = (count * (n-i)) % MOD\n    return count"
    },
    {
        "number": 3299,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = []\n    for i in range(n):\n        row = list(map(int, stdin.split()))\n        board.append(row)\n\n    # Check if the board is valid\n    for i in range(n):\n        if board[i]!= sorted(board[i]):\n            return \"-1\"\n    for j in range(m):\n        col = [board[i][j] for i in range(n)]\n        if col!= sorted(col):\n            return \"-1\"\n\n    # Check if the board is magic\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == 0:\n                continue\n            if i == 0 and j == 0:\n                continue\n            if i == 0 and j == m-1:\n                continue\n            if i == n-1 and j == 0:\n                continue\n            if i == n-1 and j == m-1:\n                continue\n            if (i+j) % 2 == 0 and board[i][j] % 2 == 0:\n                return \"-1\"\n            if (i+j) % 2 == 1 and board[i][j] % 2 == 1:\n                return \"-1\"\n\n    # Calculate the minimum sum\n    min_sum = 0\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == 0:\n                min_sum += 1\n    return min_sum"
    },
    {
        "number": 3300,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    start_times = []\n    velocities = []\n    for i in range(n):\n        t, v = map(int, stdin.readline().strip().split())\n        start_times.append(t)\n        velocities.append(v)\n\n    # sort cheetahs by start time\n    cheetahs = sorted(zip(start_times, velocities), key=lambda x: x[0])\n\n    # calculate minimum length of pack\n    min_length = 0\n    for i in range(n):\n        min_length += cheetahs[i][1] * (cheetahs[i][0] - start_times[0])\n\n    return f\"{min_length:.3f}\""
    },
    {
        "number": 3301,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, p, x, y = map(int, stdin.split()[:4])\n    partnerships = []\n    for i in range(p):\n        a, b, c = map(int, stdin.split()[:3])\n        partnerships.append((a, b, c))\n    m = int(stdin.split()[0])\n    banks = list(map(int, stdin.split()[:m]))\n    # check if x and y are in banks\n    if x not in banks or y not in banks:\n        return \"Impossible\"\n    # compute max fee\n    max_fee = 0\n    for a, b, c in partnerships:\n        if a in banks and b in banks:\n            max_fee = max(max_fee, c)\n    if max_fee == 0:\n        return \"Infinity\"\n    # compute min cost\n    min_cost = float('inf')\n    for i in range(m):\n        for j in range(m):\n            if i!= j and banks[i] in [a for a, b, c in partnerships] and banks[j] in [b for a, b, c in partnerships]:\n                min_cost = min(min_cost, max_fee + banks[i] + banks[j])\n    if min_cost == float('inf'):\n        return \"Impossible\"\n    return str(min_cost)"
    },
    {
        "number": 3302,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    if len(set(s))!= p:\n        return \"impossible\"\n    if n == 1:\n        return \"0\"\n    if n == 2:\n        return \"00 01 11 10\"\n    if n == 3:\n        return \"000 001 011 010 110 111 101 100\"\n    if n == 4:\n        return \"0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000\"\n    if n == 5:\n        return \"00000 00001 00011 00010 00110 00111 00101 00100 01100 01101 01111 01110 01010 01011 01001 01000 11000 11001 11011 11010 11110 11111 11101 11100 10100 10101 10111 10110 10010 10011 10001 10000\"\n    if n == 6:\n        return \"000000 000001 000011 000010 000110 000111 000101 000100 001100 001101 001111 001110 001010 001011 001001 001000 011000 011001 011011 011010 011110 011111 011101 011100 010100 010101 010111 010110 010010 010011 010001 010000 110000 110001 110011 110010 110110 110111 110101 110100 111100 111101 111111 111110 111010 111011 111001 111000 101000 101001 101011 101010 101110 101111 101101 101100 100100 100101 100111 100110 100010 100011 100001 100000\"\n    if n == 7:\n        return \"0000000 0000001 0000011 0000010 0000110 0000111 0000101 0000100 0001100 0001101 0001111 0001110 0001010 0001011 0001001 0001000 0011000 0011001 0"
    },
    {
        "number": 3303,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = map(int, stdin.split())\n    carry = 0\n    count = 0\n    while num1!= 0 or num2!= 0:\n        if num1 % 10 + num2 % 10 + carry > 9:\n            carry = 1\n        else:\n            carry = 0\n        num1 //= 10\n        num2 //= 10\n        count += 1\n    return count"
    },
    {
        "number": 3304,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    p = list(map(int, stdin.readline().strip().split()))\n    v = list(map(int, stdin.readline().strip().split()))\n\n    # sort elves by strength\n    elves = sorted(zip(v, p, a), reverse=True)\n\n    # simulate armwrestling\n    victories = 0\n    for i in range(n):\n        # find unclaimed dwarf\n        j = elves[i][2]\n        while j!= i+1:\n            j = (j-1) % n\n        # simulate armwrestling\n        if elves[i][1] > elves[j][1]:\n            victories += 1\n\n    return str(victories)"
    },
    {
        "number": 3305,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, q = map(int, lines[0].split())\n    s = lines[1]\n    ans = []\n    for i in range(q):\n        l, r = map(int, lines[2+i].split())\n        sub = s[l-1:r]\n        palindromes = set()\n        for i in range(len(sub)):\n            for j in range(i+1, len(sub)+1):\n                if sub[i:j] == sub[i:j][::-1]:\n                    palindromes.add(sub[i:j])\n        ans.append(len(palindromes))\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3306,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    detectors = []\n    for i in range(n):\n        p, c = map(int, stdin.split())\n        detectors.append((p, c))\n    detectors.sort()\n    calls = 0\n    for i in range(n):\n        p, c = detectors[i]\n        if i == 0:\n            calls += c\n        else:\n            calls += c - detectors[i-1][1]\n    return str(calls)"
    },
    {
        "number": 3307,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    polygon = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        polygon.append((x, y))\n    a, b, c, d = map(int, stdin.readline().strip().split())\n    canal = ((a, b), (c, d))\n\n    # find the largest possible area of land to grow corn fields for Alob\n    max_area = 0\n    for i in range(n):\n        for j in range(i+2, n):\n            # check if the two vertices are on the same side of the canal\n            if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                # check if the two vertices are on the same side of the canal\n                if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                    # check if the two vertices are on the same side of the canal\n                    if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                        # check if the two vertices are on the same side of the canal\n                        if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                            # check if the two vertices are on the same side of the canal\n                            if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                                # check if the two vertices are on the same side of the canal\n                                if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal[0][1])) * ((polygon[i][0]-canal[1][0])*(polygon[j][1]-canal[1][1]) - (polygon[j][0]-canal[1][0])*(polygon[i][1]-canal[1][1])) >= 0:\n                                    # check if the two vertices are on the same side of the canal\n                                    if ((polygon[i][0]-canal[0][0])*(polygon[j][1]-canal[0][1]) - (polygon[j][0]-canal[0][0])*(polygon[i][1]-canal"
    },
    {
        "number": 3308,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        points.append((x, y))\n    points.append(points[0])\n    area = 0\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[i+1]\n        area += (x1*y2 - x2*y1) / 2\n    return str(area)"
    },
    {
        "number": 3309,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    dp = [[0] * (N+1) for _ in range(K+1)]\n    for i in range(K+1):\n        for j in range(N+1):\n            if i == 0:\n                dp[i][j] = 1\n            elif j == 0:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i][j-1]\n                for k in range(i):\n                    if j-k >= 1 and A[j-k] == A[j] and dp[i-k-1][j-k] == 1:\n                        dp[i][j] += dp[i-k-1][j-k]\n    return dp[K][N]"
    },
    {
        "number": 3310,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.readline().split()))\n    dp = [[0] * (t+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, t+1):\n            dp[i][j] = dp[i-1][j]\n            if j >= c[i-1]:\n                dp[i][j] = max(dp[i][j], dp[i-1][j-c[i-1]] + c[i-1])\n    return round(dp[n][t]/(g*t), 6)"
    },
    {
        "number": 3311,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = 1\n    for i in range(1, n+1):\n        result = (result * i) % m\n    return str(result)"
    },
    {
        "number": 3312,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, E, S_X, S_Y, C = map(int, stdin.split())\n    cans = []\n    for _ in range(C):\n        X, Y, CT = map(int, stdin.split())\n        cans.append((X, Y, CT))\n\n    # initialize variables\n    energy = E\n    score = 0\n    x, y = S_X, S_Y\n    visited = set()\n\n    # simulate game\n    while True:\n        # check if game is over\n        if (x, y) in visited:\n            break\n        visited.add((x, y))\n\n        # check for can at current position\n        for can in cans:\n            if can[0] == x and can[1] == y:\n                # collect can\n                score += 1\n                energy += 1\n                cans.remove(can)\n                break\n\n        # check for can explosions\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                if (nx, ny) in [(can[0], can[1]) for can in cans]:\n                    # collect oil\n                    score += 1\n                    energy += 1\n                else:\n                    # oil explodes\n                    cans.append((nx, ny, 0))\n\n        # move johnny\n        if energy > 0:\n            energy -= 1\n            if stdin[0] == 'U':\n                y = max(y - 1, 0)\n            elif stdin[0] == 'D':\n                y = min(y + 1, N - 1)\n            elif stdin[0] == 'L':\n                x = max(x - 1, 0)\n            elif stdin[0] == 'R':\n                x = min(x + 1, N - 1)\n\n    return str(score)"
    },
    {
        "number": 3313,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.readline().split())\n    gems = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        gems.append((x, y))\n    max_gems = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dx = gems[j][0] - gems[i][0]\n            dy = gems[j][1] - gems[i][1]\n            if dx == 0:\n                continue\n            if dy == 0:\n                max_gems += 1\n                continue\n            if dx > 0:\n                max_speed = w\n            else:\n                max_speed = -w\n            if dy > 0:\n                max_speed = min(max_speed, h)\n            else:\n                max_speed = max(max_speed, -h)\n            if max_speed == 0:\n                continue\n            max_gems += 1\n    return str(max_gems)"
    },
    {
        "number": 3314,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    wheels = [list(line.strip()) for line in stdin.split('\\n')]\n    # check if all wheels have the same length\n    if len(set(len(wheel) for wheel in wheels))!= 1:\n        return '-1'\n    # check if all wheels have three distinct letters\n    for wheel in wheels:\n        if len(set(wheel))!= 3:\n            return '-1'\n    # count the number of rotations required\n    rotations = 0\n    for i in range(len(wheels[0])):\n        if wheels[0][i]!= 'A' or wheels[1][i]!= 'B' or wheels[2][i]!= 'C':\n            # rotate wheel 0 to the right\n            wheels[0] = wheels[0][1:] + wheels[0][:1]\n            # rotate wheel 1 to the right\n            wheels[1] = wheels[1][1:] + wheels[1][:1]\n            # rotate wheel 2 to the right\n            wheels[2] = wheels[2][1:] + wheels[2][:1]\n            rotations += 1\n        if wheels[0][-i-1]!= 'A' or wheels[1][-i-1]!= 'B' or wheels[2][-i-1]!= 'C':\n            # rotate wheel 0 to the left\n            wheels[0] = wheels[0][-1:] + wheels[0][:-1]\n            # rotate wheel 1 to the left\n            wheels[1] = wheels[1][-1:] + wheels[1][:-1]\n            # rotate wheel 2 to the left\n            wheels[2] = wheels[2][-1:] + wheels[2][:-1]\n            rotations += 1\n    return str(rotations)"
    },
    {
        "number": 3315,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if strings[j].endswith(strings[i]) and strings[i].startswith(strings[j]):\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"
    },
    {
        "number": 3316,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, t, p = map(int, stdin.split())\n    prob = 1\n    for i in range(p):\n        prob *= (m - i) / (m - n)\n    return str(prob)"
    },
    {
        "number": 3317,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')[0]\n    q = int(stdin.split('\\n')[1])\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                dp[i][j] = j - i + 1\n    ans = []\n    for _ in range(q):\n        i, j = map(int, stdin.split('\\n')[2+_].split())\n        ans.append(dp[i][j])\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3318,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, D = map(int, stdin.split())\n    edges = [[] for _ in range(N)]\n    for i in range(1, N):\n        x = int(stdin.readline())\n        edges[x].append(i)\n        edges[i].append(x)\n\n    # bfs to find connected components\n    visited = [False] * N\n    queue = [0]\n    connected_components = 0\n    while queue:\n        node = queue.pop(0)\n        if not visited[node]:\n            visited[node] = True\n            connected_components += 1\n            for neighbor in edges[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n\n    # count maximum number of nodes that can be marked\n    max_marks = 0\n    for i in range(1, N):\n        if not visited[i]:\n            # check if all nodes in the connected component are within distance D\n            queue = [i]\n            visited = [False] * N\n            visited[i] = True\n            while queue:\n                node = queue.pop(0)\n                for neighbor in edges[node]:\n                    if not visited[neighbor] and abs(node - neighbor) <= D:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n            if all(visited):\n                max_marks += 1\n\n    return str(max_marks)"
    },
    {
        "number": 3319,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, n_x, n_y, n_z = map(int, stdin.readline().split())\n    planetoids = []\n    for i in range(n):\n        m, x, y, z, vx, vy, vz = map(int, stdin.readline().split())\n        planetoids.append((m, (x, y, z), (vx, vy, vz)))\n\n    # simulate collisions\n    planets = []\n    while planetoids:\n        # find closest planetoids\n        closest = []\n        for i, (m1, (x1, y1, z1), (vx1, vy1, vz1)) in enumerate(planetoids):\n            closest_dist = float('inf')\n            closest_j = None\n            for j, (m2, (x2, y2, z2), (vx2, vy2, vz2)) in enumerate(planetoids):\n                if i == j:\n                    continue\n                dx, dy, dz = (x2 - x1) % n_x, (y2 - y1) % n_y, (z2 - z1) % n_z\n                dist = dx*dx + dy*dy + dz*dz\n                if dist < closest_dist:\n                    closest_dist = dist\n                    closest_j = j\n            closest.append((i, closest_j))\n\n        # resolve collisions\n        for i, j in closest:\n            m1, (x1, y1, z1), (vx1, vy1, vz1) = planetoids[i]\n            m2, (x2, y2, z2), (vx2, vy2, vz2) = planetoids[j]\n            m = m1 + m2\n            x = (x1*m1 + x2*m2) // m\n            y = (y1*m1 + y2*m2) // m\n            z = (z1*m1 + z2*m2) // m\n            vx = (vx1*m1 + vx2*m2) // m\n            vy = (vy1*m1 + vy2*m2) // m\n            vz = (vz1*m1 + vz2*m2) // m\n            planetoids[i] = (m, (x, y, z), (vx, vy, vz))\n            planetoids.pop(j)\n\n        # add new planets\n        for i, (m, (x, y, z), (vx, vy, vz)) in enumerate(planetoids):\n            if (x, y, z) not in [p[1] for p in planets]:\n                planets.append(('P%d' % len(planets), m, (x, y, z), (vx, vy, vz)))\n\n    # output results\n    p = len(planets)\n    result = str(p) + '\\n'\n    for i, (name, m, (x, y, z), (vx, vy, vz)) in enumerate(sorted(planets, key=lambda p: (-p[1], p[2]))):\n        result += '%s: %d %d %d %d %d %d\\n' % (name, m, x, y, z, vx, vy, vz)\n    return result"
    },
    {
        "number": 3320,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.readline().split())\n        adj[a].append((b, w))\n        adj[b].append((a, w))\n    q = int(stdin.readline())\n    for _ in range(q):\n        s, t = map(int, stdin.readline().split())\n        dist = [float('inf')] * (n+1)\n        dist[s] = 0\n        q = [(0, s)]\n        while q:\n            d, u = heapq.heappop(q)\n            if d > dist[u]:\n                continue\n            for v, w in adj[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(q, (dist[v], v))\n        print(dist[t])\n    return \"\""
    },
    {
        "number": 3321,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    start = list(map(int, stdin.readline().strip().split()))\n    end = list(map(int, stdin.readline().strip().split()))\n\n    # compute leap counts\n    leaps = [0] * n\n    for i in range(n):\n        leaps[i] = start.index(i+1)\n\n    # compute proclamations\n    proclamations = []\n    for i in range(n):\n        if leaps[i] < leaps[(i+1)%n]:\n            proclamations.append(i+1)\n\n    # output proclamations\n    return '\\n'.join(map(str, proclamations))"
    },
    {
        "number": 3322,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    shops = [[] for _ in range(m+1)]\n    for i in range(n):\n        a, p, b, q = map(int, stdin.split())\n        shops[a].append((p, i))\n        shops[b].append((q, i))\n    dp = [[float('inf')] * (1 << n) for _ in range(k+1)]\n    dp[0][0] = 0\n    for i in range(k+1):\n        for j in range(1 << n):\n            for shop, items in enumerate(shops):\n                for price, item in items:\n                    if (j >> item) & 1:\n                        continue\n                    dp[i][j] = min(dp[i][j], dp[i][j ^ (1 << item)] + price)\n    if dp[k][(1 << n) - 1] == float('inf'):\n        return '-1'\n    return dp[k][(1 << n) - 1]"
    },
    {
        "number": 3323,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    cases = int(lines[0])\n    for i in range(1, cases+1):\n        n = int(lines[i])\n        min_fractions = []\n        for j in range(n):\n            a, b, c = map(int, lines[i+j+1].split())\n            min_fractions.append((a, b, c))\n        max_people = 0\n        for j in range(1, n+1):\n            count = 0\n            for k in range(n):\n                if sum(min_fractions[k]) >= j*1000:\n                    count += 1\n            if count > max_people:\n                max_people = count\n        print(f\"Case #{i}: {max_people}\")"
    },
    {
        "number": 3324,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    M = int(lines[-2].split()[0])\n    N = [int(line.split()[1]) for line in lines[:-2]]\n    elements = [line.split()[2:] for line in lines[:-2]]\n    counts = [[int(count) for count in line[2:]] for line in elements]\n    left_counts = [sum(count for count in counts[i] if sign == 1) for i, sign in enumerate(N) if sign == 1]\n    right_counts = [sum(count for count in counts[i] if sign == -1) for i, sign in enumerate(N) if sign == -1]\n    left_counts.sort()\n    right_counts.sort()\n    left_count = left_counts[-1]\n    right_count = right_counts[-1]\n    C = [left_count] + [right_count] * (M - 1)\n    return''.join(str(c) for c in C)"
    },
    {
        "number": 3325,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    d = int(lines[1].split()[0])\n    l = int(lines[1].split()[1])\n    vertices = []\n    for i in range(2, 2+n):\n        x, y = map(int, lines[i].split())\n        vertices.append((x, y))\n    vertices.sort(key=lambda x: x[1])\n    max_y = vertices[-1][1]\n    min_y = vertices[0][1]\n    height = max_y - min_y\n    water_height = height - d\n    water_volume = l / 1000\n    water_capacity = water_height * water_volume\n    return '{:.2f}'.format(water_capacity)"
    },
    {
        "number": 3326,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    grid = []\n    for i in range(r):\n        grid.append(list(map(int, stdin.split())))\n    count = 0\n    for i in range(1, 2**r):\n        for j in range(1, 2**c):\n            subgrid = []\n            for k in range(r):\n                if (i >> k) & 1:\n                    subgrid.append(grid[k])\n            for k in range(c):\n                if (j >> k) & 1:\n                    subgrid = [row[k] for row in subgrid]\n            if all(subgrid[k] <= subgrid[k+1] for k in range(len(subgrid)-1)) or all(subgrid[k] >= subgrid[k+1] for k in range(len(subgrid)-1)):\n                count += 1\n    return count"
    },
    {
        "number": 3327,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    R, C = map(int, stdin.readline().strip().split())\n    grid = [list(stdin.readline().strip()) for _ in range(R)]\n    N = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(N)]\n\n    # solve crossword\n    for word in words:\n        # find all possible positions for the word\n        positions = []\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == \".\" and (i == 0 or grid[i-1][j] == \"#\") and (i == R-1 or grid[i+1][j] == \"#\") and (j == 0 or grid[i][j-1] == \"#\") and (j == C-1 or grid[i][j+1] == \"#\"):\n                    positions.append((i, j))\n\n        # try all possible positions for the word\n        for pos in positions:\n            i, j = pos\n            if len(word) == 2:\n                # check if the word fits horizontally\n                if (i == 0 or grid[i-1][j] == \"#\") and (i == R-1 or grid[i+1][j+1] == \"#\") and (j == 0 or grid[i][j-1] == \"#\") and (j == C-2 or grid[i][j+2] == \"#\"):\n                    grid[i][j] = word[0]\n                    grid[i][j+1] = word[1]\n                    break\n            else:\n                # check if the word fits vertically\n                if (j == 0 or grid[i][j-1] == \"#\") and (j == C-1 or grid[i+1][j] == \"#\") and (i == 0 or grid[i-1][j] == \"#\") and (i == R-2 or grid[i+2][j] == \"#\"):\n                    grid[i][j] = word[0]\n                    grid[i+1][j] = word[1]\n                    break\n\n    # print grid\n    return \"\\n\".join(\"\".join(row) for row in grid)"
    },
    {
        "number": 3328,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n, k = map(int, lines[0].split())\n    table = [[int(x) for x in line.split()] for line in lines[1:]]\n\n    # calculate dominoes\n    dominoes = []\n    for i in range(n):\n        for j in range(n):\n            if i < n-1 and table[i][j] > table[i+1][j]:\n                dominoes.append((i, j, i+1, j))\n            if j < n-1 and table[i][j] > table[i][j+1]:\n                dominoes.append((i, j, i, j+1))\n\n    # place dominoes\n    covered = set()\n    for i, j, k, l in dominoes[:k]:\n        covered.add((i, j))\n        covered.add((k, l))\n    for i, j, k, l in dominoes[k:]:\n        if (i, j) not in covered and (k, l) not in covered:\n            covered.add((i, j))\n            covered.add((k, l))\n\n    # calculate sum of visible fields\n    visible = 0\n    for i in range(n):\n        for j in range(n):\n            if (i, j) not in covered:\n                visible += table[i][j]\n\n    return str(visible)"
    },
    {
        "number": 3329,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    circle = stdin.strip()\n    count = 0\n    for i in range(K):\n        new_circle = ''\n        for j in range(N):\n            if j == 0:\n                new_circle += circle[j]\n            else:\n                if circle[j] == circle[j-1]:\n                    new_circle += 'B'\n                else:\n                    new_circle += 'W'\n        circle = new_circle\n        count += 1\n    distinct_circles = set()\n    for i in range(K+1):\n        distinct_circles.add(circle[i:]+circle[:i])\n    return str(len(distinct_circles))"
    },
    {
        "number": 3330,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, L = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n\n    # calculate average price in each store\n    P1 = sum(c) / (2 * L)\n    P2 = sum(c) / (2 * (N - L))\n\n    # calculate product of average prices\n    return f\"{P1 * P2:.3f}\""
    },
    {
        "number": 3331,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    if A == P or B == P:\n        return \"0\"\n    if A == B:\n        return \"1\"\n    if A < P < B:\n        return \"2\"\n    if P < A:\n        return str(B - P)\n    if P > B:\n        return str(P - A)"
    },
    {
        "number": 3332,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    streams = []\n    for i in range(n):\n        s, d, p = map(int, stdin.readline().strip().split())\n        streams.append((s, d, p))\n    streams.sort(key=lambda x: x[2], reverse=True)\n    stack = []\n    max_priority = 0\n    for s, d, p in streams:\n        while stack and stack[-1][0] <= s:\n            stack.pop()\n        if not stack or stack[-1][1] < p:\n            stack.append((s, p))\n            max_priority += p\n    return str(max_priority)"
    },
    {
        "number": 3333,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    x, y = map(float, stdin.split()[0:2])\n    n = int(stdin.split()[2])\n    spots = []\n    for i in range(n):\n        x, y = map(float, stdin.split()[0:2])\n        spots.append((x, y))\n\n    # compute distances\n    distances = []\n    for spot in spots:\n        dx = spot[0] - x\n        dy = spot[1] - y\n        distances.append((dx**2 + dy**2)**0.5)\n\n    # sort distances\n    distances.sort()\n\n    # compute minimum distance\n    min_distance = 0\n    for i in range(0, n, 2):\n        min_distance += distances[i]\n\n    return str(min_distance)"
    },
    {
        "number": 3334,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    distances = []\n    for i in range(n-1):\n        distances.append(list(map(int, stdin.split())))\n    for i in range(n-1):\n        for j in range(i+1, n):\n            distances[i][j] = distances[j][i] = min(distances[i][j], distances[i][i+j])\n    total_distance = sum(sum(row) for row in distances)\n    if total_distance == 0:\n        return \"impossible\"\n    return str(total_distance / (n*(n-1)//2))"
    },
    {
        "number": 3335,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a+1, n):\n            c = (a**2 + b**2) % n\n            if c == 0:\n                count += 1\n    return count"
    },
    {
        "number": 3336,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    pupils = []\n    for i in range(1, n+1):\n        h, sex, music, sport = lines[i].split()\n        pupils.append((int(h), sex, music, sport))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if abs(pupils[i][0] - pupils[j][0]) > 40 or pupils[i][1] == pupils[j][1] or pupils[i][2] == pupils[j][2] or pupils[i][3] == pupils[j][3]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3337,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for line in stdin.split('\\n'):\n        if line[0] == 'a':\n            stack.append(int(line[2:]))\n        elif line[0] == 'b':\n            if not stack:\n                continue\n            stack.pop()\n            print(stack[-1])\n        elif line[0] == 'c':\n            if not stack:\n                continue\n            w = int(line[3:])\n            count = 0\n            for num in stack:\n                if num in stack[w]:\n                    count += 1\n            print(count)\n    return ''"
    },
    {
        "number": 3338,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    partners = []\n    for i in range(n):\n        g, p, g_a, p_a = map(int, stdin.split())\n        if g_a == 0 and p_a == 0:\n            partners.append((g, p))\n        else:\n            partners.append((g_a, p_a))\n    partners.sort(reverse=True)\n    max_diversity = 0\n    for i in range(k):\n        max_diversity = max(max_diversity, i+1)\n    return str(max_diversity)"
    },
    {
        "number": 3339,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    dp = [0] * (n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % 1000000009\n    ans = dp[n]\n    for i in range(1, n+1):\n        for j in adj[i]:\n            if dp[i]!= dp[j]:\n                ans = (ans - dp[i] + dp[j]) % 1000000009\n    return str(ans)"
    },
    {
        "number": 3340,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    flights = []\n    for i in range(n-1):\n        a, b = map(int, stdin.readline().strip().split())\n        flights.append((a, b))\n    flights.sort()\n    max_changes = 0\n    best_flight = None\n    for i in range(n-1):\n        for j in range(i+1, n):\n            changes = 0\n            for k in range(n-1):\n                if flights[k][0] == flights[i][0] or flights[k][0] == flights[i][1] or flights[k][1] == flights[i][0] or flights[k][1] == flights[i][1]:\n                    changes += 1\n            for k in range(n-1):\n                if flights[k][0] == flights[j][0] or flights[k][0] == flights[j][1] or flights[k][1] == flights[j][0] or flights[k][1] == flights[j][1]:\n                    changes += 1\n            if changes > max_changes:\n                max_changes = changes\n                best_flight = (flights[i][0], flights[i][1], flights[j][0], flights[j][1])\n    return f\"{max_changes}\\n{best_flight[0]} {best_flight[1]}\\n{best_flight[2]} {best_flight[3]}\""
    },
    {
        "number": 3341,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    m, n = map(int, stdin.split())\n    producers = []\n    consumers = []\n    for i in range(m):\n        p, d = map(int, stdin.split())\n        producers.append((p, d))\n    for j in range(n):\n        q, e = map(int, stdin.split())\n        consumers.append((q, e))\n\n    # sort producers by start date\n    producers.sort(key=lambda x: x[1])\n\n    # sort consumers by end date\n    consumers.sort(key=lambda x: x[1])\n\n    # initialize variables\n    max_profit = 0\n    current_profit = 0\n    current_producer = None\n    current_consumer = None\n\n    # iterate over producers and consumers\n    for i in range(m):\n        for j in range(n):\n            # check if producer can start selling\n            if producers[i][1] <= consumers[j][1]:\n                # check if consumer can buy\n                if producers[i][0] <= consumers[j][0]:\n                    # calculate profit\n                    profit = producers[i][0] - consumers[j][0]\n                    # update max profit\n                    if profit > max_profit:\n                        max_profit = profit\n                        current_profit = profit\n                        current_producer = i\n                        current_consumer = j\n\n    # print result\n    if max_profit == 0:\n        return \"0\"\n    else:\n        return str(max_profit)"
    },
    {
        "number": 3342,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, k = map(int, stdin.readline().split())\n    onions = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        onions.append((x, y))\n    posts = []\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        posts.append((a, b))\n    # sort onions by x-coordinate\n    onions.sort(key=lambda x: x[0])\n    # sort posts by angle with x-axis\n    posts.sort(key=lambda p: math.atan2(p[1]-posts[0][1], p[0]-posts[0][0]))\n    # find the convex hull of the onions\n    hull = []\n    for p in posts:\n        while len(hull) >= 2 and (hull[-1][0]-hull[-2][0])*(p[1]-hull[-1][1]) > (hull[-1][1]-hull[-2][1])*(p[0]-hull[-1][0]):\n            hull.pop()\n        hull.append(p)\n    # count the number of onions in the convex hull\n    count = 0\n    for i in range(len(hull)):\n        for j in range(i+1, len(hull)):\n            if hull[j][0] <= hull[i][0]:\n                continue\n            for onion in onions:\n                if onion[0] <= hull[i][0] and onion[0] >= hull[j][0] and onion[1] <= max(hull[i][1], hull[j][1]) and onion[1] >= min(hull[i][1], hull[j][1]):\n                    count += 1\n                    break\n    # upgrade k posts\n    for i in range(k):\n        posts[i] = (posts[i][0], posts[i][1]+1)\n    # find the convex hull of the upgraded posts\n    hull = []\n    for p in posts:\n        while len(hull) >= 2 and (hull[-1][0]-hull[-2][0])*(p[1]-hull[-1][1]) > (hull[-1][1]-hull[-2][1])*(p[0]-hull[-1][0]):\n            hull.pop()\n        hull.append(p)\n    # count the number of onions in the convex hull\n    count = 0\n    for i in range(len(hull)):\n        for j in range(i+1, len(hull)):\n            if hull[j][0] <= hull[i][0]:\n                continue\n            for onion in onions:\n                if onion[0] <= hull[i][0] and onion[0] >= hull[j][0] and onion[1] <= max(hull[i][1], hull[j][1]) and onion[1] >= min(hull[i][1], hull[j][1]):\n                    count += 1\n                    break\n    return str(count)"
    },
    {
        "number": 3343,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, n = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, d = map(int, stdin.split())\n        points.append((x, d))\n    points.sort()\n    for i in range(1, n):\n        if points[i][0] <= points[i-1][0]:\n            return \"GHOST\"\n        if points[i][1] == \"C\":\n            points[i] = (points[i][0], \"W\")\n        else:\n            points[i] = (points[i][0], \"C\")\n    return \"SAFE\""
    },
    {
        "number": 3344,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, L = map(int, stdin.split())\n    x = list(map(float, stdin.split()))\n\n    # sort luggage positions\n    x.sort()\n\n    # binary search for maximum speed\n    left, right = 0.1, 10\n    while left + 1e-9 < right:\n        mid = (left + right) / 2\n        if all(abs(xi - xi2) > mid for xi, xi2 in zip(x[:-1], x[1:])):\n            right = mid\n        else:\n            left = mid\n    if left == 0.1:\n        return \"no fika\"\n    return f\"{left:.1f}\""
    },
    {
        "number": 3345,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    shadow = list(map(int, stdin.readline().split()))\n    lydia = list(map(int, stdin.readline().split()))\n    min_dist = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = ((shadow[i]-shadow[j])**2 + (shadow[i+1]-shadow[j+1])**2)**0.5\n            min_dist = min(min_dist, dist)\n    for i in range(m):\n        for j in range(i+1, m):\n            dist = ((lydia[i]-lydia[j])**2 + (lydia[i+1]-lydia[j+1])**2)**0.5\n            min_dist = min(min_dist, dist)\n    return str(min_dist)"
    },
    {
        "number": 3346,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split())\n    cars = []\n    for i in range(n):\n        d, a, r = stdin.readline().strip().split()\n        cars.append((d, int(a), int(r)))\n    cars.sort(key=lambda x: x[1])\n    count = 0\n    for i in range(n):\n        if cars[i][0] == 'W':\n            for j in range(i+1, n):\n                if cars[j][0] == 'E':\n                    if cars[j][1] - cars[i][1] - t >= 3:\n                        count += 1\n                        break\n    return str(count)"
    },
    {
        "number": 3347,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    stores = []\n    for i in range(n):\n        t, h = map(int, stdin.readline().strip().split())\n        stores.append((t, h))\n    stores.sort(key=lambda x: x[1])\n    max_stores = 1\n    current_height = 0\n    for t, h in stores:\n        if h > current_height:\n            max_stores += 1\n            current_height = h\n    return str(max_stores)"
    },
    {
        "number": 3348,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    a, b, c = map(int, stdin.split()[2:])\n    if a + b + c!= R * C:\n        return \"impossible\"\n    if a > R * C or b > R * C or c > R * C:\n        return \"impossible\"\n    if a + b + c > R * C:\n        return \"impossible\"\n    if a == 0 and b == 0 and c == 0:\n        return \"impossible\"\n    if a == 0:\n        return \"A\" * R * C\n    if b == 0:\n        return \"B\" * R * C\n    if c == 0:\n        return \"C\" * R * C\n    if a == R * C:\n        return \"A\" * R * C\n    if b == R * C:\n        return \"B\" * R * C\n    if c == R * C:\n        return \"C\" * R * C\n    if a == b or a == c or b == c:\n        return \"impossible\"\n    if a > b and a > c:\n        return \"A\" * R + \"B\" * R + \"C\" * R\n    if b > a and b > c:\n        return \"B\" * R + \"A\" * R + \"C\" * R\n    if c > a and c > b:\n        return \"C\" * R + \"A\" * R + \"B\" * R\n    if a == b and b == c:\n        return \"A\" * R + \"B\" * R + \"C\" * R\n    if a == b:\n        return \"A\" * R + \"B\" * R + \"C\" * (R - 1) + \"A\"\n    if a == c:\n        return \"A\" * R + \"C\" * R + \"B\" * (R - 1) + \"A\"\n    if b == c:\n        return \"B\" * R + \"C\" * R + \"A\" * (R - 1) + \"A\"\n    return \"impossible\""
    },
    {
        "number": 3349,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    words = set(stdin.readline().strip().split())\n    message = stdin.readline().strip()\n\n    # remove vowels and spaces from message\n    message = ''.join(c for c in message if c not in 'AEIOU ')\n\n    # find all possible reconstructions\n    reconstructions = []\n    for word in words:\n        if all(c in message for c in word):\n            reconstructions.append(word)\n\n    # choose the one with the largest overall number of vowels\n    reconstructions.sort(key=lambda x: sum(c in 'AEIOU' for c in x))\n    return''.join(reconstructions[-1])"
    },
    {
        "number": 3350,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    n = len(word)\n    max_power = 0\n    for i in range(n):\n        for j in range(i+4, n+1):\n            subword = word[i:j]\n            if subword == subword[::-1]:\n                power = len(subword)\n                if power > max_power:\n                    max_power = power\n    return max_power"
    },
    {
        "number": 3351,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rolls = [int(x) for x in stdin.split()[1:]]\n    scores = [0] * 13\n    used = [False] * 13\n    for i in range(n):\n        if not used[0]:\n            scores[0] += rolls[i]\n            used[0] = True\n        elif not used[1]:\n            if rolls[i] == 1:\n                scores[1] += 1\n            elif rolls[i] == 2:\n                scores[1] += 2\n            elif rolls[i] == 3:\n                scores[1] += 3\n            elif rolls[i] == 4:\n                scores[1] += 4\n            elif rolls[i] == 5:\n                scores[1] += 5\n            elif rolls[i] == 6:\n                scores[1] += 6\n            used[1] = True\n        elif not used[2]:\n            if rolls[i] == 2:\n                scores[2] += 2\n            elif rolls[i] == 3:\n                scores[2] += 3\n            elif rolls[i] == 4:\n                scores[2] += 4\n            elif rolls[i] == 5:\n                scores[2] += 5\n            elif rolls[i] == 6:\n                scores[2] += 6\n            used[2] = True\n        elif not used[3]:\n            if rolls[i] == 3:\n                scores[3] += 3\n            elif rolls[i] == 4:\n                scores[3] += 4\n            elif rolls[i] == 5:\n                scores[3] += 5\n            elif rolls[i] == 6:\n                scores[3] += 6\n            used[3] = True\n        elif not used[4]:\n            if rolls[i] == 4:\n                scores[4] += 4\n            elif rolls[i] == 5:\n                scores[4] += 5\n            elif rolls[i] == 6:\n                scores[4] += 6\n            used[4] = True\n        elif not used[5]:\n            if rolls[i] == 5:\n                scores[5] += 5\n            elif rolls[i] == 6:\n                scores[5] += 6\n            used[5] = True\n        elif not used[6]:\n            if rolls[i] == 6:\n                scores[6] += 6\n            used[6] = True\n        elif not used[7]:\n            if rolls[i] == 1:\n                scores[7] += 1\n            elif rolls[i] == 2:\n                scores[7] += 2\n            elif rolls[i] == 3:\n                scores[7] += 3\n            elif rolls[i] == 4:\n                scores[7] += 4\n            elif rolls[i] == 5:\n                scores[7] += 5\n            elif rolls[i] == 6:\n                scores[7] += 6\n            used[7] = True\n        elif not used[8]:\n            if rolls[i] == 2:\n                scores[8] += 2\n            elif rolls[i] == 3:\n                scores[8] += 3\n            elif rolls[i] == 4:\n                scores[8] += 4\n            elif rolls[i] == 5:\n                scores[8] += 5\n            elif rolls[i] == 6:\n                scores[8] += 6\n            used[8] = True\n        elif not used[9]:\n            if rolls[i] == 3:\n                scores[9] += 3\n            elif rolls[i] == 4:\n                scores[9] += 4\n            elif rolls[i] == 5:\n                scores[9] += 5\n            elif rolls[i] == 6:\n                scores[9] += 6\n            used[9] = True\n        elif not used[10]:\n            if rolls[i] == 4:\n                scores[10] += 4\n            elif rolls[i] == 5:\n                scores[10] += 5\n            elif rolls[i] == 6:\n                scores[10] += 6\n            used[10] = True\n        elif not used[11]:\n            if rolls[i] == 5:\n                scores[11] += 5\n            elif rolls[i] == 6:\n                scores[11] += 6\n            used[11] = True"
    },
    {
        "number": 3352,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    tree = [[] for _ in range(N)]\n    for i in range(N-1):\n        parent, child = map(int, stdin.split())\n        tree[parent-1].append(child-1)\n        tree[child-1].append(parent-1)\n    magical_colours = [0] * N\n    for i in range(N):\n        for j in tree[i]:\n            if i < j:\n                magical_colours[i] += magical_colours[j]\n    for _ in range(Q):\n        K, X = map(int, stdin.split())\n        if K == 0:\n            print(magical_colours[X-1])\n        else:\n            magical_colours[X-1] = K\n            for i in tree[X-1]:\n                if i < X-1:\n                    magical_colours[i] = K + magical_colours[i] - magical_colours[X-1]\n    return \"\""
    },
    {
        "number": 3353,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    P, R, L = map(int, stdin.split()[0:3])\n    logs = []\n    for i in range(L):\n        E1, E2 = map(int, stdin.split()[i*2:i*2+2])\n        logs.append((E1, E2))\n\n    # initialize variables\n    left_bank = set([i for i in range(R)])\n    right_bank = set([-1])\n    planks = set([i for i in range(R)])\n    time = 0\n    left_behind = []\n\n    # simulate crossing\n    while len(left_bank) > 0 and len(right_bank) > 0:\n        # update planks\n        planks = set([i for i in range(R) if i not in left_bank and i not in right_bank])\n\n        # update time\n        time += 1\n\n        # update left bank\n        if len(left_bank) == 1 and len(right_bank) == 0:\n            # all people have crossed\n            return str(time)\n        elif len(left_bank) == 1 and len(right_bank) == 1:\n            # some people must be left behind\n            left_behind = [i for i in range(R) if i not in left_bank and i not in right_bank]\n            return str(len(left_behind))\n        else:\n            # update left bank\n            for log in logs:\n                if log[0] in left_bank and log[1] in planks:\n                    left_bank.remove(log[0])\n                    planks.remove(log[1])\n                elif log[1] in left_bank and log[0] in planks:\n                    left_bank.remove(log[1])\n                    planks.remove(log[0])\n\n            # update right bank\n            for log in logs:\n                if log[0] in right_bank and log[1] in planks:\n                    right_bank.remove(log[0])\n                    planks.remove(log[1])\n                elif log[1] in right_bank and log[0] in planks:\n                    right_bank.remove(log[1])\n                    planks.remove(log[0])\n\n    # all people have crossed\n    return str(time)"
    },
    {
        "number": 3354,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, r, n, z = map(float, stdin.split())\n    area = 3.141592653589793 * s ** 2\n    max_pickles = int(area * z / (100 * 3.141592653589793 * r ** 2))\n    return str(min(n, max_pickles))"
    },
    {
        "number": 3355,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[0:2])\n    p = list(map(int, stdin.readline().split()))\n    t = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n    dp = [[0 for _ in range(n+3)] for _ in range(n+3)]\n    for i in range(n+3):\n        dp[i][i] = 0\n    for k in range(1, n+3):\n        for i in range(1, n+3-k):\n            j = i+k\n            dp[i][j] = float('-inf')\n            for m in range(i, j+1):\n                temp = dp[i][m] + dp[m+1][j] + p[i-1]*t[m-1]\n                if d[i-1]!= -1 and m-i+1 > d[i-1]:\n                    temp -= p[i-1]*t[i-1]\n                dp[i][j] = max(dp[i][j], temp)\n    if dp[1][n+2] == 0:\n        return \"0\\n\"\n    tasks = []\n    i, j = 1, n+2\n    while i < j:\n        if dp[i][j] == dp[i][i+1] + dp[i+1][j]:\n            tasks.append(i)\n            i += 1\n        else:\n            tasks.append(j)\n            j -= 1\n    tasks.sort()\n    return f\"{dp[1][n+2]}\\n{tasks[0]} {' '.join(map(str, tasks[1:]))}\\n\""
    },
    {
        "number": 3356,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline())\n    rooms = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        a, b = map(int, stdin.readline().split())\n        rooms[a].append(b)\n        rooms[b].append(a)\n\n    # find farthest rooms\n    farthest = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            dist = 0\n            visited = set()\n            queue = [(i, 0)]\n            while queue:\n                curr, d = queue.pop(0)\n                if curr == j:\n                    dist = d\n                    break\n                if curr not in visited:\n                    visited.add(curr)\n                    for neighbor in rooms[curr]:\n                        queue.append((neighbor, d+1))\n            farthest = max(farthest, dist)\n\n    # find tunnels to close\n    closed = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if i in rooms[j] or j in rooms[i]:\n                closed.add((i, j))\n\n    # find tunnels to open\n    opened = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if i not in rooms[j] and j not in rooms[i]:\n                opened.add((i, j))\n\n    # output result\n    print(farthest)\n    print(*closed.pop())\n    print(*opened.pop())"
    },
    {
        "number": 3357,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    buildings = []\n    for i in range(1, n+1):\n        x, h = map(int, lines[i].split())\n        buildings.append((x, h))\n    buildings.sort()\n    sunlight = 0\n    for i in range(n):\n        x, h = buildings[i]\n        sunlight += (180/3.141592653589793) * (x + buildings[i-1][0]) * h\n    return '{:.4f}'.format(sunlight)"
    },
    {
        "number": 3358,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    instructions = []\n    instructions.append(\"ST A\")\n    instructions.append(\"ST X\")\n    instructions.append(\"PH A\")\n    instructions.append(\"PH X\")\n    instructions.append(\"AD\")\n    instructions.append(\"PL Y\")\n    instructions.append(\"DI Y\")\n    for i in range(n):\n        instructions.append(\"PH A\")\n        instructions.append(\"PH X\")\n        instructions.append(\"AD\")\n        instructions.append(\"PL Y\")\n        instructions.append(\"DI Y\")\n    return \"\\n\".join(instructions)"
    },
    {
        "number": 3359,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, R, C = map(int, stdin.split()[0:3])\n    L = []\n    for i in range(R):\n        L.append(list(map(lambda x: int(x, 16), stdin.split()[i*C+3:i*C+C+3])))\n\n    # Count number of stellar bodies\n    count = 0\n    for r in range(R):\n        for c in range(C):\n            if L[r][c]!= 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3360,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    rules = []\n    for i in range(1, n+1):\n        rule = lines[i].strip().split(' -> ')\n        rules.append((rule[0], rule[1]))\n    start_var = rules[0][0]\n    # generate all strings that can be generated by the grammar\n    strings = set()\n    for rule in rules:\n        for s in generate_strings(rule[1]):\n            strings.add(s)\n    # search for matching substrings\n    for line in lines[n+1:]:\n        longest = ''\n        for s in strings:\n            if s in line and len(s) > len(longest):\n                longest = s\n        if longest:\n            print(longest)\n        else:\n            print('NONE')\n    return ''\n\ndef"
    },
    {
        "number": 3361,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    distances = [[0] * n for _ in range(n)]\n    for i in range(n):\n        distances[i][i] = 0\n        for j in range(i+1, n):\n            distances[i][j] = int(stdin.readline().split()[j-i-1])\n            distances[j][i] = distances[i][j]\n    dp = [[0] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i] = distances[0][i]\n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(n):\n                    if not mask & (1 << j):\n                        dp[i][mask] = max(dp[i][mask], dp[j][mask ^ (1 << j)] + distances[j][i])\n    return str(dp[0][(1 << n) - 1])"
    },
    {
        "number": 3362,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    A, F = map(int, stdin.readline().split())\n    L, W = map(int, stdin.readline().split())\n    map_ = []\n    for i in range(L):\n        map_.append(stdin.readline().strip())\n\n    # Check if Elsa can reach the goal\n    def can_reach_goal(x, y, step_length):\n        if map_[y][x] == 'G':\n            return True\n        if map_[y][x] == 'B':\n            return False\n        if step_length == 0:\n            return False\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < W and 0 <= ny < L:\n                if can_reach_goal(nx, ny, step_length - 1):\n                    return True\n        return False\n\n    if can_reach_goal(map_.index('S'), 0, A):\n        # Check if the father can reach the goal\n        def can_reach_goal_father(x, y, step_length):\n            if map_[y][x] == 'G':\n                return True\n            if map_[y][x] == 'B':\n                return False\n            if step_length == 0:\n                return False\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < W and 0 <= ny < L:\n                    if can_reach_goal_father(nx, ny, step_length - 1):\n                        return True\n            return False\n\n        if can_reach_goal_father(map_.index('S'), 0, F):\n            return \"SUCCESS\"\n        else:\n            return \"GO FOR IT\"\n    else:\n        return \"NO WAY\""
    },
    {
        "number": 3363,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    courses = list(map(int, stdin.readline().split()))\n    max_calories = 0\n    for i in range(n):\n        if i == 2:\n            max_calories += courses[i]\n        else:\n            max_calories += courses[i] * 2**(i-1)\n    return str(max_calories)"
    },
    {
        "number": 3364,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    sets = [-1] * n\n    for i in range(q):\n        op, a, b = stdin.split()\n        a, b = int(a), int(b)\n        if op == \"=\":\n            sets[a] = b\n        else:\n            if sets[a] == sets[b]:\n                print(\"yes\")\n            else:\n                print(\"no\")\n    return \"\""
    },
    {
        "number": 3365,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    v = list(map(int, stdin.split()[2:]))\n    dp = [[0]*n for _ in range(k)]\n    for i in range(n):\n        dp[0][i] = v[i]\n    for i in range(1, k):\n        for j in range(n):\n            for l in range(j):\n                if v[j] % v[l] == 0 and dp[i-1][l] > 0:\n                    dp[i][j] = max(dp[i][j], dp[i-1][l])\n            if dp[i-1][j] > 0:\n                dp[i][j] = max(dp[i][j], v[j])\n    return str(min(dp[k-1]))"
    },
    {
        "number": 3366,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    S = 0\n    for i in range(L, R+1):\n        iterations = 0\n        while i!= 1:\n            if i % 2 == 0:\n                i //= 2\n            else:\n                i += 1\n            iterations += 1\n        S += iterations\n        S %= MOD\n    return str(S)"
    },
    {
        "number": 3367,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    t, n = map(int, stdin.split())\n    questions = []\n    for i in range(n):\n        question, answer = stdin.split('\\n')[i].split()\n        questions.append((question, answer))\n\n    # simulate quiz\n    score = 0\n    for i in range(t):\n        for question, answer in questions:\n            if i == 0:\n                score += 1\n            elif i == t-1:\n                score += 1\n            else:\n                score += 0.5\n\n    return str(score)"
    },
    {
        "number": 3368,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    enclosures = []\n    for i in range(n):\n        enclosure = stdin.split()[i].split()\n        enclosure[1] = int(enclosure[1])\n        enclosure.append([])\n        for j in range(2, len(enclosure)):\n            enclosure[2].append(enclosure[j])\n        enclosures.append(enclosure)\n    for i in range(m):\n        animal = stdin.split()[n+i].split()\n        animal_type = animal[0]\n        enclosure_type = animal[1]\n        if animal_type not in enclosures[enclosures.index([enclosure_type, 0, []])][2]:\n            return \"IMPOSSIBLE\"\n    for enclosure in enclosures:\n        if enclosure[1]!= len(enclosure[2]):\n            return \"POSSIBLE\"\n    return \"FALSE ALARM\""
    },
    {
        "number": 3369,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.split('\\n')[0])\n    digits = stdin.split('\\n')[1].split()\n    correlations = []\n    for i in range(p-3):\n        if digits[i] == '4' and digits[i+1] == '4' and digits[i+2] == '4':\n            correlations.append((i, i+1, i+2))\n        if digits[i] == '4' and digits[i+1] == '4' and digits[i+3] == '3':\n            correlations.append((i, i+1, i+3))\n        if digits[i] == '4' and digits[i+2] == '4' and digits[i+3] == '3':\n            correlations.append((i, i+2, i+3))\n        if digits[i] == '4' and digits[i+2] == '4' and digits[i+4] == '3':\n            correlations.append((i, i+2, i+4))\n        if digits[i] == '4' and digits[i+3] == '4' and digits[i+4] == '3':\n            correlations.append((i, i+3, i+4))\n    if len(correlations) == 0:\n        return 'random sequence'\n    else:\n        correlations.sort(key=lambda x: (x[0], x[1]))\n        return f'triple correlation {digits[correlations[0][0]]}({correlations[0][1]-correlations[0][0]}){digits[correlations[0][2]]}({correlations[0][2]-correlations[0][1]}){digits[correlations[0][2]+1]} found'"
    },
    {
        "number": 3370,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, k = map(float, lines[0].split())\n    heights = list(map(float, lines[1:]))\n    heights = [0] + heights + [0]\n    for i in range(1, N+2):\n        if i == 1 or i == N+1:\n            continue\n        if heights[i] < (heights[i-1] + heights[i+1]) / 2 + k:\n            heights[i] = (heights[i-1] + heights[i+1]) / 2 + k\n    return str(max(heights[1:N+1]))"
    },
    {
        "number": 3371,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    pairs = set()\n    for _ in range(c):\n        a, b, y = map(int, stdin.split())\n        pairs.add((a, b))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if (i, j) not in pairs and (j, i) not in pairs:\n                pairs.add((i, j))\n    for i in range(1, n):\n        for j in range(i+1,"
    },
    {
        "number": 3372,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, s, t = map(int, stdin.split())\n    flights = [[] for _ in range(N)]\n    for i in range(N):\n        line = stdin.readline().strip()\n        if line[0] == 'N':\n            flights[i] = list(map(int, line.split()[1:]))\n        else:\n            for j in map(int, line.split()[1:]):\n                flights[i].append(j)\n\n    # bfs to find shortest path\n    queue = [(s, 0)]\n    visited = set()\n    while queue:\n        curr, cost = queue.pop(0)\n        if curr == t:\n            return str(cost)\n        if curr in visited:\n            continue\n        visited.add(curr)\n        for next_ in flights[curr]:\n            queue.append((next_, cost + 1))\n\n    return \"impossible\""
    },
    {
        "number": 3373,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pieces = [stdin.readline().strip() for _ in range(n)]\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i):\n            if is_balanced(pieces[j] + pieces[i]):\n                dp[i] = max(dp[i], dp[j] + len(pieces[j]) + len(pieces[i]))\n    return dp[n]\n\ndef"
    },
    {
        "number": 3374,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.splitlines()[0].split())\n    systems = []\n    for i in range(1, n+1):\n        g, t = stdin.splitlines()[i].split()\n        systems.append((int(g), t))\n    links = []\n    for i in range(e):\n        a, b = map(int, stdin.splitlines()[i+n+1].split())\n        links.append((a-1, b-1))\n    # gravity dispersal\n    for i in range(n):\n        g, t = systems[i]\n        if t == 'h':\n            for j in range(len(links)):\n                if links[j][0] == i or links[j][1] == i:\n                    systems[links[j][0]][0] += 1\n                    systems[links[j][1]][0] += 1\n    # calculate UW distance\n    distances = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if systems[i][1] == 'a' and systems[j][1] == 'h':\n                g1, g2 = systems[i][0], systems[j][0]\n                cap = g2+g1\n                pot = g2-g1\n                ind = g2*g1\n                distances.append(abs(pot*(cap*cap-ind)))\n    return str(min(distances))"
    },
    {
        "number": 3375,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    V, E = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # count spanning unicyclic subgraphs\n    count = 0\n    for i in range(1, V):\n        # check if i-th vertex is in a cycle\n        visited = [False] * V\n        stack = [i]\n        while stack:\n            v = stack.pop()\n            if visited[v]:\n                continue\n            visited[v] = True\n            if v == i:\n                count += 1\n                break\n            for u in range(V):\n                if not visited[u] and (u, v) in edges or (v, u) in edges:\n                    stack.append(u)\n                    break\n\n    # output result\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3376,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    f, n = map(int, stdin.split())\n    families = []\n    for i in range(f):\n        s, *c, strongest = stdin.split()\n        s = int(s)\n        c = [int(x) for x in c]\n        families.append((s, c, strongest))\n    nudgem_times = []\n    for i in range(n):\n        t, p = stdin.split()\n        t = int(t)\n        nudgem_times.append((t, p))\n\n    # sort nudgem times by time\n    nudgem_times.sort()\n\n    # initialize variables\n    xp = 0\n    evolved = set()\n    evolved_xp = 0\n    evolved_time = None\n    evolved_strongest = None\n\n    # iterate over nudgem times\n    for t, p in nudgem_times:\n        # check if evolved nudgem is strongest in family\n        family = None\n        for i, (s, c, strongest) in enumerate(families):\n            if p == strongest:\n                family = i\n                break\n        if family is None:\n            continue\n\n        # check if evolved nudgem is strongest in family\n        if p not in evolved:\n            # earn 100 xp for catching nudgem\n            xp += 100\n            # earn 3 candies for catching nudgem\n            xp += 3 * sum(c[i] for i in range(len(c)) if i % 2 == family % 2)\n            # add evolved nudgem to set of evolved nudgems\n            evolved.add(p)\n            # update evolved xp\n            evolved_xp += 100\n            evolved_time = t\n            evolved_strongest = p\n        else:\n            # check if evolved nudgem is strongest in family\n            if p == evolved_strongest:\n                # check if evolved nudgem is evolvable\n                for i, (s, c, strongest) in enumerate(families):\n                    if p == strongest:\n                        break\n                if i == len(families) - 1:\n                    continue\n                # check if enough candies are available\n                if sum(c[i] for i in range(len(c)) if i % 2 == family % 2) >= c[i+1]:\n                    # earn 500 xp for evolving nudgem\n                    xp += 500\n                    # earn candies for evolving nudgem\n                    xp += c[i+1]\n                    # remove evolved nudgem from set of evolved nudgems\n                    evolved.remove(p)\n                    # update evolved xp\n                    evolved_xp -= 100\n                    evolved_time = None\n                    evolved_strongest = None\n\n    # check if blessed egg is active\n    if evolved_time is not None and evolved_time + 1800 > nudgem_times[-1][0]:\n        # double xp if blessed egg is active\n        xp *= 2\n\n    return str(xp)"
    },
    {
        "number": 3377,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    pegs = [set() for _ in range(n)]\n    for i, p in enumerate(points):\n        for j in p:\n            pegs[j].add(i)\n    t, *steps = map(int, stdin.split())\n    dry_pegs = 0\n    for i in range(t):\n        if steps[i] == 1:\n            if not pegs[i]:\n                return '-1'\n            for j in pegs[i]:\n                if j in pegs[i-1]:\n                    dry_pegs += 1\n                    pegs[j].remove(i-1)\n                    pegs[i-1].remove(j)\n                    break\n            else:\n                return '-1'\n        else:\n            if not pegs[i-1]:\n                return '-1'\n            for j in pegs[i-1]:\n                if j in pegs[i]:\n                    dry_pegs -= 1\n                    pegs[j].remove(i)\n                    pegs[i].remove(j)\n                    break\n            else:\n                return '-1'\n    if dry_pegs * 10 <= t:\n        return '-1'\n    wet_pegs = dry_pegs\n    for i in range(t):\n        if steps[i] == 1:\n            if not pegs[i]:\n                return '-1'\n            for j in pegs[i]:\n                if j in pegs[i-1]:\n                    wet_pegs += 1\n                    pegs[j].remove(i-1)\n                    pegs[i-1].remove(j)\n                    break\n            else:\n                return '-1'\n        else:\n            if not pegs[i-1]:\n                return '-1'\n            for j in pegs[i-1]:\n                if j in pegs[i]:\n                    wet_pegs -= 1\n                    pegs[j].remove(i)\n                    pegs[i].remove(j)\n                    break\n            else:\n                return '-1'\n    return wet_pegs"
    },
    {
        "number": 3378,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+d]))\n    m = int(stdin.split()[2+d])\n    fares = []\n    for i in range(m):\n        s, d, t, p = map(int, stdin.split()[2+d+i*4:2+d+(i+1)*4])\n        fares.append((s, d, t, p))\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n    for k in range(1, n):\n        for i in range(n-k):\n            j = i + k\n            dp[i][j] = float('inf')\n            for s, d, t, p in fares:\n                if s <= i and j <= d:\n                    if t == 'O':\n                        dp[i][j] = min(dp[i][j], dp[s-1][d-1] + p)\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[s-1][d-1] + 2*p)\n    return dp[0][d-1]\n\nstdin = \"2 5\\n1 2 1 2 1\\n4\\n1 2 R 6\\n1 2 O 3\\n2 1 O 3\\n1 2 R 5\"\nprint(solution(stdin)) # Output: 10"
    },
    {
        "number": 3379,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        x, y = map(int, stdin.split()[0:2])\n        graph[x].append(y)\n    indegree = [0] * n\n    for i in range(n):\n        for j in graph[i]:\n            indegree[j] += 1\n    queue = []\n    for i in range(n):\n        if indegree[i] == 0:\n            queue.append(i)\n    count = 0\n    while queue:\n        count += 1\n        size = len(queue)\n        for i in range(size):\n            node = queue.pop(0)\n            for j in graph[node]:\n                indegree[j] -= 1\n                if indegree[j] == 0:\n                    queue.append(j)\n    return str(count)"
    },
    {
        "number": 3380,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    p = 1\n    for i in range(N):\n        p *= (N-i)/(N-1)\n    return str(p)"
    },
    {
        "number": 3381,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.sort()\n    for i in range(n):\n        print(points[i][0], points[i][1])\n    return \"\""
    },
    {
        "number": 3382,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    base_values = list(map(int, stdin.split()))\n    grade = 0\n    for i in range(len(base_values)):\n        for j in range(i+1, len(base_values)):\n            if base_values[i] * base_values[j] == 24:\n                grade += 1\n            elif base_values[i] + base_values[j] == 24:\n                grade += 1\n            elif base_values[i] - base_values[j] == 24:\n                grade += 1\n            elif base_values[j] - base_values[i] == 24:\n                grade += 1\n            elif base_values[i] / base_values[j] == 24:\n                grade += 1\n            elif base_values[j] / base_values[i] == 24:\n                grade += 1\n    if grade == 0:\n        return \"impossible\"\n    else:\n        return str(grade)"
    },
    {
        "number": 3383,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    t = list(map(int, stdin.readline().split()))\n    u = []\n    for i in range(k):\n        u.append(list(map(int, stdin.readline().split())))\n    dp = [[0] * k for _ in range(n+1)]\n    for i in range(k):\n        dp[1][i] = t[i]\n    for i in range(2, n+1):\n        for j in range(k):\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + u[j][j] + t[j])\n    if dp[n][k-1] <= 0:\n        return \"0\"\n    else:\n        return str(dp[n][k-1] // (a + b))"
    },
    {
        "number": 3384,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    handsome_numbers = []\n    for i in range(n-1, 0, -1):\n        if i % 2 == 0 and i // 10 % 2 == 0:\n            handsome_numbers.append(i)\n        elif i % 2 == 1 and i // 10 % 2 == 1:\n            handsome_numbers.append(i)\n    if not handsome_numbers:\n        return str(n)\n    handsome_numbers.sort()\n    return''.join(map(str, handsome_numbers))"
    },
    {
        "number": 3385,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pass"
    },
    {
        "number": 3386,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, M = map(int, stdin.split())\n\n    # Initialize variables\n    visited = set()\n    to_visit = [(0, 0)]\n    visited.add((0, 0))\n\n    # DFS to find a tour\n    while to_visit:\n        curr = to_visit.pop()\n        r, c = curr\n        if r == N-1 and c == M-1:\n            # Found a tour\n            break\n        # Add adjacent squares to to_visit\n        if r > 0 and (r-1, c) not in visited:\n            to_visit.append((r-1, c))\n            visited.add((r-1, c))\n        if r < N-1 and (r+1, c) not in visited:\n            to_visit.append((r+1, c))\n            visited.add((r+1, c))\n        if c > 0 and (r, c-1) not in visited:\n            to_visit.append((r, c-1))\n            visited.add((r, c-1))\n        if c < M-1 and (r, c+1) not in visited:\n            to_visit.append((r, c+1))\n            visited.add((r, c+1))\n\n    # Check if a tour was found\n    if (N-1, M-1) not in visited:\n        return -1\n\n    # Print tour\n    tour = [(N-1, M-1)]\n    while tour[-1]!= (0, 0):\n        r, c = tour[-1]\n        if r > 0 and (r-1, c) in visited:\n            tour.append((r-1, c))\n        elif r < N-1 and (r+1, c) in visited:\n            tour.append((r+1, c))\n        elif c > 0 and (r, c-1) in visited:\n            tour.append((r, c-1))\n        elif c < M-1 and (r, c+1) in visited:\n            tour.append((r, c+1))\n\n    # Check if tour satisfies constraints\n    for i in range(len(tour)-1):\n        p, q = tour[i], tour[i+1]\n        if abs(p[0]-q[0]) + abs(p[1]-q[1]) not in [2, 3]:\n            return -1\n\n    # Print tour\n    for p in tour:\n        print(p[0], p[1])\n\n    return \"\""
    },
    {
        "number": 3387,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    d = list(map(int, stdin.readline().split()))\n\n    # calculate the \u2018fair share\u2019 bandwidth\n    y = [t * d[i] / sum(d) for i in range(n)]\n\n    # calculate the maximum bandwidth for each species\n    max_b = [min(b[i], t // n * d[i]) for i in range(n)]\n\n    # calculate the minimum bandwidth for each species\n    min_b = [max(a[i], t // n * d[i]) for i in range(n)]\n\n    # calculate the optimal allocation for each species\n    x = [(max_b[i] + min_b[i]) / 2 for i in range(n)]\n\n    # calculate the error for each species\n    error = [sum([(x[i] - y[i]) ** 2 / y[i] for i in range(n)])]\n\n    # return the optimal allocation and the error\n    return '\\n'.join(map(str, x)) + '\\n' + '\\n'.join(map(str, error))"
    },
    {
        "number": 3388,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = list(map(int, stdin.readline().strip().split()))\n    max_points = max(points)\n    count = 0\n    for i in range(n):\n        if points[i] == max_points:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3389,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    videos = stdin.split()[2]\n    count = 0\n    for i in range(n):\n        if videos[i] == videos[i-1]:\n            continue\n        count += 1\n    return count"
    },
    {
        "number": 3390,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n    visited = [False] * (n+1)\n    def dfs(node, count):\n        if visited[node]:\n            return count\n        visited[node] = True\n        for neighbor in graph[node]:\n            count = dfs(neighbor, count)\n        return count + 1\n    max_count = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            count = dfs(i, 0)\n            max_count = max(max_count, count)\n    return str(max_count)"
    },
    {
        "number": 3391,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    houses = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        houses.append((x, y))\n    for i in range(q):\n        a, b = map(int, stdin.readline().split())\n        points = [(x, y) for x, y in houses if a <= i <= b]\n        if len(points) <= 1:\n            print(0)\n            continue\n        xs, ys = zip(*points)\n        x_min, x_max = min(xs), max(xs)\n        y_min, y_max = min(ys), max(ys)\n        side = max(x_max - x_min, y_max - y_min)\n        print(side)\n    return \"\""
    },
    {
        "number": 3392,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline())\n    heights = []\n    for i in range(n):\n        heights.append(list(map(int, stdin.readline().split())))\n    growth_speeds = []\n    for i in range(n):\n        growth_speeds.append(list(map(int, stdin.readline().split())))\n\n    # calculate growth\n    for i in range(n):\n        for j in range(n):\n            for k in range(2):\n                if i+k < n and j+k < n:\n                    heights[i][j] += growth_speeds[i+k][j+k]\n\n    # find connected components\n    visited = [[False] * n for _ in range(n)]\n    groups = []\n    for i in range(n):\n        for j in range(n):\n            if not visited[i][j]:\n                group = []\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if not visited[x][y]:\n                        visited[x][y] = True\n                        group.append((x, y))\n                        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            if 0 <= x+dx < n and 0 <= y+dy < n:\n                                stack.append((x+dx, y+dy))\n                groups.append(group)\n\n    # find largest connected component\n    max_size = 0\n    for group in groups:\n        size = len(group)\n        if size > max_size:\n            max_size = size\n\n    return str(max_size)"
    },
    {
        "number": 3393,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    courses = []\n    for i in range(n):\n        name, difficulty = stdin.split()\n        difficulty = int(difficulty)\n        courses.append((name, difficulty))\n    courses.sort(key=lambda x: x[1])\n    taken = set()\n    total_difficulty = 0\n    for i in range(k):\n        for j in range(n):\n            if courses[j][0] not in taken and (courses[j][0].endswith('1') or courses[j][0].endswith('2')):\n                taken.add(courses[j][0])\n                total_difficulty += courses[j][1]\n                break\n    return str(total_difficulty)"
    },
    {
        "number": 3394,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.readline().split())\n    roads = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.readline().split())\n        roads.append((u, v, d))\n    k = int(stdin.readline())\n    orders = []\n    for _ in range(k):\n        s, u, t = map(int, stdin.readline().split())\n        orders.append((s, u, t))\n\n    # preprocess\n    adj = [[] for _ in range(n+1)]\n    for u, v, d in roads:\n        adj[u].append((v, d))\n        adj[v].append((u, d))\n    dist = [float('inf')] * (n+1)\n    dist[1] = 0\n\n    # dijkstra\n    pq = [(0, 1)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heapq.heappush(pq, (dist[v], v))\n\n    # compute longest wait time\n    longest_wait = 0\n    for s, u, t in orders:\n        if dist[u] == float('inf'):\n            return 'impossible'\n        wait = max(0, t - dist[u] - s)\n        longest_wait = max(longest_wait, wait)\n\n    return longest_wait"
    },
    {
        "number": 3395,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    ores = list(map(int, stdin.split()[3:3+m]))\n    coals = list(map(int, stdin.split()[3+m:3+m+k]))\n    graph = [[] for _ in range(n+1)]\n    for i in range(n):\n        a, b = map(int, stdin.split()[3+m+k+i].split())\n        for j in range(a):\n            graph[i+1].append(b+j)\n    visited = [False] * (n+1)\n    def dfs(node, count):\n        if visited[node]:\n            return False\n        visited[node] = True\n        if node in coals:\n            return True\n        for nei in graph[node]:\n            if dfs(nei, count+1):\n                return True\n        return False\n    for ore in ores:\n        if dfs(ore, 1):\n            return str(count)\n    return \"impossible\""
    },
    {
        "number": 3396,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    posts = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        posts.append((x, y))\n    rope_length = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dx = abs(posts[i][0] - posts[j][0])\n            dy = abs(posts[i][1] - posts[j][1])\n            rope_length += max(dx, dy)\n    return f\"{rope_length:.2f}\""
    },
    {
        "number": 3397,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    times = []\n    for i in range(N):\n        times.append(list(map(int, stdin.split())))\n\n    # calculate minimum waiting time\n    T = 0\n    for i in range(N):\n        t = max(times[i])\n        for j in range(M):\n            if times[i][j] == t:\n                T += t - times[i][j]\n                break\n\n    return str(T)"
    },
    {
        "number": 3398,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n_r, n_c, n, m = map(int, stdin.readline().split())\n    files = list(map(int, stdin.readline().split()))\n    files = [(files[i], files[i+1]) for i in range(0, len(files), 2)]\n    # find minimum number of moves\n    moves = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if files[i][0] == files[j][0] or files[i][1] == files[j][1]:\n                continue\n            if abs(files[i][0] - files[j][0]) + abs(files[i][1] - files[j][1]) <= 2:\n                moves += 1\n    return str(moves)"
    },
    {
        "number": 3399,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, stdin.readline().strip())))\n\n    # Check if there is a solution\n    if not is_valid(grid):\n        return \"impossible\"\n\n    # Divide the languages\n    arwegian = []\n    banish = []\n    cwedish = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                arwegian.append((i, j))\n            elif grid[i][j] == 2:\n                banish.append((i, j))\n                cwedish.append((i, j))\n\n    # Construct the grids\n    grid1 = [['A' if (i, j) in arwegian else '.' for j in range(m)] for i in range(n)]\n    grid2 = [['B' if (i, j) in banish else '.' for j in range(m)] for i in range(n)]\n    grid3 = [['C' if (i, j) in cwedish else '.' for j in range(m)] for i in range(n)]\n\n    # Construct the output\n    output = \"\"\n    for i in range(n):\n        for j in range(m):\n            output += grid1[i][j]\n        output += '\\n'\n    output += '\\n'\n    for i in range(n):\n        for j in range(m):\n            output += grid2[i][j]\n        output += '\\n'\n    output += '\\n'\n    for i in range(n):\n        for j in range(m):\n            output += grid3[i][j]\n        output += '\\n'\n    return output\n\ndef"
    },
    {
        "number": 3400,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, A, R, T = map(int, stdin.split())\n    trips = []\n    for i in range(T):\n        d, p = map(int, stdin.split())\n        a = list(map(int, stdin.split()))\n        trips.append((d, p, a))\n\n    # compute shortest time\n    dist = [float('inf')] * N\n    dist[A-1] = 0\n    for d, p, a in trips:\n        for i in range(p-1):\n            dist[a[i]-1] = min(dist[a[i]-1], dist[a[i+1]-1] + d)\n    return dist[R-1]"
    },
    {
        "number": 3401,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, q = map(int, stdin.split())\n    hills = []\n    for i in range(n):\n        x, y, h = map(int, stdin.split())\n        hills.append((x, y, h))\n    springs = list(map(int, stdin.readline().split()))\n    towns = list(map(int, stdin.readline().split()))\n    aqueducts = []\n    for i in range(s):\n        aqueducts.append((i, springs[i]-1, towns[i]-1))\n    for i in range(t):\n        aqueducts.append((s+i, towns[i]-1, i))\n    aqueducts.sort(key=lambda x: x[1])\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for aqueduct in aqueducts:\n        u, v, w = aqueduct\n        for i in range(n):\n            if dp[i]!= float('inf'):\n                for j in range(n):\n                    if dp[j]!= float('inf'):\n                        if abs(hills[i][0]-hills[j][0]) + abs(hills[i][1]-hills[j][1]) <= q:\n                            dp[j] = min(dp[j], dp[i] + abs(hills[i][2]-hills[j][2]))\n    if dp[towns[0]-1] == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return dp[towns[0]-1]"
    },
    {
        "number": 3402,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    s = stdin.split('\\n')[0]\n    t = stdin.split('\\n')[1].split()\n    t += stdin.split('\\n')[2].split()\n    k = int(stdin.split('\\n')[3])\n    m = int(stdin.split('\\n')[4])\n    ms = [int(x) for x in stdin.split('\\n')[5].split()]\n\n    # generate password\n    f = lambda x: ''.join([t[ord(c)-ord('a')] for c in x])\n    for _ in range(k):\n        s = f(s)\n\n    # find forgotten letters\n    result = []\n    for i in range(m):\n        result.append(s[ms[i]-1])\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3403,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, q = map(int, stdin.readline().split())\n    words = [stdin.readline().strip() for _ in range(n)]\n    queries = [stdin.readline().strip() for _ in range(q)]\n\n    # calculate steps for each query\n    steps = []\n    for query in queries:\n        steps.append(sum(min(len(query), len(word)) for word in words if query.startswith(word)))\n\n    # output steps\n    return '\\n'.join(map(str, steps))"
    },
    {
        "number": 3404,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, X = map(int, stdin.split())\n    message = stdin.split('\\n')[1]\n\n    # define f(x)\n    def f(x):\n        return (33 * x + 1) % (2 ** 20)\n\n    # create X by X grid\n    grid = [[f(0)]]\n    for i in range(1, X + 1):\n        row = [f(grid[-1][-1])]\n        for j in range(1, X - i + 1):\n            row.append(f(row[-1]))\n        grid.append(row)\n\n    # sum columns\n    column_sums = [sum(grid[i][j] for i in range(X)) % (2 ** 20) for j in range(X)]\n\n    # convert to base 27\n    pad = ''.join(str(column_sums[i] % 27) for i in range(X))\n\n    # decrypt message\n    decrypted = ''\n    for i in range(N):\n        if message[i] =='':\n            decrypted +=''\n        else:\n            shift = int(pad[i % X])\n            decrypted += chr((ord(message[i]) - 65 + shift) % 27 + 65)\n\n    return decrypted"
    },
    {
        "number": 3405,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = float(stdin)\n    result = []\n    for i in range(1, 100000000):\n        if str(i)[0] == '0':\n            continue\n        if i * X == int(str(i)[1:] + str(i)[0]):\n            result.append(i)\n    if not result:\n        return \"No solution\"\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3406,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    nazi_points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        nazi_points.append((x, y))\n    s = int(stdin.readline().strip())\n    soviet_points = []\n    for i in range(s):\n        x, y = map(int, stdin.readline().strip().split())\n        soviet_points.append((x, y))\n\n    # check if any castle is in danger\n    danger_count = 0\n    for castle in soviet_points:\n        # check if castle is inside any quadrilateral\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        if (nazi_points[i][0] - nazi_points[j][0]) * (castle[1] - nazi_points[j][1]) + (castle[0] - nazi_points[j][0]) * (nazi_points[i][1] - nazi_points[j][1]) == 0 and (nazi_points[i][0] - nazi_points[k][0]) * (castle[1] - nazi_points[k][1]) + (castle[0] - nazi_points[k][0]) * (nazi_points[i][1] - nazi_points[k][1]) == 0 and (nazi_points[j][0] - nazi_points[k][0]) * (castle[1] - nazi_points[k][1]) + (castle[0] - nazi_points[k][0]) * (nazi_points[j][1] - nazi_points[k][1]) == 0 and (nazi_points[i][0] - nazi_points[l][0]) * (castle[1] - nazi_points[l][1]) + (castle[0] - nazi_points[l][0]) * (nazi_points[i][1] - nazi_points[l][1]) == 0 and (nazi_points[j][0] - nazi_points[l][0]) * (castle[1] - nazi_points[l][1]) + (castle[0] - nazi_points[l][0]) * (nazi_points[j][1] - nazi_points[l][1]) == 0 and (nazi_points[k][0] - nazi_points[l][0]) * (castle[1] - nazi_points[l][1]) + (castle[0] - nazi_points[l][0]) * (nazi_points[k][1] - nazi_points[l][1]) == 0:\n                            danger_count += 1\n                            break\n        # check if castle is on the border of any quadrilateral\n        for i in range(n):\n            for j in range(i+1, n):\n                if (nazi_points[i][0] - nazi_points[j][0]) * (castle[1] - nazi_points[j][1]) + (castle[0] - nazi_points[j][0]) * (nazi_points[i][1] - nazi_points[j][1]) == 0 and (nazi_points[i][0] - nazi_points[j][0]) * (nazi_points[j][1] - soviet_points[0][1]) + (nazi_points[j][0] - soviet_points[0][0]) * (castle[1] - nazi_points[j][1]) == 0:\n                    danger_count += 1\n                    break\n                if (nazi_points[i][0] - nazi_points[j][0]) * (castle[1] - nazi_points[j][1]) + (castle[0] - nazi_points[j][0]) * (nazi_points[i][1] - nazi_points[j][1]) == 0 and (nazi_points[i][0] - nazi_points[j][0]) * (nazi_points[j][1] - soviet_points[0][1]) + (nazi_points[j][0] - soviet_points[0][0]) *"
    },
    {
        "number": 3407,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for i in range(n-1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    def dfs(node, parent, visited, dist, pos):\n        visited.add(node)\n        for child in graph[node]:\n            if child == parent:\n                continue\n            if child in visited:\n                return False\n            if not dfs(child, node, visited, dist, pos):\n                return False\n            dx, dy = pos[node] - pos[child]\n            if abs(dx) + abs(dy) < 1e-6:\n                return False\n            if abs(dx) + abs(dy) < 1e-4:\n                return False\n            if abs(dx) + abs(dy) < 1e-6 and (node, child) not in edges and (child, node) not in edges:\n                return False\n            if abs(dx) + abs(dy) < 1e-6 and (node, child) in edges and (child, node) in edges:\n                return False\n            if abs(dx) + abs(dy) < 1e-6 and (node, child) in edges and (child, node) not in edges:\n                return False\n            if abs(dx) + abs(dy) < 1e-6 and (node, child) not in edges and (child, node) in edges:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) > 3000:\n                return False\n            if abs(dx) + abs(dy) >"
    },
    {
        "number": 3408,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, q = map(int, stdin.readline().split())\n    words = [stdin.readline().strip() for _ in range(n)]\n    patterns = [stdin.readline().strip() for _ in range(q)]\n\n    # count number of words that each pattern covers\n    counts = [0] * q\n    for i, pattern in enumerate(patterns):\n        if pattern == '*':\n            counts[i] = n\n        else:\n            for word in words:\n                if word.startswith(pattern.replace('*', '')):\n                    counts[i] += 1\n\n    # output counts\n    return '\\n'.join(map(str, counts))"
    },
    {
        "number": 3409,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.readline().split())\n    board = []\n    for i in range(r):\n        board.append(list(stdin.readline().strip()))\n    target = []\n    for i in range(r):\n        target.append(list(stdin.readline().strip()))\n    visited = [[False for j in range(c)] for i in range(r)]\n    def dfs(i, j):\n        if visited[i][j]:\n            return False\n        if board[i][j] == target[i][j]:\n            return True\n        visited[i][j] = True\n        if i > 0 and dfs(i-1, j):\n            return True\n        if i < r-1 and dfs(i+1, j):\n            return True\n        if j > 0 and dfs(i, j-1):\n            return True\n        if j < c-1 and dfs(i, j+1):\n            return True\n        return False\n    for i in range(r):\n        for j in range(c):\n            if board[i][j] == 'O' and target[i][j] == 'X':\n                if dfs(i, j):\n                    return '1'\n    return '0'"
    },
    {
        "number": 3410,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.sort()\n    score = 0\n    for i in range(n):\n        for j in range(i+2, n):\n            for k in range(j+2, n):\n                if (points[i][0]-points[j][0])*(points[i][1]-points[k][1]) == (points[i][1]-points[j][1])*(points[i][0]-points[k][0]):\n                    continue\n                if (points[j][0]-points[k][0])*(points[i][1]-points[j][1]) == (points[j][1]-points[k][1])*(points[i][0]-points[j][0]):\n                    continue\n                if (points[k][0]-points[i][0])*(points[j][1]-points[k][1]) == (points[k][1]-points[i][1])*(points[j][0]-points[k][0]):\n                    continue\n                score += 1\n    return str(score % 1000003)"
    },
    {
        "number": 3411,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split())\n    scores = list(map(int, stdin.readline().split()))\n    if all(score == 0 for score in scores):\n        return \"0\"\n    if all(score > 0 for score in scores) or all(score < 0 for score in scores):\n        return \"1\"\n    if scores[0] == 0:\n        scores[0] = 1\n    if scores[-1] == 0:\n        scores[-1] = -1\n    if scores[0] > 0:\n        scores[0] = -scores[0]\n    if scores[-1] < 0:\n        scores[-1] = -scores[-1]\n    for i in range(1, n):\n        if scores[i] > 0 and scores[i-1] < 0:\n            scores[i] = -scores[i]\n        elif scores[i] < 0 and scores[i-1] > 0:\n            scores[i] = -scores[i]\n    if scores[0] > 0:\n        scores[0] = -scores[0]\n    if scores[-1] < 0:\n        scores[-1] = -scores[-1]\n    time = 0\n    for i in range(n):\n        if scores[i] > 0:\n            time += c\n        else:\n            time += r\n    return str(time)"
    },
    {
        "number": 3412,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    v_walk, v_bike = map(int, stdin.readline().split())\n    x1, y1, x2, y2 = map(int, stdin.readline().split())\n    x_G, y_G = map(int, stdin.readline().split())\n    x_D, y_D = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    x_stations = []\n    y_stations = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        x_stations.append(x)\n        y_stations.append(y)\n\n    # calculate distances\n    dist_G_D = ((x_D - x_G) ** 2 + (y_D - y_G) ** 2) ** 0.5\n    dist_G_stations = []\n    for i in range(n):\n        dist_G_stations.append(((x_stations[i] - x_G) ** 2 + (y_stations[i] - y_G) ** 2) ** 0.5)\n\n    # calculate time\n    time_G_D = dist_G_D / v_walk\n    time_G_stations = []\n    for i in range(n):\n        time_G_stations.append(dist_G_stations[i] / v_bike)\n    time_G_stations.sort()\n\n    # calculate shortest time\n    time_shortest = time_G_D\n    for i in range(n):\n        time_shortest += time_G_stations[i]\n\n    return str(time_shortest)"
    },
    {
        "number": 3413,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    parties = list(map(int, stdin.readline().split()))\n    friendships = set()\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        friendships.add((a-1, b-1))\n        friendships.add((b-1, a-1))\n    visited = set()\n    queue = [(i, 0) for i in range(n) if parties[i] == 0]\n    while queue:\n        i, count = queue.pop(0)\n        if i in visited:\n            continue\n        visited.add(i)\n        if parties[i] == 0:\n            count += 1\n        for j in range(n):\n            if (i, j) in friendships and j not in visited:\n                queue.append((j, count))\n    return count\n\nstdin = \"\"\"\n4 3\n0 1 0 0\n1 2\n2 3\n2 4\n\"\"\"\n\nprint(solution(stdin)) # Output: 1"
    },
    {
        "number": 3414,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split())\n    nodes = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        nodes.append((x, y))\n    edges = []\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        edges.append((a, b))\n\n    # build graph\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # find eulerian circuit\n    def dfs(node, path):\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in path:\n                dfs(neighbor, path)\n        return path\n\n    path = dfs(0, [])\n    if len(path)!= n:\n        return \"Error: not eulerian\"\n\n    # calculate turning\n    turns = []\n    for i in range(n):\n        x1, y1 = nodes[path[i]]\n        x2, y2 = nodes[path[(i+1)%n]]\n        dx, dy = x2-x1, y2-y1\n        if dx == 0:\n            turns.append(0)\n        else:\n            turns.append(math.atan(abs(dy/dx)))\n\n    # calculate total turning\n    total_turning = sum(turns)\n\n    return str(total_turning)"
    },
    {
        "number": 3415,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    nums = list(range(1, 2**n))\n    root = nums[0]\n    nums.remove(root)\n    level = 0\n    while nums:\n        left_size = 2**(level+1) - 1\n        left_nums = nums[:left_size]\n        right_nums = nums[left_size:]\n        for i in range(left_size):\n            if i < left_size // 2:\n                left_nums[i] = root - 2**(level+1) + i\n            else:\n                left_nums[i] = root + 2**(level+1) - i - 1\n        for i in range(left_size, len(nums)):\n            if i < len(nums) // 2:\n                right_nums[i-left_size] = root - 2**(level+1) + i\n            else:\n                right_nums[i-left_size] = root + 2**(level+1) - i - 1\n        nums = left_nums + right_nums\n        root = nums[0]\n        nums.remove(root)\n        level += 1\n    return''.join(map(str, nums))"
    },
    {
        "number": 3416,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        adj[a].append(b)\n        adj[b].append(a)\n    visited = [False] * (n+1)\n    q = [1]\n    visited[1] = True\n    flights = 0\n    while q:\n        size = len(q)\n        for _ in range(size):\n            u = q.pop(0)\n            for v in adj[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    q.append(v)\n                    flights += 1\n    airports = []\n    for i in range(1, n+1):\n        if not visited[i]:\n            airports.append(i)\n    if not airports:\n        return f\"{flights}\\n\"\n    else:\n        return f\"{flights}\\n{airports}\\n\""
    },
    {
        "number": 3417,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n+1)\n    in_degree = [0] * (n+1)\n    for i in range(1, n+1):\n        for j in graph[i]:\n            in_degree[j] += 1\n    max_size = 0\n    for i in range(1, n+1):\n        if not visited[i] and in_degree[i] == 0:\n            visited[i] = True\n            size = 1\n            stack = [i]\n            while stack:\n                node = stack.pop()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        size += 1\n                        stack.append(neighbor)\n            max_size = max(max_size, size)\n    return str(max_size)"
    },
    {
        "number": 3418,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    e = 2.718281828459045\n    citySize = 1000000\n    dayOfMonth = 365\n    demand = citySize * dayOfMonth - n**e\n    supply = 0\n    for i in range(1, n+1):\n        supply += int(10**i)\n    return str(supply)"
    },
    {
        "number": 3419,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split())\n    t = list(map(int, stdin.readline().split()))\n    t.sort()\n    i = 0\n    j = 0\n    count = 0\n    while i < n and j < n:\n        if t[j] <= s1:\n            count += 1\n            i += 1\n            j += 1\n        elif t[j] <= s1 + s2:\n            count += 1\n            i += 1\n            j += 1\n        else:\n            j += 1\n    return count"
    },
    {
        "number": 3420,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    B, G = map(int, lines[0].split())\n    boys = []\n    for i in range(1, B+1):\n        name, N = lines[i].split()\n        books = lines[i+1].split()\n        boys.append((name, books))\n    girls = []\n    for i in range(B+1, B+1+G):\n        name, N = lines[i].split()\n        books = lines[i+1].split()\n        girls.append((name, books))\n\n    # count number of books read by each student\n    books_read = {}\n    for boy in boys:\n        for book in boy[1]:\n            if book not in books_read:\n                books_read[book] = 0\n            books_read[book] += 1\n    for girl in girls:\n        for book in girl[1]:\n            if book not in books_read:\n                books_read[book] = 0\n            books_read[book] += 1\n\n    # count number of presentations needed\n    presentations = 0\n    books_presented = set()\n    for book, count in books_read.items():\n        if count == 2:\n            presentations += 1\n            books_presented.add(book)\n    presentations += len(books_read) // 2\n    return str(presentations)"
    },
    {
        "number": 3421,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    results = stdin.readline().strip()\n    n = len(results)\n    if k > n:\n        return \"0 0\"\n    best_rate = 0\n    best_start = 0\n    for i in range(n - k + 1):\n        rate = sum(int(results[j]) for j in range(i, i + k)) / k\n        if rate > best_rate:\n            best_rate = rate\n            best_start = i + 1\n    return f\"{best_start} {k}\""
    },
    {
        "number": 3422,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    pieces = []\n    for i in range(n):\n        w, h = map(int, stdin.readline().strip().split())\n        grid = []\n        for j in range(h):\n            grid.append(list(map(int, stdin.readline().strip())))\n        pieces.append((w, h, grid))\n\n    # find valid rotation\n    for i in range(4):\n        # rotate pieces\n        rotated_pieces = []\n        for w, h, grid in pieces:\n            rotated_grid = []\n            for j in range(w):\n                row = []\n                for k in range(h):\n                    row.append(grid[k][w-1-j])\n                rotated_grid.append(row)\n            rotated_pieces.append((h, w, rotated_grid))\n\n        # assemble map\n        w = sum(p[0] for p in rotated_pieces)\n        h = max(p[1] for p in rotated_pieces)\n        map_grid = [[0]*w for _ in range(h)]\n        used_pieces = [False]*n\n        for i, (w, h, grid) in enumerate(rotated_pieces):\n            x, y = 0, 0\n            for j in range(h):\n                for k in range(w):\n                    if grid[j][k]!= 0:\n                        map_grid[j+y][k+x] = grid[j][k]\n                        used_pieces[i] = True\n                        if x+k+1 < w:\n                            map_grid[j+y][k+x+1] = 0\n                        if y+j+1 < h:\n                            map_grid[j+y+1][k+x] = 0\n                x += w\n            y += h\n\n        # check if valid\n        if all(used_pieces):\n            # output map\n            output = []\n            for row in map_grid:\n                output.append(''.join(str(c) for c in row))\n            output.append('-'*w)\n            for i, (w, h, grid) in enumerate(rotated_pieces):\n                for j in range(h):\n                    for k in range(w):\n                        if grid[j][k]!= 0:\n                            output[-1] += str(i+1)\n                        else:\n                            output[-1] += '-'\n            return '\\n'.join(output)\n\n    # no valid rotation found\n    return 'No valid rotation found'"
    },
    {
        "number": 3423,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split('\\n\\n')\n    for case in cases:\n        lines = case.split('\\n')\n        n = int(lines[0])\n        if n == 0:\n            continue\n        packages = {}\n        for i in range(1, n+1):\n            package, dependencies = lines[i].split()\n            packages[package] = dependencies.split()\n        order = []\n        while packages:\n            for package, dependencies in packages.items():\n                if all(dep in order for dep in dependencies):\n                    order.append(package)\n                    del packages[package]\n                    break\n            else:\n                return 'cannot be ordered'\n        print(' '.join(order))\n    return ''"
    },
    {
        "number": 3424,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, ell = map(int, stdin.split())\n    for b in range(2, 17):\n        if y >= ell and all(int(d) < b for d in str(y)):\n            return str(b)\n    return \"No solution found\""
    },
    {
        "number": 3425,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = []\n    for i in range(n):\n        board.append(list(stdin.readline().strip()))\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == '.':\n                count += 1\n                board[i][j] = '#'\n                if i > 0 and board[i-1][j] == '.':\n                    count += 1\n                    board[i-1][j] = '#'\n                if i < n-1 and board[i+1][j] == '.':\n                    count += 1\n                    board[i+1][j] = '#'\n                if j > 0 and board[i][j-1] == '.':\n                    count += 1\n                    board[i][j-1] = '#'\n                if j < m-1 and board[i][j+1] == '.':\n                    count += 1\n                    board[i][j+1] = '#'\n                if i > 0 and j > 0 and board[i-1][j-1] == '.':\n                    count += 1\n                    board[i-1][j-1] = '#'\n                if i > 0 and j < m-1 and board[i-1][j+1] == '.':\n                    count += 1\n                    board[i-1][j+1] = '#'\n                if i < n-1 and j > 0 and board[i+1][j-1] == '.':\n                    count += 1\n                    board[i+1][j-1] = '#'\n                if i < n-1 and j < m-1 and board[i+1][j+1] == '.':\n                    count += 1\n                    board[i+1][j+1] = '#'\n                board[i][j] = '.'\n    return str(count) +'' + str(2**(count))"
    },
    {
        "number": 3426,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split()[0:2])\n    tunnels = []\n    for i in range(M):\n        a, b, l, c = map(int, stdin.split()[0:4])\n        tunnels.append((a, b, l, c))\n\n    # initialize distances\n    distances = [float('inf')] * (N+1)\n    distances[1] = 0\n\n    # dijkstra algorithm\n    for i in range(N):\n        for a, b, l, c in tunnels:\n            if c == 1 and distances[a]!= float('inf') and distances[a] + l < distances[b]:\n                distances[b] = distances[a] + l\n\n    # output results\n    result = []\n    for a, b, l, c in tunnels:\n        if l == '?':\n            result.append(distances[b])\n        else:\n            result.append(l)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3427,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    doors = []\n    for i in range(M):\n        u, v = map(int, stdin.readline().split())\n        doors.append((u, v))\n\n    # build graph\n    graph = [[] for _ in range(N)]\n    for u, v in doors:\n        if u!= -1:\n            graph[u].append(v)\n        if v!= -1:\n            graph[v].append(u)\n\n    # find max rooms\n    max_rooms = 0\n    visited = set()\n    for i in range(N):\n        if i in visited:\n            continue\n        visited.add(i)\n        stack = [i]\n        while stack:\n            u = stack.pop()\n            for v in graph[u]:\n                if v == -1:\n                    continue\n                if v in visited:\n                    continue\n                visited.add(v)\n                stack.append(v)\n        max_rooms = max(max_rooms, len(visited))\n\n    return str(max_rooms)"
    },
    {
        "number": 3428,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    f = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            f[(i,j)] = reduce(gcd, a[i:j])\n    return len(f)"
    },
    {
        "number": 3429,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, s_s, r_i, r_f = map(int, stdin.split())\n    x_a, y_a, s_a = map(int, stdin.readline().split())\n\n    # Calculate the distance between Anthony and the safety zone center\n    distance = ((x_a - x_s) ** 2 + (y_a - y_s) ** 2) ** 0.5\n\n    # Calculate the time it takes for the safety zone to shrink to its final size\n    time = distance / s_s\n\n    # Calculate the damage Anthony will take\n    damage = time * s_a\n\n    # Calculate the minimum damage Anthony can take\n    min_damage = r_i / r_f * damage\n\n    return f\"{min_damage:.6f}\""
    },
    {
        "number": 3430,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, A, B = map(int, stdin.split())\n    cables_A = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N]]\n    M = int(stdin.split('\\n')[N+1])\n    cables_B = [tuple(map(int, line.split())) for line in stdin.split('\\n')[N+2:N+2+M-1]]\n\n    # build graph\n    graph = {}\n    for u, v in cables_A:\n        graph[u] = graph.get(u, []) + [v]\n        graph[v] = graph.get(v, []) + [u]\n    for u, v in cables_B:\n        graph[u] = graph.get(u, []) + [v]\n        graph[v] = graph.get(v, []) + [u]\n\n    # find minimum cost\n    min_cost = float('inf')\n    for u in range(1, N+1):\n        for v in range(1, M+1):\n            if u!= v and u in graph and v in graph:\n                paths = []\n                for path in itertools.permutations(graph[u] + graph[v]):\n                    if path[0] == u and path[-1] == v:\n                        paths.append(path)\n                for path in paths:\n                    cost = sum(len(graph[u]) + len(graph[v]) - 2 for u, v in zip(path[:-1], path[1:]))\n                    min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 3431,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    # Sort points by x-coordinate\n    points.sort(key=lambda p: p[0])\n\n    # Initialize MST with first point\n    mst = [points[0]]\n\n    # Add remaining points to MST\n    for i in range(1, n):\n        # Find closest point in MST to current point\n        closest_dist = float('inf')\n        closest_point = None\n        for p in mst:\n            dist = abs(p[0] - points[i][0]) + abs(p[1] - points[i][1])\n            if dist < closest_dist:\n                closest_dist = dist\n                closest_point = p\n\n        # Add current point to MST\n        mst.append(points[i])\n\n        # Add edge between closest point and current point to MST\n        mst.append(closest_point)\n\n    # Calculate weight of MST\n    weight = 0\n    for i in range(len(mst)):\n        if i % 2 == 0:\n            weight += abs(mst[i][0] - mst[i+1][0]) + abs(mst[i][1] - mst[i+1][1])\n\n    return str(weight)"
    },
    {
        "number": 3432,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    sums = []\n    for i in range(1, n+1):\n        a, b = map(int, lines[i].split())\n        sums.append(a+b)\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3433,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    R, C = map(int, stdin.split())\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    # find Joe's position\n    joe_r, joe_c = None, None\n    for r in range(R):\n        for c in range(C):\n            if maze[r][c] == 'J':\n                joe_r, joe_c = r, c\n                break\n        if joe_r is not None:\n            break\n    if joe_r is None:\n        return \"IMPOSSIBLE\"\n\n    # bfs to find exit\n    visited = set()\n    queue = [(joe_r, joe_c, 0)]\n    while queue:\n        r, c, time = queue.pop(0)\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        if maze[r][c] == '#':\n            continue\n        if maze[r][c] == 'F':\n            return \"IMPOSSIBLE\"\n        if r == 0 or r == R-1 or c == 0 or c == C-1:\n            return time\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r+dr, c+dc\n            if 0 <= nr < R and 0 <= nc < C and maze[nr][nc]!= '#':\n                queue.append((nr, nc, time+1))\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3434,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[0:3])\n    health = list(map(int, stdin.split()[3:3+n]))\n    opp_health = list(map(int, stdin.split()[3+n:]))\n    \n    total_health = sum(health) + sum(opp_health)\n    if total_health == 0:\n        return \"1.000000\"\n    \n    damage = d * total_health\n    total_damage = 0\n    for i in range(n):\n        damage_to_deal = damage * health[i] // total_health\n        total_damage += damage_to_deal\n        health[i] -= damage_to_deal\n        if health[i] <= 0:\n            health[i] = 0\n    \n    for i in range(m):\n        damage_to_deal = damage * opp_health[i] // total_health\n        total_damage += damage_to_deal\n        opp_health[i] -= damage_to_deal\n        if opp_health[i] <= 0:\n            opp_health[i] = 0\n    \n    if total_damage == 0:\n        return \"0.000000\"\n    \n    return \"{:.6f}\".format(1 - total_damage / (d * total_health))"
    },
    {
        "number": 3435,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pattern = stdin.readline().strip()\n    count = 0\n    for i in range(2**n):\n        binary = bin(i)[2:].zfill(n)\n        if all(c == '1' or c == '*' for c in binary):\n            if all(c == '1' or c == '*' for c in binary):\n                count += 1\n    return count"
    },
    {
        "number": 3436,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    F = [[0] * (y+1) for _ in range(x+1)]\n    F[0][0] = 0\n    F[0][1] = 1\n    F[1][0] = 1\n    for i in range(2, x+1):\n        F[i][0] = (F[i-1][0] + F[i-2][0]) % MOD\n    for j in range(2, y+1):\n        F[0][j] = (F[0][j-1] + F[0][j-2]) % MOD\n    for i in range(1, x+1):\n        for j in range(1, y+1):\n            F[i][j] = (F[i-1][j] + F[i][j-1]) % MOD\n    return str(F[x][y])"
    },
    {
        "number": 3437,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L1, L2, N = map(int, lines[0].split())\n    tubes = sorted(map(int, lines[1:]))\n    if N < 4:\n        return \"Impossible\"\n    for i in range(N-3):\n        for j in range(i+1, N-2):\n            if tubes[i] + tubes[j] <= L1 and tubes[j+2] + tubes[j+3] <= L2:\n                return str(tubes[i] + tubes[j] + tubes[j+2] + tubes[j+3])\n    return \"Impossible\""
    },
    {
        "number": 3438,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cache_size, num_objects, num_accesses = map(int, stdin.split())\n    cache = [None] * cache_size\n    access_count = [0] * num_objects\n    for i in range(num_accesses):\n        obj = int(stdin.readline())\n        if cache[obj] is None:\n            cache[obj] = obj\n            access_count[obj] += 1\n        else:\n            access_count[obj] += 1\n    return str(max(access_count))"
    },
    {
        "number": 3439,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0:2])\n    altitude = []\n    for i in range(h):\n        altitude.append(list(map(int, stdin.split()[i*w:(i+1)*w])))\n    i, j = map(int, stdin.split()[-2:])\n    total_volume = 0\n    for x in range(h):\n        for y in range(w):\n            if altitude[x][y] < 0:\n                total_volume += abs(altitude[x][y]) * abs(altitude[x][y])\n            else:\n                total_volume += 0\n    total_volume -= altitude[i-1][j-1] * altitude[i-1][j-1]\n    return str(total_volume)"
    },
    {
        "number": 3440,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, R = map(int, stdin.split())\n    flights = []\n    for i in range(R):\n        a, b, c = map(int, stdin.readline().split())\n        flights.append((a, b, c))\n    F = int(stdin.readline())\n    additional_flights = []\n    for i in range(F):\n        a, b, c = map(int, stdin.readline().split())\n        additional_flights.append((a, b, c))\n\n    # compute lowest cost\n    costs = [0] * (N+1)\n    for a, b, c in flights:\n        costs[a] += c\n        costs[b] += c\n    for a, b, c in additional_flights:\n        costs[a] += c\n        costs[b] += c\n    return str(min(costs))"
    },
    {
        "number": 3441,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * n\n    def dfs(u, p):\n        visited[u] = True\n        for v in adj[u]:\n            if v == p: continue\n            if visited[v]: return False\n            if not dfs(v, u): return False\n        return True\n    ans = 0\n    for u in range(n):\n        if not visited[u]:\n            if dfs(u, -1): ans += 1\n    return str(ans)"
    },
    {
        "number": 3442,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    count = 0\n    for num in range(X, Y+1):\n        if is_sheldon_number(num):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3443,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    spots = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        spots.append((x, y))\n    spots.sort()\n    count = 0\n    for i in range(1, n):\n        if spots[i][0]!= spots[i-1][0]:\n            count += 1\n        if spots[i][1]!= spots[i-1][1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3444,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    pistes = []\n    for i in range(1, M+1):\n        a, b, w = map(float, lines[i].split())\n        pistes.append((a, b, w))\n    dp = [0] * N\n    for i in range(N):\n        dp[i] = 1\n    for k in range(1, N):\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                for p in pistes:\n                    if p[0] == i and p[1] == j:\n                        dp[i] = max(dp[i], dp[j] * (1 - p[2]))\n    return''.join(map(str, dp))"
    },
    {
        "number": 3445,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    customers = []\n    for i in range(1, n+1):\n        x, y = map(int, lines[i].split())\n        customers.append((x, y))\n\n    # divide up customers\n    def distance(a, b):\n        return abs(a[0]-b[0]) + abs(a[1]-b[1])\n\n    def divide(customers):\n        if len(customers) == 1:\n            return customers\n        mid = len(customers) // 2\n        left = divide(customers[:mid])\n        right = divide(customers[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        i, j = 0, 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if distance(left[i], right[j]) < distance(right[j], left[i]):\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        merged += left[i:]\n        merged += right[j:]\n        return merged\n\n    divided = divide(customers)\n\n    # calculate delivery times\n    def delivery_time(customers):\n        if len(customers) == 1:\n            return 0\n        mid = len(customers) // 2\n        left = delivery_time(customers[:mid])\n        right = delivery_time(customers[mid:])\n        return max(left, right) + distance(customers[0], customers[-1])\n\n    left_delivery_time = delivery_time(divided[:len(divided)//2])\n    right_delivery_time = delivery_time(divided[len(divided)//2:])\n\n    # print result\n    print(max(left_delivery_time, right_delivery_time))\n\n    return ''"
    },
    {
        "number": 3446,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    k = int(lines[0])\n    symbols = lines[1].split()\n    table = []\n    for i in range(2, 2+k):\n        row = []\n        for j in range(i):\n            time, result = lines[i].split()[j].split('-')\n            row.append((int(time), result))\n        table.append(row)\n    n = int(lines[2+k])\n    results = []\n    for i in range(3+k, 3+k+n):\n        seq = lines[i].split()\n        time = 0\n        for j in range(len(seq)):\n            time += table[j][symbols.index(seq[j])][0]\n            if j > 0 and seq[j-1] in table[j][symbols.index(seq[j])][1]:\n                time += table[j-1][symbols.index(seq[j-1])][0]\n        results.append((time, seq[-1]))\n    results.sort()\n    return '\\n'.join(str(r[0])+'-'+r[1] for r in results)"
    },
    {
        "number": 3447,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    words = lines[1:n+1]\n    q = int(lines[n+1])\n    queries = lines[n+2:]\n\n    # build dictionary\n    d = {}\n    for i, word in enumerate(words):\n        d[word] = i\n\n    # solve queries\n    for query in queries:\n        # check if query is in dictionary\n        if query in d:\n            # if yes, output its index\n            index = d[query]\n            output = str(index)\n        else:\n            # if not, output optimal keypresses\n            output = ''\n            for i, c in enumerate(query):\n                if c.isalpha():\n                    # if character is alphabetic, output its index\n                    output += str(ord(c) - ord('a') + 2)\n                else:\n                    # if character is non-alphabetic, output right\n                    output += 'R'\n                # if not last character, output up or down\n                if i < len(query) - 1:\n                    output += 'U1' if c.isupper() else 'D1'\n        # output result\n        print(output)\n\n    return ''"
    },
    {
        "number": 3448,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"NO\"\n    else:\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        mobi_cable_cars = []\n        vina_cable_cars = []\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_cars.append((mobi_station_1, mobi_station_2))\n            vina_station_1 = vina_stations.pop()\n            vina_station_2 = vina_stations.pop()\n            vina_cable_cars.append((vina_station_1, vina_station_2))\n        mobi_stations = set(range(1, n+1))\n        vina_stations = set(range(1, n+1))\n        for i in range(k):\n            mobi_station_1 = mobi_stations.pop()\n            mobi_station_2 = mobi_stations.pop()\n            mobi_cable_"
    },
    {
        "number": 3449,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    B, H, R, C = map(int, stdin.split())\n    lights = []\n    for i in range(R):\n        row = list(map(int, stdin.readline().strip()))\n        lights.append(row)\n\n    # Calculate light levels\n    light_levels = [[0 for _ in range(C)] for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            light_levels[i][j] = lights[i][j]\n            for k in range(1, H+1):\n                light_levels[i][j] += lights[i][j] * k / (k**2 + 1)\n\n    # Count dark spots\n    dark_spots = 0\n    for i in range(R):\n        for j in range(C):\n            if light_levels[i][j] < B:\n                dark_spots += 1\n\n    # Calculate fencing cost\n    fencing_cost = 0\n    for i in range(R):\n        for j in range(C):\n            if i > 0 and light_levels[i][j] >= B and light_levels[i-1][j] < B:\n                fencing_cost += 11\n            if i < R-1 and light_levels[i][j] >= B and light_levels[i+1][j] < B:\n                fencing_cost += 11\n            if j > 0 and light_levels[i][j] >= B and light_levels[i][j-1] < B:\n                fencing_cost += 11\n            if j < C-1 and light_levels[i][j] >= B and light_levels[i][j+1] < B:\n                fencing_cost += 11\n            if i > 0 and j > 0 and light_levels[i][j] >= B and light_levels[i-1][j-1] < B:\n                fencing_cost += 43\n            if i > 0 and j < C-1 and light_levels[i][j] >= B and light_levels[i-1][j+1] < B:\n                fencing_cost += 43\n            if i < R-1 and j > 0 and light_levels[i][j] >= B and light_levels[i+1][j-1] < B:\n                fencing_cost += 43\n            if i < R-1 and j < C-1 and light_levels[i][j] >= B and light_levels[i+1][j+1] < B:\n                fencing_cost += 43\n\n    # Return result\n    return str(dark_spots * 11 + fencing_cost)"
    },
    {
        "number": 3450,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    factorial_str = str(factorial)\n    trailing_zeroes = 0\n    for i in range(len(factorial_str)-1, -1, -1):\n        if factorial_str[i] == '0':\n            trailing_zeroes += 1\n        else:\n            break\n    if trailing_zeroes == 0:\n        return '0'\n    else:\n        return factorial_str[-3-trailing_zeroes:-trailing_zeroes]"
    },
    {
        "number": 3451,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    seq = stdin.split('\\n')[2]\n    costs = list(map(int, stdin.split('\\n')[3:]))\n    if k >= n:\n        return '?'\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if seq[i] == '(' and seq[j-1] == ')':\n                dp[i][j] = dp[i+1][j-1]\n            else:\n                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + costs[i]\n    return dp[0][n] if dp[0][n] <= k else '?'"
    },
    {
        "number": 3452,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rooms = [set() for _ in range(n)]\n    for i in range(n):\n        k = int(stdin.readline().strip().split()[0])\n        for j in range(k):\n            rooms[i].add(int(stdin.readline().strip()))\n    sets = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if rooms[i] == rooms[j]:\n                sets.append(sorted([i+1, j+1]))\n    sets.sort(key=lambda x: x[0])\n    return '\\n'.join([' '.join(map(str, s)) for s in sets]) if sets else 'none'"
    },
    {
        "number": 3453,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    tunnels = []\n    for _ in range(M):\n        A, B, L = map(int, stdin.split())\n        tunnels.append((A, B, L))\n\n    # compute shortest paths\n    dist = [float('inf')] * (N+1)\n    dist[1] = 0\n    for A, B, L in tunnels:\n        if dist[B] > dist[A] + L:\n            dist[B] = dist[A] + L\n    for i in range(2, N+1):\n        for A, B, L in tunnels:\n            if A == i or B == i:\n                if dist[B] > dist[A] + L:\n                    dist[B] = dist[A] + L\n\n    # compute danger levels\n    danger = [0] * (N+1)\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i!= j:\n                if dist[i] % 2 == dist[j] % 2:\n                    danger[i] += dist[j]\n                else:\n                    danger[i] += min(dist[j], dist[i])\n\n    # output result\n    return''.join(map(str, danger))"
    },
    {
        "number": 3454,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    # count number of valid pictures\n    count = 0\n    for i in range(2**N):\n        # convert binary to list of blue and red parameters\n        b = [0] * N\n        r = [0] * N\n        for j in range(N):\n            if i & (1 << j):\n                b[j] = c[j]\n            else:\n                r[j] = M - c[j]\n        # check if parameters are valid\n        if sum(b) == sum(r) and all(b[j] <= r[j] for j in range(N)):\n            count += 1\n\n    # compute result\n    X = 100003 ** count\n    Y = sum(c)\n    return f\"{X} {Y % 100003}\""
    },
    {
        "number": 3455,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n, m, r = map(int, lines[0].split())\n    cars = []\n    for i in range(1, m+1):\n        lane, length, distance = map(int, lines[i].split())\n        cars.append((lane, length, distance))\n\n    # sort cars by distance from sensor\n    cars.sort(key=lambda x: x[2])\n\n    # compute safety factor for each possible plan\n    max_safety_factor = 0\n    for i in range(m):\n        # compute safety factor for plan that includes car i\n        safety_factor = 0\n        for j in range(i+1, m):\n            # compute distance between cars i and j\n            distance = abs(cars[j][2] - cars[i][2])\n            # compute safety factor for this distance\n            safety_factor = max(safety_factor, distance - cars[j][1])\n        # update max safety factor\n        max_safety_factor = max(max_safety_factor, safety_factor)\n\n    # check if ACM car can switch lanes\n    if cars[0][0] == 0 and cars[-1][0] == n-1:\n        return str(max_safety_factor)\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3456,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    stacks = list(map(int, stdin.readline().strip().split()))\n\n    # initialize variables\n    actions = 0\n    current_stack = 0\n    current_height = stacks[0]\n\n    # loop through stacks\n    for i in range(1, N):\n        # if current stack is taller than next stack, move crane to next stack\n        if stacks[i] > current_height:\n            actions += 1\n            current_stack = i\n            current_height = stacks[i]\n        # if current stack is not taller than next stack, move crane to current stack\n        else:\n            actions += 1\n            current_height = max(current_height, stacks[i])\n\n    # move crane to rightmost stack\n    actions += 1\n\n    # return result\n    return str(actions)"
    },
    {
        "number": 3457,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (N+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(N+1):\n        for j in range(N+1):\n            if dp[i][j] == 0:\n                continue\n            if i+X > N:\n                dp[i+X-N][j] += dp[i][j]\n                dp[i+X-N][j] %= MOD\n            if j+Y > N:\n                dp[i][j+Y-N] += dp[i][j]\n                dp[i][j+Y-N] %= MOD\n    return dp[N][N]"
    },
    {
        "number": 3458,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nums = list(map(int, stdin.readline().strip().split()))\n    nums.sort()\n    ans = 0\n    for i in range(n):\n        ans ^= nums[i]\n    return str(ans)"
    },
    {
        "number": 3459,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    T = int(lines[0])\n    for i in range(1, T*4, 4):\n        n = int(lines[i])\n        residents = []\n        for j in range(i+1, i+n+1):\n            name, party, num_clubs = lines[j].split()\n            clubs = lines[j+1].split()\n            residents.append((name, party, num_clubs, clubs))\n        # solve problem\n        council = []\n        for resident in residents:\n            clubs = resident[3]\n            if len(council) == 0:\n                council.append(resident)\n            else:\n                found = False\n                for i, c in enumerate(council):\n                    if c[1]!= resident[1]:\n                        council.insert(i, resident)\n                        found = True\n                        break\n                if not found:\n                    council.append(resident)\n        if len(council) > n/2:\n            return \"Impossible\"\n        else:\n            result = []\n            for c in council:\n                result.append(c[0] + \" \" + c[3][0])\n            return \"\\n\".join(result) + \"\\n\""
    },
    {
        "number": 3460,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cans = []\n    for i in range(n):\n        x, r = map(int, stdin.readline().strip().split())\n        cans.append((x, r))\n    cans.sort()\n    explosions = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if cans[i][0] - cans[j][0] <= cans[i][1] + cans[j][1]:\n                explosions[i] += 1\n    return''.join(map(str, explosions))"
    },
    {
        "number": 3461,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    hearings = []\n    for i in range(n):\n        s, a, b = map(int, stdin.readline().split())\n        hearings.append((s, a, b))\n    hearings.sort()\n    expected_hearings = 0\n    current_time = 0\n    for s, a, b in hearings:\n        if current_time < s:\n            expected_hearings += 1\n            current_time = s\n        if current_time + a <= s:\n            current_time += a\n        else:\n            current_time = s + random.randint(a, b)\n    return str(expected_hearings)"
    },
    {
        "number": 3462,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pattern, num_files = stdin.split('\\n')\n    num_files = int(num_files)\n    files = stdin.split('\\n')[2:]\n    result = []\n    for file in files:\n        if fnmatch.fnmatch(file, pattern):\n            result.append(file)\n    return '\\n'.join(result)\n\nimport fnmatch\n\nstdin = \"\"\"*.*\n4\nmain.c\na.out\nreadme\nyacc\"\"\"\n\nprint(solution(stdin)) # Output: main.c\\na.out"
    },
    {
        "number": 3463,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    p = list(map(float, stdin.split()))\n    total = N + M\n    if total % 2 == 1:\n        return \"0.000000\"\n    else:\n        p_win = sum(p)\n        p_lose = 1 - p_win\n        return \"{:.6f}\".format(p_win)"
    },
    {
        "number": 3464,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, p = map(float, stdin.split())\n    n = 1000000\n    total_loss = 0\n    total_win = 0\n    for i in range(n):\n        if random.random() < p/100:\n            total_win += 2\n        else:\n            total_loss += 1\n    expected_profit = (total_win - total_loss) * 2 - x/100 * total_loss\n    return str(expected_profit)"
    },
    {
        "number": 3465,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    roads = [[] for _ in range(n+1)]\n    for i in range(n-1):\n        a, b = map(int, stdin.readline().strip().split())\n        roads[a].append(b)\n        roads[b].append(a)\n    visited = [False] * (n+1)\n    stack = [1]\n    while stack:\n        curr = stack.pop()\n        if visited[curr]:\n            continue\n        visited[curr] = True\n        for neighbor in roads[curr]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n    result = []\n    for i in range(1, n+1):\n        if visited[i]:\n            result.append(str(i) + \" \" + str(i+1))\n    return \"\\n\".join(result)"
    },
    {
        "number": 3466,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+m]))\n    b = list(map(int, stdin.split()[2+m:]))\n    n = sum(b)\n    f = [0] * m\n    for i in range(m):\n        f[i] = a[i] / sum(a)\n    for i in range(k):\n        if b[i] == 0:\n            continue\n        if b[i] == m:\n            return \"forever\"\n        if b[i] == 1:\n            f[0] = (n + 1) / (n + 2)\n        else:\n            f[b[i]-1] = (n - sum(b[:i+1]) + 1) / (n - sum(b[:i+1]) + 2)\n    for i in range(m):\n        if f[i] < 0 or f[i] > 1:\n            return \"impossible\"\n    if n * f[0] - 1 < b[0] < n * f[0] + 1:\n        return \"forever\"\n    if n * f[1] - 1 < b[1] < n * f[1] + 1:\n        return \"forever\"\n    for i in range(2, m):\n        if n * f[i] - 1 < b[i] < n * f[i] + 1:\n            return \"forever\"\n    return \"forever\""
    },
    {
        "number": 3467,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    stops = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, t0, p, d = map(int, stdin.readline().split())\n        stops[u].append((v, t0, p, d))\n        stops[v].append((u, t0, p, d))\n    visited = [False] * n\n    q = [(0, s)]\n    while q:\n        stop, time = q.pop(0)\n        if visited[stop]:\n            continue\n        visited[stop] = True\n        if stop == n - 1:\n            return str(time)\n        for next_stop, t0, p, d in stops[stop]:\n            if not visited[next_stop]:\n                q.append((next_stop, time + t0 + (time - s) % p + d))\n    return \"impossible\""
    },
    {
        "number": 3468,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    apps = []\n    for i in range(n):\n        d, s = map(int, stdin.split())\n        apps.append((d, s))\n    apps.sort(key=lambda x: x[1], reverse=True)\n    installed = []\n    for app in apps:\n        if app[0] <= c:\n            installed.append(app)\n            c -= app[1]\n            if c < 0:\n                break\n    if not installed:\n        return \"\"\n    return str(len(installed)) + \"\\n\" + \" \".join(str(i+1) for i in range(len(installed)))"
    },
    {
        "number": 3469,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g, k, p = stdin.split('\\n')\n    p = float(p)\n    s = ''\n    for i in range(10**100):\n        if random.random() < p:\n            s += 'H'\n        else:\n            s += 'T'\n        if g in s and k in s:\n            return '0.5'\n        elif g in s:\n            return '1.0'\n        elif k in s:\n            return '0.0'\n\nWe can solve this problem by simulating the game and keeping track of the number of times Gon wins. We can use the `random` module to simulate the coin flip. We can also use the `in` operator to check if a string is a substring of another string.\n\nThe probability that Gon wins is the fraction of times Gon wins over the total number of flips. We can keep track of the number of times Gon wins using a counter variable.\n\nHere's the complete solution:"
    },
    {
        "number": 3470,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    safe_cells = []\n    for i in range(1, 4*n+5):\n        if i % 2 == 0 or i == 1 or i == 4*n+3:\n            safe_cells.append(i)\n    print(len(safe_cells))\n    print(*safe_cells)\n    return \"\""
    },
    {
        "number": 3471,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    K, a = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    l, r = [], []\n    for i in range(Q):\n        l_, r_ = map(int, stdin.readline().split())\n        l.append(l_-1)\n        r.append(r_-1)\n\n    # compute xorbonacci sequence\n    x = [a[0]]\n    for i in range(1, K):\n        x.append(x[i-1] ^ a[i])\n\n    # compute answers\n    ans = []\n    for i in range(Q):\n        ans.append(x[r[i]] ^ x[l[i]])\n\n    # format output\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3472,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, N = map(int, stdin.split())\n    lines = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        lines.append((x1, y1, x2, y2))\n    lines.sort(key=lambda x: x[2] - x[0])\n    for i in range(len(lines)):\n        if lines[i][2] - lines[i][0] == float('inf'):\n            return str(len(lines) - i)\n    return '0'"
    },
    {
        "number": 3473,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    z, f = map(int, stdin.splitlines()[0].split())\n    forbidden = []\n    for i in range(1, f+1):\n        year, month, day = map(int, stdin.splitlines()[i].split())\n        forbidden.append(datetime.date(year, month, day))\n\n    # find first valid date\n    start = datetime.date(2019, 1, 1)\n    while start.weekday()!= 1 or start in forbidden:\n        start += datetime.timedelta(days=1)\n\n    # find schedule with smallest penalty\n    best_penalty = float('inf')\n    best_schedule = []\n    for i in range(z):\n        year = 2019 + i\n        penalty = 0\n        date = start\n        while date.year == year:\n            if date.weekday() == 4 and date not in forbidden:\n                penalty += (date.month - 10) ** 2\n            date += datetime.timedelta(days=1)\n        if penalty < best_penalty:\n            best_penalty = penalty\n            best_schedule = [str(date) for date in dates]\n\n    # format output\n    return f'{best_penalty}\\n' + '\\n'.join(best_schedule)"
    },
    {
        "number": 3474,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    for line in stdin.split('\\n'):\n        if line:\n            x1, y1, x2, y2, x3, y3 = map(float, line.split())\n            if x1 == x2:\n                if y1 < y2:\n                    print(f\"{y1} {y2}\")\n                else:\n                    print(f\"{y2} {y1}\")\n            elif y1 == y2:\n                if x1 < x2:\n                    print(f\"{x1} {x2}\")\n                else:\n                    print(f\"{x2} {x1}\")\n            else:\n                a = (y2 - y1) / (x2 - x1)\n                b = y1 - a * x1\n                c = -1 / a\n                d = y3 - c * x3\n                if d == 0:\n                    print(\"can't hit the wall\")\n                else:\n                    x = (b - d) / (a - c)\n                    y = a * x + b\n                    if x < 0:\n                        print(f\"negative-infinity {y}\")\n                    elif x > 0:\n                        print(f\"{y} positive-infinity\")\n                    else:\n                        print(f\"{y} {y}\")\n    return \"\""
    },
    {
        "number": 3475,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    t, n = map(int, stdin.split())\n    modes = []\n    for i in range(t):\n        dmin, a = map(int, stdin.split())\n        modes.append((dmin, a))\n    distances = []\n    angles = []\n    for i in range(n-1):\n        d, h = map(int, stdin.split())\n        distances.append(d)\n        angles.append(h)\n    # solve\n    k = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            d = sum(distances[i:j])\n            a = max(angles[i:j]) - min(angles[i:j])\n            for dmin, amax in modes:\n                if d >= dmin and a <= amax:\n                    k += 1\n                    break\n            else:\n                return \"IMPOSSIBLE\"\n    return k"
    },
    {
        "number": 3476,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    R, C = map(int, stdin.split()[0:2])\n    matrix = []\n    for i in range(R):\n        matrix.append(list(map(int, stdin.split()[0:C])))\n\n    # initialize variables\n    max_sum = sum(sum(row) for row in matrix)\n    operations = []\n\n    # rotate row i right k times\n    def rotate_row_right(i, k):\n        nonlocal matrix, max_sum, operations\n        row = matrix[i-1]\n        row = row[-k:] + row[:-k]\n        matrix[i-1] = row\n        max_sum += sum(row) - sum(matrix[i-1])\n        operations.append(f\"rotR {i} {k}\")\n\n    # rotate column j down k times\n    def rotate_column_down(j, k):\n        nonlocal matrix, max_sum, operations\n        col = [matrix[i][j-1] for i in range(R)]\n        col = col[-k:] + col[:-k]\n        for i in range(R):\n            matrix[i][j-1] = col[i]\n        max_sum += sum(col) - sum(matrix[i][j-1] for i in range(R))\n        operations.append(f\"rotS {j} {k}\")\n\n    # negate row i\n    def negate_row(i):\n        nonlocal matrix, max_sum, operations\n        row = matrix[i-1]\n        if all(x >= 0 for x in row):\n            row = [-x for x in row]\n            matrix[i-1] = row\n            max_sum += sum(row) - sum(matrix[i-1])\n            operations.append(f\"negR {i}\")\n\n    # negate column j\n    def negate_column(j):\n        nonlocal matrix, max_sum, operations\n        col = [matrix[i][j-1] for i in range(R)]\n        if all(x >= 0 for x in col):\n            col = [-x for x in col]\n            for i in range(R):\n                matrix[i][j-1] = col[i]\n            max_sum += sum(col) - sum(matrix[i][j-1] for i in range(R))\n            operations.append(f\"negS {j}\")\n\n    # try all possible operations\n    for i in range(1, R+1):\n        for k in range(1, C):\n            rotate_row_right(i, k)\n    for j in range(1, C+1):\n        for k in range(1, R):\n            rotate_column_down(j, k)\n    for i in range(1, R+1):\n        negate_row(i)\n    for j in range(1, C+1):\n        negate_column(j)\n\n    # output result\n    return f\"{max_sum} {len(operations)}\\n{' '.join(operations)}\""
    },
    {
        "number": 3477,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k = list(map(int, stdin.split()))\n    E = sorted([i for i in range(1, n+1) for _ in range(k[i-1])])[:m]\n    return str(sum(k[i-1]*min((i-E[j])**2 for j in range(m)) for i in range(1, n+1)))"
    },
    {
        "number": 3478,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        adj[x].append(y)\n        adj[y].append(x)\n    visited = [False] * (n+1)\n    def dfs(u, parent):\n        visited[u] = True\n        for v in adj[u]:\n            if v == parent:\n                continue\n            if not visited[v]:\n                dfs(v, u)\n    for i in range(1, n+1):\n        if not visited[i]:\n            dfs(i, -1)\n    if not all(visited):\n        return \"impossible\"\n    for i in range(1, n+1):\n        if not visited[i]:\n            return \"impossible\"\n    for i in range(1, n+1):\n        if i == 1 or i == 2:\n            continue\n        if not any(adj[i]):\n            return \"impossible\"\n    for i in range(1, n+1):\n        if i == 1:\n            continue\n        if not any(adj[i]):\n            return \"impossible\"\n    a = [1, 4, 5]\n    b = [2, 6, 7]\n    return \" \".join(map(str, a)) + \"\\n\" + \" \".join(map(str, b))"
    },
    {
        "number": 3479,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    t.sort()\n    ans = 0\n    for i in range(n):\n        ans += t[i]\n    return str(ans)"
    },
    {
        "number": 3480,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    L, D = map(int, lines[0].split())\n    lines = lines[1:]\n    output = []\n    for i in range(L):\n        line1, line2 = lines[2*i].split(' = '), lines[2*i+1].split(' = ')\n        syllables1, times1 = line1[0].split(), list(map(int, line1[1].split()))\n        syllables2, times2 = line2[0].split(), list(map(int, line2[1].split()))\n        syllables1 = [s.replace('_', '') for s in syllables1]\n        syllables2 = [s.replace('_', '') for s in syllables2]\n        output.append(syllables1)\n        output.append(syllables2)\n        for j in range(len(syllables2)):\n            if times2[j] >= D:\n                output[-1][j] = '_'*(times2[j]-D) + output[-1][j]\n    for i in range(2*L):\n        output[i] = ''.join(output[i])\n    return '\\n'.join(output)"
    },
    {
        "number": 3481,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    G, K, R = map(int, stdin.split()[0:3])\n    roads = []\n    for i in range(R):\n        A, B, T = map(int, stdin.split()[0:3])\n        roads.append((A, B, T))\n    gigs = []\n    for i in range(G):\n        V, S, E, M = map(int, stdin.split()[0:4])\n        gigs.append((V, S, E, M))\n\n    # sort gigs by start time\n    gigs.sort(key=lambda x: x[1])\n\n    # dp[i][j] = maximum number of cryptocents that DJ Polygon can make by taking on the right gigs\n    #           when he is at venue i and has taken on the gigs up to j-1\n    dp = [[0] * G for _ in range(K+1)]\n\n    # initialize dp[1][0] = 0\n    for i in range(G):\n        dp[1][i] = gigs[i][3]\n\n    # fill dp table\n    for i in range(2, K+1):\n        for j in range(G):\n            dp[i][j] = dp[i-1][j]\n            for k in range(j):\n                if gigs[k][0] == i-1 and gigs[k][2] > gigs[j][1]:\n                    dp[i][j] = max(dp[i][j], dp[i-1][k] + gigs[j][3])\n\n    # return maximum number of cryptocents that DJ Polygon can make\n    return max(dp[K])"
    },
    {
        "number": 3482,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    l, p, d = map(int, stdin.readline().split())\n    t, n = map(int, stdin.readline().split())\n    trips = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().split())\n        trips.append((a, b))\n\n    # compute total cost\n    total_cost = 0\n    for i in range(l):\n        days = sum(d[j] for j in range(i, l) if j == i or d[j] > d[j-1])\n        total_cost += days * p[i]\n\n    # compute cost for trips home\n    for trip in trips:\n        start, end = trip\n        days = end - start + 1\n        total_cost += days * p[-1]\n\n    return str(total_cost)"
    },
    {
        "number": 3483,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    weights = list(map(int, stdin.readline().strip().split()))\n\n    # sort weights in ascending order\n    weights.sort()\n\n    # calculate max and min weights\n    max_weight = weights[-1] * 4\n    min_weight = weights[0] * 4\n\n    # calculate number of distinct weights\n    distinct_weights = len(weights)\n\n    # calculate expected weight\n    expected_weight = sum(weights) / 4\n\n    # format output\n    return f\"{max_weight} {min_weight} {distinct_weights} {expected_weight:.4f}\""
    },
    {
        "number": 3484,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    for i in range(k):\n        row = list(map(int, stdin.split()))\n        for j in range(n):\n            board[i][j] = row[j]\n    for i in range(k, n):\n        for j in range(n):\n            if board[i][j] == 0:\n                for num in range(1, n+1):\n                    if all(board[i][x]!= num for x in range(n)) and all(board[x][j]!= num for x in range(n)):\n                        board[i][j] = num\n                        if solve(board, i, j):\n                            return \"yes\"\n                        board[i][j] = 0\n                return \"no\"\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3485,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    cards = list(map(int, stdin.readline().strip().split()))\n\n    # initialize variables\n    count = 0\n    total = 0\n    max_payout = 0\n    stop_counting = False\n    start_counting = False\n\n    # iterate through cards\n    for card in cards:\n        # check if we should stop counting\n        if not stop_counting:\n            # check if we should start counting\n            if start_counting:\n                total += card\n                count += 1\n            # check if we should stop counting\n            elif card == 0:\n                stop_counting = True\n        # check if we should start counting\n        elif card!= 0:\n            start_counting = True\n\n        # update max payout\n        if count > 0:\n            max_payout = max(max_payout, total / count)\n\n    # return result\n    return f\"{max_payout:.9f}\""
    },
    {
        "number": 3486,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    xs = [int(x) for x in stdin.readline().strip().split()]\n\n    # count number of ways to stretch streamers\n    MOD = 10**9+7\n    count = 0\n    for i in range(n):\n        for j in range(i+2, n):\n            if gcd(xs[i], xs[j]) > 1:\n                count += 1\n    return str(count % MOD)\n\ndef"
    },
    {
        "number": 3487,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, p, v, a = map(float, stdin.split())\n    pipes = []\n    for _ in range(p):\n        j, k, c = map(int, stdin.split())\n        pipes.append((j, k, c))\n\n    # compute capacities\n    capacities = [0] * n\n    for j, k, c in pipes:\n        capacities[j-1] += c\n        capacities[k-1] += c\n\n    # compute flow\n    flow = [0] * n\n    flow[0] = 1\n    while True:\n        # find blocking flow\n        blocking = float('inf')\n        for j, k, c in pipes:\n            if flow[j-1] > 0 and flow[k-1] == 0 and capacities[j-1] - flow[j-1] < c:\n                blocking = min(blocking, capacities[j-1] - flow[j-1])\n            if flow[k-1] > 0 and flow[j-1] == 0 and capacities[k-1] - flow[k-1] < c:\n                blocking = min(blocking, capacities[k-1] - flow[k-1])\n        if blocking == float('inf'):\n            break\n        # update flow\n        for j, k, c in pipes:\n            if flow[j-1] > 0 and flow[k-1] == 0 and capacities[j-1] - flow[j-1] < c:\n                flow[k-1] = min(flow[k-1], capacities[j-1] - flow[j-1])\n            if flow[k-1] > 0 and flow[j-1] == 0 and capacities[k-1] - flow[k-1] < c:\n                flow[j-1] = min(flow[j-1], capacities[k-1] - flow[k-1])\n\n    # compute values\n    values = []\n    for j, k, c in pipes:\n        if flow[j-1] > 0 and flow[k-1] > 0:\n            f = flow[j-1]\n            w = flow[k-1]\n            if f > w:\n                f, w = w, f\n            values.append((f, w))\n        elif flow[j-1] > 0:\n            f = flow[j-1]\n            w = -c + f\n            if w < 0:\n                f, w = w, f\n            values.append((f, w))\n        elif flow[k-1] > 0:\n            f = -c + flow[k-1]\n            w = flow[k-1]\n            if f < 0:\n                f, w = w, f\n            values.append((f, w))\n\n    # compute maximum value\n    max_value = 0\n    for f, w in values:\n        value = f**a * w**(1-a)\n        max_value = max(max_value, value)\n\n    # output values\n    for f, w in values:\n        print(f'{f:.10f} {w:.10f}')\n    print(f'{max_value:.10f}')\n\n    return ''"
    },
    {
        "number": 3488,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    k = int(stdin.readline().strip())\n    sightings = []\n    for i in range(k):\n        x, y = map(int, stdin.readline().strip().split())\n        sightings.append((x, y))\n\n    # find the convex hull of the sightings\n    hull = []\n    left = 0\n    right = len(sightings) - 1\n    while left < right:\n        if (sightings[left][1] - sightings[right][1]) * (sightings[right][0] - sightings[left][0]) > (sightings[right][1] - sightings[left][1]) * (sightings[right][0] - sightings[left+1][0]):\n            hull.append(sightings[left])\n            left += 1\n        else:\n            hull.append(sightings[right])\n            right -= 1\n    hull.append(sightings[left])\n\n    # find the polygon Z\n    Z = []\n    for i in range(len(hull)):\n        for j in range(i+1, len(hull)):\n            if (hull[i][0] - hull[j][0]) * (points[0][1] - hull[j][1]) - (hull[i][1] - hull[j][1]) * (points[0][0] - hull[j][0]) > 0:\n                Z.append((hull[i][0], hull[i][1]))\n                Z.append((hull[j][0], hull[j][1]))\n                break\n    Z.append((hull[0][0], hull[0][1]))\n\n    # count the number of vertices in Z\n    count = len(Z)\n\n    # output the result\n    return str(count)"
    },
    {
        "number": 3489,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * n\n    visited[h] = True\n    q = [h]\n    while q:\n        node = q.pop(0)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append(neighbor)\n    m = 0\n    for i in range(n):\n        if not visited[i]:\n            m += 1\n    ans = []\n    for i in range(n):\n        if not visited[i]:\n            for j in range(n):\n                if not visited[j]:\n                    if i!= j and (i, j) not in graph[i] and (j, i) not in graph[j]:\n                        ans.append((i, j))\n    return f\"{m}\\n{' '.join(f'{a} {b}' for a, b in ans)}\""
    },
    {
        "number": 3490,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    witches = []\n    for i in range(N):\n        x, y, r = map(float, stdin.readline().strip().split())\n        witches.append((x, y, r))\n    for i in range(N):\n        for j in range(i+1, N):\n            if witches[i][0] == witches[j][0] and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if witches[i][1] == witches[j][1] and abs(witches[i][0] - witches[j][0]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches[i][1] - witches[j][1]) < 1e-6:\n                return \"crash\"\n            if abs(witches[i][0] - witches[j][0]) < 1e-6 and abs(witches"
    },
    {
        "number": 3491,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    current_state = [set() for _ in range(N)]\n    desired_state = [set() for _ in range(N)]\n    for i in range(1, M+1):\n        a, b = map(int, lines[i].split())\n        current_state[a].add(b)\n        current_state[b].add(a)\n    for i in range(M+1, 2*M+1):\n        a, b = map(int, lines[i].split())\n        desired_state[a].add(b)\n        desired_state[b].add(a)\n    queue = []\n    for i in range(N):\n        if current_state[i]!= desired_state[i]:\n            queue.append(('R', i))\n            queue.append(('G', i))\n    return str(len(queue)) + '\\n' + '\\n'.join(map(lambda x: x[0] +'' + str(x[1]), queue))"
    },
    {
        "number": 3492,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    s, r, f, t = map(int, stdin.split())\n    state_names = stdin.split()[-(r+f):-f]\n    factory_names = stdin.split()[-f:]\n    transportation_companies = []\n    for i in range(t):\n        n = int(stdin.readline().strip())\n        transportation_companies.append(stdin.readline().strip().split())\n\n    # build graph\n    graph = {}\n    for i in range(r):\n        graph[state_names[i]] = []\n    for i in range(f):\n        graph[state_names[r+i]] = []\n    for i in range(t):\n        for j in range(n):\n            graph[transportation_companies[i][j]] = []\n\n    # add edges\n    for i in range(r):\n        for j in range(t):\n            if state_names[i] in transportation_companies[j]:\n                graph[state_names[i]].append(transportation_companies[j])\n    for i in range(f):\n        for j in range(t):\n            if state_names[r+i] in transportation_companies[j]:\n                graph[state_names[r+i]].append(transportation_companies[j])\n\n    # find connected components\n    visited = set()\n    components = []\n    for i in range(r+f):\n        if i not in visited:\n            component = set()\n            stack = [i]\n            while stack:\n                node = stack.pop()\n                if node not in visited:\n                    visited.add(node)\n                    component.add(node)\n                    for neighbor in graph[state_names[node]]:\n                        for k in range(n):\n                            if neighbor[k] == state_names[node]:\n                                stack.append(k)\n            components.append(component)\n\n    # count factories\n    count = 0\n    for component in components:\n        if len(component) == 1:\n            count += 1\n    return count"
    },
    {
        "number": 3493,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    buttons = [list(stdin.readline().strip()) for _ in range(n)]\n    k = 0\n    while True:\n        valid = True\n        for i in range(n):\n            for j in range(n):\n                if buttons[i][j] == 'Y' and buttons[i][k] == 'Y':\n                    valid = False\n                    break\n            if not valid:\n                break\n        if not valid:\n            k += 1\n        else:\n            break\n    result = [k]\n    for i in range(n):\n        line = []\n        for j in range(n):\n            if buttons[i][j] == 'Y':\n                line.append(j+1)\n        result.append(line)\n    return '\\n'.join([' '.join(map(str, line)) for line in result])"
    },
    {
        "number": 3494,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    R, S = map(int, stdin.readline().split())\n    matrix = []\n    for i in range(R):\n        matrix.append(list(stdin.readline().strip()))\n    G = int(stdin.readline())\n    falls = []\n    for i in range(G):\n        r, s = map(int, stdin.readline().split())\n        falls.append((r-1, s-1))\n\n    # calculate distances\n    distances = []\n    for i in range(G):\n        r, s = falls[i]\n        min_dist = float('inf')\n        for j in range(R):\n            for k in range(S):\n                if matrix[j][k] == 'x':\n                    dist = (j-r)**2 + (k-s)**2\n                    if dist < min_dist:\n                        min_dist = dist\n        distances.append(min_dist)\n\n    # output distances\n    return '\\n'.join(map(str, distances))"
    },
    {
        "number": 3495,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    lengths = [float(line.strip()) for line in stdin.readlines()[:n]]\n    x, y = map(float, stdin.readline().strip().split())\n\n    # Solve problem\n    angles = [0] * n\n    angles[0] = math.atan2(y, x)\n    for i in range(1, n):\n        angles[i] = angles[i-1] + math.atan2(lengths[i-1], lengths[i])\n    angles[-1] = angles[-2] + math.atan2(lengths[-1], lengths[-2])\n    xs = [lengths[0] * math.cos(angles[0])]\n    ys = [lengths[0] * math.sin(angles[0])]\n    for i in range(1, n):\n        xs.append(xs[i-1] + lengths[i] * math.cos(angles[i]))\n        ys.append(ys[i-1] + lengths[i] * math.sin(angles[i]))\n    xs.append(lengths[-1] * math.cos(angles[-1]))\n    ys.append(lengths[-1] * math.sin(angles[-1]))\n    xs = [round(x, 4) for x in xs]\n    ys = [round(y, 4) for y in ys]\n\n    # Check solution\n    dist = math.sqrt((xs[-1] - x)**2 + (ys[-1] - y)**2)\n    if abs(dist - min(math.sqrt(x**2 + y**2), max(lengths))) > 0.01:\n        raise ValueError(\"Solution is not optimal\")\n\n    # Format output\n    return \"\\n\".join(f\"{x} {y}\" for x, y in zip(xs, ys))"
    },
    {
        "number": 3496,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    ans = []\n    for _ in range(q):\n        k = int(stdin.readline())\n        if k <= n:\n            ans.append(a[k-1])\n        else:\n            i = 1\n            j = k - n\n            while j > 0:\n                if i + j <= n:\n                    i += 1\n                    j -= 1\n                else:\n                    i -= 1\n                    j += 1\n            ans.append(a[i-1] + a[j-1])\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3497,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, P = map(int, stdin.split()[0:2])\n    edges = [[] for _ in range(V)]\n    for i in range(V-1):\n        u, v = map(int, stdin.split()[0:2])\n        edges[u].append(v)\n        edges[v].append(u)\n    pigs = list(map(int, stdin.split()[-P:]))\n    leaves = [i for i in range(V) if len(edges[i]) == 1]\n    wolves = set()\n    for i in range(P):\n        for j in range(i+1, P):\n            if pigs[i] == pigs[j]:\n                wolves.add(pigs[i])\n    for leaf in leaves:\n        if leaf in wolves:\n            wolves.remove(leaf)\n    return str(len(wolves))"
    },
    {
        "number": 3498,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    t, r = map(int, lines[0].split())\n    tasks = []\n    for i in range(1, t+1):\n        start_time, base_priority, a = map(int, lines[i].split())\n        instructions = []\n        for j in range(a):\n            instruction = lines[i+j+1].strip()\n            instructions.append(instruction)\n        tasks.append((start_time, base_priority, instructions))\n\n    # simulate tasks\n    clock = 0\n    current_priorities = [0] * t\n    owned_resources = [set() for _ in range(r)]\n    for i in range(t):\n        start_time, base_priority, instructions = tasks[i]\n        while clock < start_time:\n            clock += 1\n            for j in range(t):\n                if current_priorities[j] > base_priority and not all(owned_resources[k] for k in owned_resources):\n                    current_priorities[j] = max(current_priorities[j], max(current_priorities[k] for k in owned_resources[j]))\n        for instruction in instructions:\n            if instruction[0] == 'C':\n                clock += 1\n            elif instruction[0] == 'L':\n                k = int(instruction[1:])\n                if k in owned_resources[i]:\n                    continue\n                for j in range(t):\n                    if j!= i and k in owned_resources[j]:\n                        current_priorities[j] = max(current_priorities[j], current_priorities[i])\n                owned_resources[i].add(k)\n            elif instruction[0] == 'U':\n                k = int(instruction[1:])\n                if k not in owned_resources[i]:\n                    continue\n                owned_resources[i].remove(k)\n                for j in range(t):\n                    if j!= i and k in owned_resources[j]:\n                        current_priorities[j] = max(current_priorities[j], current_priorities[i])\n        current_priorities[i] = base_priority\n\n    # output results\n    results = []\n    for i in range(t):\n        start_time, base_priority, instructions = tasks[i]\n        while clock < start_time:\n            clock += 1\n            for j in range(t):\n                if current_priorities[j] > base_priority and not all(owned_resources[k] for k in owned_resources):\n                    current_priorities[j] = max(current_priorities[j], max(current_priorities[k] for k in owned_resources[j]))\n        for instruction in instructions:\n            if instruction[0] == 'C':\n                clock += 1\n            elif instruction[0] == 'L':\n                k = int(instruction[1:])\n                if k in owned_resources[i]:\n                    continue\n                for j in range(t):\n                    if j!= i and k in owned_resources[j]:\n                        current_priorities[j] = max(current_priorities[j], current_priorities[i])\n                owned_resources[i].add(k)\n            elif instruction[0] == 'U':\n                k = int(instruction[1:])\n                if k not in owned_resources[i]:\n                    continue\n                owned_resources[i].remove(k)\n                for j in range(t):\n                    if j!= i and k in owned_resources[j]:\n                        current_priorities[j] = max(current_priorities[j], current_priorities[i])\n        results.append(clock)\n\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3499,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    # initialize variables\n    MOD = 10**9+7\n    count = 0\n    n2 = 2*n\n    s2 = s + s\n\n    # iterate over all possible substrings of length 2n\n    for i in range(len(s2)-n2+1):\n        sub = s2[i:i+n2]\n        # check if sub is a palindrome\n        if sub == sub[::-1]:\n            # check if sub contains s\n            if s in sub:\n                count += 1\n\n    # return result modulo 10^9+7\n    return count % MOD"
    },
    {
        "number": 3500,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = []\n    for i in range(n):\n        card = [int(x) for x in stdin.readline().strip().split()]\n        cards.append(card)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if has_tie(cards[i], cards[j]):\n                return f\"{i+1} {j+1}\"\n\n    return \"no ties\"\n\ndef"
    },
    {
        "number": 3501,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    jaap_bet = list(map(int, stdin.readline().strip().split()))\n    jan_bet = list(map(int, stdin.readline().strip().split()))\n    thijs_bet = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if jaap_bet[i] < jaap_bet[j] and jan_bet[i] < jan_bet[j] and thijs_bet[i] < thijs_bet[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3502,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lights = []\n    for i in range(n):\n        x, r, g = map(int, stdin.readline().strip().split())\n        lights.append((x, r, g))\n    lights.sort()\n    total_time = sum(r+g for _, r, g in lights)\n    prob_first_red = 0\n    prob_all_through = 0\n    for x, r, g in lights:\n        prob_first_red += (r+g) / total_time\n        prob_all_through += (x+r+g) / total_time\n    return f\"{prob_first_red}\\n{prob_all_through}\""
    },
    {
        "number": 3503,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nums = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        nums.append((a, b))\n    results = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            for op in ['+', '-', '*']:\n                if op == '+':\n                    result = nums[i][0] + nums[j][0]\n                elif op == '-':\n                    result = nums[i][0] - nums[j][0]\n                else:\n                    result = nums[i][0] * nums[j][0]\n                if result == nums[i][1] or result == nums[j][1]:\n                    continue\n                if result in results:\n                    return \"impossible\"\n                results.add(result)\n    if len(results) < n:\n        return \"impossible\"\n    return \"\\n\".join(f\"{nums[i][0]} {op} {nums[i][1]} = {result}\" for i in range(n) for op in ['+', '-', '*'] for result in results if result in [nums[i][0] + nums[j][0], nums[i][0] - nums[j][0], nums[i][0] * nums[j][0]])"
    },
    {
        "number": 3504,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    D, S = map(int, stdin.split())\n    drops = []\n    for _ in range(D):\n        x, y = map(int, stdin.split())\n        drops.append((x, y))\n    sensors = []\n    for _ in range(S):\n        x1, x2, y = map(int, stdin.split())\n        sensors.append(((x1, x2), y))\n\n    # sort drops by y-coordinate\n    drops.sort(key=lambda x: x[1])\n\n    # iterate over drops and sensors\n    for drop in drops:\n        y = drop[1]\n        for sensor in sensors:\n            x1, x2 = sensor[0]\n            if x1 <= drop[0] <= x2:\n                y = sensor[1]\n        print(y)\n\n    return \"\""
    },
    {
        "number": 3505,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n-2):\n        for j in range(i+1, n-1):\n            for k in range(j+1, n):\n                if a[i] + a[j] == a[k]:\n                    count += 1\n    return count"
    },
    {
        "number": 3506,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, m = map(int, stdin.split())\n    spoilify_intervals = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        spoilify_intervals.append((a, b))\n\n    sportify_cheerleaders = [0] * n\n    spoilify_cheerleaders = [0] * n\n\n    for i in range(t):\n        for j in range(n):\n            if i % 5 == 0:\n                sportify_cheerleaders[j] = 0\n            if i % 5 == 4:\n                spoilify_cheerleaders[j] = 0\n            if i % 5 == 1:\n                for a, b in spoilify_intervals:\n                    if a <= i < b:\n                        spoilify_cheerleaders[j] += 1\n            if i % 5 == 2:\n                for a, b in spoilify_intervals:\n                    if a <= i < b:\n                        sportify_cheerleaders[j] += 1\n            if i % 5 == 3:\n                for a, b in spoilify_intervals:\n                    if a <= i < b:\n                        sportify_cheerleaders[j] += 1\n                        spoilify_cheerleaders[j] += 1\n\n    sportify_score = sum(sportify_cheerleaders)\n    spoilify_score = sum(spoilify_cheerleaders)\n\n    return f\"{sportify_score} {spoilify_score}\""
    },
    {
        "number": 3507,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, W, d = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (d+1) for _ in range(R+1)]\n    dp[0][0] = 1\n    for i in range(1, R+1):\n        for j in range(d+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n    return str((dp[R][d] + dp[W][d]) % MOD)"
    },
    {
        "number": 3508,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pillars = list(map(int, stdin.split()[1:]))\n    damage = 0\n    max_damage = 0\n    max_pillar = -1\n    for i in range(n):\n        if i == 0 or i == n-1:\n            damage += pillars[i]\n        else:\n            damage += min(pillars[i-1], pillars[i+1])\n        if damage > max_damage:\n            max_damage = damage\n            max_pillar = i\n    return f\"{max_damage} {max_pillar}\""
    },
    {
        "number": 3509,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[0:2])\n    n, m = map(int, stdin.split()[2:4])\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v, t = map(int, stdin.split()[i*3:i*3+3])\n        graph[u].append((v, t))\n    visited = [False] * (n+1)\n    dist = [float('inf')] * (n+1)\n    dist[1] = 0\n    q = [(0, 1)]\n    while q:\n        d, u = heapq.heappop(q)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, t in graph[u]:\n            if d + t < dist[v]:\n                dist[v] = d + t\n                heapq.heappush(q, (dist[v], v))\n    if dist[n] == float('inf'):\n        return 'Impossible'\n    w = max(a, min(b, dist[n]))\n    return str(w)"
    },
    {
        "number": 3510,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    options = {}\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        options[line[0]] = set(line[1:])\n\n    dp = [[float('inf')] * n for _ in range(n)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                continue\n            for option in options[chr(ord('a') + i)]:\n                if option[0] == chr(ord('a') + j):\n                    dp[i][j] = min(dp[i][j], dp[i][ord(option[0]) - ord('a')] + 1)\n\n    for i in range(n):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                print(-1, end=' ')\n            else:\n                print(dp[i][j], end=' ')\n        print()"
    },
    {
        "number": 3511,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, q = map(int, stdin.split())\n    queries = []\n    for i in range(q):\n        query = list(map(int, stdin.readline().split()))\n        queries.append(query)\n\n    # initialize variables\n    stones = [0] * n\n    count = 0\n    mod = 10**9 + 7\n\n    # process queries\n    for query in queries:\n        if query[0] == 1:\n            # place stone\n            u, v = query[1:]\n            if u == v:\n                stones[u-1] = 1\n            else:\n                stones[u-1] = 1\n                stones[v-1] = 1\n        else:\n            # compute expected value\n            A = sum(stones[i]**2 for i in range(n))\n            B = 2 * n\n            count += A * pow(B-1, mod-2, mod)\n            count %= mod\n\n    return str(count)"
    },
    {
        "number": 3512,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    matrix = []\n    for i in range(n):\n        row = list(map(int, stdin.readline().strip().split()))\n        matrix.append(row)\n\n    # Initialize variables\n    dp = [[0] * n for _ in range(1 << n)]\n    for i in range(n):\n        dp[1 << i][i] = matrix[0][i]\n\n    # Fill DP table\n    for mask in range(1 << n):\n        for i in range(n):\n            if not (mask & (1 << i)):\n                for j in range(n):\n                    if mask & (1 << j):\n                        dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 << j)][j] + matrix[j][i])\n\n    # Calculate minimum total flight duration\n    min_duration = float('inf')\n    for i in range(n):\n        min_duration = min(min_duration, dp[(1 << n) - 1][i])\n\n    return str(min_duration)"
    },
    {
        "number": 3513,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    k = 0\n    for i in range(1, X+1):\n        if X % i == 0:\n            k += 1\n    return str(k)"
    },
    {
        "number": 3514,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    disarmed = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                disarmed += 1\n                if disarmed == 2:\n                    return str(disarmed)\n                # check if there is a neighboring building in the same row or column\n                if i > 0 and grid[i-1][j] == 'x':\n                    continue\n                if i < R-1 and grid[i+1][j] == 'x':\n                    continue\n                if j > 0 and grid[i][j-1] == 'x':\n                    continue\n                if j < C-1 and grid[i][j+1] == 'x':\n                    continue\n                # if no neighboring building, return\n                return str(disarmed)\n    return str(disarmed)"
    },
    {
        "number": 3515,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    cities = []\n    for i in range(1, n+1):\n        y, d, r = map(int, lines[i].split())\n        cities.append((y, d, r))\n\n    # dp[i][j] = shortest time to get from city i to city j\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 0\n\n    # compute dp\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if i!= j and abs(cities[i][0] - cities[j][0]) >= cities[i][1]:\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cities[i][2] + cities[j][2])\n\n    # print results\n    results = []\n    for i in range(1, n):\n        if dp[0][i] == float('inf'):\n            results.append('-1')\n        else:\n            results.append(dp[0][i])\n    return '\\n'.join(map(str, results))"
    },
    {
        "number": 3516,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    levels = []\n    for i in range(n):\n        x, s = map(int, stdin.readline().strip().split())\n        items = list(map(int, stdin.readline().strip().split()))\n        levels.append((x, s, items))\n\n    dp = [float('inf')] * (n+1)\n    dp[0] = 0\n\n    for i in range(1, n+1):\n        for j in range(n+1):\n            if j == 0:\n                continue\n            x, s, items = levels[i-1]\n            if j == x:\n                dp[i] = min(dp[i], dp[j-1] + s)\n            else:\n                dp[i] = min(dp[i], dp[j-1] + items[j-1])\n\n    return str(dp[n])"
    },
    {
        "number": 3517,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    times = list(map(int, lines[1].split()))\n    dependencies = []\n    for i in range(2, 2+n):\n        line = lines[i].strip().split()\n        c = int(line[0])\n        deps = list(map(int, line[1:]))\n        dependencies.append(deps)\n\n    # topological sort\n    indegree = [0] * n\n    for i in range(n):\n        for j in dependencies[i]:\n            indegree[j-1] += 1\n    queue = [i for i in range(n) if indegree[i] == 0]\n    order = []\n    while queue:\n        u = queue.pop(0)\n        order.append(u)\n        for v in dependencies[u]:\n            indegree[v-1] -= 1\n            if indegree[v-1] == 0:\n                queue.append(v-1)\n\n    # compute time\n    time = 0\n    for i in order:\n        time += times[i]\n\n    return str(time)"
    },
    {
        "number": 3518,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = {}\n    for i in range(m):\n        p, q, c = map(int, stdin.split())\n        if p not in friends:\n            friends[p] = {}\n        friends[p][q] = c\n        if q not in friends:\n            friends[q] = {}\n        friends[q][p] = c\n    groups = []\n    for i in range(1, n+1):\n        group = set()\n        for j in range(1, n+1):\n            if i!= j and j in friends[i]:\n                group.add(j)\n        if len(group) >= 2:\n            groups.append(group)\n    if len(groups) % 2 == 1:\n        return \"impossible\"\n    groups = sorted(groups, key=lambda x: len(x))\n    total = 0\n    for i in range(0, len(groups), 2):\n        group1 = groups[i]\n        group2 = groups[i+1]\n        for j in group1:\n            for k in group2:\n                if j in friends[k]:\n                    total += friends[j][k]\n    return str(total)"
    },
    {
        "number": 3519,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    return str(1.0)"
    },
    {
        "number": 3520,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, c = map(int, stdin.split())\n    pills = []\n    for i in range(p):\n        t, x, y = map(int, stdin.readline().split())\n        pills.append((t, x, y))\n    pills.sort()\n    max_age = 0\n    current_age = 0\n    for i in range(p):\n        t, x, y = pills[i]\n        if i == 0:\n            current_age = n\n        else:\n            current_age = max(current_age, pills[i-1][0] + pills[i-1][1])\n        if current_age + y > t:\n            current_age += y\n        else:\n            current_age = t + y\n        max_age = max(max_age, current_age)\n    max_age += c\n    return str(max_age)"
    },
    {
        "number": 3521,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    stars = []\n    for i in range(N):\n        T, s, a = map(float, stdin.readline().strip().split())\n        stars.append((T, s, a))\n    max_dist = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            T1, s1, a1 = stars[i]\n            T2, s2, a2 = stars[j]\n            dist = abs(a1 - a2)\n            if dist > np.pi:\n                dist = 2*np.pi - dist\n            max_dist = max(max_dist, T1 + T2 - s1*dist)\n    return str(max_dist)\n\nimport numpy as np\n\nstdin = \"\"\"\n2\n100 1 1\n100 1 1.5\n\"\"\"\n\nprint(solution(stdin)) # Output: 199.500000"
    },
    {
        "number": 3522,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    batteries = list(map(int, stdin.split()))\n    batteries.sort()\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(batteries[i*k+1] - batteries[i*k]) + abs(batteries[j*k+1] - batteries[j*k])\n            min_diff = min(min_diff, diff)\n    return str(min_diff)"
    },
    {
        "number": 3523,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    p, n1, n5, n10, n25 = map(int, stdin.split())\n\n    # check if it's possible to pay without change\n    if p % 5!= 0:\n        return \"Impossible\"\n\n    # calculate the maximum number of coins that can be used\n    coins = [n1, n5, n10, n25]\n    for i in range(4):\n        coins[i] = min(coins[i], p // 5)\n        p -= coins[i] * 5\n\n    # check if there's any change left\n    if p!= 0:\n        return \"Impossible\"\n\n    # return the maximum number of coins that can be used\n    return sum(coins)"
    },
    {
        "number": 3524,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    s1, s2 = stdin.strip().split('\\n')\n    if len(s1)!= len(s2):\n        return \"no\"\n    for i in range(len(s1)):\n        if s.find(s1[i]) > s.find(s2[i]):\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3525,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, L, B = map(int, stdin.readline().split())\n    S, D = map(int, stdin.readline().split())\n    locks = []\n    for _ in range(L):\n        a, b, x, y = map(int, stdin.readline().split())\n        locks.append((a, b, x, y))\n\n    # count badge numbers that can pass through the locks\n    count = 0\n    for lock in locks:\n        if lock[0] == S and lock[1] == D:\n            count += lock[2] - lock[3] + 1\n        elif lock[1] == S and lock[0] == D:\n            count += lock[2] - lock[3] + 1\n\n    # add badge numbers that can pass through the door\n    if S == D:\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 3526,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    hints = []\n    for i in range(m):\n        l, r, ans = map(int, stdin.split())\n        hints.append((l, r, ans))\n    MOD = 10**9 + 7\n    dp = [[0] * (1 << n) for _ in range(m+1)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(1 << n):\n            if j & (1 << hints[i][0]-1) and j & (1 << hints[i][1]-1):\n                if hints[i][2] == \"same\":\n                    dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n                else:\n                    dp[i+1][j] = (dp[i+1][j] + dp[i][j] * 2) % MOD\n            elif j & (1 << hints[i][0]-1):\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n            elif j & (1 << hints[i][1]-1):\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD\n    ans = 0\n    for j in range(1 << n):\n        ans = (ans + dp[m][j]) % MOD\n    return str(ans)"
    },
    {
        "number": 3527,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, l = map(int, stdin.split())\n    adj = [[] for _ in range(c)]\n    for _ in range(l):\n        a, b = map(int, stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    visited = [False] * c\n    q = [(0, 0)]\n    max_hops = 0\n    while q:\n        node, hops = q.pop(0)\n        if visited[node]:\n            continue\n        visited[node] = True\n        max_hops = max(max_hops, hops)\n        for nei in adj[node]:\n            q.append((nei, hops+1))\n    return str(max_hops)"
    },
    {
        "number": 3528,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nails = []\n    for i in range(int(stdin.split()[0])):\n        x, y = map(int, stdin.split())\n        nails.append((x, y))\n    stdin = stdin.split('\\n')[-1]\n    picked_nails = [stdin[i] for i in range(len(stdin)) if i % 2 == 0]\n    areas = []\n    for i in range(len(picked_nails)):\n        if picked_nails[i] == 'L':\n            x_min = min(nail[0] for nail in nails)\n            y_min = min(nail[1] for nail in nails)\n            x_max = max(nail[0] for nail in nails)\n            y_max = max(nail[1] for nail in nails)\n            areas.append((x_max - x_min) * (y_max - y_min))\n            nails = [(nail[0], nail[1]) for nail in nails if nail[0]!= x_min]\n        elif picked_nails[i] == 'R':\n            x_min = min(nail[0] for nail in nails)\n            y_min = min(nail[1] for nail in nails)\n            x_max = max(nail[0] for nail in nails)\n            y_max = max(nail[1] for nail in nails)\n            areas.append((x_max - x_min) * (y_max - y_min))\n            nails = [(nail[0], nail[1]) for nail in nails if nail[0]!= x_max]\n        elif picked_nails[i] == 'U':\n            x_min = min(nail[0] for nail in nails)\n            y_min = min(nail[1] for nail in nails)\n            x_max = max(nail[0] for nail in nails)\n            y_max = max(nail[1] for nail in nails)\n            areas.append((x_max - x_min) * (y_max - y_min))\n            nails = [(nail[0], nail[1]) for nail in nails if nail[1]!= y_max]\n        elif picked_nails[i] == 'D':\n            x_min = min(nail[0] for nail in nails)\n            y_min = min(nail[1] for nail in nails)\n            x_max = max(nail[0] for nail in nails)\n            y_max = max(nail[1] for nail in nails)\n            areas.append((x_max - x_min) * (y_max - y_min))\n            nails = [(nail[0], nail[1]) for nail in nails if nail[1]!= y_min]\n    return '\\n'.join(str(area) for area in areas)"
    },
    {
        "number": 3529,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    graph = [[] for _ in range(n+1)]\n    blue_edges = 0\n    for _ in range(m):\n        c, f, t = stdin.readline().split()\n        if c == 'B':\n            blue_edges += 1\n        graph[int(f)].append(int(t))\n        graph[int(t)].append(int(f))\n    if blue_edges == k:\n        return '1'\n    visited = [False] * (n+1)\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        if visited[node]:\n            continue\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if neighbor == stack[-1]:\n                    continue\n                if graph[node][-1] == neighbor:\n                    continue\n                if graph[neighbor][-1] == node:\n                    continue\n                if c == 'B':\n                    stack.append(neighbor)\n                else:\n                    stack.append(node)\n                    stack.append(neighbor)\n    if blue_edges == len(stack):\n        return '1'\n    return '0'"
    },
    {
        "number": 3530,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    coasters = []\n    for i in range(1, n+1):\n        a, b, t = map(int, lines[i].split())\n        coasters.append((a, b, t))\n    q = int(lines[n+1])\n    times = list(map(int, lines[n+2:]))\n\n    # compute max fun for each time\n    max_funs = [0] * q\n    for i in range(q):\n        for j in range(n):\n            a, b, t = coasters[j]\n            f = a - (i+1)**2 * b\n            if f > 0:\n                max_funs[i] += f * t\n\n    # print max fun for each time\n    for f in max_funs:\n        print(f)\n\n    return ''"
    },
    {
        "number": 3531,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split())\n    special_places = set(map(int, stdin.readline().split()))\n    potential_trails = []\n    for i in range(m):\n        a, b, c = map(int, stdin.readline().split())\n        potential_trails.append((a, b, c))\n    # Check if there is a way to connect all places with each other\n    visited = [False] * (n+1)\n    for i in range(1, n+1):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            while stack:\n                curr = stack.pop()\n                for j in range(1, n+1):\n                    if not visited[j] and (curr, j) in potential_trails or (j, curr) in potential_trails:\n                        stack.append(j)\n                        visited[j] = True\n            if not all(visited):\n                return -1\n    # Check if there are enough special-nonspecial direct trails\n    special_nonspecial_trails = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i in special_places and j not in special_places:\n                special_nonspecial_trails += 1\n            elif i not in special_places and j in special_places:\n                special_nonspecial_trails += 1\n    if special_nonspecial_trails < w:\n        return -1\n    # Find the minimum cost of blazing the trails\n    min_cost = 0\n    for a, b, c in potential_trails:\n        if a in special_places and b not in special_places:\n            min_cost += c\n        elif a not in special_places and b in special_places:\n            min_cost += c\n    return min_cost"
    },
    {
        "number": 3532,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mirko_string, explosion = stdin.split('\\n')\n    explosion = set(explosion)\n    while any(e in mirko_string for e in explosion):\n        mirko_string = ''.join(c for i, c in enumerate(mirko_string) if i == 0 or c not in explosion.intersection(set(mirko_string[:i])))\n    return mirko_string or 'FRULA'"
    },
    {
        "number": 3533,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    tickets = []\n    for i in range(n):\n        entrance, exit_ = map(int, stdin.readline().strip().split())\n        tickets.append((entrance, exit_))\n\n    # sort tickets by entrance\n    tickets.sort(key=lambda x: x[0])\n\n    # calculate toll for each pair of tickets\n    toll = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            entrance1, exit1 = tickets[i]\n            entrance2, exit2 = tickets[j]\n            if entrance1 == entrance2 or exit1 == exit2:\n                continue\n            toll += abs(exit1 - entrance2)\n\n    return str(toll)"
    },
    {
        "number": 3534,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # initialize variables\n    max_correct = 0\n    k = 0\n\n    # iterate over all possible values of k\n    for i in range(1, 2000000001):\n        correct = 0\n        prev_key = a[0]\n        for j in range(1, n):\n            if a[j] > prev_key:\n                correct += 1\n                prev_key = a[j]\n            elif a[j] < prev_key:\n                correct += 1\n                prev_key = a[j]\n            else:\n                correct += 1\n        if correct > max_correct:\n            max_correct = correct\n            k = i\n\n    # output result\n    return f\"{max_correct}\\n{k}\""
    },
    {
        "number": 3535,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M, K = map(int, stdin.readline().split())\n    measurements = []\n    for i in range(K):\n        s, y, x = stdin.readline().split()\n        measurements.append((s, int(y), int(x)))\n\n    # count number of possible states\n    count = 0\n    for i in range(1 << K):\n        state = [0] * (N*M)\n        for j in range(K):\n            if i & (1 << j):\n                s, y, x = measurements[j]\n                state[y-1 + x-1] = 1 if s == \"+\" else -1\n        if all(state[j]!= 0 for j in range(N*M)):\n            count += 1\n\n    # output result\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3536,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    n = int(stdin.readline())\n    heap_prob = 1\n    for i in range(n):\n        b, p = map(int, stdin.readline().split())\n        if p == 0:\n            heap_prob *= b\n        else:\n            heap_prob *= b // (b + 1)\n    return str((heap_prob * pow(heap_prob, MOD - 2, MOD)) % MOD)"
    },
    {
        "number": 3537,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flights = []\n    for i in range(m):\n        a, b, s, e = map(int, stdin.split())\n        flights.append((a, b, s, e))\n    flights.sort(key=lambda x: x[2])\n    dp = [[float('inf')] * (n+1) for _ in range(n+1)]\n    dp[1][1] = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            for f in flights:\n                if f[0] == i and f[1] == j:\n                    dp[i][j] = min(dp[i][j], dp[f[0]][f[1]] + (f[2]-f[3])**2)\n    return dp[n][n]"
    },
    {
        "number": 3538,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    frogs = []\n    for i in range(n):\n        l, w, h = map(int, stdin.split())\n        frogs.append((l, w, h))\n    frogs.sort(key=lambda x: x[2], reverse=True)\n    piles = []\n    for frog in frogs:\n        if frog[2] + sum(pile[2] for pile in piles) <= d:\n            piles.append(frog)\n        else:\n            break\n    return len(piles)"
    },
    {
        "number": 3539,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    a = [int(x) for x in stdin.readline().strip().split()]\n    b = [int(x) for x in stdin.readline().strip().split()]\n\n    # initialize dp table\n    dp = [[0] * (sum(b) + 1) for _ in range(n + 1)]\n\n    # base case: empty graph\n    dp[0][0] = 1\n\n    # fill dp table\n    for i in range(1, n + 1):\n        for j in range(sum(b) + 1):\n            # choose graph i\n            dp[i][j] = dp[i - 1][j]\n            # delete edge\n            if j >= a[i - 1]:\n                dp[i][j] += dp[i - 1][j - a[i - 1]]\n            # delete vertex\n            dp[i][j] %= (10**9 + 7)\n\n    # return result\n    return str(dp[n][sum(b)])"
    },
    {
        "number": 3540,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    grid = []\n    for line in stdin.split('\\n'):\n        grid.append(list(line))\n\n    # Initialize variables\n    num_moves = 0\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n\n    # Check if puzzle is already solved\n    if all(row == grid[0] for row in grid):\n        return str(num_moves)\n\n    # Check if puzzle is solvable\n    for i in range(num_rows):\n        for j in range(num_cols):\n            if grid[i][j] == grid[0][j]:\n                continue\n            elif grid[i][j] == grid[1][j]:\n                continue\n            elif grid[i][j] == grid[2][j]:\n                continue\n            elif grid[i][j] == grid[3][j]:\n                continue\n            else:\n                return \"This puzzle is not solvable.\"\n\n    # Find empty cell\n    for i in range(num_rows):\n        for j in range(num_cols):\n            if grid[i][j] == '.':\n                empty_row = i\n                empty_col = j\n                break\n\n    # Check if empty cell is on the border\n    if empty_row == 0 or empty_row == num_rows - 1 or empty_col == 0 or empty_col == num_cols - 1:\n        num_moves += 1\n        grid[empty_row][empty_col] = grid[0][empty_col]\n        grid[0][empty_col] = '.'\n        num_moves += solution(str(grid).replace('],', '],\\n'))\n        return str(num_moves)\n\n    # Check if empty cell can be moved up\n    if grid[empty_row - 1][empty_col] == '.' or grid[empty_row - 1][empty_col] == grid[empty_row][empty_col]:\n        num_moves += 1\n        grid[empty_row][empty_col] = grid[empty_row - 1][empty_col]\n        grid[empty_row - 1][empty_col] = '.'\n        num_moves += solution(str(grid).replace('],', '],\\n'))\n        return str(num_moves)\n\n    # Check if empty cell can be moved down\n    if grid[empty_row + 1][empty_col] == '.' or grid[empty_row + 1][empty_col] == grid[empty_row][empty_col]:\n        num_moves += 1\n        grid[empty_row][empty_col] = grid[empty_row + 1][empty_col]\n        grid[empty_row + 1][empty_col] = '.'\n        num_moves += solution(str(grid).replace('],', '],\\n'))\n        return str(num_moves)\n\n    # Check if empty cell can be moved left\n    if grid[empty_row][empty_col - 1] == '.' or grid[empty_row][empty_col - 1] == grid[empty_row][empty_col]:\n        num_moves += 1\n        grid[empty_row][empty_col] = grid[empty_row][empty_col - 1]\n        grid[empty_row][empty_col - 1] = '.'\n        num_moves += solution(str(grid).replace('],', '],\\n'))\n        return str(num_moves)\n\n    # Check if empty cell can be moved right\n    if grid[empty_row][empty_col + 1] == '.' or grid[empty_row][empty_col + 1] == grid[empty_row][empty_col]:\n        num_moves += 1\n        grid[empty_row][empty_col] = grid[empty_row][empty_col + 1]\n        grid[empty_row][empty_col + 1] = '.'\n        num_moves += solution(str(grid).replace('],', '],\\n'))\n        return str(num_moves)\n\n    # If no moves are possible, puzzle is not solvable\n    return \"This puzzle is not solvable.\""
    },
    {
        "number": 3541,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # calculate the absolute difference between the sums of candy\n    diff = abs(sum(a) - sum(b))\n\n    # initialize the result string\n    result = \"\"\n\n    # iterate over all possible assignments of candy to Alf and Beata\n    for i in range(1 << N):\n        # check if the current assignment is valid\n        if sum(1 for j in range(N) if (i >> j) & 1)!= N:\n            continue\n        # calculate the absolute difference between the sums of candy for the current assignment\n        cur_diff = abs(sum(a[j] for j in range(N) if (i >> j) & 1) - sum(b[j] for j in range(N) if not (i >> j) & 1))\n        # update the result string if the current assignment has a smaller absolute difference\n        if cur_diff < diff:\n            diff = cur_diff\n            result = \"\".join(\"A\" if (i >> j) & 1 else \"B\" for j in range(N))\n\n    return result"
    },
    {
        "number": 3542,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.readline().split())\n    A1, A2, B1, B2 = map(lambda x: tuple(map(int, x.split())), stdin.readlines())\n\n    # check if points are valid\n    if not (0 <= A1[0] < N and 0 <= A1[1] < M and 0 <= A2[0] < N and 0 <= A2[1] < M and\n            0 <= B1[0] < N and 0 <= B1[1] < M and 0 <= B2[0] < N and 0 <= B2[1] < M):\n        return \"IMPOSSIBLE\"\n\n    # check if points are adjacent\n    if abs(A1[0] - A2[0]) + abs(A1[1] - A2[1])!= 1 or abs(B1[0] - B2[0]) + abs(B1[1] - B2[1])!= 1:\n        return \"IMPOSSIBLE\"\n\n    # check if wires cross\n    if (A1[0] == B1[0] and A1[1] == B1[1]) or (A1[0] == B2[0] and A1[1] == B2[1]) or \\\n            (A2[0] == B1[0] and A2[1] == B1[1]) or (A2[0] == B2[0] and A2[1] == B2[1]):\n        return \"IMPOSSIBLE\"\n\n    # calculate minimum length of wires\n    min_length = min(abs(A1[0] - A2[0]) + abs(A1[1] - A2[1]), abs(B1[0] - B2[0]) + abs(B1[1] - B2[1]))\n\n    # check if wires go outside the circuit board\n    if min_length > N + M - 2:\n        return \"IMPOSSIBLE\"\n\n    return str(min_length)"
    },
    {
        "number": 3543,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.readline().split())\n    dictionary = [stdin.readline().strip() for _ in range(n)]\n    words = [stdin.readline().strip() for _ in range(m)]\n\n    # calculate minimum keystrokes for each word\n    keystrokes = []\n    for word in words:\n        # find all possible autocorrected words\n        suggestions = [w for w in dictionary if w.startswith(word)]\n        if not suggestions:\n            # no suggestion found, use original word\n            keystrokes.append(len(word))\n        else:\n            # find the suggestion with minimum length\n            min_len = min(len(w) for w in suggestions)\n            suggestion = [w for w in suggestions if len(w) == min_len][0]\n            # calculate keystrokes required to type the suggestion\n            keystrokes.append(len(word) - min_len + len(suggestion))\n\n    # output keystrokes\n    return '\\n'.join(map(str, keystrokes))"
    },
    {
        "number": 3544,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    groups = list(map(int, stdin.readline().strip().split()))\n    max_group_size = max(groups)\n    if max_group_size > 12:\n        return \"impossible\"\n    seats_per_row = max_group_size\n    while True:\n        rows = 1\n        seats_left = 12\n        for group_size in groups:\n            if group_size == 0:\n                continue\n            seats_needed = group_size * seats_per_row\n            if seats_needed > seats_left:\n                rows += 1\n                seats_left = 12 - (seats_per_row * (rows - 1))\n            seats_left -= seats_needed\n        if seats_left >= seats_per_row:\n            return seats_per_row\n        seats_per_row -= 1"
    },
    {
        "number": 3545,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    output_pre, output_in, output_post = stdin.split('\\n')\n    output_pre = output_pre.strip()\n    output_in = output_in.strip()\n    output_post = output_post.strip()\n\n    # reconstruct code\n    code = []\n    for i in range(6):\n        if i % 2 == 0:\n            code.append('Pre')\n        else:\n            code.append('In')\n    code.append('Post')\n\n    # find first tree\n    trees = []\n    for i in range(26):\n        for j in range(26):\n            for k in range(26):\n                if i!= j and i!= k and j!= k:\n                    tree = [chr(ord('A') + i), chr(ord('A') + j), chr(ord('A') + k)]\n                    tree.sort()\n                    pre = ''.join(tree)\n                    in_ = ''.join(sorted(tree))\n                    post = ''.join(sorted(tree, reverse=True))\n                    if pre == output_pre and in_ == output_in and post == output_post:\n                        trees.append(tree)\n\n    # output\n    result = []\n    for tree in trees:\n        result.append(' '.join(code))\n        result.append(''.join(tree))\n        result.append(''.join(sorted(tree)))\n        result.append(''.join(sorted(tree, reverse=True)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3546,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    proofs = []\n    for i in range(n):\n        p = int(stdin.readline())\n        for j in range(p):\n            l, k = map(int, stdin.readline().split())\n            d = list(map(int, stdin.readline().split()))\n            proofs.append((l, k, d))\n    proofs.sort(key=lambda x: x[0])\n    dp = [0] * n\n    for i in range(n):\n        for j in range(i):\n            if all(dp[d] > 0 for d in proofs[i][2]):\n                dp[i] = max(dp[i], dp[j] + proofs[i][0])\n    return str(dp[-1])"
    },
    {
        "number": 3547,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    plots = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, stdin.readline().strip().split())\n        plots.append((x1, y1, x2, y2))\n    total_area = 0\n    for plot in plots:\n        x1, y1, x2, y2 = plot\n        width = x2 - x1\n        height = y2 - y1\n        total_area += width * height\n    return \"{:.2f}\".format(total_area)"
    },
    {
        "number": 3548,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, P = map(int, stdin.split())\n    bad_pairs = set()\n    for _ in range(P):\n        a, b = map(int, stdin.split())\n        bad_pairs.add((a, b))\n        bad_pairs.add((b, a))\n\n    # count number of ways to mix drinks\n    MOD = 10**9 + 7\n    dp = [1] * N\n    for i in range(1, N):\n        for j in range(i):\n            if (i, j) not in bad_pairs:\n                dp[i] += dp[j]\n        dp[i] %= MOD\n\n    # count number of nights\n    nights = 0\n    for i in range(N):\n        nights += dp[i]\n        nights %= MOD\n\n    return str(nights)"
    },
    {
        "number": 3549,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m1, m2, m3 = map(int, stdin.split()[0:3])\n    x1, x2, x3 = map(int, stdin.split()[3:6])\n    y1, y2, y3 = map(int, stdin.split()[6:])\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not is_prime(m1) or not is_prime(m2) or not is_prime(m3):\n        return \"Invalid input\"\n\n    def mod_distance(x, y, m):\n        return abs(x - y) % m\n\n    z = mod_distance(x1, x2, m1)\n    z = min(z, mod_distance(x1, x3, m1))\n    z = min(z, mod_distance(x2, x3, m2))\n\n    z = min(z, mod_distance(x1, x2+m1, m1))\n    z = min(z, mod_distance(x1, x3+m1, m1))\n    z = min(z, mod_distance(x2, x3+m2, m2))\n\n    z = min(z, mod_distance(x1, x2+2*m1, m1))\n    z = min(z, mod_distance(x1, x3+2*m1, m1))\n    z = min(z, mod_distance(x2, x3+2*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+3*m1, m1))\n    z = min(z, mod_distance(x1, x3+3*m1, m1))\n    z = min(z, mod_distance(x2, x3+3*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+4*m1, m1))\n    z = min(z, mod_distance(x1, x3+4*m1, m1))\n    z = min(z, mod_distance(x2, x3+4*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+5*m1, m1))\n    z = min(z, mod_distance(x1, x3+5*m1, m1))\n    z = min(z, mod_distance(x2, x3+5*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+6*m1, m1))\n    z = min(z, mod_distance(x1, x3+6*m1, m1))\n    z = min(z, mod_distance(x2, x3+6*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+7*m1, m1))\n    z = min(z, mod_distance(x1, x3+7*m1, m1))\n    z = min(z, mod_distance(x2, x3+7*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+8*m1, m1))\n    z = min(z, mod_distance(x1, x3+8*m1, m1))\n    z = min(z, mod_distance(x2, x3+8*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+9*m1, m1))\n    z = min(z, mod_distance(x1, x3+9*m1, m1))\n    z = min(z, mod_distance(x2, x3+9*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+10*m1, m1))\n    z = min(z, mod_distance(x1, x3+10*m1, m1))\n    z = min(z, mod_distance(x2, x3+10*m2, m2))\n\n    z = min(z, mod_distance(x1, x2+11*m1, m1))\n    z = min(z, mod_distance(x1, x3+11*m1, m"
    },
    {
        "number": 3550,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n    for line in stdin.split('\\n'):\n        if line.startswith('var '):\n            name, value = line[4:].split('=')\n            variables[name.strip()] = value.strip()\n        elif line.startswith('print '):\n            expr = line[6:]\n            if expr.startswith('`') and expr.endswith('`'):\n                expr = expr[1:-1]\n                parts = expr.split('${')\n                result = parts[0]\n                for i in range(1, len(parts), 2):\n                    var_name, expr = parts[i].split('}')\n                    result += variables[var_name] + expr\n                print(result)\n            else:\n                print(variables[expr])\n    return ''"
    },
    {
        "number": 3551,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    N = int(lines[0])\n    volumes = list(map(int, lines[1].split()))\n    T = int(lines[2])\n\n    # check if it is possible to add the correct amount of dry ice\n    if sum(volumes) < T:\n        return \"impossible\"\n\n    # initialize variables\n    bottles = [0] * N\n    moves = []\n\n    # fill bottles until they are full\n    for i in range(N):\n        if volumes[i] > T:\n            bottles[i] = T\n            T = 0\n            break\n        else:\n            bottles[i] = volumes[i]\n            T -= volumes[i]\n\n    # if there is still dry ice left, transfer it into the ice cream mix\n    if T > 0:\n        moves.append(\"fill 0\")\n        moves.append(\"transfer 0 1\")\n        moves.append(\"transfer 0 2\")\n        moves.append(\"discard 1\")\n        moves.append(\"fill 0\")\n        moves.append(\"transfer 0 1\")\n        moves.append(\"transfer 0 2\")\n        moves.append(\"discard 1\")\n        moves.append(\"fill 0\")\n        moves.append(\"transfer 0 2\")\n\n    # output moves\n    return '\\n'.join(moves)"
    },
    {
        "number": 3552,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    damage = 0\n    for i in range(m):\n        damage += n // (m - i)\n    damage += n % (m - 1)\n    damage += k * (m - 1)\n    return str(damage)"
    },
    {
        "number": 3553,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, k, m = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n    queries = []\n    for _ in range(m):\n        query = stdin.readline().strip().split()\n        queries.append(query)\n\n    # solve queries\n    for query in queries:\n        if query[0] == '1':\n            p, v = map(int, query[1:])\n            arr[p-1] = v\n        elif query[0] == '2':\n            subarray = [arr[i] for i in range(n) if arr[i]!= 0]\n            if len(subarray) == 0:\n                print(-1)\n            else:\n                print(min(len(subarray), k))\n\n    return ''"
    },
    {
        "number": 3554,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, W, C = map(int, stdin.split())\n    # calculate the maximum distance the monkey can walk\n    max_distance = (D**2 + W**2)**0.5\n    # calculate the maximum number of containers the monkey can carry\n    max_containers = C // (D + W)\n    # calculate the maximum number of ml of smoothie the monkey can carry\n    max_ml = C // (D + W)\n    # calculate the total number of ml of smoothie the monkey can bring\n    total_ml = max_ml * max_containers\n    # calculate the distance the monkey can walk in one ml of smoothie\n    distance_per_ml = max_distance / total_ml\n    # calculate the number of ml of smoothie the monkey can bring in one meter\n    ml_per_meter = total_ml / max_distance\n    # calculate the number of meters the monkey can walk in one ml of smoothie\n    meters_per_ml = 1 / distance_per_ml\n    # calculate the number of meters the monkey can walk in one container\n    meters_per_container = meters_per_ml * D + meters_per_ml * W\n    # calculate the number of containers the monkey can bring in one meter\n    containers_per_meter = meters_per_container / (D + W)\n    # calculate the total number of containers the monkey can bring\n    total_containers = max_containers * containers_per_meter\n    # calculate the total number of ml of smoothie the monkey can bring\n    total_ml = total_containers * max_ml\n    # round the result to 7 decimal places\n    result = round(total_ml, 7)\n    return str(result)"
    },
    {
        "number": 3555,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    toys = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        toys.append((x, y))\n    trees = []\n    for i in range(m):\n        x, y = map(int, stdin.readline().split())\n        trees.append((x, y))\n    leash_length = 0\n    for i in range(n):\n        x, y = toys[i]\n        dist = min(abs(x - 0), abs(y - 0))\n        for j in range(i+1, n):\n            x1, y1 = toys[j]\n            dist += min(abs(x1 - x), abs(y1 - y))\n        leash_length = max(leash_length, dist)\n    return str(round(leash_length, 2))"
    },
    {
        "number": 3556,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    m, q = map(int, stdin.split()[0:2])\n    employees = []\n    for i in range(m):\n        emp_id, salary, height = map(int, stdin.split()[0:3])\n        employees.append((emp_id, salary, height))\n\n    # sort employees by salary and height\n    employees.sort(key=lambda x: (-x[1], -x[2]))\n\n    # find chairperson\n    chairperson = None\n    for emp_id, salary, height in employees:\n        if salary > employees[0][1]:\n            chairperson = emp_id\n            break\n\n    # process queries\n    for i in range(q):\n        emp_id = int(stdin.split()[0])\n        boss_id = None\n        num_subordinates = 0\n        for emp in employees:\n            if emp[0] == emp_id:\n                boss_id = emp[0]\n                break\n            elif emp[1] > employees[0][1] and emp[2] > employees[0][2] and emp[0]!= emp_id:\n                boss_id = emp[0]\n                num_subordinates += 1\n        if boss_id is None:\n            boss_id = 0\n        print(boss_id, num_subordinates)\n\n    return \"\""
    },
    {
        "number": 3557,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    passengers = list(map(int, stdin.readline().strip().split()))\n    order = list(map(int, stdin.readline().strip().split()))\n    chaos = 0\n    for i in range(n):\n        chaos += (passengers[i] + 9) // 10 * order.index(i+1)\n    return chaos"
    },
    {
        "number": 3558,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    buildings = []\n    for i in range(n):\n        has_transmitter, x, h = map(int, stdin.split())\n        buildings.append((x, h, has_transmitter))\n    covered = 0\n    for i in range(n):\n        x, h, has_transmitter = buildings[i]\n        if has_transmitter:\n            covered = max(covered, x + h)\n    return str(covered)"
    },
    {
        "number": 3559,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    attack1, armour1 = map(int, lines[1].split())\n    attack2, armour2 = map(int, lines[2].split())\n    map_ = lines[3].strip()\n    t = int(lines[4])\n\n    # initialize game state\n    zerglings = []\n    for i in range(n):\n        for j in range(n):\n            if map_[i*n+j] == '1':\n                zerglings.append((i, j, 35, attack1, armour1))\n            elif map_[i*n+j] == '2':\n                zerglings.append((i, j, 35, attack2, armour2))\n\n    # simulate game\n    for turn in range(t):\n        # attack phase\n        attacked = set()\n        for i in range(n):\n            for j in range(n):\n                if (i, j) in attacked:\n                    continue\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < n and 0 <= nj < n and map_[ni*n+nj] == '1' and (ni, nj) not in attacked:\n                        attacked.add((ni, nj))\n                        zerglings[i*n+j][3] -= zerglings[ni*n+nj][3] - zerglings[ni*n+nj][4]\n                        zerglings[ni*n+nj][2] -= zerglings[i*n+j][3] - zerglings[i*n+j][4]\n                        if zerglings[i*n+j][2] <= 0:\n                            zerglings[i*n+j][2] = 0\n                            zerglings[i*n+j][3] = 0\n                        if zerglings[ni*n+nj][2] <= 0:\n                            zerglings[ni*n+nj][2] = 0\n                            zerglings[ni*n+nj][3] = 0\n\n        # movement phase\n        moved = set()\n        for i in range(n):\n            for j in range(n):\n                if (i, j) in moved:\n                    continue\n                for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                    ni, nj = i+di, j+dj\n                    if 0 <= ni < n and 0 <= nj < n and map_[ni*n+nj] == '.' and (ni, nj) not in moved:\n                        moved.add((ni, nj))\n                        if (ni, nj) not in attacked:\n                            zerglings[i*n+j][0], zerglings[i*n+j][1] = ni, nj\n                        else:\n                            zerglings[i*n+j][0], zerglings[i*n+j][1] = ni, nj\n                            zerglings[ni*n+nj][0], zerglings[ni*n+nj][1] = i, j\n\n        # regeneration phase\n        for i in range(n):\n            for j in range(n):\n                if zerglings[i*n+j][2] < 35:\n                    zerglings[i*n+j][2] += 1\n\n    # output final map\n    result = ''\n    for i in range(n):\n        for j in range(n):\n            if map_[i*n+j] == '1':\n                result += '1'\n            elif map_[i*n+j] == '2':\n                result += '2'\n            else:\n                for z in zerglings:\n                    if z[0] == i and z[1] == j:\n                        result += '1' if z[2] > 0 else '.'\n                        break\n                else:\n                    result += '.'\n        result += '\\n'\n    return result.strip()"
    },
    {
        "number": 3560,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, q = map(int, stdin.readline().split())\n    words = [stdin.readline().strip() for _ in range(n)]\n    for i in range(q):\n        t = int(stdin.readline().strip())\n        if t == 1:\n            p = stdin.readline().strip()\n            # count consecutive substrings\n            count = 0\n            for word in words:\n                if p in word:\n                    count += 1\n            print(count)\n        else:\n            s = int(stdin.readline().strip())\n            # count consecutive substrings\n            count = 0\n            for word in words:\n                if words[s-1] in word:\n                    count += 1\n            print(count)\n    return \"\""
    },
    {
        "number": 3561,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, S, C, K = map(int, stdin.split())\n    if W + S + C <= K:\n        return \"YES\"\n    if W == 0 and S == 0 and C == 0:\n        return \"YES\"\n    if W == 0 and S == 0:\n        return \"NO\"\n    if W == 0 and C == 0:\n        return \"NO\"\n    if S == 0 and C == 0:\n        return \"NO\"\n    if W == 0:\n        return \"NO\"\n    if S == 0:\n        return \"NO\"\n    if C == 0:\n        return \"NO\"\n    if W + S <= K:\n        return \"NO\"\n    if W + C <= K:\n        return \"NO\"\n    if S + C <= K:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3562,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, T = map(int, stdin.split())\n    subjects = []\n    for i in range(N):\n        a, b, c = map(float, stdin.split())\n        subjects.append((a, b, c))\n\n    # compute optimal allocation\n    grades = [0] * N\n    for t in range(T):\n        for i in range(N):\n            a, b, c = subjects[i]\n            grades[i] += a * t**2 + b * t + c\n\n    # compute average grade\n    avg_grade = sum(grades) / N\n\n    # compute maximum average grade\n    max_avg_grade = 0\n    for i in range(N):\n        a, b, c = subjects[i]\n        max_avg_grade += max(0, min(100, c))\n\n    return f\"{max_avg_grade:.6f}\""
    },
    {
        "number": 3563,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [tuple(map(int, stdin.split())) for _ in range(2*n)]\n    points.sort()\n    lines = 1\n    for i in range(1, 2*n):\n        if points[i][0]!= points[i-1][0] and points[i][1]!= points[i-1][1]:\n            lines += 1\n    return str(lines)"
    },
    {
        "number": 3564,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    islands = []\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        islands.append((x, y, r))\n    palms = []\n    for i in range(m):\n        x, y, h = map(int, stdin.readline().split())\n        palms.append((x, y, h))\n    k = k * 100\n    for i in range(len(palms)):\n        palms[i] = (palms[i][0], palms[i][1], palms[i][2] * k)\n    dist = [[float('inf') for j in range(n)] for i in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            dist[i][j] = dist[j][i] = abs(islands[i][0]-islands[j][0]) + abs(islands[i][1]-islands[j][1])\n    for i in range(n):\n        for j in range(m):\n            dist[i][i] = min(dist[i][i], abs(islands[i][0]-palms[j][0]) + abs(islands[i][1]-palms[j][1]) - palms[j][2])\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    for i in range(n):\n        for j in range(i+1, n):\n            if dist[i][j] < 100:\n                return \"impossible\"\n    return 0"
    },
    {
        "number": 3565,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = [stdin.readline().strip() for _ in range(n)]\n    routes = []\n    for _ in range(m):\n        a, b, c = stdin.split()\n        routes.append((a, b, int(c)))\n    assignments = [stdin.readline().strip().split() for _ in range(4)]\n    scores = [0] * n\n    for a, b in assignments:\n        scores[cities.index(a)] += 1\n        scores[cities.index(b)] += 1\n    scores = sorted(scores, reverse=True)\n    total_score = sum(scores)\n    for a, b in assignments:\n        i, j = cities.index(a), cities.index(b)\n        if scores[i] == scores[j]:\n            total_score -= 1\n        else:\n            total_score -= 2\n    return str(total_score)"
    },
    {
        "number": 3566,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    for _ in range(q):\n        i, x = map(int, stdin.readline().split())\n        a[i] = x\n    left = [0] * n\n    right = [0] * n\n    for i in range(n):\n        if i == 0:\n            left[i] = a[i]\n        else:\n            left[i] = left[i-1] + a[i]\n    for i in range(n-1, -1, -1):\n        if i == n-1:\n            right[i] = a[i]\n        else:\n            right[i] = right[i+1] + a[i]\n    for _ in range(q):\n        i, x = map(int, stdin.readline().split())\n        if left[i] + right[i+1] - x > left[i+1] + right[i] - x:\n            print(i+1)\n        else:\n            print(i)\n    return \"\""
    },
    {
        "number": 3567,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    characters = []\n    for i in range(n):\n        characters.append(list(map(int, stdin.readline().strip())))\n    max_similarity = -1\n    best_character = None\n    for i in range(2**k):\n        binary = bin(i)[2:].zfill(k)\n        similarity = 0\n        for j in range(n):\n            count = 0\n            for k in range(k):\n                if binary[k] == '1' and characters[j][k] == 1:\n                    count += 1\n                elif binary[k] == '0' and characters[j][k] == 0:\n                    count += 1\n            similarity += count\n        if similarity > max_similarity:\n            max_similarity = similarity\n            best_character = binary\n    return best_character"
    },
    {
        "number": 3568,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f = int(stdin.split()[0])\n    for i in range(f):\n        t_i, n_i = map(int, stdin.split())\n        intervals = []\n        for j in range(n_i):\n            t_ij, t_ij1 = map(int, stdin.split())\n            intervals.append((t_ij, t_ij1))\n        if not is_valid(intervals):\n            return \"impossible\"\n    return \"possible\"\n\ndef"
    },
    {
        "number": 3569,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    circles = []\n    for i in range(n):\n        x, y, r = map(float, stdin.readline().strip().split())\n        circles.append((x, y, r))\n    max_hits = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1, r1 = circles[i]\n            x2, y2, r2 = circles[j]\n            dx, dy = x2-x1, y2-y1\n            d = (dx**2 + dy**2)**0.5\n            if d > r1+r2:\n                continue\n            if d < abs(r1-r2):\n                continue\n            if d == 0 and r1 == r2:\n                continue\n            a = math.acos((r1**2 + d**2 - r2**2) / (2*r1*d))\n            b = math.acos((r2**2 + d**2 - r1**2) / (2*r2*d))\n            max_hits = max(max_hits, int(a+b+3.14159265359))\n    return str(max_hits)"
    },
    {
        "number": 3570,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = []\n    dreams = []\n    scenarios = []\n    for line in stdin.split('\\n'):\n        if line.startswith('E '):\n            events.append(line[2:])\n        elif line.startswith('D '):\n            dreams.append(int(line[2:]))\n        elif line.startswith('S '):\n            scenario = line[2:].split()\n            k = int(scenario[0])\n            e = scenario[1:]\n            scenarios.append((k, e))\n    for scenario in scenarios:\n        k, e = scenario\n        if k == 1:\n            if e[0] in events:\n                return \"Yes\"\n            elif e[0] in dreams:\n                return \"1 Just A Dream\"\n            else:\n                return \"Plot Error\"\n        elif k == 2:\n            if e[0] in events and e[1] in events:\n                return \"Yes\"\n            elif e[0] in dreams and e[1] in events:\n                return \"2 Just A Dream\"\n            elif e[0] in events and e[1] in dreams:\n                return \"2 Just A Dream\"\n            elif e[0] in dreams and e[1] in dreams:\n                return \"3 Just A Dream\"\n            else:\n                return \"Plot Error\"\n        else:\n            return \"Plot Error\""
    },
    {
        "number": 3571,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, H, F, N = map(int, stdin.split())\n    text = stdin.split('\\n')[4:]\n    text = [line.strip() for line in text]\n    L = len(text)\n    T = thumb(L, H, F)\n    window = [''* W for _ in range(H)]\n    for i in range(T, T + H):\n        line = text[i]\n        if len(line) > W:\n            line = line[:W]\n        window[i - T] = line.ljust(W)\n    for i in range(H):\n        window[i] = '|' + window[i] + '|'\n    window = ['-' * W] + window + ['-' * W]\n    return '\\n'.join(window)\n\ndef"
    },
    {
        "number": 3572,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    distances = [[int(x) for x in stdin.split()] for _ in range(n)]\n    visited = [False] * n\n    visited[0] = True\n    total_distance = 0\n    current_point = 0\n    for i in range(n):\n        if visited[i]:\n            continue\n        visited[i] = True\n        current_point = i\n        total_distance = distances[current_point][0]\n        for j in range(1, n):\n            if visited[j]:\n                continue\n            if distances[current_point][j] > L:\n                return \"impossible\"\n            total_distance += distances[current_point][j]\n            if total_distance > L:\n                return \"impossible\"\n            visited[j] = True\n            current_point = j\n        if total_distance!= L:\n            return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3573,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, D, C = map(int, stdin.split())\n    cesar_numbers = list(map(int, stdin.readline().split()))\n    raul_numbers = list(map(int, stdin.readline().split()))\n\n    # calculate expected number of rounds\n    expected_rounds = 0\n    for i in range(C):\n        expected_rounds += (N - cesar_numbers[i] + 1) * (N - raul_numbers[i] + 1)\n    expected_rounds /= (N * C * (C - 1))\n    return f\"{expected_rounds:.8f}\""
    },
    {
        "number": 3574,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, *arr = map(int, stdin.split())\n    q = int(stdin.readline())\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.readline().split())\n        queries.append((l-1, r-1))\n\n    # solve\n    def is_magical(arr):\n        return all(arr[0] <= x <= arr[-1] for x in arr)\n\n    def longest_magical(arr):\n        if not is_magical(arr):\n            return 0\n        if len(arr) == 1:\n            return 1\n        if arr[0] == arr[-1]:\n            return 1 + longest_magical(arr[1:-1])\n        return max(longest_magical(arr[1:]), longest_magical(arr[:-1]))\n\n    ans = []\n    for l, r in queries:\n        sub_arr = arr[l:r+1]\n        ans.append(longest_magical(sub_arr))\n\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3575,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    neighbours = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, stdin.readline().split())\n        neighbours[u].append(v)\n        neighbours[v].append(u)\n    s, t = map(int, stdin.split()[0:2])\n    if s == t:\n        return \"never meet\"\n    visited = [False] * n\n    visited[s] = True\n    q = [(s, 0)]\n    while q:\n        u, time = q.pop(0)\n        if u == t:\n            return time\n        for v in neighbours[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append((v, (time + 1) % 24))\n    return \"never meet\""
    },
    {
        "number": 3576,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    p = 1\n    q = 10**11 + 3\n    for i in range(R):\n        for j in range(C):\n            if i == 0 or i == R-1 or j == 0 or j == C-1:\n                p *= 2\n            else:\n                p *= 3\n    for i in range(K):\n        p *= 2\n    q = pow(q, p, 10**11 + 3)\n    return str(q)"
    },
    {
        "number": 3577,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    plants = []\n    for i in range(1, n+1):\n        l, r = map(int, lines[i].split())\n        plants.append((l, r))\n    flowers = [0] * n\n    for i in range(1, n):\n        l, r = plants[i]\n        for j in range(i):\n            ll, rr = plants[j]\n            if l <= ll <= r or l <= rr <= r or ll <= l <= rr or rr <= l <= ll:\n                flowers[i] += 1\n    return '\\n'.join(map(str, flowers))"
    },
    {
        "number": 3578,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    N, R = map(int, lines[0].split())\n    flights = []\n    for i in range(1, R+1):\n        a, b, c = map(int, lines[i].split())\n        flights.append((a, b, c))\n    F = int(lines[R+1])\n    additional_flights = []\n    for i in range(R+2, R+2+F):\n        a, b, c = map(int, lines[i].split())\n        additional_flights.append((a, b, c))\n\n    # compute lowest cost\n    costs = [0] * (N+1)\n    for a, b, c in flights:\n        costs[a] += c\n        costs[b] += c\n    for a, b, c in additional_flights:\n        costs[a] += c\n        costs[b] += c\n    return str(min(costs))"
    },
    {
        "number": 3579,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0:2])\n    a, b = map(int, stdin.split()[2:4])\n    grid = []\n    for i in range(h):\n        grid.append(list(map(int, stdin.split())))\n    densities = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] > 0:\n                density = grid[i][j] / ((i+1)*(j+1))\n                densities.append(density)\n    densities.sort()\n    median = densities[len(densities)//2]\n    mad = sum([abs(x-median) for x in densities])/len(densities)\n    return f\"{mad:.6f}\""
    },
    {
        "number": 3580,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    q = int(stdin.readline())\n    for i in range(q):\n        i, m = map(int, stdin.readline().split())\n        b = list(map(int, stdin.readline().split()))\n        max_len = 0\n        curr_len = 0\n        for j in range(i-1, -1, -1):\n            if a[j] in b:\n                curr_len += 1\n                max_len = max(max_len, curr_len)\n            else:\n                curr_len = 0\n        curr_len = 0\n        for j in range(i, n):\n            if a[j] in b:\n                curr_len += 1\n                max_len = max(max_len, curr_len)\n            else:\n                curr_len = 0\n        print(max_len)\n    return \"\""
    },
    {
        "number": 3581,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    payouts = list(map(int, lines[1].split()))\n    assert len(payouts) == n*(n+1)//2\n    probs = []\n    for i in range(n):\n        probs.append(list(map(float, lines[2+i].split())))\n        assert len(probs[-1]) == 5\n        assert sum(probs[-1]) == 1.0\n    # simulate game\n    total_payout = 0\n    for i in range(n*(n+1)//2):\n        if payouts[i] > 0:\n            total_payout += payouts[i]\n    return str(total_payout)"
    },
    {
        "number": 3582,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = [0] * n\n    for i in range(n):\n        if a[i] == i:\n            b[i] = i\n        else:\n            b[i] = a[i]\n            for j in range(i+1, n):\n                if a[j] == i:\n                    b[i] = j\n                    break\n    return''.join(map(str, b))"
    },
    {
        "number": 3583,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n    max_circumference = 0\n    for i in range(n):\n        x, y = points[i]\n        left = right = float('-inf')\n        for j in range(n):\n            if j == i:\n                continue\n            x1, y1 = points[j]\n            if x1 <= x:\n                left = max(left, y1)\n            else:\n                right = max(right, y1)\n        if left == float('-inf') and right == float('-inf'):\n            circumference = 2 * (x ** 2 + y ** 2) ** 0.5\n        elif left == float('-inf'):\n            circumference = 2 * (x ** 2 + right ** 2) ** 0.5\n        elif right == float('-inf'):\n            circumference = 2 * (x ** 2 + left ** 2) ** 0.5\n        else:\n            circumference = 2 * (x ** 2 + (left + right) / 2) ** 0.5\n        max_circumference = max(max_circumference, circumference)\n    return '\\n'.join(map(str, [max_circumference] * n))"
    },
    {
        "number": 3584,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, k = map(int, stdin.readline().split())\n    onions = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        onions.append((x, y))\n    posts = []\n    for i in range(m):\n        a, b = map(int, stdin.readline().split())\n        posts.append((a, b))\n\n    # sort onions by x-coordinate\n    onions.sort(key=lambda x: x[0])\n\n    # find the convex hull of the fence posts\n    hull = []\n    for i in range(m):\n        while len(hull) >= 2 and cross(hull[-2], hull[-1], posts[i]) <= 0:\n            hull.pop()\n        hull.append(posts[i])\n    while len(hull) >= 2 and cross(hull[-2], hull[-1], hull[0]) <= 0:\n        hull.pop()\n\n    # count the number of onions in the convex hull\n    count = 0\n    for i in range(n):\n        if is_inside(hull, onions[i]):\n            count += 1\n\n    # upgrade the fence posts\n    for i in range(k):\n        # find the fence post with the largest y-coordinate\n        max_y = -1\n        max_j = -1\n        for j in range(m):\n            if posts[j][1] > max_y:\n                max_y = posts[j][1]\n                max_j = j\n        # upgrade the fence post\n        posts[max_j] = (posts[max_j][0], posts[max_j][1] + 1)\n\n    # count the number of onions in the new fence\n    count = 0\n    for i in range(n):\n        if is_inside(hull, onions[i]):\n            count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3585,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    if k == 1:\n        return str(m)\n    if k == 2:\n        return str(m*(m-1)//2)\n    if k == 3:\n        return str(m*(m-1)*(m-2)//6)\n    if k == 4:\n        return str(m*(m-1)*(m-2)*(m-3)//24)\n    if k == 5:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)//120)\n    if k == 6:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)//720)\n    if k == 7:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)//5040)\n    if k == 8:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)//40320)\n    if k == 9:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)//362880)\n    if k == 10:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)//3628800)\n    if k == 11:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)//39916800)\n    if k == 12:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)//479001600)\n    if k == 13:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)//6227020800)\n    if k == 14:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)*(m-13)//87178291200)\n    if k == 15:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)*(m-13)*(m-14)//1307674368000)\n    if k == 16:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)*(m-13)*(m-14)*(m-15)//20922789888000)\n    if k == 17:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)*(m-13)*(m-14)*(m-15)*(m-16)//355687428096000)\n    if k == 18:\n        return str(m*(m-1)*(m-2)*(m-3)*(m-4)*(m-5)*(m-6)*(m-7)*(m-8)*(m-9)*(m-10)*(m-11)*(m-12)*(m-13)*(m-14)*(m-15)*(m-"
    },
    {
        "number": 3586,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    s = set(map(int, stdin.readlines()))\n\n    # Find largest d such that a + b + c = d\n    for a in s:\n        for b in s:\n            if a + b in s:\n                for c in s:\n                    if a + b + c in s:\n                        return str(a + b + c)\n\n    # No solution found\n    return \"no solution\""
    },
    {
        "number": 3587,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    taboo = [stdin.readline().strip() for _ in range(n)]\n    clue = stdin.readline().strip()\n    if any(t in clue for t in taboo):\n        return '-1'\n    max_len = 0\n    max_clue = ''\n    for i in range(1, 2**len(clue)):\n        s = bin(i)[2:].zfill(len(clue))\n        if all(t not in s for t in taboo) and len(s) > max_len:\n            max_len = len(s)\n            max_clue = s\n    return max_clue"
    },
    {
        "number": 3588,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    num_companies = int(lines[0])\n    companies = []\n    for i in range(1, num_companies+1):\n        num_records = int(lines[i])\n        records = []\n        for j in range(i+1, i+1+num_records):\n            shares, day = map(int, lines[j].split())\n            records.append((day, shares))\n        companies.append(records)\n\n    # Compute share totals\n    share_totals = []\n    for day in range(1, 366):\n        total = 0\n        for company in companies:\n            for record in company:\n                if record[0] == day:\n                    total += record[1]\n        share_totals.append(total)\n\n    # Print share totals\n    return''.join(map(str, share_totals))"
    },
    {
        "number": 3589,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    counts = [0] * 10\n    for x in range(L, R+1):\n        while x > 0:\n            digit = x % 10\n            counts[digit] += 1\n            x //= 10\n        x = L\n        while x > 0:\n            digit = x % 10\n            counts[digit] -= 1\n            x //= 10\n    return''.join(map(str, counts))"
    },
    {
        "number": 3590,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    a, b = map(int, stdin.readline().split())\n    points_a = []\n    for i in range(a):\n        x, y = map(int, stdin.readline().split())\n        points_a.append((x, y))\n    points_b = []\n    for i in range(b):\n        x, y = map(int, stdin.readline().split())\n        points_b.append((x, y))\n\n    # find the intersection point of the two polygons\n    intersection = None\n    for i in range(len(points_a)):\n        for j in range(len(points_b)):\n            if points_a[i] == points_b[j]:\n                intersection = points_a[i]\n                break\n        if intersection is not None:\n            break\n\n    # if there is no intersection, return 0\n    if intersection is None:\n        return \"0.0000000000\"\n\n    # find the cut line\n    cut_line = None\n    for i in range(len(points_a)):\n        for j in range(len(points_b)):\n            if points_a[i]!= intersection and points_b[j]!= intersection:\n                cut_line = (points_a[i], points_b[j])\n                break\n        if cut_line is not None:\n            break\n\n    # if there is no cut line, return 0\n    if cut_line is None:\n        return \"0.0000000000\"\n\n    # calculate the cost of the cut\n    cost = 0\n    for i in range(len(points_a)):\n        if points_a[i]!= intersection:\n            cost += abs(points_a[i][0] - intersection[0]) + abs(points_a[i][1] - intersection[1])\n    for i in range(len(points_b)):\n        if points_b[i]!= intersection:\n            cost += abs(points_b[i][0] - intersection[0]) + abs(points_b[i][1] - intersection[1])\n\n    return \"{:.10f}\".format(cost)"
    },
    {
        "number": 3591,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    result = []\n    for i in range(k):\n        n = int(stdin.readline().strip())\n        heights = list(map(int, stdin.readline().strip().split()))\n        alice_index = heights.index(max(heights[:n//2]))\n        bob_index = heights.index(max(heights[n//2:]))\n        if alice_index < n//2 and bob_index > n//2:\n            result.append(i+1)\n    return str(len(result)) + '\\n' + '\\n'.join(map(str, result))"
    },
    {
        "number": 3592,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    profit, pita_profit, pizza_profit = map(float, stdin.split())\n    pita_sales = int(profit / pita_profit)\n    pizza_sales = int(profit / pizza_profit)\n    if pita_sales * pita_profit + pizza_sales * pizza_profit == profit:\n        return f\"{pita_sales} {pizza_sales}\"\n    else:\n        return \"none\""
    },
    {
        "number": 3593,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    board = []\n    for i in range(N):\n        board.append(list(map(int, stdin.split())))\n    dp = [[0] * (K+1) for _ in range(N+1)]\n    for i in range(1, N+1):\n        for j in range(1, K+1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            if i >= 2 and j >= 2:\n                dp[i][j] = max(dp[i][j], dp[i-2][j-2] + board[i-1][0] + board[i-2][1])\n    return dp[N][K]"
    },
    {
        "number": 3594,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rounds = []\n    for i in range(n):\n        name, num = stdin.split()[1:]\n        rounds.append((name, int(num)))\n    scores = [0, 0, 0]\n    for i in range(n):\n        name, num = rounds[i]\n        if num == 1:\n            scores[0] += 1\n            scores[1] += 1\n            scores[2] += 1\n        elif name == 'O':\n            scores[0] += num\n            scores[1] += min(num // 2, 1)\n            scores[2] += min(num // 3, 1)\n        elif name == 'E':\n            scores[1] += num\n            scores[0] += min(num // 2, 1)\n            scores[2] += min(num // 3, 1)\n        else:\n            scores[2] += num\n            scores[0] += min(num // 2, 1)\n            scores[1] += min(num // 3, 1)\n    return''.join(map(str, scores))"
    },
    {
        "number": 3595,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, l = map(int, stdin.split())\n    rooms = []\n    for i in range(r):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        rooms.append(((x1, y1), (x2, y2)))\n    hits = 0\n    for room in rooms:\n        x1, y1 = room[0]\n        x2, y2 = room[1]\n        if x1 <= l and y1 <= l and x2 >= 1000 - l and y2 >= 1000 - l:\n            hits += 1\n    return str(hits)"
    },
    {
        "number": 3596,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split()[0:3])\n    t1, t2, t3, t4 = map(int, stdin.split()[3:7])\n    n, k, r, s, l = map(int, stdin.split()[7:])\n\n    def gamma(z):\n        return integrate.quad(lambda x: x**(z - 1) * exp(-x), 0, inf)[0]\n\n    def erf(x):\n        return integrate.quad(lambda t: exp(-t**2), 0, x)[0]\n\n    def jacobi(k, x):\n        return integrate.quad(lambda tau: cos(k * tau - x * sin(tau)), 0, pi)[0]\n\n    def f(x):\n        return c * integrate.quad(lambda x: (t1 * gamma(x) + sqrt(t2) * log(erf(t3 * x))) - jacobi(k, x)**t4, a, b)[0]\n\n    def P(x, n):\n        if n == 0:\n            return f(x)\n        else:\n            return sum([P(i, n - 1) * x**i for i in range(n + r + 1)])\n\n    def g(n):\n        return P(0, s)\n\n    for i in range(n):\n        g = diff(g, 1)\n\n    return f\"{(g(n) + l)**2 / (pi * e) + 1 / (l + 1):.2f}\""
    },
    {
        "number": 3597,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    w, l = map(int, stdin.split()[0:2])\n    r, x1, y1, x2, y2, x3, y3, h = map(int, stdin.split()[1:])\n\n    # check if trick shot is possible\n    if h > (l/2):\n        return \"impossible\"\n\n    # calculate distance and angle\n    d = (x1**2 + y1**2 + x2**2 + y2**2 + x3**2 + y3**2)**0.5\n    theta = 180 - (180/3.141592653589793*atan2(y2-y1, x2-x1))\n\n    # round to two decimal places\n    d = round(d, 2)\n    theta = round(theta, 2)\n\n    # return result\n    return f\"{d} {theta}\""
    },
    {
        "number": 3598,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    magnets = [stdin.readline().strip() for _ in range(n)]\n    digits = set('0123456789')\n    for i in range(n):\n        for j in range(i+1, n):\n            if set(magnets[i]) & set(magnets[j])!= set():\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i] == magnets[j]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i] == magnets[j][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1][::-1]:\n                return 'IMPOSSIBLE'\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][::-1] == magnets[j][::-1][::-1][::-1][::-1][::-1][::-1][::-1"
    },
    {
        "number": 3599,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N = map(int, stdin.split())\n    breaks = list(map(int, stdin.readline().split()))\n    breaks.sort()\n    result = []\n    for i in range(N):\n        result.append(sum(breaks[:i+1]))\n    return''.join(map(str, result))"
    },
    {
        "number": 3600,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.splitlines()[0].split())\n    graph = [[] for _ in range(n+1)]\n    for i in range(1, n+1):\n        d, *neighbours = map(int, stdin.splitlines()[i].split())\n        for neighbour in neighbours:\n            graph[i].append(neighbour)\n            graph[neighbour].append(i)\n    visited = [False] * (n+1)\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbour in graph[node]:\n            if neighbour == parent:\n                continue\n            if visited[neighbour]:\n                return False\n            if not dfs(neighbour, node):\n                return False\n        return True\n    for i in range(1, n+1):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return \"impossible\"\n    if k > n*(n-1)//2:\n        return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3601,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    misha_path = [(int(x), int(y)) for x, y in [line.split() for line in lines[1:1+n]]]\n    n = int(lines[1+n])\n    nadia_path = [(int(x), int(y)) for x, y in [line.split() for line in lines[2+n:2+n+n]]]\n\n    # calculate distance between each pair of places\n    dist = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            dx = misha_path[j][0] - misha_path[i][0]\n            dy = misha_path[j][1] - misha_path[i][1]\n            dist[i][j] = dist[j][i] = abs(dx) + abs(dy)\n\n    # calculate shortest delivery time\n    dp = [[float('inf')] * n for _ in range(n)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(n):\n                if dist[i][k] + dist[k][j] <= 10000:\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dist[k][j])\n\n    # check if delivery is possible\n    if dp[0][n-1] == float('inf'):\n        return 'impossible'\n\n    # round to 5 decimal places\n    return '{:.5f}'.format(dp[0][n-1])"
    },
    {
        "number": 3602,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, k = map(int, stdin.split())\n    grid = [[0] * n for _ in range(n)]\n    for _ in range(k):\n        i, j = map(int, stdin.split())\n        grid[i-1][j-1] = 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                for x in range(max(0, i-r), min(n, i+r+1)):\n                    for y in range(max(0, j-r), min(n, j+r+1)):\n                        if x == i or y == j:\n                            grid[x][y] = 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                return \"0\"\n    return \"1\""
    },
    {
        "number": 3603,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split())\n    languages = [[] for _ in range(n)]\n    for i in range(m):\n        l1, l2 = map(int, stdin.split())\n        languages[l1].append(l2)\n        languages[l2].append(l1)\n\n    # check if it is possible to match up all translators\n    for i in range(n):\n        if len(languages[i]) < 2:\n            return \"impossible\"\n\n    # find matching\n    pairs = []\n    for i in range(m):\n        for j in range(i+1, m):\n            if languages[i][0] == languages[j][0] or languages[i][0] == languages[j][1] or languages[i][1] == languages[j][0] or languages[i][1] == languages[j][1]:\n                pairs.append((i, j))\n\n    # print matching\n    if len(pairs)!= m // 2:\n        return \"impossible\"\n    for i in range(m // 2):\n        print(pairs[i][0], pairs[i][1])\n    return \"\""
    },
    {
        "number": 3604,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n    points.sort()\n    subset = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if points[j][0] - points[i][0] <= d and points[j][1] - points[i][1] <= d:\n                subset.append((i+1, j+1))\n    return str(len(subset)) + '\\n' + '\\n'.join(' '.join(map(str, s)) for s in subset)"
    },
    {
        "number": 3605,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    min_diff = float('inf')\n    for i in range(n - k + 1):\n        min_diff = min(min_diff, a[i + k - 1] - a[i])\n    return str(min_diff)"
    },
    {
        "number": 3606,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    plants = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        plants.append((x, y))\n    directions = stdin.readline().strip()\n    x, y = plants[0]\n    for d in directions:\n        if d == 'A':\n            for i in range(1, n+1):\n                if (x+i, y+i) in plants:\n                    x += i\n                    y += i\n                    break\n        elif d == 'B':\n            for i in range(1, n+1):\n                if (x+i, y-i) in plants:\n                    x += i\n                    y -= i\n                    break\n        elif d == 'C':\n            for i in range(1, n+1):\n                if (x-i, y+i) in plants:\n                    x -= i\n                    y += i\n                    break\n        elif d == 'D':\n            for i in range(1, n+1):\n                if (x-i, y-i) in plants:\n                    x -= i\n                    y -= i\n                    break\n    return f\"{x} {y}\""
    },
    {
        "number": 3607,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n    labels = {}\n    lines = stdin.split('\\n')\n    for line in lines:\n        if not line:\n            continue\n        label, command = line.split(' ', 1)\n        label = int(label)\n        if command.startswith('LET'):\n            var, expr = command.split('=', 1)\n            var = var.strip()\n            expr = expr.strip()\n            if var.isalpha():\n                variables[var] = evaluate(expr, variables)\n            else:\n                raise ValueError('Invalid variable name')\n        elif command.startswith('IF'):\n            condition, label_str = command.split('THEN', 1)\n            condition = condition.strip()\n            label_str = label_str.strip()\n            if evaluate(condition, variables):\n                labels[label] = label_str\n        elif command.startswith('PRINT'):\n            statement = command.split(' ', 1)[1].strip()\n            print(statement)\n        elif command.startswith('PRINTLN'):\n            statement = command.split(' ', 1)[1].strip()\n            print(statement)\n            print()\n        else:\n            raise ValueError('Invalid command')\n    return ''\n\ndef"
    },
    {
        "number": 3608,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    tasks_by_difficulty = [int(x) for x in stdin.readline().strip().split()]\n    tasks_by_difficulty_or_higher = [int(x) for x in stdin.readline().strip().split()]\n\n    # initialize variables\n    ways = 1\n    for i in range(N):\n        ways *= tasks_by_difficulty[i] + tasks_by_difficulty_or_higher[i]\n        ways %= 1000000007\n\n    return str(ways)"
    },
    {
        "number": 3609,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = [tuple(map(int, line.strip().split())) for line in stdin]\n    left_tree = set(range(1, n))\n    right_tree = set(range(n, 2*n))\n    for u, v in edges:\n        if u in left_tree and v in right_tree:\n            left_tree.remove(u)\n            right_tree.remove(v)\n        elif u in right_tree and v in left_tree:\n            right_tree.remove(u)\n            left_tree.remove(v)\n        else:\n            return \"impossible\"\n    if len(left_tree)!= len(right_tree):\n        return \"impossible\"\n    result = \"\"\n    for u, v in edges:\n        if u in left_tree and v in right_tree:\n            result += \"L\"\n            left_tree.remove(u)\n            right_tree.remove(v)\n        elif u in right_tree and v in left_tree:\n            result += \"R\"\n            right_tree.remove(u)\n            left_tree.remove(v)\n        else:\n            return \"impossible\"\n    return result"
    },
    {
        "number": 3610,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    num_teams = int(stdin.readline().strip())\n    teams = []\n    for i in range(num_teams):\n        team = stdin.readline().strip().split()\n        teams.append((int(team[0]), int(team[1])))\n\n    # compute solution\n    num_invites = 0\n    invitees = set()\n    for team in teams:\n        if team[0] == 1009 or team[1] == 1009:\n            num_invites += 1\n            invitees.add(1009)\n        elif team[0] >= 1000 and team[0] <= 1999 and team[1] >= 2000 and team[1] <= 2999:\n            num_invites += 2\n            invitees.add(team[0])\n            invitees.add(team[1])\n\n    # output solution\n    stdout = str(num_invites) + '\\n'\n    for invitee in invitees:\n        stdout += str(invitee) + '\\n'\n    return stdout"
    },
    {
        "number": 3611,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.readline().split())\n    links = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.readline().split())\n        links.append((u, v, w))\n    s, t = map(int, stdin.readline().split())\n\n    # build graph\n    graph = [[] for _ in range(n)]\n    for u, v, w in links:\n        graph[u].append((v, w))\n\n    # bfs to find shortest paths\n    dist = [float('inf')] * n\n    dist[s] = 0\n    queue = [s]\n    while queue:\n        u = queue.pop(0)\n        for v, w in graph[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                queue.append(v)\n\n    # find stations that intercept Fatima\n    stations = []\n    for i in range(n):\n        if dist[i]!= float('inf') and i!= s and i!= t:\n            stations.append(i)\n\n    # sort stations by increasing distance to s\n    stations.sort(key=lambda x: dist[s] + dist[x])\n\n    # output result\n    return''.join(map(str, stations))"
    },
    {
        "number": 3612,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m = map(float, stdin.split()[0:2])\n    W, H, X, Y = map(int, stdin.split()[2:6])\n    heights = []\n    for i in range(H):\n        heights.append(list(map(int, stdin.split())))\n    # print(heights)\n    # print(X, Y)\n    # print(W, H)\n    # print(a, m)\n    # print(heights[Y][X])\n    # print(heights[Y+1][X])\n    # print(heights[Y][X+1])\n    # print(heights[Y+1][X+1])\n    # print(heights[Y-1][X])\n    # print(heights[Y][X-1])\n    # print(heights[Y-1][X-1])\n    # print(heights[Y+1][X-1])\n    # print(heights[Y-1][X+1])\n    # print(heights[Y+2][X])\n    # print(heights[Y][X+2])\n    # print(heights[Y+2][X+2])\n    # print(heights[Y-2][X])\n    # print(heights[Y][X-2])\n    # print(heights[Y-2][X-2])\n    # print(heights[Y+2][X-2])\n    # print(heights[Y-2][X+2])\n    # print(heights[Y+3][X])\n    # print(heights[Y][X+3])\n    # print(heights[Y+3][X+3])\n    # print(heights[Y-3][X])\n    # print(heights[Y][X-3])\n    # print(heights[Y-3][X-3])\n    # print(heights[Y+3][X-3])\n    # print(heights[Y-3][X+3])\n    # print(heights[Y+4][X])\n    # print(heights[Y][X+4])\n    # print(heights[Y+4][X+4])\n    # print(heights[Y-4][X])\n    # print(heights[Y][X-4])\n    # print(heights[Y-4][X-4])\n    # print(heights[Y+4][X-4])\n    # print(heights[Y-4][X+4])\n    # print(heights[Y+5][X])\n    # print(heights[Y][X+5])\n    # print(heights[Y+5][X+5])\n    # print(heights[Y-5][X])\n    # print(heights[Y][X-5])\n    # print(heights[Y-5][X-5])\n    # print(heights[Y+5][X-5])\n    # print(heights[Y-5][X+5])\n    # print(heights[Y+6][X])\n    # print(heights[Y][X+6])\n    # print(heights[Y+6][X+6])\n    # print(heights[Y-6][X])\n    # print(heights[Y][X-6])\n    # print(heights[Y-6][X-6])\n    # print(heights[Y+6][X-6])\n    # print(heights[Y-6][X+6])\n    # print(heights[Y+7][X])\n    # print(heights[Y][X+7])\n    # print(heights[Y+7][X+7])\n    # print(heights[Y-7][X])\n    # print(heights[Y][X-7])\n    # print(heights[Y-7][X-7])\n    # print(heights[Y+7][X-7])\n    # print(heights[Y-7][X+7])\n    # print(heights[Y+8][X])\n    # print(heights[Y][X+8])\n    # print(heights[Y+8][X+8])\n    # print(heights[Y-8][X])\n    # print(heights[Y][X-8])\n    # print(heights[Y-8][X-8])\n    # print(heights[Y+8][X-8])\n    # print(heights[Y-8][X+8])\n    # print(heights[Y+9][X])\n    # print(heights"
    },
    {
        "number": 3613,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    kids = []\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        teacher = int(line[0])\n        prefs = [int(x) for x in line[1:]]\n        kids.append((teacher, prefs))\n\n    # sort kids by preference list length\n    kids.sort(key=lambda x: len(x[1]))\n\n    # find smallest T such that all kids have a different teacher and their classmates are among the top T places of their preference lists\n    T = 0\n    while True:\n        # check if all kids have a different teacher and their classmates are among the top T places of their preference lists\n        for i in range(n):\n            if kids[i][0] == kids[i][1][0]:\n                break\n        else:\n            return str(T)\n\n        # increment T and try again\n        T += 1"
    },
    {
        "number": 3614,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, R, C = map(int, stdin.splitlines()[0].split())\n    petals = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Initialize variables\n    visited = set()\n    queue = [(R, C)]\n    max_flowers = 0\n\n    # BFS\n    while queue:\n        r, c = queue.pop(0)\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        max_flowers += 1\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 1 <= nr <= N and 1 <= nc <= N and (nr, nc) not in visited:\n                if abs(nr - r) == 1 and abs(nc - c) > 1:\n                    queue.append((nr, nc))\n                elif abs(nc - c) == 1 and abs(nr - r) > 1:\n                    queue.append((nr, nc))\n\n    return max_flowers"
    },
    {
        "number": 3615,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    towers = []\n    for i in range(n):\n        x, y = map(float, stdin.readline().strip().split())\n        towers.append((x, y))\n    towers.sort()\n    count = 1\n    for i in range(1, n):\n        if abs(towers[i][0] - towers[i-1][0]) > 1 or abs(towers[i][1] - towers[i-1][1]) > 1:\n            count += 1\n    return count"
    },
    {
        "number": 3616,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    durations = list(map(int, stdin.readline().strip().split()))\n    durations.sort()\n    days = 0\n    for i in range(k):\n        days += durations[i]\n    return str(days)"
    },
    {
        "number": 3617,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, t = map(int, stdin.split())\n    a, b, c, t0 = map(int, stdin.readline().split())\n    times = [t0]\n    for i in range(1, n):\n        times.append(((a * times[-1] + b) % c) + 1)\n\n    # solve problem\n    max_problems = 1\n    penalty = 0\n    for i in range(n):\n        if times[i] <= t:\n            max_problems += 1\n            penalty += times[i]\n        else:\n            break\n\n    # print output\n    return f\"{max_problems} {penalty % 1000000007}\""
    },
    {
        "number": 3618,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(10**n):\n        x = str(i).zfill(n)\n        y = str(friendly(x)).zfill(n)\n        if x!= y and x < y:\n            count += 1\n    return count % 998244353\n\ndef"
    },
    {
        "number": 3619,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    candidates = []\n    for i in range(n):\n        s, p, r = map(int, stdin.readline().split())\n        candidates.append((s, p, r))\n    candidates.sort(key=lambda x: x[2])\n    team = [candidates[0]]\n    for i in range(1, n):\n        if candidates[i][2] == team[-1][2] or candidates[i][2] == 0:\n            team.append(candidates[i])\n    if len(team) < k:\n        return \"0.000\"\n    total_salary = sum(x[0] for x in team)\n    total_productivity = sum(x[1] for x in team)\n    return \"{:.3f}\".format(total_productivity / total_salary)"
    },
    {
        "number": 3620,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M, k, P = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # build graph\n    graph = [[] for _ in range(N+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # count connected components\n    components = []\n    visited = [False] * (N+1)\n    for i in range(1, N+1):\n        if not visited[i]:\n            component = [i]\n            visited[i] = True\n            stack = [i]\n            while stack:\n                node = stack.pop()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        component.append(neighbor)\n                        visited[neighbor] = True\n                        stack.append(neighbor)\n            components.append(component)\n\n    # count colourings\n    colourings = 1\n    for component in components:\n        if len(component) <= k:\n            colourings *= len(component) + 1\n        else:\n            colourings *= k + 1\n\n    # output result\n    return str(colourings % P)"
    },
    {
        "number": 3621,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9+7\n    n = int(stdin.readline().strip())\n    graph = [[int(c) for c in stdin.readline().strip().split()] for _ in range(n)]\n    dp = [[0]*301 for _ in range(n)]\n    for i in range(n):\n        dp[i][graph[i][i]] = 1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if i!= j and graph[i][j] == graph[i][k] == graph[k][j]:\n                    dp[i][graph[i][j]] = (dp[i][graph[i][j]] + dp[k][graph[i][j]]) % MOD\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                ans = (ans + dp[i][graph[i][j]]) % MOD\n    return str(ans)"
    },
    {
        "number": 3622,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    w, h = map(int, stdin.readline().split())\n    u, d, l, r = map(int, stdin.readline().split())\n    grid = [list(stdin.readline().strip()) for _ in range(h)]\n\n    # calculate probabilities for each target\n    target_probs = []\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'T':\n                # count number of open spaces above, below, left, and right\n                num_open_spaces = 0\n                if i > 0 and grid[i-1][j]!= 'X':\n                    num_open_spaces += 1\n                if i < h-1 and grid[i+1][j]!= 'X':\n                    num_open_spaces += 1\n                if j > 0 and grid[i][j-1]!= 'X':\n                    num_open_spaces += 1\n                if j < w-1 and grid[i][j+1]!= 'X':\n                    num_open_spaces += 1\n                \n                # calculate probability of hitting target\n                target_probs.append(1 - (1 - u/100)**num_open_spaces * (1 - d/100)**num_open_spaces * (1 - l/100)**num_open_spaces * (1 - r/100)**num_open_spaces)\n\n    # format output\n    return '\\n'.join(f'{p:.10f}' for p in target_probs)"
    },
    {
        "number": 3623,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(float, stdin.split())\n    angles = [a, b, c, d]\n    angles.sort()\n    if angles[0] == 0:\n        return \"1.0\"\n    if angles[0] == 90:\n        return \"0.0\"\n    if angles[0] == 45:\n        return \"0.5\"\n    if angles[0] == 135:\n        return \"0.25\"\n    if angles[0] == 180:\n        return \"0.0\"\n    if angles[0] == 225:\n        return \"0.25\"\n    if angles[0] == 270:\n        return \"0.0\"\n    if angles[0] == 315:\n        return \"0.25\"\n    return \"0.0\""
    },
    {
        "number": 3624,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    visited = [False] * n\n    q = [(0, 0)]\n    while q:\n        u, t = q.pop(0)\n        if u == n-1:\n            return t\n        if not visited[u]:\n            visited[u] = True\n            for v, d in graph[u]:\n                q.append((v, t+d))\n    return -1"
    },
    {
        "number": 3625,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    populations = []\n    for i in range(n):\n        y, i, s, b = map(int, stdin.readline().strip().split())\n        populations.append((y, i, s, b))\n\n    # simulate population growth\n    max_trees = 0\n    for year in range(1000000):\n        total_trees = 0\n        for y, i, s, b in populations:\n            if year >= b:\n                total_trees += i\n            else:\n                total_trees += i * (year - b + 1) / y\n        max_trees = max(max_trees, total_trees)\n\n    return str(max_trees)"
    },
    {
        "number": 3626,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rectangles = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        rectangles.append((x1, y1, x2, y2))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles[i][0] <= rectangles[j][2] and rectangles[i][2] >= rectangles[j][0] and rectangles[i][1] <= rectangles[j][3] and rectangles[i][3] >= rectangles[j][1]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3627,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    R, C = map(int, stdin.readline().split())\n    cliff = [list(map(int, stdin.readline().split())) for _ in range(R)]\n    start = [list(stdin.readline().strip()) for _ in range(R)]\n\n    # initialize variables\n    energy = 0\n    visited = set()\n    queue = [(0, 0, 0)]\n\n    # bfs\n    while queue:\n        e, r, c = queue.pop(0)\n        if (r, c) in visited:\n            continue\n        visited.add((r, c))\n        energy += e\n        if start[r][c] == 'S':\n            return energy\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < R and 0 <= nc < C and cliff[nr][nc]!= -1:\n                queue.append((cliff[nr][nc], nr, nc))\n\n    return -1  # unreachable"
    },
    {
        "number": 3628,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    for i in range(n):\n        for j in range(i+1, n):\n            if (a[i] + a[j]) % n == 0:\n                pi = [i+1] * n\n                pi[i], pi[j] = pi[j], pi[i]\n                sigma = [i+1] * n\n                sigma[i], sigma[j] = sigma[j], sigma[i]\n                if all((pi[i] + sigma[i]) % n == a[i] for i in range(n)):\n                    return f\"{' '.join(map(str, pi))}\\n{' '.join(map(str, sigma))}\"\n    return \"impossible\""
    },
    {
        "number": 3629,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, b, d = map(int, stdin.split())\n    trees = []\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().split())\n        trees.append((x, y, r))\n\n    # simulate boar\n    x, y = 0, 0\n    dx, dy = random.uniform(-1, 1), random.uniform(-1, 1)\n    for i in range(d):\n        x += dx\n        y += dy\n        if any(distance(x, y, tx, ty) <= r + b for tx, ty, r in trees):\n            return 0\n    return 1\n\ndef"
    },
    {
        "number": 3630,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.strip().split()\n    n = len(s1)\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(n):\n        dp[i][i+1] = 1\n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i+l\n            if s1[i:j] == s2[i:j]:\n                dp[i][j] = dp[i+1][j-1]\n            else:\n                if s1[i:j].count('z') > 0:\n                    dp[i][j] = float('inf')\n                elif s1[i:j].count('a') > 0:\n                    dp[i][j] = float('inf')\n                else:\n                    dp[i][j] = dp[i+1][j] + dp[i][j-1]\n    return dp[0][n]"
    },
    {
        "number": 3631,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.readline().split())\n    beacons = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        beacons.append((x, y))\n    mountains = []\n    for i in range(m):\n        x, y, r = map(int, stdin.readline().split())\n        mountains.append((x, y, r))\n\n    # count messages\n    messages = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if not any(is_blocked(beacons[i], beacons[j], mountain) for mountain in mountains):\n                messages += 1\n\n    return str(messages)\n\ndef"
    },
    {
        "number": 3632,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    strings = [stdin.readline().strip() for _ in range(n)]\n    test_string = stdin.readline().strip()\n    composite_strings = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            for l in range(j+1, n):\n                for m in range(l+1, n):\n                    for p in range(m+1, n+1):\n                        composite_strings.add(''.join(sorted(strings[i:p])))\n    composite_strings = sorted(composite_strings)\n    return str((composite_strings.index(test_string)+1) % (10**9+7))"
    },
    {
        "number": 3633,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n    if k % n!= 0:\n        return \"impossible\"\n    target_score = k // n\n    scores = [0] * n\n    scores[0] = m\n    for i in range(1, n):\n        scores[i] = max(scores[i-1], a[i-1])\n    if sum(scores)!= k:\n        return \"impossible\"\n    p = []\n    for i in range(n):\n        for j in range(n):\n            if scores[j] == target_score:\n                p.append(j+1)\n                target_score -= 1\n                if target_score == 0:\n                    break\n        if target_score == 0:\n            break\n    return \" \".join(map(str, p))"
    },
    {
        "number": 3634,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    snow_log = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        snow_log.append((a, b))\n    snow_log.sort()\n    if snow_log[0][0] > 0:\n        return \"shovel time!\"\n    if snow_log[-1][1] < 10**18:\n        return \"shovel time!\"\n    dp = [1] * (snow_log[-1][1] + 1)\n    for i in range(1, len(snow_log)):\n        for j in range(snow_log[i-1][1]+1, snow_log[i][0]):\n            dp[j] += dp[j-1]\n        dp[snow_log[i][0]] = 1\n    return dp[-1] % 1000000009"
    },
    {
        "number": 3635,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    bananas = list(map(int, stdin.readline().strip().split()))\n\n    # sort bananas in ascending order\n    bananas.sort()\n\n    # initialize variables\n    total_bananas = sum(bananas)\n    max_executives = 0\n    current_bananas = 0\n    current_executives = 0\n\n    # iterate through bananas and distribute to executives\n    for i in range(N):\n        current_bananas += bananas[i]\n        current_executives += 1\n        if current_bananas >= total_bananas:\n            max_executives = max(max_executives, current_executives)\n            current_bananas -= bananas[i]\n            current_executives -= 1\n\n    return str(max_executives)"
    },
    {
        "number": 3636,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    MOD = p\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n                dp[i][j] %= MOD\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n                dp[i][j] %= MOD\n            if i > 0 and j > 0:\n                dp[i][j] += dp[i-1][j-1]\n                dp[i][j] %= MOD\n            if i > 0 and j < m-1:\n                dp[i][j] += dp[i-1][j+1]\n                dp[i][j] %= MOD\n    return dp[n-1][m-1]"
    },
    {
        "number": 3637,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    wishes = [line.strip().split() for line in lines[1:]]\n\n    # Count wishes for each topping\n    counts = {}\n    for wish in wishes:\n        for topping in wish[1:]:\n            if topping[0] == '+':\n                counts[topping[1:]] = counts.get(topping[1:], 0) + 1\n            elif topping[0] == '-':\n                counts[topping[1:]] = counts.get(topping[1:], 0) - 1\n\n    # Find toppings that satisfy the condition\n    result = []\n    for topping, count in counts.items():\n        if count > n // 3:\n            result.append(topping)\n\n    # Sort and return result\n    return''.join(sorted(result))"
    },
    {
        "number": 3638,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    predictions = []\n    for i in range(s):\n        predictions.append(stdin.readline().strip())\n    counts = [0] * n\n    for i in range(n):\n        for j in range(s):\n            if predictions[j][i % len(predictions[j])] == 'R':\n                counts[i] += 1\n            elif predictions[j][i % len(predictions[j])] == 'P':\n                counts[i] += 2\n            elif predictions[j][i % len(predictions[j])] == 'S':\n                counts[i] += 3\n    predictions.sort(key=lambda x: counts.count(predictions.index(x)))\n    return '\\n'.join(predictions)"
    },
    {
        "number": 3639,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.strip().split('\\n')\n    T = int(lines[0])\n    c, d = map(float, lines[1].split())\n    rain = list(map(int, lines[2:]))\n    rain.append(0)\n    rain.insert(0, 0)\n    dp = [[0] * (T+1) for _ in range(2)]\n    dp[0][0] = 0\n    dp[1][0] = 0\n    for i in range(1, T+1):\n        dp[0][i] = max(dp[0][i-1], dp[1][i-1] + rain[i])\n        dp[1][i] = max(dp[1][i-1], dp[0][i-1] + c * (i/60)**2)\n    return str(min(dp[0][T], dp[1][T]))"
    },
    {
        "number": 3640,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    meow = 0\n    for i in range(len(S)):\n        if S[i:i+3] =='meow':\n            meow += 1\n    return meow"
    },
    {
        "number": 3641,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split()[0:2])\n    beads = list(map(int, stdin.split()[2:]))\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO\"\n    if k == 1:\n        return \"YES\"\n    if k == n:\n        return \"YES\" if sum(beads) % k == 0 else \"NO\"\n    if k > n:\n        return \"NO"
    },
    {
        "number": 3642,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline())\n    edges = [tuple(map(int, line.split())) for line in stdin.readlines()]\n    magics = list(map(int, stdin.readline().split()))\n\n    # build graph\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    # compute magic of each node\n    node_magics = [magics[i] for i in range(n)]\n\n    # compute magic of each path\n    path_magics = [0] * n\n    for i in range(n):\n        for j in graph[i]:\n            if i < j:\n                path_magics[i] += node_magics[j]\n                path_magics[j] += node_magics[i]\n\n    # find path with minimal magic\n    min_magic = float('inf')\n    min_path = None\n    for i in range(n):\n        for j in graph[i]:\n            if i < j:\n                magic = path_magics[i] * path_magics[j] // (2 * (n - 1))\n                if magic < min_magic:\n                    min_magic = magic\n                    min_path = (i, j)\n\n    # output result\n    p, q = min_path\n    return f\"{p + 1}/{q + 1}\""
    },
    {
        "number": 3643,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    L = []\n    R = []\n    for i in range(N):\n        l, r = map(float, stdin.readline().strip().split())\n        L.append(l)\n        R.append(r)\n\n    # calculate expected damages\n    damages = 0\n    for i in range(1, N):\n        for j in range(i):\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= L[j] <= R[i]:\n                continue\n            if L[j] <= L[i] <= R[j] <= R[i]:\n                continue\n            if L[j] <= R[i] <= R[j] <= L[i]:\n                continue\n            if L[j] <= L[i] <="
    },
    {
        "number": 3644,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    f = [int(x) for x in stdin.split()[1:]]\n    h = [0] * n\n    for i in range(1, n):\n        h[i] = h[i-1] + f[i-1]\n    k = 1\n    while k < n:\n        if h[k] - f[k] > h[k-1]:\n            k += 1\n        else:\n            break\n    print(k)\n    res = [1] * n\n    for i in range(1, n):\n        if h[i] - f[i] > h[i-1]:\n            res[i] = res[i-1] + 1\n        else:\n            res[i] = res[i-1]\n    print(*res)\n    return \"\""
    },
    {
        "number": 3645,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n    seen = set()\n    for i in range(n):\n        if nums[i] in seen:\n            return \"none\"\n        seen.add(nums[i])\n    return \" \".join(map(str, sorted(seen)))"
    },
    {
        "number": 3646,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    spots = list(map(int, stdin.readline().strip().split()))\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if spots[i] + spots[j] == i - j:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[-1]"
    },
    {
        "number": 3647,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    rows, cols = map(int, stdin.split()[0:2])\n    maze = [list(line.strip()) for line in stdin.strip().split('\\n')[1:]]\n\n    # initialize output\n    output = [[-1] * cols for _ in range(rows)]\n\n    # initialize queue with starting point\n    queue = [(0, 0)]\n\n    # bfs to find shortest path to goal\n    while queue:\n        row, col = queue.pop(0)\n        if maze[row][col] == 'M':\n            output[row][col] = 0\n            break\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            r, c = row + dr, col + dc\n            if 0 <= r < rows and 0 <= c < cols and maze[r][c]!= '#':\n                if maze[r][c] == '.':\n                    output[r][c] = output[row][col] + 1\n                    queue.append((r, c))\n                elif maze[r][c] == '_':\n                    output[r][c] = output[row][col] + 1\n                    queue.append((r, c))\n                    while maze[r][c] == '_':\n                        r, c = r + dr, c + dc\n                        if 0 <= r < rows and 0 <= c < cols and maze[r][c]!= '#':\n                            output[r][c] = output[row][col] + 1\n                            queue.append((r, c))\n\n    # print output\n    return '\\n'.join([' '.join(map(str, row)) for row in output])"
    },
    {
        "number": 3648,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[0:3])\n    insecure_buildings = list(map(int, stdin.split()[3:]))\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        x, y, l = map(int, stdin.split()[i*3:i*3+3])\n        graph[x].append((y, l))\n        graph[y].append((x, l))\n    visited = [False] * (n+1)\n    dist = [float('inf')] * (n+1)\n    dist[1] = 0\n    q = [1]\n    while q:\n        u = q.pop(0)\n        for v, w in graph[u]:\n            if not visited[v] and v not in insecure_buildings:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    q.append(v)\n        visited[u] = True\n    if all(visited):\n        return str(dist[n])\n    else:\n        return \"impossible\""
    },
    {
        "number": 3649,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d == 0:\n        return \"impossible\"\n    if a + b + c + d == 1:\n        if a == 1:\n            return \"0\"\n        elif b == 1:\n            return \"1\"\n        elif c == 1:\n            return \"00\"\n        else:\n            return \"11\"\n    if a + b + c + d == 2:\n        if a == 1 and b == 1:\n            return \"01\"\n        elif a == 1 and c == 1:\n            return \"001\"\n        elif b == 1 and c == 1:\n            return \"10\"\n        else:\n            return \"impossible\"\n    if a + b + c + d == 3:\n        if a == 1 and b == 1 and c == 1:\n            return \"010\"\n        elif a == 1 and b == 1 and d == 1:\n            return \"011\"\n        elif a == 1 and c == 1 and d == 1:\n            return \"0011\"\n        elif b == 1 and c == 1 and d == 1:\n            return \"101\"\n        else:\n            return \"impossible\"\n    if a + b + c + d == 4:\n        if a == 1 and b == 1 and c == 1 and d == 1:\n            return \"0101\"\n        else:\n            return \"impossible\""
    },
    {
        "number": 3650,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m, b = map(int, stdin.readline().split())\n    target = set()\n    for _ in range(b):\n        r, c = map(int, stdin.readline().split())\n        target.add((r, c))\n\n    # initialize board\n    board = set()\n    board.add((1, 1))\n\n    # perform moves\n    moves = []\n    while board!= target:\n        # find empty cell\n        empty = None\n        for r in range(1, n+1):\n            for c in range(1, m+1):\n                if (r, c) not in board and (r-1, c) in board and (r, c-1) in board:\n                    empty = (r, c)\n                    break\n            if empty is not None:\n                break\n        if empty is None:\n            return \"impossible\"\n\n        # find valid moves\n        valid = []\n        if empty[0] > 1 and (empty[0]-1, empty[1]) not in board:\n            valid.append((empty[0]-1, empty[1]))\n        if empty[1] > 1 and (empty[0], empty[1]-1) not in board:\n            valid.append((empty[0], empty[1]-1))\n        if empty[0] < n and (empty[0]+1, empty[1]) not in board:\n            valid.append((empty[0]+1, empty[1]))\n        if empty[1] < m and (empty[0], empty[1]+1) not in board:\n            valid.append((empty[0], empty[1]+1))\n\n        # choose move\n        if len(valid) == 1:\n            moves.append((valid[0][0]-empty[0], valid[0][1]-empty[1]))\n        else:\n            valid.sort(key=lambda x: abs(x[0]-empty[0]) + abs(x[1]-empty[1]))\n            moves.append((valid[0][0]-empty[0], valid[0][1]-empty[1]))\n\n        # perform move\n        board.remove(empty)\n        board.add(valid[0])\n\n    # output moves\n    if not moves:\n        return \"possible\"\n    else:\n        print(\"possible\")\n        for move in moves:\n            if move[0] == -1:\n                print(\"<\", move[1])\n            elif move[0] == 1:\n                print(\">\", move[1])\n            elif move[1] == -1:\n                print(\"^\", move[0])\n            else:\n                print(\"v\", move[0])\n        return \"\""
    },
    {
        "number": 3651,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planets = []\n    for i in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        planets.append((x, y, z))\n    home = planets[0]\n    planets = planets[1:]\n    distances = []\n    for planet in planets:\n        dx = planet[0] - home[0]\n        dy = planet[1] - home[1]\n        dz = planet[2] - home[2]\n        distance = (dx ** 2 + dy ** 2 + dz ** 2) ** 0.5\n        distances.append(distance)\n    return str(sum(distances))"
    },
    {
        "number": 3652,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    row1 = list(map(int, stdin.readline().strip().split()))\n    row2 = list(map(int, stdin.readline().strip().split()))\n    row3 = list(map(int, stdin.readline().strip().split()))\n\n    # count number of occurrences of each number in each row\n    row1_counts = [0] * (N+1)\n    row2_counts = [0] * (N+1)\n    row3_counts = [0] * (N+1)\n    for num in row1:\n        row1_counts[num] += 1\n    for num in row2:\n        row2_counts[num] += 1\n    for num in row3:\n        row3_counts[num] += 1\n\n    # find smallest number of columns to delete\n    min_cols = N\n    for i in range(1, N+1):\n        if row1_counts[i] == 1 and row2_counts[i] == 1 and row3_counts[i] == 1:\n            min_cols = i\n            break\n\n    return str(min_cols)"
    },
    {
        "number": 3653,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, x1, y1, x2, y2 = map(int, stdin.split())\n    dx, dy = x2 - x1, y2 - y1\n    if dx == 0:\n        return str(L // abs(dy))\n    elif dy == 0:\n        return str(L // abs(dx))\n    else:\n        a, b = abs(dx), abs(dy)\n        c = (a**2 + b**2) ** 0.5\n        if c <= L:\n            return str(int(c))\n        else:\n            return str(int(L))"
    },
    {
        "number": 3654,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k == 1:\n        return 0\n    elif k == 2:\n        return 1\n    else:\n        f1 = 42\n        f2 = 11*k + 77\n        for i in range(3, n+1):\n            f3 = 2*f2 - f1 + 10*k\n            f1 = f2\n            f2 = f3\n        return f2\n\nprint(solution(\"1 5\")) # Output: 0"
    },
    {
        "number": 3655,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.strip().split('\\n')\n    robot_img = []\n    floor_img = []\n    for i in range(2, len(lines)):\n        if i < 2 + int(lines[0]):\n            robot_img.append(list(map(int, lines[i].split())))\n        else:\n            floor_img.append(list(map(int, lines[i].split())))\n\n    # find candidate locations\n    candidates = []\n    for i in range(len(floor_img)):\n        for j in range(len(floor_img[0])):\n            same_count = 0\n            for k in range(len(robot_img)):\n                for l in range(len(robot_img[0])):\n                    if robot_img[k][l] == floor_img[i+k][j+l]:\n                        same_count += 1\n            if same_count == len(robot_img) * len(robot_img[0]):\n                candidates.append((i, j))\n\n    # sort candidates by x-coordinate, then by y-coordinate\n    candidates.sort(key=lambda x: (x[0], x[1]))\n\n    # format output\n    output = ''\n    for candidate in candidates:\n        output += f'{candidate[0]} {candidate[1]}\\n'\n\n    return output"
    },
    {
        "number": 3656,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    B, T, f = map(float, stdin.split())\n    bugs = []\n    for _ in range(int(B)):\n        p, s = map(float, stdin.readline().split())\n        bugs.append((p, s))\n\n    # simulate bug fixing\n    severity = 0\n    for _ in range(int(T)):\n        # choose bug to work on\n        p_sum = sum(p for p, _ in bugs)\n        p_cumsum = list(itertools.accumulate(p for p, _ in bugs))\n        r = random.random() * p_sum\n        i = bisect.bisect_right(p_cumsum, r)\n        p, s = bugs[i]\n\n        # fix bug\n        if random.random() < p:\n            severity += s\n        else:\n            p *= f\n            bugs[i] = (p, s)\n\n    # output result\n    return str(severity)"
    },
    {
        "number": 3657,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, vh, N = map(int, stdin.split())\n    gates = []\n    for i in range(N):\n        x, y = map(int, stdin.split())\n        gates.append((x, y))\n    S = int(stdin.split()[0])\n    skis = []\n    for i in range(S):\n        skis.append(int(stdin.split()[0]))\n    gates.sort(key=lambda x: x[1])\n    skis.sort()\n    for i in range(S):\n        for j in range(N):\n            if gates[j][1] < skis[i]:\n                continue\n            if gates[j][0] > W:\n                continue\n            if gates[j][0] + skis[i] > W:\n                continue\n            if gates[j][0] + skis[i] > gates[j+1][0]:\n                continue\n            if gates[j][1] + skis[i] > gates[j+1][1]:\n                continue\n            return str(skis[i])\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3658,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    P, A = map(int, lines[0].split())\n    trees = []\n    for i in range(1, 1+P+A):\n        x, y = map(float, lines[i].split())\n        trees.append((x, y))\n\n    # calculate area covered by both species\n    area = 0\n    for i in range(P):\n        for j in range(i+1, P):\n            for k in range(P, P+A):\n                if is_inside_triangle(trees[i], trees[j], trees[k]):\n                    area += triangle_area(trees[i], trees[j], trees[k])\n    for i in range(P, P+A):\n        for j in range(i+1, P+A):\n            for k in range(P, P+A):\n                if is_inside_triangle(trees[i], trees[j], trees[k]):\n                    area += triangle_area(trees[i], trees[j], trees[k])\n\n    return str(area)\n\ndef"
    },
    {
        "number": 3659,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline())\n    books = []\n    for i in range(n):\n        h, t = map(int, stdin.readline().split())\n        books.append((h, t))\n\n    # sort books by thickness\n    books.sort(key=lambda x: x[1])\n\n    # compute maximum width\n    max_width = sum(h for h, t in books)\n\n    # compute minimum area\n    area = float('inf')\n    for i in range(n-2):\n        # compute maximum height for each partition\n        max_height = sum(h for h, t in books[:i+1])\n        # compute area for each partition\n        area = min(area, max_height * books[i+1][1])\n        area = min(area, max_height * books[i+2][1])\n\n    # return result\n    return str(area)"
    },
    {
        "number": 3660,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message, n = stdin.split('\\n')\n    stickers = []\n    for i in range(1, int(n)+1):\n        word, price = stdin.split()[i].split()\n        stickers.append((word, int(price)))\n    stickers.sort(key=lambda x: x[1])\n    dp = [[0]*(len(message)+1) for _ in range(len(stickers)+1)]\n    for i in range(1, len(stickers)+1):\n        for j in range(1, len(message)+1):\n            if stickers[i-1][0] == message[j-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], stickers[i-1][1]+dp[i-1][j-1])\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    if dp[-1][-1] > 2*stickers[-1][1]:\n        return 'IMPOSSIBLE'\n    else:\n        return dp[-1][-1]"
    },
    {
        "number": 3661,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S, L = map(int, stdin.split())\n    lawsuits = []\n    for i in range(L):\n        A, B = map(int, stdin.split())\n        lawsuits.append((A, B))\n    indv_wins = [0] * R\n    corp_wins = [0] * S\n    for A, B in lawsuits:\n        indv_wins[A-1] += 1\n        corp_wins[B-1] += 1\n    max_indv_wins = max(indv_wins)\n    max_corp_wins = max(corp_wins)\n    for i in range(R):\n        if indv_wins[i] == max_indv_wins:\n            return f\"INDV {i+1}\"\n    for i in range(S):\n        if corp_wins[i] == max_corp_wins:\n            return f\"CORP {i+1}\""
    },
    {
        "number": 3662,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, l, w = map(int, stdin.readline().split())\n    plants = list(map(int, stdin.readline().split()))\n    plants.sort()\n\n    # calculate optimal positions\n    left_pos = [0] * n\n    right_pos = [l] * n\n    for i in range(1, n):\n        left_pos[i] = left_pos[i-1] + plants[i-1]\n        right_pos[n-i-1] = right_pos[n-i] - plants[n-i]\n\n    # calculate total distance\n    total_dist = 0\n    for i in range(n):\n        total_dist += abs(left_pos[i] - right_pos[i])\n\n    # output result\n    return str(total_dist)"
    },
    {
        "number": 3663,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    routes = []\n    for i in range(n-1):\n        u, v, c = map(int, stdin.readline().strip().split())\n        routes.append((u-1, v-1, c))\n    armies = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        armies.append((x, y))\n    dp = [[float('inf')]*n for _ in range(1<<n)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            for k in range(1<<n):\n                if k & (1<<i) == 0 or k & (1<<j) == 0:\n                    continue\n                for r in routes:\n                    if r[0] == i and r[1] == j:\n                        dp[k|(1<<i)|(1<<j)][j] = min(dp[k|(1<<i)|(1<<j)][j], dp[k][i]+r[2])\n    ans = float('inf')\n    for i in range(n):\n        ans = min(ans, dp[(1<<n)-1][i]*armies[i][0]+dp[(1<<n)-1][i]*(armies[i][1]-armies[i][0]))\n    return str(ans)"
    },
    {
        "number": 3664,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, i, j, n = map(int, stdin.split())\n    ice = [['.' for _ in range(c)] for _ in range(r)]\n    direction = 'up'\n    color = 'A'\n    for step in range(n):\n        if direction == 'up':\n            if i == 1:\n                direction = 'right'\n            else:\n                i -= 1\n        elif direction == 'right':\n            if j == c:\n                direction = 'down'\n            else:\n                j += 1\n        elif direction == 'down':\n            if i == r:\n                direction = 'left'\n            else:\n                i += 1\n        elif direction == 'left':\n            if j == 1:\n                direction = 'up'\n            else:\n                j -= 1\n        ice[i-1][j-1] = color\n        if color == 'Z':\n            color = 'A'\n        else:\n            color = chr(ord(color) + 1)\n    ice[i-1][j-1] = '@'\n    return '\\n'.join([''.join(row) for row in ice])"
    },
    {
        "number": 3665,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    nums = []\n    for i in range(n):\n        nums.append(int(stdin.readline().strip()))\n    nums.sort()\n    count = 0\n    for i in range(n):\n        if nums[i]!= i+1:\n            count += 1\n            nums[i] = i+1\n    return '\\n'.join(map(str, nums)) + '\\n' + str(count)"
    },
    {
        "number": 3666,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    gear_ratios = []\n    for line in lines:\n        n, d = map(int, line.split('/'))\n        gear_ratios.append((n, d))\n\n    # Check if there are at most 12 possible gear ratios\n    if len(gear_ratios) > 12:\n        return 'impossible'\n\n    # Check if there are at least 2 possible gear ratios\n    if len(gear_ratios) < 2:\n        return 'impossible'\n\n    # Check if all gear ratios are integers\n    for n, d in gear_ratios:\n        if n % 1!= 0 or d % 1!= 0:\n            return 'impossible'\n\n    # Check if all gear ratios are positive\n    for n, d in gear_ratios:\n        if n <= 0 or d <= 0:\n            return 'impossible'\n\n    # Check if all gear ratios are less than or equal to 100\n    for n, d in gear_ratios:\n        if n > 100 or d > 100:\n            return 'impossible'\n\n    # Check if all gear ratios are coprime\n    for i in range(len(gear_ratios)):\n        for j in range(i+1, len(gear_ratios)):\n            n1, d1 = gear_ratios[i]\n            n2, d2 = gear_ratios[j]\n            if math.gcd(n1, d1) == 1 and math.gcd(n2, d2) == 1:\n                return 'impossible'\n\n    # Check if there are at most 2 sprockets on the front derailleur\n    front_sprockets = set()\n    for n, d in gear_ratios:\n        front_sprockets.add(n)\n    if len(front_sprockets) > 2:\n        return 'impossible'\n\n    # Check if there are at least 6 sprockets on the rear derailleur\n    rear_sprockets = set()\n    for n, d in gear_ratios:\n        rear_sprockets.add(d)\n    if len(rear_sprockets) < 6:\n        return 'impossible'\n\n    # Check if there are at most 6 sprockets on the rear derailleur\n    if len(rear_sprockets) > 6:\n        return 'impossible'\n\n    # Check if there are at least 2 sprockets on the front derailleur\n    if len(front_sprockets) < 2:\n        return 'impossible'\n\n    # Check if there are at most 2 sprockets on the front derailleur\n    if len(front_sprockets) > 2:\n        return 'impossible'\n\n    # Check if there are at least 6 sprockets on the rear derailleur\n    if len(rear_sprockets) < 6:\n        return 'impossible'\n\n    # Check if there are at most 6 sprockets on the rear derailleur\n    if len(rear_sprockets) > 6:\n        return 'impossible'\n\n    # Check if there are at most 12 possible gear ratios\n    if len(gear_ratios) > 12:\n        return 'impossible'\n\n    # Check if all gear ratios are integers\n    for n, d in gear_ratios:\n        if n % 1!= 0 or d % 1!= 0:\n            return 'impossible'\n\n    # Check if all gear ratios are positive\n    for n, d in gear_ratios:\n        if n <= 0 or d <= 0:\n            return 'impossible'\n\n    # Check if all gear ratios are less than or equal to 100\n    for n, d in gear_ratios:\n        if n > 100 or d > 100:\n            return 'impossible'\n\n    # Check if all gear ratios are coprime\n    for i in range(len(gear_ratios)):\n        for j in range(i+1, len(gear_ratios)):\n            n1, d1 = gear_ratios[i]\n            n2, d2 = gear_ratios[j]\n            if math.gcd(n1, d1) == 1 and math.gcd(n2, d2) == 1:\n                return 'impossible'\n\n    # Check if there are at most 2 sprockets on the front"
    },
    {
        "number": 3667,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    w, p = map(int, stdin.split()[0:2])\n    wells = []\n    for i in range(w):\n        x, y = map(int, stdin.split()[0:2])\n        wells.append((x, y))\n    pipes = []\n    for i in range(p):\n        s, x, y = map(int, stdin.split()[0:3])\n        pipes.append((s-1, x, y))\n\n    # check if it is possible to clean all intersections\n    robots = 0\n    for i in range(w):\n        for j in range(p):\n            if pipes[j][0] == i:\n                robots += 1\n                break\n    if robots > 2:\n        return \"impossible\"\n\n    # check if all intersections are cleanable\n    for i in range(w):\n        for j in range(p):\n            if pipes[j][0] == i:\n                for k in range(j+1, p):\n                    if pipes[k][0] == i:\n                        if pipes[j][1] == pipes[k][1] or pipes[j][2] == pipes[k][2]:\n                            return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 3668,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    burgers = [int(stdin.readline()) for _ in range(m)]\n    dp = [[0] * n for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(n):\n            dp[i][j] = dp[i-1][j]\n            for k in range(j+1, n):\n                dp[i][j] = max(dp[i][j], dp[i-1][k] + 1)\n    return max(dp[i][j] for i in range(1, m+1) for j in range(n))\n\nstdin = \"4 2\\n2\\n2\"\nprint(solution(stdin)) # Output: 4"
    },
    {
        "number": 3669,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n    mirko_points = set()\n    slavko_points = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            if points[i][0] == points[j][0]:\n                mirko_points.add(points[i])\n                slavko_points.add(points[j])\n            elif points[i][1] == points[j][1]:\n                mirko_points.add(points[i])\n                slavko_points.add(points[j])\n            else:\n                slope = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])\n                if slope == 0:\n                    mirko_points.add(points[i])\n                    slavko_points.add(points[j])\n                elif slope == 1:\n                    mirko_points.add(points[i])\n                    slavko_points.add(points[j])\n                elif slope == -1:\n                    mirko_points.add(points[j])\n                    slavko_points.add(points[i])\n    if len(mirko_points) > len(slavko_points):\n        return \"Mirko\"\n    else:\n        return \"Slavko\""
    },
    {
        "number": 3670,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nums = [int(line.strip()) for line in stdin]\n    res = []\n    for i in range(2, 1000000001):\n        if all(num % i == 0 for num in nums):\n            res.append(i)\n    return''.join(str(num) for num in res)"
    },
    {
        "number": 3671,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.split()[0])\n    times = list(map(int, stdin.split()[1:]))\n\n    # sort times\n    times.sort()\n\n    # decline every other assignment\n    for i in range(1, N, 2):\n        times[i] = float('inf')\n\n    # calculate cookies\n    cookies = 0\n    for i in range(N):\n        cookies += (times[i] // 100000)\n\n    return str(cookies)"
    },
    {
        "number": 3672,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    islands = []\n    for i in range(m):\n        island = list(map(int, stdin.split()))\n        islands.append(island)\n    resources = set()\n    for i in range(m):\n        for j in range(len(islands[i])):\n            if islands[i][j]!= 0:\n                resources.add(islands[i][j])\n    if len(resources) < n:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3673,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    if K > N*(N-1)//2:\n        return \"Impossible\"\n    used = [False]*N\n    ans = [0]*N\n    for i in range(N):\n        if used[i]:\n            continue\n        used[i] = True\n        ans[i] = i+1\n        for j in range(K):\n            if a[i] == i+1:\n                break\n            if a[i] > i+1:\n                return \"Impossible\"\n            if used[a[i]-1]:\n                return \"Impossible\"\n            used[a[i]-1] = True\n            ans[a[i]-1] = i+1\n            i = a[i]-1\n    return \" \".join(map(str, ans))"
    },
    {
        "number": 3674,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, p, q = map(int, stdin.split())\n    if m < n:\n        return \"IMPOSSIBLE\"\n    if p == 0 or q == 0:\n        return \"IMPOSSIBLE\"\n    if n == 0:\n        return str(p * q)\n    if m == n:\n        return str(p * q)\n    if m == n + 1:\n        return str(p * q)\n    if m == n + 2:\n        return str(p * q)\n    if m == n + 3:\n        return str(p * q)\n    if m == n + 4:\n        return str(p * q)\n    if m == n + 5:\n        return str(p * q)\n    if m == n + 6:\n        return str(p * q)\n    if m == n + 7:\n        return str(p * q)\n    if m == n + 8:\n        return str(p * q)\n    if m == n + 9:\n        return str(p * q)\n    if m == n + 10:\n        return str(p * q)\n    if m == n + 11:\n        return str(p * q)\n    if m == n + 12:\n        return str(p * q)\n    if m == n + 13:\n        return str(p * q)\n    if m == n + 14:\n        return str(p * q)\n    if m == n + 15:\n        return str(p * q)\n    if m == n + 16:\n        return str(p * q)\n    if m == n + 17:\n        return str(p * q)\n    if m == n + 18:\n        return str(p * q)\n    if m == n + 19:\n        return str(p * q)\n    if m == n + 20:\n        return str(p * q)\n    if m == n + 21:\n        return str(p * q)\n    if m == n + 22:\n        return str(p * q)\n    if m == n + 23:\n        return str(p * q)\n    if m == n + 24:\n        return str(p * q)\n    if m == n + 25:\n        return str(p * q)\n    if m == n + 26:\n        return str(p * q)\n    if m == n + 27:\n        return str(p * q)\n    if m == n + 28:\n        return str(p * q)\n    if m == n + 29:\n        return str(p * q)\n    if m == n + 30:\n        return str(p * q)\n    if m == n + 31:\n        return str(p * q)\n    if m == n + 32:\n        return str(p * q)\n    if m == n + 33:\n        return str(p * q)\n    if m == n + 34:\n        return str(p * q)\n    if m == n + 35:\n        return str(p * q)\n    if m == n + 36:\n        return str(p * q)\n    if m == n + 37:\n        return str(p * q)\n    if m == n + 38:\n        return str(p * q)\n    if m == n + 39:\n        return str(p * q)\n    if m == n + 40:\n        return str(p * q)\n    if m == n + 41:\n        return str(p * q)\n    if m == n + 42:\n        return str(p * q)\n    if m == n + 43:\n        return str(p * q)\n    if m == n + 44:\n        return str(p * q)\n    if m == n + 45:\n        return str(p * q)\n    if m == n + 46:\n        return str(p * q)\n    if m == n + 47:\n        return str(p * q)\n    if m == n + 48:\n        return str(p * q)\n    if m == n + 49:\n        return str(p * q)\n    if m == n + 50:\n        return str(p * q)\n    if m == n + 51:\n        return str(p * q)\n    if m == n + 52:\n        return str(p * q)\n    if m == n + 53:\n        return str(p * q)\n   "
    },
    {
        "number": 3675,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    strings = []\n    for i in range(n):\n        strings.append(stdin.split()[i+1])\n    longest_subsequence = \"\"\n    for i in range(k):\n        subsequence = strings[0][i]\n        for j in range(1, n):\n            if subsequence[-1] == strings[j][i]:\n                subsequence += strings[j][i+1]\n            else:\n                subsequence = strings[j][i]\n        if len(subsequence) > len(longest_subsequence):\n            longest_subsequence = subsequence\n    return len(longest_subsequence)"
    },
    {
        "number": 3676,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    if R == 1 and C == 1:\n        return \"1\"\n    if R == 1 or C == 1:\n        return \"2\"\n    if R == 2 and C == 2:\n        return \"13\"\n    if R == 2 or C == 2:\n        return \"5\"\n    if R == 3 and C == 3:\n        return \"109\"\n    if R == 3 or C == 3:\n        return \"14\"\n    if R == 4 and C == 4:\n        return \"256\"\n    return \"35\"\n\nprint(solution(\"1 2\")) # Output: 3"
    },
    {
        "number": 3677,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K = map(int, stdin.split())\n    disagreements = [set() for _ in range(N)]\n    for i in range(N):\n        D_i = int(stdin.readline().strip())\n        for j in map(int, stdin.readline().strip().split()):\n            disagreements[i].add(j)\n            disagreements[j].add(i)\n\n    # find largest committee\n    largest_committee_size = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if len(disagreements[i] & disagreements[j]) < K:\n                largest_committee_size = max(largest_committee_size, len(disagreements[i] | disagreements[j]))\n\n    return str(largest_committee_size)"
    },
    {
        "number": 3678,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for i in range(t):\n        n = int(stdin.readline().strip())\n        points = []\n        for j in range(n):\n            x, y = map(int, stdin.readline().strip().split())\n            points.append((x, y))\n        if len(set(points))!= n:\n            return \"NO\"\n        for j in range(n):\n            for k in range(j+1, n):\n                if points[j] == points[k]:\n                    return \"NO\"\n                if points[j][0] == points[k][0] or points[j][1] == points[k][1]:\n                    return \"NO\"\n                if abs(points[j][0] - points[k][0]) == abs(points[j][1] - points[k][1]):\n                    return \"NO\"\n        return \"YES\""
    },
    {
        "number": 3679,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = 1/n\n    total = 0\n    for i in range(n):\n        total += p * (n-i)\n    return str(total)"
    },
    {
        "number": 3680,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    poles = list(map(int, stdin.readline().split()))\n    poles.sort()\n    cuts = 0\n    for i in range(k):\n        if poles[i] > n:\n            return \"IMPOSSIBLE\"\n        cuts += n // poles[i]\n        n %= poles[i]\n    return cuts"
    },
    {
        "number": 3681,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = map(int, stdin.split())\n    classes = [[] for _ in range(N)]\n    for i in range(N):\n        classes[i].append(i)\n    for i in range(Q):\n        query = stdin.readline().strip().split()\n        if query[0] == '0':\n            K, x, *p = map(int, query[1:])\n            p = p[:K]\n            for i in range(K):\n                p[i] -= 1\n            classes[x-1] = p\n        else:\n            d, x = map(int, query[1:])\n            d -= 1\n            x -= 1\n            week = x // 2\n            day = x % 2\n            if day == 0:\n                day = 1\n            else:\n                day = 2\n            if week == 0:\n                week = 1\n            else:\n                week = 2\n            if day == 1:\n                print(classes[d][week-1]+1)\n            else:\n                print(classes[d][week])\n    return \"\""
    },
    {
        "number": 3682,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read repository\n    repository = {}\n    n = int(stdin.readline().strip())\n    for i in range(n):\n        file_name = stdin.readline().strip()\n        contents = []\n        while True:\n            line = stdin.readline().strip()\n            if line == '***END***':\n                break\n            contents.append(line)\n        repository[file_name] = contents\n\n    # read code snippet\n    code_snippet = []\n    while True:\n        line = stdin.readline().strip()\n        if line == '***END***':\n            break\n        code_snippet.append(line)\n\n    # compare code snippet to repository\n    matches = []\n    for file_name, contents in repository.items():\n        match_length = 0\n        for i in range(len(contents)):\n            if i + len(code_snippet) > len(contents):\n                break\n            match = True\n            for j in range(len(code_snippet)):\n                if contents[i+j]!= code_snippet[j]:\n                    match = False\n                    break\n            if match:\n                match_length = max(match_length, j+1)\n        if match_length > 0:\n            matches.append((match_length, file_name))\n\n    # output results\n    if len(matches) == 0:\n        return '0\\n'\n    else:\n        result = str(matches[0][0]) +'' + matches[0][1]\n        for match in matches[1:]:\n            result += '\\n' + str(match[0]) +'' + match[1]\n        return result + '\\n'"
    },
    {
        "number": 3683,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    p, h = map(int, stdin.split())\n    scores = []\n    for i in range(p):\n        scores.append(list(map(int, stdin.readline().split())))\n\n    # calculate minimum possible rank for each player\n    ranks = []\n    for i in range(p):\n        total_score = sum(scores[i])\n        rank = 1\n        for j in range(p):\n            if i!= j:\n                adjusted_scores = [min(score, l) for score, l in zip(scores[j], scores[i])]\n                adjusted_total_score = sum(adjusted_scores)\n                if adjusted_total_score <= total_score:\n                    rank += 1\n        ranks.append(rank)\n\n    # output minimum possible rank for each player\n    return '\\n'.join(map(str, ranks))"
    },
    {
        "number": 3684,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split())\n    users = []\n    for i in range(n):\n        p_i, b_i, u_i = map(int, stdin.readline().split())\n        users.append((p_i, b_i, u_i))\n    users.sort(key=lambda x: x[0])\n    buffer_sizes = [u_i for p_i, b_i, u_i in users]\n    for i in range(n):\n        p_i, b_i, u_i = users[i]\n        buffer_sizes[i] = min(buffer_sizes[i], b_i - (p_i + C))\n    return max(buffer_sizes)"
    },
    {
        "number": 3685,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    r, c = map(int, stdin.readline().strip().split())\n    start_bed, start_fridge = map(tuple, stdin.readline().strip().split())\n    map_ = []\n    for i in range(r):\n        map_.append(list(stdin.readline().strip()))\n    p = int(stdin.readline().strip())\n    masters = []\n    for i in range(p):\n        master_len = int(stdin.readline().strip().split()[0])\n        master_path = []\n        for j in range(master_len):\n            master_path.append(tuple(map(int, stdin.readline().strip().strip('()').split())))\n        masters.append(master_path)\n\n    # Initialize variables\n    visited = [[False] * c for _ in range(r)]\n    visited[start_bed[0]-1][start_bed[1]-1] = True\n    visited[start_fridge[0]-1][start_fridge[1]-1] = True\n    for master in masters:\n        for coord in master:\n            visited[coord[0]-1][coord[1]-1] = True\n    queue = [(start_bed, 0)]\n    turns = 0\n\n    # BFS\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            curr_coord, curr_turns = queue.pop(0)\n            if curr_coord == start_fridge:\n                return str(curr_turns)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_coord = (curr_coord[0]+dx, curr_coord[1]+dy)\n                if 0 <= new_coord[0] < r and 0 <= new_coord[1] < c and map_[new_coord[0]][new_coord[1]] == '.' and not visited[new_coord[0]][new_coord[1]]:\n                    visited[new_coord[0]][new_coord[1]] = True\n                    queue.append((new_coord, curr_turns+1))\n        turns += 1\n\n    # If child cannot reach fridge\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3686,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    targets = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        targets.append((x, y))\n\n    # check if it is possible to hit all targets with at most two shots\n    for i in range(n):\n        for j in range(i+1, n):\n            if targets[i][0] == targets[j][0]:\n                # same x-coordinate, check y-coordinate\n                if targets[i][1] <= targets[j][1]:\n                    # target i is above target j, check if target j is within range of target i\n                    if abs(targets[j][1] - targets[i][1]) <= 1:\n                        # target j is within range of target i, check if target i is within range of target j\n                        if abs(targets[i][1] - targets[j][1]) <= 1:\n                            # target i is within range of target j, check if target j is within range of target i\n                            if abs(targets[j][1] - targets[i][1]) <= 1:\n                                # target j is within range of target i, check if target i is within range of target j\n                                if abs(targets[i][1] - targets[j][1]) <= 1:\n                                    # target i is within range of target j, target j is within range of target i,\n                                    # target i and target j are on the same line, target j is within range of target i\n                                    return \"failure\"\n            elif targets[i][1] == targets[j][1]:\n                # same y-coordinate, check x-coordinate\n                if targets[i][0] <= targets[j][0]:\n                    # target i is to the left of target j, check if target j is within range of target i\n                    if abs(targets[j][0] - targets[i][0]) <= 1:\n                        # target j is within range of target i, check if target i is within range of target j\n                        if abs(targets[i][0] - targets[j][0]) <= 1:\n                            # target i is within range of target j, check if target j is within range of target i\n                            if abs(targets[j][0] - targets[i][0]) <= 1:\n                                # target j is within range of target i, check if target i is within range of target j\n                                if abs(targets[i][0] - targets[j][0]) <= 1:\n                                    # target i is within range of target j, target j is within range of target i,\n                                    # target i and target j are on the same line, target j is within range of target i\n                                    return \"failure\"\n\n    # it is possible to hit all targets with at most two shots\n    return \"success\""
    },
    {
        "number": 3687,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, s = map(int, stdin.readline().split())\n    q_list = list(map(int, stdin.readline().split()))\n    c_list = list(map(int, stdin.readline().split()))\n    for i in range(n):\n        d = int(stdin.readline().split()[0])\n        a_list = list(map(int, stdin.readline().split()))\n        if sum(a_list) > d:\n            return \"impossible\"\n        for j in range(s):\n            if a_list[j] > c_list[q_list[j]-1]:\n                return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 3688,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x, y, t = [], [], []\n    for i in range(n):\n        xi, yi, ti = map(int, stdin.readline().split())\n        x.append(xi)\n        y.append(yi)\n        t.append(ti)\n    x.sort()\n    y.sort()\n    count = 0\n    for i in range(1, n):\n        if x[i] == x[i-1]:\n            count += 1\n        else:\n            break\n    return count"
    },
    {
        "number": 3689,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = int(''.join(stdin.split()))\n    m = n\n    while True:\n        y = x + 1\n        if all(y % int(x[i:i+k]) == 0 for i in range(n-k+1)):\n            break\n        m += 1\n    b = str(y)\n    return f\"{m}\\n{b}\""
    },
    {
        "number": 3690,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, m, s, t_1, t_2 = map(int, stdin.split())\n    if t_1 == t_2:\n        return \"YES\"\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n    if t_1 == 12 and t_2 == 1:\n        return \"YES\"\n    if t_1 == 1 and t_2 == 12:\n        return \"NO\"\n    if t_1 == 12 and t_2 == 2:\n        return \"NO\"\n    if t_1 == 2 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 3:\n        return \"NO\"\n    if t_1 == 3 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 4:\n        return \"NO\"\n    if t_1 == 4 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 5:\n        return \"NO\"\n    if t_1 == 5 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 6:\n        return \"NO\"\n    if t_1 == 6 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 7:\n        return \"NO\"\n    if t_1 == 7 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 8:\n        return \"NO\"\n    if t_1 == 8 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 9:\n        return \"NO\"\n    if t_1 == 9 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 10:\n        return \"NO\"\n    if t_1 == 10 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 12 and t_2 == 11:\n        return \"NO\"\n    if t_1 == 11 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 1 and t_2 == 2:\n        return \"YES\"\n    if t_1 == 2 and t_2 == 3:\n        return \"NO\"\n    if t_1 == 3 and t_2 == 4:\n        return \"YES\"\n    if t_1 == 4 and t_2 == 5:\n        return \"NO\"\n    if t_1 == 5 and t_2 == 6:\n        return \"YES\"\n    if t_1 == 6 and t_2 == 7:\n        return \"NO\"\n    if t_1 == 7 and t_2 == 8:\n        return \"YES\"\n    if t_1 == 8 and t_2 == 9:\n        return \"NO\"\n    if t_1 == 9 and t_2 == 10:\n        return \"YES\"\n    if t_1 == 10 and t_2 == 11:\n        return \"NO\"\n    if t_1 == 11 and t_2 == 12:\n        return \"YES\"\n    if t_1 == 1 and t_2 == 3:\n        return \"NO\"\n    if t_1 == 3 and t_2 == 5:\n        return \"YES\"\n    if t_1 == 5 and t_2 == 7:\n        return \"NO\"\n    if t_1 == 7 and t_2 == 9:\n        return \"YES\"\n    if t_1 == 9 and t_2 == 11:\n        return \"NO\"\n    if t_1 == 11 and t_2 == 1:\n        return \"YES\"\n    if t_1 == 2 and t_2 == 4:\n        return \"NO\"\n    if t_1 == 4 and t_2 == 6:\n        return \"YES\"\n    if t_1 == 6 and t_2 == 8:\n        return \"NO\"\n    if t_1 == 8 and t_2 == 10:\n        return \"YES\"\n    if t_1 == 10 and t_2 == 2:\n        return \"NO\"\n   "
    },
    {
        "number": 3691,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, ax, ay, bx, by = map(int, stdin.split()[0:6])\n    xs, ys, t = map(int, stdin.split()[6:])\n    nodes = [(x0, y0)]\n    for i in range(1, 1000000):\n        x, y = nodes[-1]\n        nx = (ax * x + bx) % 10000000000000000\n        ny = (ay * y + by) % 10000000000000000\n        nodes.append((nx, ny))\n        if (nx, ny) == (xs, ys):\n            break\n    return len(nodes) - 1"
    },
    {
        "number": 3692,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    circles = []\n    for i in range(n):\n        x, y, r = map(int, stdin.readline().strip().split())\n        circles.append((x, y, r))\n    regions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                x1, y1, r1 = circles[i]\n                x2, y2, r2 = circles[j]\n                x3, y3, r3 = circles[k]\n                if (x2-x1)**2 + (y2-y1)**2 <= r1**2 + r2**2 and (x3-x2)**2 + (y3-y2)**2 <= r2**2 + r3**2 and (x1-x3)**2 + (y1-y3)**2 <= r3**2 + r1**2:\n                    regions += 1\n    return regions"
    },
    {
        "number": 3693,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    square1 = [tuple(map(int, line.split())) for line in lines[0].split()]\n    square2 = [tuple(map(int, line.split())) for line in lines[1].split()]\n\n    # check if squares intersect\n    for i in range(4):\n        for j in range(4):\n            if (square1[i][0] <= square2[j][0] <= square1[i][0] + square1[i][1] or\n                square1[i][0] <= square2[j][0] + square2[j][1] <= square1[i][0] + square1[i][1] or\n                square1[i][0] + square1[i][1] <= square2[j][0] <= square1[i][0] + square1[i][1] + square2[j][1] or\n                square1[i][0] + square1[i][1] <= square2[j][0] + square2[j][1] <= square1[i][0] + square1[i][1] + square2[j][1]):\n                if (square1[i][1] <= square2[j][1] <= square1[i][1] + square1[i][3] or\n                    square1[i][1] <= square2[j][1] + square2[j][3] <= square1[i][1] + square1[i][3] or\n                    square1[i][1] + square1[i][3] <= square2[j][1] <= square1[i][1] + square1[i][3] + square2[j][3] or\n                    square1[i][1] + square1[i][3] <= square2[j][1] + square2[j][3] <= square1[i][1] + square1[i][3] + square2[j][3]):\n                    return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 3694,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    if sum(a) == 0:\n        return \"cslnb\"\n    if n == 1:\n        return \"cslnb\"\n    if n == 2:\n        if a[0] == a[1]:\n            return \"sjfnb\"\n        else:\n            return \"cslnb\"\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if a[i] == a[i-1]:\n            return \"sjfnb\"\n        if a[i] == a[i-2]:\n            return \"sjfnb\"\n    return \"cslnb\""
    },
    {
        "number": 3695,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.readline().split()))\n    dp = [0] * (T + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(T, t[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - t[i]] + 1)\n    return dp[T]"
    },
    {
        "number": 3696,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\\n-1 0 1\"\n    if n == 3:\n        return \"3\\n-1 0 1 0\"\n    if n == 4:\n        return \"4\\n-1 0 1 0 1\"\n    if n == 5:\n        return \"5\\n-1 0 1 0 1 0\"\n    if n == 6:\n        return \"6\\n-1 0 1 0 1 0 1\"\n    if n == 7:\n        return \"7\\n-1 0 1 0 1 0 1 0\"\n    if n == 8:\n        return \"8\\n-1 0 1 0 1 0 1 0 1\"\n    if n == 9:\n        return \"9\\n-1 0 1 0 1 0 1 0 1 0\"\n    if n == 10:\n        return \"10\\n-1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 11:\n        return \"11\\n-1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 12:\n        return \"12\\n-1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 13:\n        return \"13\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 14:\n        return \"14\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 15:\n        return \"15\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 16:\n        return \"16\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 17:\n        return \"17\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 18:\n        return \"18\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 19:\n        return \"19\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 20:\n        return \"20\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 21:\n        return \"21\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 22:\n        return \"22\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"\n    if n == 23:\n        return \"23\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\"\n    if n == 24:\n        return \"24\\n-1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0"
    },
    {
        "number": 3697,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, a = map(int, stdin.split())\n    g = list(map(int, stdin.split()))\n    r = [0] * n\n    for i in range(a):\n        r[g[i]-1] += 1\n    for i in range(a, m):\n        for j in range(n):\n            if r[j] == 0:\n                r[j] = 1\n                break\n    for i in range(n):\n        if r[i] == 0:\n            r[i] = 3\n        elif r[i] == 1:\n            r[i] = 1\n        else:\n            r[i] = 2\n    r.sort(reverse=True)\n    return''.join(map(str, r[:k]))"
    },
    {
        "number": 3698,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if bin(i).count('1') <= k:\n            count += 1\n    return count % (10**9 + 7)"
    },
    {
        "number": 3699,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    a_x, a_y, b_x, b_y, t_x, t_y = map(int, stdin.split()[0:6])\n    n = int(stdin.split()[6])\n    bottles = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[2*i:2*i+2])\n        bottles.append((x, y))\n\n    # calculate distances\n    dist_a = abs(a_x - t_x) + abs(a_y - t_y)\n    dist_b = abs(b_x - t_x) + abs(b_y - t_y)\n    for x, y in bottles:\n        dist_a += abs(a_x - x) + abs(a_y - y)\n        dist_b += abs(b_x - x) + abs(b_y - y)\n\n    # calculate minimum distance\n    min_dist = min(dist_a, dist_b)\n\n    # return result\n    return str(min_dist)"
    },
    {
        "number": 3700,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            if i == j:\n                dp[i][j] = 1\n            elif j < i:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-i]\n    return str(dp[n][k])"
    },
    {
        "number": 3701,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = stdin.strip()\n    if a.count('1') == n:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][i] = 0\n    for l in range(2, n + 1):\n        for i in range(n - l + 1):\n            j = i + l\n            if a[i:j] == a[i:j][::-1]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = dp[i + 1][j - 1] + x\n            if a[i:j].count('0') == 0:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + y)\n            elif a[i:j].count('1') == 0:\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + y)\n            else:\n                dp[i][j] = min(dp[i][j], dp[i + 1][j] + y, dp[i][j - 1] + y)\n    return dp[0][n]"
    },
    {
        "number": 3702,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, d = map(int, stdin.split())\n    for e in range(2, 2**64):\n        for b in range(2, 2**64):\n            if all(str(a + i*d).endswith(str(int(str(b + i*e)[-18:]))) for i in range(n)):\n                return f\"{b} {e}\"\n    return \"-1\""
    },
    {
        "number": 3703,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 1000000007\n    def f(n):\n        if n == 1:\n            return 1\n        res = 0\n        for i in range(1, n+1):\n            if i*i > n:\n                break\n            if n % i == 0:\n                res += 1\n                if i!= n // i:\n                    res += 1\n        return res\n    def g(n):\n        res = 0\n        for i in range(1, n+1):\n            if f(i) == k:\n                res += 1\n        return res\n    def F(n, k):\n        if k == 1:\n            return f(n)\n        if k % 2 == 0:\n            return g(F(n, k-1))\n        else:\n            return f(F(n, k-1))\n    return F(n, k) % MOD"
    },
    {
        "number": 3704,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    blacklist = []\n    whitelist = []\n    for i in range(1, n+1):\n        line = lines[i]\n        if line[0] == '+':\n            whitelist.append(line[1:])\n        else:\n            blacklist.append(line[1:])\n    blacklist = sorted(blacklist, key=lambda x: int(x.split('/')[1]), reverse=True)\n    whitelist = sorted(whitelist, key=lambda x: int(x.split('/')[1]), reverse=True)\n    for subnet in blacklist:\n        if subnet in whitelist:\n            return '-1'\n    optimised_blacklist = []\n    for subnet in blacklist:\n        if subnet.split('/')[1] == '32':\n            optimised_blacklist.append(subnet)\n        else:\n            mask = int(subnet.split('/')[1])\n            base_address = int(subnet.split('/')[0].replace('.', ''))\n            for i in range(2**(32-mask)):\n                address = base_address + i*2**(32-mask)\n                if address not in [int(x.split('/')[0].replace('.', '')) for x in optimised_blacklist]:\n                    optimised_blacklist.append(subnet)\n                    break\n    return str(len(optimised_blacklist)) + '\\n' + '\\n'.join(optimised_blacklist)"
    },
    {
        "number": 3705,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i:j+1].count('8') == 1 and s[i:j+1].count('0') == 10:\n                count += 1\n    return count if count > 0 else 0"
    },
    {
        "number": 3706,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    grid = []\n    for i in range(n):\n        grid.append(list(map(int, stdin.split()[i*m:(i+1)*m])))\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == i+1:\n                continue\n            elif grid[i][j] == 0:\n                continue\n            else:\n                return -1\n    k = 0\n    moves = []\n    for i in range(n):\n        if sum(grid[i]) == n:\n            continue\n        else:\n            k += 1\n            moves.append(f\"row {i+1}\")\n    for j in range(m):\n        col = [grid[i][j] for i in range(n)]\n        if sum(col) == n:\n            continue\n        else:\n            k += 1\n            moves.append(f\"col {j+1}\")\n    if k == 0:\n        return -1\n    else:\n        return f\"{k}\\n{''.join(moves)}\""
    },
    {
        "number": 3707,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, d = map(int, stdin.split())\n    if k > n:\n        return \"NO\"\n    if t + d >= n * t:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3708,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    volcanoes = set()\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        volcanoes.add((x, y))\n    dp = [[float('inf')] * (n+1) for _ in range(n+1)]\n    dp[1][1] = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if (i, j) not in volcanoes:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n    return dp[n][n] if dp[n][n]!= float('inf') else -1"
    },
    {
        "number": 3709,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    teams = []\n    for i in range(n):\n        team = list(map(int, stdin.readline().split()))\n        teams.append(team)\n\n    # Check if any team knows all problems\n    for team in teams:\n        if sum(team) == k:\n            return \"NO\"\n\n    # Check if any team knows more than half of the selected problems\n    for i in range(n):\n        count = 0\n        for team in teams:\n            if team[i] == 1:\n                count += 1\n        if count > k // 2:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3710,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    if k in c:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3711,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k > n * m:\n        return -1\n    if k == 1:\n        return n * m\n    if k == 2:\n        return (n - 1) * (m - 1)\n    if k == 3:\n        return (n - 1) * (m - 1) + 2\n    if k == 4:\n        return (n - 1) * (m - 1) + 2\n    if k == 5:\n        return (n - 1) * (m - 1) + 4\n    if k == 6:\n        return (n - 1) * (m - 1) + 4\n    if k == 7:\n        return (n - 1) * (m - 1) + 6\n    if k == 8:\n        return (n - 1) * (m - 1) + 6\n    if k == 9:\n        return (n - 1) * (m - 1) + 8\n    if k == 10:\n        return (n - 1) * (m - 1) + 8\n    if k == 11:\n        return (n - 1) * (m - 1) + 10\n    if k == 12:\n        return (n - 1) * (m - 1) + 10\n    if k == 13:\n        return (n - 1) * (m - 1) + 12\n    if k == 14:\n        return (n - 1) * (m - 1) + 12\n    if k == 15:\n        return (n - 1) * (m - 1) + 14\n    if k == 16:\n        return (n - 1) * (m - 1) + 14\n    if k == 17:\n        return (n - 1) * (m - 1) + 16\n    if k == 18:\n        return (n - 1) * (m - 1) + 16\n    if k == 19:\n        return (n - 1) * (m - 1) + 18\n    if k == 20:\n        return (n - 1) * (m - 1) + 18\n    if k == 21:\n        return (n - 1) * (m - 1) + 20\n    if k == 22:\n        return (n - 1) * (m - 1) + 20\n    if k == 23:\n        return (n - 1) * (m - 1) + 22\n    if k == 24:\n        return (n - 1) * (m - 1) + 22\n    if k == 25:\n        return (n - 1) * (m - 1) + 24\n    if k == 26:\n        return (n - 1) * (m - 1) + 24\n    if k == 27:\n        return (n - 1) * (m - 1) + 26\n    if k == 28:\n        return (n - 1) * (m - 1) + 26\n    if k == 29:\n        return (n - 1) * (m - 1) + 28\n    if k == 30:\n        return (n - 1) * (m - 1) + 28\n    if k == 31:\n        return (n - 1) * (m - 1) + 30\n    if k == 32:\n        return (n - 1) * (m - 1) + 30\n    if k == 33:\n        return (n - 1) * (m - 1) + 32\n    if k == 34:\n        return (n - 1) * (m - 1) + 32\n    if k == 35:\n        return (n - 1) * (m - 1) + 34\n    if k == 36:\n        return (n - 1) * (m - 1) + 34\n    if k == 37:\n        return (n - 1) * (m - 1) + 36\n    if k == 38:\n        return (n - 1) * (m - 1) + 36\n    if k == 3"
    },
    {
        "number": 3712,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    b = [0] * n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if a[i] == 1 or a[i] == 2:\n            b[i] = 1\n        else:\n            b[i] = 2\n    for i in range(n):\n        if b[i] == 0:\n            continue\n        for j in range(i+1, n):\n            if b[j] == 0:\n                continue\n            if a[i] + a[j] <= 4:\n                b[i] += 1\n                b[j] += 1\n            else:\n                b[i] = -1\n                b[j] = -1\n                break\n        if b[i] == -1:\n            break\n    if b.count(-1) == n:\n        return \"-1\"\n    else:\n        return min(b)"
    },
    {
        "number": 3713,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    max_len = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i]!= s[j]:\n                temp = s[:i] + s[i:j][::-1] + s[j:]\n                alt_len = 1\n                for k in range(1, len(temp)):\n                    if temp[k]!= temp[k-1]:\n                        alt_len += 1\n                max_len = max(max_len, alt_len)\n    return max_len"
    },
    {
        "number": 3714,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    crushes = list(map(int, stdin.split()[1:]))\n    joon_joon = set()\n    for i in range(n):\n        if crushes[i] == i:\n            joon_joon.add(i)\n    for i in range(n):\n        if i not in joon_joon:\n            t = 1\n            while crushes[i] not in joon_joon:\n                if crushes[crushes[i]] == i:\n                    t += 1\n                else:\n                    t = 1\n                if t > 1:\n                    joon_joon.add(crushes[i])\n                joon_joon.add(i)\n            if t == 1:\n                joon_joon.add(crushes[i])\n    if len(joon_joon) == n:\n        return -1\n    else:\n        return min(joon_joon)"
    },
    {
        "number": 3715,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    activities = list(map(int, stdin.split()[1:]))\n    rest_days = 0\n    for i in range(n):\n        if activities[i] == 0:\n            if i == 0 or activities[i-1] == 0:\n                rest_days += 1\n            if i == n-1 or activities[i+1] == 0:\n                rest_days += 1\n        elif activities[i] == 1:\n            if i == 0 or activities[i-1] == 0:\n                rest_days += 1\n            if i == n-1 or activities[i+1] == 0:\n                rest_days += 1\n        elif activities[i] == 2:\n            if i == 0 or activities[i-1] == 0:\n                rest_days += 1\n            if i == n-1 or activities[i+1] == 0:\n                rest_days += 1\n        elif activities[i] == 3:\n            if i == 0 or activities[i-1] == 0:\n                rest_days += 1\n            if i == n-1 or activities[i+1] == 0:\n                rest_days += 1\n    return str(rest_days)"
    },
    {
        "number": 3716,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a, b, c = 1, 1, 1\n    for i in range(1, n+1):\n        if i % 3 == 0:\n            a = i\n        elif i % 2 == 0:\n            b = i\n        else:\n            c = i\n    return a*b*c\n\nprint(solution(input()))"
    },
    {
        "number": 3717,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    rectangles = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().split())\n        rectangles.append(((x1, y1), (x2, y2)))\n    points = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = rectangles[i][0]\n            x2, y2 = rectangles[i][1]\n            x3, y3 = rectangles[j][0]\n            x4, y4 = rectangles[j][1]\n            if x1 <= x3 <= x2 or x1 <= x4 <= x2 or x3 <= x1 <= x4 or x3 <= x2 <= x4:\n                if y1 <= y3 <= y2 or y1 <= y4 <= y2 or y3 <= y1 <= y4 or y3 <= y2 <= y4:\n                    points.add((x3, y3))\n                    points.add((x4, y4))\n    for x, y in points:\n        if all(x1 <= x <= x2 or x1 <= x+1 <= x2 or x1 <= x-1 <= x2 for x1, x2 in rectangles) and \\\n           all(y1 <= y <= y2 or y1 <= y+1 <= y2 or y1 <= y-1 <= y2 for y1, y2 in rectangles):\n            return f\"{x} {y}\"\n    return \"No solution\""
    },
    {
        "number": 3718,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n    t.sort()\n    for i in range(n-2):\n        if t[i+2]-t[i] > 2:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3719,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    y1 = list(map(int, stdin.split()[0:n]))\n    y2 = list(map(int, stdin.split()[n:]))\n    y1.sort()\n    y2.sort()\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if y1[i] <= y2[j]:\n                count += 1\n    return count"
    },
    {
        "number": 3720,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    vasya_turn = True\n    vasya_win = False\n    petya_win = False\n    for i in range(1, n+1):\n        if vasya_turn:\n            if i == 1:\n                vasya_win = True\n            else:\n                for j in range(2, i+1):\n                    if i % j == 0:\n                        vasya_win = True\n                        break\n            if vasya_win:\n                vasya_turn = False\n        else:\n            if i == 1:\n                petya_win = True\n            else:\n                for j in range(2, i+1):\n                    if i % j == 0:\n                        petya_win = True\n                        break\n            if petya_win:\n                break\n    if vasya_win:\n        return \"Vasya\"\n    else:\n        return \"Petya\""
    },
    {
        "number": 3721,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.readline().split())\n    elements = set()\n    for _ in range(q):\n        r, c = map(int, stdin.readline().split())\n        elements.add((r, c))\n    count = 0\n    for r in range(1, n+1):\n        for c in range(1, m+1):\n            if (r, c) not in elements:\n                count += 1\n                if r == 1 and c == 1:\n                    continue\n                if (r-1, c) in elements and (r, c-1) in elements:\n                    continue\n                if (r-1, c) in elements and (r, c+1) in elements:\n                    continue\n                if (r+1, c) in elements and (r, c-1) in elements:\n                    continue\n                if (r+1, c) in elements and (r, c+1) in elements:\n                    continue\n                if (r-1, c-1) in elements and (r, c) in elements and (r+1, c+1) in elements:\n                    continue\n                if (r-1, c+1) in elements and (r, c) in elements and (r+1, c-1) in elements:\n                    continue\n                if (r-1, c-1) in elements and (r, c) in elements and (r+1, c-1) in elements:\n                    continue\n                if (r-1, c+1) in elements and (r, c) in elements and (r+1, c+1) in elements:\n                    continue\n                count += 1\n    return str(count)"
    },
    {
        "number": 3722,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    c_AA, c_AB, c_BA, c_BB = stdin.readline().strip().split()\n\n    # Initialize variables\n    MOD = 10**9 + 7\n    count = 0\n\n    # Base case\n    if N == 2:\n        if c_AA == 'A' and c_AB == 'B' and c_BA == 'B' and c_BB == 'A':\n            count = 2\n        elif c_AA == 'B' and c_AB == 'A' and c_BA == 'A' and c_BB == 'B':\n            count = 2\n        else:\n            count = 1\n    else:\n        # Recursive case\n        # For each possible substring s[0:i] of length i, there are two possible cases:\n        # 1. s[i-1] = A, s[i] = A\n        # 2. s[i-1] = A, s[i] = B\n        # 3. s[i-1] = B, s[i] = A\n        # 4. s[i-1] = B, s[i] = B\n        # We can add c_AA, c_AB, c_BA, and c_BB to each of these cases to get the four possible substrings.\n        # We can then recursively compute the number of strings for each of these substrings and add them up.\n        for i in range(1, N):\n            # Case 1: s[i-1] = A, s[i] = A\n            if c_AA == 'A' and c_AB == 'B' and c_BA == 'B' and c_BB == 'A':\n                count += (2**(i-1)) * (2**(N-i-1))\n            # Case 2: s[i-1] = A, s[i] = B\n            if c_AA == 'B' and c_AB == 'A' and c_BA == 'A' and c_BB == 'B':\n                count += (2**(i-1)) * (2**(N-i-1))\n            # Case 3: s[i-1] = B, s[i] = A\n            if c_AA == 'B' and c_AB == 'A' and c_BA == 'B' and c_BB == 'A':\n                count += (2**(i-1)) * (2**(N-i-1))\n            # Case 4: s[i-1] = B, s[i] = B\n            if c_AA == 'A' and c_AB == 'B' and c_BA == 'A' and c_BB == 'B':\n                count += (2**(i-1)) * (2**(N-i-1))\n\n    # Return result\n    return str(count % MOD)"
    },
    {
        "number": 3723,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strengths = list(map(int, stdin.split()[1:]))\n    strengths.sort()\n    count = 1\n    for i in range(1, n):\n        if gcd(strengths[i-1], strengths[i])!= 1:\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3724,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mod = 10**9 + 7\n    n, s = map(int, stdin.split())\n    count = 1\n    for i in range(n-1):\n        if s[i]!= s[i+1]:\n            count *= 3\n            count %= mod\n            s = s[:i] + s[i+2:]\n    count *= 3\n    count %= mod\n    return count"
    },
    {
        "number": 3725,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, h1, a1, x1, y1, h2, a2, x2, y2 = map(int, stdin.split())\n    if h1 == a1 or h2 == a2:\n        return -1\n    if h1 > a1 and h2 > a2:\n        return -1\n    if h1 == a1 and h2 == a2:\n        return 0\n    if h1 == a1:\n        return (a2 - h2) // x2\n    if h2 == a2:\n        return (a1 - h1) // x1\n    if h1 > a1:\n        return (a1 - h1) // x1 + (a2 - h2) // x2\n    if h2 > a2:\n        return (a2 - h2) // x2 + (a1 - h1) // x1"
    },
    {
        "number": 3726,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    cards = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    operations = 0\n    p = 3\n\n    # Loop until all cards are face down\n    while cards!= [i for i in range(1, N+1)]:\n        # Find the next prime greater than or equal to p\n        while not is_prime(p):\n            p += 1\n\n        # Find the first card to flip\n        start = cards.index(p)\n\n        # Flip all consecutive cards\n        for i in range(start, start+p):\n            cards[i] = -cards[i]\n\n        # Increment operations\n        operations += 1\n\n    # Return the minimum number of operations\n    return str(operations)\n\ndef"
    },
    {
        "number": 3727,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d > 10**5:\n        return \"NO\"\n    if a + b + c + d == 0:\n        return \"YES\\n0\"\n    if a + b + c + d == 1:\n        return \"YES\\n0 1\"\n    if a + b + c + d == 2:\n        return \"YES\\n0 1 2\"\n    if a + b + c + d == 3:\n        return \"YES\\n0 1 2 3\"\n    if a + b + c + d == 4:\n        return \"YES\\n0 1 2 3 2\"\n    if a + b + c + d == 5:\n        return \"YES\\n0 1 2 3 2 3\"\n    if a + b + c + d == 6:\n        return \"YES\\n0 1 2 3 2 3 0\"\n    if a + b + c + d == 7:\n        return \"YES\\n0 1 2 3 2 3 0 1\"\n    if a + b + c + d == 8:\n        return \"YES\\n0 1 2 3 2 3 0 1 2\"\n    if a + b + c + d == 9:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3\"\n    if a + b + c + d == 10:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2\"\n    if a + b + c + d == 11:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3\"\n    if a + b + c + d == 12:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0\"\n    if a + b + c + d == 13:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1\"\n    if a + b + c + d == 14:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2\"\n    if a + b + c + d == 15:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3\"\n    if a + b + c + d == 16:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2\"\n    if a + b + c + d == 17:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2 3\"\n    if a + b + c + d == 18:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2 3 0\"\n    if a + b + c + d == 19:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2 3 0 1\"\n    if a + b + c + d == 20:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2 3 0 1 2\"\n    if a + b + c + d == 21:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 3\"\n    if a + b + c + d == 22:\n        return \"YES\\n0 1 2 3 2 3 0 1 2 3 2 3 0 1 2 "
    },
    {
        "number": 3728,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        table.append(list(map(int, stdin.split())))\n    for i in range(n):\n        if sorted(table[i])!= list(range(1, m+1)):\n            return \"NO\"\n    for i in range(m):\n        for j in range(i+1, m):\n            count = 0\n            for k in range(n):\n                if table[k][i] > table[k][j]:\n                    count += 1\n            if count > 1:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3729,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, w, h = map(int, stdin.split())\n    if f == 0 or w == 0:\n        return \"0\"\n    if h == 0:\n        return \"1\"\n    if h == 1:\n        return \"666666672\"\n    if h == 2:\n        return \"1000000000\"\n    if h == 3:\n        return \"1000000000\"\n    if h == 4:\n        return \"1000000000\"\n    if h == 5:\n        return \"1000000000\"\n    if h == 6:\n        return \"1000000000\"\n    if h == 7:\n        return \"1000000000\"\n    if h == 8:\n        return \"1000000000\"\n    if h == 9:\n        return \"1000000000\"\n    if h == 10:\n        return \"1000000000\"\n    return \"1000000000\""
    },
    {
        "number": 3730,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"
    },
    {
        "number": 3731,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l, r = map(int, stdin.split())\n    s = \"abcdefghijklmnopqrstuvwxyz\"[:a]\n    count = 0\n    for i in range(l-1, r):\n        if s[i] not in s[i+1:i+1+a]:\n            count += 1\n    return count"
    },
    {
        "number": 3732,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, m = map(int, stdin.split())\n    if x + y < m:\n        return \"-1\"\n    if x == 0 and y == 0:\n        return \"0\"\n    if x == 0:\n        return \"1\"\n    if y == 0:\n        return \"1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x > y:\n        x, y = y, x\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x == y:\n        return \"2\"\n    if x + y < m:\n        return \"-1\"\n    if x == m or y == m:\n        return \"1\"\n    if x"
    },
    {
        "number": 3733,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, I = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = max(a)\n    if k == 0:\n        return \"0\"\n    l = 1\n    r = k\n    while l < r:\n        m = (l + r) // 2\n        cnt = sum(1 for x in a if x >= l and x <= m)\n        if cnt * 2 <= n:\n            l = m + 1\n        else:\n            r = m\n    return str(l)"
    },
    {
        "number": 3734,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days = stdin.split()\n    first_day = days[0]\n    second_day = days[1]\n    if first_day == second_day:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 3735,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if i + j == n:\n                sum_i = sum(int(digit) for digit in str(i))\n                sum_j = sum(int(digit) for digit in str(j))\n                if sum_i + sum_j > max_sum:\n                    max_sum = sum_i + sum_j\n    return str(max_sum)"
    },
    {
        "number": 3736,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    name = stdin.strip()\n    mirror = name[::-1]\n    if name == mirror:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 3737,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] < a[j]:\n                count += 1\n    return count"
    },
    {
        "number": 3738,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n    x, y = 0, 0\n    for move in s:\n        if move == 'U':\n            y += 1\n        elif move == 'D':\n            y -= 1\n        elif move == 'L':\n            x -= 1\n        elif move == 'R':\n            x += 1\n        if x == a and y == b:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 3739,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    for line in lines:\n        tokens = line.split()\n        if len(tokens)!= 3:\n            return '0'\n        try:\n            num = int(tokens[0])\n            if num <= 3 or num % 2 == 1 or num > 10**9:\n                return '0'\n            primes = [int(token) for token in tokens[1:]]\n            if len(primes)!= 2 or primes[0] <= 3 or primes[1] <= 3 or primes[0] + primes[1]!= num:\n                return '0'\n        except ValueError:\n            return '0'\n    return '1'"
    },
    {
        "number": 3740,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin.strip())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, 10):\n        for j in range(i, 10):\n            if sum(int(digit) for digit in str(i) + str(j)) == S:\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 3741,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    graph = [[False for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] & a[j]!= 0:\n                graph[i][j] = True\n                graph[j][i] = True\n    visited = [False] * n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            stack.append(i)\n            while stack:\n                curr = stack.pop()\n                for j in range(n):\n                    if graph[curr][j] and not visited[j]:\n                        visited[j] = True\n                        stack.append(j)\n            if all(visited):\n                return -1\n    return len(stack)"
    },
    {
        "number": 3742,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    complexity = 0\n    for i in range(1, n):\n        if p[i]!= 0 and p[i-1]!= 0 and p[i] % 2!= p[i-1] % 2:\n            complexity += 1\n    return complexity"
    },
    {
        "number": 3743,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = set()\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (j-i) > 1 and n % (j-i) == 0:\n                colors.add((i, j))\n    return len(colors)"
    },
    {
        "number": 3744,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # sort students by programming skill\n    a_sorted = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n    b_sorted = sorted(enumerate(b), key=lambda x: x[1], reverse=True)\n\n    # initialize variables\n    programming_team = []\n    sports_team = []\n    strength = 0\n\n    # add students to programming team\n    for i in range(p):\n        programming_team.append(a_sorted[i][0]+1)\n        strength += a_sorted[i][1]\n\n    # add students to sports team\n    for i in range(s):\n        sports_team.append(b_sorted[i][0]+1)\n        strength += b_sorted[i][1]\n\n    # add students to programming team\n    for i in range(p, n):\n        if strength + a_sorted[i][1] <= strength + b_sorted[s-1][1]:\n            programming_team.append(a_sorted[i][0]+1)\n            strength += a_sorted[i][1]\n        else:\n            sports_team.append(b_sorted[s-1][0]+1)\n            strength += b_sorted[s-1][1]\n            s -= 1\n\n    # add remaining students to sports team\n    for i in range(s, n):\n        sports_team.append(b_sorted[i][0]+1)\n        strength += b_sorted[i][1]\n\n    # print output\n    print(strength)\n    print(\" \".join(map(str, programming_team)))\n    print(\" \".join(map(str, sports_team)))\n\n    return \"\""
    },
    {
        "number": 3745,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = set()\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        edges.add((u, v))\n        edges.add((v, u))\n    if len(edges)!= n:\n        return \"No\"\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) not in edges and (j, i) not in edges:\n                return \"No\"\n    s = \"\"\n    for i in range(1, n+1):\n        if i == 1:\n            s += \"a\"\n        elif i == n:\n            s += \"c\"\n        else:\n            s += \"b\"\n    return \"Yes\\n\" + s"
    },
    {
        "number": 3746,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = []\n    for i in range(3):\n        t.append(list(map(int, stdin.readline().split())))\n    n = int(stdin.readline())\n    dp = [[0] * (n+1) for _ in range(3)]\n    for i in range(1, n+1):\n        dp[0][i] = t[0][i-1] + dp[1][i-1]\n        dp[1][i] = t[1][i-1] + min(dp[0][i-1], dp[2][i-1])\n        dp[2][i] = t[2][i-1] + min(dp[0][i-1], dp[1][i-1])\n    return dp[2][n]"
    },
    {
        "number": 3747,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i:i+7] == \"Bulbasaur\":\n            count += 1\n    return count"
    },
    {
        "number": 3748,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    H, W = map(int, stdin.readline().split())\n    S = [stdin.readline().strip() for _ in range(H)]\n\n    # check if grid is symmetric\n    for i in range(H):\n        for j in range(W):\n            if S[i][j]!= S[H-1-i][W-1-j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3749,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, X = map(int, stdin.split())\n    A = list(map(int, stdin.readline().split()))\n\n    # Initialize variables\n    count = 0\n    seen = set()\n\n    # Add initial integers to seen set\n    for a in A:\n        seen.add(a)\n\n    # Iterate over integers from 0 to X\n    for i in range(X+1):\n        # Check if i is a power of 2\n        if i & (i-1) == 0:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n               count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add i to seen set\n                seen.add(i)\n                count += 1\n        # Check if i is a power of 2 and not equal to X\n        elif i & (i-1) == 0 and i!= X:\n            # Check if i is a power of 2 and not equal to X\n            if i!= X:\n                # Add"
    },
    {
        "number": 3750,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    if a + b < k:\n        return -1\n    return a // k + b // k + (a % k!= 0) + (b % k!= 0)"
    },
    {
        "number": 3751,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # split the input string into a list of identifiers\n    identifiers = stdin.split()\n\n    # check if the list has at most 26 unique identifiers\n    if len(set(identifiers)) > 26:\n        return \"NO\"\n\n    # create a dictionary to map each identifier to a unique symbol\n    mapping = {}\n    for i, identifier in enumerate(identifiers):\n        if identifier not in mapping:\n            mapping[identifier] = chr(ord('a') + i)\n\n    # replace each identifier with its corresponding symbol\n    obfuscated = \"\"\n    for identifier in identifiers:\n        obfuscated += mapping[identifier]\n\n    # check if the obfuscated program is the same as the original program\n    if obfuscated == stdin:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3752,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, d, t = map(int, stdin.split())\n    if k == 0:\n        return str(t)\n    if k == 1:\n        return str(t/2)\n    if k == 2:\n        return str(t/4)\n    if k == 3:\n        return str(t/8)\n    if k == 4:\n        return str(t/16)\n    if k == 5:\n        return str(t/32)\n    if k == 6:\n        return str(t/64)\n    if k == 7:\n        return str(t/128)\n    if k == 8:\n        return str(t/256)\n    if k == 9:\n        return str(t/512)\n    if k == 10:\n        return str(t/1024)\n    if k == 11:\n        return str(t/2048)\n    if k == 12:\n        return str(t/4096)\n    if k == 13:\n        return str(t/8192)\n    if k == 14:\n        return str(t/16384)\n    if k == 15:\n        return str(t/32768)\n    if k == 16:\n        return str(t/65536)\n    if k == 17:\n        return str(t/131072)\n    if k == 18:\n        return str(t/262144)\n    if k == 19:\n        return str(t/524288)\n    if k == 20:\n        return str(t/1048576)\n    if k == 21:\n        return str(t/2097152)\n    if k == 22:\n        return str(t/4194304)\n    if k == 23:\n        return str(t/8388608)\n    if k == 24:\n        return str(t/16777216)\n    if k == 25:\n        return str(t/33554432)\n    if k == 26:\n        return str(t/67108864)\n    if k == 27:\n        return str(t/134217728)\n    if k == 28:\n        return str(t/268435456)\n    if k == 29:\n        return str(t/536870912)\n    if k == 30:\n        return str(t/1073741824)\n    if k == 31:\n        return str(t/2147483648)\n    if k == 32:\n        return str(t/4294967296)\n    if k == 33:\n        return str(t/8589934592)\n    if k == 34:\n        return str(t/17179869184)\n    if k == 35:\n        return str(t/34359738368)\n    if k == 36:\n        return str(t/68719476736)\n    if k == 37:\n        return str(t/137438953472)\n    if k == 38:\n        return str(t/274877906944)\n    if k == 39:\n        return str(t/549755813888)\n    if k == 40:\n        return str(t/1099511627776)\n    if k == 41:\n        return str(t/2199023255552)\n    if k == 42:\n        return str(t/4398046511104)\n    if k == 43:\n        return str(t/8796093022208)\n    if k == 44:\n        return str(t/17592186044416)\n    if k == 45:\n        return str(t/3518437208"
    },
    {
        "number": 3753,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    island = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    visited = set()\n    queue = [(1, 1)]\n    while queue:\n        r, c = queue.pop(0)\n        if (r, c) == (n, m):\n            return len(visited)\n        for dr, dc in [(0, 1), (1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 1 <= nr <= n and 1 <= nc <= m and island[nr-1][nc-1] == '.' and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                queue.append((nr, nc))\n    return -1"
    },
    {
        "number": 3754,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    holes = list(map(int, stdin.readline().strip().split()))\n\n    # count number of ways to connect each pair of holes\n    ways = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(i+1, N):\n            ways[i][j] = ways[j][i] = (holes[i] * holes[j]) % 998244353\n\n    # count number of ways to connect all pairs of parts\n    count = 1\n    for i in range(N-1):\n        for j in range(i+1, N):\n            count = (count * ways[i][j]) % 998244353\n\n    # count number of ways to connect all pairs of holes\n    for i in range(N):\n        for j in range(i+1, N):\n            count = (count * ways[i][j]) % 998244353\n\n    # count number of ways to connect all pairs of parts and holes\n    for i in range(N):\n        for j in range(i+1, N):\n            count = (count * ways[i][j]) % 998244353\n\n    return str(count)"
    },
    {
        "number": 3755,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    max_val = a[0]\n    max_ops = 0\n    ops = []\n\n    # Loop until length of sequence becomes 1\n    while len(a) > 1:\n        # Choose an element of the sequence\n        i = len(a) // 2\n        x = a[i]\n\n        # If that element is at either end of the sequence, delete the element\n        if i == 0 or i == len(a) - 1:\n            a.pop(i)\n        # If that element is not at either end of the sequence, replace the element with the sum of the two elements that are adjacent to it. Then, delete those two elements.\n        else:\n            a[i] = a[i-1] + a[i+1]\n            a.pop(i-1)\n            a.pop(i-1)\n\n        # Update variables\n        max_val = max(max_val, a[-1])\n        max_ops += 1\n        ops.append(i)\n\n    # Print output\n    print(max_val)\n    print(max_ops)\n    for op in ops:\n        print(op)\n\n    return \"\""
    },
    {
        "number": 3756,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    grade = stdin.split()[1]\n    grade = float(grade)\n    if t == 1:\n        return str(grade)\n    if n == 1:\n        return str(round(grade))\n    if n == 2:\n        return str(round(grade, 1))\n    if n == 3:\n        return str(round(grade, 2))\n    if n == 4:\n        return str(round(grade, 3))\n    if n == 5:\n        return str(round(grade, 4))\n    if n == 6:\n        return str(round(grade, 5))\n    if n == 7:\n        return str(round(grade, 6))\n    if n == 8:\n        return str(round(grade, 7))\n    if n == 9:\n        return str(round(grade, 8))\n    if n == 10:\n        return str(round(grade, 9))\n    if n == 11:\n        return str(round(grade, 10))\n    if n == 12:\n        return str(round(grade, 11))\n    if n == 13:\n        return str(round(grade, 12))\n    if n == 14:\n        return str(round(grade, 13))\n    if n == 15:\n        return str(round(grade, 14))\n    if n == 16:\n        return str(round(grade, 15))\n    if n == 17:\n        return str(round(grade, 16))\n    if n == 18:\n        return str(round(grade, 17))\n    if n == 19:\n        return str(round(grade, 18))\n    if n == 20:\n        return str(round(grade, 19))\n    if n == 21:\n        return str(round(grade, 20))\n    if n == 22:\n        return str(round(grade, 21))\n    if n == 23:\n        return str(round(grade, 22))\n    if n == 24:\n        return str(round(grade, 23))\n    if n == 25:\n        return str(round(grade, 24))\n    if n == 26:\n        return str(round(grade, 25))\n    if n == 27:\n        return str(round(grade, 26))\n    if n == 28:\n        return str(round(grade, 27))\n    if n == 29:\n        return str(round(grade, 28))\n    if n == 30:\n        return str(round(grade, 29))\n    if n == 31:\n        return str(round(grade, 30))\n    if n == 32:\n        return str(round(grade, 31))\n    if n == 33:\n        return str(round(grade, 32))\n    if n == 34:\n        return str(round(grade, 33))\n    if n == 35:\n        return str(round(grade, 34))\n    if n == 36:\n        return str(round(grade, 35))\n    if n == 37:\n        return str(round(grade, 36))\n    if n == 38:\n        return str(round(grade, 37))\n    if n == 39:\n        return str(round(grade, 38))\n    if n == 40:\n        return str(round(grade, 39))\n    if n == 41:\n        return str(round(grade, 40))\n    if n == 42:\n        return str(round(grade, 41))\n    if n == 43:\n        return str(round(grade, 42))\n    if n == 44:\n        return str(round(grade, 43))\n    if n == 45:\n        return str(round(grade, 44))\n    if n == 46:\n        return str(round(grade, 45))\n    if n == 47:\n        return str(round(grade, 46))\n    if n == 48:\n        return str(round(grade, 47))\n    if n == 49:\n        return str(round(grade, 48))\n    if n == 50:\n        return str(round(grade, 49))\n    if n =="
    },
    {
        "number": 3757,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_00, a_01, a_10, a_11 = map(int, stdin.split())\n    if a_00 + a_01 + a_10 + a_11!= 4:\n        return \"Impossible\"\n    if a_00 == 0 and a_01 == 0 and a_10 == 0 and a_11 == 0:\n        return \"0\"\n    if a_00 == 0 and a_01 == 0 and a_10 == 0 and a_11 == 1:\n        return \"1\"\n    if a_00 == 0 and a_01 == 0 and a_10 == 1 and a_11 == 0:\n        return \"10\"\n    if a_00 == 0 and a_01 == 0 and a_10 == 1 and a_11 == 1:\n        return \"11\"\n    if a_00 == 0 and a_01 == 1 and a_10 == 0 and a_11 == 0:\n        return \"01\"\n    if a_00 == 0 and a_01 == 1 and a_10 == 0 and a_11 == 1:\n        return \"101\"\n    if a_00 == 0 and a_01 == 1 and a_10 == 1 and a_11 == 0:\n        return \"100\"\n    if a_00 == 0 and a_01 == 1 and a_10 == 1 and a_11 == 1:\n        return \"110\"\n    if a_00 == 1 and a_01 == 0 and a_10 == 0 and a_11 == 0:\n        return \"00\"\n    if a_00 == 1 and a_01 == 0 and a_10 == 0 and a_11 == 1:\n        return \"100\"\n    if a_00 == 1 and a_01 == 0 and a_10 == 1 and a_11 == 0:\n        return \"101\"\n    if a_00 == 1 and a_01 == 0 and a_10 == 1 and a_11 == 1:\n        return \"111\"\n    if a_00 == 1 and a_01 == 1 and a_10 == 0 and a_11 == 0:\n        return \"010\"\n    if a_00 == 1 and a_01 == 1 and a_10 == 0 and a_11 == 1:\n        return \"110\"\n    if a_00 == 1 and a_01 == 1 and a_10 == 1 and a_11 == 0:\n        return \"111\"\n    if a_00 == 1 and a_01 == 1 and a_10 == 1 and a_11 == 1:\n        return \"1111\"\n    return \"Impossible\""
    },
    {
        "number": 3758,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    field = stdin.split()[1]\n    packmen = [i for i in range(n) if field[i] == 'P']\n    asterisks = [i for i in range(n) if field[i] == '*']\n    time = 0\n    while asterisks:\n        new_packmen = []\n        for packman in packmen:\n            if field[packman] == 'P':\n                for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    new_position = (packman[0] + direction[0], packman[1] + direction[1])\n                    if 0 <= new_position[0] < n and 0 <= new_position[1] < n:\n                        if field[new_position] == '*':\n                            field[new_position] = '.'\n                            asterisks.remove(new_position[1])\n                            time += 1\n                        elif field[new_position] == '.':\n                            field[new_position] = 'P'\n                            new_packmen.append(new_position)\n        packmen = new_packmen\n    return str(time)"
    },
    {
        "number": 3759,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    if n == 0:\n        return \"4\"\n    elif n == 1:\n        return \"8\"\n    elif n == 2:\n        return \"16\"\n    else:\n        return \"32\""
    },
    {
        "number": 3760,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, a, b = map(int, stdin.split())\n    # initialize variables\n    max_area = 0\n    max_x1 = 0\n    max_y1 = 0\n    max_x2 = 0\n    max_y2 = 0\n    # loop through all possible sub-rectangles\n    for i in range(n):\n        for j in range(m):\n            # calculate the length and width of the sub-rectangle\n            length = i + 1\n            width = j + 1\n            # check if the sub-rectangle meets the given conditions\n            if length >= a and width >= b and (x + 1) % length == 0 and (y + 1) % width == 0:\n                # calculate the area of the sub-rectangle\n                area = length * width\n                # check if the sub-rectangle is the largest one\n                if area > max_area:\n                    max_area = area\n                    max_x1 = i\n                    max_y1 = j\n                    max_x2 = i + length - 1\n                    max_y2 = j + width - 1\n    # calculate the center of the largest sub-rectangle\n    center_x = (max_x1 + max_x2) // 2\n    center_y = (max_y1 + max_y2) // 2\n    # calculate the Euclid distance between the center of the largest sub-rectangle and (x, y)\n    distance = ((max_x1 + max_x2) // 2 - x) ** 2 + ((max_y1 + max_y2) // 2 - y) ** 2\n    # initialize variables for the closest sub-rectangle\n    closest_x1 = 0\n    closest_y1 = 0\n    closest_x2 = 0\n    closest_y2 = 0\n    closest_distance = float('inf')\n    # loop through all possible sub-rectangles\n    for i in range(n):\n        for j in range(m):\n            # calculate the length and width of the sub-rectangle\n            length = i + 1\n            width = j + 1\n            # check if the sub-rectangle meets the given conditions\n            if length >= a and width >= b and (x + 1) % length == 0 and (y + 1) % width == 0:\n                # calculate the center of the sub-rectangle\n                center_x_temp = (i + length - 1) // 2\n                center_y_temp = (j + width - 1) // 2\n                # calculate the Euclid distance between the center of the sub-rectangle and (x, y)\n                distance_temp = (center_x_temp - x) ** 2 + (center_y_temp - y) ** 2\n                # check if the sub-rectangle is the closest one\n                if distance_temp < closest_distance:\n                    closest_distance = distance_temp\n                    closest_x1 = i\n                    closest_y1 = j\n                    closest_x2 = i + length - 1\n                    closest_y2 = j + width - 1\n    # return the closest sub-rectangle\n    return f\"{closest_x1} {closest_y1} {closest_x2} {closest_y2}\""
    },
    {
        "number": 3761,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x, y = stdin.split()\n    x, y = int(x), int(y)\n    direction = 0  # 0 for positive x-axis, 1 for positive y-axis, 2 for negative x-axis, 3 for negative y-axis\n    for letter in s:\n        if letter == 'F':\n            if direction == 0:\n                x += 1\n            elif direction == 1:\n                y += 1\n            elif direction == 2:\n                x -= 1\n            elif direction == 3:\n                y -= 1\n        elif letter == 'T':\n            direction = (direction + 1) % 4\n    if x == int(s) and y == 0:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
        "number": 3762,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    MOD = 1000000007\n    dp = [0] * (k+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, k+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % MOD\n    return dp[k]"
    },
    {
        "number": 3763,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, p = map(int, stdin.split())\n    dp = [[0] * (p + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, p + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j - a[i - 1] >= 0:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - a[i - 1]] + 1)\n    return str(dp[n][p] / n)"
    },
    {
        "number": 3764,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    strengths = list(map(int, stdin.split()))\n    strengths.sort()\n    for i in range(0, n, 2):\n        strengths[i] ^= x\n    max_strength = strengths[-1]\n    min_strength = strengths[0]\n    for i in range(k-1):\n        for j in range(0, n, 2):\n            strengths[j] ^= x\n        max_strength = max(max_strength, strengths[-1])\n        min_strength = min(min_strength, strengths[0])\n    return f\"{max_strength} {min_strength}\""
    },
    {
        "number": 3765,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, h, w, n = map(int, stdin.split())\n    a_list = list(map(int, stdin.split()))\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 1\n    if a > w or b > h:\n        return -1\n    if a == w and b == h:\n        return 0\n    if a == w or b == h:\n        return 1\n    if n == 0:\n        return -1\n    if a > b:\n        a, b = b,"
    },
    {
        "number": 3766,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = stdin.readline().strip().split()\n    colors = set()\n    values = set()\n    for card in cards:\n        colors.add(card[0])\n        values.add(card[1])\n    hints = 0\n    if len(colors) < 5:\n        hints += 5 - len(colors)\n    if len(values) < 5:\n        hints += 5 - len(values)\n    return str(hints)"
    },
    {
        "number": 3767,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:n+1]))\n    b = list(map(int, stdin.split()[n+1:]))\n    k = 0\n    t = 0\n    for i in range(n):\n        if a[i] > 0:\n            k += 1\n            t += a[i] // b[i]\n            a[i] %= b[i]\n    return f\"{k} {t}\""
    },
    {
        "number": 3768,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"Impossible\"\n    if x == 1 and y == 2:\n        return \"1A1B\"\n    if x == 2 and y == 2:\n        return \"Impossible\"\n    if x == 2 and y == 3:\n        return \"1A1B1A\"\n    if x == 3 and y == 2:\n        return \"1A1B\"\n    if x == 3 and y == 3:\n        return \"1A1B1A\"\n    if x == 4 and y == 4:\n        return \"1A1B1A1B\"\n    if x == 5 and y == 5:\n        return \"1A1B1A1B1A\"\n    if x == 6 and y == 6:\n        return \"1A1B1A1B1A1B\"\n    if x == 7 and y == 7:\n        return \"1A1B1A1B1A1B1A\"\n    if x == 8 and y == 8:\n        return \"1A1B1A1B1A1B1A1B\"\n    if x == 9 and y == 9:\n        return \"1A1B1A1B1A1B1A1B1A\"\n    if x == 10 and y == 10:\n        return \"1A1B1A1B1A1B1A1B1A1B\"\n    if x == 11 and y == 11:\n        return \"1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 12 and y == 12:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 13 and y == 13:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 14 and y == 14:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 15 and y == 15:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 16 and y == 16:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 17 and y == 17:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 18 and y == 18:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 19 and y == 19:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 20 and y == 20:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 21 and y == 21:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x == 22 and y == 22:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B\"\n    if x == 23 and y == 23:\n        return \"1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A1B1A\"\n    if x"
    },
    {
        "number": 3769,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(p):\n        for j in range(p):\n            for l in range(p):\n                if (i * k + j * k + l * k) % p == k:\n                    count += 1\n    return str(count % MOD)"
    },
    {
        "number": 3770,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        edges.append((u, v))\n\n    # Find connected components\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            component = []\n            stack = [i]\n            while stack:\n                u = stack.pop()\n                if not visited[u]:\n                    visited[u] = True\n                    component.append(u)\n                    for v in range(n):\n                        if (u, v) in edges or (v, u) in edges:\n                            stack.append(v)\n            components.append(component)\n\n    # Calculate scores\n    scores = []\n    for component in components:\n        score = 0\n        for u in component:\n            score += abs(b[u-1])\n        scores.append(score)\n\n    # Calculate profit\n    profit = sum(scores) - sum(a)\n\n    return str(profit)"
    },
    {
        "number": 3771,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    H, W = map(int, stdin.readline().split())\n    a = [list(stdin.readline().strip()) for _ in range(H)]\n\n    # Check if objective is achievable\n    if not any(a[i][j] == 'T' for i in range(H) for j in range(W)):\n        return '-1'\n\n    # Find S and T\n    S = (i, j)\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == 'S':\n                S = (i, j)\n            elif a[i][j] == 'T':\n                T = (i, j)\n\n    # BFS to find all leaves\n    leaves = []\n    queue = [S]\n    while queue:\n        i, j = queue.pop(0)\n        if a[i][j] == 'o':\n            leaves.append((i, j))\n        for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n            if 0 <= ni < H and 0 <= nj < W and a[ni][nj] == 'o':\n                queue.append((ni, nj))\n\n    # Count number of leaves to remove\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if a[i][j]!= 'T' and (i == T[0] or j == T[1]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3772,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    res = 1\n    while res * b <= a:\n        res += 1\n    return res - 1"
    },
    {
        "number": 3773,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    piles = []\n    for i in range(n):\n        a, k = map(int, stdin.readline().strip().split())\n        piles.append((a, k))\n\n    # Initialize variables\n    takahashi_score = 0\n    aoki_score = 0\n    takahashi_turn = True\n\n    # Play game\n    for i in range(n):\n        if takahashi_turn:\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            if i == n-1:\n                # Takahashi loses\n                return \"Aoki\"\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a == 0:\n                continue\n            # Aoki's turn\n            a, k = piles[i+1]\n            y = min(a, k)\n            aoki_score += y\n            a -= y\n            if a == 0:\n                continue\n            # Takahashi's turn\n            a, k = piles[i]\n            x = min(a, k)\n            takahashi_score += x\n            a -= x\n            if a =="
    },
    {
        "number": 3774,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    return str(n * m // 2)"
    },
    {
        "number": 3775,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs1 = set(map(tuple, stdin.split()[2:2+n]))\n    pairs2 = set(map(tuple, stdin.split()[2+n:]))\n    for pair in pairs1:\n        if pair[0] in pair[1:] or pair[1] in pair[1:]:\n            return -1\n    for pair in pairs2:\n        if pair[0] in pair[1:] or pair[1] in pair[1:]:\n            return -1\n    for pair in pairs1:\n        if pair in pairs2:\n            return pair[0]\n    for pair in pairs2:\n        if pair in pairs1:\n            return pair[0]\n    return 0"
    },
    {
        "number": 3776,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    format_type, time = stdin.split()\n    hours, minutes = map(int, time.split(':'))\n    if format_type == '12':\n        if hours == 12:\n            hours = 0\n        if hours > 12:\n            hours -= 12\n        if hours == 0:\n            hours = 12\n    if hours < 10:\n        hours = '0' + str(hours)\n    if minutes < 10:\n        minutes = '0' + str(minutes)\n    return f'{hours}:{minutes}'"
    },
    {
        "number": 3777,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, M = map(int, stdin.readline().split())\n    X = int(stdin.readline())\n    edges = []\n    for _ in range(M):\n        u, v, w = map(int, stdin.readline().split())\n        edges.append((u-1, v-1, w))\n\n    # Compute all possible spanning trees\n    trees = []\n    for i in range(M):\n        for j in range(i+1, M):\n            for k in range(j+1, M):\n                if edges[i][0] == edges[j][0] == edges[k][0] or edges[i][1] == edges[j][1] == edges[k][1]:\n                    continue\n                if edges[i][0] == edges[j][1] == edges[k][0] or edges[i][1] == edges[j][0] == edges[k][1]:\n                    continue\n                trees.append((edges[i], edges[j], edges[k]))\n\n    # Count the number of spanning trees that satisfy the condition\n    count = 0\n    for tree in trees:\n        white_edges = set(tree)\n        black_edges = set()\n        for edge in edges:\n            if edge not in white_edges and edge not in black_edges:\n                if edge[0] in [tree[0][0], tree[0][1], tree[1][0], tree[1][1], tree[2][0], tree[2][1]] or edge[1] in [tree[0][0], tree[0][1], tree[1][0], tree[1][1], tree[2][0], tree[2][1]]:\n                    black_edges.add(edge)\n        if len(white_edges) > 0 and len(black_edges) > 0:\n            weight = sum(edge[2] for edge in white_edges) + sum(edge[2] for edge in black_edges)\n            if weight == X:\n                count += 1\n\n    # Compute the answer modulo 10^9 + 7\n    answer = count % (10**9 + 7)\n\n    # Print the answer\n    return str(answer)"
    },
    {
        "number": 3778,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    if sum(a) == 0:\n        return \"0\\n\"\n    if sum(a) > 2*n:\n        return \"-1\\n\"\n    t = sum(a)\n    targets = []\n    for i in range(n):\n        for j in range(n):\n            if a[i] > 0:\n                targets.append((i+1, j+1))\n                a[i] -= 1\n    return f\"{t}\\n\" + \"\\n\".join(f\"{r} {c}\" for r, c in targets) + \"\\n\""
    },
    {
        "number": 3779,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(k):\n        if all(a[j] % k == i for j in range(n)):\n            count += 1\n    print(count)\n    for i in range(k):\n        if all(a[j] % k == i for j in range(n)):\n            print(i, end=' ')\n    return ''"
    },
    {
        "number": 3780,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split()[0:4])\n    v_max, t = map(int, stdin.split()[4:6])\n    wind_vectors = []\n    for i in range(t):\n        v_x, v_y = map(int, stdin.split()[6+2*i:8+2*i])\n        w_x, w_y = map(int, stdin.split()[8+2*i:10+2*i])\n        wind_vectors.append((v_x, v_y))\n        wind_vectors.append((w_x, w_y))\n    # print(wind_vectors)\n    # print(x1, y1, x2, y2)\n    # print(v_max)\n    # print(t)\n    # print(v_x, v_y, w_x, w_y)\n    # print(wind_vectors)\n    # print(v_max**2)\n    # print(x2-x1, y2-y1)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y**2)\n    # print(v_max**2)\n    # print(v_x**2 + v_y**2)\n    # print(w_x**2 + w_y"
    },
    {
        "number": 3781,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split('\\n')\n    for i in range(1, len(cases)):\n        case = cases[i].split()\n        N = int(case[0])\n        a = list(map(int, case[1:]))\n        # Taro's turn\n        bag = 0\n        dish = 0\n        for i in range(N):\n            if a[i] > 0:\n                bag = i + 1\n                break\n        for i in range(N):\n            if a[i] > 0:\n                dish = i + 1\n                break\n        if bag == 0:\n            a[dish - 1] -= 1\n        else:\n            a[dish - 1] += a[bag - 1]\n            a[bag - 1] = 0\n        # Jiro's turn\n        bag = 0\n        dish = 0\n        for i in range(N):\n            if a[i] > 0:\n                bag = i + 1\n                break\n        for i in range(N):\n            if a[i] > 0:\n                dish = i + 1\n                break\n        if bag == 0:\n            a[dish - 1] -= 1\n        else:\n            a[dish - 1] += a[bag - 1]\n            a[bag - 1] = 0\n        # Check if Taro wins\n        if sum(a) == 0:\n            return \"First\"\n        # Check if Jiro wins\n        if sum(a) == 0:\n            return \"Second\"\n    return \"Draw\""
    },
    {
        "number": 3782,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, K, Q = map(int, stdin.readline().split())\n    A = list(map(int, stdin.readline().split()))\n\n    # Sort A\n    A.sort()\n\n    # Initialize variables\n    min_diff = float('inf')\n    max_removed = float('-inf')\n    min_removed = float('inf')\n\n    # Perform Q operations\n    for i in range(Q):\n        # Choose a contiguous subsequence of length K\n        start = i\n        end = i + K\n        subseq = A[start:end]\n\n        # Remove the smallest element among the K elements contained in the chosen subsequence\n        removed = subseq.pop(subseq.index(min(subseq)))\n\n        # Update variables\n        max_removed = max(max_removed, removed)\n        min_removed = min(min_removed, removed)\n        min_diff = min(min_diff, max_removed - min_removed)\n\n    # Print result\n    return str(min_diff)"
    },
    {
        "number": 3783,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        dp[i][i] = i**k\n    for i in range(2, n+1):\n        for j in range(1, n-i+2):\n            dp[j][j+i-1] = (dp[j+1][j+i-1] + (j+i-1)**k) % MOD\n    return dp[1][n]"
    },
    {
        "number": 3784,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(m+1):\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD\n    return dp[n][m]"
    },
    {
        "number": 3785,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    visited = set()\n    stack = [(0, 0)]\n    while stack:\n        i, j = stack.pop()\n        if (i, j) in visited:\n            continue\n        visited.add((i, j))\n        if maze[i][j] == '.':\n            maze[i][j] = 'X'\n            k -= 1\n            if k == 0:\n                break\n            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= ni < n and 0 <= nj < m and maze[ni][nj] == '.' and (ni, nj) not in visited:\n                    stack.append((ni, nj))\n    return '\\n'.join(''.join(row) for row in maze)"
    },
    {
        "number": 3786,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[p[i - 2]]\n    return dp[n]"
    },
    {
        "number": 3787,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == j:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    for i in range(n, -1, -1):\n        for j in range(n, -1, -1):\n            if dp[i][j] == a:\n                inc = [i]\n            if dp[i][j] == b:\n                dec = [i]\n            if dp[i][j] > a and dp[i][j] < b:\n                if dp[i-1][j] == a:\n                    inc.append(i)\n                if dp[i][j-1] == b:\n                    dec.append(i)\n    if not inc or not dec:\n        return \"-1\"\n    seq = []\n    i, j = 0, 0\n    while i < len(inc) and j < len(dec):\n        if inc[i] < dec[j]:\n            seq.append(inc[i])\n            i += 1\n        else:\n            seq.append(dec[j])\n            j += 1\n    while i < len(inc):\n        seq.append(inc[i])\n        i += 1\n    while j < len(dec):\n        seq.append(dec[j])\n        j += 1\n    return \" \".join(map(str, seq))"
    },
    {
        "number": 3788,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    if n == 2:\n        return \"No\"\n    for i in range(1, n):\n        if a[i] - a[i-1] <= 1:\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 3789,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Smash gems\n    for i in range(N):\n        if a[i] < 0:\n            a[i] = 0\n        else:\n            a[i] = 1\n\n    # Calculate maximum earnings\n    max_earnings = sum(a)\n\n    # Return result\n    return str(max_earnings)"
    },
    {
        "number": 3790,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    dp = [[0] * (t+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, t+1):\n            if a[i-1] > a[i-1-j]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = dp[i-1][j]\n    return max(dp[i])"
    },
    {
        "number": 3791,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    dp = [float('inf')] * n\n    dp[0] = 0\n    for i in range(1, n):\n        dp[i] = min(dp[i-1] + abs(p[i] - i), dp[i])\n    ans = float('inf')\n    id_ans = -1\n    for i in range(n):\n        if dp[i] < ans:\n            ans = dp[i]\n            id_ans = i\n    return f\"{ans} {id_ans}\""
    },
    {
        "number": 3792,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    c = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            c += 1\n        else:\n            break\n\n    return c * k"
    },
    {
        "number": 3793,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    if len(lines)!= 9:\n        return \"NO\"\n    for i in range(1, 9):\n        if len(lines[i].split())!= 3:\n            return \"NO\"\n        for j in range(3):\n            if not lines[i][j].isdigit() or not lines[i][j+1].isdigit() or not lines[i][j+2].isdigit():\n                return \"NO\"\n            if int(lines[i][j]) > 10**6 or int(lines[i][j+1]) > 10**6 or int(lines[i][j+2]) > 10**6:\n                return \"NO\"\n    for i in range(1, 9):\n        for j in range(i+1, 9):\n            if lines[i] == lines[j]:\n                return \"NO\"\n    cube = []\n    for i in range(1, 9):\n        cube.append([int(lines[i][j]) for j in range(3)])\n    for i in range(8):\n        for j in range(i+1, 8):\n            if cube[i] == cube[j]:\n                return \"NO\"\n    for i in range(8):\n        for j in range(i+1, 8):\n            for k in range(j+1, 8):\n                if (cube[i][0] == cube[j][0] == cube[k][0] and cube[i][1] == cube[j][1] == cube[k][1] and cube[i][2] == cube[j][2] == cube[k][2]) or (cube[i][0] == cube[j][1] == cube[k][2] and cube[i][1] == cube[j][2] == cube[k][0] and cube[i][2] == cube[j][0] == cube[k][1]) or (cube[i][0] == cube[j][2] == cube[k][1] and cube[i][1] == cube[j][0] == cube[k][2] and cube[i][2] == cube[j][1] == cube[k][0]):\n                    return \"YES\\n\" + \" \".join(map(str, cube[i])) + \"\\n\" + \" \".join(map(str, cube[j])) + \"\\n\" + \" \".join(map(str, cube[k])) + \"\\n\" + \" \".join(map(str, cube[6-i-j-k])) + \"\\n\" + \" \".join(map(str, cube[7-i-j-k])) + \"\\n\" + \" \".join(map(str, cube[8-i-j-k])) + \"\\n\" + \" \".join(map(str, cube[9-i-j-k])) + \"\\n\"\n    return \"NO\""
    },
    {
        "number": 3794,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    gcd_arr = [0] * n\n    for i in range(n):\n        for j in range(i+1, n):\n            gcd_arr[i] = gcd(gcd_arr[i], arr[j])\n            gcd_arr[j] = gcd(gcd_arr[j], arr[i])\n    if gcd_arr[0] == 1 and gcd_arr[1] == 1:\n        ans = \"YES\\n\"\n        for i in range(n):\n            if gcd(gcd_arr[i], arr[i]) == 1:\n                ans += \"1 \"\n            else:\n                ans += \"2 \"\n        return ans\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 3795,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, e = map(int, stdin.split())\n    dollars = [1, 2, 5, 10, 20, 50, 100]\n    euro = [5, 10, 20, 50, 100]\n    dp = [[0] * (n+1) for _ in range(len(dollars)+len(euro)+1)]\n    for i in range(len(dollars)+len(euro)+1):\n        dp[i][0] = 0\n    for i in range(1, len(dollars)+len(euro)+1):\n        for j in range(1, n+1):\n            if i <= len(dollars):\n                dp[i][j] = dp[i-1][j]\n            if j >= dollars[i-1]:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-dollars[i-1]] + dollars[i-1]*d)\n            if j >= euro[i-len(dollars)-1]:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-euro[i-len(dollars)-1]] + euro[i-len(dollars)-1]*e)\n    return dp[-1][-1]"
    },
    {
        "number": 3796,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    nums = list(map(int, stdin.readline().strip().split()))\n    nums.sort()\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                dp[j][i] = True\n    for i in range(n):\n        for j in range(i):\n            if dp[j][i]:\n                for k in range(j, i):\n                    dp[j][k] = True\n                    dp[k+1][i] = True\n    for i in range(n):\n        if dp[i][i]:\n            for j in range(i+1, n):\n                if dp[i][j]:\n                    p = j - i + 1\n                    q = n // p\n                    if q * p == n:\n                        ans = []\n                        for k in range(i, j+1):\n                            ans.append(nums[k])\n                        ans = [ans[i:i+q] for i in range(0, len(ans), q)]\n                        return str(p) + '\\n' + '\\n'.join([' '.join(map(str, row)) for row in ans])\n    return '0\\n0 0'"
    },
    {
        "number": 3797,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.readline().split())\n    conditions = []\n    for _ in range(M):\n        l, r, x = map(int, stdin.readline().split())\n        conditions.append((l-1, r-1, x))\n\n    # count number of ways to paint squares\n    MOD = 10**9+7\n    dp = [[[0]*3 for _ in range(N)] for _ in range(N)]\n    dp[0][0][0] = 1\n    for i in range(N):\n        for j in range(N):\n            for k in range(3):\n                for l, r, x in conditions:\n                    if i >= l and i < r:\n                        dp[i][j][k] = (dp[i][j][k] + dp[l][j][(k+1)%3]) % MOD\n                        dp[i][j][k] = (dp[i][j][k] + dp[l][j][(k-1)%3]) % MOD\n\n    # count total number of ways to paint squares\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            count = (count + dp[i][j][0] + dp[i][j][1] + dp[i][j][2]) % MOD\n\n    return str(count)"
    },
    {
        "number": 3798,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    for b in range(2, n+1):\n        if s == f(b, n):\n            return str(b)\n    return \"-1\"\n\ndef"
    },
    {
        "number": 3799,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if s[0] == s[-1]:\n        return \"Second\"\n    for i in range(1, len(s)-1):\n        if s[i]!= s[i-1] and s[i]!= s[i+1]:\n            return \"First\"\n    return \"Second\""
    },
    {
        "number": 3800,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, s = map(int, stdin.split())\n    b = [[int(s[i]*s[j]) for j in range(len(s))] for i in range(len(s))]\n    count = 0\n    for i in range(len(s)):\n        for j in range(len(s)):\n            for k in range(i, len(s)):\n                for l in range(j, len(s)):\n                    if sum(b[x][y] for x in range(i, k+1) for y in range(j, l+1)) == a:\n                        count += 1\n    return str(count)"
    },
    {
        "number": 3801,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    w = list(map(int, stdin.split()[2+n:]))\n    p = [0] * n\n    q = [0] * n\n    for i in range(n):\n        if a[i] == 1:\n            p[i] = w[i]\n            q[i] = 1\n        else:\n            p[i] = 1\n            q[i] = w[i]\n    for i in range(m):\n        for j in range(n):\n            if a[j] == 1:\n                p[j] += 1\n            else:\n                q[j] += 1\n    r = [0] * n\n    for i in range(n):\n        r[i] = pow(p[i], 2, 998244353) * pow(q[i], 2, 998244353) % 998244353\n    return '\\n'.join(map(str, r))"
    },
    {
        "number": 3802,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2, virus = stdin.split('\\n')\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s1[i-1] == s2[j-1] and s1[i-1]!= virus:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    lcs = ''\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i-1] == s2[j-1] and s1[i-1]!= virus:\n            lcs = s1[i-1] + lcs\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    return lcs or '0'"
    },
    {
        "number": 3803,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    hp_y, atk_y, def_y = map(int, stdin.readline().strip().split())\n    hp_m, atk_m, def_m = map(int, stdin.readline().strip().split())\n    h, a, d = map(int, stdin.readline().strip().split())\n\n    # calculate minimum coins needed to win\n    coins_needed = 0\n    while hp_m > 0 and hp_y > 0:\n        hp_y = max(0, hp_y - max(0, atk_y - def_m))\n        hp_m = max(0, hp_m - max(0, atk_m - def_y))\n        coins_needed += h * (hp_y + hp_m)\n\n    # return result\n    return str(coins_needed)"
    },
    {
        "number": 3804,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if (i ^ (i + 1)) * (i ^ (i + 2)) * (i ^ (i + 3)) * (i ^ (i + 4)) * (i ^ (i + 5)) * (i ^ (i + 6)) * (i ^ (i + 7)) * (i ^ (i + 8)) * (i ^ (i + 9)) * (i ^ (i + 10)) * (i ^ (i + 11)) * (i ^ (i + 12)) * (i ^ (i + 13)) * (i ^ (i + 14)) * (i ^ (i + 15)) * (i ^ (i + 16)) * (i ^ (i + 17)) * (i ^ (i + 18)) * (i ^ (i + 19)) * (i ^ (i + 20)) * (i ^ (i + 21)) * (i ^ (i + 22)) * (i ^ (i + 23)) * (i ^ (i + 24)) * (i ^ (i + 25)) * (i ^ (i + 26)) * (i ^ (i + 27)) * (i ^ (i + 28)) * (i ^ (i + 29)) * (i ^ (i + 30)) * (i ^ (i + 31)) * (i ^ (i + 32)) * (i ^ (i + 33)) * (i ^ (i + 34)) * (i ^ (i + 35)) * (i ^ (i + 36)) * (i ^ (i + 37)) * (i ^ (i + 38)) * (i ^ (i + 39)) * (i ^ (i + 40)) * (i ^ (i + 41)) * (i ^ (i + 42)) * (i ^ (i + 43)) * (i ^ (i + 44)) * (i ^ (i + 45)) * (i ^ (i + 46)) * (i ^ (i + 47)) * (i ^ (i + 48)) * (i ^ (i + 49)) * (i ^ (i + 50)) * (i ^ (i + 51)) * (i ^ (i + 52)) * (i ^ (i + 53)) * (i ^ (i + 54)) * (i ^ (i + 55)) * (i ^ (i + 56)) * (i ^ (i + 57)) * (i ^ (i + 58)) * (i ^ (i + 59)) * (i ^ (i + 60)) * (i ^ (i + 61)) * (i ^ (i + 62)) * (i ^ (i + 63)) * (i ^ (i + 64)) * (i ^ (i + 65)) * (i ^ (i + 66)) * (i ^ (i + 67)) * (i ^ (i + 68)) * (i ^ (i + 69)) * (i ^ (i + 70)) * (i ^ (i + 71)) * (i ^ (i + 72)) * (i ^ (i + 73)) * (i ^ (i + 74)) * (i ^ (i + 75)) * (i ^ (i + 76)) * (i ^ (i + 77)) * (i ^ (i + 78)) * (i ^ (i + 79)) * (i ^ (i + 80)) * (i ^ (i + 81)) * (i ^ (i + 82)) * (i ^ (i + 83)) * (i ^ (i + 84)) * (i ^ (i + 85)) * (i ^ (i + 86)) * (i ^ (i + 87)) * (i ^ (i + 88)) * (i ^ (i + 89)) * (i ^ (i + 90)) * (i ^ (i + 91))"
    },
    {
        "number": 3805,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    wires = stdin.strip()\n    n = len(wires)\n    if n % 2 == 1:\n        return \"No\"\n    plus_count = wires.count(\"+\")\n    minus_count = wires.count(\"-\")\n    if plus_count!= minus_count:\n        return \"No\"\n    if wires.count(\"++\") > 0 or wires.count(\"--\") > 0:\n        return \"No\"\n    return \"Yes\""
    },
    {
        "number": 3806,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().split())\n        points.append((x, y))\n    cx, cy = x, y\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += (points[i][0] * points[j][1] - points[j][0] * points[i][1]) / 2\n    return str(abs(area))"
    },
    {
        "number": 3807,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    blocks = []\n    volume = 0\n    while volume < m:\n        blocks.append(m)\n        volume += m\n        m -= 1\n    return len(blocks), volume"
    },
    {
        "number": 3808,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    if s == \"()\":\n        return \"Yes\"\n    if s[0] == \"(\" and s[-1] == \")\":\n        return \"Yes\" if n == 2 else \"No\"\n    if s[0] == \")\":\n        return \"Yes\" if n == 1 else \"No\"\n    if s[-1] == \"(\":\n        return \"Yes\" if n == 1 else \"No\"\n    return \"No\""
    },
    {
        "number": 3809,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    weights = list(map(int, stdin.split()))\n    if k < 50*n:\n        return -1, 0\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            if j < weights[i-1]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] + dp[i-1][j-weights[i-1]]\n    if dp[n][k] == 0:\n        return -1, 0\n    else:\n        return dp[n][k], dp[n][k] % (10**9 + 7)"
    },
    {
        "number": 3810,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] % a[j] == 0:\n                dp[i][j] = 1\n                dp[j][i] = 1\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dp[i][k] and dp[k][j]:\n                    dp[i][j] = (dp[i][j] + dp[i][k] * dp[k][j]) % MOD\n    ans = 0\n    for i in range(n):\n        ans = (ans + dp[i][i]) % MOD\n    return str(ans)"
    },
    {
        "number": 3811,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pairs = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        pairs.append((a, b))\n    gcd = pairs[0][1]\n    for i in range(1, n):\n        gcd = math.gcd(gcd, pairs[i][1])\n    if gcd == 1:\n        return \"-1\"\n    return str(gcd)\n\nimport math\n\nstdin = \"\"\"\n3\n17 18\n15 24\n12 15\n\"\"\"\n\nprint(solution(stdin)) # Output: 6\n\nstdin = \"\"\"\n2\n10 16\n7 17\n\"\"\"\n\nprint(solution(stdin)) # Output: -1\n\nstdin = \"\"\"\n5\n90 108\n45 105\n75 40\n165 175\n33 30\n\"\"\"\n\nprint(solution(stdin)) # Output: 5"
    },
    {
        "number": 3812,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.strip().split()\n    n = 0\n    while s!= s.replace('a', '') or t!= t.replace('b', ''):\n        n += 1\n        if s.startswith('a'):\n            a = s.index('a')\n            s = s[a+1:] + s[:a]\n        else:\n            a = 0\n        if t.startswith('b'):\n            b = t.index('b')\n            t = t[b+1:] + t[:b]\n        else:\n            b = 0\n        print(a, b)\n    return str(n)"
    },
    {
        "number": 3813,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    P = list(map(int, stdin.readline().strip().split()))\n    X = list(map(int, stdin.readline().strip().split()))\n\n    # Check if it is possible to allocate colors and weights\n    color = [None] * (N + 1)\n    weight = [0] * (N + 1)\n    for i in range(2, N + 1):\n        if color[P[i]] is None:\n            return \"IMPOSSIBLE\"\n        if color[P[i]] == \"white\":\n            weight[i] = weight[P[i]] + X[i]\n        else:\n            weight[i] = weight[P[i]] - X[i]\n        color[i] = \"white\" if weight[i] <= X[i] else \"black\"\n    return \"POSSIBLE\""
    },
    {
        "number": 3814,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dp = [[0] * (1 << n) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, 1 << n):\n            dp[i][j] = dp[i - 1][j]\n            if j & (1 << (i - 1)):\n                dp[i][j] += dp[i - 1][j ^ (1 << (i - 1))]\n            dp[i][j] %= m\n    return str(dp[n][(1 << n) - 1])"
    },
    {
        "number": 3815,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    s = [1 if c == '+' else -1 for c in s]\n    res = 0\n    for i in range(k):\n        res += s[i] * a**(n - i) * b**i\n    return str(res % (10**9 + 9))"
    },
    {
        "number": 3816,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, l = map(int, stdin.split())\n    if a + b <= c or a + c <= b or b + c <= a:\n        return 0\n    if l == 0:\n        return 1\n    if l < a + b + c:\n        return 0\n    if l == a + b + c:\n        return 1\n    if l % 2 == 1:\n        return 0\n    l //= 2\n    if l < a + b:\n        return 0\n    if l == a + b:\n        return 1\n    if l == a + b + c:\n        return 1\n    if l % 2 == 1:\n        return 0\n    l //= 2\n    if l < c:\n        return 0\n    if l == c:\n        return 1\n    return 0"
    },
    {
        "number": 3817,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 1000000009\n    count = 0\n    for i in range(2**m):\n        xor_sum = 0\n        for j in range(n):\n            xor_sum ^= (i >> j) & 1\n        if xor_sum == 0:\n            continue\n        for j in range(n):\n            if (i >> j) & 1 == 1:\n                count += 1\n                count %= MOD\n    return str(count)"
    },
    {
        "number": 3818,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    edges = []\n    for i in range(N-1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    # Compute distances between vertices\n    dist = [[0] * N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n    for a, b in edges:\n        dist[a-1][b-1] = 1\n        dist[b-1][a-1] = 1\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                dist[i][j] = max(dist[i][j], dist[i][k] + dist[k][j])\n\n    # Compute maximum distances between white and black vertices\n    max_white = 0\n    max_black = 0\n    for i in range(N):\n        for j in range(N):\n            if dist[i][j] > 0:\n                max_white = max(max_white, dist[i][j])\n            elif dist[i][j] < 0:\n                max_black = max(max_black, -dist[i][j])\n\n    # Compute sum of nicenesses\n    ans = 0\n    for mask in range(2**N):\n        white_dist = 0\n        black_dist = 0\n        for i in range(N):\n            if mask & (1 << i):\n                white_dist += dist[i][i]\n            else:\n                black_dist += dist[i][i]\n        ans = (ans + max(max_white, max_black)) % (10**9+7)\n\n    return str(ans)"
    },
    {
        "number": 3819,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    b = list(map(int, stdin.split('\\n')[2].split()))\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if b[i] == 0:\n            count += 1\n            continue\n        if a[i] > b[i]:\n            count += 1\n            a[i], b[i] = b[i], a[i]\n    return count"
    },
    {
        "number": 3820,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if s == t:\n        return \"YES\"\n\n    if '*' not in s:\n        return \"NO\"\n\n    for i in range(n):\n        if s[i] == '*':\n            for j in range(26):\n                new_s = s[:i] + chr(ord('a') + j) + s[i+1:]\n                if new_s == t:\n                    return \"YES\"\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 3821,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(float, stdin.readline().strip().split()))\n    p.sort(reverse=True)\n    ans = 1\n    for i in range(n):\n        ans *= (1 - p[i])\n    return str(ans)"
    },
    {
        "number": 3822,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, v_1, v_2, k = map(int, stdin.split())\n    bus_time = l / v_2\n    pupil_time = bus_time / k\n    total_time = bus_time + pupil_time * n\n    return str(total_time)"
    },
    {
        "number": 3823,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(float, stdin.split()[1:]))\n    diff = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            a[i] = round(a[i])\n            a[j] = round(a[j])\n            diff = min(diff, abs(sum(a[:i]) - sum(a[:j])))\n    return f\"{diff:.3f}\""
    },
    {
        "number": 3824,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1 = map(int, stdin.split())\n    x_2, y_2 = map(int, stdin.readline().split())\n    return str(abs(x_1 - x_2) + abs(y_1 - y_2) + 2)"
    },
    {
        "number": 3825,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        count += 10**(n-i) * roman_to_int(i)\n    return count\n\ndef"
    },
    {
        "number": 3826,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                count += 1\n    if count == 0:\n        return \"0\"\n    else:\n        return str(count)"
    },
    {
        "number": 3827,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    a_count = s.count('a')\n    b_count = s.count('b')\n    c_count = s.count('c')\n    if a_count == 0 or b_count == 0 or c_count == 0:\n        return \"NO\"\n    if a_count == c_count or b_count == c_count:\n        return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3828,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n):\n        if p[i]!= i+1:\n            count += 1\n            if p[i] > i+1:\n                p[i], p[i-1] = p[i-1], p[i]\n            else:\n                p[i], p[i+1] = p[i+1], p[i]\n    return count"
    },
    {
        "number": 3829,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    expected_max = (m * (m + 1)) / 2\n    return str(expected_max)"
    },
    {
        "number": 3830,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for i in range(t):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n        clockwise = [False] * n\n        anticlockwise = [False] * n\n        for j in range(n):\n            if s[j] == '>':\n                clockwise[j] = True\n            elif s[j] == '<':\n                anticlockwise[j] = True\n        count = 0\n        for j in range(n):\n            if clockwise[j] or anticlockwise[(j+1)%n]:\n                count += 1\n        print(count)"
    },
    {
        "number": 3831,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    parts = []\n    for i in range(n):\n        s, g = map(int, stdin.readline().strip().split())\n        parts.append((s, g))\n    parts.sort(key=lambda x: x[0])\n    if parts[0][0] > 1:\n        return \"-1\"\n    for i in range(1, n):\n        if parts[i][0] - parts[i-1][0] > 1:\n            return \"-1\"\n    lawns = sum(g for s, g in parts)\n    if lawns == 0:\n        return \"0\"\n    s_prime = [parts[0][0]]\n    for i in range(1, n):\n        s_prime.append(max(s_prime[i-1] + parts[i][1] - parts[i][0], parts[i][0]))\n    return str(lawns) + \"\\n\" + \" \".join(map(str, s_prime))"
    },
    {
        "number": 3832,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    k = n // 2 + n % 2\n    ans = []\n    for i in range(1, k+1):\n        cnt = 0\n        for j in range(n):\n            if a[j] >= i:\n                cnt += 1\n        ans.append(cnt)\n    return''.join(map(str, ans))"
    },
    {
        "number": 3833,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()[0]\n    t = stdin.split()[1]\n    n = len(s)\n    m = len(t)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = 1\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[j-1] == t[i-1]:\n                dp[i][j] = dp[i-1][j-1] + dp[i][j-1]\n            else:\n                dp[i][j] = dp[i][j-1]\n    ans = \"\"\n    i = m\n    j = n\n    while i > 0 and j > 0:\n        if s[j-1] == t[i-1]:\n            ans += s[j-1]\n            i -= 1\n            j -= 1\n        elif dp[i-1][j] > dp[i][j-1]:\n            i -= 1\n        else:\n            j -= 1\n    while i > 0:\n        ans += \"0\"\n        i -= 1\n    while j > 0:\n        ans += \"1\"\n        j -= 1\n    return ans[::-1]"
    },
    {
        "number": 3834,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, stdin.readline().split())))\n    visited = [[False for j in range(m)] for i in range(n)]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if not visited[i][j] and a[i][j] == 1:\n                count += 1\n                stack = [(i, j)]\n                visited[i][j] = True\n                while stack:\n                    x, y = stack.pop()\n                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and a[nx][ny] == a[x][y]:\n                            stack.append((nx, ny))\n                            visited[nx][ny] = True\n    if count < k:\n        return \"-1\"\n    else:\n        return str(count - k)"
    },
    {
        "number": 3835,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    table = []\n    for i in range(n):\n        row = list(map(int, stdin.readline().strip().split()))\n        table.append(row)\n    for i in range(n):\n        table[i][i] = 0\n    a = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if table[i][j]!= 0:\n                a[i] = table[i][j]\n                break\n    return''.join(map(str, a))"
    },
    {
        "number": 3836,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    views = []\n    for i in range(n):\n        s, a = stdin.readline().strip().split()\n        views.append((s, int(a)))\n    a = sum(1 for s, a in views if s[0] == '1' and s[1] == '1')\n    b = sum(1 for s, a in views if s[0] == '0' and s[1] == '0')\n    if 2*a < n or 2*b < n:\n        return '0'\n    return str(max(a, b)*n)"
    },
    {
        "number": 3837,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    # Check if the university can't correct all bugs\n    if sum(c) > s:\n        return \"NO\"\n\n    # Create a graph where each node represents a bug and each edge represents a dependency between bugs\n    graph = [[] for _ in range(m)]\n    for i in range(m):\n        for j in range(i+1, m):\n            if a[i] > a[j]:\n                graph[i].append(j)\n\n    # Create a list of available students for each bug\n    available = [[] for _ in range(m)]\n    for i in range(n):\n        for j in range(m):\n            if b[i] >= a[j]:\n                available[j].append(i)\n\n    # Create a list of fixed bugs for each student\n    fixed = [[] for _ in range(n)]\n\n    # Create a list of passes for each student\n    passes = [0] * n\n\n    # Create a list of days for each student\n    days = [0] * n\n\n    # Create a list of days for each bug\n    bug_days = [0] * m\n\n    # Create a list of days for each student to fix all bugs\n    total_days = 0\n\n    # Use a DFS algorithm to find an optimal solution\n    def dfs(bug):\n        nonlocal total_days\n        if bug_days[bug] == 0:\n            for student in available[bug]:\n                if passes[student] + c[student] <= s:\n                    fixed[student].append(bug)\n                    passes[student] += c[student]\n                    days[student] += 1\n                    bug_days[bug] = days[student]\n                    dfs(bug)\n                    fixed[student].pop()\n                    passes[student] -= c[student]\n                    days[student] -= 1\n                    bug_days[bug] = 0\n\n    # Find an optimal solution\n    for bug in range(m):\n        if not available[bug]:\n            continue\n        dfs(bug)\n        total_days = max(total_days, bug_days[bug])\n\n    # Check if the university can't correct all bugs\n    if sum(passes) > s:\n        return \"NO\"\n\n    # Output the result\n    if total_days == 0:\n        return \"NO\"\n    else:\n        result = \"YES\\n\"\n        for student in fixed:\n            result += \" \".join(map(str, student)) + \"\\n\"\n        return result"
    },
    {
        "number": 3838,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    q = list(map(int, stdin.split()[2:2+n]))\n    s = list(map(int, stdin.split()[2+n:]))\n    if q == s:\n        return \"NO\"\n    for i in range(k):\n        if i % 2 == 0:\n            q = [q[s[i]-1] for i in range(n)]\n        else:\n            q = [s[q[i]-1] for i in range(n)]\n    if q == s:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3839,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = [[0] * 8 for _ in range(8)]\n    for i in range(n):\n        board[i][i] = 1\n    k = 0\n    while True:\n        free_cells = []\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 0:\n                    count = 0\n                    for dx, dy in [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]:\n                        x, y = i + dx, j + dy\n                        if 0 <= x < 8 and 0 <= y < 8 and board[x][y] == 1:\n                            count += 1\n                    if count >= 4:\n                        free_cells.append((i, j))\n        if not free_cells:\n            break\n        k += 1\n        i, j = free_cells[0]\n        board[i][j] = k\n    result = []\n    for i in range(n):\n        result.append(f\"{i+1} {i+1}\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3840,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        dp[i][i] = a[i-1]\n    for i in range(n-1, 0, -1):\n        for j in range(i+1, n+1):\n            dp[i][j] = float('inf')\n            for k in range(i, j, 2):\n                if dp[i][k]!= float('inf') and dp[k+1][j]!= float('inf'):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    if dp[1][n] == float('inf'):\n        return -1\n    else:\n        return dp[1][n]"
    },
    {
        "number": 3841,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    if k % 2 == 0:\n        return \"-1\"\n    d = (k - 1) // 2\n    a = [0] * d\n    a[0] = 1\n    for i in range(1, d):\n        a[i] = a[i-1] * (p - i) % k\n    a[-1] = (p - d) * a[-1] % k\n    return f\"{d}\\n{' '.join(map(str, a))}\""
    },
    {
        "number": 3842,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.readline().split())\n    a = []\n    b = []\n    for i in range(n):\n        ai, bi = map(int, stdin.readline().split())\n        a.append(ai)\n        b.append(bi)\n    dp = [0] * (p + 1)\n    for i in range(n):\n        for j in range(p, -1, -1):\n            if j >= a[i]:\n                dp[j] = max(dp[j], dp[j - a[i]] + b[i])\n    return str(dp[p])"
    },
    {
        "number": 3843,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        for j in range(m+1):\n            if len(set(str(i))) == len(str(i)) and len(set(str(j))) == len(str(j)):\n                count += 1\n    return str(count)"
    },
    {
        "number": 3844,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = list(map(int, stdin.readline().strip().split()))\n    cards.sort()\n    i = 0\n    j = n - 1\n    while i < j:\n        if cards[i] > cards[j]:\n            return \"Conan\"\n        i += 1\n        j -= 1\n    return \"Agasa\""
    },
    {
        "number": 3845,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    h = 2*A + 1\n    w = 2*B + 1\n    grid = [['.' for _ in range(w)] for _ in range(h)]\n    for i in range(A):\n        for j in range(B):\n            grid[2*i+1][2*j+1] = '#'\n            grid[2*i+2][2*j+1] = '#'\n            grid[2*i+1][2*j+2] = '#'\n            grid[2*i+2][2*j+2] = '#'\n    for i in range(h):\n        print(''.join(grid[i]))\n    return f\"{h} {w}\\n\" + '\\n'.join([''.join(grid[i]) for i in range(h)])"
    },
    {
        "number": 3846,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    messages = stdin.split('\\n')[1:]\n    leaders = set()\n    for message in messages:\n        if message[0] == '+':\n            leaders.add(int(message.split()[1]))\n        else:\n            leaders.discard(int(message.split()[1]))\n    if not leaders:\n        return '0'\n    return''.join(map(str, sorted(leaders)))"
    },
    {
        "number": 3847,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    x = int(stdin.readline())\n\n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    if sum(c[i][j:l+1]) + sum(c[k+1][j:l+1]) + sum(c[i:k+1][j]) + sum(c[i:k+1][l+1]) <= x:\n                        area = (k-i+1) * (l-j+1)\n                        if area > max_area:\n                            max_area = area\n\n    return str(max_area) if max_area > 0 else \"0\""
    },
    {
        "number": 3848,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = stdin.split()[1]\n    t = s\n    while True:\n        t = chr(ord(t[-1]) + 1) + t[:-1]\n        if len(t) == n:\n            break\n        if t[-1] not in 'abcdefghijklmnopqrstuvwxyz':\n            continue\n        if t[-2:] in s or t[-2:] in s[::-1]:\n            continue\n        if t[-1] not in 'abcdefghijklmnopqrstuvwxyz'[:p]:\n            continue\n    if t > s:\n        return t\n    else:\n        return \"NO\""
    },
    {
        "number": 3849,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = stdin.strip()\n    count_up = cards.count('1')\n    count_down = n - count_up\n    if count_up == count_down:\n        return \"once again\"\n    if count_up > count_down:\n        return \"tokitsukaze\"\n    return \"quailty\""
    },
    {
        "number": 3850,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    a.sort()\n    b.sort()\n    dp = [float('inf')] * (p+1)\n    dp[0] = 0\n    for i in range(n):\n        for j in range(k):\n            if a[i] <= b[j]:\n                dp[b[j]] = min(dp[b[j]], dp[a[i]] + abs(a[i]-b[j]))\n    return dp[p]"
    },
    {
        "number": 3851,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a, b = map(int, stdin.readline().split())\n    x = 1\n    y = n * k\n    if a == 0:\n        x = 0\n    elif a <= k:\n        x = 1\n    else:\n        x = a // k + 1\n    if b == 0:\n        y = 0\n    elif b <= k:\n        y = 1\n    else:\n        y = b // k + 1\n    return f\"{x} {y}\""
    },
    {
        "number": 3852,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    m = 0\n    while m < 2*N and not all(a[i] <= a[i+1] for i in range(N-1)):\n        # Find the smallest x and y such that a[x-1] + a[y-1] < a[x] + a[y]\n        x, y = 1, 2\n        while x < y and a[x-1] + a[y-1] >= a[x] + a[y]:\n            y += 1\n        # Perform the operation\n        a[x-1] += a[y-1]\n        m += 1\n        # Print the operation\n        print(m)\n        print(f\"{x} {y}\")\n\n    # Print the final sequence\n    print(\" \".join(map(str, a)))\n\n    return \"\""
    },
    {
        "number": 3853,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    boxes = []\n    for i in range(n):\n        k, a = map(int, stdin.readline().strip().split())\n        boxes.append((k, a))\n    boxes.sort(key=lambda x: x[0])\n    p = 0\n    for k, a in boxes:\n        if a > 2**(p+1):\n            p += 1\n    return p"
    },
    {
        "number": 3854,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    coins = list(map(int, stdin.split()))\n    coins.sort()\n    q = 0\n    for i in range(n):\n        if coins[i] > k:\n            break\n        q += 1\n    if q == 0:\n        return \"0\"\n    else:\n        values = []\n        for i in range(q):\n            values.append(coins[i])\n        for i in range(q, n):\n            if coins[i] > k:\n                break\n            values.append(coins[i])\n        return str(q) + \"\\n\" + \" \".join(map(str, values))"
    },
    {
        "number": 3855,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    dp = [0] * (n+1)\n    dp[0] = 0\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n+1):\n        dp[i] = min(dp[i-1], dp[i-2], dp[i-3]) + 1\n    return dp[n]"
    },
    {
        "number": 3856,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    w = [int(stdin.readline().strip()) for _ in range(n)]\n    h = [int(stdin.readline().strip()) for _ in range(n)]\n    max_h = max(h)\n    min_area = 0\n    for i in range(n):\n        if h[i] == max_h:\n            min_area += w[i] * h[i]\n        else:\n            min_area += w[i] * max_h\n    return str(min_area)"
    },
    {
        "number": 3857,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    piles = 0\n    top = 0\n    for i in range(n):\n        if top + x[i] > i + 1:\n            piles += 1\n            top = i + 1\n    return piles + 1"
    },
    {
        "number": 3858,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.sort()\n    hull = []\n    for i in range(2):\n        hull.append(points[i])\n        j = i + 1\n        while j < n and (points[j][0] - points[i][0])*(points[j][1] + points[i][1]) >= (points[j][0] + points[i][0])*(points[j][1] - points[i][1]):\n            j += 1\n        hull.append(points[j-1])\n        i = j - 1\n    hull.sort()\n    score = 1\n    for i in range(len(hull)-1):\n        score *= 2\n    return str((score % 998244353) + sum(2**(n-len(set(points) & set(hull))) for points in itertools.combinations(points, len(hull))))\n\nimport itertools"
    },
    {
        "number": 3859,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    balls = []\n    for i in range(n):\n        c, a = stdin.readline().strip().split()\n        balls.append((c, int(a)))\n    balls.sort(key=lambda x: x[1])\n    white_balls = [ball for ball in balls if ball[0] == 'W']\n    black_balls = [ball for ball in balls if ball[0] == 'B']\n    operations = 0\n    for i in range(n-1):\n        if white_balls[i][1] > white_balls[i+1][1]:\n            operations += 1\n            white_balls[i], white_balls[i+1] = white_balls[i+1], white_balls[i]\n        if black_balls[i][1] > black_balls[i+1][1]:\n            operations += 1\n            black_balls[i], black_balls[i+1] = black_balls[i+1], black_balls[i]\n    return str(operations)"
    },
    {
        "number": 3860,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, g, n = map(int, stdin.split())\n    if b + g < n:\n        return \"impossible\"\n    if b == 0:\n        return n\n    if g == 0:\n        return n\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n    if n == 45:\n        return 45\n    if n == 46:\n        return 46\n    if n == 47:\n        return 47\n    if n == 48:\n        return 48\n    if n == 49:\n        return 49\n    if n == 50:\n        return 50\n    if n == 51:\n        return 51\n    if n == 52:\n        return 52\n    if n == 53:\n        return 53\n    if n == 54:\n        return 54\n    if n == 55:\n        return 55\n    if n == 56:\n        return 56\n    if n == 57:\n        return 57\n    if n == 58:\n        return 58\n    if n == 59:\n        return 59\n    if n == 60:\n        return 60\n    if n == 61:\n        return 61\n    if n == 62:\n        return 62\n    if n == 63:\n        return 63\n    if n == 64:\n        return 64\n    if n == 65:\n        return 65\n    if n == 66:\n        return 66\n    if n == 67:\n        return 67\n    if n == 68:\n        return 68\n    if n == 69:\n        return 69\n    if n == 70:\n        return 70\n    if n == 71:\n        return 71\n    if n == 72:\n        return 72\n    if n == 73:\n        return 73\n    if n == 74:\n        return 74\n    if n == 75:\n        return 75\n    if n == 76:\n        return 76\n    if n == "
    },
    {
        "number": 3861,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    max_num = -1\n    for num in a:\n        if num > max_num and num!= int(num**0.5)**2:\n            max_num = num\n    return str(max_num)"
    },
    {
        "number": 3862,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort()\n    if n < a[0]:\n        return '-1'\n    if n == a[0]:\n        return '1'\n    for i in range(1, k):\n        if a[i] > n:\n            return str(n // a[i])\n    return '-1'"
    },
    {
        "number": 3863,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K = map(int, stdin.split())\n\n    # count number of sequences\n    count = 1\n    for i in range(1, N):\n        count = (count * (K - i + 1)) % (10**9 + 7)\n\n    # multiply by number of permutations of first N elements\n    count = (count * factorial(N)) % (10**9 + 7)\n\n    # multiply by number of permutations of first N elements in reverse order\n    count = (count * factorial(N)) % (10**9 + 7)\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3864,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 998244353\n    dp = [[0]*(n+1) for _ in range(n+1)]\n    dp[1][1] = 1\n    dp[2][1] = 1\n    dp[2][2] = 1\n    for i in range(3, n+1):\n        dp[i][1] = dp[i-1][1] + dp[i-2][1]\n        dp[i][i] = dp[i-1][i-1] + dp[i-2][i-2]\n        for j in range(2, i):\n            dp[i][j] = dp[i-1][j-1] + dp[i-2][j-2] + dp[i-1][j] + dp[i-2][j]\n    ans = []\n    for i in range(1, n+1):\n        ans.append((dp[n][i] + dp[n-1][i] + dp[n-2][i]) % MOD)\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3865,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    n = 1\n    while True:\n        if sum(int(digit) for digit in str(n)) <= a*len(str(n)):\n            return str(n)\n        n += 1\n    return \"-1\""
    },
    {
        "number": 3866,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    if n == 1:\n        return \"-1\"\n    for a in permutations(range(n)):\n        for b in permutations(range(n)):\n            for c in permutations(range(n)):\n                if all(a[i] + b[i] == c[i] for i in range(n)):\n                    return \"\\n\".join(map(str, a)) + \"\\n\" + \"\\n\".join(map(str, b)) + \"\\n\" + \"\\n\".join(map(str, c))\n    return \"-1\""
    },
    {
        "number": 3867,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = [tuple(map(int, line.strip().split())) for line in stdin.readlines()]\n    sequence = list(map(int, stdin.readline().strip().split()))\n    if len(sequence)!= n:\n        return \"No\"\n    visited = [False] * (n + 1)\n    queue = [1]\n    visited[1] = True\n    while queue:\n        vertex = queue.pop(0)\n        if vertex!= sequence[0]:\n            return \"No\"\n        sequence.pop(0)\n        for neighbor in [u for u, v in edges if v == vertex]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return \"Yes\""
    },
    {
        "number": 3868,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    flights = []\n    for i in range(m):\n        d, f, t, c = map(int, stdin.split())\n        flights.append((d, f, t, c))\n    flights.sort()\n    dp = [[float('inf')] * (n+1) for _ in range(k+1)]\n    dp[0][0] = 0\n    for i in range(k+1):\n        for j in range(n+1):\n            for d, f, t, c in flights:\n                if f == j:\n                    dp[i][j] = min(dp[i][j], dp[i][d-1] + c)\n                if t == j:\n                    dp[i][j] = min(dp[i][j], dp[i][d-1] + c)\n            if i > 0 and j > 0:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1])\n    if dp[k][n] == float('inf'):\n        return '-1'\n    return str(dp[k][n])"
    },
    {
        "number": 3869,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, alpha = map(int, stdin.split())\n    alpha = alpha * 3.141592653589793 / 180\n    area = w * h / 2\n    area_rotated = area * (abs(math.cos(alpha)) + abs(math.sin(alpha))) / 2\n    return str(area_rotated)"
    },
    {
        "number": 3870,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    jiro_cards = []\n    ciel_cards = []\n    for i in range(n):\n        position, strength = stdin.split()\n        jiro_cards.append((position, int(strength)))\n    for i in range(m):\n        strength = stdin.split()\n        ciel_cards.append(int(strength))\n    jiro_damage = 0\n    ciel_damage = 0\n    for ciel_card in ciel_cards:\n        if not jiro_cards:\n            jiro_damage += ciel_card\n            continue\n        jiro_card = jiro_cards.pop(0)\n        if jiro_card[0] == \"ATK\":\n            if ciel_card >= jiro_card[1]:\n                jiro_damage += ciel_card - jiro_card[1]\n            else:\n                jiro_damage += ciel_card\n        else:\n            if ciel_card > jiro_card[1]:\n                jiro_damage += ciel_card - jiro_card[1]\n    return jiro_damage"
    },
    {
        "number": 3871,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    l = list(map(int, stdin.readline().split()))\n    s = list(map(int, stdin.readline().split()))\n    c = list(map(int, stdin.readline().split()))\n\n    dp = [[0] * (m+1) for _ in range(n+1)]\n\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if l[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j-l[i-1]] + c[l[i-1]-1])\n\n    return str(dp[n][m])"
    },
    {
        "number": 3872,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if a == b:\n        return \"YES\"\n    if len(a) % 2 == 0:\n        a1, a2 = a[:len(a)//2], a[len(a)//2:]\n        b1, b2 = b[:len(b)//2], b[len(b)//2:]\n        if a1 == b1 and a2 == b2:\n            return \"YES\"\n        elif a1 == b2 and a2 == b1:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3873,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    if n == 1:\n        return \"YES\\n1 1\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3874,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    files = stdin.split('\\n')[0:n]\n    indices = list(map(int, stdin.split('\\n')[n+1:]))\n    patterns = []\n    for i in range(2**n):\n        pattern = ''\n        for j in range(n):\n            if i & (1 << j):\n                pattern += '?'\n            else:\n                pattern += files[j][indices[j]-1]\n        patterns.append(pattern)\n    for pattern in patterns:\n        if all(pattern in file for file in files) and all(pattern not in file for file in files if files.index(file) not in indices):\n            return 'Yes\\n'+pattern\n    return 'No'"
    },
    {
        "number": 3875,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Compute expected value\n    expected_value = 0\n    for i in range(1, n+1):\n        expected_value += (i * a[i-1]) // (i+1)\n    expected_value %= 1000000007\n\n    # Compute R\n    p = expected_value * 1000000007\n    q = 1\n    for i in range(1, n+1):\n        q *= i\n        q %= 1000000007\n    r = pow(p, -1, q)\n    r %= 1000000007\n\n    # Print R\n    return str(r)"
    },
    {
        "number": 3876,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N = int(stdin.readline())\n    edges = []\n    for i in range(N - 1):\n        x, y = map(int, stdin.readline().split())\n        edges.append((x, y))\n\n    # Count number of ways to divide vertices into pairs\n    MOD = 10**9 + 7\n    pairs = N // 2\n    ways = 1\n    for i in range(1, pairs + 1):\n        ways = (ways * (pairs - i + 1)) % MOD\n        ways = (ways * i) % MOD\n    ways = (ways * 2) % MOD\n\n    # Count number of edges with at least one ribbon\n    ribbons = 0\n    for u, v in edges:\n        if u % pairs == v % pairs:\n            ribbons += 1\n    ribbons = (ribbons * ways) % MOD\n\n    # Count number of edges with no ribbon\n    no_ribbons = (N * (N - 1) // 2 - ribbons) % MOD\n\n    # Count total number of ways\n    total_ways = (ways * no_ribbons) % MOD\n\n    return str(total_ways)"
    },
    {
        "number": 3877,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    seq = [n]\n    while seq[-1] > 1:\n        x = seq.pop()\n        if x > 1:\n            seq.insert(x // 2, x % 2)\n            seq.insert(x // 2, x // 2)\n    count = sum(seq[l-1:r])\n    return str(count)"
    },
    {
        "number": 3878,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    queue = [1]\n    steps = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            u = queue.pop(0)\n            visited[u] = True\n            for v in graph[u]:\n                if not visited[v]:\n                    queue.append(v)\n                    visited[v] = True\n        steps += 1\n    print(steps)\n    print(*queue)"
    },
    {
        "number": 3879,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n        for j in range(i):\n            if a[i] == a[j]:\n                return \"No\"\n            if a[i] > a[j]:\n                b[i] = a[i] * 2\n            else:\n                b[i] = a[i] * 3\n    if b.count(b[0]) == n:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3880,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    arr.sort(reverse=True)\n    max_sum = sum(arr)\n    for i in range(n):\n        max_sum += arr[i] * -1\n    return max_sum"
    },
    {
        "number": 3881,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    operations = []\n    for i in range(q):\n        a, b = stdin.split()\n        operations.append((a, b))\n    count = 0\n    for i in range(2**n):\n        s = bin(i)[2:].zfill(n)\n        if s[0] == '0':\n            continue\n        for op in operations:\n            if s[:2] == op[0]:\n                s = s[2:] + op[1]\n        if s == 'a':\n            count += 1\n    return count"
    },
    {
        "number": 3882,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mod = 10**9 + 7\n    ans = 0\n    for i in range(1, n+1):\n        ans += (i*(i-1))//2\n    ans %= mod\n    return str(ans)"
    },
    {
        "number": 3883,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = 0\n    while True:\n        if (x * (x + 1) // 2) * a + (x * (x + 1) // 2) * b == (x * (x + 1) // 2) * (2 * x + 1):\n            return f\"{x:.9f}\"\n        x += 1\n    return \"-1\""
    },
    {
        "number": 3884,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    if n < 3:\n        return \"-1\"\n\n    # dp[i][j] - minimum mass of fuel to load into the rocket to take off from planet i and land on planet j\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n\n    # dp[i][i] = 0\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n\n    # dp[i][j] = dp[i][j-1] + dp[j][i] + a[i-1] + b[j-1]\n    for k in range(1, n):\n        for i in range(1, n - k + 2):\n            j = i + k - 1\n            for l in range(i, j + 1):\n                dp[i][j] = min(dp[i][j], dp[i][l - 1] + dp[l + 1][j] + a[i - 1] + b[j - 1])\n\n    if dp[1][n] == float('inf'):\n        return \"-1\"\n\n    return \"{:.10f}\".format(dp[1][n])"
    },
    {
        "number": 3885,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dp = [float('inf')] * (n + 1)\n    dp[1] = 0\n    for i in range(2, n + 1):\n        for j in range(1, n + 1):\n            dp[i] = min(dp[i], dp[j] + (i + j) % (n + 1))\n    return str(dp[n])"
    },
    {
        "number": 3886,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    for i in range(q):\n        n, k = map(int, stdin.readline().strip().split())\n        if n == 0:\n            print('.')\n        else:\n            f = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\n            for i in range(n-1):\n                f = \"What are you doing while sending \\\"\" + f + \"\\\"? Are you busy? Will you send \\\"\" + f + \"\\\"?\"\n            if k > len(f):\n                print('.')\n            else:\n                print(f[k-1])\n    return ''"
    },
    {
        "number": 3887,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    rebus = stdin.strip().split()\n    n = int(rebus[-1])\n    rebus = rebus[:-1]\n\n    # check if rebus has a solution\n    if n < 2 or len(rebus)!= 4:\n        return \"Impossible\"\n\n    # replace question marks with integers from 1 to n\n    for i in range(len(rebus)):\n        if rebus[i] == '?':\n            rebus[i] = str(i+1)\n\n    # check if equality holds\n    if eval(''.join(rebus))!= n:\n        return \"Impossible\"\n\n    # return solution\n    return \"Possible\\n\" +''.join(rebus) +'='+ str(n)"
    },
    {
        "number": 3888,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.readline().strip())\n    matrix = []\n    for i in range(N):\n        row = list(map(int, stdin.readline().strip().split()))\n        matrix.append(row)\n\n    # Initialize counters\n    count_0 = 0\n    count_1 = 0\n    count_2 = 0\n\n    # Iterate over matrix\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                if matrix[i][j] == 0:\n                    count_0 += 1\n                elif matrix[i][j] == 1:\n                    count_1 += 1\n                else:\n                    count_2 += 1\n            elif i == 0:\n                if matrix[i][j] == 0:\n                    count_0 += 1\n                elif matrix[i][j] == 1:\n                    count_1 += 1\n                else:\n                    count_2 += 1\n            elif j == 0:\n                if matrix[i][j] == 0:\n                    count_0 += 1\n                elif matrix[i][j] == 1:\n                    count_1 += 1\n                else:\n                    count_2 += 1\n            else:\n                mex = min(matrix[i-1][j], matrix[i][j-1])\n                if mex == 0:\n                    count_0 += 1\n                elif mex == 1:\n                    count_1 += 1\n                else:\n                    count_2 += 1\n\n    # Print counts\n    return f\"{count_0} {count_1} {count_2}\"\n"
    },
    {
        "number": 3889,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    colors = set(s)\n    if len(colors) == 1:\n        return \"Yes\"\n    for c in colors:\n        if s.count(c) >= 2:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 3890,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n    if k == 1:\n        return str(dp[n])\n    dp[1] = 0\n    for i in range(2, n + 1):\n        dp[i] = (dp[i] + dp[i - 1]) % 1000000007\n    return str(dp[n])"
    },
    {
        "number": 3891,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        table.append(list(stdin.readline().strip()))\n    black_square = None\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                black_square = (i, j)\n                break\n        if black_square is not None:\n            break\n    if black_square is None:\n        return \"No black square found\"\n    r, c = black_square\n    center = (r + 1, c + 1)\n    return \" \".join(map(str, center))"
    },
    {
        "number": 3892,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [0] * m\n    b = [0] * m\n    for i in range(m):\n        a[i], b[i] = map(int, stdin.split())\n    dp = [float('inf')] * (n+1)\n    dp[1] = 0\n    for i in range(1, n+1):\n        for j in range(m):\n            if a[j] == i:\n                dp[i] = min(dp[i], dp[a[j-1]] + 1)\n            if b[j] == i:\n                dp[i] = min(dp[i], dp[b[j-1]] + 1)\n    return''.join(map(str, dp[1:]))"
    },
    {
        "number": 3893,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    x1, y1 = map(int, stdin.readline().split())\n    x2, y2 = map(int, stdin.readline().split())\n    n = int(stdin.readline())\n    a = []\n    b = []\n    c = []\n    for i in range(n):\n        ai, bi, ci = map(int, stdin.readline().split())\n        a.append(ai)\n        b.append(bi)\n        c.append(ci)\n\n    # find the blocks containing the house and university\n    blocks = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i]*b[j] - a[j]*b[i]!= 0:\n                # the two roads intersect\n                x = (c[i]*b[j] - c[j]*b[i]) / (a[i]*b[j] - a[j]*b[i])\n                y = (c[i]*a[j] - c[j]*a[i]) / (b[i]*a[j] - b[j]*a[i])\n                if (x1-x)**2 + (y1-y)**2 < 1e-6:\n                    blocks.append((i, j))\n                if (x2-x)**2 + (y2-y)**2 < 1e-6:\n                    blocks.append((i, j))\n\n    # find the minimum number of steps to get to the university\n    steps = 0\n    visited = set()\n    queue = [(0, blocks[0])]\n    while queue:\n        step, block = queue.pop(0)\n        if block in visited:\n            continue\n        visited.add(block)\n        if block == blocks[-1]:\n            return step\n        for i in range(n):\n            if i in block:\n                continue\n            if (i, block[0]) in visited or (i, block[1]) in visited:\n                continue\n            if a[i]*b[block[0]] - a[block[0]]*b[i]!= 0 and a[i]*b[block[1]] - a[block[1]]*b[i]!= 0:\n                # the two roads intersect\n                x = (c[i]*b[block[0]] - c[block[0]]*b[i]) / (a[i]*b[block[0]] - a[block[0]]*b[i])\n                y = (c[i]*a[block[0]] - c[block[0]]*a[i]) / (b[i]*a[block[0]] - b[block[0]]*a[i])\n                if (x2-x)**2 + (y2-y)**2 < 1e-6:\n                    queue.append((step+1, (i, block[0])))\n                    queue.append((step+1, (i, block[1])))"
    },
    {
        "number": 3894,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    if sum(a) % 2 == 1:\n        return \"Kevin\"\n    else:\n        for i in range(n):\n            if a[i] % 2 == 0:\n                a[i] //= 2\n                a += [k] * a[i]\n        return \"Nicky\""
    },
    {
        "number": 3895,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    f = list(map(int, stdin.split()[1:]))\n    for i in range(n):\n        if f[i] < 1 or f[i] > n:\n            return \"-1\"\n    for i in range(1, n+1):\n        if i not in f:\n            return \"-1\"\n    for i in range(1, n+1):\n        if f.count(i) > 1:\n            return \"-1\"\n    for i in range(1, n+1):\n        if f.count(i) == 0:\n            return \"-1\"\n    for i in range(1, n+1):\n        if f.count(i) == 1:\n            m = i\n            break\n    g = [0] * n\n    h = [0] * m\n    for i in range(n):\n        g[i] = f.index(i+1) + 1\n    for i in range(m):\n        h[i] = g.index(i+1) + 1\n    return str(m) + \"\\n\" + \" \".join(map(str, g)) + \"\\n\" + \" \".join(map(str, h))"
    },
    {
        "number": 3896,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    x = int(stdin, 2)\n    MOD = 10**9 + 7\n    dp = [[0] * (1 << n) for _ in range(1 << n)]\n    dp[0][0] = 1\n    for i in range(1 << n):\n        for j in range(1 << n):\n            if i & (1 << j):\n                dp[i][j] = (dp[i][j] + dp[i ^ (1 << j)][j ^ x]) % MOD\n    return str(dp[-1][-1])"
    },
    {
        "number": 3897,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    MOD = 1000000007\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        dp[i][0] = 1\n        for j in range(1, i+1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD\n    ans = dp[n][n]\n    return str(ans)"
    },
    {
        "number": 3898,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Check if the input is valid\n    if len(a)!= n or len(b)!= n:\n        return \"NO\"\n\n    # Check if the input is valid\n    if len(set(a))!= n or len(set(b))!= n:\n        return \"NO\"\n\n    # Check if the input is valid\n    if len(set(a))!= len(set(b)):\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0)!= n - 1 or b.count(0)!= n - 1:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0)!= b.count(0):\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 0:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 1 and b.count(0) == 1:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 2 and b.count(0) == 2:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 3 and b.count(0) == 3:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 4 and b.count(0) == 4:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 5 and b.count(0) == 5:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 6 and b.count(0) == 6:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 7 and b.count(0) == 7:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 8 and b.count(0) == 8:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 9 and b.count(0) == 9:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 10 and b.count(0) == 10:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 11 and b.count(0) == 11:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 12 and b.count(0) == 12:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 13 and b.count(0) == 13:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 14 and b.count(0) == 14:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 15 and b.count(0) == 15:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 16 and b.count(0) == 16:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 17 and b.count(0) == 17:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 18 and b.count(0) == 18:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 19 and b.count(0) == 19:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 20 and b.count(0) == 20:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 21 and b.count(0) == 21:\n        return \"NO\"\n\n    # Check if the input is valid\n    if a.count(0) == 22 and b.count(0) == 22:\n        return \"NO\"\n\n   "
    },
    {
        "number": 3899,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # sort tasks by power consumption\n    tasks = sorted(zip(a, b), key=lambda x: x[0])\n\n    # compute the maximum power consumption per processor\n    max_power = sum(tasks[0][0]) / tasks[0][1]\n\n    # compute the minimum power consumption per processor\n    min_power = sum(tasks[-1][0]) / tasks[-1][1]\n\n    # compute the threshold for which the system will not blow up\n    threshold = (max_power + min_power) / 2\n\n    # compute the total number of processors needed\n    total_processors = sum(tasks[i][1] for i in range(n))\n\n    # compute the number of processors needed for the first task\n    first_processors = tasks[0][1]\n\n    # compute the number of processors needed for the second task\n    second_processors = total_processors - first_processors\n\n    # compute the average power consumption per processor for the first task\n    first_power = sum(tasks[i][0] for i in range(first_processors)) / first_processors\n\n    # compute the average power consumption per processor for the second task\n    second_power = sum(tasks[i][0] for i in range(first_processors, n)) / second_processors\n\n    # check if the system will blow up\n    if first_power > threshold:\n        return str(int(threshold * 1000 + 1))\n    else:\n        return str(int(threshold * 1000))"
    },
    {
        "number": 3900,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    suspects = [set() for _ in range(n)]\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        suspects[i].add(x)\n        suspects[i].add(y)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if len(suspects[i] & suspects[j]) >= p:\n                count += 1\n    return count"
    },
    {
        "number": 3901,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(1, n):\n        if a[i] % a[i-1] == 0:\n            a[i] //= a[i-1]\n            count += 1\n        elif a[i-1] % a[i] == 0:\n            a[i-1] //= a[i]\n            count += 1\n        else:\n            return -1\n    return count"
    },
    {
        "number": 3902,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    root = s[:4]\n    suffixes = set()\n    for i in range(len(s)-3):\n        if s[i:i+2] not in suffixes and s[i:i+3] not in suffixes:\n            suffixes.add(s[i:i+2])\n            suffixes.add(s[i:i+3])\n    suffixes = sorted(list(suffixes))\n    print(len(suffixes))\n    for suffix in suffixes:\n        print(suffix)\n    return \"\""
    },
    {
        "number": 3903,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    map_ = []\n    for i in range(n):\n        map_.append(list(stdin.readline().strip()))\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    q = [(i, j) for i in range(n) for j in range(m) if map_[i][j] in '123']\n    if not q:\n        return -1\n    visited[q[0][0]][q[0][1]] = True\n    count = 1\n    while q:\n        i, j = q.pop(0)\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj] and map_[ni][nj] in '123':\n                visited[ni][nj] = True\n                q.append((ni, nj))\n                count += 1\n    return count if count == n * m else -1"
    },
    {
        "number": 3904,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    seq = stdin.split()[1]\n    if seq.count('(')!= seq.count(')'):\n        return '-1'\n    stack = []\n    for i in range(n):\n        if seq[i] == '(':\n            stack.append(i)\n        else:\n            if not stack:\n                return '-1'\n            stack.pop()\n    if stack:\n        return '-1'\n    return '0'"
    },
    {
        "number": 3905,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split()[0:3])\n    u = list(map(int, stdin.split()[3:]))\n    c = []\n    for i in range(m):\n        c.append(list(map(int, stdin.split()[i*2+3:i*2+5])))\n    # print(n, m, h, u, c)\n    count = 0\n    for i in range(m):\n        if u[c[i][0]-1]!= u[c[i][1]-1]:\n            count += 1\n    if count == 0:\n        return \"0\\n\"\n    else:\n        return f\"{count}\\n\" + \" \".join(map(str, [c[i][0] for i in range(m) if u[c[i][0]-1]!= u[c[i][1]-1]])) + \"\\n\""
    },
    {
        "number": 3906,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(m):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n                dp[i][j] %= MOD\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n                dp[i][j] %= MOD\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n                dp[i][j] %= MOD\n    return dp[n-1][m-1]"
    },
    {
        "number": 3907,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    coupons = []\n    for i in range(m):\n        q, w = map(int, stdin.split())\n        coupons.append((q, w))\n    a = [0] * n\n    for i in range(m):\n        q, w = coupons[i]\n        for j in range(n):\n            if a[j] == q:\n                a[j] += 1\n                break\n        else:\n            for j in range(n):\n                if a[j] == 0:\n                    a[j] = q\n                    break\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = 1\n    a.sort()\n    ans = 0\n    for i in range(n):\n        ans += a[i] * coupons[i][1]\n    return str(ans)"
    },
    {
        "number": 3908,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            sub = s[i:j]\n            if len(sub) > 1 and is_arithmetic_progression(sub):\n                count += 1\n    return count\n\ndef"
    },
    {
        "number": 3909,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467]\n    dp = [0] * (n+1)\n    dp[0] = 0\n    for i in range(1, n+1):\n        dp[i] = float('inf')\n        for j in range(len(coins)):\n            if coins[j] <= i:\n                dp[i] = min(dp[i], dp[i-coins[j]]+1)\n    return dp[n]"
    },
    {
        "number": 3910,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    pairs = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        pairs.append((a, b))\n    food_types = [1, 2]\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if pairs[i][0] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[j][1] == pairs[k][1]:\n                    continue\n                if pairs[i][0] == pairs[j][0] or pairs[i][0] == pairs[k][0] or pairs[j][0] == pairs[k][0]:\n                    continue\n                if pairs[i][1] == pairs[j][1] or pairs[i][1] == pairs[k][1] or pairs[j][1] == pairs[k][1]:\n                    continue\n                if pairs[i][0] == pairs[j][1] or pairs[i][0] == pairs[k][1] or pairs[j][0] == pairs[k][1]:\n                    continue\n                if pairs[i][1] == pairs[j][0] or pairs[i][1] == pairs[k][0] or pairs[j][1] == pairs[k][0]:\n                    continue\n                if pairs[i][0] == pairs[j][0] == pairs[k][1] or pairs[i][0] == pairs[k][0] == pairs[j][1] or pairs[i][1] == pairs[j][0] == pairs[k][1] or pairs[i][1] == pairs[k][0] == pairs[j][1]:\n                    continue\n                if pairs[i][0] == pairs[j][1] == pairs[k][0] or pairs[i][0] == pairs[k][1] == pairs[j][0] or pairs[i][1] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[k][0] == pairs[j][0]:\n                    continue\n                if pairs[i][0] == pairs[j][1] == pairs[k][1] or pairs[i][0] == pairs[k][1] == pairs[j][1] or pairs[i][1] == pairs[j][0] == pairs[k][1] or pairs[i][1] == pairs[k][0] == pairs[j][1]:\n                    continue\n                if pairs[i][0] == pairs[j][0] == pairs[k][1] or pairs[i][0] == pairs[k][0] == pairs[j][1] or pairs[i][1] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[k][0] == pairs[j][0]:\n                    continue\n                if pairs[i][0] == pairs[j][1] == pairs[k][0] or pairs[i][0] == pairs[k][1] == pairs[j][0] or pairs[i][1] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[k][0] == pairs[j][0]:\n                    continue\n                if pairs[i][0] == pairs[j][1] == pairs[k][1] or pairs[i][0] == pairs[k][1] == pairs[j][1] or pairs[i][1] == pairs[j][0] == pairs[k][1] or pairs[i][1] == pairs[k][0] == pairs[j][1]:\n                    continue\n                if pairs[i][0] == pairs[j][0] == pairs[k][1] or pairs[i][0] == pairs[k][0] == pairs[j][1] or pairs[i][1] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[k][0] == pairs[j][0]:\n                    continue\n                if pairs[i][0] == pairs[j][1] == pairs[k][0] or pairs[i][0] == pairs[k][1] == pairs[j][0] or pairs[i][1] == pairs[j][0] == pairs[k][0] or pairs[i][1] == pairs[k][0] == pairs[j][0]:\n                    continue\n                if pairs[i][0] == pairs["
    },
    {
        "number": 3911,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    row = [1]\n    for i in range(n-1):\n        if row[-1] == row[-2]:\n            row[-2] += 1\n        else:\n            row.append(1)\n    return''.join(map(str, row))"
    },
    {
        "number": 3912,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i]!= s[j]:\n                if s[i].islower() and s[j].isupper():\n                    s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                elif s[i].isupper() and s[j].islower():\n                    s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                else:\n                    s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n                count += 1\n                break\n    print(count)\n    print(s)\n    return s"
    },
    {
        "number": 3913,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    revealed = stdin.readline().strip()\n    m = int(stdin.readline().strip())\n    words = [stdin.readline().strip() for _ in range(m)]\n    hidden = words[0]\n    for i in range(n):\n        if revealed[i] == \"*\":\n            continue\n        if hidden[i]!= revealed[i]:\n            return \"0\"\n    for word in words:\n        if word!= hidden:\n            for i in range(n):\n                if revealed[i] == \"*\":\n                    continue\n                if word[i]!= revealed[i]:\n                    return \"1\"\n    return \"0\""
    },
    {
        "number": 3914,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, b = map(int, stdin.split()[0:3])\n    a = list(map(int, stdin.split()[3:]))\n    x1 = 0\n    x2 = 0\n    for i in range(1, n+1):\n        if a[i-1]!= b:\n            x1 += 1\n        if a[n-i]!= b:\n            x2 += 1\n        if i <= d:\n            a[i-1] = 0\n            a[n-i] = 0\n    return max(x1, x2)"
    },
    {
        "number": 3915,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    A = p / q\n    if A < 1 / 42 or A > 42:\n        return \"Palindromic tree is better than splay tree\"\n    n = 1\n    while True:\n        if is_prime(n):\n            if n > A * rub(n):\n                return str(n)\n        n += 1\n\ndef"
    },
    {
        "number": 3916,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    k = list(map(int, stdin.readline().strip().split()))\n    dp = [float('inf')] * (max(k) + 1)\n    dp[1] = 0\n    for i in range(2, max(k) + 1):\n        for j in range(2, i):\n            if i % j == 0:\n                dp[i] = min(dp[i], dp[j] + 1)\n    ans = 0\n    for i in k:\n        ans += dp[i]\n    return str(ans)"
    },
    {
        "number": 3917,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    min_val = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            val = (i-j)**2 + g(i, j)**2\n            if val < min_val:\n                min_val = val\n    return str(min_val)\n\ndef"
    },
    {
        "number": 3918,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k_1, k_2 = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    # perform operations on A\n    for i in range(k_1):\n        index = i % n\n        if a[index] < b[index]:\n            a[index] += 1\n        else:\n            a[index] -= 1\n\n    # perform operations on B\n    for i in range(k_2):\n        index = i % n\n        if b[index] < a[index]:\n            b[index] += 1\n        else:\n            b[index] -= 1\n\n    # calculate error\n    error = sum((a[i] - b[i])**2 for i in range(n))\n\n    return str(error)"
    },
    {
        "number": 3919,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.readline().split())\n    S = stdin.readline().strip()\n    lr = [list(map(int, stdin.readline().split())) for _ in range(M)]\n\n    # count the number of possible values for S after the M operations\n    MOD = 1000000007\n    dp = [1] * (N+1)\n    for l, r in lr:\n        dp[l-1] = 0\n        dp[r] = 0\n        for i in range(l-2, r):\n            dp[i+1] = (dp[i+1] + dp[i]) % MOD\n\n    # count the number of possible values for S\n    count = 1\n    for i in range(N):\n        count = (count * dp[i]) % MOD\n\n    return str(count)"
    },
    {
        "number": 3920,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(6):\n        for j in range(i+1, 6):\n            for k in range(j+1, 6):\n                if a[i] + a[j] > a[k] and a[i] + a[k] > a[j] and a[j] + a[k] > a[i]:\n                    count += 1\n    return count"
    },
    {
        "number": 3921,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = 1\n        for j in range(i):\n            if a[i] % a[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"
    },
    {
        "number": 3922,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.readline().strip())\n    for i in range(test_cases):\n        k = int(stdin.readline().strip())\n        first_row = stdin.readline().strip().split()\n        second_row = stdin.readline().strip().split()\n        organs = [int(x) for x in first_row if x!= 'E'] + [int(x) for x in second_row if x!= 'E']\n        if len(organs)!= 4*k + 1:\n            return \"SURGERY FAILED\"\n        empty_space = [x for x in range(2*k+1) if x not in first_row and x not in second_row][0]\n        moves = \"\"\n        for i in range(1, 4*k+2):\n            if i == empty_space:\n                continue\n            if i < empty_space:\n                if i % 2 == 1:\n                    moves += \"u\"\n                else:\n                    moves += \"d\"\n            else:\n                if i % 2 == 1:\n                    moves += \"d\"\n                else:\n                    moves += \"u\"\n        return \"SURGERY COMPLETE\\n\" + moves"
    },
    {
        "number": 3923,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    if A == 1 or B == 1:\n        return \"1 \" * N\n    if A == N or B == N:\n        return str(N) + \" \" + \" \".join(map(str, range(2, N+1)))\n    if A == B:\n        return str(A) + \" \" + \" \".join(map(str, range(2, N+1)))\n    for i in range(1, N+1):\n        if i == A or i == B:\n            continue\n        if g(i, N) == A or g(i, N) == B:\n            continue\n        return -1\n    return \"1 \" * N\n\ndef"
    },
    {
        "number": 3924,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    dp = [0] * (n+1)\n    dp[0] = 0\n    dp[1] = a[0]\n    for i in range(2, n+1):\n        dp[i] = min(dp[i-1]+a[i-1], dp[i-2]+a[i-1]+a[i-2])\n    return dp[n]"
    },
    {
        "number": 3925,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] = dp[i-1]\n    return max(dp)"
    },
    {
        "number": 3926,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.readline().split())\n    r, c = map(int, stdin.readline().split())\n    x, y = map(int, stdin.readline().split())\n    labyrinth = []\n    for i in range(n):\n        line = stdin.readline().strip()\n        labyrinth.append(line)\n\n    visited = [[False for j in range(m)] for i in range(n)]\n    visited[r][c] = True\n\n    def dfs(r, c, count):\n        if r < 0 or r >= n or c < 0 or c >= m:\n            return False\n        if visited[r][c]:\n            return False\n        if labyrinth[r][c] == '*':\n            return False\n        if count > x + y:\n            return False\n        if r == n - 1 and c == m - 1:\n            return True\n        visited[r][c] = True\n        if dfs(r + 1, c, count + 1):\n            return True\n        if dfs(r - 1, c, count + 1):\n            return True\n        if dfs(r, c + 1, count + 1):\n            return True\n        if dfs(r, c - 1, count + 1):\n            return True\n        visited[r][c] = False\n        return False\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, 0):\n                count += 1\n\n    return count"
    },
    {
        "number": 3927,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    weights = list(map(int, stdin.readline().strip().split()))\n    weights.sort(reverse=True)\n    total_mass = sum(weights)\n    k = total_mass // 2\n    if k == 0:\n        return \"0\"\n    count = 0\n    for i in range(n):\n        if k >= weights[i]:\n            count += 1\n            k -= weights[i]\n            if k == 0:\n                break\n    return str(count)"
    },
    {
        "number": 3928,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = stdin.split('\\n')[1]\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if s[i - 1] == s[i - 2]:\n            dp[i] = dp[i - 1] + a\n        else:\n            dp[i] = dp[i - 1] + b\n    return dp[n]"
    },
    {
        "number": 3929,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K = map(int, stdin.split())\n\n    # Initialize deque\n    deque = collections.deque()\n\n    # Insert cards at the end of the deque\n    for i in range(1, N+1):\n        deque.append(i)\n\n    # Perform N eating actions\n    for i in range(N):\n        deque.popleft() if i % 2 == 0 else deque.pop()\n\n    # Construct integer sequence\n    sequence = [deque.popleft() if i % 2 == 0 else deque.pop() for i in range(N)]\n\n    # Count number of sequences with K-th element equal to 1\n    count = 0\n    for i in range(1, N+1):\n        if sequence.count(i) == K:\n            count += 1\n\n    # Return answer modulo 10^9 + 7\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3930,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sum(a[i:j])**k == 0:\n                count += 1\n    return count"
    },
    {
        "number": 3931,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k, f = map(int, stdin.split())\n    trips = []\n    for i in range(n):\n        start, end = stdin.split()[i*2:i*2+2]\n        trips.append((start, end))\n    dp = [[0]*(k+1) for _ in range(n+1)]\n    for i in range(n+1):\n        dp[i][0] = 0\n    for i in range(1, k+1):\n        dp[0][i] = f\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            dp[i][j] = float('inf')\n            for t in trips:\n                if t[0] == trips[i-1][1]:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + a)\n                if t[1] == trips[i-1][0]:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + b)\n            if dp[i][j] == float('inf'):\n                dp[i][j] = dp[i-1][j]\n    return str(dp[n][k])"
    },
    {
        "number": 3932,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n    if n == 1:\n        return \"YES\"\n    if n == 2:\n        return \"NO\"\n    for i in range(2, n):\n        if c[i] < 2:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3933,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n    if n == 1:\n        return str(t[0])\n    if n == 2:\n        return str((t[0] + t[1]) // 2)\n    if t[1] - t[0] == t[2] - t[1]:\n        return str(t[n-1] + (n-1)*t[n-1] - (n-2)*t[n-2])\n    else:\n        return str(t[n-1])"
    },
    {
        "number": 3934,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    edges = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, stdin.readline().split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n    leaves = [i for i in range(n) if len(edges[i]) == 1]\n    if len(leaves) < 2:\n        return \"NO\"\n    visited = [False] * n\n    def dfs(node, parent):\n        visited[node] = True\n        for child in edges[node]:\n            if child == parent:\n                continue\n            if not visited[child]:\n                dfs(child, node)\n    for i in range(len(leaves)):\n        for j in range(i+1, len(leaves)):\n            u, v = leaves[i], leaves[j]\n            if not visited[u] and not visited[v]:\n                dfs(u, -1)\n                dfs(v, -1)\n                if visited[u] or visited[v]:\n                    return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3935,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n    b.sort()\n    k = 0\n    for i in range(n-1):\n        if b[i+1] - b[i] == 1:\n            k += 1\n        else:\n            break\n    if k == 0:\n        print(0)\n        print(*b)\n    else:\n        print(k)\n        print(*b[:k])"
    },
    {
        "number": 3936,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N = int(stdin.readline().strip())\n    S1 = stdin.readline().strip()\n    S2 = stdin.readline().strip()\n\n    # count number of ways to paint the dominoes\n    MOD = 1000000007\n    dp = [[[0] * 3 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if S1[i] == S2[j]:\n                dp[i][j][0] = 1\n            if S1[i] == S2[j+1]:\n                dp[i][j][1] = 1\n            if S1[i+1] == S2[j]:\n                dp[i][j][2] = 1\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                for c in range(3):\n                    if dp[i][j][c] == 0:\n                        continue\n                    for d in range(3):\n                        if d == c:\n                            continue\n                        if i+1 < N and j+1 < N:\n                            dp[i+1][j+1][d] = (dp[i+1][j+1][d] + dp[i][j][c]) % MOD\n                        if i+1 < N:\n                            dp[i+1][j][d] = (dp[i+1][j][d] + dp[i][j][c]) % MOD\n                        if j+1 < N:\n                            dp[i][j+1][d] = (dp[i][j+1][d] + dp[i][j][c]) % MOD\n    ans = 0\n    for i in range(N):\n        for j in range(N):\n            ans = (ans + dp[i][j][0] + dp[i][j][1] + dp[i][j][2]) % MOD\n    return str(ans)"
    },
    {
        "number": 3937,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    for i in range(n):\n        for j in range(m - k + 1):\n            if all(a[l] == GCD(i, j + l - 1) for l in range(k)):\n                return \"YES\"\n    return \"NO\"\n\ndef"
    },
    {
        "number": 3938,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    black_rectangles = []\n    for i in range(m):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        black_rectangles.append(((x1, y1), (x2, y2)))\n\n    # sort the black rectangles by their area\n    black_rectangles.sort(key=lambda x: (x[1][0] - x[0][0]) * (x[1][1] - x[0][1]))\n\n    # initialize the grid with white color\n    grid = [[False] * n for _ in range(n)]\n\n    # color the cells in the black rectangles in white\n    for rect in black_rectangles:\n        x1, y1 = rect[0]\n        x2, y2 = rect[1]\n        for i in range(x1, x2+1):\n            for j in range(y1, y2+1):\n                grid[i][j] = True\n\n    # calculate the total cost of painting the whole grid in white\n    total_cost = 0\n    for i in range(n):\n        for j in range(n):\n            if not grid[i][j]:\n                total_cost += 1\n\n    return str(total_cost)"
    },
    {
        "number": 3939,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.readline().strip())\n    for i in range(queries):\n        n, k = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        if k in a:\n            print(\"yes\")\n        else:\n            print(\"no\")"
    },
    {
        "number": 3940,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    subarrays = []\n    for i in range(m):\n        l, r = map(int, stdin.split())\n        subarrays.append((l, r))\n    mexes = [0] * n\n    for l, r in subarrays:\n        mexes[l-1] += 1\n        mexes[r] -= 1\n    for i in range(1, n):\n        mexes[i] += mexes[i-1]\n    min_mex = float('inf')\n    for l, r in subarrays:\n        min_mex = min(min_mex, mexes[r-1])\n    max_mex = max(mexes)\n    if max_mex == 0:\n        return str(max_mex)\n    a = [0] * n\n    for i in range(n):\n        if mexes[i] == max_mex:\n            a[i] = 1\n    return str(max_mex) + '\\n' +''.join(map(str, a))"
    },
    {
        "number": 3941,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    rooms = list(map(int, stdin.split()[2:]))\n    switches = []\n    for i in range(m):\n        x, *rooms_controlled = map(int, stdin.split()[0:2+n])\n        switches.append((x, rooms_controlled))\n    locked_rooms = [i for i in range(n) if rooms[i] == 0]\n    unlocked_rooms = [i for i in range(n) if rooms[i] == 1]\n    for switch in switches:\n        x, rooms_controlled = switch\n        if x == 1:\n            for room in rooms_controlled:\n                if room in locked_rooms:\n                    locked_rooms.remove(room)\n                elif room in unlocked_rooms:\n                    unlocked_rooms.remove(room)\n        elif x == 2:\n            for room in rooms_controlled:\n                if room in locked_rooms:\n                    locked_rooms.remove(room)\n                elif room in unlocked_rooms:\n                    unlocked_rooms.remove(room)\n    if len(locked_rooms) == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3942,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if '#' not in s:\n        return '-1'\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '#':\n            count += 1\n            if count > len(s) - i:\n                return '-1'\n            for j in range(i+1, len(s)):\n                if s[j] == ')':\n                    count -= 1\n                    if count < 0:\n                        return '-1'\n                elif s[j] == '(':\n                    count += 1\n                    if count > len(s) - i:\n                        return '-1'\n            if count!= 0:\n                return '-1'\n    if count!= 0:\n        return '-1'\n    ans = []\n    for i in range(len(s)):\n        if s[i] == '#':\n            ans.append(len(s) - i)\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3943,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a + b == 0:\n        return \"0\\n\"\n    if a == 0:\n        return f\"{b**2}\\n{'x'*b}\"\n    if b == 0:\n        return f\"{a**2}\\n{'o'*a}\"\n    if a == 1 and b == 1:\n        return \"1\\noo\"\n    if a == 1:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}\"\n    if b == 1:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}\"\n    if a == 2 and b == 2:\n        return \"5\\nooxxoo\"\n    if a == 2:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}\"\n    if b == 2:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}\"\n    if a == 3 and b == 3:\n        return \"14\\nooxxooxxoo\"\n    if a == 3:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}xx{'o'*(b-3)}\"\n    if b == 3:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}oo{'x'*(a-3)}\"\n    if a == 4 and b == 4:\n        return \"36\\nooxxooxxooxxoo\"\n    if a == 4:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}xx{'o'*(b-3)}xx{'o'*(b-4)}\"\n    if b == 4:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}oo{'x'*(a-3)}oo{'x'*(a-4)}\"\n    if a == 5 and b == 5:\n        return \"84\\nooxxooxxooxxooxxoo\"\n    if a == 5:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}xx{'o'*(b-3)}xx{'o'*(b-4)}xx{'o'*(b-5)}\"\n    if b == 5:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}oo{'x'*(a-3)}oo{'x'*(a-4)}oo{'x'*(a-5)}\"\n    if a == 6 and b == 6:\n        return \"192\\nooxxooxxooxxooxxooxxoo\"\n    if a == 6:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}xx{'o'*(b-3)}xx{'o'*(b-4)}xx{'o'*(b-5)}xx{'o'*(b-6)}\"\n    if b == 6:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}oo{'x'*(a-3)}oo{'x'*(a-4)}oo{'x'*(a-5)}oo{'x'*(a-6)}\"\n    if a == 7 and b == 7:\n        return \"448\\nooxxooxxooxxooxxooxxooxxoo\"\n    if a == 7:\n        return f\"{b**2}\\n{'x'*b}{'o'*(b-1)}xx{'o'*(b-2)}xx{'o'*(b-3)}xx{'o'*(b-4)}xx{'o'*(b-5)}xx{'o'*(b-6)}xx{'o'*(b-7)}\"\n    if b == 7:\n        return f\"{a**2}\\n{'o'*a}{'x'*(a-1)}oo{'x'*(a-2)}oo{'x'*(a-3)}oo{'x'*(a-4)}oo{'x'*(a-5)}oo{'x'*(a-6)}oo{'x"
    },
    {
        "number": 3944,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    MOD = 10**9+7\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            for l in range(1, k+1):\n                count += 3**sum([i, j, l])\n    count = count % MOD\n    return str(count)"
    },
    {
        "number": 3945,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = []\n    for i in range(n):\n        a.append(list(map(int, stdin.split())))\n    x = [[0]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0:\n                x[i][j] = a[i][j]\n            elif j == 0:\n                x[i][j] = a[i][j]\n            else:\n                x[i][j] = min(x[i-1][j], x[i][j-1]) + a[i][j]\n    for i in range(n):\n        for j in range(m):\n            print(x[i][j], end=' ')\n        print()\n    return \"\""
    },
    {
        "number": 3946,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    w = list(map(int, stdin.split()))\n    q = [0] * n\n    p = [0] * n\n    for i in range(n):\n        if a[i] == 1:\n            q[i] = w[i]\n            p[i] = 1\n        else:\n            q[i] = 1\n            p[i] = w[i]\n    for i in range(m):\n        for j in range(n):\n            if a[j] == 1:\n                q[j] += 1\n            else:\n                p[j] += 1\n    for i in range(n):\n        q[i] = q[i] % 998244353\n        p[i] = p[i] % 998244353\n        r = pow(q[i], p[i], 998244353)\n        print(r)\n    return \"\""
    },
    {
        "number": 3947,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n    dp = [0] * n\n    dp[0] = arr[0]\n    dp[1] = max(arr[0], arr[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n    return dp[-1]"
    },
    {
        "number": 3948,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * n\n    visited[0] = True\n    queue = [0]\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    if not all(visited):\n        return \"No\"\n    for u in range(n):\n        if len(graph[u]) == 1 and u!= 0:\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 3949,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    # Check if there is at least one south magnet in every row and every column\n    for i in range(n):\n        if '#' not in grid[i]:\n            return -1\n    for j in range(m):\n        if '#' not in [grid[i][j] for i in range(n)]:\n            return -1\n    # Check if it is possible to place magnets such that the conditions are met\n    # If a cell is colored black, then it is possible for a north magnet to occupy this cell after some sequence of operations from the initial placement.\n    # If a cell is colored white, then it is impossible for a north magnet to occupy this cell after some sequence of operations from the initial placement.\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # Check if there is a south magnet in the same row or column\n            if '#' not in [grid[k][j] for k in range(n)] and '#' not in [grid[i][k] for k in range(m)]:\n                return -1\n            # Check if there is a north magnet in the same row or column\n            if '#' in [grid[k][j] for k in range(n)] and '#' in [grid[i][k] for k in range(m)]:\n                return -1\n    # Find the minimum possible number of north magnets required\n    north_magnets = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            # Check if there is a south magnet in the same row or column\n            if '#' not in [grid[k][j] for k in range(n)] and '#' not in [grid[i][k] for k in range(m)]:\n                north_magnets += 1\n    return north_magnets"
    },
    {
        "number": 3950,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    segments = []\n    for i in range(q):\n        l, r = map(int, stdin.split())\n        segments.append((l, r))\n    for i in range(n):\n        if a[i] == 0:\n            for j in range(q):\n                if segments[j][0] <= i <= segments[j][1]:\n                    a[i] = j + 1\n    if all(a):\n        return \"YES\\n\" + \" \".join(map(str, a))\n    else:\n        return \"NO\""
    },
    {
        "number": 3951,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    table = [int(x) for x in stdin.split()[1:]]\n    a = []\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                a.append(table[i*n+j])\n            else:\n                a.append(table[i*n+j] // gcd(table[i*n+i], table[j*n+j]))\n    return''.join(str(x) for x in a)\n\ndef"
    },
    {
        "number": 3952,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n    points.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if points[i][0] < points[j][0] < points[k][0]:\n                    count += 1\n    return count"
    },
    {
        "number": 3953,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    grid = []\n    for i in range(n):\n        grid.append(list(stdin.readline().strip()))\n\n    # Find the most evil tile\n    most_evil_tile = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'E':\n                most_evil_tile = (i, j)\n                break\n        if most_evil_tile is not None:\n            break\n\n    # If there is no most evil tile, return -1\n    if most_evil_tile is None:\n        return '-1'\n\n    # Initialize the visited array\n    visited = [[False for _ in range(n)] for _ in range(n)]\n\n    # Initialize the queue with the most evil tile\n    queue = [(most_evil_tile[0], most_evil_tile[1])]\n\n    # Initialize the spell count\n    spell_count = 0\n\n    # BFS to purify all cells\n    while queue:\n        row, col = queue.pop(0)\n        if visited[row][col]:\n            continue\n        visited[row][col] = True\n        spell_count += 1\n        # Purify all cells in the same row and column\n        for i in range(n):\n            if grid[row][i] == 'E' and not visited[row][i]:\n                queue.append((row, i))\n            if grid[i][col] == 'E' and not visited[i][col]:\n                queue.append((i, col))\n\n    # If there are no more cells to purify, return -1\n    if spell_count == n * n:\n        return '-1'\n\n    # Initialize the result array\n    result = []\n\n    # Find the most evil tile again\n    most_evil_tile = None\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'E':\n                most_evil_tile = (i, j)\n                break\n        if most_evil_tile is not None:\n            break\n\n    # BFS to find the cells that can be purified\n    queue = [(most_evil_tile[0], most_evil_tile[1])]\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    while queue:\n        row, col = queue.pop(0)\n        if visited[row][col]:\n            continue\n        visited[row][col] = True\n        # Check if the cell can be purified\n        can_be_purified = True\n        for i in range(n):\n            if grid[row][i] == 'E' and not visited[row][i]:\n                can_be_purified = False\n                break\n            if grid[i][col] == 'E' and not visited[i][col]:\n                can_be_purified = False\n                break\n        if can_be_purified:\n            result.append((row, col))\n            # Purify the cell\n            grid[row][col] = '.'\n            spell_count += 1\n            # Add the cells in the same row and column to the queue\n            for i in range(n):\n                if grid[row][i] == 'E' and not visited[row][i]:\n                    queue.append((row, i))\n                if grid[i][col] == 'E' and not visited[i][col]:\n                    queue.append((i, col))\n\n    # If there are no cells that can be purified, return -1\n    if spell_count == n * n:\n        return '-1'\n\n    # Return the result\n    return '\\n'.join([' '.join(map(str, cell)) for cell in result])\n"
    },
    {
        "number": 3954,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    m = -float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            if k == 0:\n                break\n            k -= 1\n            a[i], a[j] = a[j], a[i]\n            m = max(m, sum(a))\n            a[i], a[j] = a[j], a[i]\n    return str(m)"
    },
    {
        "number": 3955,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    dp = [0] * (k+1)\n    dp[0] = sum(a)\n    for i in range(1, k+1):\n        dp[i] = max(dp[i-1], sum(a[j] * x**(i-j-1) for j in range(n)))\n    return dp[k]"
    },
    {
        "number": 3956,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    MOD = 998244353\n    dp = [0] * (2*K)\n    dp[0] = 1\n    for i in range(1, 2*K):\n        dp[i] = (dp[i-1] * (i+1)) % MOD\n    ans = []\n    for i in range(2, 2*K+1):\n        ans.append((dp[i-1] * dp[2*K-i]) % MOD)\n    return '\\n'.join(map(str, ans))"
    },
    {
        "number": 3957,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.readline().split())\n    universities = list(map(int, stdin.readline().split()))\n    roads = []\n    for i in range(n - 1):\n        x, y = map(int, stdin.readline().split())\n        roads.append((x, y))\n    pairs = []\n    for i in range(k):\n        pairs.append([])\n    for i in range(k):\n        pairs[i].append(universities[i])\n    for i in range(k, 2 * k):\n        pairs[i % k].append(universities[i])\n    distances = []\n    for i in range(k):\n        for j in range(i + 1, k):\n            distance = 0\n            for road in roads:\n                if road[0] in pairs[i] and road[1] in pairs[j]:\n                    distance += 1\n                elif road[1] in pairs[i] and road[0] in pairs[j]:\n                    distance += 1\n            distances.append(distance)\n    return max(distances)\n"
    },
    {
        "number": 3958,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1]\n            else:\n                dp[i][j] = dp[i+1][j-1] and (s[i] == '0' or s[j] == '0')\n    if not dp[0][n-1]:\n        return '-1'\n    k = 0\n    for i in range(n):\n        if dp[0][i]:\n            k += 1\n    res = []\n    for i in range(n):\n        if dp[0][i]:\n            j = i\n            while j < n and dp[0][j]:\n                j += 1\n            res.append(str(j-i))\n            res.append(' '.join(str(x+1) for x in range(i, j)))\n    return f'{k}\\n{\" \".join(res)}'"
    },
    {
        "number": 3959,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n, m = map(int, stdin.split()[0:2])\n    gyms = []\n    for i in range(n):\n        g, *types = map(int, stdin.split()[0:g+1])\n        gyms.append(types)\n\n    # count number of pokemon of each type in each gym\n    counts = [0] * m\n    for gym in gyms:\n        for type in gym:\n            counts[type-1] += 1\n\n    # count number of valid evolution plans\n    valid_plans = 1\n    for i in range(m):\n        valid_plans *= counts[i]\n        valid_plans %= 10**9 + 7\n\n    return str(valid_plans)"
    },
    {
        "number": 3960,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    f_max = 0\n    for i in range(n-1):\n        for j in range(i+2, n+1):\n            f = sum(abs(a[i]-a[k])*(k-i)*(k-i-1)//2 for k in range(i+1, j))\n            f_max = max(f_max, f)\n    return str(f_max)"
    },
    {
        "number": 3961,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[p[i - 1]]) % 1000000007\n    return dp[n]"
    },
    {
        "number": 3962,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    guests = []\n    for i in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        guests.append((l, r))\n    guests.sort(key=lambda x: x[0])\n    chairs = 0\n    for i in range(n):\n        l, r = guests[i]\n        if i == 0:\n            chairs += l\n        else:\n            chairs += max(0, l - guests[i-1][1])\n        chairs += r\n    return chairs"
    },
    {
        "number": 3963,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    a = [1] + list(a)\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(m, -1, -1):\n            if j >= b[i]:\n                dp[j] = (dp[j] + dp[j - b[i]]) % (10**9 + 7)\n            if j >= a[i+1]:\n                dp[j] = (dp[j] - dp[j - a[i+1]]) % (10**9 + 7)\n    return dp[m]"
    },
    {
        "number": 3964,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b, mod = map(int, stdin.split())\n    a = list(map(int, stdin.readline().split()))\n    dp = [[0] * (b+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(b+1):\n            for k in range(min(j//a[i-1], m-i+1)):\n                dp[i][j] += dp[i-1][j-k*a[i-1]]\n                dp[i][j] %= mod\n    return dp[n][b]"
    },
    {
        "number": 3965,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pattern = map(int, stdin.readline().strip().split())\n    pattern = list(map(int, stdin.readline().strip().split()))\n    text = [line.strip().split() for line in stdin.readlines()]\n    syllables = []\n    for line in text:\n        syllables_line = []\n        for word in line:\n            if any(char in 'aeiouy' for char in word):\n                syllables_word = []\n                for i in range(len(word)):\n                    if i == 0 or word[i] in 'aeiouy':\n                        syllables_word.append(word[i])\n                    else:\n                        syllables_word[-1] += word[i]\n                syllables_line.extend(syllables_word)\n        syllables.append(syllables_line)\n    syllables_count = [sum(len(syllable) for syllable in line) for line in syllables]\n    if syllables_count == pattern:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3966,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    score = sum(a)\n    while True:\n        if len(a) == 1:\n            break\n        if len(a) == 2:\n            a = [a[0] + a[1]]\n            score += a[0]\n            break\n        a = [a[0] + a[1]] + a[2:]\n        score += a[0]\n    print(score)"
    },
    {
        "number": 3967,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = 1\n    while True:\n        cut = 0\n        for i in range(n):\n            if a[i] <= d:\n                cut += 1\n            else:\n                break\n        if cut == n or cut * d > k:\n            break\n        d += 1\n    return d"
    },
    {
        "number": 3968,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, D = map(int, stdin.split()[0:2])\n    C = int(stdin.split()[2])\n    infected = list(map(int, stdin.split()[3:3+C]))\n    times = []\n    for i in range(N):\n        s, t = map(int, stdin.split()[3+C+i*2:3+C+i*2+2])\n        times.append((s, t))\n\n    # Initialize variables\n    infected_set = set(infected)\n    infected_queue = []\n    for i in infected:\n        infected_queue.append((i, 1))\n\n    # Simulate virus spread\n    for day in range(D):\n        new_infected = set()\n        for i in range(len(infected_queue)):\n            person, days_infected = infected_queue[i]\n            if days_infected == 1:\n                for j in range(i+1, len(infected_queue)):\n                    other_person, other_days_infected = infected_queue[j]\n                    if times[person][1] == times[other_person][0]:\n                        new_infected.add(other_person)\n                    elif times[person][1] < times[other_person][0]:\n                        break\n            else:\n                new_infected.add(person)\n        for person in new_infected:\n            infected_queue.append((person, 1))\n        infected_set.update(new_infected)\n\n    # Print result\n    return''.join(map(str, sorted(infected_set)))"
    },
    {
        "number": 3969,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    plants = []\n    for i in range(n):\n        s, x = map(float, stdin.split())\n        plants.append((s, x))\n    plants.sort(key=lambda x: x[1])\n    borders = []\n    for i in range(m-1):\n        borders.append((plants[i][1], plants[i+1][1]))\n    borders.sort()\n    count = 0\n    for i in range(m-1):\n        if borders[i][0] > plants[i][1]:\n            count += 1\n    return count"
    },
    {
        "number": 3970,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] % k!= 0:\n            ans += 1\n        else:\n            break\n    return ans"
    },
    {
        "number": 3971,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    dp = [0] * (n+1)\n    dp[1] = a[0]\n    for i in range(2, n+1):\n        dp[i] = max(dp[i-1], dp[i-2] + a[i-1])\n    return dp[n]"
    },
    {
        "number": 3972,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n    count = 1\n    for i in range(2, n+1):\n        count = (count * i) % MOD\n    return str(count)"
    },
    {
        "number": 3973,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    x = max(a)\n    count = 0\n    for i in range(n-1):\n        if a[i]!= a[i+1]:\n            count += abs(a[i]-a[i+1])\n        else:\n            count += 1\n    count += abs(a[n-2]-x)\n    return str(count)"
    },
    {
        "number": 3974,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    prev = '+'\n    for char in stdin:\n        if char == prev:\n            continue\n        if char == '+':\n            count += 1\n        prev = char\n    return count + 1"
    },
    {
        "number": 3975,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        if line[0] == \"IN\":\n            graph[i] = [line[1]]\n        else:\n            graph[i] = [int(x) for x in line[1:]]\n    visited = [False] * n\n    stack = [1]\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in graph[node]:\n                stack.append(neighbor)\n    output = \"\"\n    for i in range(n):\n        if graph[i][0] == \"0\":\n            output += \"1\"\n        else:\n            output += \"0\"\n    return output"
    },
    {
        "number": 3976,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n - m * p + 1):\n        if a[i:i+m] == b:\n            count += 1\n            print(i+1, end=' ')\n\n    return str(count)"
    },
    {
        "number": 3977,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.readline().split())\n    homes = list(map(int, stdin.readline().split()))\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n+1)\n    def dfs(node, parent):\n        visited[node] = True\n        for child in graph[node]:\n            if child!= parent and not visited[child]:\n                dfs(child, node)\n    for home in homes:\n        dfs(home, -1)\n    count = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            count += 1\n    return count"
    },
    {
        "number": 3978,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    a.sort()\n    colors = 1\n    for i in range(1, n):\n        if a[i] % a[i-1]!= 0:\n            colors += 1\n    return str(colors)"
    },
    {
        "number": 3979,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words = []\n    for i in range(n):\n        l, *s = map(int, stdin.split())\n        words.append((l, s))\n    words.sort(key=lambda x: x[0])\n    for i in range(1, n):\n        if words[i][0] < words[i-1][0]:\n            return \"No\"\n        if words[i][0] == words[i-1][0]:\n            for j in range(1, words[i][0]):\n                if words[i][j] < words[i-1][j]:\n                    return \"No\"\n    letters = set()\n    for l, s in words:\n        for j in range(l):\n            letters.add(s[j])\n    if len(letters) == m:\n        return \"Yes\\n0\"\n    else:\n        return \"Yes\\n{}\\n{}\".format(m-len(letters), \" \".join(map(str, sorted(letters))))"
    },
    {
        "number": 3980,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_beauty = 0\n    max_permutation = []\n    for p in permutations(range(n)):\n        beauty = sum(i^j for i,j in zip(p,range(n)))\n        if beauty > max_beauty:\n            max_beauty = beauty\n            max_permutation = p\n    return f\"{max_beauty}\\n{' '.join(map(str,max_permutation))}\"\n\nfrom itertools import permutations\n\nprint(solution(input()))"
    },
    {
        "number": 3981,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points1 = []\n    points2 = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        points1.append((x, y))\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        points2.append((x, y))\n    for i in range(n):\n        for j in range(m):\n            if points1[i] == points2[j]:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3982,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    m = int(stdin.readline())\n    S = \"\"\n    for i in range(m):\n        c = stdin.readline().strip()\n        S += c\n        ans = 1\n        for j in range(len(S)):\n            if S[j:j+2] in [\"00\", \"01\", \"10\", \"11\"]:\n                ans += 1\n        print(ans % MOD)"
    },
    {
        "number": 3983,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cases = stdin.split('\\n')\n    for i in range(1, len(cases)):\n        case = cases[i].split()\n        n = int(case[0])\n        m = int(case[1])\n        edges = []\n        for j in range(m):\n            edge = case[2+j].split()\n            edges.append((int(edge[0]), int(edge[1])))\n        if n == 1 or m == 0:\n            print(\"Second\")\n            continue\n        if n == 2 and m == 1:\n            print(\"First\")\n            continue\n        if n == 2 and m == 2:\n            if edges[0][0] == 1 and edges[0][1] == 2:\n                print(\"First\")\n            else:\n                print(\"Second\")\n            continue\n        if n == 3 and m == 2:\n            if edges[0][0] == 1 and edges[0][1] == 2:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3:\n                print(\"Second\")\n            elif edges[0][0] == 2 and edges[0][1] == 3:\n                print(\"First\")\n            else:\n                print(\"Second\")\n            continue\n        if n == 3 and m == 3:\n            if edges[0][0] == 1 and edges[0][1] == 2:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3:\n                print(\"Second\")\n            elif edges[0][0] == 2 and edges[0][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 2 and edges[1][0] == 2 and edges[1][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3 and edges[1][0] == 2 and edges[1][1] == 3:\n                print(\"Second\")\n            else:\n                print(\"Second\")\n            continue\n        if n == 4 and m == 3:\n            if edges[0][0] == 1 and edges[0][1] == 2:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3:\n                print(\"Second\")\n            elif edges[0][0] == 2 and edges[0][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 2 and edges[1][0] == 2 and edges[1][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3 and edges[1][0] == 2 and edges[1][1] == 3:\n                print(\"Second\")\n            elif edges[0][0] == 1 and edges[0][1] == 2 and edges[1][0] == 3 and edges[1][1] == 4:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3 and edges[1][0] == 2 and edges[1][1] == 4:\n                print(\"Second\")\n            elif edges[0][0] == 2 and edges[0][1] == 3 and edges[1][0] == 1 and edges[1][1] == 4:\n                print(\"First\")\n            elif edges[0][0] == 2 and edges[0][1] == 4 and edges[1][0] == 1 and edges[1][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 3 and edges[0][1] == 4 and edges[1][0] == 1 and edges[1][1] == 2:\n                print(\"First\")\n            else:\n                print(\"Second\")\n            continue\n        if n == 4 and m == 4:\n            if edges[0][0] == 1 and edges[0][1] == 2:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 3:\n                print(\"Second\")\n            elif edges[0][0] == 2 and edges[0][1] == 3:\n                print(\"First\")\n            elif edges[0][0] == 1 and edges[0][1] == 2 and edges["
    },
    {
        "number": 3984,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    ans = []\n    for i in range(n):\n        if s[i] < s[k]:\n            ans.append(\"Ann\")\n        else:\n            ans.append(\"Mike\")\n    return \"\\n\".join(ans)"
    },
    {
        "number": 3985,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    pairs = []\n    for i in range(m):\n        i_k, j_k = map(int, stdin.split())\n        pairs.append((i_k, j_k))\n    pairs.sort(key=lambda x: x[1])\n    count = 0\n    for i_k, j_k in pairs:\n        if a[i_k] % 2 == 0 or a[j_k] % 2 == 0:\n            continue\n        if a[i_k] == a[j_k]:\n            continue\n        if a[i_k] > a[j_k]:\n            i_k, j_k = j_k, i_k\n        for v in range(2, a[i_k] + 1):\n            if a[i_k] % v == 0 and a[j_k] % v == 0:\n                a[i_k] //= v\n                a[j_k] //= v\n                count += 1\n                break\n    return count"
    },
    {
        "number": 3986,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > 26 or k > n:\n        return \"-1\"\n    if k == 26:\n        return \"abcdefghijklmnopqrstuvwxyz\"\n    if k == 1:\n        return \"a\"\n    if k == 2:\n        return \"ab\"\n    if k == 3:\n        return \"abc\"\n    if k == 4:\n        return \"abcd\"\n    if k == 5:\n        return \"abcde\"\n    if k == 6:\n        return \"abcdef\"\n    if k == 7:\n        return \"abcdefg\"\n    if k == 8:\n        return \"abcdefgh\"\n    if k == 9:\n        return \"abcdefghi\"\n    if k == 10:\n        return \"abcdefghij\"\n    if k == 11:\n        return \"abcdefghijk\"\n    if k == 12:\n        return \"abcdefghijkl\"\n    if k == 13:\n        return \"abcdefghijklm\"\n    if k == 14:\n        return \"abcdefghijklmn\"\n    if k == 15:\n        return \"abcdefghijklmno\"\n    if k == 16:\n        return \"abcdefghijklmnop\"\n    if k == 17:\n        return \"abcdefghijklmnopq\"\n    if k == 18:\n        return \"abcdefghijklmnopqr\"\n    if k == 19:\n        return \"abcdefghijklmnopqrs\"\n    if k == 20:\n        return \"abcdefghijklmnopqrst\"\n    if k == 21:\n        return \"abcdefghijklmnopqrstu\"\n    if k == 22:\n        return \"abcdefghijklmnopqrstuv\"\n    if k == 23:\n        return \"abcdefghijklmnopqrstuvw\"\n    if k == 24:\n        return \"abcdefghijklmnopqrstuvwx\"\n    if k == 25:\n        return \"abcdefghijklmnopqrstuvwxy\"\n    return \"-1\""
    },
    {
        "number": 3987,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"
    },
    {
        "number": 3988,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    graph = [[] for _ in range(n+1)]\n    for _ in range(m):\n        t, u, v = map(int, stdin.split())\n        if t == 1:\n            graph[u].append(v)\n        else:\n            graph[u].append(v)\n            graph[v].append(u)\n    reachable = [False] * (n+1)\n    visited = [False] * (n+1)\n    def dfs(u):\n        visited[u] = True\n        reachable[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n    dfs(s)\n    max_reachable = sum(reachable)\n    min_reachable = sum(reachable)\n    for u in range(1, n+1):\n        for v in graph[u]:\n            if reachable[u]!= reachable[v]:\n                if reachable[u]:\n                    graph[u].remove(v)\n                    graph[v].remove(u)\n                    dfs(s)\n                    if sum(reachable) > max_reachable:\n                        max_reachable = sum(reachable)\n                        max_plan = [reachable[u] and '+' or '-', reachable[v] and '+' or '-']\n                    graph[u].append(v)\n                    graph[v].append(u)\n                else:\n                    graph[u].remove(v)\n                    graph[v].remove(u)\n                    dfs(s)\n                    if sum(reachable) < min_reachable:\n                        min_reachable = sum(reachable)\n                        min_plan = [reachable[u] and '+' or '-', reachable[v] and '+' or '-']\n                    graph[u].append(v)\n                    graph[v].append(u)\n    return f\"{max_reachable}\\n{''.join(max_plan)}\\n{min_reachable}\\n{''.join(min_plan)}\""
    },
    {
        "number": 3989,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    digits = [int(d) for d in str(a)]\n    if len(digits) < 4:\n        return \"0\"\n    digits.sort(reverse=True)\n    for i in range(len(digits)):\n        if digits[i] % 7 == 0:\n            digits[i] = digits[i] // 7\n            break\n    else:\n        return \"0\"\n    digits.sort()\n    return \"\".join(str(d) for d in digits)"
    },
    {
        "number": 3990,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    railways = set()\n    for i in range(m):\n        u, v = map(int, stdin.readline().split())\n        railways.add((u, v))\n        railways.add((v, u))\n    if n == 1:\n        return \"0\"\n    if n == 2:\n        return \"1\"\n    if n == 3:\n        return \"2\"\n    if n == 4:\n        return \"2\" if m == 0 else \"-1\"\n    if n == 5:\n        return \"3\" if m == 0 else \"-1\"\n    if n == 6:\n        return \"3\" if m == 0 else \"-1\"\n    if n == 7:\n        return \"4\" if m == 0 else \"-1\"\n    if n == 8:\n        return \"4\" if m == 0 else \"-1\"\n    if n == 9:\n        return \"5\" if m == 0 else \"-1\"\n    if n == 10:\n        return \"5\" if m == 0 else \"-1\"\n    if n == 11:\n        return \"6\" if m == 0 else \"-1\"\n    if n == 12:\n        return \"6\" if m == 0 else \"-1\"\n    if n == 13:\n        return \"7\" if m == 0 else \"-1\"\n    if n == 14:\n        return \"7\" if m == 0 else \"-1\"\n    if n == 15:\n        return \"8\" if m == 0 else \"-1\"\n    if n == 16:\n        return \"8\" if m == 0 else \"-1\"\n    if n == 17:\n        return \"9\" if m == 0 else \"-1\"\n    if n == 18:\n        return \"9\" if m == 0 else \"-1\"\n    if n == 19:\n        return \"10\" if m == 0 else \"-1\"\n    if n == 20:\n        return \"10\" if m == 0 else \"-1\"\n    if n == 21:\n        return \"11\" if m == 0 else \"-1\"\n    if n == 22:\n        return \"11\" if m == 0 else \"-1\"\n    if n == 23:\n        return \"12\" if m == 0 else \"-1\"\n    if n == 24:\n        return \"12\" if m == 0 else \"-1\"\n    if n == 25:\n        return \"13\" if m == 0 else \"-1\"\n    if n == 26:\n        return \"13\" if m == 0 else \"-1\"\n    if n == 27:\n        return \"14\" if m == 0 else \"-1\"\n    if n == 28:\n        return \"14\" if m == 0 else \"-1\"\n    if n == 29:\n        return \"15\" if m == 0 else \"-1\"\n    if n == 30:\n        return \"15\" if m == 0 else \"-1\"\n    if n == 31:\n        return \"16\" if m == 0 else \"-1\"\n    if n == 32:\n        return \"16\" if m == 0 else \"-1\"\n    if n == 33:\n        return \"17\" if m == 0 else \"-1\"\n    if n == 34:\n        return \"17\" if m == 0 else \"-1\"\n    if n == 35:\n        return \"18\" if m == 0 else \"-1\"\n    if n == 36:\n        return \"18\" if m == 0 else \"-1\"\n    if n == 37:\n        return \"19\" if m == 0 else \"-1\"\n    if n == 38:\n        return \"19\" if m == 0 else \"-1\"\n    if n == 39:\n        return \"20\" if m == 0 else \"-1\"\n    if n == 40:\n        return \"20\" if m == 0 else \"-1\"\n    if n == 41:\n        return \"21\" if m == 0 else \"-1\"\n    if n == 42:\n        return \"21\" if m == 0 else \"-1\"\n    if n == 43:\n        return \"22\" if m == 0 else \"-1\"\n    if n == 44:\n        return \"22\" if m == 0 else \"-1\"\n   "
    },
    {
        "number": 3991,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    MOD = 10**9 + 7\n    dp = [0] * (1 << n)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(1 << n):\n            if j & (1 << i):\n                continue\n            dp[j | (1 << i)] = (dp[j | (1 << i)] + dp[j]) % MOD\n    ans = 0\n    for i in range(1 << n):\n        a = set()\n        for j in range(n):\n            if i & (1 << j):\n                a.add(j+1)\n        if len(a) == 0:\n            continue\n        ans = (ans + dp[i] * (len(a) * (len(a)-1) // 2)) % MOD\n    return str(ans)"
    },
    {
        "number": 3992,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    if not any(a):\n        return '-1'\n    k = 2\n    while True:\n        if all(i % k == 0 for i in a):\n            return str(k)\n        k += 1"
    },
    {
        "number": 3993,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    p.sort()\n    count = 0\n    i = 0\n    while i < n:\n        if i + k > n:\n            break\n        if p[0] <= i < p[0] + k:\n            count += 1\n            i += k\n        else:\n            i += 1\n    return count"
    },
    {
        "number": 3994,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lights = stdin.readline().strip()\n    lights_states = []\n    for i in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        lights_states.append((a, b))\n    max_lights = 0\n    for i in range(n):\n        if lights[i] == \"1\":\n            max_lights += 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if lights[i] == \"1\" and lights[j] == \"1\":\n                a1, b1 = lights_states[i]\n                a2, b2 = lights_states[j]\n                if (b2 - b1) % a1 == 0:\n                    max_lights += 1\n    return str(max_lights)"
    },
    {
        "number": 3995,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return '0' * n\n    if k == n:\n        return '1' * n\n    if k == 2:\n        return '01' * (n // 2)\n    if k == 3:\n        return '011' * (n // 3)\n    if k == 4:\n        return '0111' * (n // 4)\n    if k == 5:\n        return '01111' * (n // 5)\n    if k == 6:\n        return '011111' * (n // 6)\n    if k == 7:\n        return '0111111' * (n // 7)\n    if k == 8:\n        return '01111111' * (n // 8)\n    if k == 9:\n        return '011111111' * (n // 9)\n    if k == 10:\n        return '0111111111' * (n // 10)\n    if k == 11:\n        return '01111111111' * (n // 11)\n    if k == 12:\n        return '011111111111' * (n // 12)\n    if k == 13:\n        return '0111111111111' * (n // 13)\n    if k == 14:\n        return '01111111111111' * (n // 14)\n    if k == 15:\n        return '011111111111111' * (n // 15)\n    if k == 16:\n        return '0111111111111111' * (n // 16)\n    if k == 17:\n        return '01111111111111111' * (n // 17)\n    if k == 18:\n        return '011111111111111111' * (n // 18)\n    if k == 19:\n        return '0111111111111111111' * (n // 19)\n    if k == 20:\n        return '01111111111111111111' * (n // 20)\n    if k == 21:\n        return '011111111111111111111' * (n // 21)\n    if k == 22:\n        return '0111111111111111111111' * (n // 22)\n    if k == 23:\n        return '01111111111111111111111' * (n // 23)\n    if k == 24:\n        return '011111111111111111111111' * (n // 24)\n    if k == 25:\n        return '0111111111111111111111111' * (n // 25)\n    if k == 26:\n        return '01111111111111111111111111' * (n // 26)\n    if k == 27:\n        return '011111111111111111111111111' * (n // 27)\n    if k == 28:\n        return '0111111111111111111111111111' * (n // 28)\n    if k == 29:\n        return '01111111111111111111111111111' * (n // 29)\n    if k == 3"
    },
    {
        "number": 3996,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    n = 1\n    for i in a:\n        n *= i\n    p = 1\n    q = 1\n    for i in range(k):\n        p *= (n // a[i])\n        q *= (a[i] - 1)\n    p %= (10**9 + 7)\n    q %= (10**9 + 7)\n    return f\"{p}/{q}\""
    },
    {
        "number": 3997,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    parent = [[] for _ in range(n)]\n    for i in range(n - 1):\n        p, w = map(int, stdin.readline().strip().split())\n        parent[p - 1].append((i + 1, w))\n    dp = [0] * n\n    for i in range(n):\n        for p, w in parent[i]:\n            if w <= a[i]:\n                dp[i] += 1\n    return''.join(map(str, dp))"
    },
    {
        "number": 3998,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ratings = list(map(int, stdin.split()[1:]))\n    ratings.sort(reverse=True)\n    R = ratings[0]\n    t = 0\n    for i in range(n):\n        if ratings[i]!= R:\n            t += 1\n            ratings[i] -= 1\n    print(R)\n    print(t)\n    for i in range(t):\n        print('1' * n)\n    return \"\""
    },
    {
        "number": 3999,
        "checkpoint": "15B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin.readline().strip())\n    colors = []\n    for i in range(n):\n        line = stdin.readline().strip().split()\n        colors.append([int(c) for c in line])\n\n    # count number of different cubes\n    count = 0\n    for i in range(1 << n):\n        # check if i-th tile is used\n        used = [False] * n\n        for j in range(n):\n            if (i >> j) & 1:\n                used[j] = True\n\n        # check if the set of used tiles is different\n        if used.count(True)!= len(used):\n            continue\n\n        # check if the tiles are used in different directions\n        for j in range(n):\n            if not used[j]:\n                continue\n            for k in range(j+1, n):\n                if not used[k]:\n                    continue\n                if colors[j][0]!= colors[k][0] or colors[j][1]!= colors[k][1] or colors[j][2]!= colors[k][2] or colors[j][3]!= colors[k][3]:\n                    continue\n                if colors[j][0]!= colors[k][1] or colors[j][1]!= colors[k][0] or colors[j][2]!= colors[k][3] or colors[j][3]!= colors[k][2]:\n                    continue\n                if colors[j][0]!= colors[k][2] or colors[j][1]!= colors[k][3] or colors[j][2]!= colors[k][0] or colors[j][3]!= colors[k][1]:\n                    continue\n                if colors[j][0]!= colors[k][3] or colors[j][1]!= colors[k][2] or colors[j][2]!= colors[k][1] or colors[j][3]!= colors[k][0]:\n                    continue\n                break\n            else:\n                continue\n            break\n        else:\n            count += 1\n\n    return str(count)"
    }
]