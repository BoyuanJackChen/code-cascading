[
    {
        "number": 3000,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tokens = stdin.split()[1:]\n    stack = []\n    result = 0\n\n    for token in tokens:\n        if token == \"(\":\n            stack.append(token)\n        elif token == \")\":\n            if not stack:\n                return \"0\"\n            top = stack.pop()\n            if top == \"(\":\n                result = (result + 1) % (10**9 + 7)\n            else:\n                result = (result + 1) % (10**9 + 7) * int(top)\n        else:\n            result = (result + 1) % (10**9 + 7) * int(token)\n\n    return str(result)"
    },
    {
        "number": 3001,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    wheels = [int(digit) for digit in stdin]\n    steps = 0\n    while not is_palindrome(wheels):\n        steps += 1\n        for i in range(len(wheels) - 1, -1, -1):\n            wheels[i] += 1\n            if wheels[i] < 10:\n                break\n            wheels[i] = 0\n    return str(steps)\n\ndef"
    },
    {
        "number": 3002,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    entries = [list(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    service_history = sorted(entries, key=lambda x: (x[0], x[1]))\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2]) for i in range(len(service_history)) if service_history[i][2]!= 0]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i in range(len(service_history))]\n    service_history = [(service_history[i][0], service_history[i][1], service_history[i][2] - service_history[i - 1][2] if i > 0 else 0) for i"
    },
    {
        "number": 3003,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:3])\n        graph[u].append(v)\n        graph[v].append(u)\n    colors = set()\n    visited = set()\n    def dfs(u):\n        if u in visited:\n            return\n        visited.add(u)\n        colors.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                dfs(v)\n    for u in range(n):\n        if u not in visited:\n            dfs(u)\n    return str(len(colors))"
    },
    {
        "number": 3004,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    offers = []\n    for i in range(n):\n        color, a, b = stdin.split()[1].split()\n        a, b = int(a), int(b)\n        offers.append((color, a, b))\n\n    colors = set()\n    for color, a, b in offers:\n        colors.add(color)\n\n    if len(colors) > 3:\n        return \"IMPOSSIBLE\"\n\n    colors = sorted(colors)\n    colors_used = 0\n    min_offers = 0\n\n    for color, a, b in offers:\n        if colors_used >= 3:\n            break\n\n        if color == colors[colors_used]:\n            colors_used += 1\n            min_offers += 1\n\n    if colors_used < 3:\n        return \"IMPOSSIBLE\"\n\n    return str(min_offers)"
    },
    {
        "number": 3005,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.upper()\n    n = len(s)\n    max_weight = 0\n    max_factoring = \"\"\n\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            weight = 2\n        else:\n            weight = 1\n\n        if i == 1 or s[i]!= s[i - 1]:\n            if weight > max_weight:\n                max_weight = weight\n                max_factoring = s[i - 1] * (i - 1)\n\n    return str(max_weight)"
    },
    {
        "number": 3006,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    program1 = []\n    program2 = []\n\n    for line in stdin.split('\\n'):\n        if line[0] == 'D':\n            program1.append(('D', int(line[2:])))\n        elif line[0] == 'I':\n            program1.append(('I', int(line[2:]), line[line.index(' ')+1].upper()))\n        elif line[0] == 'E':\n            break\n\n    for line in stdin.split('\\n'):\n        if line[0] == 'D':\n            program2.append(('D', int(line[2:])))\n        elif line[0] == 'I':\n            program2.append(('I', int(line[2:]), line[line.index(' ')+1].upper()))\n        elif line[0] == 'E':\n            break\n\n    if program1 == program2:\n        return '0'\n    else:\n        return '1'"
    },
    {
        "number": 3007,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    bling = b\n    fruits = f\n    fruit_trees = [t0, t1, t2]\n    exotic_fruits = 0\n    exotic_fruit_trees = 0\n\n    for _ in range(d):\n        if fruits > 0:\n            bling += 100\n            fruits -= 1\n        if exotic_fruits > 0:\n            bling += 500\n            exotic_fruits -= 1\n        if exotic_fruit_trees > 0:\n            bling += 1500\n            exotic_fruit_trees -= 1\n\n        if fruit_trees[0] > 0:\n            fruit_trees[0] -= 1\n            bling += 100\n        if fruit_trees[1] > 0:\n            fruit_trees[1] -= 1\n            bling += 100\n        if fruit_trees[2] > 0:\n            fruit_trees[2] -= 1\n            bling += 100\n\n        if exotic_fruit_trees > 0:\n            exotic_fruit_trees -= 1\n            bling += 1500\n\n    return str(bling)"
    },
    {
        "number": 3008,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    assistants = list(map(int, stdin.split()))\n    assistants.sort(key=lambda x: (-x[0], -x[1]))\n    ranks = set()\n    for i in range(n):\n        if assistants[i][0] + k < assistants[i][1]:\n            ranks.add(i + 1)\n    return str(len(ranks))"
    },
    {
        "number": 3009,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lamps = []\n    for _ in range(n):\n        x, y, e = map(int, stdin.split()[1:])\n        lamps.append((x, y, e))\n    lamps.sort(key=lambda x: (x[0], x[1]))\n\n    def is_valid(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_2(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_3(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_4(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_5(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_6(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_7(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_8(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_valid_line_9(lamps, i, j):\n        for k in range(i, j):\n            if lamps[k][0] <= lamps[i][0] <= lamps[k][0] + 1 and lamps[k][1] <= lamps[i][1] <= lamps[k][1] + 1:\n                return False\n        return True\n\n    def is_"
    },
    {
        "number": 3010,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x0, y0, x1, y1 = map(int, stdin.split()[1:])\n        points.append((x0, y0))\n        points.append((x1, y1))\n    points = set(points)\n    count = 0\n    for p in points:\n        count += len(points.intersection(set(points) - {p}))\n    if count == 0:\n        return \"-1\"\n    else:\n        return str(count)"
    },
    {
        "number": 3011,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 10:\n        return -1\n    hill_count = 0\n    for i in range(1, n + 1):\n        if i % 10 == 0:\n            hill_count += 1\n        else:\n            if i % 10 == 9:\n                hill_count += 1\n            else:\n                hill_count += 2\n    return str(hill_count)"
    },
    {
        "number": 3012,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def count_sequences(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] * i) % MOD\n        return dp[n]\n\n    def is_valid_move(attacker: int, defender: int) -> bool:\n        return attacker!= defender\n\n    def count_valid_sequences(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                if is_valid_move(j, i):\n                    dp[i] = (dp[i] * dp[j]) % MOD\n        return dp[n]\n\n    def count_sequences_with_length(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] * i) % MOD\n        return dp[n]\n\n    def count_valid_sequences_with_length(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                if is_valid_move(j, i):\n                    dp[i] = (dp[i] * dp[j]) % MOD\n        return dp[n]\n\n    def count_sequences_with_length_and_gcd(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] * i) % MOD\n        return dp[n]\n\n    def count_valid_sequences_with_length_and_gcd(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                if is_valid_move(j, i):\n                    dp[i] = (dp[i] * dp[j]) % MOD\n        return dp[n]\n\n    def count_sequences_with_length_and_lcm(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] * i) % MOD\n        return dp[n]\n\n    def count_valid_sequences_with_length_and_lcm(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                if is_valid_move(j, i):\n                    dp[i] = (dp[i] * dp[j]) % MOD\n        return dp[n]\n\n    def count_sequences_with_length_and_gcd_and_lcm(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] * i) % MOD\n        return dp[n]\n\n    def count_valid_sequences_with_length_and_gcd_and_lcm(n: int) -> int:\n        MOD = 1000000007\n        dp = [1] * (n + 1)\n        for i in range(2, n + 1):\n            for j"
    },
    {
        "number": 3013,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    t = (tx, ty)\n    r = b * 2 * math.pi\n    x, y = 0, 0\n    dx, dy = 1, 0\n    steps = 0\n    while True:\n        steps += 1\n        x += dx\n        y += dy\n        if x**2 + y**2 > r**2:\n            dx, dy = -dy, dx\n        if x**2 + y**2 > t[0]**2 + t[1]**2:\n            break\n    x, y = x / steps, y / steps\n    return f\"{x:.5f} {y:.5f}\""
    },
    {
        "number": 3014,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: list(map(int, x.split())), stdin.split()[1:].split('\\n')):\n        corridors[u].append(v)\n        corridors[v].append(u)\n\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = [1]\n    removed = 0\n\n    while queue:\n        current = queue.pop(0)\n        for neighbor in corridors[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            removed += 1\n\n    return str(removed) + '\\n' + '\\n'.join(map(str, sorted(set(range(1, n + 1)) - set(queue))))"
    },
    {
        "number": 3015,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    balls = [[] for _ in range(n)]\n    for i in range(m):\n        a, b, w = map(int, stdin.split())\n        balls[a].append((b, w))\n        balls[b].append((a, w))\n    visited = [False] * n\n    visited[s] = True\n    queue = [(s, 0)]\n    while queue:\n        ball, time = queue.pop(0)\n        if ball == t:\n            return str(time)\n        for neighbor, weight in balls[ball]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append((neighbor, time + weight))\n    return \"infinity\""
    },
    {
        "number": 3016,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in k]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors = [colors[i] for i in range(n) if i not in l]\n    colors.sort()\n    colors ="
    },
    {
        "number": 3017,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') == e:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3018,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, t = map(int, stdin.split())\n    dice_rolls = list(map(int, stdin.split()))\n\n    # Calculate probability of getting target number\n    def probability(target, dice_rolls):\n        count = 0\n        for roll in dice_rolls:\n            if roll == target:\n                count += 1\n        return count / len(dice_rolls)\n\n    # Find the number of dice to pick up\n    def find_best_pick_up(dice_rolls, target):\n        best_pick_up = 0\n        best_probability = 1\n        for i in range(1, n + 1):\n            probability_i = probability(target, dice_rolls[:i])\n            if probability_i < best_probability:\n                best_pick_up = i\n                best_probability = probability_i\n        return best_pick_up\n\n    # Find the best pick up\n    best_pick_up = find_best_pick_up(dice_rolls, t)\n\n    # Print the result\n    print(best_pick_up)"
    },
    {
        "number": 3019,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = list(map(int, stdin.split()[1:]))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> list:\n        factors = []\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        for i in range(3, int(n ** 0.5) + 1, 2):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 2:\n            factors.append(n)\n        return factors\n\n    def max_revenue(S: list) -> int:\n        revenue = 0\n        for s in S:\n            factors = prime_factors(s)\n            distinct_factors = len(set(factors))\n            revenue += distinct_factors\n        return revenue\n\n    return str(max_revenue(S))"
    },
    {
        "number": 3020,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n\n    a = 1\n    while True:\n        a += 1\n        if a * a == N:\n            break\n\n    return str(a)"
    },
    {
        "number": 3021,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = list(stdin.split()[0])\n    words = stdin.split()[1:]\n\n    def is_consistent(word):\n        for i in range(len(word) - 1):\n            if word[i] > word[i + 1]:\n                return False\n        return True\n\n    def is_ambiguous(word):\n        for i in range(len(word) - 1):\n            if word[i] < word[i + 1]:\n                return True\n        return False\n\n    def find_order(word):\n        for i in range(len(word) - 1):\n            if word[i] > word[i + 1]:\n                return word[i], word[i + 1]\n        return word[-1], word[0]\n\n    def find_order_from_words(words):\n        for word in words:\n            if is_consistent(word):\n                return find_order(word)\n        return None\n\n    def find_order_from_alphabet(alphabet):\n        for i in range(len(alphabet) - 1):\n            if alphabet[i] > alphabet[i + 1]:\n                return alphabet[i], alphabet[i + 1]\n        return alphabet[-1], alphabet[0]\n\n    def find_order_from_words_and_alphabet(words, alphabet):\n        for word in words:\n            if is_consistent(word):\n                return find_order(word)\n        return find_order_from_alphabet(alphabet)\n\n    order = find_order_from_words_and_alphabet(words, alphabet)\n\n    if order is None:\n        return \"IMPOSSIBLE\"\n    elif is_ambiguous(order):\n        return \"AMBIGUOUS\"\n    else:\n        return \"\".join(order)\n"
    },
    {
        "number": 3022,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    cookies = [a, b, c]\n    cookies.sort()\n    total_cookies = sum(cookies)\n    max_cookies = total_cookies // n\n    leftover_cookies = total_cookies % n\n\n    for i in range(n):\n        if i < leftover_cookies:\n            cookies[i] += 1\n        else:\n            cookies[i] = 0\n\n    return str(max(cookies))"
    },
    {
        "number": 3023,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        candles.append((x, y))\n\n    cuts = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        cuts.append((a, b, c))\n\n    def is_valid(candles, cuts):\n        for cut in cuts:\n            x, y = 0, 0\n            for i in range(len(candles)):\n                x += candles[i][0] * i\n                y += candles[i][1] * i\n            if cut[0] * x + cut[1] * y + cut[2]!= 0:\n                return False\n        return True\n\n    if is_valid(candles, cuts):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3024,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    max_k = 0\n    for k in range(1, n + 1):\n        if is_palindrome(s, k):\n            max_k = k\n    return str(max_k)\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    g = list(map(int, stdin.split()))\n    g[0] = 0\n    g[1] = 0\n    g[2] = 0\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n    g.append(0)\n   "
    },
    {
        "number": 3026,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n    critical_elements = []\n\n    for i in range(n):\n        if sequence.count(i) == 1:\n            critical_elements.append(i)\n\n    if not critical_elements:\n        return \"-1\"\n\n    critical_elements.sort()\n    return \" \".join(map(str, critical_elements))"
    },
    {
        "number": 3027,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mark = [list(line.strip()) for line in stdin.splitlines()[1:]]\n    min_nubs = float('inf')\n\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                min_nubs = min(min_nubs, 2)\n\n    return str(min_nubs)"
    },
    {
        "number": 3028,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    board = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        board.append(row)\n\n    def is_winning_move(move: list) -> bool:\n        row, col = move\n        for i in range(n):\n            if board[i][col] == p:\n                return False\n        for i in range(m):\n            if board[row][i] == p:\n                return False\n        return True\n\n    def is_valid_move(move: list) -> bool:\n        row, col = move\n        if 0 <= row < n and 0 <= col < m:\n            return True\n        return False\n\n    def is_valid_move_and_not_winning(move: list) -> bool:\n        return is_valid_move(move) and not is_winning_move(move)\n\n    moves = []\n    for i in range(m):\n        for j in range(n):\n            if board[j][i] == p:\n                moves.append((j, i))\n\n    moves.sort(key=lambda x: (x[0], x[1]))\n\n    for move in moves:\n        if is_valid_move_and_not_winning(move):\n            board[move[0]][move[1]] += 1\n            moves.remove(move)\n            break\n\n    if moves:\n        return str(len(moves)) + \" \" + \" \".join(map(str, moves))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int, depth: int, path: List[int]) -> None:\n        nonlocal max_length, max_jumps, max_path\n        if node == 1:\n            return\n        if depth > max_length:\n            max_length = depth\n            max_jumps = 1\n            max_path = path\n        elif depth == max_length:\n            max_jumps += 1\n            if path not in max_path:\n                max_path.append(path)\n        dfs(parent, node, depth + 1, path + [node])\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def get_prime_divisor(n: int) -> int:\n        for i in range(11092019, 1, -1):\n            if is_prime(i) and n % i == 0:\n                return i\n        return 1\n\n    def get_jumping_paths(node: int, parent: int, depth: int, path: List[int]) -> List[List[int]]:\n        nonlocal jumping_paths\n        if node == 1:\n            return [path]\n        paths = get_jumping_paths(parent, node, depth + 1, path + [node])\n        for i in range(len(paths)):\n            for j in range(i + 1, len(paths)):\n                if paths[i] + paths[j] == [node]:\n                    paths[i].append(node)\n                    paths[j].append(node)\n        return paths\n\n    def main() -> None:\n        n = int(stdin.split()[0])\n        u = list(map(int, stdin.split()[1:]))\n        parent = [0] * (n + 1)\n        for i in range(1, n):\n            parent[i] = int(stdin.split()[i + 1])\n        dfs(1, 0, 1, [1])\n        max_length = 0\n        max_jumps = 0\n        max_path = []\n        for i in range(1, n):\n            dfs(i, parent[i], 1, [i])\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if u[i] < u[j]:\n                    dfs(i, j, 1, [i, j])\n        jumping_paths = get_jumping_paths(1, 0, 1, [1])\n        L = max_length\n        M = max_jumps\n        if L % 2 == 0:\n            L -= 1\n        M %= get_prime_divisor(11092019)\n        print(L, M)\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 3030,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nodes = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2*n, 2)]\n    nodes.sort(key=lambda x: x[0])\n    heap = []\n    for node in nodes:\n        if not heap or heap[-1][0] < node[0]:\n            heap.append(node)\n        else:\n            heapq.heappop(heap)\n            heapq.heappush(heap, node)\n    return str(len(heap))"
    },
    {
        "number": 3031,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    colors = set(map(lambda x: x[2], edges))\n    colors.remove(1)\n    colors.remove(n)\n    colors = list(colors)\n    colors.sort()\n    colors = [colors[0]] + colors + [colors[-1]]\n\n    def is_rainbow(path: list) -> bool:\n        for i in range(len(path) - 1):\n            if path[i][2] == path[i + 1][2]:\n                return False\n        return True\n\n    def find_good_nodes(node: int) -> list:\n        good_nodes = []\n        for color in colors:\n            path = [(node, color)]\n            while path:\n                current = path.pop(0)\n                if current[0] == node:\n                    good_nodes.append(current[0])\n                for neighbor, neighbor_color in edges:\n                    if neighbor == current[0]:\n                        continue\n                    if neighbor_color == color:\n                        path.append((neighbor, neighbor_color))\n        return good_nodes\n\n    good_nodes = []\n    for i in range(1, n):\n        good_nodes.extend(find_good_nodes(i))\n\n    return str(len(good_nodes)) + '\\n' + '\\n'.join(map(str, good_nodes))"
    },
    {
        "number": 3032,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split())\n    program = stdin.split()[2:]\n\n    def count_instructions(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_references(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_references(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n        return count\n\n    def count_banks(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_banks(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_banks_with_references(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_banks_with_references(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_banks_with_references_and_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_banks_with_references_and_bsr(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions_with_references(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references_and_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions_with_references_and_bsr(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references_and_bsr_set_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions_with_references_and_bsr_set_bsr(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references_and_bsr_set_bsr_set_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions_with_references_and_bsr_set_bsr_set_bsr(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references_and_bsr_set_bsr_set_bsr_set_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count += count_instructions_with_references_and_bsr_set_bsr_set_bsr_set_bsr(op[2:])\n            elif op[0] == \"V\":\n                count += 1\n            elif op[0] == \"E\":\n                count += 1\n        return count\n\n    def count_instructions_with_references_and_bsr_set_bsr_set_bsr_set_bsr_set_bsr(program: list) -> int:\n        count = 0\n        for op in program:\n            if op[0] == \"R\":\n                count"
    },
    {
        "number": 3033,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    if b < 2 or b > 10000 or n < 0 or n >= 2**63:\n        return \"impossible\"\n\n    def f(x):\n        return sum(int(digit) * b**(len(str(x)) - i - 1) for i, digit in enumerate(str(x)))\n\n    def g(x):\n        return f(x) - n\n\n    x = 0\n    while g(x) >= 0:\n        x += 1\n\n    if g(x) == 0:\n        return str(x)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3034,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    d, t, c, r = map(int, stdin.split())\n    clouds = []\n    for _ in range(c):\n        s, e, p, a = map(int, stdin.split())\n        clouds.append((s, e, p, a))\n    roofs = []\n    for _ in range(r):\n        x, y = map(int, stdin.split())\n        roofs.append((x, y))\n\n    # Calculate expected rainfall\n    rainfall = 0\n    for cloud in clouds:\n        if cloud[2] > 0.5:\n            rainfall += cloud[3] * (cloud[1] - cloud[0]) * cloud[2]\n\n    # Calculate expected time to reach bus stop\n    time_to_bus = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs\n    time_to_bus_with_roofs = d / 1000 / 1000 / 1000 * t\n    for x, y in roofs:\n        time_to_bus_with_roofs += (x - d) / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop without roofs\n    time_to_bus_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_with_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n    for x, y in roofs:\n        time_to_bus_with_roofs_without_roofs += (x - d) / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_with_roofs = d / 1000 / 1000 / 1000 * t\n    for x, y in roofs:\n        time_to_bus_without_roofs_with_roofs += (y - d) / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_with_roofs_without_roofs_with_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_with_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_without_roofs_with_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_with_roofs_without_roofs_with_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_with_roofs_without_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_without_roofs_with_roofs_without_roofs = d / 1000 / 1000 / 1000 * t\n\n    # Calculate expected time to reach bus stop with roofs and without roofs\n    time_to_bus_without_roofs_without_roofs_without_roofs_with_roofs = d / 1000 / 1000 / 1000 * t\n\n   "
    },
    {
        "number": 3035,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    children = []\n    for _ in range(n):\n        name, lemonade, rate = stdin.split()\n        children.append((name, lemonade, float(rate)))\n    children.sort(key=lambda x: x[2])\n    blue_lemonade = 0\n    for child in children:\n        if child[1] == 'blue':\n            blue_lemonade += 10\n            if blue_lemonade > 10:\n                break\n    return f\"{blue_lemonade:.6f}\""
    },
    {
        "number": 3036,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_unique_ingredients(ingredients: List[int]) -> int:\n        return len(set(ingredients))\n\n    def count_unique_brands(ingredients: List[int]) -> int:\n        return len(set(brands[i] for i in ingredients))\n\n    def count_unique_dishes(dishes: List[List[int]]) -> int:\n        return len(set(tuple(sorted(d)) for d in dishes))\n\n    def count_unique_dinner_experiences(r: int, s: int, m: int, d: int, n: int) -> int:\n        starter_ingredients = [int(x) for x in stdin.split()[2].split()]\n        main_ingredients = [int(x) for x in stdin.split()[3].split()]\n        dessert_ingredients = [int(x) for x in stdin.split()[4].split()]\n\n        starter_brands = [int(x) for x in stdin.split()[5].split()]\n        main_brands = [int(x) for x in stdin.split()[6].split()]\n        dessert_brands = [int(x) for x in stdin.split()[7].split()]\n\n        starter_dishes = [sorted(list(set(starter_ingredients[i] for i in starter_ingredients[:i+1]))) for i in range(s)]\n        main_dishes = [sorted(list(set(main_ingredients[i] for i in main_ingredients[:i+1]))) for i in range(m)]\n        dessert_dishes = [sorted(list(set(dessert_ingredients[i] for i in dessert_ingredients[:i+1]))) for i in range(d)]\n\n        incompatible_dishes = [sorted(list(set(int(x) for x in stdin.split()[i+8].split()))) for i in range(n)]\n\n        starter_unique_ingredients = count_unique_ingredients(starter_ingredients)\n        main_unique_ingredients = count_unique_ingredients(main_ingredients)\n        dessert_unique_ingredients = count_unique_ingredients(dessert_ingredients)\n\n        starter_unique_brands = count_unique_brands(starter_ingredients)\n        main_unique_brands = count_unique_brands(main_ingredients)\n        dessert_unique_brands = count_unique_brands(dessert_ingredients)\n\n        starter_unique_dishes = count_unique_dishes(starter_dishes)\n        main_unique_dishes = count_unique_dishes(main_dishes)\n        dessert_unique_dishes = count_unique_dishes(dessert_dishes)\n\n        starter_unique_dinner_experiences = 1\n        for i in range(s):\n            starter_unique_dinner_experiences *= starter_unique_ingredients * starter_unique_brands * starter_unique_dishes\n\n        main_unique_dinner_experiences = 1\n        for i in range(m):\n            main_unique_dinner_experiences *= main_unique_ingredients * main_unique_brands * main_unique_dishes\n\n        dessert_unique_dinner_experiences = 1\n        for i in range(d):\n            dessert_unique_dinner_experiences *= dessert_unique_ingredients * dessert_unique_brands * dessert_unique_dishes\n\n        incompatible_unique_dinner_experiences = 1\n        for i in range(n):\n            incompatible_unique_dinner_experiences *= count_unique_dishes(incompatible_dishes[i])\n\n        return min(starter_unique_dinner_experiences, main_unique_dinner_experiences, dessert_unique_dinner_experiences, incompatible_unique_dinner_experiences)\n\n    r, s, m, d, n = map(int, stdin.split()[0].split())\n    return str(count_unique_dinner_experiences(r, s, m, d, n))"
    },
    {
        "number": 3037,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split())\n    board = [list(line.strip()) for line in stdin.splitlines()[h+1:h+1+w]]\n    commands = stdin.splitlines()[h+1+w:]\n\n    def move(x, y, d):\n        if d == 'up':\n            return x, y-1\n        elif d == 'down':\n            return x, y+1\n        elif d == 'left':\n            return x-1, y\n        else:\n            return x+1, y\n\n    def dry_out(x, y):\n        return board[x][y] == '#'\n\n    def dry_out_at(x, y):\n        return dry_out(x, y) and dry_out(x, y-1) and dry_out(x, y+1) and dry_out(x-1, y) and dry_out(x+1, y)\n\n    def dry_out_at_timestep(timestep):\n        for x in range(w):\n            for y in range(h):\n                if dry_out_at(x, y):\n                    return x, y, timestep\n        return -1, -1, -1\n\n    dry_out_start = dry_out_at_timestep(0)\n    dry_out_end = dry_out_at_timestep(18)\n\n    if dry_out_start[2] == dry_out_end[2]:\n        return str(dry_out_start[2]) +'' + str(dry_out_end[2])\n    else:\n        return '-1 -1'"
    },
    {
        "number": 3038,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split())\n    companies = []\n    for i in range(k):\n        l, *n = map(int, stdin.split())\n        companies.append((l, n))\n\n    def min_pack_size(B, companies):\n        def min_pack_size_helper(B, companies, current_size, current_sum, min_size):\n            if current_sum > B:\n                return min_size\n            if current_sum == B:\n                return min(min_size, current_size)\n\n            for l, n in companies:\n                if current_size + l <= n[-1]:\n                    min_pack_size_helper(B, companies, current_size + l, current_sum + l * l, min_size)\n            return min_size\n\n        return min_pack_size_helper(B, companies, 0, 0, float('inf'))\n\n    return str(min_pack_size(B, companies))"
    },
    {
        "number": 3039,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Check if the input is valid\n    for line in stdin.split('\\n'):\n        if len(line)!= 6:\n            return \"cannot fold\"\n        for char in line:\n            if char not in ['.', '#']:\n                return \"cannot fold\"\n\n    # Check if the input can form a cube\n    for i in range(3):\n        for j in range(3):\n            if stdin[i][j] == '#' and stdin[i][j+1] == '#' and stdin[i][j+2] == '#' and stdin[i+1][j] == '#' and stdin[i+1][j+1] == '#' and stdin[i+1][j+2] == '#':\n                return \"can fold\"\n\n    return \"cannot fold\""
    },
    {
        "number": 3040,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a set to remove duplicates\n    input_set = set(stdin)\n\n    # Initialize variables for the longest substring and its length\n    longest_substring = \"\"\n    longest_length = 0\n\n    # Iterate through the input set\n    for i in range(len(input_set)):\n        # Initialize variables for the current substring and its length\n        current_substring = \"\"\n        current_length = 0\n\n        # Iterate through the input set again\n        for j in range(i, len(input_set)):\n            # Add the current character to the current substring\n            current_substring += input_set[j]\n\n            # Check if the current substring is longer than the longest substring\n            if len(current_substring) > longest_length:\n                # Update the longest substring and its length\n                longest_substring = current_substring\n                longest_length = len(current_substring)\n\n    # Return the longest substring\n    return longest_substring"
    },
    {
        "number": 3041,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trips = []\n    for _ in range(n):\n        zone, time = map(int, stdin.split()[1:])\n        trips.append((zone, time))\n    trips.sort(key=lambda x: x[1])\n    zones = set()\n    for zone, time in trips:\n        zones.add(zone)\n    min_coupons = 0\n    for i in range(len(trips)):\n        for j in range(i + 1, len(trips)):\n            if trips[i][0] < trips[j][0] and trips[i][0] in zones and trips[j][0] in zones:\n                min_coupons += 2 + abs(trips[i][0] - trips[j][0])\n                break\n    return str(min_coupons)"
    },
    {
        "number": 3042,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n\n    def dfs(node, parent, path):\n        if node == n:\n            return 1\n\n        ways = 0\n        for child in range(1, n + 1):\n            if child!= parent and (child in path or child in values):\n                continue\n\n            new_path = path.copy()\n            new_path.append(child)\n            ways += dfs(child, node, new_path)\n\n        return ways % (10**9 + 7)\n\n    return str(dfs(1, 0, []))"
    },
    {
        "number": 3043,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    grid = [list(row) for row in stdin.splitlines()]\n    stamina = k\n    days = 0\n\n    def move(x: int, y: int, dx: int, dy: int) -> bool:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < m and grid[nx][ny]!= '#' and grid[nx][ny]!= 'M':\n            grid[x][y] = '.'\n            grid[nx][ny] = grid[x][y]\n            return True\n        return False\n\n    while True:\n        days += 1\n        if stamina == 0:\n            return -1\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == 'S':\n                    if move(x, y, 0, 1):\n                        stamina -= 1\n                    if move(x, y, 0, -1):\n                        stamina -= 1\n                    if move(x, y, 1, 0):\n                        stamina -= 1\n                    if move(x, y, -1, 0):\n                        stamina -= 1\n        if grid[n - 1][m - 1] == 'G':\n            return days\n        if stamina == k:\n            stamina = 0"
    },
    {
        "number": 3044,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n    start = grid.index(['S'])\n    goal = grid.index(['G'])\n    obstacles = [grid.index(['#']) for row in grid for cell in row if cell == '#']\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < H and 0 <= y < W and x not in obstacles\n\n    def move(x: int, y: int, direction: str) -> tuple[int, int]:\n        if direction == 'L':\n            return x - 1, y\n        elif direction == 'R':\n            return x + 1, y\n        elif direction == 'U':\n            return x, y - 1\n        elif direction == 'D':\n            return x, y + 1\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    def is_goal(x: int, y: int) -> bool:\n        return x == goal[0] and y == goal[1]\n\n    def is_obstacle(x: int, y: int) -> bool:\n        return x in obstacles or y in obstacles\n\n    def is_valid_move(x: int, y: int, direction: str) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and not is_obstacle(nx, ny)\n\n    def is_valid_path(x: int, y: int, direction: str) -> bool:\n        if not is_valid_move(x, y, direction):\n            return False\n        nx, ny = move(x, y, direction)\n        return is_valid_path(nx, ny, direction)\n\n    def min_changes(x: int, y: int, direction: str) -> int:\n        if is_goal(x, y):\n            return 0\n        if is_obstacle(x, y):\n            return float('inf')\n        if is_valid_move(x, y, direction):\n            return 1 + min_changes(x, y, direction)\n        return min_changes(x, y, 'L') + min_changes(x, y, 'R') + min_changes(x, y, 'U') + min_changes(x, y, 'D')\n\n    changes = min_changes(start[0], start[1], 'L')\n    for i in range(len(stdin.split()[2])):\n        changes = min(changes, min_changes(start[0], start[1], stdin.split()[2][i]))\n    return str(changes)"
    },
    {
        "number": 3045,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    beacons = []\n    for line in stdin.split('\\n')[1:]:\n        x, y, d = map(int, line.split())\n        beacons.append((x, y, d))\n\n    receiver_positions = set()\n    for beacon in beacons:\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dx == 0 and dy == 0:\n                    continue\n                x, y, d = beacon\n                x += dx\n                y += dy\n                if (x, y) in receiver_positions:\n                    receiver_positions.remove((x, y))\n                else:\n                    receiver_positions.add((x, y))\n\n    if len(receiver_positions) == 1:\n        x, y = receiver_positions.pop()\n        return f\"{x} {y}\"\n    elif len(receiver_positions) == 0:\n        return \"impossible\"\n    else:\n        return \"uncertain\""
    },
    {
        "number": 3046,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    corners = []\n    for i in range(n):\n        row, col = map(int, stdin.split()[1:3])\n        corners.append((row, col))\n    corners.sort()\n    for i in range(n):\n        if corners[i][0] == corners[i][1]:\n            return \"syntax error\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if corners[i][0] < corners[j][0] and corners[i][1] > corners[j][1]:\n                return str(i + 1) + \" \" + str(j + 1)\n    return \"syntax error\""
    },
    {
        "number": 3047,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_solutions(plates: List[int]) -> int:\n        plates.sort()\n        n = len(plates)\n        if n == 1:\n            return 1\n        if plates[0] == 0:\n            return 0\n        if plates[0] == 1:\n            return count_solutions(plates[1:])\n        if plates[0] == 2:\n            return count_solutions(plates[1:]) * count_solutions(plates[2:])\n        if plates[0] == 3:\n            return count_solutions(plates[1:]) * count_solutions(plates[2:]) * count_solutions(plates[3:])\n        if plates[0] == 4:\n            return count_solutions(plates[1:]) * count_solutions(plates[2:]) * count_solutions(plates[3:]) * count_solutions(plates[4:])\n\n    plates = [int(x) for x in stdin.split()]\n    return str(count_solutions(plates))"
    },
    {
        "number": 3048,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    junctions = list(map(int, stdin.split()[1:]))\n    junctions.sort()\n    paths = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            paths.append((junctions[i], junctions[j]))\n    paths.sort()\n    count = 0\n    for i in range(len(paths) - 1):\n        if paths[i][0]!= paths[i + 1][0] and paths[i][1]!= paths[i + 1][1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3049,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_message = encrypted_message.lower()\n    decrypted_fragment = decrypted_fragment.lower()\n\n    encrypted_message_length = len(encrypted_message)\n    decrypted_fragment_length = len(decrypted_fragment)\n\n    for i in range(encrypted_message_length):\n        if encrypted_message[i:i+decrypted_fragment_length] == decrypted_fragment:\n            return encrypted_message[i:i+decrypted_fragment_length]\n\n    return encrypted_message_length - decrypted_fragment_length"
    },
    {
        "number": 3050,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    program = stdin.split()[1]\n    grid = [list(row) for row in stdin.split()[2:]]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < N and grid[x][y]!= '#'\n\n    def move(x: int, y: int, direction: str) -> tuple[int, int]:\n        if direction == '<':\n            return x - 1, y\n        elif direction == '>':\n            return x + 1, y\n        elif direction == '^':\n            return x, y - 1\n        elif direction == 'v':\n            return x, y + 1\n        else:\n            raise ValueError(f\"Invalid direction: {direction}\")\n\n    def is_impassable(x: int, y: int) -> bool:\n        return not is_valid(x, y)\n\n    def is_empty(x: int, y: int) -> bool:\n        return grid[x][y] == '.'\n\n    def is_robot(x: int, y: int) -> bool:\n        return grid[x][y] == 'R'\n\n    def is_robot_at(x: int, y: int) -> bool:\n        return is_robot(x, y) and is_empty(x, y)\n\n    def is_robot_at_start(x: int, y: int) -> bool:\n        return is_robot(x, y) and x == 0 and y == 0\n\n    def is_robot_at_end(x: int, y: int) -> bool:\n        return is_robot(x, y) and x == N - 1 and y == N - 1\n\n    def is_robot_at_border(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1)\n\n    def is_robot_at_corner(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1)\n\n    def is_robot_at_corner_or_border(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1)\n\n    def is_robot_at_corner_or_border_or_empty(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1 or grid[x][y] == '.')\n\n    def is_robot_at_corner_or_border_or_empty_or_impassable(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1 or grid[x][y] == '.' or grid[x][y] == '#')\n\n    def is_robot_at_corner_or_border_or_empty_or_impassable_or_robot_at_start(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1 or grid[x][y] == '.' or grid[x][y] == '#' or is_robot_at_start(x, y))\n\n    def is_robot_at_corner_or_border_or_empty_or_impassable_or_robot_at_start_or_robot_at_end(x: int, y: int) -> bool:\n        return is_robot(x, y) and (x == 0 or x == N - 1 or y == 0 or y == N - 1 or grid[x][y] == '.' or grid[x][y] == '#' or is_robot_at_start(x, y) or is_robot_at_end(x, y))\n\n    def is_robot_at_corner_or_border_or_empty_or_impassable_or_robot_at_start_or_robot_at_end_or_robot_at_corner_or_border_or_empty_or_impassable_or_robot"
    },
    {
        "number": 3051,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fogs = []\n    for i in range(n):\n        m, d, l, r, h, dx, dh = map(int, stdin.split()[1:])\n        fogs.append((m, d, l, r, h, dx, dh))\n    missed = 0\n    for i in range(1, len(fogs)):\n        m, d, l, r, h, dx, dh = fogs[i]\n        missed += (m - 1) * (i - 1)\n    return str(missed)"
    },
    {
        "number": 3052,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    x_a, y_a, x_b, y_b = map(float, stdin.split())\n    n = int(stdin.split()[1])\n    conveyors = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, stdin.split())\n        conveyors.append((x1, y1, x2, y2))\n\n    # Calculate minimum time\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_time(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return 0\n        if x1 == x2:\n            return distance(y1, 0, y2, 0)\n        if y1 == y2:\n            return distance(0, x1, 0, x2)\n\n        dx = x2 - x1\n        dy = y2 - y1\n        t = dx / (dx ** 2 + dy ** 2)\n        x = x1 + t * dx\n        y = y1 + t * dy\n        return distance(x1, y1, x, y)\n\n    def min_time_on_conveyor(x1, y1, x2, y2, conveyor):\n        x1, y1, x2, y2 = map(int, map(lambda x: round(x), [x1, y1, x2, y2]))\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x + 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x - 1, [x1, y1, x2, y2])\n        x1, y1, x2, y2 = map(lambda x: x +"
    },
    {
        "number": 3053,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def has_k_distinct_chars(s: str) -> bool:\n        return len(set(s)) == K\n\n    def has_longest_palindromic_substring(s: str) -> bool:\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_palindrome(s[i:j]):\n                    return True\n        return False\n\n    def is_valid_string(s: str) -> bool:\n        return len(s) == N and has_k_distinct_chars(s) and has_longest_palindromic_substring(s)\n\n    def find_perfect_symmetry(s: str) -> str:\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                for k in range(j + 1, len(s) + 1):\n                    for l in range(k + 1, len(s) + 1):\n                        for m in range(l + 1, len(s) + 1):\n                            for n in range(m + 1, len(s) + 1):\n                                for o in range(n + 1, len(s) + 1):\n                                    for p in range(o + 1, len(s) + 1):\n                                        for q in range(p + 1, len(s) + 1):\n                                            for r in range(q + 1, len(s) + 1):\n                                                for s in range(r + 1, len(s) + 1):\n                                                    for t in range(s + 1, len(s) + 1):\n                                                        for u in range(t + 1, len(s) + 1):\n                                                            for v in range(u + 1, len(s) + 1):\n                                                                for w in range(v + 1, len(s) + 1):\n                                                                    for x in range(w + 1, len(s) + 1):\n                                                                        for y in range(x + 1, len(s) + 1):\n                                                                            for z in range(y + 1, len(s) + 1):\n                                                                                if is_valid_string(s[i:i + P] + s[j:j + P] + s[k:k + P] + s[l:l + P] + s[m:m + P] + s[n:n + P] + s[o:o + P] + s[p:p + P] + s[q:q + P] + s[r:r + P] + s[s:s + P] + s[t:t + P] + s[u:u + P] + s[v:v + P] + s[w:w + P] + s[x:x + P] + s[y:y + P] + s[z:z + P]):\n                                                                                    return s[i:i + P] + s[j:j + P] + s[k:k + P] + s[l:l + P] + s[m:m + P] + s[n:n + P] + s[o:o + P] + s[p:p + P] + s[q:q + P] + s[r:r + P] + s[s:s + P] + s[t:t + P] + s[u:u + P] + s[v:v + P] + s[w:w + P] + s[x:x + P] + s[y:y + P] + s[z:z + P]\n\n    perfect_symmetry = find_perfect_symmetry(\"abcdefghijklmnopqrstuvwxyz\")\n    if perfect_symmetry:\n        return perfect_symmetry\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3054,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    syllables = 0\n    syllable_count = 0\n    syllable_start = 0\n    syllable_end = 0\n    haiku = []\n\n    for i, word in enumerate(words):\n        syllable_count = 0\n        syllable_start = 0\n        syllable_end = 0\n\n        for j, char in enumerate(word):\n            if char.isalpha():\n                if char.isupper():\n                    syllable_count += 1\n                elif char.islower():\n                    syllable_count += 1\n                else:\n                    syllable_count += 1\n            else:\n                syllable_count += 1\n\n            if j == len(word) - 1:\n                syllable_end = j\n            else:\n                syllable_end = j + 1\n\n            if syllable_count == 1:\n                syllable_start = j\n                syllable_end = j + 1\n\n        if syllable_count >= 5 and syllable_count <= 7:\n            syllables += syllable_count\n            syllable_count = 0\n            syllable_start = 0\n            syllable_end = 0\n\n            if syllable_start == 0:\n                haiku.append(word)\n            else:\n                haiku.append(word[:syllable_start] + word[syllable_end:])\n\n    if syllables >= 5 and syllables <= 7:\n        for word in words:\n            syllable_count = 0\n            syllable_start = 0\n            syllable_end = 0\n\n            for j, char in enumerate(word):\n                if char.isalpha():\n                    if char.isupper():\n                        syllable_count += 1\n                    elif char.islower():\n                        syllable_count += 1\n                    else:\n                        syllable_count += 1\n                else:\n                    syllable_count += 1\n\n                if j == len(word) - 1:\n                    syllable_end = j\n                else:\n                    syllable_end = j + 1\n\n                if syllable_count == 1:\n                    syllable_start = j\n                    syllable_end = j + 1\n\n            if syllable_count >= 5 and syllable_count <= 7:\n                syllables += syllable_count\n                syllable_count = 0\n                syllable_start = 0\n                syllable_end = 0\n\n                if syllable_start == 0:\n                    haiku.append(word)\n                else:\n                    haiku.append(word[:syllable_start] + word[syllable_end:])\n\n        if syllables >= 5 and syllables <= 7:\n            haiku.append('')\n            haiku.append('')\n            haiku.append('')\n\n    return '\\n'.join(haiku)"
    },
    {
        "number": 3055,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.split('\\n')\n    names.remove('ThoreHusfeldt')\n    names.sort(key=lambda x: (-len(x), x))\n    for i, name in enumerate(names):\n        if 'ThoreHusfeldt' in name:\n            return 'Thore is awesome'\n        if 'ThoreHusfeld' in name:\n            return 'Thore sucks'\n    return 'Thore is awesome'"
    },
    {
        "number": 3056,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int, depth: int, path: str, result: list) -> None:\n        if node == 1:\n            result.append(depth)\n            return\n        if node % 2 == 0:\n            left = 2 * node\n            right = 2 * node + 1\n        else:\n            left = 2 * node - 1\n            right = 2 * node\n        if left == parent:\n            dfs(right, node, depth + 1, path + \"R\", result)\n        elif right == parent:\n            dfs(left, node, depth + 1, path + \"L\", result)\n        else:\n            dfs(left, node, depth + 1, path + \"P\", result)\n            dfs(right, node, depth + 1, path + \"P\", result)\n\n    def count_walks(walks: str) -> int:\n        result = []\n        dfs(1, 0, 0, \"\", result)\n        walks_set = set(walks)\n        return sum(w for w in result if w in walks_set)\n\n    walks = stdin.strip()\n    return str(count_walks(walks))\n"
    },
    {
        "number": 3057,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    statements = []\n    for _ in range(n):\n        statement = stdin.split()[1]\n        if statement.startswith(\"not \"):\n            statements.append((statement[4:], statement[4:]))\n        else:\n            statements.append((statement, statement))\n    for i in range(len(statements)):\n        for j in range(i + 1, len(statements)):\n            if statements[i][0] == statements[j][1] or statements[i][1] == statements[j][0]:\n                return \"wait what?\"\n    return \"yes\""
    },
    {
        "number": 3058,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    current_sequence = stdin.split('\\n')[1]\n    fossil_sequences = stdin.split('\\n')[2:]\n\n    def is_parallel_evolution(sequence1: str, sequence2: str) -> bool:\n        return sequence1 == sequence2\n\n    def find_evolutionary_path(sequence: str) -> str:\n        if is_parallel_evolution(sequence, current_sequence):\n            return 'first'\n        else:\n            return'second'\n\n    def find_evolutionary_paths(sequences: List[str]) -> Tuple[List[str], List[str]]:\n        first_path = []\n        second_path = []\n        for sequence in sequences:\n            path = find_evolutionary_path(sequence)\n            if path == 'first':\n                first_path.append(sequence)\n            else:\n                second_path.append(sequence)\n        return first_path, second_path\n\n    first_path, second_path = find_evolutionary_paths(fossil_sequences)\n\n    if len(first_path) == 0 or len(second_path) == 0:\n        return 'impossible'\n\n    first_path.sort()\n    second_path.sort()\n\n    return f'{len(first_path)} {len(second_path)}' + '\\n' + '\\n'.join(first_path) + '\\n' + '\\n'.join(second_path)"
    },
    {
        "number": 3059,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split())\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, stdin.split())\n        tricks.append((t, p, d))\n    tricks.sort(key=lambda x: x[0])\n\n    def reset_game(tricks, n, r):\n        total_time = 0\n        for t, p, d in tricks:\n            if total_time + t <= r:\n                total_time += t\n            else:\n                return total_time\n        return total_time\n\n    def expected_time(tricks, n, r):\n        total_time = 0\n        for t, p, d in tricks:\n            if total_time + t <= r:\n                total_time += t\n            else:\n                return total_time\n        return total_time\n\n    return str(expected_time(tricks, n, r))"
    },
    {
        "number": 3060,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    valid_sequences = [tuple(map(int, line.split())) for line in open(\"valid_sequences.txt\")]\n    valid_sequences.sort()\n    return \" \".join(map(str, valid_sequences[k-1]))"
    },
    {
        "number": 3061,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [[] for _ in range(n + 1)]\n    for u, v in stdin.split()[1:]:\n        u, v = int(u), int(v)\n        roads[u].append(v)\n        roads[v].append(u)\n\n    blocked_roads = set()\n    for u, v in stdin.split()[1:]:\n        u, v = int(u), int(v)\n        blocked_roads.add((u, v))\n\n    def dfs(station, path_length, blocked_roads):\n        if station in blocked_roads:\n            return 0, 0\n\n        if len(path) == path_length:\n            return 1, 0\n\n        max_length = 0\n        for neighbor in roads[station]:\n            if neighbor not in blocked_roads:\n                new_path = path + [neighbor]\n                length, time = dfs(neighbor, path_length, blocked_roads)\n                max_length = max(max_length, length + time)\n\n        return max_length, 1\n\n    path_length = 1\n    max_length, time = dfs(1, path_length, blocked_roads)\n    return str(max_length)"
    },
    {
        "number": 3062,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split()[0].split())\n    v, w = map(float, stdin.split()[1].split())\n\n    dx = x - 0\n    dy = y - 0\n\n    if dx == 0 and dy == 0:\n        return \"0.000\"\n\n    if dx == 0:\n        dy = -dy\n        if dy > 0:\n            dx = 1\n        else:\n            dx = -1\n\n    if dy == 0:\n        dx = -dx\n        if dx > 0:\n            dy = 1\n        else:\n            dy = -1\n\n    if dx == 0:\n        return \"0.000\"\n\n    if dy == 0:\n        return \"0.000\"\n\n    if dx > 0:\n        if dy > 0:\n            return str(abs(dx) / v)\n        else:\n            return str(abs(dx) / v) + \" + \" + str(abs(dy) / v)\n    else:\n        if dy > 0:\n            return str(abs(dy) / v) + \" + \" + str(abs(dx) / v)\n        else:\n            return str(abs(dy) / v) + \" + \" + str(abs(dx) / v) + \" + \" + str(abs(dy) / v)"
    },
    {
        "number": 3063,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    debts = []\n    for i in range(1, n+1):\n        a, b = map(int, stdin.split()[1:])\n        debts.append((a, b))\n\n    def dfs(node, total):\n        if node == n:\n            return total\n\n        min_amount = float('inf')\n        for neighbor, amount in debts:\n            if neighbor!= node:\n                min_amount = min(min_amount, dfs(neighbor, total + amount))\n\n        return min_amount\n\n    return str(dfs(1, 0))"
    },
    {
        "number": 3064,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(city, visited, path):\n        if city == 1:\n            return 1\n        visited.add(city)\n        for neighbor in graph[city]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path + [neighbor]) > 0:\n                    return 1\n        visited.remove(city)\n        return 0\n\n    longest_path = 0\n    for city in range(1, n + 1):\n        visited = set()\n        if dfs(city, visited, [city]) > longest_path:\n            longest_path = dfs(city, visited, [city])\n\n    return str(longest_path)"
    },
    {
        "number": 3065,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    rooms = list(map(int, stdin.split()))\n    neighbours = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        while queue:\n            node, depth = queue.pop(0)\n            if node == n - 1:\n                return depth\n            for neighbour in neighbours[node]:\n                if neighbour not in visited:\n                    visited.add(neighbour)\n                    queue.append((neighbour, depth + 1))\n        return -1\n\n    def sentry_time(start: int, end: int) -> int:\n        sentry_room = rooms.index(start)\n        sentry_time = 0\n        for i in range(sentry_room, n):\n            sentry_time += rooms[i]\n        return sentry_time\n\n    def time_to_reach(start: int, end: int) -> int:\n        return rooms.index(end) - rooms.index(start)\n\n    def chance_of_success(start: int, end: int) -> float:\n        sentry_time_start = sentry_time(start, end)\n        sentry_time_end = sentry_time(end, start)\n        time_to_reach_start = time_to_reach(start, end)\n        time_to_reach_end = time_to_reach(end, start)\n        return (sentry_time_start + time_to_reach_start) / (sentry_time_start + sentry_time_end + time_to_reach_start + time_to_reach_end)\n\n    start = rooms.index(0)\n    end = rooms.index(n - 1)\n    return str(chance_of_success(start, end))"
    },
    {
        "number": 3066,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = map(int, stdin.split())\n    colors = set(colors)\n    if len(colors)!= 1:\n        return \"IMPOSSIBLE\"\n\n    tape_colors = set(colors)\n    tape_pieces = [0] * len(tape_colors)\n\n    for i in range(1, n + 1):\n        if i in tape_colors:\n            tape_pieces[tape_colors.index(i)] += 1\n        else:\n            tape_colors.add(i)\n            tape_pieces.append(1)\n\n    instructions = []\n    for i in range(len(tape_colors)):\n        if tape_pieces[i] > 1:\n            instructions.append(f\"{tape_pieces[i]} {i + 1} {tape_colors.pop()}\")\n\n    return \"\\n\".join(instructions)\n"
    },
    {
        "number": 3067,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequences = []\n    for _ in range(n):\n        l = int(stdin.split()[1])\n        sequence = list(map(int, stdin.split()[2:2+l]))\n        sequences.append(sequence)\n    best_sequence = []\n    for sequence in sequences:\n        if not best_sequence:\n            best_sequence = sequence\n            continue\n        for i in range(len(sequence)):\n            if sequence[i] < best_sequence[i]:\n                best_sequence = sequence\n                break\n    return \" \".join(map(str, best_sequence))"
    },
    {
        "number": 3068,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    investigations = []\n    for _ in range(n):\n        investigations.append(list(map(str.upper, stdin.split()[1].split())))\n    investigations.sort(key=lambda x: (x[1], x[0]))\n    admissible_solutions = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if investigations[i][2] == investigations[j][2] == investigations[k][2]:\n                    admissible_solutions.add(tuple(sorted(investigations[i][0], investigations[j][0], investigations[k][0])))\n    return str(len(admissible_solutions))"
    },
    {
        "number": 3069,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    brackets = list(stdin)\n    n = len(brackets)\n\n    def is_valid(l: int, r: int) -> bool:\n        if l == r:\n            return True\n        if brackets[l] == ')' and brackets[r] == '(':\n            return is_valid(l + 1, r - 1)\n        if brackets[l] == ')' and brackets[r] == ')':\n            return is_valid(l + 1, r)\n        if brackets[l] == '(' and brackets[r] == ')':\n            return is_valid(l, r - 1)\n        return False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid(i, j):\n                return \"possible\"\n\n    return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    trains = []\n    for _ in range(m):\n        x, s, t, l = map(int, stdin.split())\n        trains.append((x, s, t, l))\n\n    def is_valid(s: int, t: int, l: int) -> bool:\n        return s + l <= t\n\n    def earliest_valid_time(s: int, t: int, l: int) -> int:\n        if is_valid(s, t, l):\n            return s\n        else:\n            return earliest_valid_time(s + 1, t, l)\n\n    def earliest_valid_train(s: int, t: int, l: int) -> int:\n        for x, s1, t1, l1 in trains:\n            if x == s:\n                if is_valid(s1, t1, l1):\n                    return earliest_valid_time(s1, t1, l1)\n        return -1\n\n    def earliest_valid_journey(s: int, t: int, l: int) -> int:\n        if is_valid(s, t, l):\n            return earliest_valid_time(s, t, l)\n        else:\n            return earliest_valid_journey(s + 1, t, l)\n\n    def earliest_valid_journey_from_station(s: int) -> int:\n        for x, s1, t1, l1 in trains:\n            if x == s:\n                return earliest_valid_journey(s1, t1, l1)\n        return -1\n\n    earliest_valid_journey_from_station_1 = earliest_valid_journey_from_station(1)\n    if earliest_valid_journey_from_station_1 == -1:\n        return \"impossible\"\n    else:\n        return str(earliest_valid_journey_from_station_1)"
    },
    {
        "number": 3071,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = [[] for _ in range(m)]\n    for _ in range(n):\n        team, player = map(str, stdin.split())\n        teams[int(team) - 1].append(player)\n    rounds = []\n    for i in range(m):\n        for j in range(i + 1, m):\n            for player in teams[i]:\n                rounds.append(f\"{player}-{teams[j][0]}\")\n                teams[j].pop(0)\n            for player in teams[j]:\n                rounds.append(f\"{player}-{teams[i][0]}\")\n                teams[i].pop(0)\n    return \" \".join(rounds)"
    },
    {
        "number": 3072,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split())\n    apartment = [list(row) for row in stdin.split('\\n')]\n\n    def is_free(row: int, col: int) -> bool:\n        return apartment[row][col] == '.'\n\n    def is_blocked(row: int, col: int) -> bool:\n        return apartment[row][col] == 'X'\n\n    def count_free_squares(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if 0 <= i < rows and 0 <= j < cols and is_free(i, j):\n                    count += 1\n        return count\n\n    def count_blocked_squares(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if 0 <= i < rows and 0 <= j < cols and is_blocked(i, j):\n                    count += 1\n        return count\n\n    def is_valid_table(row: int, col: int) -> bool:\n        return count_free_squares(row, col) >= 2\n\n    def is_valid_table_for_guests(row: int, col: int) -> bool:\n        return count_blocked_squares(row, col) >= 2\n\n    def is_valid_table_for_dinner(row: int, col: int) -> bool:\n        return count_free_squares(row, col) >= 2 and count_blocked_squares(row, col) >= 2\n\n    def is_valid_table_for_both(row: int, col: int) -> bool:\n        return is_valid_table(row, col) and is_valid_table_for_guests(row, col) and is_valid_table_for_dinner(row, col)\n\n    def find_valid_table(row: int, col: int) -> tuple[int, int]:\n        for i in range(rows):\n            for j in range(cols):\n                if is_valid_table(i, j):\n                    return i, j\n        return -1, -1\n\n    row, col = find_valid_table(0, 0)\n    if row == -1 or col == -1:\n        return '0'\n\n    visited = set()\n    queue = [(row, col)]\n    while queue:\n        current_row, current_col = queue.pop(0)\n        if (current_row, current_col) in visited:\n            continue\n        visited.add((current_row, current_col))\n\n        if is_valid_table_for_both(current_row, current_col):\n            return '1'\n\n        for i in range(rows):\n            for j in range(cols):\n                if is_valid_table(i, j) and (i, j) not in visited:\n                    queue.append((i, j))\n\n    return '0'"
    },
    {
        "number": 3073,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.split()[1:])\n        cards.append((r, c, a, b, p))\n    initial_card = cards[0]\n    tarot_board = {(0, 0): initial_card}\n    visited = {(0, 0)}\n    min_cost = float('inf')\n\n    def bfs(start):\n        queue = [(start, 0)]\n        while queue:\n            pos, cost = queue.pop(0)\n            if pos == (0, 0):\n                min_cost = min(min_cost, cost)\n                return\n            for offset in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                new_pos = (pos[0] + offset[0], pos[1] + offset[1])\n                if 0 <= new_pos[0] < n and 0 <= new_pos[1] < n and new_pos not in visited:\n                    visited.add(new_pos)\n                    queue.append((new_pos, cost + offset[0] + offset[1]))\n\n    bfs((0, 0))\n    return str(min_cost) if min_cost!= float('inf') else '-1'"
    },
    {
        "number": 3074,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = str(s)\n    valid_subsets = 0\n    MOD = 10**9 + 7\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            subset = s[i:j]\n            if len(subset) > 0 and subset[0] == '0':\n                continue\n            if int(subset) % 3 == 0:\n                valid_subsets = (valid_subsets + 1) % MOD\n\n    return str(valid_subsets)"
    },
    {
        "number": 3075,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g = map(int, stdin.split())\n    stations = []\n    for i in range(n):\n        d, c = map(int, stdin.split())\n        stations.append((d, c))\n\n    stations.sort(key=lambda x: x[0])\n    total_cost = 0\n    total_fuel = 0\n\n    for d, c in stations:\n        total_cost += c\n        total_fuel += d\n        if total_fuel > g:\n            return \"cancel road trip\"\n\n    return total_cost"
    },
    {
        "number": 3076,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = []\n    for _ in range(n):\n        size, value = map(int, stdin.split())\n        jewels.append((size, value))\n\n    jewels.sort(key=lambda x: x[0])\n\n    max_values = [0] * (k + 1)\n    max_values[1] = jewels[0][1]\n\n    for size, value in jewels[1:]:\n        for i in range(k, size - 1, -1):\n            max_values[i] = max(max_values[i], max_values[i + 1] + value)\n\n    return''.join(map(str, max_values))"
    },
    {
        "number": 3077,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    minions = []\n\n    for _ in range(n):\n        x, y, r = map(int, stdin.split())\n        villages.append((x, y, r))\n\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        minions.append((x, y))\n\n    def is_inside(x, y, r, center):\n        return (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r ** 2\n\n    def is_valid_attack(x, y, r, center):\n        return is_inside(x, y, r, center) and not any(is_inside(x, y, r, minion) for minion in minions)\n\n    def count_minions(center, r):\n        count = 0\n        for x, y in minions:\n            if is_inside(x, y, r, center):\n                count += 1\n        return count\n\n    def max_minions(center, r):\n        max_count = 0\n        for x, y in villages:\n            if is_inside(x, y, r, center):\n                count = count_minions((x, y), r)\n                max_count = max(max_count, count)\n        return max_count\n\n    max_count = 0\n    for x, y in villages:\n        for r in range(1, r + 1):\n            if is_valid_attack(x, y, r, (x, y)):\n                max_count = max(max_count, max_minions((x, y), r))\n\n    return str(max_count)"
    },
    {
        "number": 3078,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_interesting(start: int) -> bool:\n        return sum(a[:start]) <= s and sum(a[start:]) <= s\n\n    longest_interesting = 0\n    for i in range(n):\n        if is_interesting(i):\n            longest_interesting = max(longest_interesting, i + 1)\n\n    return \"\\n\".join(map(str, longest_interesting))\n"
    },
    {
        "number": 3079,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    sequence = list(sequence)\n    sequence.reverse()\n\n    beautiful_word = \"\"\n    for i in range(N):\n        word = \"\"\n        for j in range(i + 1):\n            word += sequence[j]\n        if word > beautiful_word:\n            beautiful_word = word\n\n    if beautiful_word == \"\":\n        return \"NE\"\n    else:\n        return \"DA\""
    },
    {
        "number": 3080,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    areas = list(map(int, stdin.split()))\n    runs = []\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        if x!= y:\n            runs.append((x, y))\n\n    def dfs(area, visited, result):\n        if area in visited:\n            return\n        visited.add(area)\n        if area == 1:\n            result.append(1)\n        else:\n            for run in runs:\n                if run[0] == area:\n                    dfs(run[1], visited, result)\n\n    result = []\n    visited = set()\n    for i in range(q):\n        k, a = map(int, stdin.split())\n        areas = list(map(int, stdin.split()))\n        dfs(1, visited, result)\n        for i in range(a):\n            if areas[i] in result:\n                result.remove(areas[i])\n        result.sort()\n        result = result[:k]\n        result.sort(reverse=True)\n        print(len(result))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3081,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    inspections = list(map(int, stdin.split()))\n    flights = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            flights.append((i, j, inspections[i] + inspections[j]))\n\n    flights.sort(key=lambda x: x[2])\n    flights = [x for x in flights if x[0]!= x[1]]\n\n    total_time = sum(inspections)\n    total_flights = len(flights)\n\n    if total_time <= total_flights:\n        return str(total_flights)\n    else:\n        return str(total_flights - 1)"
    },
    {
        "number": 3082,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> tuple[int, int, int]:\n        dish_type, w, t, dt = input_str.split()\n        if dish_type == \"D\":\n            return 0, int(w), int(t), int(dt)\n        elif dish_type == \"C\":\n            return 1, None, int(t), int(dt)\n        else:\n            raise ValueError(\"Invalid dish type\")\n\n    def compute_tastiness(dish_type: int, w: int, t: int, dt: int) -> float:\n        if dish_type == 0:\n            return t - (n - 1) * dt\n        elif dish_type == 1:\n            return (t - x * dt) * d * x\n        else:\n            raise ValueError(\"Invalid dish type\")\n\n    def compute_total_tastiness(dishes: list[tuple[int, int, int, int]]) -> float:\n        total_tastiness = 0\n        for dish_type, w, t, dt in dishes:\n            total_tastiness += compute_tastiness(dish_type, w, t, dt)\n        return total_tastiness\n\n    def compute_max_total_tastiness(dishes: list[tuple[int, int, int, int]]) -> float:\n        max_total_tastiness = float(\"-inf\")\n        for dish_type, w, t, dt in dishes:\n            max_total_tastiness = max(max_total_tastiness, compute_tastiness(dish_type, w, t, dt))\n        return max_total_tastiness\n\n    def compute_relative_error(max_total_tastiness: float, total_tastiness: float) -> float:\n        return abs(max_total_tastiness - total_tastiness) / max_total_tastiness\n\n    def compute_impossible(dishes: list[tuple[int, int, int, int]]) -> bool:\n        total_weight = sum(w for dish_type, w, t, dt in dishes)\n        return total_weight > w\n\n    dishes = [parse_input(input_str) for input_str in stdin.split(\"\\n\")[1:]]\n    if compute_impossible(dishes):\n        return \"impossible\"\n    total_tastiness = compute_total_tastiness(dishes)\n    max_total_tastiness = compute_max_total_tastiness(dishes)\n    relative_error = compute_relative_error(max_total_tastiness, total_tastiness)\n    return f\"{total_tastiness:.6f} {relative_error:.6f}\""
    },
    {
        "number": 3083,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    songs = []\n    for i in range(1, n + 1):\n        artist, t, *s = stdin.split()\n        songs.append((artist, int(t), [int(x) for x in s]))\n\n    def is_valid(song_numbers: list) -> bool:\n        for i in range(len(song_numbers) - 1):\n            if song_numbers[i] + 1!= song_numbers[i + 1]:\n                return False\n        return True\n\n    def find_valid_playlist(songs: list) -> list:\n        for i in range(len(songs)):\n            for j in range(i + 1, len(songs)):\n                if songs[i][1] > songs[j][1]:\n                    songs[i], songs[j] = songs[j], songs[i]\n                    break\n            else:\n                continue\n            for k in range(i + 1, len(songs)):\n                if songs[i][1] > songs[k][1]:\n                    songs[i], songs[k] = songs[k], songs[i]\n                    break\n            else:\n                continue\n            for l in range(i + 1, len(songs)):\n                if songs[i][1] > songs[l][1]:\n                    songs[i], songs[l] = songs[l], songs[i]\n                    break\n            else:\n                continue\n            for m in range(i + 1, len(songs)):\n                if songs[i][1] > songs[m][1]:\n                    songs[i], songs[m] = songs[m], songs[i]\n                    break\n            else:\n                continue\n            for n in range(i + 1, len(songs)):\n                if songs[i][1] > songs[n][1]:\n                    songs[i], songs[n] = songs[n], songs[i]\n                    break\n            else:\n                continue\n            for o in range(i + 1, len(songs)):\n                if songs[i][1] > songs[o][1]:\n                    songs[i], songs[o] = songs[o], songs[i]\n                    break\n            else:\n                continue\n            for p in range(i + 1, len(songs)):\n                if songs[i][1] > songs[p][1]:\n                    songs[i], songs[p] = songs[p], songs[i]\n                    break\n            else:\n                continue\n            for q in range(i + 1, len(songs)):\n                if songs[i][1] > songs[q][1]:\n                    songs[i], songs[q] = songs[q], songs[i]\n                    break\n            else:\n                continue\n            for r in range(i + 1, len(songs)):\n                if songs[i][1] > songs[r][1]:\n                    songs[i], songs[r] = songs[r], songs[i]\n                    break\n            else:\n                continue\n            for s in range(i + 1, len(songs)):\n                if songs[i][1] > songs[s][1]:\n                    songs[i], songs[s] = songs[s], songs[i]\n                    break\n            else:\n                continue\n            for t in range(i + 1, len(songs)):\n                if songs[i][1] > songs[t][1]:\n                    songs[i], songs[t] = songs[t], songs[i]\n                    break\n            else:\n                continue\n            for u in range(i + 1, len(songs)):\n                if songs[i][1] > songs[u][1]:\n                    songs[i], songs[u] = songs[u], songs[i]\n                    break\n            else:\n                continue\n            for v in range(i + 1, len(songs)):\n                if songs[i][1] > songs[v][1]:\n                    songs[i], songs[v] = songs[v], songs[i]\n                    break\n            else:\n                continue\n            for w in range(i + 1, len(songs)):\n                if songs[i][1] > songs[w][1]:\n                    songs[i], songs[w] = songs[w], songs[i]\n                    break\n            else:\n                continue\n            for x in range(i + 1, len(songs)):\n                if songs[i][1] > songs[x][1]:\n                    songs[i], songs[x] = songs[x], songs[i]\n                    break\n            else:\n                continue\n            for y in range(i + 1, len(songs)):\n                if songs[i][1] > songs[y][1]:\n                    songs[i], songs[y] = songs[y], songs[i]\n                    break\n            else:\n                continue"
    },
    {
        "number": 3084,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_time = original_time.split(':')\n    current_time = current_time.split(':')\n\n    def set_time(time: list[int]) -> str:\n        def set_digit(digit: int) -> int:\n            if digit == 0:\n                return 9\n            elif digit == 9:\n                return 0\n            else:\n                return digit\n\n        def set_hour(hour: int) -> int:\n            if hour == 24:\n                return 0\n            else:\n                return hour\n\n        def set_minute(minute: int) -> int:\n            if minute == 60:\n                return 0\n            else:\n                return minute\n\n        hour, minute = time\n        hour = set_hour(hour)\n        minute = set_minute(minute)\n        return f'{hour:02d}:{minute:02d}'\n\n    def count_different_times(times: list[str]) -> int:\n        return len(set(times))\n\n    def find_closest_time(original_time: list[int], current_time: list[int]) -> str:\n        def distance(t1: list[int], t2: list[int]) -> int:\n            return abs(t1[0] - t2[0]) + abs(t1[1] - t2[1])\n\n        def closest_time(times: list[str]) -> str:\n            return min(times, key=lambda t: distance(t.split(':'), original_time))\n\n        def closest_times(times: list[str]) -> list[str]:\n            return sorted(times, key=lambda t: distance(t.split(':'), original_time))\n\n        def find_closest_time_to_current_time(times: list[str]) -> str:\n            closest_times_to_current_time = closest_times([t for t in times if t.split(':')!= current_time])\n            return closest_time(closest_times_to_current_time)\n\n        closest_times_to_current_time = closest_times([t for t in times if t.split(':')!= current_time])\n        closest_time_to_current_time = closest_time(closest_times_to_current_time)\n        return closest_time_to_current_time\n\n    def find_closest_time_to_original_time(times: list[str]) -> str:\n        closest_times_to_original_time = closest_times([t for t in times if t.split(':')!= original_time])\n        return closest_time(closest_times_to_original_time)\n\n    def find_closest_time_to_current_time(times: list[str]) -> str:\n        closest_times_to_current_time = closest_times([t for t in times if t.split(':')!= current_time])\n        return closest_time(closest_times_to_current_time)\n\n    def find_closest_time_to_original_time_and_current_time(times: list[str]) -> str:\n        closest_times_to_original_time = closest_times([t for t in times if t.split(':')!= original_time])\n        closest_times_to_current_time = closest_times([t for t in times if t.split(':')!= current_time])\n        closest_times_to_original_time_and_current_time = closest_times([t for t in times if t.split(':')!= original_time and t.split(':')!= current_time])\n        return closest_time(closest_times_to_original_time_and_current_time)\n\n    def find_closest_time_to_original_time_and_current_time_and_closest_time_to_original_time(times: list[str]) -> str:\n        closest_times_to_original_time = closest_times([t for t in times if t.split(':')!= original_time])\n        closest_times_to_current_time = closest_times([t for t in times if t.split(':')!= current_time])\n        closest_times_to_original_time_and_current_time = closest_times([t for t in times if t.split(':')!= original_time and t.split(':')!= current_time])\n        closest_times_to_original_time_and_current_time_and_closest_time_to_original_time = closest_times([t for t in times if t.split(':')!= original_time and t.split(':')!= current_time and t.split"
    },
    {
        "number": 3085,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_matching_brackets(s: str, start: int, end: int) -> str:\n        stack = []\n        for i in range(start, end):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if not stack:\n                    return \"\"\n                stack.pop()\n        return \"\"\n\n    def find_alternative_brackets(s: str, start: int, end: int) -> str:\n        result = []\n        for i in range(start, end):\n            if s[i] == '(':\n                result.append(f\"{i},{i}:\")\n            elif s[i] == ')':\n                if not stack:\n                    return \"\"\n                stack.pop()\n        return \":\".join(result)\n\n    s = stdin.strip()\n    stack = []\n    start = 0\n    end = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            if not stack:\n                return \"\"\n            stack.pop()\n        else:\n            if not stack:\n                start = i\n            end = i + 1\n\n    if not stack:\n        return find_alternative_brackets(s, start, end)\n\n    matching_brackets = find_matching_brackets(s, start, end)\n    if not matching_brackets:\n        return find_alternative_brackets(s, start, end)\n\n    return min(matching_brackets, key=len)"
    },
    {
        "number": 3086,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    telescopes = []\n    for _ in range(n):\n        start_date, end_date, *events = map(int, stdin.split())\n        telescopes.append((start_date, end_date, events))\n\n    def merge_events(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date(events: list[int]) -> int:\n        return max(events)\n\n    def merge_events_by_date_and_time(events: list[int]) -> int:\n        return min(events)\n\n    def merge_events_by_date_and_time_and_type(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet(events: list[int]) -> int:\n        return max(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event(events: list[int]) -> int:\n        return min(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month(events: list[int]) -> int:\n        return max(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day(events: list[int]) -> int:\n        return min(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute(events: list[int]) -> int:\n        return max(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second(events: list[int]) -> int:\n        return min(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second_and_day_of_week(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second_and_day_of_week_and_day_of_year(events: list[int]) -> int:\n        return max(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second_and_day_of_week_and_day_of_year_and_day_of_month(events: list[int]) -> int:\n        return min(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second_and_day_of_week_and_day_of_year_and_day_of_month_and_day_of_week_in_month(events: list[int]) -> int:\n        return sum(events)\n\n    def merge_events_by_date_and_time_and_type_and_planet_and_event_and_year_and_month_and_day_and_hour_and_minute_and_second_and_day_of_week_and_day_of_year_and_day_of_month_and_day_of_week_in_month_and_day_of_week_in_year(events:"
    },
    {
        "number": 3087,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    for i in range(n):\n        if a[i] == i + 1:\n            continue\n        else:\n            break\n    else:\n        return \"Impossible\"\n    arrows = []\n    for i in range(n):\n        if a[i] == i + 1:\n            arrows.append(i + 1)\n    if len(arrows) < k:\n        return \"Impossible\"\n    arrows.sort()\n    arrows.append(n)\n    arrows.sort()\n    arrows.append(1)\n    arrows.sort()\n    arrows = list(set(arrows))\n    arrows.sort()\n    return \" \".join(map(str, arrows))"
    },
    {
        "number": 3088,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_num = 0\n    for i in range(10):\n        for j in range(i+1, 10):\n            if i!= j:\n                num = n\n                for _ in range(k):\n                    if num % 10 == i:\n                        num = num // 10 + j * 10\n                    elif num % 10 == j:\n                        num = num // 10 + i * 10\n                    else:\n                        num = num // 10\n                if num > max_num:\n                    max_num = num\n    return str(max_num)"
    },
    {
        "number": 3089,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.append(points[0])\n\n    def distance(p1: tuple, p2: tuple) -> float:\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def is_inside_cbd(point: tuple) -> bool:\n        x, y = point\n        return all(0 <= x <= 1 and 0 <= y <= 1 for p in points for x, y in p)\n\n    def is_inside_cbd_polygon(point: tuple) -> bool:\n        x, y = point\n        return is_inside_cbd(point) and all(is_inside_cbd(p) for p in points)\n\n    def shortest_distance(start: tuple, end: tuple) -> float:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, distance = queue.pop(0)\n            if current == end:\n                return distance\n            visited.add(current)\n            for neighbor in [(current[0] + 1, current[1]), (current[0] - 1, current[1]), (current[0], current[1] + 1), (current[0], current[1] - 1)]:\n                if neighbor not in visited and is_inside_cbd(neighbor) and distance + distance(neighbor, end) < 1e-6:\n                    queue.append((neighbor, distance + distance(neighbor, end)))\n        return float('inf')\n\n    expected_distance = shortest_distance((0, 0), (1, 1))\n    return f\"{expected_distance:.6f}\""
    },
    {
        "number": 3090,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    costs = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def dfs(i, j, visited):\n        if (i, j) in visited:\n            return 0\n\n        visited.add((i, j))\n\n        if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n            return costs[i][j]\n\n        cost = dfs(i - 1, j, visited) + dfs(i, j - 1, visited) + dfs(i + 1, j, visited) + dfs(i, j + 1, visited)\n\n        if cost > 0:\n            cost += k\n\n        return cost\n\n    visited = set()\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(m):\n            min_cost = min(min_cost, dfs(i, j, visited))\n\n    return str(min_cost)"
    },
    {
        "number": 3091,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, stdin.split())\n    grid = []\n    for _ in range(m):\n        row = list(map(int, stdin.split()))\n        grid.append(row)\n\n    def is_valid(row, col, target, op):\n        if row in visited or col in visited:\n            return False\n        visited.add((row, col))\n\n        if row == target:\n            return True\n\n        if op == '+':\n            return is_valid(row + 1, col, target, op)\n        elif op == '-':\n            return is_valid(row - 1, col, target, op)\n        elif op == '*':\n            return is_valid(row, col + 1, target, op)\n        elif op == '/':\n            return is_valid(row, col - 1, target, op)\n        else:\n            return False\n\n    visited = set()\n    count = 0\n    for row in range(n):\n        for col in range(m):\n            if is_valid(row, col, t, op):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3092,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        o, d, l = map(int, stdin.split())\n        roads.append((o, d, l))\n\n    def dfs(road, path, visited):\n        if road[1] in visited:\n            return 0\n        visited.add(road[1])\n        if road[0] == 1:\n            return 1\n        return dfs(roads[road[0] - 1], path + [road[1]], visited)\n\n    result = [dfs(road, [road[0]], set()) % 1000000007 for road in roads]\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3093,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n\n    def count_ways(i: int, color: int) -> int:\n        if i == N:\n            return 1\n        if f[i] == i:\n            return count_ways(i + 1, color)\n        return count_ways(i + 1, color) * (K - color + 1) // (color + 1)\n\n    return str(count_ways(0, 0))"
    },
    {
        "number": 3094,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1].split()))\n    MOD = 10**9 + 7\n\n    def count_ways(s: int) -> int:\n        if s == 1:\n            return 1\n        if s == 2:\n            return 2\n        if s == 3:\n            return 4\n        if s == 4:\n            return 7\n        if s == 5:\n            return 11\n        if s == 6:\n            return 16\n        if s == 7:\n            return 22\n        if s == 8:\n            return 29\n        if s == 9:\n            return 37\n        if s == 10:\n            return 46\n        if s == 11:\n            return 56\n        if s == 12:\n            return 67\n        if s == 13:\n            return 79\n        if s == 14:\n            return 92\n        if s == 15:\n            return 106\n        if s == 16:\n            return 121\n        if s == 17:\n            return 137\n        if s == 18:\n            return 154\n        if s == 19:\n            return 172\n        if s == 20:\n            return 191\n\n    ways = 0\n    for i in range(1, n + 1):\n        if i in t:\n            s = i\n            while s <= n:\n                ways += count_ways(s)\n                s += 1\n        else:\n            s = i\n            while s <= n:\n                ways += count_ways(s)\n                s += 1\n\n    return str(ways % MOD)"
    },
    {
        "number": 3095,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split())\n    A = []\n    for _ in range(R):\n        A.append(list(map(int, stdin.split())))\n\n    max_elements = 0\n    for i in range(1, R - 1):\n        for j in range(1, S - 1):\n            if A[i][j] + A[i][j + 1] <= A[i + 1][j] + A[i][j + 1]:\n                max_elements = max(max_elements, A[i][j] + A[i][j + 1] + A[i + 1][j] + A[i][j + 1])\n\n    return str(max_elements)"
    },
    {
        "number": 3096,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    jokes = [int(x) for x in stdin.split()[1:]]\n    superiors = []\n    for i in range(1, n):\n        a, b = map(int, stdin.split()[1:])\n        superiors.append((a, b))\n\n    def is_valid(jokes_set):\n        for i in range(len(jokes_set) - 1):\n            if jokes_set[i] == jokes_set[i + 1]:\n                return False\n        return True\n\n    def dfs(jokes_set, visited, result):\n        if is_valid(jokes_set):\n            result.add(tuple(jokes_set))\n        for i in range(len(jokes_set)):\n            if i > 0 and jokes_set[i] - jokes_set[i - 1] == 1:\n                continue\n            if i > 0 and jokes_set[i] - jokes_set[i - 1]!= 1:\n                continue\n            if i == 0:\n                visited.add(jokes_set[i])\n            else:\n                visited.add(jokes_set[i])\n                visited.add(jokes_set[i - 1])\n            dfs(jokes_set[:i] + jokes_set[i + 1:], visited, result)\n            visited.remove(jokes_set[i])\n\n    result = set()\n    dfs(jokes, set(), result)\n    return str(len(result))"
    },
    {
        "number": 3097,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    result = []\n\n    for i in range(queries):\n        a, b = map(int, stdin.split()[1].split(' '))\n        result.append(count_occurrences(a, b))\n\n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cake = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        cake.append((x, y))\n    cake.append(cake[0])\n    cake.sort(key=lambda x: x[0])\n    area = 0\n    for i in range(k):\n        area += 0.5 * (cake[i][0] * cake[i + 1][1] - cake[i + 1][0] * cake[i][1])\n    return str(area)"
    },
    {
        "number": 3099,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(spy: int, visited: set) -> int:\n        if spy in visited:\n            return 0\n        visited.add(spy)\n        count = 1\n        for neighbor in range(1, n + 1):\n            if graph[spy][neighbor] and neighbor not in visited:\n                count += dfs(neighbor, visited)\n        return count\n\n    n, m, c = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    enemy_spies = set(map(int, stdin.split()))\n    visited = set()\n    min_messages = float('inf')\n\n    for spy in range(1, n + 1):\n        if spy not in enemy_spies:\n            min_messages = min(min_messages, dfs(spy, visited))\n\n    return str(min_messages)"
    },
    {
        "number": 3100,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def dfs(i, j, k, path):\n        if i == A and j == C and k == M:\n            return 1\n        if i == 0:\n            return dfs(i, j, k, path + [1])\n        if j == 0:\n            return dfs(i, j, k, path + [2])\n        if k == 0:\n            return dfs(i, j, k, path + [3])\n\n        if i > 0 and path[-1]!= 1:\n            return dfs(i - 1, j, k, path + [1])\n        if j > 0 and path[-1]!= 2:\n            return dfs(i, j - 1, k, path + [2])\n        if k > 0 and path[-1]!= 3:\n            return dfs(i, j, k - 1, path + [3])\n\n        return dfs(i - 1, j, k, path)\n\n    return str(dfs(A, C, M, [])) % MOD"
    },
    {
        "number": 3101,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = 1\n        else:\n            a[i] += 1\n\n    if a == sorted(a):\n        return \" \".join(map(str, a))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3102,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(L, R+1):\n        if not any(d in str(i) for d in [4]):\n            if sum(1 for d in str(i) if d in [6, 8]) == sum(1 for d in str(i) if d not in [6, 8]):\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 3103,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split())\n    map_ = [list(row) for row in stdin.splitlines()]\n\n    def dfs(x, y, path):\n        if x == X and y == Y:\n            return 1\n        if x < 0 or x >= X or y < 0 or y >= Y:\n            return 0\n\n        if map_[y][x] == '@':\n            return 0\n\n        if map_[y][x] == '~':\n            return dfs(x + 1, y, path + (x + 1,)) + dfs(x - 1, y, path + (x - 1,))\n\n        if map_[y][x] == '#':\n            return 0\n\n        if map_[y][x] == '>':\n            return dfs(x + 1, y, path + (x + 1,))\n\n        if map_[y][x] == '<':\n            return dfs(x - 1, y, path + (x - 1,))\n\n    paths = set()\n    for i in range(Y):\n        for j in range(X):\n            if map_[i][j] == '@':\n                paths.add(dfs(x_init, i, (x_init,)))\n\n    return str(len(paths)) % 1000003"
    },
    {
        "number": 3104,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.split('=')\n    a, s = int(equation[0]), int(equation[1])\n\n    # Find the smallest number of addition operations needed to make A=S\n    def count_operations(n: int) -> int:\n        count = 0\n        while n > 0:\n            count += n % 10\n            n //= 10\n        return count\n\n    operations = count_operations(a) - count_operations(s)\n\n    # Insert the required number of addition operations\n    corrected_equation = f\"{a:0{operations}d}={s:0{operations}d}\"\n\n    return corrected_equation"
    },
    {
        "number": 3105,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1:]))\n\n    def find_pattern(s: list) -> tuple:\n        for i in range(len(s) - 3):\n            if s[i] == s[i + 1] and s[i] == s[i + 2] and s[i] == s[i + 3]:\n                return (s[i], s[i + 1])\n        return (-1, -1)\n\n    def find_min(a: int, b: int) -> int:\n        if a < b:\n            return a\n        return b\n\n    a, b = find_pattern(s)\n    if a!= -1 and b!= -1:\n        return f\"{a} {b}\"\n    return -1\n"
    },
    {
        "number": 3106,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [0] * n\n    buttons = [0] * n\n    for i, c in enumerate(stdin):\n        if c == '1':\n            lights[i] = 1\n        else:\n            lights[i] = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if buttons[i] == 0 and buttons[j] == 0:\n                lights[j] = 1\n                buttons[j] = 1\n    for i in range(n):\n        if buttons[i] == 0:\n            return str(i+1)\n    return '0'"
    },
    {
        "number": 3107,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    trucks = []\n    for i in range(n):\n        k = int(stdin.split()[1])\n        cities = list(map(int, stdin.split()[2:2+k]))\n        trucks.append(cities)\n\n    encounters = []\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        encounters.append(trucks[a][b] == trucks[b][a])\n\n    return '\\n'.join(map(str, encounters))"
    },
    {
        "number": 3108,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()[1:]))\n\n    def max_avg(arr, k):\n        max_sum = float('-inf')\n        max_avg = float('-inf')\n        for i in range(len(arr) - k + 1):\n            sum_ = 0\n            for j in range(i, i + k):\n                sum_ += arr[j]\n            avg = sum_ / k\n            if avg > max_avg:\n                max_avg = avg\n                max_sum = sum_\n        return max_avg\n\n    return str(max_avg(arr, k))"
    },
    {
        "number": 3109,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h = map(int, stdin.split()[1:])\n    v = list(map(float, stdin.split()[2:]))\n    x = list(map(float, stdin.split()[2 + n]))\n    min_height = [list(map(float, stdin.split()[2 + n + i])) for i in range(n)]\n    max_height = [list(map(float, stdin.split()[2 + n + n + i])) for i in range(n)]\n\n    def min_max_height(section: int, color: int) -> float:\n        return min(max_height[section][color], min_height[section][color])\n\n    def min_max_volume(section: int, color: int) -> float:\n        return min(v[color], min_height[section][color] * min_height[section][color])\n\n    def min_max_sand_height(section: int) -> float:\n        return min(max_height[section][0], min_height[section][0])\n\n    def min_max_sand_volume(section: int) -> float:\n        return min(v[0] * min_height[section][0], min_height[section][0] * min_height[section][0])\n\n    def min_max_sand_difference(section: int) -> float:\n        return min_max_sand_height(section) - min_max_sand_height(section + 1)\n\n    def min_max_sand_difference_volume(section: int) -> float:\n        return min_max_sand_volume(section) - min_max_sand_volume(section + 1)\n\n    def min_max_sand_difference_height(section: int) -> float:\n        return min_max_sand_height(section) - min_max_sand_height(section + 1)\n\n    def min_max_sand_difference_height_volume(section: int) -> float:\n        return min_max_sand_height(section) * min_max_sand_height(section + 1)\n\n    def min_max_sand_difference_height_volume_difference(section: int) -> float:\n        return min_max_sand_difference_height(section) - min_max_sand_difference_height_volume(section)\n\n    def min_max_sand_difference_height_volume_difference_volume(section: int) -> float:\n        return min_max_sand_difference_height_volume(section) - min_max_sand_difference_height_volume_difference(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference(section) - min_max_sand_difference_height_volume_difference_volume(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference_volume(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference_volume(section) - min_max_sand_difference_height_volume_difference_volume_difference(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference_volume_difference(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference_volume_difference(section) - min_max_sand_difference_height_volume_difference_volume_difference_volume(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference_volume_difference_volume(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference_volume_difference_volume(section) - min_max_sand_difference_height_volume_difference_volume_difference_volume_difference(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference_volume_difference_volume(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference_volume_difference_volume(section) - min_max_sand_difference_height_volume_difference_volume_difference_volume_difference_volume(section)\n\n    def min_max_sand_difference_height_volume_difference_volume_difference_volume_difference_volume_difference(section: int) -> float:\n        return min_max_sand_difference_height_volume_difference_volume_difference_volume(section) - min_max_sand_difference_height_volume_difference_volume"
    },
    {
        "number": 3110,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0].split())\n    grid = [list(map(int, stdin.split()[1].split())) for _ in range(m)]\n\n    def is_valid(code):\n        for i in range(m):\n            for j in range(n):\n                if code[i][j] == 0:\n                    continue\n                for k in range(i + 1, m):\n                    if code[k][j] == 0:\n                        break\n                    if code[i][j] * code[k][j] == code[i][j]:\n                        return False\n                for k in range(j + 1, n):\n                    if code[i][k] == 0:\n                        break\n                    if code[i][j] * code[i][k] == code[i][j]:\n                        return False\n        return True\n\n    def count_codes(code):\n        if is_valid(code):\n            return 1\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if code[i][j] == 0:\n                    continue\n                for k in range(i + 1, m):\n                    if code[k][j] == 0:\n                        break\n                    if code[i][j] * code[k][j] == code[i][j]:\n                        count += count_codes(code[:i] + code[k:])\n                for k in range(j + 1, n):\n                    if code[i][k] == 0:\n                        break\n                    if code[i][j] * code[i][k] == code[i][j]:\n                        count += count_codes(code[:i] + code[i][k:])\n        return count\n\n    return str(count_codes(grid))"
    },
    {
        "number": 3111,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dials = list(map(int, stdin.split()))\n    sums = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        sums.append(sum(dials[a-1:b]))\n        for i in range(a-1, b):\n            dials[i] += 1\n            if dials[i] == 10:\n                dials[i] = 0\n            else:\n                break\n\n    return \"\\n\".join(map(str, sums))"
    },
    {
        "number": 3112,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        while queue:\n            current = queue.popleft()\n            for neighbor in edges[current - 1]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        return visited\n\n    def max_producers(start: int) -> int:\n        visited = bfs(start)\n        return len(visited)\n\n    max_producers_1 = max_producers(1)\n    max_producers_2 = max_producers(2)\n\n    return str(max(max_producers_1, max_producers_2))"
    },
    {
        "number": 3113,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    garry_triangles = []\n    jerry_triangles = []\n\n    for _ in range(n):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n        garry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    for _ in range(m):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n        jerry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    garry_triangles.sort(key=lambda x: (x[0], x[1]))\n    jerry_triangles.sort(key=lambda x: (x[0], x[1]))\n\n    garry_triangles_set = set(garry_triangles)\n    jerry_triangles_set = set(jerry_triangles)\n\n    if garry_triangles_set == jerry_triangles_set:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3114,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def bfs(start: int) -> list:\n        queue = [start]\n        visited = set()\n        visited.add(start)\n        direction = [0] * (n + 1)\n        direction[start] = 1\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    direction[neighbor] = 1 - direction[current]\n        return direction\n\n    directions = bfs(1)\n    if all(directions[i] == directions[j] for i in range(1, n + 1) for j in range(i + 1, n + 1)):\n        return \"NO\"\n\n    result = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if directions[i] == directions[j]:\n                result.append(f\"{i} {j}\")\n\n    return \"YES\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 3115,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matches = []\n    for _ in range(m):\n        k, symbol, l = map(int, stdin.split())\n        matches.append((k, l, symbol))\n\n    def is_consistent(matches):\n        for i in range(len(matches)):\n            for j in range(i + 1, len(matches)):\n                if matches[i][2] == '>' and matches[j][2] == '=' or matches[i][2] == '=' and matches[j][2] == '>':\n                    return False\n        return True\n\n    if is_consistent(matches):\n        return \"consistent\"\n    else:\n        return \"inconsistent\""
    },
    {
        "number": 3116,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stars = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split()[1:])\n        stars.append((x, y, z))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def cross_product(a, b):\n        return (a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0])\n\n    def dot_product(a, b):\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n\n    def is_coplanar(a, b, c):\n        return abs(dot_product(cross_product(a, b), c)) < 1e-6\n\n    def is_in_cone(a, b, c, d):\n        return dot_product(cross_product(b - a, c - a), d - a) > 0\n\n    def is_in_triangle(a, b, c, d):\n        return dot_product(cross_product(b - a, c - a), d - a) > 0 and dot_product(cross_product(c - a, d - a), b - a) > 0\n\n    def is_in_sphere(a, b, c, d):\n        return distance(a, b) + distance(b, c) + distance(c, d) + distance(d, a) <= distance(a, c) + distance(b, c) + distance(c, d) + distance(d, a)\n\n    def is_in_cylinder(a, b, c, d, e, f):\n        return is_in_cone(a, b, c, d) and is_in_cone(e, f, c, d)\n\n    def is_in_cone_of_planes(a, b, c, d, e, f):\n        return is_in_cone(a, b, c, d) or is_in_cone(e, f, c, d)\n\n    def is_in_triangle_of_planes(a, b, c, d, e, f):\n        return is_in_triangle(a, b, c, d) or is_in_triangle(e, f, c, d)\n\n    def is_in_sphere_of_planes(a, b, c, d, e, f):\n        return is_in_sphere(a, b, c, d) or is_in_sphere(e, f, c, d)\n\n    def is_in_cylinder_of_planes(a, b, c, d, e, f):\n        return is_in_cylinder(a, b, c, d, e, f) or is_in_cylinder(e, f, c, d, e, f)\n\n    def is_in_cone_of_planes_of_planes(a, b, c, d, e, f, g, h, i, j, k, l):\n        return is_in_cone_of_planes(a, b, c, d, e, f) or is_in_cone_of_planes(g, h, i, j, k, l)\n\n    def is_in_triangle_of_planes_of_planes(a, b, c, d, e, f, g, h, i, j, k, l):\n        return is_in_triangle_of_planes(a, b, c, d, e, f) or is_in_triangle_of_planes(g, h, i, j, k, l)\n\n    def is_in_sphere_of_planes_of_planes(a, b, c, d, e, f, g, h, i, j, k, l):\n        return is_in_sphere_of_planes(a, b, c, d, e, f) or is_in_sphere_of_planes(g, h, i, j, k, l)\n\n    def is_in_cylinder_of_planes_of_planes(a, b, c, d, e, f, g, h, i, j, k, l):\n        return is"
    },
    {
        "number": 3117,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.split()[0])\n    s = stdin.split()[1]\n    max_len = 0\n    count = 0\n    for i in range(L):\n        for j in range(i+1, L):\n            if s[i] == s[j]:\n                count += 1\n                if count > 1:\n                    max_len = max(max_len, j-i+1)\n                count = 0\n    return str(max_len)"
    },
    {
        "number": 3118,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    alice_cards = [i for i in range(1, n+1)]\n    bob_cards = [i for i in range(1, n+1)]\n\n    alice_cards.sort(key=lambda x: a.index(x))\n    bob_cards.sort(key=lambda x: b.index(x))\n\n    alice_shuffles = 0\n    bob_shuffles = 0\n\n    while alice_cards!= bob_cards:\n        alice_cards.sort(key=lambda x: a.index(x))\n        bob_cards.sort(key=lambda x: b.index(x))\n        alice_shuffles += 1\n        bob_shuffles += 1\n\n    return str(min(alice_shuffles, bob_shuffles))"
    },
    {
        "number": 3119,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n    sp = []\n    for i in range(p):\n        s, e = map(int, stdin.split()[1:3])\n        sp.append((s, e))\n\n    t.sort()\n    t.append(t[-1] + 1000)\n\n    def is_sp(t: int) -> bool:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return True\n        return False\n\n    def is_sp_overlap(t1: int, t2: int) -> bool:\n        for s, e in sp:\n            if t1 >= s and t1 <= e and t2 >= s and t2 <= e:\n                return True\n        return False\n\n    def sp_charge(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return s\n        return 0\n\n    def sp_degrade(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return 0\n        return 0\n\n    def sp_activation_time(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge_and_sp_activation(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge_and_sp_activation_and_sp_degrade(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge_and_sp_activation_and_sp_degrade_and_sp_activation_charge(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge_and_sp_activation_and_sp_degrade_and_sp_activation_charge_and_sp_activation(t: int) -> int:\n        for s, e in sp:\n            if t >= s and t <= e:\n                return e - s\n        return 0\n\n    def sp_activation_charge_time_remaining_after_activation_and_degrade_and_sp_charge_and_sp_activation_and_sp_degrade_and_sp_activation_charge_and_sp_activation_and_sp_degrade(t: int) -> int:\n        for s, e"
    },
    {
        "number": 3120,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_expr(expr: str) -> list:\n        if expr[0] == '[':\n            return [int(x) for x in expr[1:-1].split(',')]\n        else:\n            return [parse_expr(x) for x in expr.split(',')]\n\n    def eval_expr(expr: str, env: dict) -> list:\n        if expr[0] == '[':\n            return [eval_expr(x, env) for x in expr[1:-1].split(',')]\n        elif expr[0] == 'x':\n            return [env[x] for x in expr[1:]]\n        else:\n            return [eval_expr(x, env) for x in expr.split(',')]\n\n    def shuffle_list(lst: list) -> list:\n        return [lst[i] for i in range(len(lst))]\n\n    def is_equivalent(program1: str, program2: str) -> bool:\n        env = {}\n        program1_expr = parse_expr(program1)\n        program2_expr = parse_expr(program2)\n\n        for i in range(len(program1_expr)):\n            if isinstance(program1_expr[i], list):\n                env[f'x{i}'] = program1_expr[i]\n            else:\n                env[f'x{i}'] = eval_expr(program1_expr[i], env)\n\n        for i in range(len(program2_expr)):\n            if isinstance(program2_expr[i], list):\n                env[f'x{i}'] = program2_expr[i]\n            else:\n                env[f'x{i}'] = eval_expr(program2_expr[i], env)\n\n        return program1_expr == program2_expr\n\n    A, B = stdin.split('\\n')\n    return 'equal' if is_equivalent(A, B) else 'not equal'"
    },
    {
        "number": 3121,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(area, visited, path):\n        if area == n:\n            return 1\n        if area in visited:\n            return 0\n        visited.add(area)\n        max_health = 0\n        for i in range(1, m + 1):\n            if area == e[i] and b[i] == area + 1:\n                enemy_health = a[i]\n                enemy_attack = h[i]\n                if enemy_health > 0:\n                    max_health = max(max_health, dfs(b[i], visited, path + [area]))\n                    enemy_health -= 1\n                    if enemy_health == 0:\n                        return max(max_health, dfs(b[i], visited, path + [area]))\n        return max_health\n\n    n, m = map(int, stdin.split())\n    e, b, a, h = [], [], [], []\n    for _ in range(m):\n        e.append(int(stdin.split()[0]))\n        b.append(int(stdin.split()[1]))\n        a.append(int(stdin.split()[2]))\n        h.append(int(stdin.split()[3]))\n\n    visited = set()\n    max_health = dfs(1, visited, [])\n    if max_health == 0:\n        return \"Oh no\"\n    return str(max_health)"
    },
    {
        "number": 3122,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        routes.append((a, b, c))\n\n    lounges = [0] * n\n    visited = [False] * n\n\n    def dfs(i):\n        if visited[i]:\n            return\n        visited[i] = True\n        for j, (k, l, m) in enumerate(routes):\n            if k == i or l == i:\n                if lounges[i] + m <= lounges[j]:\n                    lounges[j] = lounges[i] + m\n                if lounges[j] == 0:\n                    return\n        for j, (k, l, m) in enumerate(routes):\n            if k == i or l == i:\n                continue\n            if lounges[i] + m <= lounges[j]:\n                lounges[j] = lounges[i] + m\n            if lounges[j] == 0:\n                return\n        lounges[i] = 0\n\n    for i in range(n):\n        if lounges[i] == 0:\n            dfs(i)\n            if lounges[i] == 0:\n                return \"impossible\"\n\n    return str(min(lounges))\n"
    },
    {
        "number": 3123,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    max_k = 0\n    for i in range(1, n + 1):\n        k = 1\n        while a[i - 1] == a[i]:\n            k += 1\n        if k > max_k:\n            max_k = k\n    return str(max_k)"
    },
    {
        "number": 3124,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n\n    def is_odd(num: int) -> bool:\n        return num % 2!= 0\n\n    def find_first_move(numbers: List[int]) -> int:\n        odd_numbers = [num for num in numbers if is_odd(num)]\n        if not odd_numbers:\n            return 1\n\n        odd_numbers.sort()\n        return odd_numbers[0]\n\n    first_moves = set()\n    for i in range(1, N + 1):\n        first_moves.add(find_first_move(numbers))\n\n    return str(len(first_moves))"
    },
    {
        "number": 3125,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', 'a+').replace('-', 'a-')\n    output_str = output_str.replace('+', 'a+').replace('-', 'a-')\n\n    if not input_str:\n        return '<empty>'\n    elif input_str == output_str:\n        return '<any>'\n    else:\n        return output_str"
    },
    {
        "number": 3126,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    changes = []\n    for _ in range(int(stdin.split()[1])):\n        changes.append(stdin.split()[2])\n\n    def dance(p: List[int], t: int) -> int:\n        jumps = 0\n        tower = [0] * n\n        for i in range(n):\n            tower[i] = p[i]\n        for i in range(t):\n            if i % 2 == 0:\n                jumps += 1\n                tower[i // 2] += 1\n            else:\n                jumps += 1\n                tower[i // 2] -= 1\n        return jumps\n\n    def find_min_jumps(p: List[int], t: int) -> int:\n        min_jumps = float('inf')\n        for i in range(t):\n            min_jumps = min(min_jumps, dance(p, i))\n        return min_jumps\n\n    min_jumps = find_min_jumps(p, t)\n    print(min_jumps)\n\n    for change in changes:\n        if change[0] == '+':\n            p.append(int(change[1:]))\n        elif change[0] == '-':\n            p.remove(int(change[1:]))\n        else:\n            t = int(change[1:])\n\n    min_jumps = find_min_jumps(p, t)\n    print(min_jumps)\n\n    return ''\n"
    },
    {
        "number": 3127,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cables = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.split())\n        cables.append((a, b, l))\n\n    def is_redundant(cable):\n        for i in range(len(cables)):\n            if i!= cable[0] - 1 and i!= cable[1] - 1 and cables[i][0] == cable[0] and cables[i][1] == cable[1]:\n                return True\n        return False\n\n    redundant_cables = [cable for cable in cables if is_redundant(cable)]\n    redundant_cable_lengths = [cable[2] for cable in redundant_cables]\n    redundant_cable_lengths.sort()\n\n    def find_redundant_switches(cable_lengths):\n        redundant_switches = []\n        for i in range(len(cable_lengths)):\n            for j in range(i + 1, len(cable_lengths)):\n                if cable_lengths[i] + cable_lengths[j] == 0:\n                    redundant_switches.append((i + 1, j + 1))\n        return redundant_switches\n\n    redundant_switches = find_redundant_switches(redundant_cable_lengths)\n\n    unused_switches = [i for i in range(1, n + 1) if i not in [cable[0] for cable in cables] and i not in [cable[1] for cable in cables]]\n\n    return f\"{len(redundant_switches)}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3128,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [int(x) for x in stdin.split()]\n    n = queries[0]\n    queries = queries[1:]\n\n    for query in queries:\n        if query == 1:\n            x = int(input())\n            print(x)\n        else:\n            x = int(input())\n            print(x)\n\n    return \"\""
    },
    {
        "number": 3129,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    clean_count = 0\n    infected_count = 0\n    for char in stdin:\n        if char == 'C':\n            clean_count += 1\n        else:\n            infected_count += 1\n\n    if clean_count == 0:\n        return '0'\n\n    if infected_count == 0:\n        return '1'\n\n    if infected_count == 1:\n        return '2'\n\n    if infected_count == 2:\n        return '3'\n\n    if infected_count == 3:\n        return '4'\n\n    if infected_count == 4:\n        return '5'\n\n    if infected_count == 5:\n        return '6'\n\n    if infected_count == 6:\n        return '7'\n\n    if infected_count == 7:\n        return '8'\n\n    if infected_count == 8:\n        return '9'\n\n    if infected_count == 9:\n        return '10'\n\n    if infected_count == 10:\n        return '11'\n\n    if infected_count == 11:\n        return '12'\n\n    if infected_count == 12:\n        return '13'\n\n    if infected_count == 13:\n        return '14'\n\n    if infected_count == 14:\n        return '15'\n\n    if infected_count == 15:\n        return '16'\n\n    if infected_count == 16:\n        return '17'\n\n    if infected_count == 17:\n        return '18'\n\n    if infected_count == 18:\n        return '19'\n\n    if infected_count == 19:\n        return '20'\n\n    if infected_count == 20:\n        return '21'\n\n    if infected_count == 21:\n        return '22'\n\n    if infected_count == 22:\n        return '23'\n\n    if infected_count == 23:\n        return '24'\n\n    if infected_count == 24:\n        return '25'\n\n    if infected_count == 25:\n        return '26'\n\n    if infected_count == 26:\n        return '27'\n\n    if infected_count == 27:\n        return '28'\n\n    if infected_count == 28:\n        return '29'\n\n    if infected_count == 29:\n        return '30'\n\n    if infected_count == 30:\n        return '31'\n\n    if infected_count == 31:\n        return '32'\n\n    if infected_count == 32:\n        return '33'\n\n    if infected_count == 33:\n        return '34'\n\n    if infected_count == 34:\n        return '35'\n\n    if infected_count == 35:\n        return '36'\n\n    if infected_count == 36:\n        return '37'\n\n    if infected_count == 37:\n        return '38'\n\n    if infected_count == 38:\n        return '39'\n\n    if infected_count == 39:\n        return '40'\n\n    if infected_count == 40:\n        return '41'\n\n    if infected_count == 41:\n        return '42'\n\n    if infected_count == 42:\n        return '43'\n\n    if infected_count == 43:\n        return '44'\n\n    if infected_count == 44:\n        return '45'\n\n    if infected_count == 45:\n        return '46'\n\n    if infected_count == 46:\n        return '47'\n\n    if infected_count == 47:\n        return '48'\n\n    if infected_count == 48:\n        return '49'\n\n    if infected_count == 49:\n        return '50'\n\n    if infected_count == 50:\n        return '51'\n\n    if infected_count == 51:\n        return '52'\n\n    if infected_count == 52:\n        return '53'\n\n    if infected_count == 53:\n        return '54'\n\n    if infected_count == 54:\n        return '55'\n\n    if infected_count == 55:\n        return '56'\n\n    if infected_count == 56:\n        return '57'\n\n    if infected_count =="
    },
    {
        "number": 3130,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    knowledge_base = []\n    for line in stdin.split('\\n'):\n        if line:\n            implication = line.split()\n            knowledge_base.append((int(implication[0]), int(implication[1])))\n\n    events = set(map(int, stdin.split()[-1].split(',')))\n\n    def is_implied_by(event: int) -> bool:\n        for implication in knowledge_base:\n            if event == implication[0]:\n                return True\n        return False\n\n    def find_causality_chain(event: int) -> list:\n        causality_chain = []\n        while event!= 1:\n            if is_implied_by(event):\n                causality_chain.append(event)\n                event = implication[1]\n            else:\n                break\n        return causality_chain\n\n    def find_causality_chains(events: set) -> set:\n        causality_chains = set()\n        for event in events:\n            causality_chains.add(find_causality_chain(event))\n        return causality_chains\n\n    causality_chains = find_causality_chains(events)\n    causality_chains = [chain for chain in causality_chains if all(event in events for event in chain)]\n\n    return''.join(map(str, sorted(causality_chains[0])))"
    },
    {
        "number": 3131,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n    total = sum(a[:K])\n    return str(total % 1000000007)"
    },
    {
        "number": 3132,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    def find_building(row: int, col: int) -> bool:\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    return True\n        return False\n\n    def find_overlap(row: int, col: int) -> bool:\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x' and (i!= row or j!= col):\n                    return True\n        return False\n\n    def find_corner(row: int, col: int) -> tuple:\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    return i, j\n        return None\n\n    def find_size(row: int, col: int) -> int:\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    return abs(i - row) + abs(j - col)\n        return None\n\n    building1 = find_building(0, 0)\n    building2 = find_building(1, 3)\n\n    if building1 and building2:\n        row1, col1 = find_corner(0, 0)\n        row2, col2 = find_corner(1, 3)\n        size1 = find_size(row1, col1)\n        size2 = find_size(row2, col2)\n        return f\"{row1} {col1} {size1}\\n{row2} {col2} {size2}\"\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3133,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split())\n    intersections = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_visible(intersection: int) -> bool:\n        for i in range(n):\n            if intersections[i][2] == 1 and (intersection == A or intersection == B):\n                return True\n        return False\n\n    def get_turn(intersection: int) -> int:\n        for i in range(n):\n            if intersections[i][2] == 1 and (intersection == A or intersection == B):\n                return intersections[i][0] - intersections[i][1]\n        return 0\n\n    def get_distance(intersection: int) -> int:\n        return abs(intersections[intersection][0] - intersections[intersection][1])\n\n    def get_turn_distance(intersection: int) -> int:\n        return get_turn(intersection) + get_distance(intersection)\n\n    def get_turn_distance_from_A(intersection: int) -> int:\n        return get_turn_distance(intersection) + get_distance(A)\n\n    def get_turn_distance_from_B(intersection: int) -> int:\n        return get_turn_distance(intersection) + get_distance(B)\n\n    def get_turn_distance_from_A_and_B(intersection: int) -> int:\n        return get_turn_distance_from_A(intersection) + get_turn_distance_from_B(intersection)\n\n    def get_turn_distance_from_A_or_B(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C_or_D(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection), get_turn_distance_from_D(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C_or_D_or_E(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection), get_turn_distance_from_D(intersection), get_turn_distance_from_E(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C_or_D_or_E_or_F(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection), get_turn_distance_from_D(intersection), get_turn_distance_from_E(intersection), get_turn_distance_from_F(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C_or_D_or_E_or_F_or_G(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection), get_turn_distance_from_D(intersection), get_turn_distance_from_E(intersection), get_turn_distance_from_F(intersection), get_turn_distance_from_G(intersection))\n\n    def get_turn_distance_from_A_or_B_or_C_or_D_or_E_or_F_or_G_or_H(intersection: int) -> int:\n        return min(get_turn_distance_from_A(intersection), get_turn_distance_from_B(intersection), get_turn_distance_from_C(intersection), get_turn_distance_from_D(intersection), get_turn_distance_from_E(intersection), get_turn_distance_from_F(intersection), get_turn_distance_from_G(intersection), get_turn_distance_from_H"
    },
    {
        "number": 3134,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = stdin.split('\\n')\n    R, C = [int(x) for x in R], [int(x) for x in C]\n\n    row_parity = [0] * len(R)\n    col_parity = [0] * len(C)\n\n    for i in range(len(R)):\n        row_parity[i] = R[i]\n\n    for j in range(len(C)):\n        col_parity[j] = C[j]\n\n    row_parity = [1 if x % 2 == 1 else 0 for x in row_parity]\n    col_parity = [1 if x % 2 == 1 else 0 for x in col_parity]\n\n    row_parity = ''.join(str(x) for x in row_parity)\n    col_parity = ''.join(str(x) for x in col_parity)\n\n    if row_parity == '0' * len(R) and col_parity == '0' * len(C):\n        return '1' * len(R) + '1' * len(C)\n    else:\n        return -1"
    },
    {
        "number": 3135,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"+1\"\n\n    def count_zeros(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_ones(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_binary(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_ones(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def count_sign_bits_in_signed_binary_with_zeros_and_ones_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits_and_sign_bits(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n       "
    },
    {
        "number": 3136,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n    roads = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        if u!= v:\n            roads.append((u, v, d))\n\n    def bellman_ford(graph: List[List[Tuple[int, int]]], start: int) -> int:\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u, v, d in graph:\n                if dist[u]!= float('inf') and dist[u] + d < dist[v]:\n                    dist[v] = dist[u] + d\n        for u, v, d in graph:\n            if dist[u]!= float('inf') and dist[u] + d < dist[v]:\n                return False\n        return True\n\n    def dijkstra(graph: List[List[Tuple[int, int]]], start: int) -> List[int]:\n        dist = [float('inf')] * n\n        dist[start] = 0\n        prev = [-1] * n\n        for _ in range(n - 1):\n            for u, v, d in graph:\n                if dist[u]!= float('inf') and dist[u] + d < dist[v]:\n                    dist[v] = dist[u] + d\n                    prev[v] = u\n        return dist, prev\n\n    def min_distance(warehouses: List[int], employees: List[int], clients: List[int]) -> int:\n        graph = [[] for _ in range(n)]\n        for u, v, d in roads:\n            graph[u - 1].append((v - 1, d))\n            graph[v - 1].append((u - 1, d))\n\n        warehouse_graph = [[] for _ in range(n)]\n        for u, v in zip(warehouses, warehouses[1:]):\n            warehouse_graph[u - 1].append((v - 1, 0))\n            warehouse_graph[v - 1].append((u - 1, 0))\n\n        warehouse_dist, warehouse_prev = dijkstra(warehouse_graph, a - 1)\n        employee_graph = [[] for _ in range(n)]\n        for u, v in zip(employees, employees[1:]):\n            employee_graph[u - 1].append((v - 1, 0))\n            employee_graph[v - 1].append((u - 1, 0))\n\n        employee_dist, employee_prev = dijkstra(employee_graph, x[0] - 1)\n        client_graph = [[] for _ in range(n)]\n        for u, v in zip(clients, clients[1:]):\n            client_graph[u - 1].append((v - 1, 0))\n            client_graph[v - 1].append((u - 1, 0))\n\n        client_dist, client_prev = dijkstra(client_graph, y[0] - 1)\n\n        for u, v, d in roads:\n            if warehouse_dist[u - 1] + d < warehouse_dist[v - 1]:\n                warehouse_dist[v - 1] = warehouse_dist[u - 1] + d\n                warehouse_prev[v - 1] = u - 1\n            if employee_dist[u - 1] + d < employee_dist[v - 1]:\n                employee_dist[v - 1] = employee_dist[u - 1] + d\n                employee_prev[v - 1] = u - 1\n            if client_dist[u - 1] + d < client_dist[v - 1]:\n                client_dist[v - 1] = client_dist[u - 1] + d\n                client_prev[v - 1] = u - 1\n\n        return warehouse_dist[b - 1] + employee_dist[x[1] - 1] + client_dist[y[1] - 1]\n\n    return str(min_distance(x, y, x))"
    },
    {
        "number": 3137,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n    trap_row, trap_col = map(int, stdin.split())\n\n    bacteria = []\n    for _ in range(k):\n        x, y, c = map(int, stdin.split())\n        bacteria.append((x, y, c))\n\n    def turn(x, y, c, n):\n        if c == 'U':\n            return (x, y - n)\n        elif c == 'R':\n            return (x + n, y)\n        elif c == 'D':\n            return (x, y + n)\n        elif c == 'L':\n            return (x - n, y)\n        else:\n            return (x, y)\n\n    def move(x, y, c):\n        if c == 'U':\n            return (x, y - 1)\n        elif c == 'R':\n            return (x + 1, y)\n        elif c == 'D':\n            return (x, y + 1)\n        elif c == 'L':\n            return (x - 1, y)\n        else:\n            return (x, y)\n\n    def trap(x, y):\n        return trap_row == x and trap_col == y\n\n    def bacteria_at(x, y):\n        for b in bacteria:\n            if b[0] == x and b[1] == y:\n                return b\n        return None\n\n    def bacteria_at_cell(cell):\n        x, y = cell\n        return bacteria_at(x, y)\n\n    def bacteria_at_cell_turned(cell, n):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = turn(x, y, b[2], n)\n        return bacteria_at(new_x, new_y)\n\n    def bacteria_at_cell_moved(cell):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = move(x, y, b[2])\n        return bacteria_at(new_x, new_y)\n\n    def bacteria_at_cell_turned_moved(cell, n):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = turn(x, y, b[2], n)\n        new_x, new_y = move(new_x, new_y, b[2])\n        return bacteria_at(new_x, new_y)\n\n    def bacteria_at_cell_turned_moved_trap(cell, n):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = turn(x, y, b[2], n)\n        new_x, new_y = move(new_x, new_y, b[2])\n        if trap(new_x, new_y):\n            return None\n        return bacteria_at(new_x, new_y)\n\n    def bacteria_at_cell_turned_moved_trap_kill(cell, n):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = turn(x, y, b[2], n)\n        new_x, new_y = move(new_x, new_y, b[2])\n        if trap(new_x, new_y):\n            return None\n        if bacteria_at(new_x, new_y) is not None:\n            return None\n        return (new_x, new_y)\n\n    def bacteria_at_cell_turned_moved_trap_kill_bacteria_at_cell_turned_moved_trap_kill(cell, n):\n        x, y = cell\n        b = bacteria_at(x, y)\n        if b is None:\n            return None\n        new_x, new_y = turn(x, y, b[2], n)\n        new_x, new_y = move(new_x, new_y, b[2])\n        if trap(new_x, new_y):\n            return None\n        if bacteria_at(new"
    },
    {
        "number": 3138,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n\n    def count_ways(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        return count_ways(start + 1, end) + count_ways(start, end - 1)\n\n    def count_combinations(start, end):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        return count_combinations(start + 1, end) + count_combinations(start, end - 1)\n\n    def count_combinations_with_sum(start, end, target_sum):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] + numbers[end] == target_sum:\n            return 1\n        return count_combinations_with_sum(start + 1, end, target_sum) + count_combinations_with_sum(start, end - 1, target_sum)\n\n    def count_combinations_with_product(start, end, target_product):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] * numbers[end] == target_product:\n            return 1\n        return count_combinations_with_product(start + 1, end, target_product) + count_combinations_with_product(start, end - 1, target_product)\n\n    def count_combinations_with_sum_and_product(start, end, target_sum, target_product):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] + numbers[end] == target_sum and numbers[start] * numbers[end] == target_product:\n            return 1\n        return count_combinations_with_sum_and_product(start + 1, end, target_sum, target_product) + count_combinations_with_sum_and_product(start, end - 1, target_sum, target_product)\n\n    def count_combinations_with_sum_and_product_in_range(start, end, target_sum, target_product):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] + numbers[end] == target_sum and numbers[start] * numbers[end] == target_product:\n            return 1\n        return count_combinations_with_sum_and_product_in_range(start + 1, end, target_sum, target_product) + count_combinations_with_sum_and_product_in_range(start, end - 1, target_sum, target_product)\n\n    def count_combinations_with_sum_and_product_in_range_with_page_count(start, end, target_sum, target_product, page_count):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] + numbers[end] == target_sum and numbers[start] * numbers[end] == target_product:\n            return 1\n        if start - page_count >= 0 and numbers[start - page_count] + numbers[start] == target_sum and numbers[start - page_count] * numbers[start] == target_product:\n            return 1\n        if end + page_count < n and numbers[end + page_count] + numbers[end] == target_sum and numbers[end + page_count] * numbers[end] == target_product:\n            return 1\n        return count_combinations_with_sum_and_product_in_range_with_page_count(start + 1, end, target_sum, target_product, page_count) + count_combinations_with_sum_and_product_in_range_with_page_count(start, end - 1, target_sum, target_product, page_count)\n\n    def count_combinations_with_sum_and_product_in_range_with_page_count_and_page_size(start, end, target_sum, target_product, page_count, page_size):\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n        if numbers[start] + numbers[end] == target_sum and numbers[start] * numbers[end] == target_product:\n            return 1"
    },
    {
        "number": 3139,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = []\n    for _ in range(n):\n        line = stdin.split()\n        if line[0] == \"D\":\n            students.append((int(line[1]), int(line[2])))\n        elif line[0] == \"P\":\n            i = int(line[1]) - 1\n            if i < len(students) and students[i][0] >= students[i][1]:\n                print(\"NE\")\n            else:\n                print(i + 1)\n    return \"\""
    },
    {
        "number": 3140,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.split())\n    x_0, y_0 = map(int, stdin.split())\n    t = [list(map(int, stdin.split())) for _ in range(r)]\n\n    def bfs(x, y, visited):\n        queue = [(x, y)]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if (x, y) == (r - 1, c - 1):\n                    return visited\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < r and 0 <= ny < c and t[nx][ny] <= l:\n                        queue.append((nx, ny))\n        return visited\n\n    visited = set()\n    visited.add((x_0, y_0))\n    max_points = 0\n    while visited:\n        visited = bfs(x_0, y_0, visited)\n        max_points = max(max_points, len(visited))\n\n    return str(max_points)"
    },
    {
        "number": 3141,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    flaws = []\n    for _ in range(int(stdin.split()[0])):\n        flaw = list(map(float, stdin.split()[1:]))\n        flaws.append(flaw)\n    flaw_diameters = [((flaw[0]-flaw[1])**2 + (flaw[0]-flaw[2])**2 + (flaw[1]-flaw[2])**2)**0.5 for flaw in flaws]\n    min_diameter = min(flaw_diameters)\n    return f\"{min_diameter:.4f}\""
    },
    {
        "number": 3142,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    min_num = float('inf')\n    for num in range(A, B+1):\n        if sum(int(digit) for digit in str(num)) == S:\n            count += 1\n            if num < min_num:\n                min_num = num\n    return str(count) + '\\n' + str(min_num)"
    },
    {
        "number": 3143,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def find_position(name: int) -> int:\n        for i, x in enumerate(b):\n            if x == name:\n                return i\n        return -1\n\n    def find_min_inspections(name: int) -> int:\n        min_inspections = 0\n        for i, x in enumerate(a):\n            if x == name:\n                min_inspections += 1\n                if i > 0:\n                    min_inspections += find_min_inspections(a[i - 1])\n        return min_inspections\n\n    min_inspections = float('inf')\n    for i in range(1, n + 1):\n        position = find_position(i)\n        if position!= -1:\n            min_inspections = min(min_inspections, find_min_inspections(i))\n\n    positions = []\n    for i in range(1, n + 1):\n        position = find_position(i)\n        if position!= -1:\n            positions.append(position)\n\n    return str(min_inspections) + '\\n' +''.join(map(str, positions))"
    },
    {
        "number": 3144,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    coins = [d, g]\n    rounds = 0\n    while rounds < n:\n        if rounds in [0, k]:\n            g += 1\n        else:\n            g -= 1\n        if g < 0:\n            g = 0\n        coins.append(g)\n        rounds += 1\n    return str(max(coins))"
    },
    {
        "number": 3145,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split())\n    allowed_digits = set(stdin.split()[1])\n\n    def is_valid(num: int) -> bool:\n        return all(d in allowed_digits for d in str(num))\n\n    count = 0\n    for i in range(A, B + 1):\n        if i % X == 0 and is_valid(i):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3146,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    prescriptions = []\n    for _ in range(n):\n        d, t, t_type = map(int, stdin.split())\n        prescriptions.append((d, t, t_type))\n\n    prescriptions.sort(key=lambda x: (x[0], x[2]))\n\n    in_store_prescriptions = [p for p in prescriptions if p[2] == 'R']\n    remote_prescriptions = [p for p in prescriptions if p[2] == 'S']\n\n    in_store_times = [p[1] for p in in_store_prescriptions]\n    remote_times = [p[1] for p in remote_prescriptions]\n\n    in_store_completion_time = sum(in_store_times) / len(in_store_times)\n    remote_completion_time = sum(remote_times) / len(remote_times)\n\n    return f\"{in_store_completion_time:.6f} {remote_completion_time:.6f}\""
    },
    {
        "number": 3147,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    memory = []\n    for _ in range(R):\n        row = list(stdin.strip())\n        memory.append(row)\n\n    killers = []\n    for i in range(R):\n        for j in range(C):\n            if memory[i][j] == '1':\n                killer = []\n                for k in range(i, i + 3):\n                    for l in range(j, j + 3):\n                        if k == i and l == j:\n                            continue\n                        killer.append(memory[k][l])\n                killers.append(killer)\n\n    max_killer = 0\n    for killer in killers:\n        if len(killer) > max_killer:\n            max_killer = len(killer)\n\n    if max_killer == 0:\n        return -1\n    else:\n        return str(max_killer)"
    },
    {
        "number": 3148,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    swimmers = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        swimmers.append((x, y))\n\n    swimmers.sort(key=lambda x: (x[0], x[1]))\n\n    x_sum = 0\n    y_sum = 0\n    for i in range(n):\n        x_sum += swimmers[i][0]\n        y_sum += swimmers[i][1]\n\n    x_avg = x_sum / n\n    y_avg = y_sum / n\n\n    x_diff = abs(x_avg - swimmers[0][0])\n    y_diff = abs(y_avg - swimmers[0][1])\n\n    if x_diff == y_diff:\n        return f\"{swimmers[0][0]} {swimmers[0][1]}\"\n    elif x_diff < y_diff:\n        return f\"{swimmers[0][0]} {swimmers[0][1]}\"\n    else:\n        return f\"{swimmers[0][0]} {swimmers[0][1]}\""
    },
    {
        "number": 3149,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, omega, v0, theta, w = map(float, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        vertices.append((x, y))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def angle(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p2[1]) - (p2[1] - p1[1]) * (p3[0] - p2[0])\n\n    def intersect(p1, p2, p3, p4):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n        )\n\n    def is_inside(p, p1, p2, p3):\n        return (\n            (p[0] - p1[0]) * (p2[1] - p3[1]) - (p[1] - p1[1]) * (p2[0] - p3[0])\n            > 0\n        )\n\n    def is_colliding(p1, p2, p3, p4):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n        )\n\n    def is_colliding_with_wall(p1, p2, p3, p4, w):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n            and (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 > w ** 2\n        )\n\n    def is_colliding_with_vertex(p1, p2, p3, p4, v):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n            and distance(p1, v) < distance(p2, v)\n        )\n\n    def is_colliding_with_vertex_and_wall(p1, p2, p3, p4, v, w):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n            and distance(p1, v) < distance(p2, v)\n            and (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 > w ** 2\n        )\n\n    def is_colliding_with_vertex_and_corner(p1, p2, p3, p4, v, c):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n            and distance(p1, v) < distance(p2, v)\n            and distance(p1, c) < distance(p2, c)\n        )\n\n    def is_colliding_with_vertex_and_corner_and_wall(p1, p2, p3, p4, v, c, w):\n        return (\n            (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n            < 0\n            and distance(p1, v) < distance(p2, v)\n            and distance(p1, c) < distance(p"
    },
    {
        "number": 3150,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trenches = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        trenches.append((x1, y1, x2, y2))\n    trenches.sort(key=lambda x: (x[0], x[1]))\n\n    def dfs(start, end, count):\n        if start == end:\n            return 1\n        if count == 0:\n            return 0\n\n        count -= 1\n        ways = 0\n        for i in range(start, end):\n            if trenches[i][0] == trenches[start][0] and trenches[i][1] == trenches[start][1]:\n                continue\n            if trenches[i][0] == trenches[end][0] and trenches[i][1] == trenches[end][1]:\n                continue\n            if trenches[i][0] == trenches[start][0] or trenches[i][1] == trenches[start][1]:\n                continue\n            if trenches[i][0] == trenches[end][0] or trenches[i][1] == trenches[end][1]:\n                continue\n            ways += dfs(i + 1, end, count)\n        return ways\n\n    return str(dfs(0, n, 2))"
    },
    {
        "number": 3151,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1 1\"\n\n    m = int(n ** 0.5)\n    k = n - m ** 2\n\n    if m * m == n and k * k == n:\n        return f\"{m} {k}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3152,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    arr.sort()\n    min_val = arr[0]\n    max_val = arr[-1]\n    L = len(arr)\n    cost = min_val * max_val * L\n    subsequences = []\n    for i in range(L):\n        for j in range(i + 1, L):\n            subsequences.append(arr[i:j + 1])\n    subsequences.sort(key=lambda x: sum(x))\n    total_price = 0\n    for subsequence in subsequences:\n        total_price += sum(subsequence)\n    return str(total_price % 1000000000)"
    },
    {
        "number": 3153,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    purchases = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        purchases.append((a, b, 0))\n\n    def is_valid(cards: list[int], purchases: list[tuple[int, int, int]]) -> bool:\n        for purchase in purchases:\n            if purchase[2] == 0:\n                if cards[purchase[0] - 1] < 2:\n                    return False\n            elif purchase[2] == 1:\n                if cards[purchase[0] - 1] < 1:\n                    return False\n            elif purchase[2] == 2:\n                if cards[purchase[0] - 1] < 0:\n                    return False\n        return True\n\n    def find_solution(cards: list[int], purchases: list[tuple[int, int, int]]) -> str:\n        for i in range(1, n + 1):\n            if cards[i - 1] == 0:\n                cards[i - 1] = 1\n                if is_valid(cards, purchases):\n                    return f\"{i} {find_solution(cards, purchases)}\"\n                cards[i - 1] = 0\n        return \"IMPOSSIBLE\"\n\n    return find_solution(cards, purchases)"
    },
    {
        "number": 3154,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d, e = map(int, stdin.split())\n    events = []\n    for _ in range(e):\n        s, k, t = map(int, stdin.split())\n        events.append((s, k, t))\n\n    def find_best_assignment(toys: List[int]) -> List[int]:\n        crying = [0] * n\n        for s, k, t in events:\n            if t == 0:\n                crying[k - 1] = 0\n            else:\n                crying[k - 1] = 1\n\n        def is_envious(a: int, b: int, t: int) -> bool:\n            return sum(crying[:a]) > sum(crying[:b])\n\n        def is_flexible(a: int, b: int, t: int) -> bool:\n            return sum(crying[:a]) == sum(crying[:b])\n\n        def is_cannot_multitask(a: int, b: int, t: int) -> bool:\n            return crying[a - 1] + crying[b - 1] > 1\n\n        def is_uncooperative(a: int, b: int, t: int) -> bool:\n            return crying[a - 1] + crying[b - 1] == 1\n\n        def is_valid(a: int, b: int, t: int) -> bool:\n            return (\n                is_envious(a, b, t)\n                and is_flexible(a, b, t)\n                and is_cannot_multitask(a, b, t)\n                and is_uncooperative(a, b, t)\n            )\n\n        def is_valid_assignment(assignment: List[int]) -> bool:\n            for i in range(n):\n                if crying[i] == 1 and assignment[i] == 0:\n                    return False\n            return True\n\n        def is_valid_assignment_with_enjoyment(assignment: List[int]) -> bool:\n            for i in range(n):\n                if crying[i] == 1 and assignment[i] == 0:\n                    return False\n                if crying[i] == 0 and assignment[i]!= 0:\n                    return False\n            return True\n\n        def enjoyment(assignment: List[int]) -> int:\n            enjoyment = 0\n            for i in range(n):\n                if crying[i] == 1 and assignment[i] == 0:\n                    enjoyment += 1\n            return enjoyment\n\n        def enjoyment_score(assignment: List[int]) -> int:\n            return enjoyment(assignment) * (enjoyment(assignment) + 1)\n\n        def is_better(a: List[int], b: List[int]) -> bool:\n            return enjoyment_score(a) > enjoyment_score(b)\n\n        def is_equal(a: List[int], b: List[int]) -> bool:\n            return enjoyment_score(a) == enjoyment_score(b)\n\n        def is_worse(a: List[int], b: List[int]) -> bool:\n            return enjoyment_score(a) < enjoyment_score(b)\n\n        def is_best_assignment(assignment: List[int]) -> bool:\n            return is_better(assignment, best_assignment)\n\n        def is_best_assignment_with_enjoyment(assignment: List[int]) -> bool:\n            return is_best_assignment(assignment) and is_valid_assignment_with_enjoyment(assignment)\n\n        def is_best_assignment_with_enjoyment_score(assignment: List[int]) -> bool:\n            return is_best_assignment_with_enjoyment(assignment) and enjoyment_score(assignment) == best_enjoyment_score\n\n        def is_best_assignment_with_enjoyment_score_and_enjoyment(assignment: List[int]) -> bool:\n            return is_best_assignment_with_enjoyment(assignment) and enjoyment_score(assignment) == best_enjoyment_score and enjoyment(assignment) == best_enjoyment\n\n        def is_best_assignment_with_enjoyment_score_and_enjoyment_score(assignment: List[int]) -> bool:\n            return is_best_assignment_with_enjoyment_score(assignment) and enjoyment_score(assignment) == best_enjoyment_score\n\n        def is_best_assignment_with_enjoy"
    },
    {
        "number": 3155,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 1\n    k = 1\n    while True:\n        n += 1\n        k += 1\n        if n * k > X:\n            break\n    return str(n) + \" \" + str(k)"
    },
    {
        "number": 3156,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stores = [[] for _ in range(n)]\n    items = set()\n\n    for _ in range(k):\n        i, s = map(int, stdin.split()) - 1, stdin.split()[1]\n        stores[i].append(s)\n        items.add(s)\n\n    m, k = map(int, stdin.split())\n    bought = set(stdin.split()[1:])\n\n    def dfs(i, path):\n        if path == bought:\n            return True\n\n        if i == n:\n            return False\n\n        for s in stores[i]:\n            if s not in path:\n                if dfs(i + 1, path | {s}):\n                    return True\n\n        return False\n\n    if dfs(0, set()):\n        return \"unique\"\n    elif dfs(0, set()):\n        return \"ambiguous\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3157,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    if m < 6 or m > 25:\n        return \"Invalid input\"\n\n    def f(word: str) -> int:\n        if not word:\n            return 0\n        return (f(word[1:]) * 33) ^ ord(word[0])\n\n    count = 0\n    for i in range(26):\n        word = chr(i + ord('a')) * n\n        if f(word) == k:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3158,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    images = stdin.split('\\n\\n')\n    image1 = [list(line.strip()) for line in images[0].split('\\n')]\n    image2 = [list(line.strip()) for line in images[1].split('\\n')]\n\n    def count_touches(image: list) -> int:\n        return sum(1 for row in image for pixel in row if pixel == 'X')\n\n    def count_gestures(image1: list, image2: list) -> int:\n        count = 0\n        for i in range(len(image1)):\n            for j in range(len(image1[0])):\n                if image1[i][j] == 'X' and image2[i][j] == 'X':\n                    count += 1\n        return count\n\n    def distance(grip1: list, grip2: list) -> float:\n        return sum((grip1[i] - grip2[i]) ** 2 for i in range(len(grip1))) ** 0.5\n\n    def touch_vector(grip: list, touch: list) -> list:\n        return [touch[i] - grip[i] for i in range(len(touch))]\n\n    def grip_spread(grip: list) -> float:\n        return sum(distance(grip, touch) for touch in grip) / len(grip)\n\n    def zoom_direction(grip1: list, grip2: list) -> str:\n        return 'in' if grip2[0] < grip1[0] else 'out'\n\n    def rotate_direction(grip1: list, grip2: list) -> str:\n        angle = angle_between_vectors(touch_vector(grip1, grip2[0]), touch_vector(grip1, grip2[1]))\n        return 'clockwise' if angle > 0 else 'counter-clockwise'\n\n    def angle_between_vectors(v1: list, v2: list) -> float:\n        return abs(v1[0] * v2[1] - v1[1] * v2[0]) / (distance(v1, v2) ** 2) ** 0.5\n\n    def classify_gesture(grip1: list, grip2: list) -> str:\n        if count_touches(grip1) == 1 and count_touches(grip2) == 1:\n            return 'pan'\n        elif count_touches(grip1) == 2 and count_touches(grip2) == 2:\n            return 'zoom'\n        elif count_touches(grip1) == 2 and count_touches(grip2) == 1:\n            return 'zoom'\n        elif count_touches(grip1) == 1 and count_touches(grip2) == 2:\n            return 'zoom'\n        elif count_touches(grip1) == 2 and count_touches(grip2) == 3:\n            return 'rotate'\n        elif count_touches(grip1) == 3 and count_touches(grip2) == 2:\n            return 'rotate'\n        else:\n            return 'unknown'\n\n    def classify_gestures(image1: list, image2: list) -> str:\n        count = count_gestures(image1, image2)\n        if count == 1:\n            return classify_gesture(image1, image2)\n        elif count == 2:\n            grip1 = [sum(image1[i][j] == 'X' for j in range(len(image1[0]))) / len(image1[0]),\n                     sum(image1[i][j] == 'X' for i in range(len(image1))) / len(image1)]\n            grip2 = [sum(image2[i][j] == 'X' for j in range(len(image2[0]))) / len(image2[0]),\n                     sum(image2[i][j] == 'X' for i in range(len(image2))) / len(image2)]\n            return f'{classify_gesture(grip1, grip2)} {zoom_direction(grip1, grip2)}'\n        elif count == 3:\n            grip1 = [sum(image1[i][j] == 'X' for j in range(len(image1[0]))) / len(image1[0]),\n                     sum(image1[i][j] == 'X' for i in range(len(image1))) / len(image1)]\n            g"
    },
    {
        "number": 3159,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    height, width = map(int, stdin.split())\n    web_page = [list(line.strip()) for line in stdin.splitlines()]\n\n    def is_valid_image(image: list) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1] == '$' and image[i + 1] == '$':\n                return False\n        return True\n\n    def is_valid_border(image: list) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$':\n                return False\n        return True\n\n    def is_valid_image_border(image: list) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$':\n                return False\n        return True\n\n    def is_valid_image_border_adjacent(image: list) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$' and (i == 1 or i == len(image) - 2):\n                return False\n        return True\n\n    def is_valid_image_border_contact(image: list) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$' and (i == 1 or i == len(image) - 2) and (i - 1 == 0 or i + 1 == len(image) - 1):\n                return False\n        return True\n\n    def is_valid_image_border_banned_character(image: list, banned_characters: set) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$' and (i == 1 or i == len(image) - 2) and (i - 1 == 0 or i + 1 == len(image) - 1):\n                for char in banned_characters:\n                    if char in image[i - 1] or char in image[i + 1]:\n                        return False\n        return True\n\n    def is_valid_image_border_banned_character_min_size(image: list, banned_characters: set, min_size: int) -> bool:\n        for i in range(1, len(image) - 1):\n            if image[i] == '$' and image[i - 1]!= '$' and image[i + 1]!= '$' and (i == 1 or i == len(image) - 2) and (i - 1 == 0 or i + 1 == len(image) - 1):\n                for char in banned_characters:\n                    if char in image[i - 1] or char in image[i + 1]:\n                        min_image_size = min(len(image[i - 1]), len(image[i + 1]))\n                        if min_image_size < min_size:\n                            return False\n        return True\n\n    def remove_banned_characters(image: list, banned_characters: set) -> list:\n        for char in banned_characters:\n            image = [char if char in image_part else'' for image_part in image]\n        return image\n\n    def remove_ad(image: list, banned_characters: set) -> list:\n        min_image_size = min(len(image[1:-1]), len(image[1:-1][1:-1]))\n        if is_valid_image_border_banned_character_min_size(image, banned_characters, min_image_size):\n            return remove_banned_characters(image, banned_characters)\n        return image\n\n    def remove_ads(web_page: list, banned_characters: set) -> list:\n        for i in range(len(web_page)):\n            for j in range(len(web_page[i])):\n                if web_page[i][j] == '$':\n                    web_page[i][j] =''\n               "
    },
    {
        "number": 3160,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    coins = list(stdin)\n    n = len(coins)\n    k = 0\n    total_operations = 0\n    while k < n:\n        if coins[k] == 'H':\n            k += 1\n        else:\n            k = 0\n        total_operations += k\n    return str(total_operations / n)"
    },
    {
        "number": 3161,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    target = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    target = [[0 if pixel == 0 else 1 for pixel in row] for row in target]\n\n    def paint(x, y, target, visited):\n        if (x, y) in visited:\n            return 0\n\n        visited.add((x, y))\n\n        if (x, y) == (N - 1, N - 1):\n            return 0\n\n        if target[x][y] == 0:\n            return 1\n\n        diff = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if 0 <= x + dx < N and 0 <= y + dy < N and target[x + dx][y + dy] == 1:\n                diff += paint(x + dx, y + dy, target, visited)\n\n        return diff + 1\n\n    diff = float('inf')\n    for i in range(N):\n        for j in range(N):\n            visited = set()\n            diff = min(diff, paint(i, j, target, visited))\n\n    return str(diff)"
    },
    {
        "number": 3162,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    current_pulses = []\n    for i in range(n):\n        direction, start_time, length, wire_number = stdin.split()[1:5]\n        current_pulses.append((direction, int(start_time), int(length), int(wire_number)))\n\n    current_time = 0\n    activated_pixels = 0\n\n    for pulse in current_pulses:\n        if pulse[0] == 'h':\n            if current_time >= pulse[1] and current_time < pulse[1] + pulse[2]:\n                activated_pixels += 1\n        else:\n            if current_time >= pulse[1] and current_time < pulse[1] + pulse[2]:\n                activated_pixels += 1\n\n        current_time += pulse[2]\n\n    return str(activated_pixels)"
    },
    {
        "number": 3163,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    shelves = [list(map(int, stdin.split())) for _ in range(n)]\n    wanted_shelves = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_valid(shelf: List[int]) -> bool:\n        return all(book!= 0 for book in shelf)\n\n    def is_empty(shelf: List[int]) -> bool:\n        return all(book == 0 for book in shelf)\n\n    def is_book_in_hand(shelf: List[int]) -> bool:\n        return any(book!= 0 for book in shelf)\n\n    def is_book_available(shelf: List[int], book: int) -> bool:\n        return any(book == i for i in shelf)\n\n    def move_book(shelf: List[int], book: int, target_shelf: List[int]) -> int:\n        if is_book_available(target_shelf, book):\n            target_shelf[book] = 0\n            shelf[book] = 0\n            return 1\n        return 0\n\n    def move_books(shelf: List[int], target_shelf: List[int]) -> int:\n        lifting = 0\n        for book in range(1, m + 1):\n            if is_book_available(shelf, book) and is_book_available(target_shelf, book):\n                lifting += move_book(shelf, book, target_shelf)\n        return lifting\n\n    def find_min_lifting(shelves: List[List[int]], wanted_shelves: List[List[int]]) -> int:\n        min_lifting = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if is_valid(shelves[i]) and is_valid(wanted_shelves[i]):\n                    lifting = move_books(shelves[i], wanted_shelves[i])\n                    if lifting < min_lifting:\n                        min_lifting = lifting\n        return min_lifting if min_lifting!= float('inf') else -1\n\n    return str(find_min_lifting(shelves, wanted_shelves))\n"
    },
    {
        "number": 3164,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_len = 0\n    current_len = 1\n    start = 0\n\n    for i in range(1, N):\n        if arr[i] == arr[i - 1]:\n            current_len += 1\n        else:\n            if current_len > max_len:\n                max_len = current_len\n            current_len = 1\n            start = i\n\n    if current_len > max_len:\n        max_len = current_len\n\n    return str(max_len)"
    },
    {
        "number": 3165,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    rooks = []\n    for _ in range(k):\n        r, c, x = map(int, stdin.split())\n        rooks.append((r - 1, c - 1, x))\n\n    moves = []\n    for _ in range(p):\n        r1, c1, r2, c2 = map(int, stdin.split())\n        moves.append((r1 - 1, c1 - 1, r2 - 1, c2 - 1))\n\n    def count_attacked_fields(r, c, power):\n        def is_attacked(x, y):\n            return any(\n                (x, y) in rooks\n                and (x, y)!= (r, c)\n                and (x, y)!= (x, y)\n                and (x, y)!= (x, y) + (r, y)\n                and (x, y)!= (x, y) + (y, r)\n            )\n\n        def count_fields(x, y):\n            return sum(is_attacked(x, y) for y in range(n))\n\n        return count_fields(r, c) + sum(count_fields(x, y) for x in range(n) for y in range(n) if x!= r and y!= c)\n\n    result = [count_attacked_fields(r, c, x) for r, c, x in rooks]\n    for r1, c1, r2, c2 in moves:\n        result[r1][c1] -= result[r2][c2]\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3166,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    beats = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    disqualified = list(map(int, stdin.split('\\n')[2].split()))\n\n    def find_fair_ranking(disqualified: list) -> int:\n        def find_rank(player: int) -> int:\n            for i, (beat, disqualified_player) in enumerate(beats):\n                if beat and disqualified_player == player:\n                    return i + 1\n            return 0\n\n        ranks = [find_rank(player) for player in range(n)]\n        return max(ranks)\n\n    fair_rank = find_fair_ranking(disqualified)\n    if fair_rank == n:\n        return \"impossible\"\n    else:\n        return str(fair_rank)"
    },
    {
        "number": 3167,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    X = list(map(int, stdin.split()))\n    Q = int(stdin.split()[1])\n    result = []\n\n    for i in range(Q):\n        L, R = map(int, stdin.split())\n        result.append(sum(X[L:R+1]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3168,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    def insert(node: TreeNode, value: int) -> int:\n        if not node:\n            return TreeNode(value)\n\n        if value < node.value:\n            node.left = insert(node.left, value)\n        else:\n            node.right = insert(node.right, value)\n\n        node.depth += 1\n        return node\n\n    root = insert(None, sequence[0])\n    C = 0\n\n    for value in sequence[1:]:\n        root = insert(root, value)\n        C += root.depth\n\n    return \"\\n\".join(map(str, C))\n"
    },
    {
        "number": 3169,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sticks = []\n    for line in stdin.split('\\n'):\n        x1, y1, x2, y2 = map(int, line.split())\n        sticks.append((x1, y1, x2, y2))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def closest_stick(stick):\n        closest = stick\n        for s in sticks:\n            if distance(stick, s) < distance(stick, closest):\n                closest = s\n        return closest\n\n    def stick_order(stick):\n        closest = closest_stick(stick)\n        return (stick[0] - closest[0], stick[1] - closest[1])\n\n    stick_orders = sorted(sticks, key=stick_order)\n\n    result = []\n    for stick in stick_orders:\n        result.append(f\"{stick[0]} {stick[1]}\")\n\n    return''.join(result)"
    },
    {
        "number": 3170,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    deck = [c for c in stdin]\n    deck.sort()\n    theta_cards = deck[:10]\n    friend_cards = deck[10:]\n\n    theta_cards.sort()\n    friend_cards.sort()\n\n    for i in range(10):\n        if theta_cards[i]!= friend_cards[i]:\n            return \"Theta wins\"\n\n    return \"Theta loses\""
    },
    {
        "number": 3171,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    candidates = [[] for _ in range(N + 1)]\n    for _ in range(K):\n        name, *propositions = stdin.split()\n        candidates[int(name)].append(propositions)\n\n    def is_truther(propositions: list) -> bool:\n        return \"truther\" in propositions\n\n    def is_fabulist(propositions: list) -> bool:\n        return \"fabulist\" in propositions\n\n    def is_charlatan(propositions: list) -> bool:\n        return \"charlatan\" in propositions\n\n    truthers = [propositions for propositions in candidates[1:] if is_truther(propositions)]\n    fabulists = [propositions for propositions in candidates[1:] if is_fabulist(propositions)]\n    charlatans = [propositions for propositions in candidates[1:] if is_charlatan(propositions)]\n\n    truther_count = sum(1 for propositions in truthers)\n    fabulist_count = sum(1 for propositions in fabulists)\n    charlatan_count = sum(1 for propositions in charlatans)\n\n    if truther_count > 0:\n        return \"truther\"\n    elif fabulist_count > 0:\n        return \"fabulist\"\n    elif charlatan_count > 0:\n        return \"charlatan\"\n    else:\n        return \"unknown\""
    },
    {
        "number": 3172,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fruits = []\n    for i in range(n):\n        x, y = map(float, stdin.split()[1:3])\n        fruits.append((x, y))\n    fruits.sort(key=lambda x: x[0])\n    max_slices = 0\n    current_slice = 0\n    for i in range(1, n):\n        if fruits[i][0] - fruits[i - 1][0] == 0:\n            current_slice += 1\n        else:\n            max_slices = max(max_slices, current_slice)\n            current_slice = 1\n    max_slices = max(max_slices, current_slice)\n    return str(max_slices)"
    },
    {
        "number": 3173,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    grid = []\n    for _ in range(R):\n        row = list(stdin.readline().strip())\n        grid.append(row)\n\n    def is_last_row(row: list) -> bool:\n        return row[-1] == '.'\n\n    def is_last_column(row: list) -> bool:\n        return all(row[i] == '.' for i in range(len(row) - 1))\n\n    def is_valid_position(row: list, col: int) -> bool:\n        return 0 <= col < len(row) and row[col] == '.'\n\n    def set_belt(row: list, col: int, direction: str) -> None:\n        if direction == 'R':\n            row[col] = 'R'\n        elif direction == 'L':\n            row[col] = 'L'\n        else:\n            row[col] = '?'\n\n    def set_position(row: list, col: int, position: int) -> None:\n        row[col] = str(position)\n\n    def get_position(row: list, col: int) -> int:\n        return int(row[col])\n\n    def get_score(row: list) -> int:\n        return sum(map(int, row))\n\n    def get_max_score(grid: list) -> int:\n        max_score = 0\n        for row in grid:\n            if is_last_row(row):\n                max_score = max(max_score, get_score(row))\n        return max_score\n\n    def get_valid_positions(row: list) -> list:\n        return [i for i in range(len(row)) if is_valid_position(row, i)]\n\n    def get_valid_positions_for_belt(row: list, col: int) -> list:\n        positions = get_valid_positions(row)\n        belt_positions = [i for i in positions if row[i] == '?' or row[i] == row[col]]\n        return belt_positions\n\n    def get_belt_positions(row: list, col: int) -> list:\n        positions = get_valid_positions(row)\n        belt_positions = [i for i in positions if row[i] == row[col]]\n        return belt_positions\n\n    def get_belt_directions(row: list, col: int) -> list:\n        positions = get_valid_positions(row)\n        belt_positions = [i for i in positions if row[i] == row[col]]\n        return [row[i] for i in belt_positions]\n\n    def get_belt_positions_for_direction(row: list, col: int, direction: str) -> list:\n        positions = get_belt_positions(row, col)\n        return [i for i in positions if row[i] == direction]\n\n    def get_belt_positions_for_belt(row: list, col: int, direction: str) -> list:\n        positions = get_belt_positions_for_direction(row, col, direction)\n        return [i for i in positions if row[i] == row[col]]\n\n    def get_belt_positions_for_belt_and_direction(row: list, col: int, direction: str) -> list:\n        positions = get_belt_positions_for_belt(row, col, direction)\n        return [i for i in positions if row[i] == row[col]]\n\n    def get_belt_positions_for_belt_and_direction_and_position(row: list, col: int, direction: str, position: int) -> list:\n        positions = get_belt_positions_for_belt_and_direction(row, col, direction)\n        return [i for i in positions if get_position(row, i) == position]\n\n    def get_belt_positions_for_belt_and_direction_and_position_and_score(row: list, col: int, direction: str, position: int, score: int) -> list:\n        positions = get_belt_positions_for_belt_and_direction_and_position(row, col, direction, position)\n        return [i for i in positions if get_score(row) == score]\n\n    def get_belt_positions_for_belt_and_direction_and_position_and_score_and_belt_positions(row: list, col: int, direction: str, position: int, score: int, belt_positions: list"
    },
    {
        "number": 3174,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cities = []\n    for _ in range(n):\n        x, y, k = map(int, stdin.split())\n        cities.append((x, y, k))\n\n    def is_happy(x: int) -> bool:\n        while x!= 1:\n            x = sum(int(digit) ** 2 for digit in str(x))\n        return x == 1\n\n    def is_divisible(cities: List[Tuple[int, int, int]]) -> bool:\n        total_residents = sum(city[2] for city in cities)\n        return total_residents % k == 0\n\n    def is_valid(cities: List[Tuple[int, int, int]]) -> bool:\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                if is_happy(cities[i][0] - cities[j][0]) and is_happy(cities[i][1] - cities[j][1]):\n                    return False\n        return True\n\n    def min_distance(cities: List[Tuple[int, int, int]]) -> float:\n        min_distance = float('inf')\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                distance = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    def min_distance_with_roads(cities: List[Tuple[int, int, int]]) -> float:\n        min_distance = float('inf')\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                distance = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    def min_distance_with_roads_and_happy(cities: List[Tuple[int, int, int]]) -> float:\n        min_distance = float('inf')\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                distance = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    def min_distance_with_roads_and_happy_and_divisible(cities: List[Tuple[int, int, int]]) -> float:\n        min_distance = float('inf')\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                distance = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    min_distance_with_roads_and_happy_and_divisible_cities = [city for city in cities if is_divisible(cities) and is_valid(cities)]\n    min_distance_with_roads_and_happy_cities = [city for city in cities if is_valid(cities)]\n    min_distance_with_roads_cities = [city for city in cities]\n    min_distance_cities = [city for city in cities]\n\n    min_distance_with_roads_and_happy_and_divisible_cities_distance = min_distance_with_roads_and_happy_and_divisible(min_distance_with_roads_and_happy_and_divisible_cities)\n    min_distance_with_roads_and_happy_cities_distance = min_distance_with_roads_and_happy(min_distance_with_roads_and_happy_cities)\n    min_distance_with_roads_cities_distance = min_distance_with_roads(min_distance_with_roads_cities)\n    min_distance_cities_distance = min_distance(min_distance_cities)\n\n    min_distance_with_roads_and_happy_and_divisible_cities_happy = min_distance_with_"
    },
    {
        "number": 3175,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    lengths.sort(reverse=True)\n    area = 0\n    for length in lengths:\n        area += length * length\n    return str(area)"
    },
    {
        "number": 3176,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    plants = []\n    for _ in range(n):\n        x, y, f = map(int, stdin.split())\n        plants.append((x, y, f))\n\n    def can_jump(x1, y1, x2, y2):\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def jump(x1, y1, x2, y2, energy):\n        if not can_jump(x1, y1, x2, y2):\n            return False, energy\n        return True, energy - k\n\n    def dfs(x, y, energy):\n        if x == n:\n            return energy\n        if x == 1:\n            return dfs(x + 1, y, energy + 1)\n\n        can_jump_to_x, energy = jump(x, y, plants[x - 1][0], plants[x - 1][1], energy)\n        if can_jump_to_x:\n            return dfs(x + 1, plants[x - 1][0], energy)\n\n        can_jump_to_y, energy = jump(x, y, plants[x - 1][0], plants[x - 1][1], energy)\n        if can_jump_to_y:\n            return dfs(x + 1, plants[x - 1][0], energy)\n\n        return dfs(x + 1, y, energy)\n\n    return str(dfs(1, 1, 0))"
    },
    {
        "number": 3177,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    permutation = list(map(int, stdin.split()))\n    swaps = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        swaps.append((a - 1, b - 1))\n\n    def is_valid(swap):\n        a, b = swap\n        return a!= b and a < n and b < n\n\n    swaps = list(filter(is_valid, swaps))\n\n    def backtrack(i, path):\n        if i == n:\n            return path\n        for j, (a, b) in enumerate(swaps):\n            if a == i:\n                return backtrack(b, path + [b + 1])\n        return backtrack(i + 1, path)\n\n    path = backtrack(0, [])\n    return str(len(path))"
    },
    {
        "number": 3178,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    min_cost = float('inf')\n    for i in range(1, n + 1):\n        if not visited[i]:\n            visited[i] = True\n            cycle_cost = dfs(graph, i, visited)\n            if cycle_cost!= -1:\n                min_cost = min(min_cost, cycle_cost)\n    return str(min_cost) if min_cost!= float('inf') else '-1'\n\n\ndef"
    },
    {
        "number": 3179,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n\n    def is_collinear(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p2[1]) == (p3[0] - p2[0]) * (p1[1] - p2[1])\n\n    def is_inside(p, points):\n        return any(is_collinear(p, q, r) for q, r in zip(points, points[1:]))\n\n    def is_convex(points):\n        return all(is_inside(p, points) for p in points)\n\n    def convex_hull(points):\n        hull = []\n        stack = []\n        for p in points:\n            while stack and is_collinear(stack[-1], stack[-2], p):\n                stack.pop()\n            stack.append(p)\n            if not stack or is_inside(p, stack):\n                hull.append(p)\n        return hull\n\n    def area(points):\n        return 0.5 * sum(x[0] * y[1] - x[1] * y[0] for x, y in zip(points, points[1:]))\n\n    def min_side_length(points):\n        hull = convex_hull(points)\n        return max(abs(x[0] - y[0]) for x, y in zip(hull, hull[1:]))\n\n    def min_side_length_map(points):\n        min_side_length_map = []\n        for i in range(k):\n            min_side_length_map.append(min_side_length(points))\n        return min_side_length_map\n\n    min_side_length_map = min_side_length_map(points)\n    return f\"{min_side_length_map[0]:.2f}\""
    },
    {
        "number": 3180,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    commands = stdin.split('\\n')[2:]\n    painting = [1] * N * N\n    for command in commands:\n        if command.startswith('PAINT'):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            if x1 > x2:\n                x1, x2 = x2, x1\n            if y1 > y2:\n                y1, y2 = y2, y1\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    painting[i + j * N] = c\n        elif command.startswith('SAVE'):\n            save_count += 1\n            save_commands.append(painting)\n        elif command.startswith('LOAD'):\n            c, x = map(int, command.split()[1:])\n            painting = save_commands[x - 1]\n    return''.join(map(str, painting))\n\nsave_count = 0\nsave_commands = []"
    },
    {
        "number": 3181,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return -1\n\n    def is_monotone(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return True\n        return False\n\n    def longest_monotone_subsequence(arr):\n        max_length = 1\n        start = 0\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i - 1]:\n                if i - start + 1 > max_length:\n                    max_length = i - start + 1\n                    end = i\n        return arr[start:end + 1]\n\n    def find_sequence(n, k):\n        arr = list(range(1, n + 1))\n        while True:\n            if is_monotone(arr) and len(longest_monotone_subsequence(arr)) == k:\n                return arr\n            arr.append(max(arr) + 1)\n\n    sequence = find_sequence(n, k)\n    if sequence:\n        return \" \".join(map(str, sequence))\n    else:\n        return -1\n"
    },
    {
        "number": 3182,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if points[i][0] + points[j][0] > points[k][0]:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3183,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split())\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))\n    dist = [float('inf')] * n\n    dist[s] = 0\n    prev = [-1] * n\n    q = [(s, 0)]\n    while q:\n        u, d = q.pop(0)\n        if d > dist[u]:\n            continue\n        for v, c, w in graph[u]:\n            if c > 0 and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                prev[v] = u\n                q.append((v, dist[v]))\n    if dist[t] == float('inf'):\n        return '0 0'\n    flow = 0\n    cost = 0\n    u = t\n    while u!= s:\n        flow += 1\n        v = prev[u]\n        cost += dist[u] * graph[u][v][2]\n        u = v\n    flow += 1\n    cost += dist[u] * graph[u][t][2]\n    return f'{flow} {cost}'"
    },
    {
        "number": 3184,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cameras = []\n    for _ in range(k):\n        a, b = map(int, stdin.split())\n        cameras.append((a, b))\n    cameras.sort()\n    for i in range(n):\n        if i == 0 or cameras[0][0] > i:\n            cameras.insert(0, (i, i))\n    for i in range(1, len(cameras)):\n        if cameras[i][0] > cameras[i - 1][1]:\n            return \"impossible\"\n    return len(cameras)"
    },
    {
        "number": 3185,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    return str(n)"
    },
    {
        "number": 3186,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    dp = [[0] * (K + 1) for _ in range(N + 1)]\n\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if j >= i:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - i]) % MOD\n\n    return str(dp[N][K])"
    },
    {
        "number": 3187,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *houses = map(int, stdin.split())\n    houses = set(houses)\n    d = int(stdin.split()[1])\n\n    def distance(x1: int, y1: int, x2: int, y2: int) -> int:\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_distance(x: int, y: int) -> int:\n        return min(distance(x, y, *house) for house in houses)\n\n    def min_distance_from_center(x: int, y: int) -> int:\n        return min_distance(x, y) + d\n\n    min_distance_from_center_x = min(x for x, y in houses)\n    min_distance_from_center_y = min(y for x, y in houses)\n\n    if min_distance_from_center(min_distance_from_center_x, min_distance_from_center_y) > d:\n        return \"impossible\"\n    else:\n        return str(min_distance_from_center(min_distance_from_center_x, min_distance_from_center_y))\n"
    },
    {
        "number": 3188,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    planets = []\n    for _ in range(N):\n        x, y, z = map(int, stdin.split()[1:])\n        planets.append((x, y, z))\n    planets.sort(key=lambda x: (x[0], x[1], x[2]))\n    tunnel_costs = []\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            tunnel_costs.append(min(abs(planets[i][0] - planets[j][0]), abs(planets[i][1] - planets[j][1]), abs(planets[i][2] - planets[j][2])))\n    return str(min(tunnel_costs))"
    },
    {
        "number": 3189,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    photos = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    count = 0\n    for i in range(1, 1 << n):\n        for j in range(1, 1 << m):\n            if all(photos[k][i >> k & 1] == 1 for k in range(m)):\n                count += 1\n                if count % 1000003 == 0:\n                    return str(count)\n    return str(count)"
    },
    {
        "number": 3190,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *prices = map(int, stdin.split())\n    P = int(stdin.split()[2])\n\n    prices.sort()\n    count = 1\n    current_sum = prices[0]\n\n    for i in range(1, N):\n        if prices[i] - current_sum >= P:\n            count += 1\n            current_sum = prices[i]\n\n    return str(count)"
    },
    {
        "number": 3191,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    code = [f\"printf(\\\"{i}\\\");\" for i in range(n)]\n    code.append(\"int main() { return 0; }\")\n    code = \"\\n\".join(code)\n\n    start_time = time.time()\n    with tempfile.NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(code)\n        f.flush()\n        os.fsync(f.fileno())\n        pid = os.fork()\n        if pid == 0:\n            os.execlp(\"gcc\", \"gcc\", \"-o\", \"a.out\", f.name)\n        else:\n            os.wait()\n\n    end_time = time.time()\n    total_time = end_time - start_time\n\n    if pid == 0:\n        time.sleep(r)\n        os.kill(os.getppid(), signal.SIGINT)\n        os.wait()\n\n    crash_time = total_time - p\n    return str(crash_time)"
    },
    {
        "number": 3192,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    files = stdin.split()[1:]\n    file_dependencies = {}\n\n    for file_name, file_section in zip(files, stdin.split()[2:]):\n        file_dependencies[file_name] = set()\n        for import_line in file_section.split(\"\\n\")[1:]:\n            import_file_names = import_line.split(\", \")\n            for import_file_name in import_file_names:\n                file_dependencies[file_name].add(import_file_name)\n\n    def find_cycle(file_name):\n        visited = set()\n        stack = [file_name]\n        while stack:\n            current_file = stack.pop()\n            if current_file in visited:\n                return current_file\n            visited.add(current_file)\n            for import_file_name in file_dependencies[current_file]:\n                stack.append(import_file_name)\n        return None\n\n    cycle_files = []\n    for file_name in files:\n        cycle = find_cycle(file_name)\n        if cycle:\n            cycle_files.append(cycle)\n\n    if cycle_files:\n        shortest_cycle = min(cycle_files, key=len)\n        return \" \".join(shortest_cycle)\n    else:\n        return \"SHIP IT\"\n"
    },
    {
        "number": 3193,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split()\n    A = int(A)\n    P = int(P)\n    M = int(M)\n\n    def is_valid(A: int) -> bool:\n        for i in range(len(A)):\n            if A[i] == 'x':\n                return False\n        return True\n\n    def is_valid_expression(A: int) -> bool:\n        for i in range(len(A)):\n            if A[i] == 'x':\n                if i == 0 or A[i - 1] == 'x':\n                    return False\n                if i == len(A) - 1 or A[i + 1] == 'x':\n                    return False\n        return True\n\n    def is_valid_remainder(A: int, P: int, M: int) -> bool:\n        remainder = A % M\n        return remainder == P\n\n    def is_valid_laws(A: int) -> bool:\n        for i in range(len(A)):\n            if A[i] == 'x':\n                if i == 0 or A[i - 1] == 'x':\n                    return False\n                if i == len(A) - 1 or A[i + 1] == 'x':\n                    return False\n        return True\n\n    def find_minimal_x(A: int) -> int:\n        x = 0\n        while x < M and not is_valid_remainder(A, P, M):\n            x += 1\n        return x\n\n    if is_valid(int(A)):\n        if is_valid_expression(int(A)):\n            if is_valid_remainder(int(A), P, M):\n                if is_valid_laws(int(A)):\n                    return str(find_minimal_x(int(A)))\n        return \"Invalid expression\"\n    return \"Invalid arithmetic expression\""
    },
    {
        "number": 3194,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    available_periods = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        available_periods.append((a, b))\n\n    available_periods.sort(key=lambda x: x[0])\n\n    for i in range(n):\n        if available_periods[i][0] + t <= available_periods[i][1]:\n            return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 3195,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_color(t: int, t_g: int, t_y: int, t_r: int) -> str:\n        if t < t_g:\n            return \"green\"\n        elif t < t_g + t_y:\n            return \"yellow\"\n        else:\n            return \"red\"\n\n    def get_time(t: int, t_g: int, t_y: int, t_r: int) -> int:\n        if t < t_g:\n            return t\n        elif t < t_g + t_y:\n            return t_g\n        else:\n            return t_g + t_y\n\n    def get_duration(t_g: int, t_y: int, t_r: int) -> int:\n        return t_g + t_y + t_r\n\n    t_g, t_y, t_r = map(int, stdin.split()[0].split(\",\"))\n    n = int(stdin.split()[1])\n    times = []\n    colors = []\n    for _ in range(n):\n        t, c = map(int, stdin.split()[2].split())\n        times.append(t)\n        colors.append(c)\n\n    t_q = int(stdin.split()[3])\n    c_q = stdin.split()[4]\n\n    t_g, t_y, t_r = t_g, t_y, t_r\n    t_q = t_q\n\n    duration = get_duration(t_g, t_y, t_r)\n    t_start = 0\n\n    prob = 0\n    for t in times:\n        t_curr = get_time(t, t_g, t_y, t_r)\n        color = get_color(t_curr, t_g, t_y, t_r)\n        if color == c_q:\n            prob += 1\n        t_start = t_curr\n\n    prob /= len(times)\n\n    return f\"{prob:.3f}\"\n"
    },
    {
        "number": 3196,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        roads.add((a, b))\n        roads.add((b, a))\n    roads = list(roads)\n    roads.sort()\n    routes = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) in roads or (j, i) in roads:\n                routes.append((i, j))\n    routes.sort()\n    count = 0\n    for i in range(len(routes) - 1):\n        for j in range(i + 1, len(routes)):\n            if routes[i]!= routes[j]:\n                count += 1\n                if count > 999999999:\n                    count = 999999999\n    if count == 0:\n        return \"inf\"\n    return str(count)"
    },
    {
        "number": 3197,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    preferences = list(map(int, stdin.split()))\n\n    def dfs(start: int, visited: set) -> int:\n        nonlocal k\n        if len(visited) == k:\n            return 1\n\n        result = 0\n        for i in range(n):\n            if i == start or i in visited:\n                continue\n\n            visited.add(i)\n            result += dfs(i, visited)\n            visited.remove(i)\n\n        return result\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 3198,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dictionary = set(stdin.split()[1:])\n\n    typos = set()\n    for word in dictionary:\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                if j == len(word):\n                    continue\n                new_word = word[:i] + word[i + 1:]\n                if new_word in dictionary:\n                    typos.add(word)\n                    break\n\n    if not typos:\n        return \"NO TYPOS\"\n    else:\n        return \" \".join(sorted(typos))\n"
    },
    {
        "number": 3199,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    L = int(stdin.split()[1])\n\n    insecure = 0\n    secure = 0\n    super_secure = 0\n\n    for i in range(1, L + 1):\n        if i % (A + 1) == 0:\n            if i == 1:\n                insecure += 1\n            elif i == L:\n                super_secure += 1\n            else:\n                secure += 1\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3200,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    traffic_lights = []\n    for i in range(n - 1):\n        t, g, r = map(int, stdin.split()[1:])\n        traffic_lights.append((t, g, r))\n    traffic_lights.append((0, 0, 0))\n\n    def is_green(t, g, r):\n        return t <= g + r\n\n    def is_red(t, g, r):\n        return t > g + r\n\n    def is_changing_colour(t, g, r):\n        return t > g and t < g + r\n\n    def is_changing_colour_at_start(t, g, r):\n        return t > g and t == g\n\n    def is_changing_colour_at_end(t, g, r):\n        return t < g + r\n\n    def is_changing_colour_at_exact_moment(t, g, r):\n        return t == g\n\n    def is_changing_colour_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g\n\n    def is_changing_colour_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_start(t, g, r):\n        return t == g and t > g + r\n\n    def is_changing_colour_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_exact_moment_at_end(t, g, r):\n        return t == g + r\n\n    def is_changing_colour_at_exact_"
    },
    {
        "number": 3201,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def hash_array(arr):\n        h = 0\n        for i in range(len(arr)):\n            h = (h * B + arr[i]) % M\n        return h\n\n    def is_prefix(arr1, arr2):\n        for i in range(len(arr1)):\n            if arr1[i]!= arr2[i]:\n                return False\n        return True\n\n    def is_lexicographically_smaller(arr1, arr2):\n        for i in range(len(arr1)):\n            if arr1[i] < arr2[i]:\n                return True\n            elif arr1[i] > arr2[i]:\n                return False\n        return len(arr1) < len(arr2)\n\n    def find_subsequences(arr, k):\n        subsequences = []\n        for i in range(1, len(arr) + 1):\n            for j in range(i, len(arr) + 1):\n                subsequences.append(arr[j - i : j])\n        return subsequences[:k]\n\n    def find_lexicographically_smaller_subsequences(arr, k):\n        subsequences = find_subsequences(arr, k)\n        lexicographically_smaller_subsequences = []\n        for i in range(len(subsequences)):\n            for j in range(i + 1, len(subsequences)):\n                if is_lexicographically_smaller(subsequences[i], subsequences[j]):\n                    lexicographically_smaller_subsequences.append(subsequences[i])\n        return lexicographically_smaller_subsequences\n\n    def find_hash(subsequence):\n        return hash_array(subsequence)\n\n    lexicographically_smaller_subsequences = find_lexicographically_smaller_subsequences(A, K)\n    hashes = [find_hash(subsequence) for subsequence in lexicographically_smaller_subsequences]\n\n    return \"\\n\".join(map(str, hashes))\n"
    },
    {
        "number": 3202,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    arr.sort()\n    count = 0\n    for i in range(1, n):\n        if arr[i] == arr[i - 1]:\n            count += 1\n        else:\n            if count >= k:\n                return count\n            count = 0\n    return count"
    },
    {
        "number": 3203,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    jimmy_bonds = [int(x) for x in stdin.split()[1:]]\n    jimmy_bonds = [x / 100 for x in jimmy_bonds]\n\n    max_probability = 0\n    max_arrangement = []\n\n    for i in range(1, n + 1):\n        probability = 1\n        for j in range(1, n + 1):\n            if i!= j:\n                probability *= jimmy_bonds[j - 1]\n        if probability > max_probability:\n            max_probability = probability\n            max_arrangement = [i]\n        elif probability == max_probability:\n            max_arrangement.append(i)\n\n    return str(max_probability)\n"
    },
    {
        "number": 3204,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    times = [int(x) for x in stdin.split()[1:]]\n    times.sort()\n\n    total_time = 0\n    bridge_open = False\n    waiting_boats = []\n\n    for time in times:\n        if not bridge_open:\n            total_time += time\n            if total_time <= 30:\n                bridge_open = True\n                waiting_boats.append(time)\n        else:\n            total_time += time\n            if total_time > 30:\n                waiting_boats.pop(0)\n                total_time -= time\n                if total_time <= 30:\n                    bridge_open = False\n\n    return str(total_time)"
    },
    {
        "number": 3205,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    receipts = []\n    for _ in range(n):\n        a, b, p = map(int, stdin.split())\n        receipts.append((a, b, p))\n\n    def find_min_transactions(people: list, receipts: list) -> int:\n        transactions = 0\n        for i in range(len(people)):\n            for j in range(i + 1, len(people)):\n                if people[i]!= people[j]:\n                    for k in range(len(receipts)):\n                        if receipts[k][0] == people[i] and receipts[k][1] == people[j]:\n                            transactions += 1\n                            break\n        return transactions\n\n    min_transactions = find_min_transactions(list(range(m)), receipts)\n    return str(min_transactions)"
    },
    {
        "number": 3206,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    blocks = list(map(int, stdin.split()))\n    buildings = list(map(int, stdin.split()))\n\n    def stack(blocks, buildings):\n        stack = []\n        for i in range(len(blocks)):\n            while stack and stack[-1][0] > buildings[i]:\n                stack.pop()\n            if not stack or stack[-1][1] < buildings[i]:\n                stack.append((blocks[i], buildings[i]))\n            else:\n                stack[-1] = (stack[-1][0] + blocks[i], max(stack[-1][1], buildings[i]))\n        return stack\n\n    stacked = stack(blocks, buildings)\n    if not stacked:\n        return -1\n\n    result = []\n    for i in range(s):\n        if i < len(stacked):\n            result.append(str(stacked[i][0]))\n            for j in range(stacked[i][0]):\n                result.append(str(blocks.index(stacked[i][0])))\n        else:\n            result.append(\"0\")\n            for j in range(blocks.index(stacked[-1][0])):\n                result.append(str(blocks.index(stacked[-1][0])))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3207,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    chameleons = []\n    for _ in range(n):\n        d, b, direction = map(int, stdin.split())\n        chameleons.append((d, b, direction))\n\n    chameleons.sort(key=lambda x: x[0])\n\n    total_trips = [0] * k\n\n    for d, b, direction in chameleons:\n        if direction == 'L':\n            total_trips[b] += d\n        else:\n            total_trips[(b + k - 1) % k] += d\n\n    return''.join(map(str, total_trips))\n"
    },
    {
        "number": 3208,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Define the set of known words\n    known_words = {\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"}\n\n    # Define the set of unique letters in the encrypted text\n    unique_letters = set(stdin)\n\n    # Define the set of unique letters in the known words\n    unique_known_letters = set(word for word in known_words)\n\n    # Check if the set of unique letters in the encrypted text is a subset of the set of unique letters in the known words\n    if unique_letters <= unique_known_letters:\n        # Define the mapping from encrypted letters to plain text letters\n        mapping = {letter: letter for letter in unique_letters}\n\n        # Define the set of words that show up in the plain text\n        words_in_plain_text = set()\n\n        # Iterate over the encrypted text and replace each encrypted letter with its corresponding plain text letter\n        for letter in stdin:\n            if letter in mapping:\n                plain_text_letter = mapping[letter]\n            else:\n                plain_text_letter = \" \"\n\n            # Add the plain text letter to the set of words that show up in the plain text\n            words_in_plain_text.add(plain_text_letter)\n\n        # Check if the number of different letters in the words in the set of words that show up in the plain text is equal to the number of different letters in the encrypted text\n        if len(words_in_plain_text) == len(unique_letters):\n            # Define the set of words that are present in the plain text\n            words_in_plain_text = set(words_in_plain_text)\n\n            # Check if all the words in the set of words that show up in the plain text are present in the set of known words\n            if words_in_plain_text.issubset(known_words):\n                # Define the set of words that are present in the plain text and unique to the plain text\n                unique_words_in_plain_text = words_in_plain_text.intersection(unique_letters)\n\n                # Define the set of words that are present in the plain text and not unique to the plain text\n                words_not_unique_in_plain_text = words_in_plain_text.difference(unique_letters)\n\n                # Check if the number of unique words in the set of words that show up in the plain text is equal to the number of unique letters in the plain text\n                if len(unique_words_in_plain_text) == len(unique_letters):\n                    # Define the set of words that are present in the plain text and unique to the plain text and present in the set of known words\n                    unique_words_in_plain_text_known = unique_words_in_plain_text.intersection(known_words)\n\n                    # Define the set of words that are present in the plain text and unique to the plain text and not present in the set of known words\n                    words_not_unique_in_plain_text_known = unique_words_in_plain_text.difference(known_words)\n\n                    # Check if the number of unique words in the set of words that show up in the plain text and unique to the plain text and present in the set of known words is equal to the number of unique letters in the plain text\n                    if len(unique_words_in_plain_text_known) == len(unique_letters):\n                        # Define the set of words that are present in the plain text and not unique to the plain text and present in the set of known words\n                        words_not_unique_in_plain_text_known = set(words_not_unique_in_plain_text_known)\n\n                        # Check if all the words in the set of words that show up in the plain text and not unique to the plain text and present in the set of known words are present in the set of known words\n                        if words_not_unique_in_plain_text_known.issubset(known_words):\n                            # Define the set of words that are present in the plain text and not unique to the plain text and present in the set of known words and unique to the plain text\n                            unique_words_not_unique_in_plain_text_known = words_not_unique_in_plain_text_known.intersection(unique_letters)\n\n                            # Define the set of words that are present in the plain text and not unique to the plain text and present in the set of known words and not unique to the plain text\n                            words_not_unique_not_unique_in_plain_text_known = words_not_unique_in_plain_text_known.difference(unique_letters)\n\n                            # Check if the"
    },
    {
        "number": 3209,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    origin, destination = stdin.split()\n    n = int(stdin.split()[1])\n    connections = []\n    for i in range(n):\n        line = stdin.split()\n        connections.append((line[0], line[1], int(line[2]), int(line[3]), int(line[4])))\n\n    # Calculate probabilities\n    delays = []\n    for connection in connections:\n        departure_time, duration, probability, max_delay = connection\n        delay = np.random.randint(1, max_delay + 1)\n        delays.append((departure_time, delay))\n\n    # Calculate expected duration\n    def expected_duration(delays):\n        total_delay = sum(delay for departure_time, delay in delays)\n        return total_delay / len(delays)\n\n    expected_duration_h = expected_duration(delays)\n    expected_duration_min = expected_duration_h * 60\n\n    # Check if destination is reachable\n    if expected_duration_min > 300:\n        return \"IMPOSSIBLE\"\n\n    return f\"{expected_duration_min:.6f}\""
    },
    {
        "number": 3210,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    board = [list(row) for row in stdin.split('\\n')[1:]]\n\n    def count_points(player: int) -> int:\n        points = 0\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == '*' and (i == 0 or j == 0 or i == N - 1 or j == N - 1):\n                    points += 1\n        return points\n\n    alice_points = count_points(1)\n    bob_points = count_points(2)\n\n    if alice_points > bob_points:\n        return str(N * N)\n    elif bob_points > alice_points:\n        return str(N * N)\n    else:\n        return str(N * N - 1)"
    },
    {
        "number": 3211,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(stdin.split()[1])\n\n    # Count the votes for each party\n    party1_votes = 0\n    party2_votes = 0\n    for c in s:\n        if c == '1':\n            party1_votes += 1\n        elif c == '2':\n            party2_votes += 1\n\n    # If both parties have the same number of votes, neither of them receives a point\n    if party1_votes == party2_votes:\n        return \"impossible\"\n\n    # Count the points for each party\n    party1_points = 0\n    party2_points = 0\n    for c in s:\n        if c == '1':\n            party1_points += 1\n        elif c == '2':\n            party2_points += 1\n\n    # If both parties have the same number of points, chaos ensues\n    if party1_points == party2_points:\n        return \"impossible\"\n\n    # If party1 has more points, swap the tellers\n    if party1_points > party2_points:\n        s[s.index('0')] = '2'\n        s[s.index('1')] = '0'\n    else:\n        s[s.index('0')] = '0'\n        s[s.index('1')] = '2'\n\n    # Count the votes for each party\n    party1_votes = 0\n    party2_votes = 0\n    for c in s:\n        if c == '1':\n            party1_votes += 1\n        elif c == '2':\n            party2_votes += 1\n\n    # If both parties have the same number of votes, neither of them receives a point\n    if party1_votes == party2_votes:\n        return \"impossible\"\n\n    # Count the points for each party\n    party1_points = 0\n    party2_points = 0\n    for c in s:\n        if c == '1':\n            party1_points += 1\n        elif c == '2':\n            party2_points += 1\n\n    # If both parties have the same number of points, chaos ensues\n    if party1_points == party2_points:\n        return \"impossible\"\n\n    # If party1 has more points, swap the tellers\n    if party1_points > party2_points:\n        s[s.index('0')] = '2'\n        s[s.index('1')] = '0'\n    else:\n        s[s.index('0')] = '0'\n        s[s.index('1')] = '2'\n\n    # Count the votes for each party\n    party1_votes = 0\n    party2_votes = 0\n    for c in s:\n        if c == '1':\n            party1_votes += 1\n        elif c == '2':\n            party2_votes += 1\n\n    # If both parties have the same number of votes, neither of them receives a point\n    if party1_votes == party2_votes:\n        return \"impossible\"\n\n    # Count the points for each party\n    party1_points = 0\n    party2_points = 0\n    for c in s:\n        if c == '1':\n            party1_points += 1\n        elif c == '2':\n            party2_points += 1\n\n    # If both parties have the same number of points, chaos ensues\n    if party1_points == party2_points:\n        return \"impossible\"\n\n    # If party1 has more points, swap the tellers\n    if party1_points > party2_points:\n        s[s.index('0')] = '2'\n        s[s.index('1')] = '0'\n    else:\n        s[s.index('0')] = '0'\n        s[s.index('1')] = '2'\n\n    # Count the votes for each party\n    party1_votes = 0\n    party2_votes = 0\n    for c in s:\n        if c == '1':\n            party1_votes += 1\n        elif c == '2':\n            party2_votes += 1\n\n    # If both parties have the same number of votes, neither of them receives a point\n    if party1_votes == party2_votes:\n        return \"impossible\"\n\n    # Count the points for each party\n    party1_points = 0\n    party2_points = 0\n    for c in s:\n        if c == '1':\n            party1_points += 1\n        elif c == '2':\n            party2_points += 1\n\n    # If both parties have the same number of points, chaos ensues\n    if party1_points == party2_points:\n        return \"impossible\"\n\n    "
    },
    {
        "number": 3212,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    snakes = []\n    for _ in range(n):\n        x, y, d = map(int, stdin.split()[1:])\n        snakes.append((x, y, d))\n    snakes.sort(key=lambda x: (x[1], x[0]))\n    southwest = snakes[0]\n    northeast = snakes[-1]\n    if southwest[0] == 0 and southwest[1] == 0:\n        southwest = (0, 0)\n    if northeast[0] == 1000 and northeast[1] == 1000:\n        northeast = (1000, 1000)\n    if southwest[0] > northeast[0]:\n        southwest, northeast = northeast, southwest\n    if southwest[1] > northeast[1]:\n        southwest, northeast = northeast, southwest\n    if southwest[0] == northeast[0] and southwest[1] == northeast[1]:\n        return \"Bill will be bitten.\"\n    if southwest[0] == 0:\n        return f\"Bill enters at ({southwest[1] + 0.01:.2f}, {northeast[1]:.2f}).\"\n    if southwest[1] == 0:\n        return f\"Bill enters at ({southwest[0]:.2f}, {northeast[1] + 0.01:.2f}).\"\n    if northeast[0] == 1000:\n        return f\"Bill enters at ({southwest[0]:.2f}, {northeast[1] - 0.01:.2f}).\"\n    if northeast[1] == 1000:\n        return f\"Bill enters at ({southwest[0] - 0.01:.2f}, {northeast[1]:.2f}).\"\n    return f\"Bill enters at ({southwest[0]:.2f}, {northeast[1]:.2f}).\""
    },
    {
        "number": 3213,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    steps = list(stdin.split()[1])\n    power = 1\n\n    for step in steps:\n        if step == '+':\n            power += 1\n        elif step == 'x':\n            power *= 2\n\n    if power > 1:\n        steps[::2] = ['o'] * (power // 2)\n\n    return ''.join(steps)"
    },
    {
        "number": 3214,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    similar_words = {}\n    for line in stdin.split('\\n'):\n        if line == '***':\n            break\n        words = line.split()\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                core1 = ''.join(c.lower() for c in words[i])\n                core2 = ''.join(c.lower() for c in words[j])\n                if core1 == core2:\n                    continue\n                for transformation in [\n                    lambda x: x[1:] + x[0],\n                    lambda x: x[:1] + x[1:],\n                    lambda x: x[:1] + x[2:] + x[1],\n                    lambda x: x[1] + x[2] + x[0] + x[1:],\n                ]:\n                    transformed_core1 = transformation(core1)\n                    transformed_core2 = transformation(core2)\n                    if transformed_core1 == transformed_core2:\n                        similar_words.setdefault(core1, []).append(core2)\n                        similar_words.setdefault(core2, []).append(core1)\n    result = []\n    for core, similar_cores in similar_words.items():\n        result.append(f'{core}: {\" \".join(sorted(similar_cores))}')\n    return '\\n'.join(result)"
    },
    {
        "number": 3215,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n    cards.sort()\n    shuffles = 0\n    while True:\n        if cards == list(range(1, n+1)):\n            return str(shuffles)\n        shuffles += 1\n        for i in range(n//2):\n            cards[i], cards[n-i-1] = cards[n-i-1], cards[i]\n        for i in range(n//2, n):\n            cards[i], cards[n-i-1] = cards[n-i-1], cards[i]"
    },
    {
        "number": 3216,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num, repeat = stdin.split()\n    num = int(num)\n    repeat = int(repeat)\n    num_str = str(num)\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_str = num_str.rstrip('.')\n    num_str = num_str.lstrip('0')\n    num_"
    },
    {
        "number": 3217,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    defective_cells = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split()[1:])\n        defective_cells.append((x, y, z))\n    defective_cells.sort(key=lambda x: (x[0], x[1], x[2]))\n\n    def is_adjacent(a, b):\n        return abs(a[0] - b[0]) == 1 and abs(a[1] - b[1]) == 1 and abs(a[2] - b[2]) == 1\n\n    def is_defective(cell):\n        return cell in defective_cells\n\n    def is_healthy(cell):\n        return not is_defective(cell)\n\n    def is_inside(cell, enclosure):\n        return all(cell[i] >= enclosure[i] and cell[i] <= enclosure[i + 1] for i in range(3))\n\n    def is_valid(cell, enclosure):\n        return is_inside(cell, enclosure) and is_adjacent(cell, enclosure)\n\n    def count_panels(enclosure):\n        count = 0\n        for i in range(1, 10):\n            for j in range(1, 10):\n                for k in range(1, 10):\n                    if is_valid((i, j, k), enclosure):\n                        count += 1\n        return count\n\n    def find_enclosure(defective_cells):\n        enclosure = None\n        for i in range(1, 10):\n            for j in range(1, 10):\n                for k in range(1, 10):\n                    if all(is_healthy(cell) for cell in defective_cells if is_adjacent(cell, (i, j, k))):\n                        if enclosure is None or is_valid((i, j, k), enclosure):\n                            enclosure = (i, j, k)\n        return enclosure\n\n    enclosure = find_enclosure(defective_cells)\n    if enclosure is None:\n        return \"0\"\n    return str(count_panels(enclosure))"
    },
    {
        "number": 3218,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [[int(x) for x in stdin.split()[1:]] for _ in range(n)]\n\n    def is_valid(a: list) -> bool:\n        n = len(a)\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == -1:\n                    continue\n                count = 0\n                for k in range(n):\n                    if k == i or k == j:\n                        continue\n                    if a[i][k] == a[k][j]:\n                        count += 1\n                if count!= a[i][j]:\n                    return False\n        return True\n\n    valid_count = 0\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == -1:\n                continue\n            valid_count += 1\n            a[i][j] = valid_count\n            if not is_valid(a):\n                a[i][j] = -1\n                valid_count -= 1\n\n    return str(valid_count)"
    },
    {
        "number": 3219,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 0\n    for i in range(1, 32):\n        if bin(n ^ (1 << i))[2:].count('1') % 2 == 0:\n            count += 1\n    return str((count % 1000000009))"
    },
    {
        "number": 3220,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    def teleport(i: int, p: int, direction: str) -> int:\n        if direction == 'L':\n            return (i + p - 1) % N + 1\n        else:\n            return (i - p + N) % N + 1\n\n    def is_valid(p: List[int]) -> bool:\n        for i in range(N):\n            if p[i] == teleport(i, p[i], 'L'):\n                return False\n            if p[i] == teleport(i, p[i], 'R'):\n                return False\n        return True\n\n    def find_valid_dance(p: List[int]) -> str:\n        for i in range(N):\n            if p[i] == teleport(i, p[i], 'L'):\n                return 'L' * p[i]\n            if p[i] == teleport(i, p[i], 'R'):\n                return 'R' * p[i]\n        return ''\n\n    valid_dances = [find_valid_dance(p) for p in itertools.permutations(p)]\n    valid_dances = [dance for dance in valid_dances if dance!= '']\n    valid_dances.sort()\n\n    if not valid_dances:\n        return ''\n    else:\n        return valid_dances[0]"
    },
    {
        "number": 3221,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, alpha = map(int, stdin.split())\n    candies = [int(x) for x in stdin.split()]\n    candies.sort()\n\n    def dfs(u, visited, energy):\n        if u == n:\n            return energy\n\n        visited.add(u)\n        for v, c in enumerate(candies):\n            if v not in visited and c <= energy:\n                energy -= c\n                energy = dfs(v, visited, energy)\n                energy += c\n\n        visited.remove(u)\n        return energy\n\n    return str(dfs(1, set(), alpha))"
    },
    {
        "number": 3222,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    places = list(map(int, stdin.split()))\n    streets = []\n    for i in range(m):\n        f, t = map(int, stdin.split())\n        streets.append((f, t))\n\n    def dfs(start, visited, path):\n        if start in visited:\n            return\n        visited.add(start)\n        path.append(start)\n        if start == n - 1:\n            print(len(path), end=\" \")\n            for i in range(len(path) - 1):\n                print(path[i], end=\" \")\n            print(path[-1])\n            return\n        for end in range(n):\n            if end not in visited and (end, start) not in streets:\n                dfs(end, visited, path)\n        path.pop()\n\n    dfs(0, set(), [])\n    return \"Yeah!\" if len(visited) == n else \"Impossible\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    degrees = list(map(int, stdin.split()[1:]))\n\n    def dfs(u: int, visited: set) -> None:\n        visited.add(u)\n        for v in range(n):\n            if v!= u and degrees[v] > 0 and v not in visited:\n                dfs(v, visited)\n\n    def bfs(u: int, visited: set) -> None:\n        queue = deque([u])\n        visited.add(u)\n        while queue:\n            v = queue.popleft()\n            for w in range(n):\n                if w!= v and degrees[w] > 0 and w not in visited:\n                    degrees[w] -= 1\n                    if degrees[w] == 0:\n                        visited.add(w)\n                        queue.append(w)\n\n    def is_connected(u: int, visited: set) -> bool:\n        visited.add(u)\n        for v in range(n):\n            if v!= u and degrees[v] > 0 and v not in visited:\n                if not is_connected(v, visited):\n                    return False\n        return True\n\n    def construct_forest() -> None:\n        visited = set()\n        for u in range(n):\n            if degrees[u] > 0 and u not in visited:\n                dfs(u, visited)\n        for u in range(n):\n            if degrees[u] > 0 and u not in visited:\n                bfs(u, visited)\n\n    def check_forest() -> bool:\n        visited = set()\n        for u in range(n):\n            if degrees[u] > 0 and u not in visited:\n                if not is_connected(u, visited):\n                    return False\n        return True\n\n    if check_forest():\n        construct_forest()\n        for u in range(n):\n            if degrees[u] > 0:\n                print(u + 1, u + 1)\n        return \"POSSIBLE\"\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3224,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for line in stdin.split('\\n'):\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def closest_point(points, point):\n        closest = points[0]\n        min_distance = distance(point, closest)\n        for p in points:\n            distance_to_p = distance(point, p)\n            if distance_to_p < min_distance:\n                closest = p\n                min_distance = distance_to_p\n        return closest\n\n    def sphere_center(points):\n        closest_point_1 = closest_point(points, points[0])\n        closest_point_2 = closest_point(points, points[1])\n        closest_point_3 = closest_point(points, points[2])\n        closest_point_4 = closest_point(points, points[3])\n\n        normal_1 = (closest_point_1[0] - closest_point_2[0], closest_point_1[1] - closest_point_2[1], closest_point_1[2] - closest_point_2[2])\n        normal_2 = (closest_point_2[0] - closest_point_3[0], closest_point_2[1] - closest_point_3[1], closest_point_2[2] - closest_point_3[2])\n        normal_3 = (closest_point_3[0] - closest_point_4[0], closest_point_3[1] - closest_point_4[1], closest_point_3[2] - closest_point_4[2])\n        normal_4 = (closest_point_4[0] - closest_point_1[0], closest_point_4[1] - closest_point_1[1], closest_point_4[2] - closest_point_1[2])\n\n        normal = (normal_1[0] * normal_2[1] * normal_3[2] + normal_1[1] * normal_2[2] * normal_3[0] + normal_1[2] * normal_2[0] * normal_3[1] -\n                   normal_1[0] * normal_2[2] * normal_3[1] - normal_1[1] * normal_2[0] * normal_3[2] - normal_1[2] * normal_2[1] * normal_3[0],\n                   normal_1[0] * normal_2[2] * normal_4[1] + normal_1[1] * normal_2[0] * normal_4[2] + normal_1[2] * normal_2[1] * normal_4[0] -\n                   normal_1[0] * normal_2[1] * normal_4[2] - normal_1[1] * normal_2[2] * normal_4[0] - normal_1[2] * normal_2[0] * normal_4[1],\n                   normal_1[0] * normal_3[2] * normal_4[1] + normal_1[1] * normal_3[0] * normal_4[2] + normal_1[2] * normal_3[1] * normal_4[0] -\n                   normal_1[0] * normal_3[1] * normal_4[2] - normal_1[1] * normal_3[2] * normal_4[0] - normal_1[2] * normal_3[0] * normal_4[1])\n\n        normal = (normal[0] / distance(closest_point_1, closest_point_2), normal[1] / distance(closest_point_1, closest_point_2), normal[2] / distance(closest_point_1, closest_point_2))\n\n        return (closest_point_1[0] + normal[0] * distance(closest_point_1, closest_point_2),\n                closest_point_1[1] + normal[1] * distance(closest_point_1, closest_point_2),\n                closest_point_1[2] + normal[2] * distance(closest_point_1, closest_point_2))\n\n    sphere_center_"
    },
    {
        "number": 3225,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n\n    queue = []\n    for i in range(n):\n        queue.append((values[i], i))\n\n    minutes = 0\n    while queue:\n        minutes += 1\n        for i in range(len(queue)):\n            if i > 0:\n                if queue[i][0] > queue[i - 1][0]:\n                    queue.pop(i)\n                    break\n            if i < len(queue) - 1:\n                if queue[i][0] > queue[i + 1][0]:\n                    queue.pop(i)\n                    break\n\n        if not queue:\n            break\n\n    result = []\n    for value, index in queue:\n        result.append(str(value))\n\n    return f\"{minutes}\\n{' '.join(result)}\\n{' '.join(str(value) for value, index in queue)}\""
    },
    {
        "number": 3226,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split())\n    intersections = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, l = map(int, stdin.split())\n        intersections[a].append((b, l))\n        intersections[b].append((a, l))\n    exits = [set(map(int, stdin.split())) for _ in range(e)]\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            intersection, distance = queue.pop(0)\n            if intersection in visited:\n                continue\n            visited.add(intersection)\n            if intersection == p:\n                return distance\n            for neighbor, length in intersections[intersection]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + length))\n        return float('inf')\n\n    p = bfs(b)\n    if p == float('inf'):\n        return 'IMPOSSIBLE'\n    return str(p)"
    },
    {
        "number": 3227,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(e):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def bfs(u, visited):\n        queue = [u]\n        visited[u] = True\n        while queue:\n            v = queue.pop(0)\n            for w in graph[v]:\n                if not visited[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    def find_restaurant(chain, visited):\n        for u in range(1, n + 1):\n            if not visited[u]:\n                dfs(u, visited)\n                if chain in visited:\n                    return 1\n        return 0\n\n    def find_restaurants(chain1, chain2, visited):\n        for u in range(1, n + 1):\n            if not visited[u]:\n                dfs(u, visited)\n                if chain1 in visited and chain2 in visited:\n                    return 1\n        return 0\n\n    visited = [False] * (n + 1)\n    for u in range(1, n + 1):\n        if not visited[u]:\n            dfs(u, visited)\n\n    if find_restaurant(1, visited) == 0:\n        return \"0\"\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            bfs(u, visited)\n            if find_restaurants(1, 2, visited) == 1:\n                return \"1\"\n            if find_restaurants(2, 1, visited) == 1:\n                return \"2\"\n\n    return \"0\"\n"
    },
    {
        "number": 3228,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, g = map(int, stdin.split())\n    arrivals = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def min_waiting_time(gondolas):\n        waiting_time = 0\n        for i in range(n):\n            waiting_time += abs(arrivals[i] - gondolas[i])\n        return waiting_time\n\n    def min_waiting_time_helper(gondolas, index, remaining_gondolas):\n        if index == n:\n            return min_waiting_time(gondolas)\n\n        if remaining_gondolas == 0:\n            return float('inf')\n\n        gondolas[index] = min(gondolas[index], remaining_gondolas)\n        waiting_time = min_waiting_time_helper(gondolas, index + 1, remaining_gondolas - gondolas[index])\n        gondolas[index] = 0\n        return waiting_time\n\n    gondolas = [0] * n\n    return str(min_waiting_time_helper(gondolas, 0, g))\n"
    },
    {
        "number": 3229,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scores = list(map(int, stdin.split()))\n    scores.append(0)\n    scores.sort(reverse=True)\n    rank = 1\n    for i in range(1, n):\n        if scores[i] > scores[i - 1]:\n            rank += 1\n    return str(rank)"
    },
    {
        "number": 3230,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split()[0].split())\n    layout = [list(row) for row in stdin.split()[1:]]\n\n    explosions = 0\n    visited = set()\n    queue = [(0, 0)]\n\n    while queue:\n        x, y = queue.pop(0)\n\n        if (x, y) in visited:\n            continue\n\n        visited.add((x, y))\n\n        if layout[x][y] == 'X':\n            explosions += 1\n            break\n\n        if layout[x][y] == 'L':\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n\n                if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n\n    return str(explosions)"
    },
    {
        "number": 3231,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    students = [[] for _ in range(n)]\n    for i in range(n):\n        m = int(stdin.readline().strip())\n        for j in range(m):\n            students[i].append(int(stdin.readline().strip()))\n\n    def is_valid_partition(students: List[List[int]]) -> bool:\n        groups = defaultdict(list)\n        for i in range(n):\n            for j in range(len(students[i])):\n                groups[students[i][j]].append(i)\n\n        for group in groups.values():\n            if len(group) < p + q:\n                return False\n            for i in range(len(group) - 1):\n                if groups[group[i]][0] == group[i + 1]:\n                    return False\n                if groups[group[i]][0] > group[i + 1]:\n                    return False\n\n        return True\n\n    if is_valid_partition(students):\n        return \"detention\"\n    else:\n        return \"home\""
    },
    {
        "number": 3232,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2!= 0:\n        return -1\n\n    def is_valid(s: str) -> bool:\n        return len(set(s)) == n // 2 + 1\n\n    def is_valid_permutation(s: str) -> bool:\n        return all(len(set(s[i:i + n // 2])) == 1 for i in range(n // 2))\n\n    def find_permutation(s: str) -> str:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    return \"\"\n        return s\n\n    def find_valid_permutation(s: str) -> str:\n        while True:\n            p = find_permutation(s)\n            if p == \"\":\n                return p\n            if is_valid_permutation(p):\n                return p\n\n    s = stdin.lower()\n    if is_valid(s):\n        return s\n    else:\n        return find_valid_permutation(s)"
    },
    {
        "number": 3233,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    scary_count = 0\n    left = 0\n    right = 0\n    while right < n:\n        if arr[right] < arr[left]:\n            scary_count += 1\n        left += 1\n        right += 1\n    return str(scary_count)"
    },
    {
        "number": 3234,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W, H = 1, 1\n    while W * H < N:\n        W += 1\n        H = 1\n    if W * H == N:\n        return str(W)\n    else:\n        return str(H)"
    },
    {
        "number": 3235,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ious = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        ious.append((a, b, c))\n\n    def find_cycle(debt, cycles):\n        for cycle in cycles:\n            if sum(cycle) == debt:\n                return cycle\n        return None\n\n    def cancel_cycle(cycle, cycles):\n        new_cycle = []\n        for i in range(len(cycle)):\n            if i in cycle:\n                new_cycle.append(cycle.index(i))\n            else:\n                new_cycle.append(cycle.index(cycle[i]))\n        cycles.remove(cycle)\n        cycles.append(new_cycle)\n\n    def cancel_cycles(cycles):\n        while cycles:\n            cycle = cycles.pop()\n            debt = sum(cycle)\n            new_cycle = find_cycle(debt, cycles)\n            if new_cycle:\n                cancel_cycle(cycle, cycles)\n            else:\n                return debt\n\n    def find_min_cycle(cycles):\n        min_cycle = None\n        min_debt = float('inf')\n        for cycle in cycles:\n            debt = sum(cycle)\n            if debt < min_debt:\n                min_debt = debt\n                min_cycle = cycle\n        return min_cycle\n\n    def cancel_min_cycle(cycles):\n        min_cycle = find_min_cycle(cycles)\n        if min_cycle:\n            cancel_cycle(min_cycle, cycles)\n\n    def cancel_cycles_and_output(cycles):\n        debt = cancel_cycles(cycles)\n        cancel_min_cycle(cycles)\n        return debt\n\n    cycles = []\n    for i in range(n):\n        cycles.append([i])\n\n    debt = cancel_cycles_and_output(cycles)\n    print(debt)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].remove(j)\n            cycles[j].remove(i)\n\n    for i, j, c in ious:\n        if c > 0:\n            cycles[i].append(j)\n            cycles[j].append(i)\n\n   "
    },
    {
        "number": 3236,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mansions = list(map(int, stdin.split()))\n    roads = []\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        roads.append((a - 1, b - 1))\n\n    def is_fibonacci(n: int) -> bool:\n        a, b = 0, 1\n        while b <= n:\n            a, b = b, a + b\n        return a == n\n\n    def fibonacci_tour(start: int) -> int:\n        visited = set()\n        stack = [(start, 1)]\n        length = 0\n        while stack:\n            mansion, height = stack.pop()\n            if mansion in visited:\n                continue\n            visited.add(mansion)\n            length += height\n            if mansion == n:\n                return length\n            for neighbor, road_height in roads:\n                if neighbor == mansion:\n                    continue\n                if neighbor in visited:\n                    continue\n                stack.append((neighbor, height + road_height))\n        return 0\n\n    max_length = 0\n    for i in range(n):\n        if is_fibonacci(mansions[i]):\n            length = fibonacci_tour(i)\n            if length > max_length:\n                max_length = length\n\n    return str(max_length)"
    },
    {
        "number": 3237,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def prime_factors(n: int) -> list[int]:\n        factors = []\n        for i in range(2, n + 1):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n        return factors\n\n    def min_cost(n: int) -> int:\n        factors = prime_factors(n)\n        min_cost = 0\n        for i in range(len(factors)):\n            for j in range(i + 1, len(factors)):\n                min_cost += lcm(factors[i], factors[j])\n        return min_cost\n\n    k = int(stdin)\n    print(min_cost(k))\n"
    },
    {
        "number": 3238,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    image = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def fold(image, axis, value):\n        if axis == 0:\n            for i in range(n):\n                image[i].insert(value - 1, '#')\n        elif axis == 1:\n            for i in range(m):\n                image.insert(value - 1, ['.'] * m)\n        else:\n            for i in range(n):\n                for j in range(m):\n                    if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                        image[i][j] = '#'\n                    else:\n                        image[i][j] = '.'\n\n    for line in image:\n        if line.count('#') > line.count('.'):\n            fold(image, 0, line.index('#') + 1)\n        else:\n            fold(image, 1, line.index('.') + 1)\n\n    def find_edges(image):\n        edges = []\n        for i in range(n):\n            if image[i][0] == '#':\n                edges.append((i, 0))\n            if image[i][-1] == '#':\n                edges.append((i, m - 1))\n        for j in range(m):\n            if image[0][j] == '#':\n                edges.append((0, j))\n            if image[-1][j] == '#':\n                edges.append((n - 1, j))\n        return edges\n\n    edges = find_edges(image)\n    edges.sort()\n    return''.join(map(str, edges))"
    },
    {
        "number": 3239,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    P = round(P, 3)\n    expected_money = 0\n    for i in range(N):\n        expected_money += 100 * P\n    expected_money += 5 * P\n    return f\"{expected_money:.6f}\""
    },
    {
        "number": 3240,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split())\n    p = [float(x) for x in stdin.split()]\n    b = [int(x) for x in stdin.split()]\n\n    def count_positions(b: List[int]) -> int:\n        count = 0\n        for i in range(k):\n            count += b[i] & 1\n        return count\n\n    def max_positions(b: List[int]) -> int:\n        max_count = 0\n        max_positions = 0\n        for i in range(1, 2 ** k):\n            count = count_positions(b + [i])\n            if count > max_count:\n                max_count = count\n                max_positions = i\n        return max_positions\n\n    return str(max_positions(b))"
    },
    {
        "number": 3241,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n    B = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(A, B):\n        A.sort(reverse=True)\n        B.sort(reverse=True)\n\n        def helper(A, B, i, j):\n            if i == 0:\n                return 0\n            if j == 0:\n                return 0\n\n            if A[i - 1] <= B[j - 1]:\n                return helper(A, B, i - 1, j)\n            else:\n                return helper(A, B, i, j - 1) + lcm(A[i - 1], B[j - 1])\n\n        return helper(A, B, len(A), len(B))\n\n    total_ham = sum(A)\n    ham_per_person = [total_ham // n] * n\n\n    for i in range(1, n):\n        ham_per_person[i] = ham_per_person[i - 1] + A[i - 1]\n\n    ham_per_person.sort(reverse=True)\n\n    for i in range(n):\n        if ham_per_person[i] == 0:\n            return -1\n\n    ham_per_person = [ham_per_person[i] // B[i] for i in range(n)]\n\n    result = solve(A, ham_per_person)\n\n    if result == 0:\n        return -1\n\n    return str(result)\n"
    },
    {
        "number": 3242,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    boxes = []\n    for _ in range(N):\n        energy, prob = map(float, stdin.split())\n        boxes.append((energy, prob))\n    boxes.sort(key=lambda x: x[1])\n    energy_wasted = 0\n    for energy, prob in boxes:\n        if prob >= P:\n            energy_wasted += energy\n            break\n    return str(energy_wasted)"
    },
    {
        "number": 3243,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    connections = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        connections[u].append(v)\n        connections[v].append(u)\n    visited = [False] * n\n    visited[0] = True\n    queue = [0]\n    while queue:\n        current = queue.pop(0)\n        for neighbor in connections[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if len(queue) == k:\n                    return \"yes\"\n    return \"no\""
    },
    {
        "number": 3244,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ring = list(map(int, stdin.split()[1:]))\n    ring.append(ring[0])\n    ring.append(ring[-1])\n\n    for i in range(n - 2):\n        ring.append(ring[i] + ring[i + 2])\n\n    return \"\\n\".join(map(str, ring))"
    },
    {
        "number": 3245,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    history = []\n    for line in stdin.splitlines():\n        command = \"\"\n        for char in line:\n            if char == \"^\":\n                if command:\n                    history.append(command)\n                    command = \"\"\n            else:\n                command += char\n        if command:\n            history.append(command)\n    return \"\\n\".join(history)"
    },
    {
        "number": 3246,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    words = stdin.split()\n    n = len(words)\n    valid_words = set(words)\n\n    def shuffle_words(words: list) -> list:\n        for i in range(len(words)):\n            j = random.randint(0, i)\n            words[i], words[j] = words[j], words[i]\n        return words\n\n    def decipher(s: str, valid_words: set) -> str:\n        words = s.split()\n        shuffled_words = shuffle_words(words)\n        deciphered_words = []\n        for word in shuffled_words:\n            if word in valid_words:\n                deciphered_words.append(word)\n            else:\n                deciphered_words.append(\" \")\n        return \" \".join(deciphered_words)\n\n    deciphered_s = decipher(s, valid_words)\n    if deciphered_s == s:\n        return deciphered_s\n    else:\n        return \"impossible\" if len(set(deciphered_s.split())) == 1 else \"ambiguous\""
    },
    {
        "number": 3247,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    def count_knights(row, col, visited):\n        if row < 0 or row >= n or col < 0 or col >= m:\n            return 0\n        if (row, col) in visited:\n            return 0\n        visited.add((row, col))\n        if board[row][col] == 0:\n            return count_knights(row + 1, col, visited) + count_knights(row - 1, col, visited) + count_knights(row, col + 1, visited) + count_knights(row, col - 1, visited)\n        elif board[row][col] == 1:\n            return count_knights(row + 2, col, visited) + count_knights(row - 2, col, visited) + count_knights(row, col + 2, visited) + count_knights(row, col - 2, visited)\n        else:\n            return 0\n\n    board = [[0] * m for _ in range(n)]\n    visited = set()\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            board[i][j] = 1\n            count += count_knights(i, j, visited)\n            board[i][j] = 0\n    return str(count % (10**9 + 9))"
    },
    {
        "number": 3248,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *street = stdin.split()\n    M, *tile_patterns = stdin.split()\n\n    def is_untileable(tile_pattern: str, street: str) -> bool:\n        for i in range(len(tile_pattern)):\n            if tile_pattern[i]!= street[i]:\n                return False\n        return True\n\n    untileable_cells = 0\n    for tile_pattern in tile_patterns:\n        if is_untileable(tile_pattern, street):\n            untileable_cells += 1\n\n    return str(untileable_cells)"
    },
    {
        "number": 3249,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(x1, y1, x2, y2):\n        return abs(x1 * y2 - x2 * y1)\n\n    def cross_product(x1, y1, x2, y2):\n        return x1 * y2 - x2 * y1\n\n    def orientation(x1, y1, x2, y2, x3, y3):\n        return cross_product(x2 - x1, y2 - y1, x3 - x2, y3 - y2)\n\n    def is_left(x1, y1, x2, y2, x3, y3):\n        return orientation(x1, y1, x2, y2, x3, y3) < 0\n\n    def is_right(x1, y1, x2, y2, x3, y3):\n        return orientation(x1, y1, x2, y2, x3, y3) > 0\n\n    def is_on_segment(x1, y1, x2, y2, x3, y3):\n        return is_left(x1, y1, x2, y2, x3, y3)!= is_left(x2, y2, x1, y1, x3, y3)\n\n    def is_inside(x, y, x1, y1, x2, y2):\n        return is_left(x, y, x1, y1, x2, y2) <= 0 and is_left(x2, y2, x1, y1, x, y) <= 0\n\n    def is_colliding(x1, y1, x2, y2, x3, y3, x4, y4):\n        return is_on_segment(x1, y1, x2, y2, x3, y3)!= is_on_segment(x1, y1, x2, y2, x4, y4) and is_on_segment(x3, y3, x4, y4, x1, y1)!= is_on_segment(x3, y3, x4, y4, x2, y2)\n\n    def is_colliding_with_hull(x, y, x1, y1, x2, y2):\n        return is_colliding(x, y, x1, y1, x2, y2, x1, y1) or is_colliding(x, y, x1, y1, x2, y2, x2, y2)\n\n    def is_colliding_with_bulkhead(x, y, x1, y1, x2, y2, x3, y3):\n        return is_colliding(x1, y1, x2, y2, x3, y3, x, y)\n\n    def is_colliding_with_section(x, y, x1, y1, x2, y2, x3, y3):\n        return is_colliding(x1, y1, x2, y2, x3, y3, x, y) or is_colliding(x1, y1, x2, y2, x3, y3, x1, y1) or is_colliding(x1, y1, x2, y2, x3, y3, x2, y2)\n\n    def is_colliding_with_section_or_hull(x, y, x1, y1, x2, y2, x3, y3):\n        return is_colliding_with_section(x, y, x1, y1, x2, y2, x3, y3) or is_colliding_with_hull(x, y, x1, y1, x2, y2)\n\n    def is_colliding_with_section_or_bulkhead(x, y, x1, y1, x2, y2, x3, y3):\n        return is_colliding_with_section(x, y, x1, y1, x2, y2, x3, y3) or is_colliding_with_bulkhead(x, y, x1, y1, x2, y2, x3, y3)\n\n    def is_colliding_with_section_or_bulkhead_or_hull(x, y, x1, y1, x2, y2, x3, y3):\n        return is_colliding_with_section_or_bulkhead(x, y, x1, y"
    },
    {
        "number": 3250,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if d == 2 or d == 3 or d == 5 or d == 7 or d == 11 or d == 13 or d == 17:\n        return \"no\"\n\n    def is_valid(n: int) -> bool:\n        def reduce(n: int) -> int:\n            result = 0\n            while n > 0:\n                result += n % b\n                n //= b\n            return result\n\n        def is_divisible(n: int, d: int) -> bool:\n            return reduce(n) % d == 0\n\n        def is_valid_hack(b: int, d: int, m: int) -> bool:\n            def is_valid_divisor(n: int) -> bool:\n                return is_divisible(n, d)\n\n            def is_valid_base(n: int) -> bool:\n                return reduce(n) % b == 0\n\n            def is_valid_sum(n: int) -> bool:\n                return is_valid_divisor(n) and is_valid_base(n)\n\n            def is_valid_product(n: int) -> bool:\n                return is_valid_divisor(n) and is_valid_base(n)\n\n            def is_valid_sum_product(n: int) -> bool:\n                return is_valid_sum(n) and is_valid_product(n)\n\n            def is_valid_product_sum(n: int) -> bool:\n                return is_valid_product(n) and is_valid_sum(n)\n\n            def is_valid_sum_product_sum(n: int) -> bool:\n                return is_valid_sum_product(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum(n: int) -> bool:\n                return is_valid_product_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum_sum(n) and is_valid_sum_product(n)\n\n            def is_valid_product_sum_sum_sum_sum_sum_sum_sum_sum_sum(n: int) -> bool:\n                return is_valid_product_sum_sum_sum_"
    },
    {
        "number": 3251,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    intervals.sort(key=lambda x: x[0])\n\n    longest_sequence = []\n    current_sequence = []\n\n    for interval in intervals:\n        if not current_sequence or current_sequence[-1][1] < interval[0]:\n            current_sequence.append(interval)\n        else:\n            longest_sequence = max(longest_sequence, current_sequence, key=lambda x: len(x))\n            current_sequence = [interval]\n\n    longest_sequence = max(longest_sequence, current_sequence, key=lambda x: len(x))\n\n    return str(len(longest_sequence)) + '\\n' + '\\n'.join(map(lambda x:''.join(map(str, x)), longest_sequence))"
    },
    {
        "number": 3252,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = []\n    for _ in range(n):\n        w, h, q = map(int, stdin.split())\n        cards.append((w, h, q))\n\n    def find_best_envelope(cards, k):\n        total_waste = 0\n        for card in cards:\n            waste = 144 - card[0] * card[1]\n            total_waste += waste * card[2]\n        return total_waste\n\n    best_waste = float('inf')\n    for i in range(1, k + 1):\n        waste = find_best_envelope(cards, i)\n        if waste < best_waste:\n            best_waste = waste\n\n    return str(best_waste)"
    },
    {
        "number": 3253,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    states = []\n    for _ in range(n):\n        state = list(map(int, stdin.split()[1:]))\n        states.append(state)\n    constituents = sum(states[0][1:])\n    federals = sum(states[1][1:])\n    undecided = sum(states[2][1:])\n    if constituents > federals:\n        return \"impossible\"\n    elif constituents == federals:\n        return min(constituents, undecided)\n    else:\n        return constituents"
    },
    {
        "number": 3254,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    ones = 0\n    twos = 0\n    threes = 0\n    fours = 0\n    fives = 0\n\n    for i in range(1, 6):\n        paper_count = 0\n        while paper_count < p:\n            paper_count += 1\n            paper_number = int(input())\n            if paper_number == 1:\n                ones += 1\n            elif paper_number == 2:\n                twos += 1\n            elif paper_number == 3:\n                threes += 1\n            elif paper_number == 4:\n                fours += 1\n            elif paper_number == 5:\n                fives += 1\n\n    return f\"{ones} {twos} {threes} {fours} {fives}\""
    },
    {
        "number": 3255,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, D, M = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    def explore(start: int, visited: set) -> int:\n        if start == len(arr):\n            return 0\n\n        if start in visited:\n            return 0\n\n        visited.add(start)\n\n        if abs(arr[start] - arr[start + 1]) <= M:\n            return max(explore(start + 1, visited), explore(start + 2, visited))\n\n        return explore(start + 1, visited)\n\n    return str(explore(0, set()))"
    },
    {
        "number": 3256,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def power(a: int) -> int:\n        result = 1\n        while a > 0:\n            if a & 1:\n                result *= a\n            a >>= 1\n        return result\n\n    def max_power(a: int) -> int:\n        max_power = 0\n        for i in range(1, n + 1):\n            max_power = max(max_power, power(a ^ i))\n        return max_power\n\n    def max_and(a: int, b: int) -> int:\n        max_a = max_power(a)\n        max_b = max_power(b)\n        return max(max_a, max_b)\n\n    def max_and_of_sections(a: int, b: int) -> int:\n        max_a = max_power(a)\n        max_b = max_power(b)\n        return max_and(max_a, max_b)\n\n    def max_and_of_circle(a: int) -> int:\n        max_a = max_power(a)\n        return max_and(max_a, a)\n\n    max_a = max_and_of_circle(a[0])\n    max_b = max_and_of_circle(a[1])\n\n    for i in range(2, n):\n        max_a = max(max_a, max_and_of_sections(a[i - 1], a[i]))\n        max_b = max(max_b, max_and_of_sections(a[i], a[i + 1]))\n\n    return str(max_and_of_sections(max_a, max_b))\n"
    },
    {
        "number": 3257,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    if a + b <= c or b + c <= a or c + a <= b:\n        return -1\n    else:\n        area = 0.5 * a * b * c\n        return f\"{area:.3f}\""
    },
    {
        "number": 3258,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mice = []\n    for _ in range(n):\n        x, y, s = map(float, stdin.split())\n        mice.append((x, y, s))\n    mice.sort(key=lambda x: x[2])\n    velocity = 0\n    min_velocity = float('inf')\n    for mouse in mice:\n        if mouse[2] <= velocity:\n            velocity = mouse[2]\n            min_velocity = min(min_velocity, velocity)\n        else:\n            velocity *= m\n    return f\"{min_velocity:.2f}\""
    },
    {
        "number": 3259,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def simulate(boxes: List[int], stones: int) -> int:\n        for i in range(len(boxes) - 1):\n            boxes[i + 1] = (boxes[i + 1] + stones) % 2\n        return sum(boxes)\n\n    def query(boxes: List[int], l: int, r: int) -> int:\n        return simulate(boxes, r - l + 1)\n\n    def process_input(stdin: str) -> Tuple[List[int], int]:\n        lines = stdin.split('\\n')\n        boxes = [0] * 6\n        stones = 0\n        for line in lines:\n            if line.startswith('1'):\n                l, r, a, b = map(int, line.split()[1:])\n                boxes[l - 1] = a\n                stones = simulate(boxes, stones)\n            elif line.startswith('2'):\n                l, r = map(int, line.split()[1:])\n                return boxes, query(boxes, l - 1, r - 1)\n        return boxes, stones\n\n    boxes, stones = process_input(stdin)\n    return str(stones)\n"
    },
    {
        "number": 3260,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    if k > n:\n        return \"0\"\n\n    def count_permutations(n: int, k: int, p: int) -> int:\n        def count_runs(n: int, k: int) -> int:\n            count = 0\n            for i in range(1, n + 1):\n                if i <= k:\n                    count += count_runs(n - i, k)\n                else:\n                    count += count_runs(n - i, k - 1)\n            return count\n\n        def count_permutations_with_runs(n: int, k: int) -> int:\n            count = 0\n            for i in range(1, n + 1):\n                count += count_runs(n - i, k)\n            return count\n\n        return count_permutations_with_runs(n, k) % p\n\n    return str(count_permutations(n, k, p))"
    },
    {
        "number": 3261,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    visited = 0\n    row = 0\n    col = 0\n    direction = 0\n    while visited < K:\n        if direction == 0:\n            row += 1\n            if row == R:\n                row = 0\n                col += 1\n                if col == C:\n                    col = 0\n                    direction = 1\n        elif direction == 1:\n            col -= 1\n            if col < 0:\n                col = C - 1\n                row -= 1\n                if row < 0:\n                    row = R - 1\n                    direction = 0\n        elif direction == 2:\n            row -= 1\n            if row < 0:\n                row = R - 1\n                col -= 1\n                if col < 0:\n                    col = C - 1\n                    direction = 1\n        else:\n            col += 1\n            if col == C:\n                col = 0\n                row += 1\n                if row == R:\n                    row = 0\n                    direction = 2\n        if board[row][col] == 1:\n            visited += 1\n    return str(visited)"
    },
    {
        "number": 3262,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: List[List[int]], start: int) -> List[int]:\n        dist = [float('inf')] * (len(graph) + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            cost, u = heappop(pq)\n            if dist[u] < cost:\n                continue\n            for v, w in graph[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heappush(pq, (dist[v], v))\n        return dist\n\n    def bellman_ford(graph: List[List[int]]) -> bool:\n        n = len(graph)\n        dist = dijkstra(graph, 0)\n        for i in range(1, n):\n            for u, w in graph[i]:\n                if dist[u] + w < dist[i]:\n                    return False\n        return True\n\n    def min_trucks(graph: List[List[int]]) -> int:\n        n = len(graph)\n        dist = dijkstra(graph, 0)\n        if not bellman_ford(graph):\n            return -1\n        min_time = float('inf')\n        for u, w in graph[0]:\n            min_time = min(min_time, dist[u] + w)\n        return n - min_time\n\n    def min_trucks_helper(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_2(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_2(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_3(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_3(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_4(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_4(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_5(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_5(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_6(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_6(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_7(graph: List[List[int]], start: int, visited: List[bool]) -> int:\n        if visited[start]:\n            return 0\n        visited[start] = True\n        min_time = float('inf')\n        for u, w in graph[start]:\n            min_time = min(min_time, w + min_trucks_helper_7(graph, u, visited))\n        return min_time\n\n    def min_trucks_helper_8(graph"
    },
    {
        "number": 3263,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n    customers = []\n    for _ in range(n):\n        c, t = map(int, stdin.split())\n        customers.append((c, t))\n\n    clothing = [0] * m\n    clothing_count = 0\n\n    def is_valid(clothing: list) -> bool:\n        for i in range(m):\n            if clothing[i] == 1:\n                return False\n        return True\n\n    def put_on(clothing: list, p: int) -> None:\n        clothing[clothing_count] = 1\n        clothing_count += 1\n\n    def remove_clothing(clothing: list, r: int) -> None:\n        clothing[clothing_count - 1] = 0\n        clothing_count -= 1\n\n    def serve_customers(clothing: list) -> int:\n        max_ponies = 0\n        for i, (c, t) in enumerate(customers):\n            if clothing[c - 1] == 1:\n                put_on(clothing, p[c - 1])\n                max_ponies += 1\n            else:\n                remove_clothing(clothing, r[c - 1])\n                max_ponies += 1\n        return max_ponies\n\n    max_ponies = 0\n    while clothing_count < m:\n        max_ponies = max(max_ponies, serve_customers(clothing))\n        put_on(clothing, p[clothing_count])\n        clothing_count += 1\n\n    return str(max_ponies)"
    },
    {
        "number": 3264,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    pairs = []\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            pairs.append((i, j))\n    pairs.sort()\n    count = 0\n    for i in range(len(pairs)):\n        for j in range(i+1, len(pairs)):\n            if gcd(pairs[i][0], pairs[j][0]) == 1 and gcd(pairs[i][1], pairs[j][1]) == 1:\n                count += 1\n                if count % 1000000000 == 0:\n                    return str(count % 1000000000)\n    return str(count % 1000000000)\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        a, b, c = map(int, stdin.split())\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n\n    def dfs(v, visited):\n        visited.add(v)\n        for u, w in adj[v]:\n            if u not in visited:\n                dfs(u, visited)\n\n    def bfs(v, visited):\n        queue = [v]\n        visited.add(v)\n        while queue:\n            u = queue.pop(0)\n            for u, w in adj[u]:\n                if u not in visited:\n                    visited.add(u)\n                    queue.append(u)\n\n    def is_valid(t):\n        visited = set()\n        dfs(1, visited)\n        bfs(n, visited)\n        return len(visited) == n\n\n    def min_t():\n        t = 1\n        while is_valid(t):\n            t += 1\n        return t - 1\n\n    def max_t():\n        t = l + 10\n        while is_valid(t):\n            t -= 1\n        return t\n\n    if is_valid(l):\n        return str(l)\n    elif is_valid(max_t()):\n        return str(max_t())\n    else:\n        return str(min_t())"
    },
    {
        "number": 3266,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, c = map(int, stdin.split())\n        edges.append((u, v, c))\n\n    def bfs(graph, start, end):\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            node, path = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited and neighbor!= end:\n                        queue.append((neighbor, path + [neighbor]))\n        return visited\n\n    def max_flow(graph, start, end):\n        flow = 0\n        while True:\n            path = bfs(graph, start, end)\n            if not path:\n                return flow\n            path.remove(end)\n            for node in path:\n                for neighbor in graph[node]:\n                    if neighbor not in path and graph[node][neighbor] - graph[node][node] > 0:\n                        graph[node][neighbor] -= 1\n                        graph[neighbor][node] += 1\n            flow += 1\n        return flow\n\n    def augment(graph, start, end):\n        flow = 0\n        while True:\n            path = bfs(graph, start, end)\n            if not path:\n                return flow\n            path.remove(end)\n            for node in path:\n                for neighbor in graph[node]:\n                    if neighbor not in path and graph[node][neighbor] - graph[node][node] > 0:\n                        flow = min(flow, graph[node][neighbor])\n                        graph[node][neighbor] -= flow\n                        graph[neighbor][node] += flow\n            flow += 1\n        return flow\n\n    graph = [{} for _ in range(n)]\n    for u, v, c in edges:\n        graph[u][v] = c\n        graph[v][u] = 0\n\n    max_flow_value = max_flow(graph, s, t)\n    if max_flow_value == 0:\n        return \"0 0 0\"\n\n    augmented_graph = [{} for _ in range(n)]\n    for u, v, c in edges:\n        augmented_graph[u][v] = c\n        augmented_graph[v][u] = 0\n\n    augmented_flow = augment(augmented_graph, s, t)\n    if augmented_flow == 0:\n        return \"0 0 0\"\n\n    m = m + augmented_flow\n    return f\"{n} {max_flow_value} {m}\""
    },
    {
        "number": 3267,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split()[0].split())\n    board = [list(row) for row in stdin.split()[1:]]\n\n    def count_moves(row: int, col: int) -> int:\n        moves = 0\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_row, new_col = row + dr, col + dc\n            if 0 <= new_row < rows and 0 <= new_col < cols and board[new_row][new_col]!= '.':\n                moves += 1\n        return moves\n\n    def calculate_spread(player: str) -> int:\n        spread = 0\n        for row in range(rows):\n            for col in range(cols):\n                if board[row][col] == player:\n                    spread += count_moves(row, col)\n        return spread\n\n    mirko_spread = calculate_spread('M')\n    slavko_spread = calculate_spread('S')\n\n    return f\"{mirko_spread} {slavko_spread}\""
    },
    {
        "number": 3268,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tree = [[] for _ in range(n + 1)]\n    for line in stdin.split()[1:]:\n        parent, label, type, label_ = line.split()\n        parent = int(parent)\n        label = label.lower()\n        label_ = label_.lower()\n        if type == 'B':\n            tree[parent].append((label, label_))\n        elif type == 'S':\n            tree[parent].append((label, label_))\n        elif type == 'T':\n            tree[parent].append((label, label_))\n        elif type == 'E':\n            tree[parent].append((label, label_))\n        elif type == 'G':\n            tree[parent].append((label, label_))\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = [(1, 'a')]\n    result = []\n    while queue:\n        vertex, label = queue.pop(0)\n        if not visited[vertex]:\n            visited[vertex] = True\n            result.append(label)\n            for child in tree[vertex]:\n                queue.append((child[0], child[1]))\n    k = len(result)\n    return str(k) + '\\n' + '\\n'.join(f'{x} {y}' for x, y in zip(result, result))"
    },
    {
        "number": 3269,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    MOD = 1000000007\n\n    distances = []\n    for a in range(A, B+1):\n        for b in range(A, B+1):\n            if a!= b:\n                distance = sum(abs(a - b % 10))\n                distances.append(distance)\n\n    return str(sum(distances) % MOD)"
    },
    {
        "number": 3270,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dictionary = set(stdin.split()[1:])\n    starting_word = stdin.split()[2]\n    ending_word = stdin.split()[3]\n\n    def is_valid_word(word: str) -> bool:\n        return word in dictionary\n\n    def is_valid_transition(word: str) -> bool:\n        for i in range(len(word) - 1):\n            if word[i] == word[i + 1]:\n                return False\n        return True\n\n    def find_shortest_path(word: str) -> int:\n        queue = [(word, 0)]\n        visited = set()\n        while queue:\n            current_word, current_distance = queue.pop(0)\n            if current_word == ending_word:\n                return current_distance\n            if current_word in visited:\n                continue\n            visited.add(current_word)\n            for i in range(len(current_word)):\n                for new_letter in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                    new_word = current_word[:i] + new_letter + current_word[i + 1:]\n                    if is_valid_word(new_word) and is_valid_transition(new_word):\n                        queue.append((new_word, current_distance + 1))\n        return -1\n\n    shortest_path = find_shortest_path(starting_word)\n    if shortest_path == -1:\n        return \"0\\n-1\"\n    return find_shortest_path(ending_word) + \"\\n\" + str(shortest_path)\n"
    },
    {
        "number": 3271,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if i > j:\n                count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 3272,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floorplan = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def rotate_gargoyle(gargoyle: list, direction: int) -> list:\n        if direction == 0:\n            return [gargoyle[1], gargoyle[0]]\n        elif direction == 1:\n            return [gargoyle[0], gargoyle[1]]\n        elif direction == 2:\n            return [gargoyle[1], gargoyle[0]]\n        else:\n            return [gargoyle[0], gargoyle[1]]\n\n    def is_valid_gargoyle(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return gargoyle[0] == gargoyle[1]\n        elif direction == 1:\n            return gargoyle[1] == gargoyle[0]\n        elif direction == 2:\n            return gargoyle[0] == gargoyle[1]\n        else:\n            return gargoyle[1] == gargoyle[0]\n\n    def is_valid_path(path: list, direction: int) -> bool:\n        if direction == 0:\n            return path[0] == path[1]\n        elif direction == 1:\n            return path[1] == path[0]\n        elif direction == 2:\n            return path[0] == path[1]\n        else:\n            return path[1] == path[0]\n\n    def is_valid_mirror(mirror: str) -> bool:\n        return mirror in ['/', '\\\\']\n\n    def is_valid_cell(cell: str) -> bool:\n        return cell in ['.', '#', '/', '\\\\', 'V', 'H']\n\n    def is_valid_gargoyle_path(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return is_valid_path(rotate_gargoyle(gargoyle, 0), 1)\n        elif direction == 1:\n            return is_valid_path(rotate_gargoyle(gargoyle, 1), 0)\n        elif direction == 2:\n            return is_valid_path(rotate_gargoyle(gargoyle, 2), 1)\n        else:\n            return is_valid_path(rotate_gargoyle(gargoyle, 3), 0)\n\n    def is_valid_gargoyle_mirror(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return is_valid_mirror(gargoyle[0])\n        elif direction == 1:\n            return is_valid_mirror(gargoyle[1])\n        elif direction == 2:\n            return is_valid_mirror(gargoyle[0])\n        else:\n            return is_valid_mirror(gargoyle[1])\n\n    def is_valid_gargoyle_cell(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return is_valid_cell(gargoyle[0])\n        elif direction == 1:\n            return is_valid_cell(gargoyle[1])\n        elif direction == 2:\n            return is_valid_cell(gargoyle[0])\n        else:\n            return is_valid_cell(gargoyle[1])\n\n    def is_valid_gargoyle_position(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return gargoyle[0] == '.'\n        elif direction == 1:\n            return gargoyle[1] == '.'\n        elif direction == 2:\n            return gargoyle[0] == '.'\n        else:\n            return gargoyle[1] == '.'\n\n    def is_valid_gargoyle_position_mirror(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return gargoyle[0] == '/'\n        elif direction == 1:\n            return gargoyle[1] == '\\\\'\n        elif direction == 2:\n            return gargoyle[0] == '/'\n        else:\n            return gargoyle[1] == '\\\\'\n\n    def is_valid_gargoyle_position_cell(gargoyle: list, direction: int) -> bool:\n        if direction == 0:\n            return gargoyle[0] == 'V'\n        elif direction == 1:\n            return gargoyle[1] == 'H'\n        elif direction == 2:\n            return gargoyle[0] == 'V'\n        else:\n            return gargoyle[1] == '"
    },
    {
        "number": 3273,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    fragments = stdin.split('\\n')\n    n = len(fragments)\n    if n == 1:\n        return fragments[0]\n\n    def is_valid(i: int, j: int) -> bool:\n        if i == j:\n            return False\n        if fragments[i].endswith(fragments[j]):\n            return True\n        if fragments[j].endswith(fragments[i]):\n            return True\n        return False\n\n    def find_maximal_length(i: int, j: int) -> int:\n        max_length = 0\n        while i < j:\n            if is_valid(i, j):\n                max_length = max(max_length, j - i + 1)\n            if is_valid(i, j - 1):\n                max_length = max(max_length, j - i + 1)\n            i += 1\n            j -= 1\n        return max_length\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid(i, j):\n                max_length = max(max_length, find_maximal_length(i, j))\n\n    if max_length == 0:\n        return 'AMBIGUOUS'\n\n    result = ''\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid(i, j) and find_maximal_length(i, j) == max_length:\n                result += fragments[i] + '|' + fragments[j] + '|'\n\n    return result.rstrip('|')"
    },
    {
        "number": 3274,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.split())\n        ships.append((x1, x2, y))\n\n    def is_safe(x, y, ships):\n        for ship in ships:\n            if x == ship[0] or x == ship[1]:\n                return False\n            if y == ship[2]:\n                return False\n        return True\n\n    def is_safe_from_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is_safe_from_torpedo_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship_and_ship(x, y, ship):\n        if x == ship[0] or x == ship[1]:\n            return False\n        if y == ship[2]:\n            return False\n        return True\n\n    def is"
    },
    {
        "number": 3275,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    q = int(stdin.split()[0])\n    changes = []\n    for _ in range(q):\n        p, a_p, b_p = map(int, stdin.split())\n        changes.append((p, a_p, b_p))\n\n    def count_purchases(a_p, b_p):\n        if a_p > c:\n            return 0\n        colored_purchases = 0\n        black_white_purchases = 0\n        for i in range(n):\n            if a[i] <= a_p and b[i] <= b_p:\n                colored_purchases += 1\n            elif a[i] <= a_p:\n                black_white_purchases += 1\n        return colored_purchases + black_white_purchases\n\n    result = []\n    for change in changes:\n        a_p, b_p = change[1], change[2]\n        result.append(count_purchases(a_p, b_p))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3276,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    board = [[\"W\" for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        row = stdin.split()[i]\n        for j in range(M):\n            board[i][j] = row[j]\n\n    red_paint = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0],\n    ]\n    green_paint = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0],\n    ]\n    blue_paint = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0],\n    ]\n\n    def stamp_square(x: int, y: int, color: str) -> None:\n        for i in range(3):\n            for j in range(3):\n                if board[x + i][y + j] == \"W\":\n                    board[x + i][y + j] = color\n\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == \"R\":\n                red_paint[i // 3][j // 3] += 1\n            elif board[i][j] == \"G\":\n                green_paint[i // 3][j // 3] += 1\n            elif board[i][j] == \"B\":\n                blue_paint[i // 3][j // 3] += 1\n\n    for i in range(N):\n        for j in range(M):\n            if red_paint[i // 3][j // 3] > 0:\n                stamp_square(i, j, \"R\")\n            if green_paint[i // 3][j // 3] > 0:\n                stamp_square(i, j, \"G\")\n            if blue_paint[i // 3][j // 3] > 0:\n                stamp_square(i, j, \"B\")\n\n    for i in range(N):\n        for j in range(M):\n            if board[i][j] == \"W\":\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3277,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_smooth(arr):\n        return sum(arr[i:i + k]) == s\n\n    def min_changes(arr):\n        min_changes = 0\n        for i in range(n - k + 1):\n            if is_smooth(arr[i:i + k]):\n                min_changes += k\n            else:\n                break\n        return min_changes\n\n    return str(min_changes(a))\n"
    },
    {
        "number": 3278,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    frogs = []\n    for i in range(n):\n        x, d = map(int, stdin.split()[1:3])\n        frogs.append((x, d))\n    frogs.sort(key=lambda x: x[1])\n    max_tower = frogs[-1][0]\n    tower_size = 1\n    for i in range(n - 1, -1, -1):\n        if frogs[i][0] - max_tower > tower_size:\n            tower_size = frogs[i][0] - max_tower\n    return f\"{max_tower} {tower_size}\""
    },
    {
        "number": 3279,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rows = []\n    for i in range(n):\n        row = list(map(int, stdin.split()[i+1:i+1+n]))\n        rows.append(row)\n\n    def is_valid(row: list, col: int) -> bool:\n        for i in range(len(row)):\n            if row[i] > 0 and row[i]!= col:\n                return False\n        return True\n\n    def find_valid_marking(rows: list, cols: list) -> str:\n        for i in range(n):\n            for j in range(n):\n                if rows[i][j] > 0 and cols[j][i] > 0:\n                    return \"0\" * n + \"1\" * n\n\n        for i in range(n):\n            for j in range(n):\n                if rows[i][j] > 0 and is_valid(rows[i], j):\n                    return \"0\" * n + \"1\" * rows[i][j]\n\n        for i in range(n):\n            for j in range(n):\n                if cols[j][i] > 0 and is_valid(cols[j], i):\n                    return \"1\" * n + \"0\" * cols[j][i]\n\n        return \"1\" * n + \"1\" * n\n\n    def find_consistent_marking(rows: list, cols: list) -> str:\n        for i in range(n):\n            for j in range(n):\n                if rows[i][j] > 0 and cols[j][i] > 0:\n                    return \"0\" * n + \"1\" * n\n\n        for i in range(n):\n            for j in range(n):\n                if rows[i][j] > 0 and is_valid(rows[i], j):\n                    return \"0\" * n + \"1\" * rows[i][j]\n\n        for i in range(n):\n            for j in range(n):\n                if cols[j][i] > 0 and is_valid(cols[j], i):\n                    return \"1\" * n + \"0\" * cols[j][i]\n\n        return \"1\" * n + \"1\" * n\n\n    rows_marking = find_valid_marking(rows, [0] * n)\n    cols_marking = find_valid_marking([0] * n, cols)\n\n    return rows_marking + cols_marking"
    },
    {
        "number": 3280,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    shows = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        shows.append((x, y))\n\n    shows.sort(key=lambda x: x[0])\n\n    count = 0\n    current_start = 0\n    current_end = 0\n\n    for i in range(n):\n        if current_end < shows[i][0]:\n            count += 1\n            current_start = shows[i][0]\n            current_end = shows[i][1]\n        elif current_end == shows[i][0]:\n            current_end = shows[i][1]\n\n    return str(count)"
    },
    {
        "number": 3281,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int, List[Tuple[int, int]], List[Tuple[int, int]]]:\n        J, R, D = map(int, stdin.split())\n        junctions = []\n        for _ in range(J):\n            x, y = map(int, stdin.split())\n            junctions.append((x, y))\n        roads = []\n        for _ in range(R):\n            a, b = map(int, stdin.split())\n            roads.append((a - 1, b - 1))\n        return J, R, D, junctions, roads\n\n    def is_valid_route(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]]) -> bool:\n        visited = set()\n        queue = deque([0])\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        return len(visited) == len(junctions)\n\n    def calculate_turning_angle(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]]) -> float:\n        visited = set()\n        queue = deque([0])\n        turning_angle = 0\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    turning_angle += calculate_turning_angle(junctions, roads)\n        return turning_angle\n\n    def calculate_distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def calculate_angle(x1: int, y1: int, x2: int, y2: int) -> float:\n        return math.degrees(math.atan2(y2 - y1, x2 - x1))\n\n    def calculate_turning_angle_for_junction(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]], current_junction: int) -> float:\n        visited = set()\n        queue = deque([current_junction])\n        turning_angle = 0\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    turning_angle += calculate_turning_angle_for_junction(junctions, roads, neighbor)\n        return turning_angle\n\n    def find_shortest_route(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        visited = set()\n        queue = deque([0])\n        shortest_route = []\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    shortest_route.append(neighbor)\n        return shortest_route\n\n    def find_optimal_route(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        visited = set()\n        queue = deque([0])\n        optimal_route = []\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    optimal_route.append(neighbor)\n        return optimal_route\n\n    def find_shortest_route_with_minimum_turning_angle(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        visited = set()\n        queue = deque([0])\n        shortest_route = []\n        while queue:\n            current = queue.popleft()\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in roads[current]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    shortest_route.append(neighbor)\n        return shortest_route\n\n    def find_optimal_route_with_minimum_turning_angle(junctions: List["
    },
    {
        "number": 3282,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    if P < 1:\n        return \"Invalid input\"\n\n    def is_valid_bill(bill: str) -> bool:\n        beverage_price, main_dish_price, total_price = map(int, bill.split())\n        if beverage_price >= main_dish_price:\n            return False\n        for i in range(10):\n            if bill.count(str(i)) > 1:\n                return False\n        return True\n\n    def get_free_desserts(P: int) -> int:\n        bills = []\n        for beverage_price in range(1, P + 1):\n            for main_dish_price in range(beverage_price, P + 1):\n                total_price = beverage_price + main_dish_price\n                if total_price == P:\n                    bills.append(f\"{beverage_price} {main_dish_price}\")\n        return len(bills)\n\n    free_desserts = get_free_desserts(P)\n    if free_desserts > 5000:\n        free_desserts = 5000\n\n    return str(free_desserts)"
    },
    {
        "number": 3283,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n    expected = sum(a[:r])\n    for i in range(d):\n        a.pop(0)\n        expected += a[0]\n    return f\"{expected:.6f}\""
    },
    {
        "number": 3284,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a, b + 1):\n        for y in range(c, d + 1):\n            if gcd(x, y) == 1:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, m = map(int, stdin.split())\n    A = [1]\n    for i in range(r - 1):\n        A.append(A[-1] + i + 1)\n    A.sort()\n    for i in range(len(A)):\n        if A[i] == m:\n            return str(i + 1)\n    return \"0\""
    },
    {
        "number": 3286,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    password = stdin.lower()\n    result = \"\"\n    for i in range(len(password)):\n        if password[i] in \"aeiou\":\n            result += password[i]\n        else:\n            result += password[i] * 2\n    return str((len(password) * 2) % 1000009)"
    },
    {
        "number": 3287,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *x = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [0] * (2**k)\n    dp[0] = 0\n    for i in range(1, 2**k):\n        for j in range(k):\n            if i & (1 << j):\n                dp[i] = min(dp[i], dp[i ^ (1 << j)] + x[j])\n        dp[i] %= MOD\n    return str(dp[2**k - 1])"
    },
    {
        "number": 3288,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k < 2 or k > 26:\n        return -1\n\n    strings = []\n    for i in range(26):\n        for j in range(1, k + 1):\n            if i + j == 26:\n                strings.append(chr(i) * j)\n\n    strings.sort()\n    return strings[n - 1] if 0 <= n <= len(strings) else -1"
    },
    {
        "number": 3289,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    data = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    data.sort(key=lambda x: x[0] * 1000000 + x[1] * 10000 + x[2])\n    cluster_size = 1\n    for i in range(1, n):\n        if data[i][2] == data[i - 1][2]:\n            cluster_size += 1\n        else:\n            break\n    return str(cluster_size)"
    },
    {
        "number": 3290,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players, exploding_kittens, defuses = map(int, stdin.split())\n    exploding_kittens_cards = [exploding_kittens]\n    defuses_cards = [defuses]\n\n    for _ in range(exploding_kittens):\n        exploding_kittens_cards.append(exploding_kittens_cards[-1] + exploding_kittens_cards[-2])\n\n    for _ in range(defuses):\n        defuses_cards.append(defuses_cards[-1] + defuses_cards[-2])\n\n    def get_player_id(player_hand: list) -> int:\n        for i, card in enumerate(player_hand):\n            if card in exploding_kittens_cards:\n                return i\n        return -1\n\n    def get_winner(exploding_kittens_cards: list, defuses_cards: list) -> int:\n        exploding_kittens_cards.sort()\n        defuses_cards.sort()\n\n        for i, card in enumerate(exploding_kittens_cards):\n            if card in defuses_cards:\n                return i\n\n        return -1\n\n    def play_turn(player_hand: list, exploding_kittens_cards: list, defuses_cards: list) -> int:\n        player_id = get_player_id(player_hand)\n\n        if player_id == -1:\n            return -1\n\n        if len(player_hand) > 5:\n            player_hand = player_hand[:5]\n\n        if player_hand:\n            if player_hand[-1] in exploding_kittens_cards:\n                if len(player_hand) > 1:\n                    player_hand.pop()\n                    player_hand.pop()\n                else:\n                    player_hand.pop()\n            else:\n                player_hand.pop()\n\n        return player_id\n\n    def play_game(players: int, exploding_kittens: int, defuses: int) -> int:\n        exploding_kittens_cards = [exploding_kittens]\n        defuses_cards = [defuses]\n\n        for _ in range(exploding_kittens):\n            exploding_kittens_cards.append(exploding_kittens_cards[-1] + exploding_kittens_cards[-2])\n\n        for _ in range(defuses):\n            defuses_cards.append(defuses_cards[-1] + defuses_cards[-2])\n\n        player_hands = [[] for _ in range(players)]\n        player_ids = [0] * players\n\n        for i in range(players):\n            player_id = play_turn(player_hands[i], exploding_kittens_cards, defuses_cards)\n            player_ids[i] = player_id\n\n        winner_id = get_winner(exploding_kittens_cards, defuses_cards)\n\n        return player_ids.index(winner_id)\n\n    return str(play_game(players, exploding_kittens, defuses))\n"
    },
    {
        "number": 3291,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    def dfs(i, used, res):\n        if i == len(splitters):\n            if used == 0:\n                res.append(used)\n            return\n        if used == 0:\n            dfs(i + 1, used, res)\n            return\n        if splitters[i][0] == -1:\n            dfs(i + 1, used, res)\n        else:\n            dfs(i + 1, used - 1, res)\n            dfs(i + 1, used, res)\n\n    splitters = []\n    for i in range(200):\n        splitters.append([i, -1])\n\n    dfs(0, 0, splitters)\n\n    return str(len(splitters)) + '\\n' + '\\n'.join(map(lambda x:''.join(map(str, x)), splitters))"
    },
    {
        "number": 3292,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = [line.strip() for line in stdin.split('\\n')]\n    n = len(names)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if names[i][:2] == names[j][:2]:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3293,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    snacks = []\n    for i in range(1, n+1):\n        f, p, m, s = map(int, stdin.split()[1:])\n        snacks.append((f, p, m, s))\n    snacks.sort(key=lambda x: (-x[1], x[0]))\n    max_profit = 0\n    for i in range(n):\n        if snacks[i][3] > 0:\n            max_profit += snacks[i][3] * snacks[i][2] - snacks[i][1]\n    return str(max_profit)"
    },
    {
        "number": 3294,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *heights = map(int, stdin.split())\n    contours = []\n    for i in range(n):\n        h0, h1, m = map(int, input().split())\n        contour = []\n        for j in range(m):\n            x, y = map(int, input().split())\n            contour.append((x, y))\n        contours.append((h0, h1, contour))\n\n    def distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def closest_slanted_distance(contour: tuple) -> float:\n        h0, h1, points = contour\n        min_distance = float('inf')\n        for i in range(len(points) - 1):\n            p1, p2 = points[i], points[i + 1]\n            distance_to_target = distance(p1, (0, 0))\n            if distance_to_target < min_distance:\n                min_distance = distance_to_target\n        return min_distance\n\n    closest_slanted_distances = [closest_slanted_distance(contour) for contour in contours]\n    return str(min(closest_slanted_distances))"
    },
    {
        "number": 3295,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.split()[0])\n    happy_numbers = []\n    for i in range(Q):\n        K, L, M = map(int, stdin.split()[1:])\n        slavko_numbers = list(range(1, K+1))\n        slavko_numbers.sort()\n        happy_numbers.append(len(slavko_numbers))\n        for j in range(L):\n            slavko_numbers.pop(0)\n            if all(x <= M for x in slavko_numbers) and all(is_prime(x) for x in slavko_numbers):\n                happy_numbers[-1] -= 1\n                break\n        if happy_numbers[-1] <= 0:\n            return -1\n    return''.join(map(str, happy_numbers))\n\ndef"
    },
    {
        "number": 3296,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    P = 2**31 - 1\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if (i + j) % 2 == 0:\n                continue\n            for k in range(1, N + 1):\n                if (i + j + k) % 2 == 0:\n                    continue\n                if (i + j + k) % P == 0:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 3297,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def replace_letter(word: str, letter: str, digit: int) -> str:\n        if letter == '0':\n            return word\n        if letter == 'A':\n            return str(digit)\n        if letter == 'B':\n            return str(digit + 1)\n        if letter == 'C':\n            return str(digit + 2)\n        if letter == 'D':\n            return str(digit + 3)\n        if letter == 'E':\n            return str(digit + 4)\n        if letter == 'F':\n            return str(digit + 5)\n        if letter == 'G':\n            return str(digit + 6)\n        if letter == 'H':\n            return str(digit + 7)\n        if letter == 'I':\n            return str(digit + 8)\n        if letter == 'J':\n            return str(digit + 9)\n        if letter == 'K':\n            return str(digit + 10)\n        if letter == 'L':\n            return str(digit + 11)\n        if letter == 'M':\n            return str(digit + 12)\n        if letter == 'N':\n            return str(digit + 13)\n        if letter == 'O':\n            return str(digit + 14)\n        if letter == 'P':\n            return str(digit + 15)\n        if letter == 'Q':\n            return str(digit + 16)\n        if letter == 'R':\n            return str(digit + 17)\n        if letter == 'S':\n            return str(digit + 18)\n        if letter == 'T':\n            return str(digit + 19)\n        if letter == 'U':\n            return str(digit + 20)\n        if letter == 'V':\n            return str(digit + 21)\n        if letter == 'W':\n            return str(digit + 22)\n        if letter == 'X':\n            return str(digit + 23)\n        if letter == 'Y':\n            return str(digit + 24)\n        if letter == 'Z':\n            return str(digit + 25)\n        return word\n\n    def is_valid(word: str) -> bool:\n        for i in range(len(word)):\n            if word[i] == '0':\n                return False\n        return True\n\n    def find_min_solution(puzzle: str) -> str:\n        words = puzzle.split('+')\n        min_solution = ''\n        for i in range(len(words)):\n            word1 = words[i].split('=')[0]\n            word2 = words[i].split('=')[1]\n            for digit in range(10):\n                word1_new = replace_letter(word1, word1[0], digit)\n                word2_new = replace_letter(word2, word2[0], digit)\n                if is_valid(word1_new) and is_valid(word2_new):\n                    min_solution = word1_new + '+' + word2_new + '=' + word2_new\n                    break\n            if min_solution!= '':\n                break\n        return min_solution\n\n    puzzles = stdin.split('\\n')\n    for puzzle in puzzles:\n        solution = find_min_solution(puzzle)\n        if solution == '':\n            print('impossible')\n        else:\n            print(solution)"
    },
    {
        "number": 3298,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_sorted(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i - 1]:\n                return False\n        return True\n\n    def count_unsorted_sequences(arr):\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i]!= arr[j]:\n                    count += 1\n        return count\n\n    def permute(arr):\n        if len(arr) == 1:\n            return [arr]\n        result = []\n        for i in range(len(arr)):\n            rest = arr[:i] + arr[i + 1:]\n            for p in permute(rest):\n                result.append([arr[i]] + p)\n        return result\n\n    count = 0\n    for p in permute(a):\n        if is_sorted(p):\n            count += 1\n\n    return str((count % (10**9 + 9)))"
    },
    {
        "number": 3299,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    board = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()[1].split()))\n        board.append(row)\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == 0:\n                for k in range(i, n):\n                    if board[k][j] > board[i][j]:\n                        board[i][j] = board[k][j]\n                        break\n                else:\n                    return -1\n\n    for i in range(m):\n        for j in range(n):\n            if board[j][i] == 0:\n                for k in range(j, m):\n                    if board[j][k] > board[j][i]:\n                        board[j][i] = board[j][k]\n                        break\n                else:\n                    return -1\n\n    total_sum = sum(sum(row) for row in board)\n    return str(total_sum)"
    },
    {
        "number": 3300,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    times = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    times.sort(key=lambda x: x[0])\n    total_time = sum(t for t, _ in times)\n    min_length = float('inf')\n    current_length = 0\n    for t, v in times:\n        current_length += v * (t - total_time)\n        min_length = min(min_length, current_length)\n    return f'{min_length:.20f}'"
    },
    {
        "number": 3301,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, x, y = map(int, stdin.split())\n    banks = list(map(int, stdin.split()))\n    agreements = []\n    for i in range(p):\n        a, b, c = map(int, stdin.split())\n        agreements.append((a, b, c))\n\n    owned_banks = set(banks)\n    for i in range(n):\n        if banks[i] == x or banks[i] == y:\n            owned_banks.remove(banks[i])\n\n    max_fee = 0\n    for a, b, c in agreements:\n        if a in owned_banks and b in owned_banks:\n            max_fee = max(max_fee, c)\n\n    if max_fee == 0:\n        return \"Impossible\"\n    elif max_fee == float('inf'):\n        return \"Infinity\"\n    else:\n        return str(max_fee)"
    },
    {
        "number": 3302,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = set(map(int, stdin.split()[1:]))\n    if len(s)!= p:\n        return \"impossible\"\n\n    def gray_code(n: int) -> list:\n        if n == 0:\n            return [\"\"]\n        return gray_code(n - 1) + [\"\".join(reversed(code)) for code in gray_code(n - 1)]\n\n    def color_code(n: int, s: set) -> list:\n        if n == 0:\n            return [\"\"]\n        codes = color_code(n - 1, s)\n        return [code + bit for code in codes for bit in \"01\" if bit not in s]\n\n    codes = color_code(n, s)\n    if not codes:\n        return \"impossible\"\n    return \"\\n\".join(codes)\n"
    },
    {
        "number": 3303,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = map(int, stdin.split())\n    steps = 0\n    while num1!= 0 or num2!= 0:\n        if num1 == 0:\n            num1 = 1\n            steps += 1\n        elif num2 == 0:\n            num2 = 1\n            steps += 1\n        else:\n            carry = 0\n            if num1 % 10 > num2 % 10:\n                carry = 1\n                num1 -= 1\n            elif num2 % 10 > num1 % 10:\n                carry = 1\n                num2 -= 1\n            else:\n                num1 //= 10\n                num2 //= 10\n            steps += 1\n            if carry == 1:\n                steps += 1\n    return str(steps)"
    },
    {
        "number": 3304,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *adversaries, *dwarves, *elves = map(int, stdin.split())\n    adversaries.sort(reverse=True)\n    dwarves.sort(reverse=True)\n    elves.sort(reverse=True)\n\n    def find_victor(elves, adversaries, dwarves):\n        victor = 0\n        for elf, adversary, dwarf in zip(elves, adversaries, dwarves):\n            if elf > adversary and elf > dwarf:\n                victor += 1\n        return victor\n\n    max_victor = 0\n    for i in range(n):\n        max_victor = max(max_victor, find_victor(elves[:i] + elves[i + 1 :], adversaries, dwarves))\n\n    return str(max_victor)"
    },
    {
        "number": 3305,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    S = stdin.split()[1]\n\n    def almost_palindromic(start: int, end: int) -> int:\n        count = 0\n        for i in range(start, end):\n            for j in range(i + 1, end + 1):\n                if S[i:j] == S[i:j][::-1]:\n                    count += 1\n        return count\n\n    result = []\n    for i in range(Q):\n        L, R = map(int, stdin.split())\n        result.append(almost_palindromic(L - 1, R))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3306,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    detectors = []\n    for i in range(n):\n        p, c = map(int, stdin.split())\n        detectors.append((p, c))\n\n    detectors.sort(key=lambda x: x[0])\n\n    min_calls = float('inf')\n    for i in range(n):\n        p, c = detectors[i]\n        if p == 1:\n            min_calls = min(min_calls, c)\n        else:\n            min_calls = min(min_calls, c + min_calls)\n\n    return str(min_calls)"
    },
    {
        "number": 3307,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vertices = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[i+1].split())\n        vertices.append((x, y))\n\n    x_a, y_a, x_b, y_b = map(int, stdin.split()[-4:])\n\n    def is_collinear(p1, p2, p3):\n        return (p1[0] - p2[0]) * (p3[1] - p2[1]) == (p2[0] - p1[0]) * (p3[1] - p1[1])\n\n    def is_simple_polygon(vertices):\n        for i in range(len(vertices) - 1):\n            if is_collinear(vertices[i], vertices[i+1], vertices[0]):\n                return False\n        return True\n\n    def is_connected(vertices):\n        return len(set(vertices)) == len(vertices)\n\n    def is_valid_land(vertices):\n        return is_simple_polygon(vertices) and is_connected(vertices)\n\n    def area(vertices):\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        return abs(x1 * y2 - x2 * y1) / 2\n\n    def max_area(land):\n        max_area = 0\n        for i in range(len(land) - 1):\n            for j in range(i + 2, len(land)):\n                max_area = max(max_area, area([land[i], land[j]]))\n        return max_area\n\n    def max_corn_area(land):\n        max_corn_area = 0\n        for i in range(len(land) - 1):\n            for j in range(i + 2, len(land)):\n                max_corn_area = max(max_corn_area, area([land[i], land[j]]))\n        return max_corn_area\n\n    def max_rice_area(land):\n        max_rice_area = 0\n        for i in range(len(land) - 1):\n            for j in range(i + 2, len(land)):\n                max_rice_area = max(max_rice_area, area([land[i], land[j]]))\n        return max_rice_area\n\n    def max_area_of_land(land):\n        max_corn_area = max_corn_area(land)\n        max_rice_area = max_rice_area(land)\n        return max(max_corn_area, max_rice_area)\n\n    def max_area_of_fields(land):\n        max_area_of_land(land)\n\n    def max_area_of_fields_for_person(land, person):\n        if person == 1:\n            return max_corn_area(land)\n        else:\n            return max_rice_area(land)\n\n    def max_area_of_fields_for_person_and_land(land, person):\n        max_area_of_fields_for_person(land, person)\n\n    def max_area_of_fields_for_person_and_land_and_land(land, person):\n        max_area_of_fields_for_person_and_land(land, person)\n\n    def max_area_of_fields_for_person_and_land_and_land_and_land(land, person):\n        max_area_of_fields_for_person_and_land_and_land(land, person)\n\n    def max_area_of_fields_for_person_and_land_and_land_and_land_and_land(land, person):\n        max_area_of_fields_for_person_and_land_and_land_and_land(land, person)\n\n    def max_area_of_fields_for_person_and_land_and_land_and_land_and_land_and_land(land, person):\n        max_area_of_fields_for_person_and_land_and_land_and_land_and_land(land, person)\n\n    def max_area_of_fields_for_person_and_land_and_land_and_land_and_land_and_land_and_land(land, person):\n        max_area_of_fields_for_person_and_land_and_land_and_land_and_land_and_land(land, person)\n\n    def max_area_of_fields_for_person_and"
    },
    {
        "number": 3308,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(float, stdin.split()[1:])\n        points.append((x, y))\n    points.append(points[0])\n\n    def is_inside(p: tuple, points: list) -> bool:\n        return not any(cross(p, q, r) for q in points for r in points if q!= r)\n\n    def cross(p: tuple, q: tuple, r: tuple) -> float:\n        return (p[0] - r[0]) * (q[1] - r[1]) - (p[1] - r[1]) * (q[0] - r[0])\n\n    def area(points: list) -> float:\n        return abs(sum(cross(points[i], points[i + 1], points[0]) for i in range(len(points) - 1))) / 2\n\n    def is_valid(points: list) -> bool:\n        return all(is_inside(p, points) for p in points)\n\n    def is_valid_polygon(points: list) -> bool:\n        return is_valid(points) and is_inside(points[0], points)\n\n    def is_valid_polygon_with_walls(points: list) -> bool:\n        return is_valid_polygon(points) and all(not is_inside(p, points) for p in points)\n\n    def is_valid_polygon_with_walls_and_neck(points: list) -> bool:\n        return is_valid_polygon_with_walls(points) and all(cross(p, points[0], points[1]) > 0 for p in points)\n\n    def is_valid_polygon_with_walls_and_neck_and_happiness(points: list) -> bool:\n        return is_valid_polygon_with_walls_and_neck(points) and all(cross(p, points[0], points[1]) > 0 for p in points)\n\n    def happiness(points: list) -> float:\n        return area(points) / area(points[0])\n\n    happiness_points = [p for p in points if is_valid_polygon_with_walls_and_neck_and_happiness(p)]\n    return str(happiness(happiness_points))"
    },
    {
        "number": 3309,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = map(int, stdin.split())\n    teams = list(map(int, stdin.split()))\n\n    def count_colors(team: int) -> int:\n        return len(set(teams))\n\n    def count_sectors(team: int) -> int:\n        return teams.count(team)\n\n    def is_valid(team: int) -> bool:\n        return count_colors(team) >= c and count_sectors(team) >= k\n\n    valid_teams = [team for team in teams if is_valid(team)]\n    return str(len(valid_teams))"
    },
    {
        "number": 3310,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, t = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    expected_occupancy = 0\n    for i in range(t):\n        group_size = random.randint(1, g)\n        table_capacity = min(c)\n        expected_occupancy += group_size * table_capacity\n        c.remove(table_capacity)\n\n    return str(expected_occupancy / t)"
    },
    {
        "number": 3311,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = pow(n, (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5), m)\n    return str(result)"
    },
    {
        "number": 3312,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e, s_x, s_y, c = map(int, stdin.split())\n    cans = []\n    for _ in range(c):\n        x, y, t = map(int, stdin.split())\n        cans.append((x, y, t))\n\n    def can_appear(x: int, y: int) -> bool:\n        return all(0 <= i < n for i in range(x - 1, x + 2)) and all(0 <= j < n for j in range(y - 1, y + 2))\n\n    def can_collect(x: int, y: int) -> bool:\n        return can_appear(x, y) and all(cans[i][0] == x and cans[i][1] == y for i in range(c))\n\n    def collect_can(x: int, y: int) -> int:\n        points = 1\n        for i in range(c):\n            if cans[i][0] == x and cans[i][1] == y:\n                points += 1\n                cans.pop(i)\n                break\n        return points\n\n    def collect_spilled_oil(x: int, y: int) -> int:\n        points = 0\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < n and 0 <= ny < n and can_appear(nx, ny):\n                points += collect_can(nx, ny)\n        return points\n\n    def collect_exploded_oil(x: int, y: int) -> int:\n        points = 0\n        for i in range(4):\n            nx, ny = x + dx[i], y + dy[i]\n            if 0 <= nx < n and 0 <= ny < n and can_appear(nx, ny):\n                points += collect_spilled_oil(nx, ny)\n        return points\n\n    dx = [0, 0, -1, 1]\n    dy = [-1, 1, 0, 0]\n\n    points = 0\n    x, y = s_x, s_y\n    while can_collect(x, y):\n        points += collect_can(x, y)\n        x, y = x + dx[0], y + dy[0]\n\n    points += collect_exploded_oil(x, y)\n\n    return str(points)"
    },
    {
        "number": 3313,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.split())\n    gems = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        gems.append((x, y))\n\n    def is_valid(x, y):\n        return 0 <= x <= w and 0 <= y <= h\n\n    def is_gem(x, y):\n        return any(abs(x - gem[0]) <= r and abs(y - gem[1]) <= r for gem in gems)\n\n    def is_finish(x, y):\n        return y == h\n\n    def is_valid_move(x, y, dx, dy):\n        return is_valid(x + dx, y + dy) and is_gem(x + dx, y + dy)\n\n    def is_valid_move_with_velocity(x, y, dx, dy, v):\n        return is_valid_move(x + dx * v, y + dy * v, dx, dy)\n\n    def is_valid_move_with_velocity_and_horizontal_speed(x, y, dx, dy, v, h):\n        return is_valid_move_with_velocity(x, y, dx, dy, v) and abs(dx) <= h\n\n    def is_valid_move_with_velocity_and_horizontal_speed_and_vertical_speed(x, y, dx, dy, v, h):\n        return is_valid_move_with_velocity_and_horizontal_speed(x, y, dx, dy, v, h) and abs(dy) <= v\n\n    def collect_gems(x, y, dx, dy, v, h):\n        gems_collected = 0\n        while is_valid_move_with_velocity_and_horizontal_speed_and_vertical_speed(x, y, dx, dy, v, h):\n            x += dx * v\n            y += dy * v\n            gems_collected += 1\n        return gems_collected\n\n    max_gems = 0\n    for dx in range(-r, r + 1):\n        for dy in range(-r, r + 1):\n            if is_gem(x + dx, y + dy):\n                max_gems = max(max_gems, collect_gems(x, y, dx, dy, v, w))\n\n    return str(max_gems)"
    },
    {
        "number": 3314,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_distinct_letters(wheel: str) -> int:\n        letter_count = [0] * 3\n        for letter in wheel:\n            letter_count[letter_count.index(letter)] += 1\n        return letter_count\n\n    def is_valid_rotation(wheel1: str, wheel2: str, wheel3: str) -> bool:\n        letter_count1 = count_distinct_letters(wheel1)\n        letter_count2 = count_distinct_letters(wheel2)\n        letter_count3 = count_distinct_letters(wheel3)\n        return letter_count1 == letter_count2 == letter_count3\n\n    def min_rotations(wheel1: str, wheel2: str, wheel3: str) -> int:\n        if not is_valid_rotation(wheel1, wheel2, wheel3):\n            return -1\n\n        def rotate_wheel(wheel: str, direction: int) -> str:\n            new_wheel = wheel[direction:] + wheel[:direction]\n            return new_wheel\n\n        def count_distinct_letters_after_rotation(wheel: str, direction: int) -> int:\n            new_wheel = rotate_wheel(wheel, direction)\n            return count_distinct_letters(new_wheel)\n\n        def is_valid_rotation_after_rotation(wheel1: str, wheel2: str, wheel3: str, direction: int) -> bool:\n            new_wheel1 = rotate_wheel(wheel1, direction)\n            new_wheel2 = rotate_wheel(wheel2, direction)\n            new_wheel3 = rotate_wheel(wheel3, direction)\n            return is_valid_rotation(new_wheel1, new_wheel2, new_wheel3)\n\n        def min_rotations_helper(wheel1: str, wheel2: str, wheel3: str, current_rotations: int) -> int:\n            if is_valid_rotation_after_rotation(wheel1, wheel2, wheel3, 0):\n                return current_rotations\n            if is_valid_rotation_after_rotation(wheel1, wheel2, wheel3, 1):\n                return min_rotations_helper(wheel1, wheel2, wheel3, current_rotations + 1)\n            if is_valid_rotation_after_rotation(wheel1, wheel2, wheel3, 2):\n                return min_rotations_helper(wheel1, wheel2, wheel3, current_rotations + 1)\n            return -1\n\n        return min_rotations_helper(wheel1, wheel2, wheel3, 0)\n\n    def process_input(input_str: str) -> str:\n        wheel1, wheel2, wheel3 = input_str.split()\n        return min_rotations(wheel1, wheel2, wheel3)\n\n    return process_input(stdin)"
    },
    {
        "number": 3315,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    strings = stdin.split('\\n')\n    strings = [s.upper() for s in strings]\n    N = len(strings)\n    max_length = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if strings[i] in strings[j] and strings[j] in strings[i]:\n                max_length = max(max_length, len(strings[i]) + len(strings[j]))\n    return str(max_length)"
    },
    {
        "number": 3316,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, t, p = map(int, stdin.split())\n    if n > m:\n        return \"0.0\"\n\n    # Calculate the probability of getting tickets for the entire group\n    probability = 1\n    for i in range(1, p + 1):\n        probability *= (i / p)\n\n    # Calculate the probability of getting tickets for each person\n    for i in range(1, p + 1):\n        probability *= (i / p)\n\n    # Calculate the probability of getting tickets for the lucky winners\n    for i in range(1, n + 1):\n        probability *= (i / n)\n\n    # Calculate the probability of getting tickets for each winner\n    for i in range(1, t + 1):\n        probability *= (i / t)\n\n    return f\"{probability:.9f}\""
    },
    {
        "number": 3317,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    q = int(stdin.split('\\n')[1])\n    queries = []\n    for _ in range(q):\n        i, j = map(int, stdin.split('\\n')[2].split())\n        queries.append((i, j))\n\n    def is_valid(seq: str) -> bool:\n        for i in range(len(seq) - 1):\n            if seq[i]!= seq[i + 1]:\n                return False\n        return True\n\n    def longest_valid_sequence(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if is_valid(seq[i:i + 2]):\n                longest = max(longest, longest_valid_sequence(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_sequence(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_sequence(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates_and_repetitions(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates_and_repetitions(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions_and_repetitions(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions_and_repetitions(seq[i:i + 2]))\n        return longest + 1\n\n    def longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions_and_repetitions_and_repetitions(seq: str) -> int:\n        longest = 0\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                longest = max(longest, longest_consecutive_sequence_with_duplicates_and_repetitions_and_repetitions_and_repetitions_and_repetitions_and_repetitions(seq[i:i + 2]))"
    },
    {
        "number": 3318,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    tree = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for child in tree[node]:\n            if child not in visited:\n                dfs(child, visited)\n\n    max_marked = 0\n    for i in range(n):\n        visited = set()\n        dfs(i, visited)\n        max_marked = max(max_marked, len(visited))\n\n    return str(max_marked)"
    },
    {
        "number": 3319,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, n_x, n_y, n_z = map(int, stdin.split())\n    planetoids = []\n    for _ in range(n):\n        m, x, y, z, vx, vy, vz = map(int, stdin.split())\n        planetoids.append((m, (x, y, z), (vx, vy, vz)))\n\n    def collide(p1, p2):\n        return (p1[1][0] == p2[1][0] and p1[1][1] == p2[1][1] and p1[1][2] == p2[1][2])\n\n    def average_velocity(p1, p2):\n        return tuple(int(round((p1[2][i] + p2[2][i]) / 2)) for i in range(3))\n\n    def collide_and_resolve(p1, p2):\n        if collide(p1, p2):\n            p1[0] += p2[0]\n            p1[1] = p2[1]\n            p1[2] = average_velocity(p1, p2)\n            return True\n        return False\n\n    def find_collisions(planetoids):\n        collisions = []\n        for i in range(len(planetoids)):\n            for j in range(i + 1, len(planetoids)):\n                if collide(planetoids[i], planetoids[j]):\n                    collisions.append((i, j))\n        return collisions\n\n    def find_full_planets(planetoids):\n        full_planets = []\n        for i in range(len(planetoids)):\n            if planetoids[i][0] == max(planetoids, key=lambda x: x[0])[0]:\n                full_planets.append(i)\n        return full_planets\n\n    def find_planets(planetoids):\n        collisions = find_collisions(planetoids)\n        full_planets = find_full_planets(planetoids)\n        planets = []\n        for i in range(len(planetoids)):\n            if i not in full_planets and i not in collisions:\n                planets.append(i)\n        return planets\n\n    planets = find_planets(planetoids)\n    print(len(planets))\n    for i in range(len(planets)):\n        print(f\"P{i}: {planetoids[planets[i]][0]} {planetoids[planets[i]][1]} {planetoids[planets[i]][2]}\")\n\n    return \"\"\n"
    },
    {
        "number": 3320,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    cities = [0] + cities\n    dp = [0] * (n + 1)\n    dp[1] = cities[1] - cities[0]\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + cities[i]\n    for i in range(m):\n        a, b, w = map(int, stdin.split())\n        dp[a] = min(dp[a], dp[b] + w)\n        dp[b] = min(dp[b], dp[a] + w)\n    q = int(stdin.split()[0])\n    for _ in range(q):\n        s, t = map(int, stdin.split())\n        print(dp[s] + dp[t])"
    },
    {
        "number": 3321,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    starting_sequence = list(map(int, stdin.split()[1].split()))\n    resulting_sequence = list(map(int, stdin.split()[2].split()))\n\n    def make_leaps(frog_id: int, leaps: int) -> int:\n        if leaps == 0:\n            return frog_id\n        return make_leaps(frog_id + 1, leaps - 1)\n\n    def rearrange_frogs(frog_sequence: List[int]) -> List[int]:\n        result = []\n        for frog_id in frog_sequence:\n            result.append(make_leaps(frog_id, frog_sequence.index(frog_id) + 1))\n        return result\n\n    starting_rearranged = rearrange_frogs(starting_sequence)\n    resulting_rearranged = rearrange_frogs(resulting_sequence)\n\n    proclamations = []\n    for i in range(len(starting_rearranged)):\n        if starting_rearranged[i]!= resulting_rearranged[i]:\n            proclamations.append(starting_rearranged[i])\n\n    return \" \".join(map(str, proclamations))\n"
    },
    {
        "number": 3322,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    shops = [[] for _ in range(m + 1)]\n    for _ in range(n):\n        a, p, b, q = map(int, stdin.split())\n        shops[a].append((p, b))\n        shops[b].append((q, a))\n\n    min_cost = float('inf')\n    for i in range(1, m + 1):\n        if len(shops[i]) <= k:\n            continue\n        min_cost = min(min_cost, sum(p for p, _ in shops[i]) + sum(q for _, q in shops[i]))\n\n    return str(min_cost) if min_cost!= float('inf') else '-1'"
    },
    {
        "number": 3323,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for i in range(1, test_cases + 1):\n        n = int(stdin.split('\\n')[i])\n        min_fractions = [int(x) for x in stdin.split('\\n')[i].split()[1:]]\n        max_likes = 0\n        for j in range(n):\n            likes = [min_fractions[0], min_fractions[1], min_fractions[2]]\n            for k in range(3):\n                likes[k] = min_fractions[k] + likes[k]\n            max_likes = max(max_likes, max(likes))\n        print(f\"Case #{i}: {max_likes}\")"
    },
    {
        "number": 3324,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    reactants = []\n    products = []\n    for line in lines:\n        if line.strip() == '0 0':\n            break\n        sign, n, *elements = line.split()\n        n = int(n)\n        elements = [tuple(sorted(e.split())) for e in elements]\n        if sign == '+':\n            reactants.append(elements)\n        else:\n            products.append(elements)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def balance(reactants, products):\n        def common_elements(reactants, products):\n            common = set()\n            for r, p in zip(reactants, products):\n                common.update(set(r) & set(p))\n            return common\n\n        def common_coefficients(reactants, products):\n            common = set()\n            for r, p in zip(reactants, products):\n                common.update(set(r) & set(p))\n            return common\n\n        def common_coefficient(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c for c in common if c[0] == element)\n\n        def common_coefficient_count(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum_product(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum_product_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum_product_sum_product(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return next(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum_product_sum_product_sum(reactants, products, element):\n            common = common_coefficients(reactants, products)\n            return sum(c[1] for c in common if c[0] == element)\n\n        def common_coefficient_count_product_sum_product_sum_product_sum_product_sum_product_sum_product(reactants, products, element):\n            common = common_coefficients(reactants"
    },
    {
        "number": 3325,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, l = map(int, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        vertices.append((x, y))\n    vertices.sort(key=lambda x: x[1])\n    left, right = 0, 1\n    height = 0\n    while left < right:\n        mid = (left + right) // 2\n        if vertices[mid][1] <= height:\n            left = mid + 1\n        else:\n            right = mid\n    return f\"{height:.2f}\""
    },
    {
        "number": 3326,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[1:])\n    grid = [list(map(int, stdin.split()[1:])) for _ in range(r)]\n\n    def is_monotonic(row: list) -> bool:\n        return all(row[i] <= row[i + 1] for i in range(len(row) - 1))\n\n    def is_monotonic_column(column: list) -> bool:\n        return all(column[i] <= column[i + 1] for i in range(len(column) - 1))\n\n    def count_monotonic_subgrids(grid: list) -> int:\n        monotonic_subgrids = 0\n        for i in range(r):\n            for j in range(c):\n                if is_monotonic(grid[i][j]):\n                    monotonic_subgrids += 1\n        for j in range(c):\n            for i in range(r):\n                if is_monotonic_column(grid[i][j]):\n                    monotonic_subgrids += 1\n        return monotonic_subgrids\n\n    return str(count_monotonic_subgrids(grid))"
    },
    {
        "number": 3327,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    N = int(stdin.split('\\n')[2])\n    words = stdin.split('\\n')[3:]\n\n    for word in words:\n        for i in range(len(word)):\n            if word[i] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                for j in range(len(word)):\n                    if j == i:\n                        continue\n                    if word[j] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                        if grid[i][j] == '.':\n                            grid[i][j] = word[i]\n                        elif grid[i][j] == '#':\n                            grid[i][j] = word[j]\n                        else:\n                            return \"Invalid input\"\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                grid[i][j] = '#'\n\n    return '\\n'.join([''.join(row) for row in grid])"
    },
    {
        "number": 3328,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_valid(table, dominoes):\n        for i in range(n):\n            for j in range(n):\n                if table[i][j] == 0:\n                    continue\n                for d in dominoes:\n                    if i == d[0] or i == d[1] or j == d[0] or j == d[1]:\n                        return False\n        return True\n\n    def domino_sum(table, dominoes):\n        total_sum = 0\n        for d in dominoes:\n            total_sum += table[d[0]][d[1]] + table[d[1]][d[0]]\n        return total_sum\n\n    def domino_cover(table, dominoes):\n        for d in dominoes:\n            table[d[0]][d[1]] = 0\n            table[d[1]][d[0]] = 0\n\n    def find_dominoes(table):\n        dominoes = []\n        for i in range(n):\n            for j in range(n):\n                if table[i][j] == 0:\n                    continue\n                for d in dominoes:\n                    if i == d[0] or i == d[1] or j == d[0] or j == d[1]:\n                        continue\n                dominoes.append((i, j))\n        return dominoes\n\n    dominoes = find_dominoes(table)\n    domino_cover(table, dominoes)\n    domino_sum_before = domino_sum(table, dominoes)\n\n    while k > 0:\n        dominoes = find_dominoes(table)\n        if not is_valid(table, dominoes):\n            break\n        domino_cover(table, dominoes)\n        k -= 1\n\n    domino_sum_after = domino_sum(table, dominoes)\n    return str(domino_sum_after)"
    },
    {
        "number": 3329,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    pebbles = list(stdin.strip())\n    pebbles.reverse()\n    pebbles = ''.join(pebbles)\n\n    def count_circles(pebbles: str) -> int:\n        pebbles = list(pebbles)\n        pebbles.reverse()\n        pebbles = ''.join(pebbles)\n        count = 0\n        for i in range(len(pebbles) - n + 1):\n            if pebbles[i:i + n] == pebbles[i + n:i + 2 * n]:\n                count += 1\n        return count\n\n    def count_distinct_circles(pebbles: str) -> int:\n        return len(set(count_circles(pebbles)))\n\n    def transform(pebbles: str) -> str:\n        pebbles = list(pebbles)\n        for i in range(len(pebbles) - n + 1):\n            if pebbles[i:i + n] == pebbles[i + n:i + 2 * n]:\n                pebbles[i:i + n] = pebbles[i + n:i + 2 * n] = 'B'\n        return ''.join(pebbles)\n\n    def count_transformations(pebbles: str) -> int:\n        count = 0\n        while transform(pebbles)!= pebbles:\n            count += 1\n        return count\n\n    def count_starting_circles(pebbles: str) -> int:\n        count = 0\n        for _ in range(k):\n            count += count_transformations(pebbles)\n        return count\n\n    return str(count_distinct_circles(pebbles))"
    },
    {
        "number": 3330,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, *a, *c = map(int, stdin.split())\n    a = [a[i:i+l] for i in range(0, len(a), l)]\n    c = [c[i:i+l] for i in range(0, len(c), l)]\n    a = [sum(a[i]) for i in range(len(a))]\n    c = [sum(c[i]) for i in range(len(c))]\n    p1 = min(a) / n\n    p2 = min(c) / n\n    return f\"{p1:.3f}\""
    },
    {
        "number": 3331,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n    cow_positions = [A, B]\n    horse_position = P\n    cow_positions.append(horse_position)\n    cow_positions.sort()\n    cow_positions = list(set(cow_positions))\n    cow_positions.sort()\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions.append(L)\n    cow_positions."
    },
    {
        "number": 3332,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    streams = []\n    for i in range(n):\n        s, d, p = map(int, stdin.split()[1:])\n        streams.append((s, d, p))\n    streams.sort(key=lambda x: (x[2], x[0]))\n    max_priority = 0\n    chosen_streams = []\n    for s, d, p in streams:\n        if not chosen_streams or chosen_streams[-1][2] < p:\n            chosen_streams.append((s, d, p))\n            max_priority = max(max_priority, p)\n        else:\n            break\n    return str(max_priority)"
    },
    {
        "number": 3333,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(float, stdin.split())\n    hiding_spots = []\n    for _ in range(int(stdin.split()[1])):\n        hiding_spots.append(map(float, stdin.split()))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def closest_hiding_spot(x, y):\n        return min(hiding_spots, key=lambda s: distance(s, (x, y)))\n\n    def closest_hiding_spot_distance(x, y):\n        return distance(closest_hiding_spot(x, y), (x, y))\n\n    def closest_hiding_spot_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost(x, y):\n        return distance(closest_hiding_spot(x, y), (x, y))\n\n    def closest_hiding_spot_distance_to_roost_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index(x, y):\n        return hiding_spots.index(closest_hiding_spot(x, y))\n\n    def closest_hiding_spot_distance_to_roost_index_to_closest_hiding_spot_distance_to_roost_index_to_"
    },
    {
        "number": 3334,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    distances = [list(map(int, stdin.split()[1:])) for _ in range(n - 1)]\n\n    def shortest_distance(a: int, b: int) -> int:\n        return min(distances[a - 1][b], distances[b - 1][a])\n\n    def average_shortest_distance() -> float:\n        total_distance = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                total_distance += shortest_distance(i + 1, j + 1)\n        return total_distance / (n * (n - 1) // 2)\n\n    def is_impossible() -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if shortest_distance(i + 1, j + 1) == 0:\n                    return True\n        return False\n\n    if is_impossible():\n        return \"impossible\"\n    else:\n        return str(average_shortest_distance())"
    },
    {
        "number": 3335,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = n - a - b\n            if a**2 + b**2 == c**2:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3336,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pupils = []\n    for _ in range(n):\n        height, gender, preferred_music, favourite_sport = stdin.split()\n        height = int(height)\n        pupils.append((height, gender, preferred_music, favourite_sport))\n    pupils.sort(key=lambda x: (-x[0], x[1], x[2], x[3]))\n    max_count = 0\n    for i in range(n - 1):\n        if pupils[i][0] - pupils[i + 1][0] <= 40 and pupils[i][1] == pupils[i + 1][1] and pupils[i][2]!= pupils[i + 1][2] and pupils[i][3]!= pupils[i + 1][3]:\n            max_count += 1\n    return str(max_count)"
    },
    {
        "number": 3337,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    operations = stdin.split()[1:]\n    stack = [0] * N\n    for operation in operations:\n        if operation[0] == 'a':\n            stack[int(operation[1])] = stack[int(operation[1])] + 1\n        elif operation[0] == 'b':\n            if stack[int(operation[1])]:\n                print(stack[int(operation[1])])\n                stack[int(operation[1])] = 0\n        elif operation[0] == 'c':\n            count = 0\n            for i in range(int(operation[1]), N):\n                if stack[i] in stack[int(operation[2:4])]:\n                    count += 1\n            print(count)\n    return ''"
    },
    {
        "number": 3338,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    partners = []\n    for _ in range(n):\n        g, p, g_a, p_a = map(int, stdin.split())\n        partners.append((g, p, g_a, p_a))\n\n    partners.sort(key=lambda x: (-x[0], -x[1]))\n\n    max_d = 0\n    for i in range(k):\n        max_d = max(max_d, diversity(partners[:i+1]))\n\n    return str(max_d)\n\ndef"
    },
    {
        "number": 3339,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for a, b in map(lambda x: list(map(int, x.split())), stdin.split()[1:].split('\\n')):\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    def dfs(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n    ways = 0\n    for u in range(1, n + 1):\n        if not visited[u]:\n            dfs(u)\n            ways += 1\n    return str((ways % 1000000009))"
    },
    {
        "number": 3340,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    flights = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def find_best_flight(flights, city):\n        return min(flights, key=lambda x: abs(x[0] - city))\n\n    def find_best_new_flight(flights, city):\n        return min(flights, key=lambda x: abs(x[1] - city))\n\n    best_flight_changes = float('inf')\n    best_flight_to_cancel = None\n    best_new_flight_to_add = None\n\n    for i in range(n):\n        flight_to_cancel = find_best_flight(flights, i + 1)\n        new_flight_to_add = find_best_new_flight(flights, i + 1)\n\n        flight_changes = abs(flight_to_cancel[0] - i + 1) + abs(new_flight_to_add[1] - i + 1)\n\n        if flight_changes < best_flight_changes:\n            best_flight_changes = flight_changes\n            best_flight_to_cancel = flight_to_cancel\n            best_new_flight_to_add = new_flight_to_add\n\n    return f\"{best_flight_changes}\\n{best_flight_to_cancel[0]} {best_flight_to_cancel[1]}\\n{best_new_flight_to_add[0]} {best_new_flight_to_add[1]}\""
    },
    {
        "number": 3341,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    producers = []\n    consumers = []\n\n    for i in range(m):\n        p, d = map(int, stdin.split())\n        producers.append((p, d))\n\n    for j in range(n):\n        q, e = map(int, stdin.split())\n        consumers.append((q, e))\n\n    producers.sort(key=lambda x: x[1])\n    consumers.sort(key=lambda x: x[1])\n\n    total_profit = 0\n    for i in range(m):\n        for j in range(n):\n            if producers[i][1] <= consumers[j][1]:\n                total_profit += producers[i][0] - consumers[j][0]\n\n    return str(total_profit)"
    },
    {
        "number": 3342,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    onions = [tuple(map(int, stdin.split())) for _ in range(n)]\n    fence_posts = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def convex_hull(points):\n        points.sort(key=lambda x: x[1])\n        hull = [points[0]]\n        for i in range(1, len(points)):\n            if points[i][1]!= points[i - 1][1]:\n                hull.append(points[i])\n        return hull\n\n    def is_convex(points):\n        return len(points) > 2 and points[0][0] * (points[1][1] - points[2][1]) <= points[1][0] * (points[2][1] - points[0][1])\n\n    def is_convex_hull(points):\n        return is_convex(convex_hull(points))\n\n    def is_on_convex_hull(point, hull):\n        return all(point[0] <= hull[i][0] <= point[0] for i in range(len(hull)))\n\n    def is_on_fence_posts(point, fence_posts):\n        return all(point[0] <= fence_post[0] <= point[0] for fence_post in fence_posts)\n\n    def is_on_convex_hull_and_fence_posts(point, hull, fence_posts):\n        return is_on_convex_hull(point, hull) and is_on_fence_posts(point, fence_posts)\n\n    def count_onions_in_convex_hull_and_fence_posts(hull, fence_posts):\n        return sum(1 for onion in onions if is_on_convex_hull_and_fence_posts(onion, hull, fence_posts))\n\n    hull = convex_hull(fence_posts)\n    max_onions = count_onions_in_convex_hull_and_fence_posts(hull, fence_posts)\n\n    return str(max_onions)"
    },
    {
        "number": 3343,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, n = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y, direction = map(int, stdin.split())\n        points.append((x, y, direction))\n    points.sort(key=lambda x: (x[0], x[1]))\n    for i in range(n):\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            return \"GHOST\"\n    return \"SAFE\""
    },
    {
        "number": 3344,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    x = list(map(float, stdin.split()))\n\n    def find_max_speed(speed: float) -> float:\n        positions = [0] * n\n        for i in range(n):\n            positions[i] = x[i] + speed * (i + 1)\n        positions.sort()\n\n        for i in range(n - 1):\n            if positions[i + 1] - positions[i] > 1:\n                return speed\n\n        return speed\n\n    max_speed = 0\n    for speed in range(1, 11):\n        max_speed = max(max_speed, find_max_speed(speed))\n\n    if max_speed == 0:\n        return \"no fika\"\n    else:\n        return str(max_speed)"
    },
    {
        "number": 3345,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    shadow_walk = list(map(int, stdin.split()))\n    lydia_walk = list(map(int, stdin.split()))\n\n    shadow_x, shadow_y = shadow_walk\n    lydia_x, lydia_y = lydia_walk\n\n    shadow_distance = abs(shadow_x - lydia_x) + abs(shadow_y - lydia_y)\n    lydia_distance = abs(lydia_x - shadow_x) + abs(lydia_y - shadow_y)\n\n    return str(min(shadow_distance, lydia_distance))"
    },
    {
        "number": 3346,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split())\n    cars = []\n    for _ in range(n):\n        direction, arrival, irritation_time = map(int, stdin.split())\n        cars.append((direction, arrival, irritation_time))\n    cars.sort(key=lambda x: x[1])\n    irritated_drivers = 0\n    current_irritation_time = 0\n    for direction, arrival, irritation_time in cars:\n        if direction == 'W':\n            if current_irritation_time + irritation_time <= t:\n                current_irritation_time += irritation_time\n            else:\n                irritated_drivers += 1\n        else:\n            if current_irritation_time + irritation_time <= t:\n                current_irritation_time += irritation_time\n            else:\n                irritated_drivers += 1\n    return str(irritated_drivers)"
    },
    {
        "number": 3347,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    gold_stores = []\n    for i in range(n):\n        t, h = map(int, stdin.split()[1:])\n        gold_stores.append((t, h))\n    gold_stores.sort(key=lambda x: x[0])\n    max_stores = 0\n    current_store = 0\n    current_time = 0\n    current_height = 0\n    for t, h in gold_stores:\n        if current_height < h:\n            current_height = h\n            current_time = t\n            current_store += 1\n            max_stores = max(max_stores, current_store)\n        else:\n            current_time += t\n            current_height += 1\n    return str(max_stores)"
    },
    {
        "number": 3348,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    a, b, c = map(int, stdin.split()[1].split())\n\n    if a + b + c!= R * C:\n        return \"impossible\"\n\n    def is_valid(bonbons: list[str]) -> bool:\n        for i in range(len(bonbons) - 1):\n            if bonbons[i] == bonbons[i + 1]:\n                return False\n        return True\n\n    def find_good_arrangement(bonbons: list[str]) -> str:\n        for i in range(len(bonbons)):\n            for j in range(i + 1, len(bonbons)):\n                if bonbons[i] == bonbons[j]:\n                    return \"impossible\"\n        return \"\".join(bonbons)\n\n    def find_good_arrangements(bonbons: list[str]) -> list[str]:\n        result = []\n        for i in range(len(bonbons)):\n            for j in range(i + 1, len(bonbons)):\n                if bonbons[i] == bonbons[j]:\n                    continue\n                new_bonbons = bonbons[:i] + bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bonbons[:i] + new_bonbons[i + 1:]\n                new_bonbons = new_bonbons[:j] + new_bonbons[j + 1:]\n                new_bonbons = new_bon"
    },
    {
        "number": 3349,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dictionary = set(stdin.split()[1:])\n    message = stdin.split()[n+1]\n\n    def is_vowel(c: str) -> bool:\n        return c in \"AEIOUaeiou\"\n\n    def is_consonant(c: str) -> bool:\n        return not is_vowel(c)\n\n    def reconstruct_message(words: set) -> str:\n        result = []\n        for word in words:\n            result.append(word)\n        return \" \".join(result)\n\n    def count_vowels(word: str) -> int:\n        return sum(1 for c in word if is_vowel(c))\n\n    def count_consonants(word: str) -> int:\n        return sum(1 for c in word if is_consonant(c))\n\n    def reconstruct_no_vowels(words: set) -> str:\n        result = []\n        for word in words:\n            result.append(word)\n        return \" \".join(result)\n\n    def reconstruct_no_vowels_helper(words: set, remaining_words: set) -> str:\n        if not remaining_words:\n            return reconstruct_no_vowels(words)\n\n        word = remaining_words.pop()\n        if is_vowel(word):\n            return reconstruct_no_vowels_helper(words, remaining_words)\n\n        if is_consonant(word):\n            return reconstruct_no_vowels_helper(words, remaining_words)\n\n        if count_vowels(word) == count_consonants(word):\n            return reconstruct_no_vowels_helper(words, remaining_words)\n\n        return reconstruct_no_vowels_helper(words | {word}, remaining_words)\n\n    words = set()\n    for word in dictionary:\n        if is_vowel(word):\n            words.add(word)\n        else:\n            words.add(word[0])\n\n    reconstructed_message = reconstruct_no_vowels_helper(words, set(message))\n    return reconstructed_message"
    },
    {
        "number": 3350,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.lower()\n    power = 0\n    for i in range(len(word)):\n        if i == 0:\n            power += len(word) - i\n        elif i == len(word) - 1:\n            power += len(word) - i\n        else:\n            power += len(word) - i - 1\n    return str(power)"
    },
    {
        "number": 3351,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dice_rolls = [int(x) for x in stdin.split()[1:]]\n    max_score = 0\n    for i in range(1, 14):\n        if i == 1:\n            max_score += sum(dice_rolls[:5])\n        elif i == 2:\n            max_score += sum(dice_rolls[5:10])\n        elif i == 3:\n            max_score += sum(dice_rolls[10:15])\n        elif i == 4:\n            max_score += sum(dice_rolls[15:20])\n        elif i == 5:\n            max_score += sum(dice_rolls[20:])\n        else:\n            max_score += sum(dice_rolls)\n    return str(max_score)"
    },
    {
        "number": 3352,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    def dfs(node, parent, depth):\n        nonlocal count\n        if parent == 0:\n            count += 1\n        for child in range(1, n + 1):\n            if child!= node and p[child] == node:\n                dfs(child, node, depth + 1)\n\n    count = 0\n    for node in range(1, n + 1):\n        dfs(node, 0, 0)\n\n    for _ in range(q):\n        k, x = map(int, stdin.split())\n        if k == 0:\n            print(count)\n        else:\n            c[x] = k\n\n    return \"\\n\".join(map(str, c))\n"
    },
    {
        "number": 3353,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    P, R, L = map(int, stdin.split())\n    edges = []\n    for _ in range(L):\n        endpoints = map(int, stdin.split())\n        edges.append((endpoints[0], endpoints[1]))\n\n    # Create graph\n    graph = [[] for _ in range(R + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Bellman-Ford algorithm\n    dist = [float('inf')] * (R + 1)\n    dist[0] = 0\n    for _ in range(R):\n        for u in range(1, R + 1):\n            for v in graph[u]:\n                if dist[u]!= float('inf') and dist[u] + 1 < dist[v]:\n                    dist[v] = dist[u] + 1\n\n    # Check for negative cycles\n    for u in range(1, R + 1):\n        for v in graph[u]:\n            if dist[u]!= float('inf') and dist[u] + 1 < dist[v]:\n                return \"IMPOSSIBLE\"\n\n    # Find minimum time\n    min_time = float('inf')\n    for u in range(1, R + 1):\n        if dist[u]!= float('inf'):\n            min_time = min(min_time, dist[u])\n\n    # Find left behind\n    left_behind = 0\n    for u in range(1, R + 1):\n        if dist[u] == float('inf'):\n            left_behind += 1\n\n    # Print result\n    if left_behind == 0:\n        return str(min_time)\n    else:\n        return str(left_behind)"
    },
    {
        "number": 3354,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sandwich_radius, pickle_radius, n, z = map(float, stdin.split())\n    area = 2 * sandwich_radius * sandwich_radius\n    max_pickles = int(area * z / (pickle_radius * pickle_radius))\n    return str(max_pickles)"
    },
    {
        "number": 3355,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    p, t, d = map(int, stdin.split())\n    graph = [[] for _ in range(n + 3)]\n    for i in range(n + 2):\n        for j in range(n + 2):\n            if i!= j:\n                graph[i].append((j, int(stdin.split()[i * (n + 2) + j])))\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (n + 3)\n        dist[start] = 0\n        for _ in range(n - 1):\n            for i in range(n + 3):\n                for j in graph[i]:\n                    if dist[i]!= float('inf') and dist[i] + j[1] < dist[j[0]]:\n                        dist[j[0]] = dist[i] + j[1]\n        return dist[n + 2]\n\n    def dfs(start: int, visited: set) -> int:\n        visited.add(start)\n        if start == n + 2:\n            return 0\n        total_points = 0\n        for i in graph[start]:\n            if i[0] not in visited:\n                total_points += dfs(i[0], visited)\n        return total_points\n\n    def is_valid(start: int, end: int) -> bool:\n        return bellman_ford(start) <= T and bellman_ford(end) <= T\n\n    def is_valid_task(start: int, end: int, task: int) -> bool:\n        return is_valid(start, end) and (d[task] == -1 or bellman_ford(start) - bellman_ford(end) <= d[task])\n\n    def find_max_points(start: int, end: int) -> int:\n        visited = set()\n        max_points = 0\n        for i in range(n + 3):\n            if i!= start and i!= end:\n                if is_valid_task(start, end, i):\n                    max_points = max(max_points, dfs(i, visited))\n        return max_points\n\n    max_points = find_max_points(n + 1, n + 2)\n    if max_points == 0:\n        print(0)\n    else:\n        tasks = []\n        for i in range(n + 3):\n            if i!= n + 2:\n                if is_valid_task(n + 1, n + 2, i):\n                    tasks.append(i)\n        tasks.sort()\n        print(max_points)\n        print(' '.join(map(str, tasks)))"
    },
    {
        "number": 3356,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    connections = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def reconstruct(rooms: List[int], closed_tunnel: int, open_rooms: List[int]) -> int:\n        if len(rooms) == 1:\n            return 0\n\n        min_distance = float('inf')\n        for tunnel in range(closed_tunnel + 1):\n            for open_room in open_rooms:\n                distance = reconstruct(rooms[1:], tunnel, open_rooms) + tunnel + 1\n                min_distance = min(min_distance, distance)\n\n        return min_distance\n\n    min_distance = reconstruct(list(range(1, n + 1)), 0, [])\n    min_rooms = []\n    for tunnel in range(min_distance):\n        min_rooms.append(tunnel + 1)\n\n    return str(min_distance) + '\\n' +''.join(map(str, min_rooms)) + '\\n' +''.join(map(str, min_rooms[::-1])) + '\\n'"
    },
    {
        "number": 3357,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    buildings = []\n    for _ in range(n):\n        x, h = map(int, stdin.split()[1:])\n        buildings.append((x, h))\n    buildings.sort(key=lambda x: x[0])\n    result = []\n    for i, (x, h) in enumerate(buildings):\n        if i == 0:\n            result.append(h * 180)\n        else:\n            result.append(result[-1] + h * 180)\n    return''.join(map(str, result))"
    },
    {
        "number": 3358,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    instructions = []\n\n    def push(reg: str) -> None:\n        instructions.append(f\"PH {reg}\")\n\n    def pop(reg: str) -> None:\n        instructions.append(f\"PL {reg}\")\n\n    def add() -> None:\n        instructions.append(\"AD\")\n\n    def zero(reg: str) -> None:\n        instructions.append(f\"ZE {reg}\")\n\n    def one(reg: str) -> None:\n        instructions.append(f\"ST {reg}\")\n\n    def display(reg: str) -> None:\n        instructions.append(f\"DI {reg}\")\n\n    stack = []\n    registers = {\"A\": 0, \"X\": 0, \"Y\": 0}\n\n    for _ in range(N):\n        command, arg = stdin.split()\n        arg = int(arg)\n\n        if command == \"PH\":\n            push(arg)\n        elif command == \"PL\":\n            pop(arg)\n        elif command == \"AD\":\n            add()\n        elif command == \"ZE\":\n            zero(arg)\n        elif command == \"ST\":\n            one(arg)\n        elif command == \"DI\":\n            display(arg)\n        else:\n            raise ValueError(\"Invalid command\")\n\n    return \"\\n\".join(instructions)\n"
    },
    {
        "number": 3359,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, C = map(int, stdin.split())\n    L = [list(map(int, stdin.split())) for _ in range(R)]\n\n    def count_stars(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if 0 <= i < R and 0 <= j < C:\n                    count += L[i][j]\n        return count\n\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if count_stars(i, j) > 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3360,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rules = []\n    for line in stdin.split('\\n')[1:]:\n        if line:\n            rule = line.split('->')\n            if len(rule) == 2:\n                rules.append(tuple(rule[0].split()))\n    grammar = tuple(rules)\n    text = stdin.split('\\n')[1].strip()\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_substrings(s: str) -> list[str]:\n        result = []\n        for i in range(1, len(s) + 1):\n            result.extend(s[:i])\n        return result\n\n    def generate_substrings_with_grammar(s: str) -> list[str]:\n        result = []\n        for rule in grammar:\n            for production in rule:\n                if production in s:\n                    result.append(s.replace(production, '', 1))\n        return result\n\n    def find_longest_palindrome(s: str) -> str:\n        max_length = 0\n        max_substring = ''\n        for substring in generate_substrings(s):\n            if is_palindrome(substring) and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n        return max_substring\n\n    def find_longest_palindrome_with_grammar(s: str) -> str:\n        max_length = 0\n        max_substring = ''\n        for substring in generate_substrings_with_grammar(s):\n            if is_palindrome(substring) and len(substring) > max_length:\n                max_length = len(substring)\n                max_substring = substring\n        return max_substring\n\n    longest_palindrome = find_longest_palindrome(text)\n    longest_palindrome_with_grammar = find_longest_palindrome_with_grammar(text)\n\n    return f'{longest_palindrome}\\n{longest_palindrome_with_grammar}\\n'"
    },
    {
        "number": 3361,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    distances = [list(map(int, stdin.split()[1:])) for _ in range(n - 1)]\n    distances.append([0] * n)\n    distances.append([0] * n)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            distances[i][j] = distances[j][i] = distances[i][i] = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            distances[i][j] = min(distances[i][j], distances[i][j - 1] + distances[j][j - 1])\n            distances[i][j] = min(distances[i][j], distances[i - 1][j] + distances[i - 1][j - 1])\n            distances[i][j] = min(distances[i][j], distances[i - 1][j - 1] + distances[i - 1][j])\n\n    return str(distances[0][n - 1] + distances[n - 1][0])\n"
    },
    {
        "number": 3362,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, F, L, W = map(int, stdin.split())\n    map_ = []\n    for _ in range(L):\n        line = stdin.readline().strip()\n        map_.append(line)\n\n    start = map_.index('S')\n    goal = map_.index('G')\n\n    def is_safe(x, y):\n        return map_[x][y] == 'W'\n\n    def is_lava(x, y):\n        return map_[x][y] == 'B'\n\n    def is_valid(x, y, dx, dy):\n        return 0 <= x + dx < L and 0 <= y + dy < W and is_safe(x + dx, y + dy)\n\n    def is_valid_move(x, y, dx, dy):\n        return is_valid(x, y, dx, dy) and not is_lava(x + dx, y + dy)\n\n    def is_valid_move_elsa(x, y, dx, dy):\n        return is_valid_move(x, y, dx, dy) and (x + dx, y + dy) not in visited\n\n    def is_valid_move_father(x, y, dx, dy):\n        return is_valid_move(x, y, dx, dy) and (x + dx, y + dy) not in visited_father\n\n    def is_valid_move_elsa_father(x, y, dx, dy):\n        return is_valid_move_elsa(x, y, dx, dy) and is_valid_move_father(x, y, dx, dy)\n\n    def is_valid_move_elsa_father_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited\n\n    def is_valid_move_elsa_father_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited_visited_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited_visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited_visited_visited(x, y, dx, dy):\n        return is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited_visited_visited(x, y, dx, dy) and (x + dx, y + dy) not in visited_visited_visited_visited_visited_visited_visited_visited_visited\n\n    def is_valid_move_elsa_father_visited_visited_visited_visited_visited_visited_visited_visited"
    },
    {
        "number": 3363,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    courses = list(map(int, stdin.split()))\n\n    max_calories = 0\n    for i in range(1, n + 1):\n        if i == 1:\n            max_calories += courses[0]\n        else:\n            max_calories += courses[i - 1] * 2\n\n    return str(max_calories)"
    },
    {
        "number": 3364,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    base_set = list(range(n))\n    sets = [set(base_set)]\n\n    for _ in range(q):\n        operation, a, b = stdin.split()\n        if operation == \"=\":\n            sets.append(sets[-1].union(set(base_set[a:b+1])))\n        elif operation == \"?\":\n            if sets[-1].issubset(set(base_set[a:b+1])):\n                print(\"yes\")\n            else:\n                print(\"no\")\n\n    return \"\""
    },
    {
        "number": 3365,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def max_prime(v: list) -> int:\n        max_num = max(v)\n        for num in v:\n            if num % max_num == 0 and is_prime(num // max_num):\n                return num // max_num\n        return 0\n\n    def score(v: list) -> int:\n        max_prime_sum = 0\n        for i in range(k):\n            max_prime_sum += max_prime(v[i * (n // k):(i + 1) * (n // k)])\n        return min(max_prime_sum, 0)\n\n    max_score = 0\n    for i in range(n):\n        max_score = max(max_score, score(v[:i] + v[i + 1:]))\n\n    return str(max_score)\n"
    },
    {
        "number": 3366,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    prime = 2\n    while True:\n        if prime * prime > R:\n            break\n        prime += 1\n\n    def f(x: int) -> int:\n        iterations = 0\n        while x!= 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x += 1\n            iterations += 1\n        return iterations\n\n    def sum_f(l: int, r: int) -> int:\n        return sum(f(x) for x in range(l, r + 1))\n\n    return str((sum_f(L, R) % MOD) % prime)"
    },
    {
        "number": 3367,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split())\n    questions = []\n    for _ in range(n):\n        question, answer = stdin.split()\n        questions.append((question, answer))\n\n    def is_valid_answer(question, answer):\n        words = question.split()\n        for i in range(len(words) - 1):\n            if words[i] == words[i + 1]:\n                return False\n        return True\n\n    def score(question, answer):\n        if is_valid_answer(question, answer):\n            return 1\n        return 0\n\n    def optimal_strategy(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n        return best_answer\n\n    def optimal_strategy_with_penalty(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption(questions):\n        best_score = 0\n        best_answer = \"\"\n        for question, answer in questions:\n            score = score(question, answer)\n            if score > best_score:\n                best_score = score\n                best_answer = answer\n            elif score == best_score:\n                best_score += 1\n        return best_answer\n\n    def optimal_strategy_with_penalty_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption_and_interruption_and"
    },
    {
        "number": 3368,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    enclosures = []\n    for _ in range(n):\n        enclosure = stdin.split()\n        animal_type, num_animals = enclosure[0], int(enclosure[1])\n        animals = enclosure[2:]\n        enclosures.append((animal_type, num_animals, animals))\n\n    def backtrack(enclosure_idx, animal_idx, visited):\n        if animal_idx == m:\n            return True\n\n        if visited[animal_idx]:\n            return False\n\n        visited[animal_idx] = True\n\n        if enclosures[enclosure_idx][1] == 0:\n            return backtrack(enclosure_idx + 1, animal_idx + 1, visited)\n\n        if enclosures[enclosure_idx][2][animal_idx] == enclosures[enclosure_idx][0]:\n            return backtrack(enclosure_idx, animal_idx + 1, visited)\n\n        return backtrack(enclosure_idx, animal_idx + 1, visited)\n\n    visited = [False] * m\n    for enclosure_idx in range(n):\n        if backtrack(enclosure_idx, 0, visited):\n            return \"POSSIBLE\"\n\n    return \"FALSE ALARM\""
    },
    {
        "number": 3369,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.split()[0])\n    sequence = stdin.split()[1:]\n    sequence = [int(digit) for digit in sequence]\n\n    def find_correlations(sequence):\n        correlations = []\n        for i in range(len(sequence) - 2):\n            for j in range(i + 3, len(sequence) - 1):\n                for k in range(j + 2, len(sequence)):\n                    if sequence[i] == 4 and sequence[j] == 4 and sequence[k] == 3:\n                        correlations.append((i, j, k))\n        return correlations\n\n    correlations = find_correlations(sequence)\n    if not correlations:\n        return \"random sequence\"\n\n    correlations.sort(key=lambda x: (x[0], x[1], x[2]))\n    correlation = correlations[0]\n    return f\"triple correlation {sequence[correlation[0]]:d}({sequence[correlation[0] - 1]:d})4({sequence[correlation[1] - 1]:d})4({sequence[correlation[2] - 1]:d})3 found\"\n"
    },
    {
        "number": 3370,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    h = list(map(float, stdin.split()))\n\n    def remodel(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k\n\n    def max_height(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return max(h[i - 1], h[i + 1])\n\n    def max_height_after_remodeling(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return max(h[i - 1], h[i + 1]) + k\n\n    def height_after_remodeling(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2\n\n    def height_after_remodeling_with_k(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k\n\n    def height_after_remodeling_with_k_and_max_height(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling_with_k(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling_with_k(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling_with_k_and_max_height(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height_after_remodeling(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling_with_k_and_max_height_after_remodeling(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height_after_remodeling_with_k(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling_with_k_and_max_height_after_remodeling_with_k(i)\n\n    def height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height(i: int) -> float:\n        if i == 1 or i == N:\n            return 0\n        else:\n            return (h[i - 1] + h[i + 1]) / 2 + k + max_height_after_remodeling_with_k_and_max_height_after_remodeling_with_k_and_max_height(i)"
    },
    {
        "number": 3371,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    pairs = []\n    for _ in range(c):\n        a, b, y = map(int, stdin.split())\n        pairs.append((a, b, y))\n\n    def is_valid(pairs: List[Tuple[int, int, int]], year: int) -> bool:\n        first_part = [pair for pair in pairs if pair[2] < year]\n        second_part = [pair for pair in pairs if pair[2] >= year]\n        return len(first_part) <= 2 * n / 3 and len(second_part) <= 2 * n / 3\n\n    for year in range(1948, 2008):\n        if is_valid(pairs, year):\n            return str(year)\n\n    return \"Impossible\""
    },
    {
        "number": 3372,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    flights = [[] for _ in range(n)]\n    for i in range(n):\n        line = stdin.split()\n        if line[0] == 'N':\n            flights[i] = list(map(int, line[1].split()))\n        elif line[0] == 'C':\n            flights[i] = list(map(int, line[1].split()))\n\n    def dfs(i, path, visited):\n        if i == t:\n            return 1\n        if i in visited:\n            return 0\n        visited.add(i)\n        res = 0\n        for j in flights[i]:\n            if j not in visited:\n                res += dfs(j, path + [j], visited)\n        return res\n\n    if dfs(s, [s], set()) == 0:\n        return \"impossible\"\n    return str(dfs(t, [t], set()))"
    },
    {
        "number": 3373,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pieces = [stdin.split()[1]]\n    for _ in range(n - 1):\n        pieces.append(stdin.split()[1])\n    max_length = 0\n    for i in range(1, len(pieces) + 1):\n        for j in range(len(pieces) - i + 1):\n            current_length = 0\n            for k in range(j, j + i):\n                current_length += len(pieces[k])\n            if current_length > max_length:\n                max_length = current_length\n    return str(max_length)"
    },
    {
        "number": 3374,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    systems = [tuple(map(int, stdin.split())) for _ in range(n)]\n    links = [tuple(map(int, stdin.split())) for _ in range(e)]\n\n    def find_gravity(system: tuple) -> int:\n        return system[0]\n\n    def find_type(system: tuple) -> str:\n        return system[1]\n\n    def find_distance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return abs(g1 - g2)\n        elif d1 == 'a' and d2 == 'h':\n            return abs(g1 - g2)\n        else:\n            return abs(g1 - g2)\n\n    def find_capacitance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 + g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 + g1\n        else:\n            return g2 + g1\n\n    def find_potential(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 - g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 - g1\n        else:\n            return g2 - g1\n\n    def find_inductance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 * g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 * g1\n        else:\n            return g2 * g1\n\n    def find_gravity_dispersal(system: tuple) -> int:\n        g, d = system\n        if d == 'h':\n            return 1\n        else:\n            return 0\n\n    def find_gravity_dispersal_distance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return abs(g1 - g2)\n        elif d1 == 'a' and d2 == 'h':\n            return abs(g1 - g2)\n        else:\n            return abs(g1 - g2)\n\n    def find_gravity_dispersal_capacitance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 + g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 + g1\n        else:\n            return g2 + g1\n\n    def find_gravity_dispersal_potential(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 - g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 - g1\n        else:\n            return g2 - g1\n\n    def find_gravity_dispersal_inductance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return g2 * g1\n        elif d1 == 'a' and d2 == 'h':\n            return g2 * g1\n        else:\n            return g2 * g1\n\n    def find_gravity_dispersal_distance_capacitance(system1: tuple, system2: tuple) -> int:\n        g1, d1 = system1\n        g2, d2 = system2\n\n        if d1 == 'h' and d2 == 'a':\n            return abs(g1 - g2) + g2 + g1\n        elif d1 == 'a' and d2 == 'h':\n            return abs(g1 - g2) + g2 + g1\n        else:"
    },
    {
        "number": 3375,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) == 1:\n                    return 1\n        return 0\n\n    def count_spanning_subgraphs(graph: List[List[int]]) -> int:\n        n = len(graph)\n        count = 0\n        for u in range(n):\n            visited = set()\n            if dfs(u, visited) == 1:\n                count += 1\n        return count\n\n    def read_input() -> Tuple[int, List[List[int]]]:\n        n, m = map(int, stdin.split())\n        graph = [[] for _ in range(n)]\n        for _ in range(m):\n            a, b = map(int, stdin.split())\n            graph[a - 1].append(b - 1)\n            graph[b - 1].append(a - 1)\n        return n, graph\n\n    n, graph = read_input()\n    count = count_spanning_subgraphs(graph)\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3376,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_family(name: str) -> tuple:\n        return tuple(map(int, name.split()))\n\n    def get_candies(name: str) -> int:\n        return int(name.split()[1])\n\n    def get_strongest(name: str) -> str:\n        return name.split()[2]\n\n    def get_time(name: str) -> int:\n        return int(name.split()[0])\n\n    def get_name(name: str) -> str:\n        return name.split()[3]\n\n    def get_family_chain(name: str) -> list:\n        family = get_family(name)\n        return [get_strongest(name) for _ in range(family[0])]\n\n    def get_evolution_cost(family_chain: list) -> int:\n        return sum(1 for _ in range(len(family_chain) - 1))\n\n    def get_evolution_time(family_chain: list) -> int:\n        return 1800 * (len(family_chain) - 1)\n\n    def get_evolution_xp(family_chain: list) -> int:\n        return 500 * (len(family_chain) - 1)\n\n    def get_xp(candies: int, evolution_xp: int) -> int:\n        return candies * 3 + evolution_xp\n\n    def get_max_xp(families: list) -> int:\n        max_xp = 0\n        for family in families:\n            max_xp += get_xp(get_candies(family[1]), get_evolution_xp(get_family_chain(family[1])))\n        return max_xp\n\n    def get_time_to_activate_egg(families: list) -> int:\n        return min(get_evolution_time(get_family_chain(family[1])) for family in families)\n\n    def get_time_to_catch_nudgemon(families: list) -> int:\n        return min(get_time(family[2]) for family in families)\n\n    def get_time_to_evolution(families: list) -> int:\n        return min(get_evolution_time(get_family_chain(family[1])) for family in families)\n\n    def get_time_to_transfer_nudgemon(families: list) -> int:\n        return min(get_time(family[2]) for family in families)\n\n    def get_time_to_transfer_candies(families: list) -> int:\n        return min(get_time(family[1]) for family in families)\n\n    def get_time_to_activate_egg_and_evolution(families: list) -> int:\n        return min(get_time_to_activate_egg(families), get_time_to_evolution(families))\n\n    def get_time_to_activate_egg_and_transfer_nudgemon(families: list) -> int:\n        return min(get_time_to_activate_egg(families), get_time_to_transfer_nudgemon(families))\n\n    def get_time_to_activate_egg_and_transfer_candies(families: list) -> int:\n        return min(get_time_to_activate_egg(families), get_time_to_transfer_candies(families))\n\n    def get_time_to_catch_nudgemon_and_evolution(families: list) -> int:\n        return min(get_time_to_catch_nudgemon(families), get_time_to_evolution(families))\n\n    def get_time_to_catch_nudgemon_and_transfer_nudgemon(families: list) -> int:\n        return min(get_time_to_catch_nudgemon(families), get_time_to_transfer_nudgemon(families))\n\n    def get_time_to_catch_nudgemon_and_transfer_candies(families: list) -> int:\n        return min(get_time_to_catch_nudgemon(families), get_time_to_transfer_candies(families))\n\n    def get_time_to_catch_nudgemon_and_activate_egg(families: list) -> int:\n        return min(get_time_to_catch_nudgemon(families), get_time_to_activate_egg(families))\n\n    def get_time_to_catch"
    },
    {
        "number": 3377,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    pegs = [[] for _ in range(n + 1)]\n    for i, line in enumerate(stdin.splitlines()[1:], start=1):\n        p, *points = map(int, line.split())\n        pegs[p].extend(points)\n\n    def is_safe(plan: list[int]) -> bool:\n        pegs_used = set()\n        for step in plan:\n            if step > 0:\n                if step not in pegs_used:\n                    return False\n                pegs_used.remove(step)\n            else:\n                pegs_used.add(-step)\n        return True\n\n    dry_plan = [1] * (t + 1)\n    dry_plan[1] = 0\n    dry_plan[2] = 0\n    dry_plan[3] = 0\n    dry_plan[4] = 0\n    dry_plan[5] = 0\n\n    dry_plan_count = 0\n    dry_plan_index = 0\n\n    while dry_plan_index < t:\n        dry_plan_count += 1\n        dry_plan_index += 1\n        dry_plan[dry_plan_index] = dry_plan[dry_plan_index - 1] + 1\n        if dry_plan_index == 5:\n            dry_plan_index = 0\n\n        if is_safe(dry_plan):\n            break\n\n    if dry_plan_count == t:\n        return str(t)\n\n    wet_plan = [1] * (t + 1)\n    wet_plan[1] = 0\n    wet_plan[2] = 0\n    wet_plan[3] = 0\n    wet_plan[4] = 0\n    wet_plan[5] = 0\n\n    wet_plan_count = 0\n    wet_plan_index = 0\n\n    while wet_plan_index < t:\n        wet_plan_count += 1\n        wet_plan_index += 1\n        wet_plan[wet_plan_index] = wet_plan[wet_plan_index - 1] + 1\n        if wet_plan_index == 5:\n            wet_plan_index = 0\n\n        if is_safe(wet_plan):\n            break\n\n    if wet_plan_count == t:\n        return str(t)\n\n    return \"-1\"\n"
    },
    {
        "number": 3378,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m, = map(int, stdin.split())\n    airfares = []\n    for _ in range(m):\n        s, d, t, p = map(str, stdin.split())\n        airfares.append((int(s), int(d), t, int(p)))\n\n    def dfs(i, path, cost):\n        if i == d:\n            return cost\n        if (i, path[-1]) in visited:\n            return visited[(i, path[-1])]\n        visited[(i, path[-1])] = float('inf')\n        for j in range(i + 1, d):\n            if a[i]!= a[j]:\n                visited[(i, path[-1])] = min(visited[(i, path[-1])], dfs(j, path + [a[j]], cost + airfares[i][3]))\n        return visited[(i, path[-1])]\n\n    visited = {}\n    return str(dfs(0, [], 0))"
    },
    {
        "number": 3379,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n    visited = [False] * n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(graph, visited, stack, i)\n    return str(len(stack))\n\ndef"
    },
    {
        "number": 3380,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    cities = [i for i in range(1, N+1)]\n    road_count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            road_count += 1\n    probability = 1 - (1 - 1/N) ** road_count\n    return f\"{probability:.10f}\""
    },
    {
        "number": 3381,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    if N < 3:\n        return \"Error: N must be at least 3.\"\n\n    def is_valid_polygon(vertices):\n        if len(vertices) < 3:\n            return False\n        for i in range(len(vertices) - 1):\n            if vertices[i][0] == vertices[i + 1][0] or vertices[i][1] == vertices[i + 1][1]:\n                return False\n        return True\n\n    def is_valid_lattice_point(x, y):\n        return 0 <= x < 40000000 and 0 <= y < 40000000\n\n    def is_valid_vertex(x, y):\n        return is_valid_lattice_point(x, y) and (x, y) not in vertices\n\n    def is_valid_polygon_order(vertices):\n        for i in range(len(vertices) - 1):\n            if vertices[i][0] * vertices[i + 1][1] > vertices[i + 1][0] * vertices[i][1]:\n                return False\n        return True\n\n    def generate_polygon(vertices):\n        if not is_valid_polygon(vertices):\n            return None\n        if not is_valid_polygon_order(vertices):\n            return None\n        return vertices\n\n    def generate_lattice_points(N):\n        lattice_points = set()\n        while len(lattice_points) < N:\n            x = random.randint(0, 40000000)\n            y = random.randint(0, 40000000)\n            if (x, y) not in lattice_points:\n                lattice_points.add((x, y))\n        return lattice_points\n\n    def generate_vertices(N):\n        lattice_points = generate_lattice_points(N)\n        vertices = []\n        for i in range(N):\n            x, y = random.choice(list(lattice_points))\n            vertices.append((x, y))\n        return vertices\n\n    vertices = generate_vertices(N)\n    polygon = generate_polygon(vertices)\n    if polygon is None:\n        return \"Error: Invalid polygon.\"\n\n    output = \"\"\n    for vertex in polygon:\n        output += f\"{vertex[0]} {vertex[1]}\\n\"\n\n    return output"
    },
    {
        "number": 3382,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    base_values = list(map(int, stdin.split()))\n    base_values.sort()\n    grade = 0\n    for i in range(len(base_values)):\n        for j in range(i + 1, len(base_values)):\n            for k in range(j + 1, len(base_values)):\n                for l in range(k + 1, len(base_values)):\n                    expression = f\"{base_values[i]}*{base_values[j]}-{base_values[k]}*{base_values[l]}+{base_values[l]}*{base_values[i]}-{base_values[j]}*{base_values[k]}-{base_values[i]}*{base_values[l]}\"\n                    if expression == \"24\":\n                        grade = 4\n                    elif expression.count(\"(\") == expression.count(\")\") and expression.count(\"-\") == 0 and expression.count(\"*\") == 2 and expression.count(\"/\") == 0:\n                        grade = 2\n                    elif expression.count(\"(\") == expression.count(\")\") and expression.count(\"-\") == 0 and expression.count(\"*\") == 2 and expression.count(\"/\") == 0:\n                        grade = 2\n                    else:\n                        grade = 0\n                    if grade!= 0:\n                        break\n                if grade!= 0:\n                    break\n            if grade!= 0:\n                break\n    if grade == 0:\n        return \"impossible\"\n    else:\n        return str(grade)"
    },
    {
        "number": 3383,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    tastiness = list(map(int, stdin.split()))\n    u = [[0] * k for _ in range(k)]\n    for i in range(k):\n        for j in range(k):\n            u[i][j] = int(stdin.split())\n\n    tastiness.sort(reverse=True)\n    tastiness_sum = sum(tastiness)\n    max_tastiness = 0\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if tastiness[i] + u[i][j] > tastiness[j]:\n                max_tastiness = max(max_tastiness, tastiness[i] + u[i][j])\n\n    if max_tastiness == 0:\n        return \"0\"\n    else:\n        return str(max_tastiness // a + max_tastiness % a // b)"
    },
    {
        "number": 3384,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N < 10:\n        return str(N)\n\n    def is_handsome(num: int) -> bool:\n        digits = [int(digit) for digit in str(num)]\n        for i in range(len(digits) - 1):\n            if digits[i] % 2 == digits[i + 1] % 2:\n                return False\n        return True\n\n    def closest_handsome(num: int) -> int:\n        if is_handsome(num):\n            return num\n        else:\n            return closest_handsome(num + 1)\n\n    closest_handsome_num = closest_handsome(N)\n    closest_handsome_num_prev = closest_handsome(closest_handsome_num - 1)\n\n    if closest_handsome_num_prev < closest_handsome_num:\n        return f\"{closest_handsome_num} {closest_handsome_num_prev}\"\n    else:\n        return f\"{closest_handsome_num_prev} {closest_handsome_num}\"\n"
    },
    {
        "number": 3385,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    children = []\n    for i in range(n):\n        l, r, x = map(int, stdin.split()[1:])\n        children.append((l, r, x))\n\n    MOD = 10**9 + 7\n\n    def count_ways(l, r, x):\n        if l == 0 and r == 0:\n            return 1\n        if l == 0:\n            return count_ways(r, r, x)\n        if r == 0:\n            return count_ways(l, l, x)\n        if x == 0:\n            return count_ways(l, r, 1)\n        if x == 1:\n            return count_ways(l, r, 0)\n        return 0\n\n    ways = 1\n    for child in children:\n        ways = (ways * count_ways(child[0], child[1], child[2])) % MOD\n\n    return str(ways)"
    },
    {
        "number": 3386,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N * M < 2:\n        return -1\n\n    visited = set()\n    tour = []\n\n    def dfs(i, j):\n        if (i, j) in visited:\n            return\n        visited.add((i, j))\n        tour.append((i, j))\n\n        if len(tour) >= 2:\n            for k in range(len(tour) - 1):\n                if abs(tour[k][0] - tour[k + 1][0]) + abs(tour[k][1] - tour[k + 1][1]) not in [2, 3]:\n                    return\n\n        if i == N - 1 and j == M - 1:\n            return\n        if i < N - 1:\n            dfs(i + 1, j)\n        if j < M - 1:\n            dfs(i, j + 1)\n\n    dfs(0, 0)\n\n    if len(tour) < 2:\n        return -1\n\n    result = []\n    for i in range(len(tour)):\n        result.append(\" \".join(map(str, tour[i])))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3387,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a, b, d = map(int, stdin.split())\n    x = [0] * n\n    y = [0] * n\n\n    for i in range(n):\n        x[i] = a + (b - a) * (t - y[i]) / (d - y[i])\n        y[i] = t * (d - y[i]) / (d - y[i])\n\n    return '\\n'.join(map(str, x))"
    },
    {
        "number": 3388,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    points = [0] + points\n    points.sort(reverse=True)\n    count = 0\n    for i in range(1, n):\n        if points[i] == points[i - 1]:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 3389,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    watch_later = list(stdin.split()[1])\n    click_count = 0\n    current_type = None\n\n    for video in watch_later:\n        if video.islower():\n            if current_type is None:\n                current_type = video\n            elif current_type!= video:\n                click_count += 1\n                current_type = video\n\n    return str(click_count)"
    },
    {
        "number": 3390,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dishes = list(range(1, n+1))\n    menu = []\n\n    for a, b in map(lambda x: list(map(int, x.split())), stdin.split('\\n')[1:m+1]):\n        if b in dishes:\n            dishes.remove(b)\n            menu.append(b)\n\n    return str(len(menu))"
    },
    {
        "number": 3391,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    houses = [tuple(map(int, stdin.split())) for _ in range(n)]\n    requests = [(a, b) for _ in range(q)]\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_valid(house, zone):\n        return distance(house, zone[0]) <= 1 and distance(house, zone[1]) <= 1\n\n    def find_zone(houses, zone):\n        min_size = float('inf')\n        for i in range(len(houses)):\n            if i == zone[0] - 1 or i == zone[1] - 1:\n                continue\n            if is_valid(houses[i], zone):\n                min_size = min(min_size, distance(houses[i], zone[0]))\n                min_size = min(min_size, distance(houses[i], zone[1]))\n        return min_size\n\n    result = []\n    for a, b in requests:\n        zone = (houses[a - 1], houses[b - 1])\n        result.append(str(find_zone(houses, zone)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3392,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    forest = []\n    for i in range(N):\n        forest.append(list(map(int, stdin.split()[1:])))\n\n    heights = [forest[0][0]]\n    for row in forest:\n        heights.append(row[0] + heights[-1])\n\n    growth_speeds = [forest[0][0]]\n    for row in forest:\n        growth_speeds.append(row[0] + growth_speeds[-1])\n\n    max_height = max(heights)\n    max_growth_speed = max(growth_speeds)\n\n    connected_groups = []\n    for i in range(1, N):\n        for j in range(1, N):\n            if forest[i][j] == 1:\n                if forest[i - 1][j] == 1 and forest[i][j - 1] == 1:\n                    connected_groups.append((i, j))\n\n    max_connected_group_size = 0\n    for group in connected_groups:\n        group_heights = [heights[group[0]], heights[group[1]]]\n        group_growth_speeds = [growth_speeds[group[0]], growth_speeds[group[1]]]\n        for i in range(2, len(group)):\n            group_heights.append(heights[group[i]] + group_heights[-1])\n            group_growth_speeds.append(growth_speeds[group[i]] + group_growth_speeds[-1])\n\n        max_group_height = max(group_heights)\n        max_group_growth_speed = max(group_growth_speeds)\n\n        if max_group_height == max_height and max_group_growth_speed == max_growth_speed:\n            max_connected_group_size = max(max_connected_group_size, len(group))\n\n    return str(max_connected_group_size)"
    },
    {
        "number": 3393,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    courses = {}\n    for i in range(1, n + 1):\n        name, difficulty = stdin.split()\n        if name[-1] == '1':\n            courses[name] = (difficulty, 'I')\n        elif name[-1] == '2':\n            courses[name] = (difficulty, 'II')\n        else:\n            courses[name] = (difficulty, None)\n\n    min_sum = float('inf')\n    for i in range(1, k + 1):\n        taken_courses = set()\n        for course, (difficulty, level) in courses.items():\n            if i <= len(taken_courses) or (level == 'I' and course not in taken_courses) or (level == 'II' and course in taken_courses):\n                continue\n            taken_courses.add(course)\n            min_sum = min(min_sum, difficulty)\n\n    return str(min_sum)"
    },
    {
        "number": 3394,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        roads[u].append((v, d))\n        roads[v].append((u, d))\n\n    k = int(stdin.split()[1])\n    orders = []\n    for _ in range(k):\n        s, u, t = map(int, stdin.split())\n        orders.append((s, u, t))\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(1, n + 1):\n                for v, d in roads[u]:\n                    if dist[u] + d < dist[v]:\n                        dist[v] = dist[u] + d\n        return dist[n]\n\n    def min_time(start: int) -> int:\n        dist = bellman_ford(start)\n        min_time = float('inf')\n        for u in range(1, n + 1):\n            for v, d in roads[u]:\n                if dist[u] + d < dist[v]:\n                    min_time = min(min_time, dist[u] + d)\n        return min_time\n\n    return str(min_time(1))\n"
    },
    {
        "number": 3395,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    ore_cells = set(map(int, stdin.split()))\n    coal_cells = set(map(int, stdin.split()))\n    ore_cells.remove(1)\n    coal_cells.remove(1)\n    if len(ore_cells) < m or len(coal_cells) < k:\n        return \"impossible\"\n    ore_cells = sorted(ore_cells)\n    coal_cells = sorted(coal_cells)\n    visited = set()\n    queue = [(1, 0)]\n    while queue:\n        cell, steps = queue.pop(0)\n        if cell in visited:\n            continue\n        visited.add(cell)\n        if cell in ore_cells and cell in coal_cells:\n            return steps\n        if cell in ore_cells:\n            for neighbour in range(1, n + 1):\n                if neighbour not in visited and neighbour in ore_cells:\n                    queue.append((neighbour, steps + 1))\n        if cell in coal_cells:\n            for neighbour in range(1, n + 1):\n                if neighbour not in visited and neighbour in coal_cells:\n                    queue.append((neighbour, steps + 1))\n    return \"impossible\""
    },
    {
        "number": 3396,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    posts = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1].split())\n        posts.append((x, y))\n    max_rope = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if posts[i][0] < posts[j][0] and posts[i][1] < posts[j][1]:\n                max_rope = max(max_rope, abs(posts[i][0] - posts[j][0]) + abs(posts[i][1] - posts[j][1]))\n    return f\"{max_rope:.2f}\""
    },
    {
        "number": 3397,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    bowls = [list(map(int, stdin.split())) for _ in range(m)]\n    dogs = [[] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            dogs[i].append(bowls[j][i])\n\n    t = [0] * n\n    for i in range(n):\n        t[i] = max(t[i], sum(dog))\n\n    return str(sum(t))"
    },
    {
        "number": 3398,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_r, n_c, n, m = map(int, stdin.split())\n    icons = []\n    for _ in range(n + m):\n        row, col = map(int, stdin.split())\n        icons.append((row, col))\n\n    def is_in_box(icon, box):\n        return icon[0] >= box[0] and icon[0] <= box[2] and icon[1] >= box[1] and icon[1] <= box[3]\n\n    def move_icons(icons, box):\n        moved_icons = []\n        for icon in icons:\n            if is_in_box(icon, box):\n                moved_icons.append((icon[0] - box[0], icon[1] - box[1]))\n            else:\n                moved_icons.append(icon)\n        return moved_icons\n\n    def count_icons(icons):\n        return len(icons)\n\n    def min_moves(icons):\n        min_moves = 0\n        for i in range(len(icons)):\n            for j in range(i + 1, len(icons)):\n                if is_in_box(icons[i], icons[j]):\n                    min_moves += 1\n        return min_moves\n\n    def delete_icons(icons):\n        for i in range(len(icons)):\n            for j in range(i + 1, len(icons)):\n                if is_in_box(icons[i], icons[j]):\n                    icons.remove(icons[j])\n                    break\n\n    def move_icons_and_delete(icons, box):\n        moved_icons = move_icons(icons, box)\n        delete_icons(moved_icons)\n        return count_icons(moved_icons)\n\n    box = tuple(map(int, stdin.split()))\n    min_moves = move_icons_and_delete(icons, box)\n    return str(min_moves)"
    },
    {
        "number": 3399,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(map(int, line.strip())) for line in stdin.splitlines()]\n\n    def dfs(i, j, visited):\n        if (i, j) in visited:\n            return\n        visited.add((i, j))\n\n        if grid[i][j] == 1:\n            grid[i][j] = 2\n            dfs(i - 1, j, visited)\n            dfs(i + 1, j, visited)\n            dfs(i, j - 1, visited)\n            dfs(i, j + 1, visited)\n        else:\n            dfs(i - 1, j, visited)\n            dfs(i + 1, j, visited)\n            dfs(i, j - 1, visited)\n            dfs(i, j + 1, visited)\n\n    for i in range(n):\n        for j in range(m):\n            visited = set()\n            dfs(i, j, visited)\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                print(\"A\", end=\"\")\n            elif grid[i][j] == 2:\n                print(\"B\", end=\"\")\n            else:\n                print(\".\", end=\"\")\n        print()\n\n    return \"\""
    },
    {
        "number": 3400,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, r, t = map(int, stdin.split())\n    trips = []\n    for _ in range(t):\n        d, p = map(int, stdin.split())\n        a = list(map(int, stdin.split()))\n        trips.append((d, p, a))\n\n    def shortest_time(a, r, trips):\n        visited = set()\n        queue = [(a, 0)]\n        while queue:\n            location, time = queue.pop(0)\n            if location == r:\n                return time\n            visited.add(location)\n            for next_location in trips[location - 1][2]:\n                if next_location not in visited:\n                    queue.append((next_location, time + 1))\n        return -1\n\n    return str(shortest_time(a, r, trips))"
    },
    {
        "number": 3401,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t, q = map(int, stdin.split())\n    hills = [tuple(map(int, stdin.split())) for _ in range(n)]\n    springs = [tuple(map(int, stdin.split())) for _ in range(s)]\n    towns = [tuple(map(int, stdin.split())) for _ in range(t)]\n\n    def bfs(start: tuple, visited: set) -> int:\n        queue = [(start, 0)]\n        while queue:\n            current, distance = queue.pop(0)\n            if current in visited:\n                continue\n            visited.add(current)\n            if current == end:\n                return distance\n            for neighbor in [(current[0] - 1, current[1]), (current[0] + 1, current[1]), (current[0], current[1] - 1), (current[0], current[1] + 1)]:\n                if 0 <= neighbor[0] < n and 0 <= neighbor[1] < n and abs(neighbor[0] - end[0]) + abs(neighbor[1] - end[1]) <= q and (neighbor[0], neighbor[1]) not in visited:\n                    queue.append((neighbor, distance + 1))\n        return float('inf')\n\n    def find_spring(hill: tuple) -> int:\n        for i, h in enumerate(hills):\n            if h == hill:\n                return i\n        return -1\n\n    def find_town(hill: tuple) -> int:\n        for i, h in enumerate(hills):\n            if h == hill:\n                return i\n        return -1\n\n    def find_distance(start: tuple, end: tuple) -> int:\n        visited = set()\n        return bfs(start, visited)\n\n    def find_min_distance(towns: list) -> float:\n        min_distance = float('inf')\n        for town in towns:\n            spring_index = find_spring(town)\n            town_index = find_town(town)\n            if spring_index!= -1 and town_index!= -1:\n                distance = find_distance(hills[spring_index], hills[town_index])\n                min_distance = min(min_distance, distance)\n        return min_distance\n\n    min_distance = find_min_distance(towns)\n    return str(min_distance)"
    },
    {
        "number": 3402,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T_a, T_b, T_c, T_d, T_e, T_f, T_g, T_h, T_i, T_j, T_k, T_l, T_m, T_n, T_o, T_p, T_q, T_r, T_s, T_t, T_u, T_v, T_w, T_x, T_y, T_z = stdin.split()\n    K, M = map(int, stdin.split())\n    m = list(map(int, stdin.split()))\n\n    def f(s: str) -> str:\n        return ''.join(T_a if c.islower() else T_b for c in s)\n\n    def g(s: str) -> str:\n        return ''.join(T_c if c.islower() else T_d for c in s)\n\n    def h(s: str) -> str:\n        return ''.join(T_e if c.islower() else T_f for c in s)\n\n    def i(s: str) -> str:\n        return ''.join(T_g if c.islower() else T_h for c in s)\n\n    def j(s: str) -> str:\n        return ''.join(T_i if c.islower() else T_j for c in s)\n\n    def k(s: str) -> str:\n        return ''.join(T_k if c.islower() else T_l for c in s)\n\n    def l(s: str) -> str:\n        return ''.join(T_m if c.islower() else T_n for c in s)\n\n    def m(s: str) -> str:\n        return ''.join(T_o if c.islower() else T_p for c in s)\n\n    def n(s: str) -> str:\n        return ''.join(T_q if c.islower() else T_r for c in s)\n\n    def o(s: str) -> str:\n        return ''.join(T_s if c.islower() else T_t for c in s)\n\n    def p(s: str) -> str:\n        return ''.join(T_u if c.islower() else T_v for c in s)\n\n    def q(s: str) -> str:\n        return ''.join(T_w if c.islower() else T_x for c in s)\n\n    def r(s: str) -> str:\n        return ''.join(T_y if c.islower() else T_z for c in s)\n\n    def apply_f(s: str, f: Callable[[str], str]) -> str:\n        return ''.join(f(s[i:i + 26]) for i in range(0, len(s), 26))\n\n    P = apply_f(S, f)\n    for _ in range(K - 1):\n        P = apply_f(P, g)\n        P = apply_f(P, h)\n        P = apply_f(P, i)\n        P = apply_f(P, j)\n        P = apply_f(P, k)\n        P = apply_f(P, l)\n        P = apply_f(P, m)\n        P = apply_f(P, n)\n        P = apply_f(P, o)\n        P = apply_f(P, p)\n        P = apply_f(P, q)\n        P = apply_f(P, r)\n\n    for i in range(M):\n        if m[i] <= len(P):\n            print(P[m[i] - 1])\n        else:\n            print('?')"
    },
    {
        "number": 3403,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    words = set(stdin.split())\n    steps = [0] * Q\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            steps[j - i - 1] += min(len(words[i]), len(words[j]))\n            while words[i][:len(words[j])] == words[j][:len(words[i])]:\n                steps[j - i - 1] += len(words[i])\n                i += 1\n                j += 1\n                if i == N:\n                    break\n\n    return \"\\n\".join(map(str, steps))\n"
    },
    {
        "number": 3404,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    encrypted_text = stdin.split()[1]\n\n    # Step 1: Define the function f(x) = (33x + 1) % 2^20\n    def f(x):\n        return (33 * x + 1) % (2 ** 20)\n\n    # Step 2: Create a X by X size grid, fill the upper left corner with f^1(0), the next cell to the right with f^2(0), f^3(0) etc.\n    grid = [[f(0)] * X for _ in range(X)]\n    for i in range(X):\n        grid[0][i] = f(grid[0][i])\n\n    # Step 3: Sum all the values in every column, and take those values mod 2^20\n    column_sums = [sum(row) % (2 ** 20) for row in grid]\n\n    # Step 4: Concatenate the base-10 representations of the column sums together, to get a very long base-10 number\n    long_number = ''.join(str(x) for x in column_sums)\n\n    # Step 5: Convert the result of step 4 from base 10 to base 27\n    pad = int(long_number)\n\n    # Step 6: For each letter l of the intercepted message, shift the letter by the amount given by the corresponding digit of step 5, base 27\n    decrypted_text = ''\n    for i, l in enumerate(encrypted_text):\n        decrypted_text += chr(((ord(l) - 65 + pad) % 27) + 65)\n\n    return decrypted_text"
    },
    {
        "number": 3405,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = float(stdin)\n    if X == 0:\n        return \"No solution\"\n    if X == 1:\n        return \"1\"\n    if X == 2:\n        return \"12\"\n    if X == 3:\n        return \"123\"\n    if X == 4:\n        return \"1234\"\n    if X == 5:\n        return \"12345\"\n    if X == 6:\n        return \"123456\"\n    if X == 7:\n        return \"1234567\"\n    if X == 8:\n        return \"12345678\"\n    if X == 9:\n        return \"123456789\"\n\n    def move_first_digit(num: int) -> int:\n        return num // 10 * 10 + num % 10\n\n    def square_root(num: int) -> int:\n        return int(num ** 0.5)\n\n    def multiply_by_x(num: int) -> int:\n        return move_first_digit(num) * X\n\n    def is_valid(num: int) -> bool:\n        return 10 ** 8 > num > 0\n\n    def find_solutions(X: float) -> list[int]:\n        solutions = []\n        for num in range(10 ** 8):\n            if is_valid(num):\n                if square_root(num) == num:\n                    solutions.append(num)\n                if multiply_by_x(num) == num:\n                    solutions.append(num)\n        return solutions\n\n    solutions = find_solutions(X)\n    if not solutions:\n        return \"No solution\"\n    return \"\\n\".join(map(str, sorted(solutions)))"
    },
    {
        "number": 3406,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    n_points = len(points)\n    n_castles = n_points // 4\n    in_danger = 0\n\n    for i in range(n_castles):\n        x, y = points[i * 4]\n        if all(x < points[j * 4][0] < x + 1 for j in range(i)) and all(y < points[j * 4][1] < y + 1 for j in range(i)):\n            in_danger += 1\n\n    return str(in_danger)"
    },
    {
        "number": 3407,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[1:3])\n        edges.append((a - 1, b - 1))\n    edges.append((n - 1, 0))\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        while queue:\n            current = queue.popleft()\n            for neighbor in edges[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        return visited\n\n    def dfs(start: int, visited: Set[int]) -> List[int]:\n        visited.add(start)\n        result = []\n        for neighbor in edges[start]:\n            if neighbor not in visited:\n                result.extend(dfs(neighbor, visited))\n        result.append(start)\n        return result\n\n    def is_valid(points: List[int]) -> bool:\n        for i in range(len(points) - 1):\n            if abs(points[i + 1] - points[i]) < 1e-6:\n                return False\n        return True\n\n    def find_valid_points(points: List[int]) -> List[int]:\n        valid_points = []\n        for i in range(len(points) - 1):\n            if abs(points[i + 1] - points[i]) > 1e-6:\n                valid_points.append(points[i])\n        return valid_points\n\n    def find_valid_edges(points: List[int]) -> List[Tuple[int, int]]:\n        valid_edges = []\n        for i in range(len(points) - 1):\n            valid_edges.append((points[i], points[i + 1]))\n        return valid_edges\n\n    def find_valid_graph(points: List[int]) -> List[List[int]]:\n        valid_graph = []\n        for i in range(len(points) - 1):\n            valid_graph.append([points[i], points[i + 1]])\n        return valid_graph\n\n    def find_valid_coordinates(points: List[int]) -> List[Tuple[float, float]]:\n        valid_coordinates = []\n        for i in range(len(points)):\n            valid_coordinates.append((points[i] / n, (points[i + 1] + points[i]) / 2 / n))\n        return valid_coordinates\n\n    def find_valid_solution(points: List[int]) -> List[Tuple[float, float]]:\n        valid_points = find_valid_points(points)\n        valid_edges = find_valid_edges(valid_points)\n        valid_graph = find_valid_graph(valid_points)\n        valid_coordinates = find_valid_coordinates(valid_points)\n\n        for i in range(len(valid_points) - 1):\n            for j in range(i + 1, len(valid_points)):\n                if abs(valid_points[i] - valid_points[j]) < 1e-6:\n                    valid_edges.append((valid_points.index(i), valid_points.index(j)))\n\n        for i in range(len(valid_graph)):\n            for j in range(i + 1, len(valid_graph)):\n                if abs(valid_graph[i][0] - valid_graph[j][0]) < 1e-6:\n                    valid_graph[i][1] = valid_graph[j][1]\n\n        for i in range(len(valid_coordinates)):\n            for j in range(i + 1, len(valid_coordinates)):\n                if abs(valid_coordinates[i][0] - valid_coordinates[j][0]) < 1e-6:\n                    valid_coordinates[i][1] = valid_coordinates[j][1]\n\n        return valid_coordinates\n\n    valid_points = find_valid_points(list(range(n)))\n    valid_coordinates = find_valid_solution(valid_points)\n\n    return \"\\n\".join(f\"{x:.6f} {y:.6f}\" for x, y in valid_coordinates)\n"
    },
    {
        "number": 3408,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    words = stdin.split('\\n')[1:]\n    patterns = stdin.split('\\n')[1:n+1]\n\n    def count_words(pattern: str) -> int:\n        count = 0\n        for word in words:\n            if pattern in word:\n                count += 1\n        return count\n\n    result = [count_words(pattern) for pattern in patterns]\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3409,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[1:])\n    board = [list(row) for row in stdin.split()[2:]]\n\n    def hammer(row: int, col: int) -> None:\n        board[row][col] = 'X'\n        for i in range(row - 1, -1, -1):\n            if board[i][col] == 'O':\n                hammer(i, col)\n        for i in range(col - 1, -1, -1):\n            if board[row][i] == 'O':\n                hammer(row, i)\n        for i in range(row + 1, r):\n            if board[i][col] == 'O':\n                hammer(i, col)\n        for i in range(col + 1, c):\n            if board[row][i] == 'O':\n                hammer(row, i)\n\n    for row in range(r):\n        for col in range(c):\n            if board[row][col] == 'O':\n                hammer(row, col)\n\n    for row in range(r):\n        for col in range(c):\n            if board[row][col] == 'O':\n                return '0'\n\n    return '1'"
    },
    {
        "number": 3410,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort()\n    x1, y1, x2, y2 = points[0], points[1], points[2], points[3]\n    if x1[0] == x2[0] or x1[1] == x2[1]:\n        return \"0\"\n    if x1[0] == x2[0]:\n        if y1[1] > y2[1]:\n            x1, x2 = x2, x1\n            y1, y2 = y2, y1\n        return str((x1[1] - y1[1]) * (x2[0] - x1[0]) + (x2[1] - y2[1]) * (x1[0] - x2[0]))\n    if x1[1] == x2[1]:\n        if y1[0] > y2[0]:\n            x1, x2 = x2, x1\n            y1, y2 = y2, y1\n        return str((x1[0] - y1[0]) * (x2[1] - x1[1]) + (x2[0] - y2[0]) * (x1[1] - x2[1]))\n    if x1[0] > x2[0]:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n    if x1[1] > x2[1]:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n    return str((x1[1] - y1[1]) * (x2[0] - x1[0]) + (x2[1] - y2[1]) * (x1[0] - x2[0]))"
    },
    {
        "number": 3411,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n\n    def create_fake_account(i: int) -> None:\n        nonlocal s\n        s[i] += 1\n\n    def report_comment(i: int) -> None:\n        nonlocal s\n        s[i] = 0\n\n    def upvote(i: int) -> None:\n        nonlocal s\n        s[i] += 1\n\n    def downvote(i: int) -> None:\n        nonlocal s\n        s[i] -= 1\n\n    def is_alternating(i: int) -> bool:\n        nonlocal s\n        return s[i]!= 0 and (s[i] * s[i + 1] < 0 or (i + 1 < n and s[i] * s[i + 1] == 0 and s[i] * s[i + 2] < 0))\n\n    def find_alternating_index(i: int) -> int:\n        nonlocal s\n        for j in range(i + 1, n):\n            if is_alternating(j):\n                return j\n        return -1\n\n    def find_alternating_chain() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_length() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i - s[i] + 1\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return s[i]\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i - s[i] + 1\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return s[i]\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time_length() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i - s[i] + 1\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time_length_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return s[i]\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time_length_time_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i - s[i] + 1\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time_length_time_time_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return s[i]\n            i = find_alternating_index(i)\n            if i == -1:\n                return -1\n        return -1\n\n    def find_alternating_chain_score_time_length_time_time_time_time() -> int:\n        nonlocal s\n        i = 0\n        while i < n:\n            if is_alternating(i):\n                return i - s[i] + 1\n            i = find_alternating_index(i)\n            if i == -"
    },
    {
        "number": 3412,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v_walk, v_bike, x1, y1, x2, y2, x_g, y_g, x_d, y_d, n = map(int, stdin.split())\n    stations = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        stations.append((x, y))\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def closest_station(x, y):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dist = distance(x, y, station[0], station[1])\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_point(x, y):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dx = x - station[0]\n            dy = y - station[1]\n            dist = dx ** 2 + dy ** 2\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_line(x1, y1, x2, y2):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dx = x2 - x1\n            dy = y2 - y1\n            dist = abs(dx * (station[1] - y1) - dy * (station[0] - x1) + x1 * y2 - y1 * x2) / distance(x1, y1, x2, y2)\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_circle(x, y, r):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dx = x - station[0]\n            dy = y - station[1]\n            dist = (dx ** 2 + dy ** 2) ** 0.5\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_polygon(x, y, polygon):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dist = distance_to_polygon(x, y, polygon)\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def distance_to_polygon(x, y, polygon):\n        min_dist = float('inf')\n        for i in range(len(polygon) - 1):\n            xi, yi = polygon[i]\n            xj, yj = polygon[i + 1]\n            if (yi > y)!= (yj > y) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi):\n                min_dist = min(min_dist, distance(x, y, xi, yi))\n        return min_dist\n\n    def closest_station_to_map(x, y):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dx = x - station[0]\n            dy = y - station[1]\n            dist = dx ** 2 + dy ** 2\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_map_polygon(x, y, polygon):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dist = distance_to_polygon(x, y, polygon)\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_map_circle(x, y, r):\n        min_dist = float('inf')\n        closest_station = None\n        for station in stations:\n            dx = x - station[0]\n            dy = y - station[1]\n            dist = (dx ** 2 + dy ** 2) ** 0.5\n            if dist < min_dist:\n                min_dist = dist\n                closest_station = station\n        return closest_station\n\n    def closest_station_to_map_line(x1, y1, x2,"
    },
    {
        "number": 3413,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    visited = [False] * n\n    min_months = float('inf')\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            min_months = min(min_months, dfs(i, graph, visited))\n    return str(min_months)\n\n\ndef"
    },
    {
        "number": 3414,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        a -= 1\n        b -= 1\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, path, result):\n        visited[node] = True\n        path.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path, result)\n            elif neighbor!= path[-1]:\n                result += abs(neighbor - path[-1])\n        path.pop()\n\n    visited = [False] * n\n    result = 0\n    dfs(0, visited, [0], result)\n    return str(result)"
    },
    {
        "number": 3415,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    root = 1\n    for i in range(N):\n        root *= 2\n    return str(root)"
    },
    {
        "number": 3416,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    trains = []\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        trains.append((a, b))\n\n    def dfs(city, visited, flights):\n        if city in visited:\n            return flights\n        visited.add(city)\n        for train in trains:\n            if train[0] == city:\n                flights += dfs(train[1], visited, flights)\n        return flights\n\n    min_flights = float('inf')\n    for city in cities:\n        visited = set()\n        min_flights = min(min_flights, dfs(city, visited, 0))\n\n    if min_flights == float('inf'):\n        return ''\n\n    return str(min_flights) +'' +''.join(map(str, cities))"
    },
    {
        "number": 3417,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    indep_set = []\n    for i in range(1, n + 1):\n        if not graph[i]:\n            indep_set.append(i)\n    return str(len(indep_set))"
    },
    {
        "number": 3418,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    citySize = 1000\n    dayOfMonth = 31\n    e = 2\n    luckyNumbers = [i for i in range(10 ** n, 10 ** (n + 1)) if i % citySize == 0 and i % dayOfMonth == 0]\n    supply = len(luckyNumbers)\n    return str(supply)"
    },
    {
        "number": 3419,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    def is_open(i: int) -> bool:\n        return s1 <= i < s2\n\n    def is_open_at_counter(i: int, counter: int) -> bool:\n        return s1 <= i < s2 and counter == 1 or s1 <= i < s2 and counter == 2\n\n    customers = []\n    for i in range(n):\n        if is_open(i):\n            customers.append(i)\n\n    customers.sort()\n    customers.reverse()\n\n    count = 0\n    for i in customers:\n        if is_open_at_counter(i, 1):\n            count += 1\n        elif is_open_at_counter(i, 2):\n            count += 1\n        else:\n            break\n\n    return str(count)"
    },
    {
        "number": 3420,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_books(stdin: str) -> list:\n        books = []\n        while True:\n            name, n = stdin.split()\n            if not name:\n                break\n            books.append((name, int(n)))\n        return books\n\n    def count_books(books: list) -> int:\n        return sum(len(books[i][1]) for i in range(len(books)))\n\n    def count_presentations(books: list, boys: int, girls: int) -> int:\n        presentations = 0\n        for i in range(len(books)):\n            if count_books(books[:i]) <= boys and count_books(books[i+1:]) <= girls:\n                presentations += 1\n        return presentations\n\n    def find_books(books: list, boys: int, girls: int) -> list:\n        presentations = []\n        for i in range(len(books)):\n            if count_books(books[:i]) <= boys and count_books(books[i+1:]) <= girls:\n                presentations.append(books[i])\n        return presentations\n\n    def find_books_by_name(books: list, name: str) -> list:\n        return [book for book in books if book[0] == name]\n\n    def find_books_by_title(books: list, title: str) -> list:\n        return [book for book in books if title in book[1]]\n\n    def find_books_by_names(books: list, names: list) -> list:\n        return [book for book in books if book[0] in names]\n\n    def find_books_by_titles(books: list, titles: list) -> list:\n        return [book for book in books if any(title in book[1] for title in titles)]\n\n    def find_books_by_names_and_titles(books: list, names: list, titles: list) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles)]\n\n    def find_books_by_names_and_titles_and_count(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count]\n\n    def find_books_by_names_and_titles_and_count_by_name(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count and book[0] in names]\n\n    def find_books_by_names_and_titles_and_count_by_title(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count and any(title in book[1] for title in titles)]\n\n    def find_books_by_names_and_titles_and_count_by_names(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count and book[0] in names]\n\n    def find_books_by_names_and_titles_and_count_by_titles(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count and any(title in book[1] for title in titles)]\n\n    def find_books_by_names_and_titles_and_count_by_names_and_titles(books: list, names: list, titles: list, count: int) -> list:\n        return [book for book in books if book[0] in names and any(title in book[1] for title in titles) and count_books(books) >= count and book[0] in names and any(title in book[1] for title in titles)]\n\n    def find_books_by_names_and_titles_and_count_by_names_and_titles_and_count("
    },
    {
        "number": 3421,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    stdin = stdin.split()[1]\n    stdin = [int(x) for x in stdin]\n\n    def success_rate(subseq):\n        return sum(subseq) / len(subseq)\n\n    def is_valid(subseq):\n        return len(subseq) >= k and all(x in [0, 1] for x in subseq)\n\n    def is_better(subseq1, subseq2):\n        return success_rate(subseq1) > success_rate(subseq2)\n\n    def find_best_subseq(start, end):\n        if end - start + 1 < k:\n            return None\n\n        subseq = stdin[start:end + 1]\n        if not is_valid(subseq):\n            return None\n\n        if end - start + 1 == k:\n            return subseq, success_rate(subseq)\n\n        best_subseq = None\n        best_success_rate = 0\n\n        for i in range(start, end):\n            for j in range(i + 1, end + 1):\n                subseq1 = stdin[start:i + 1]\n                subseq2 = stdin[i + 1:j]\n                subseq3 = stdin[j:]\n\n                if is_valid(subseq1) and is_valid(subseq2) and is_valid(subseq3):\n                    subseq1_success_rate = success_rate(subseq1)\n                    subseq2_success_rate = success_rate(subseq2)\n                    subseq3_success_rate = success_rate(subseq3)\n\n                    if is_better(subseq1, subseq2) and is_better(subseq2, subseq3):\n                        if subseq1_success_rate > best_success_rate:\n                            best_subseq = subseq1\n                            best_success_rate = subseq1_success_rate\n                    elif is_better(subseq1, subseq3) and is_better(subseq3, subseq2):\n                        if subseq1_success_rate > best_success_rate:\n                            best_subseq = subseq1\n                            best_success_rate = subseq1_success_rate\n\n        return best_subseq, best_success_rate\n\n    start = 0\n    end = 0\n    best_subseq = None\n    best_success_rate = 0\n\n    while end < len(stdin) - 1:\n        subseq, success_rate = find_best_subseq(start, end)\n\n        if subseq is not None and success_rate > best_success_rate:\n            best_subseq = subseq\n            best_success_rate = success_rate\n            start = end + 1\n        else:\n            end += 1\n\n    return f\"{best_subseq[0]} {len(best_subseq)}\"\n"
    },
    {
        "number": 3422,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pieces = []\n    for i in range(n):\n        w, h = map(int, stdin.split()[1:3])\n        pieces.append(list(stdin.split()[3:3+h]))\n        stdin = stdin.split()[3+h:]\n    pieces = [list(map(int, piece)) for piece in pieces]\n    \n    def rotate(piece):\n        return piece[::-1]\n    \n    def flip(piece):\n        return piece[::-1][::-1]\n    \n    def combine(piece1, piece2):\n        return [piece1[i] + piece2[i] for i in range(len(piece1))]\n    \n    def valid_map(pieces):\n        for i in range(len(pieces)):\n            for j in range(i+1, len(pieces)):\n                if pieces[i] == pieces[j]:\n                    return False\n        return True\n    \n    def reconstruct_map(pieces):\n        if not valid_map(pieces):\n            return None\n        result = pieces[0]\n        for piece in pieces[1:]:\n            result = combine(result, piece)\n        return result\n    \n    def find_map_piece(map_piece, reconstructed_map):\n        for i in range(len(reconstructed_map)):\n            for j in range(len(reconstructed_map[i])):\n                if reconstructed_map[i][j] == map_piece:\n                    return i, j\n        return None\n    \n    def find_treasure(map_piece, reconstructed_map):\n        for i in range(len(reconstructed_map)):\n            for j in range(len(reconstructed_map[i])):\n                if reconstructed_map[i][j] == map_piece:\n                    return i, j\n        return None\n    \n    def find_treasure_map(pieces):\n        for piece in pieces:\n            map_piece = reconstruct_map([piece])\n            if map_piece is not None:\n                return map_piece\n        return None\n    \n    def find_best_map(pieces):\n        best_map = None\n        best_score = 0\n        for i in range(4):\n            for j in range(4):\n                rotated_pieces = [rotate(piece) for piece in pieces]\n                flipped_pieces = [flip(piece) for piece in rotated_pieces]\n                combined_pieces = [combine(piece1, piece2) for piece1 in pieces for piece2 in flipped_pieces]\n                for piece in combined_pieces:\n                    map_piece = reconstruct_map([piece])\n                    if map_piece is not None:\n                        score = sum(map_piece) % 10\n                        if score > best_score:\n                            best_score = score\n                            best_map = map_piece\n        return best_map\n    \n    def find_best_map_piece(pieces):\n        best_map_piece = None\n        best_score = 0\n        for piece in pieces:\n            map_piece = reconstruct_map([piece])\n            if map_piece is not None:\n                score = sum(map_piece) % 10\n                if score > best_score:\n                    best_score = score\n                    best_map_piece = map_piece\n        return best_map_piece\n    \n    def find_best_map_piece_index(pieces):\n        best_map_piece_index = None\n        best_score = 0\n        for i in range(len(pieces)):\n            for j in range(len(pieces[i])):\n                for k in range(len(pieces[i][j])):\n                    for l in range(len(pieces[i][j][k])):\n                        for m in range(len(pieces[i][j][k][l])):\n                            for n in range(len(pieces[i][j][k][l][m])):\n                                for o in range(len(pieces[i][j][k][l][m][n])):\n                                    for p in range(len(pieces[i][j][k][l][m][n][o])):\n                                        map_piece = reconstruct_map([pieces[i][j][k][l][m][n][o][p]])\n                                        if map_piece is not None:\n                                            score = sum(map_piece) % 10\n                                            if score > best_score:\n                                                best_score = score\n                                                best_map_piece_index = i, j, k, l, m, n, o, p\n        return best_map_piece_index\n    \n    def find_best_map_piece_location(pieces):\n        best_map_piece_location = None\n        best_score = 0\n        for i in range(len(pieces)):\n            for j in range(len(pieces[i])):\n                for"
    },
    {
        "number": 3423,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def topological_sort(packages: List[str], visited: Set[str]) -> List[str]:\n        result = []\n        stack = []\n        for package in packages:\n            if package not in visited:\n                stack.append(package)\n        while stack:\n            package = stack.pop()\n            if package not in visited:\n                visited.add(package)\n                for dependency in packages[packages.index(package) + 1:]:\n                    if dependency in visited:\n                        continue\n                    if dependency in stack:\n                        stack.remove(dependency)\n                result.append(package)\n        if not result:\n            return \"cannot be ordered\"\n        return result\n\n    def parse_package(package: str) -> Tuple[str, List[str]]:\n        name, dependencies = package.split()\n        return name, dependencies.split()\n\n    def parse_input(input_str: str) -> List[Tuple[str, List[str]]]:\n        packages = []\n        for line in input_str.split(\"\\n\"):\n            if line:\n                name, dependencies = parse_package(line)\n                packages.append((name, dependencies))\n        return packages\n\n    def is_valid_package(package: str, packages: List[Tuple[str, List[str]]]) -> bool:\n        name, dependencies = package\n        if name not in packages:\n            return False\n        for dependency in dependencies:\n            if dependency not in packages:\n                return False\n        return True\n\n    def is_valid_order(packages: List[Tuple[str, List[str]]]) -> bool:\n        visited = set()\n        for package in packages:\n            if package[0] not in visited:\n                if not topological_sort(packages, visited):\n                    return False\n        return True\n\n    def is_valid_input(input_str: str) -> bool:\n        packages = parse_input(input_str)\n        return all(is_valid_package(package, packages) for package in packages)\n\n    def is_valid_output(output_str: str) -> bool:\n        return output_str.strip() == \"cannot be ordered\"\n\n    def is_valid_test_case(input_str: str, output_str: str) -> bool:\n        return is_valid_input(input_str) and is_valid_output(output_str)\n\n    test_cases = stdin.split(\"\\n\\n\")\n    for test_case in test_cases:\n        input_str, output_str = test_case.split(\"\\n\")\n        if is_valid_test_case(input_str, output_str):\n            print(output_str)\n        else:\n            print(\"Invalid test case\")"
    },
    {
        "number": 3424,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, l = map(int, stdin.split())\n    for b in range(1, 10):\n        if y % b == 0:\n            digits = [int(d) for d in str(y // b)]\n            if all(0 <= d <= 9 for d in digits) and sum(digits) >= l:\n                return str(b)\n    return \"impossible\""
    },
    {
        "number": 3425,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(row: int, col: int) -> bool:\n        for i in range(n):\n            if board[row][i] == 'Q' or board[i][col] == 'Q':\n                return False\n            if row - i == col - i or row + i == col + i:\n                return False\n        return True\n\n    def backtrack(row: int, col: int) -> None:\n        if row == n:\n            result.append(board)\n            return\n\n        for i in range(n):\n            if is_valid(row, i):\n                board[row][i] = 'Q'\n                backtrack(row + 1, i)\n                board[row][i] = '.'\n\n    result = []\n    backtrack(0, 0)\n    return f\"{len(result)} {len(set(tuple(row) for row in result))}\""
    },
    {
        "number": 3426,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stations = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, l, c = map(int, stdin.split())\n        stations[a].append((b, l, c))\n        stations[b].append((a, l, c))\n    distances = [float('inf')] * (n + 1)\n    distances[1] = 0\n    for i in range(1, n + 1):\n        for j, (k, l, c) in enumerate(stations[i]):\n            if c == 1:\n                if distances[i] + l < distances[k]:\n                    distances[k] = distances[i] + l\n    return''.join(map(str, distances[1:]))"
    },
    {
        "number": 3427,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    doors = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        doors.append((u, v))\n\n    def bfs(start: int) -> int:\n        queue = [(start, 1)]\n        visited = set()\n        max_rooms = 0\n\n        while queue:\n            room, depth = queue.pop(0)\n            if room not in visited:\n                visited.add(room)\n                max_rooms = max(max_rooms, depth)\n                for neighbor, _ in doors:\n                    if neighbor == room:\n                        continue\n                    queue.append((neighbor, depth + 1))\n\n        return max_rooms\n\n    return str(bfs(0))"
    },
    {
        "number": 3428,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    f = [1] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            f[i] *= gcd(a[i], a[j], *a[:i] + a[j + 1:])\n    return str(len(set(f)))\n\ndef"
    },
    {
        "number": 3429,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, s_s, r_i, r_f = map(int, stdin.split())\n    x_a, y_a, s_a = map(int, stdin.split())\n\n    # Calculate the initial radius\n    r_0 = r_i\n\n    # Calculate the maximum distance that Anthony can travel\n    max_distance = r_f * 2 * math.pi\n\n    # Calculate the number of seconds it takes for the radius to decrease\n    time_to_decrease = max_distance / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink\n    time_to_shrink = (r_f - r_0) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow\n    time_to_grow = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant\n    time_to_remain_constant = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink again\n    time_to_shrink_again = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow again\n    time_to_grow_again = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant again\n    time_to_remain_constant_again = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the minimum radius\n    time_to_shrink_to_min = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow to the minimum radius\n    time_to_grow_to_min = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant to the minimum radius\n    time_to_remain_constant_to_min = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the maximum radius\n    time_to_shrink_to_max = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow to the maximum radius\n    time_to_grow_to_max = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant to the maximum radius\n    time_to_remain_constant_to_max = (r_f - r_f) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the initial radius\n    time_to_shrink_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow to the initial radius\n    time_to_grow_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant to the initial radius\n    time_to_remain_constant_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the initial radius\n    time_to_shrink_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow to the initial radius\n    time_to_grow_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant to the initial radius\n    time_to_remain_constant_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the initial radius\n    time_to_shrink_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to grow to the initial radius\n    time_to_grow_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to remain constant to the initial radius\n    time_to_remain_constant_to_init = (r_f - r_i) / s_s\n\n    # Calculate the number of seconds it takes for the safety zone to shrink to the initial radius\n   "
    },
    {
        "number": 3430,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a_cables = [tuple(map(int, stdin.split())) for _ in range(n - 1)]\n    b_cables = [tuple(map(int, stdin.split())) for _ in range(m - 1)]\n\n    def bellman_ford(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        for _ in range(len(graph) - 1):\n            for u in range(len(graph)):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def min_cost_path(graph, start, end):\n        dist = bellman_ford(graph, start)\n        if dist[end] == float('inf'):\n            return float('inf')\n        path = []\n        u = end\n        while u!= start:\n            path.append(u)\n            u = graph[u][u].index(min(graph[u][u], key=lambda x: x[1]))\n        path.append(start)\n        path.reverse()\n        return dist[end], path\n\n    a_graph = [[] for _ in range(n)]\n    for u, v in a_cables:\n        a_graph[u - 1].append((v - 1, 1))\n    a_dist, a_path = min_cost_path(a_graph, 0, n - 1)\n\n    b_graph = [[] for _ in range(m)]\n    for u, v in b_cables:\n        b_graph[u - 1].append((v - 1, 1))\n    b_dist, b_path = min_cost_path(b_graph, 0, m - 1)\n\n    c_graph = [[] for _ in range(n + m)]\n    for u, v in a_cables:\n        c_graph[u - 1].append((v - 1, 1))\n    for u, v in b_cables:\n        c_graph[u - 1].append((v - 1, 1))\n    for u, v in a_cables:\n        c_graph[v - 1].append((u - 1, 1))\n    for u, v in b_cables:\n        c_graph[v - 1].append((u - 1, 1))\n\n    c_dist, c_path = min_cost_path(c_graph, 0, n + m - 1)\n\n    return str(c_dist)\n"
    },
    {
        "number": 3431,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0] + x[1])\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((points[i], points[j]))\n    edges.sort(key=lambda x: x[0][0] + x[0][1] + x[1][0] + x[1][1])\n    mst = []\n    for edge in edges:\n        if not mst or mst[-1][1]!= edge[0]:\n            mst.append(edge[0])\n            break\n    return str(sum(map(lambda x: x[1], mst)))"
    },
    {
        "number": 3432,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rounds = int(stdin.split()[0])\n    result = []\n    for i in range(rounds):\n        A, B = map(int, stdin.split()[1:])\n        pairs = []\n        for a in range(A):\n            for b in range(B):\n                pairs.append((a, b))\n        pairs.sort(key=lambda x: x[0] + x[1])\n        max_sum = 0\n        for pair in pairs:\n            max_sum += pair[0] + pair[1]\n        result.append(max_sum)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3433,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    maze = [list(row) for row in stdin.split()[1:]]\n    j_pos = [i for i, row in enumerate(maze) for j, cell in enumerate(row) if cell == 'J'][0]\n    fire_pos = [i for i, row in enumerate(maze) for j, cell in enumerate(row) if cell == 'F'][0]\n    visited = set()\n    queue = [(j_pos, 0)]\n    while queue:\n        pos, time = queue.pop(0)\n        if pos in visited:\n            continue\n        visited.add(pos)\n        if pos == fire_pos:\n            return str(time)\n        for i in range(4):\n            new_pos = (pos[0] + (i - 1) // 2, pos[1] + (i - 1) % 2)\n            if 0 <= new_pos[0] < R and 0 <= new_pos[1] < C and maze[new_pos[0]][new_pos[1]]!= '#' and new_pos not in visited:\n                queue.append((new_pos, time + 1))\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3434,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    minions = list(map(int, stdin.split()))\n    opponent_minions = list(map(int, stdin.split()))\n\n    def explosion(minions, opponent_minions, d):\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n                minion.health -= 1\n                if minion.health == 0:\n                    minions.remove(minion)\n        for opponent_minion in opponent_minions:\n            if opponent_minion.health > 0:\n                opponent_minion.health -= 1\n                if opponent_minion.health == 0:\n                    opponent_minions.remove(opponent_minion)\n        for minion in minions:\n            if minion.health > 0:\n               "
    },
    {
        "number": 3435,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pattern = map(int, stdin.split())\n    pattern = ''.join(map(str, pattern))\n    count = 0\n    for i in range(2 ** n):\n        binary = bin(i)[2:].zfill(n)\n        if pattern == binary:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3436,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    F = [[0] * 1001 for _ in range(1001)]\n    F[0][0] = 0\n    F[0][1] = 1\n    for i in range(2, 1001):\n        F[i][0] = (F[i-1][0] + F[i-2][0]) % (10**9 + 7)\n        F[0][i] = (F[0][i-1] + F[0][i-2]) % (10**9 + 7)\n    return str((F[x][y] + 10**9) % (10**9 + 7))"
    },
    {
        "number": 3437,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L1, L2, N = map(int, stdin.split())\n    tubes = list(map(int, stdin.split()))\n    tubes.sort()\n    tubes.append(tubes[-1] + L2)\n    tubes.append(tubes[-1] + L1)\n    tubes.sort()\n    if tubes[-1] > L1 + L2:\n        return \"Impossible\"\n    return tubes[-1]"
    },
    {
        "number": 3438,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cache_size, n, a = map(int, stdin.split())\n    accesses = list(map(int, stdin.split()))\n\n    monkey = IntrospectiveCachingMonkey(cache_size)\n\n    for access in accesses:\n        monkey.access(access)\n\n    return str(monkey.least_reads)\n\nclass IntrospectiveCachingMonkey:\n    def __init__(self, cache_size: int):\n        self.cache_size = cache_size\n        self.cache = {}\n        self.least_reads = float('inf')\n\n    def access(self, obj_id: int) -> None:\n        if obj_id not in self.cache:\n            self.cache[obj_id] = obj_id\n            self.least_reads = min(self.least_reads, 1)\n        else:\n            self.cache.pop(obj_id)\n            self.least_reads = min(self.least_reads, 2)"
    },
    {
        "number": 3439,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    grid = []\n    for _ in range(h):\n        row = list(map(int, stdin.split()[1].split()))\n        grid.append(row)\n\n    i, j = map(int, stdin.split()[-1].split())\n    device_altitude = grid[i - 1][j - 1]\n\n    def get_neighbours(i, j):\n        return [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1), (i - 1, j - 1), (i - 1, j + 1), (i + 1, j - 1), (i + 1, j + 1)]\n\n    def get_water_level(i, j):\n        neighbours = get_neighbours(i, j)\n        water_level = min(grid[i][j], device_altitude)\n        for x, y in neighbours:\n            if 1 <= x <= h and 1 <= y <= w and grid[x - 1][y - 1] < 0:\n                water_level = min(water_level, grid[x - 1][y - 1])\n        return water_level\n\n    def get_water_volume(i, j):\n        water_level = get_water_level(i, j)\n        return (water_level - device_altitude) ** 3\n\n    total_water_volume = 0\n    for i in range(1, h):\n        for j in range(1, w):\n            total_water_volume += get_water_volume(i, j)\n\n    return str(total_water_volume)"
    },
    {
        "number": 3440,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    flights = []\n    for _ in range(r):\n        a, b, c = map(int, stdin.split())\n        flights.append((a, b, c))\n\n    f, flights = map(int, stdin.split())\n    for _ in range(f):\n        a, b, c = map(int, stdin.split())\n        flights.append((a, b, c))\n\n    flights.sort(key=lambda x: x[2])\n    total_cost = 0\n    for a, b, c in flights:\n        total_cost += c\n\n    return str(total_cost)"
    },
    {
        "number": 3441,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n    visited = [False] * n\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            count += 1\n            dfs(graph, visited, i, i)\n    return str(count)\n\ndef"
    },
    {
        "number": 3442,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    count = 0\n    for i in range(x, y + 1):\n        if is_sheldon(i):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3443,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    spots = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        spots.append((x, y))\n    spots.sort()\n    x, y = spots[0]\n    dx, dy = spots[1][0] - x, spots[1][1] - y\n    if dx == 0:\n        return str(abs(y - spots[1][1]))\n    elif dy == 0:\n        return str(abs(x - spots[1][0]))\n    else:\n        return str(abs(x - spots[1][0]) + abs(y - spots[1][1]))"
    },
    {
        "number": 3444,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    pistes = []\n    for _ in range(M):\n        a, b, w = map(int, stdin.split())\n        pistes.append((a, b, w))\n\n    p = [0] * N\n    p[0] = 1\n    for i in range(1, N):\n        for piste in pistes:\n            if i == piste[0] or i == piste[1]:\n                p[i] = max(p[i], p[piste[0]] * piste[2])\n\n    return''.join(map(str, p))"
    },
    {
        "number": 3445,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    customers = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        customers.append((x, y))\n    customers.sort(key=lambda x: (x[0], x[1]))\n    x_min = customers[0][0]\n    x_max = customers[-1][0]\n    y_min = customers[0][1]\n    y_max = customers[-1][1]\n    max_delivery_time = 0\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            delivery_time = 0\n            for customer in customers:\n                if customer[0] == x and customer[1] == y:\n                    delivery_time += 1\n            max_delivery_time = max(max_delivery_time, delivery_time)\n    return str(max_delivery_time)"
    },
    {
        "number": 3446,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_time(assembly_table: List[Tuple[int, str]]) -> Tuple[int, str]:\n        min_time = float('inf')\n        min_result = ''\n        for time, result in assembly_table:\n            if time < min_time:\n                min_time = time\n                min_result = result\n        return min_time, min_result\n\n    def find_min_time_for_sequence(sequence: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence)):\n            for j in range(i + 1, len(sequence)):\n                assembly_table.append((sequence[i] + sequence[j], sequence[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_pieces(pieces: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(pieces)):\n            for j in range(i + 1, len(pieces)):\n                assembly_table.append((pieces[i] + pieces[j], pieces[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_components(components: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(components)):\n            for j in range(i + 1, len(components)):\n                assembly_table.append((components[i] + components[j], components[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_sequence_of_components(sequence_of_components: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence_of_components)):\n            for j in range(i + 1, len(sequence_of_components)):\n                assembly_table.append((sequence_of_components[i] + sequence_of_components[j], sequence_of_components[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_sequence_of_pieces(sequence_of_pieces: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence_of_pieces)):\n            for j in range(i + 1, len(sequence_of_pieces)):\n                assembly_table.append((sequence_of_pieces[i] + sequence_of_pieces[j], sequence_of_pieces[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_sequence_of_components_of_pieces(sequence_of_components_of_pieces: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence_of_components_of_pieces)):\n            for j in range(i + 1, len(sequence_of_components_of_pieces)):\n                assembly_table.append((sequence_of_components_of_pieces[i] + sequence_of_components_of_pieces[j], sequence_of_components_of_pieces[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_sequence_of_components_of_pieces_of_pieces(sequence_of_components_of_pieces_of_pieces: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence_of_components_of_pieces_of_pieces)):\n            for j in range(i + 1, len(sequence_of_components_of_pieces_of_pieces)):\n                assembly_table.append((sequence_of_components_of_pieces_of_pieces[i] + sequence_of_components_of_pieces_of_pieces[j], sequence_of_components_of_pieces_of_pieces[j]))\n        return find_min_time(assembly_table)\n\n    def find_min_time_for_sequence_of_components_of_pieces_of_pieces_of_pieces(sequence_of_components_of_pieces_of_pieces_of_pieces: List[str]) -> Tuple[int, str]:\n        assembly_table = []\n        for i in range(len(sequence_of_components_of_pieces_of_pieces_of_pieces)):\n            for j in range(i + 1, len(sequence_of_components_of_pieces_of_pieces_of_pieces)):\n                assembly_table.append((sequence_of_"
    },
    {
        "number": 3447,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    dictionary = []\n    for _ in range(n):\n        word = stdin.readline().strip()\n        dictionary.append(word)\n\n    for _ in range(q):\n        query = stdin.readline().strip()\n        query_parts = query.split()\n        if len(query_parts) == 1:\n            digit = int(query_parts[0])\n            print(digit)\n        elif len(query_parts) == 2:\n            if query_parts[0] == \"right\":\n                print(\"R\")\n            elif query_parts[0] == \"up\":\n                x = int(query_parts[1])\n                print(f\"U({x})\")\n            elif query_parts[0] == \"down\":\n                x = int(query_parts[1])\n                print(f\"D({x})\")\n        else:\n            raise ValueError(\"Invalid query\")\n\n    return \"\"\n\n\ndef"
    },
    {
        "number": 3448,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return 'NO'\n\n    ms = [0] * n\n    me = [0] * n\n    vs = [0] * n\n    ve = [0] * n\n\n    for i in range(n):\n        ms[i] = i + 1\n        me[i] = i + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ms[i] < ms[j]:\n                me[i] = j + 1\n            if vs[i] < vs[j]:\n                ve[i] = j + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ms[i] == ms[j] and me[i] == me[j]:\n                return 'NO'\n            if vs[i] == vs[j] and ve[i] == ve[j]:\n                return 'NO'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ms[i] < ms[j] and me[i] < me[j]:\n                return 'NO'\n            if vs[i] < vs[j] and ve[i] < ve[j]:\n                return 'NO'\n\n    return 'YES'"
    },
    {
        "number": 3449,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, H, R, C = map(int, stdin.split())\n    grid = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def fence(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C\n\n    def is_valid_fence(x1, y1, x2, y2):\n        return is_valid(x1, y1) and is_valid(x2, y2) and fence(x1, y1, x2, y2) >= B\n\n    def fence_cost(x1, y1, x2, y2):\n        return 43 if is_valid_fence(x1, y1, x2, y2) else 11\n\n    total_cost = 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] < B:\n                continue\n            for dr in range(-1, 2):\n                for dc in range(-1, 2):\n                    if dr == 0 and dc == 0:\n                        continue\n                    x = r + dr\n                    y = c + dc\n                    if is_valid(x, y) and grid[x][y] < B:\n                        total_cost += fence_cost(r, c, x, y)\n\n    return str(total_cost)"
    },
    {
        "number": 3450,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    trailing_zeroes = 0\n    while factorial % 10 == 0:\n        factorial //= 10\n        trailing_zeroes += 1\n    last_three_digits = factorial % 1000\n    if last_three_digits == 0:\n        return str(last_three_digits)\n    else:\n        return str(last_three_digits) + \" \" + str(last_three_digits) + \" \" + str(last_three_digits)"
    },
    {
        "number": 3451,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    c = map(int, stdin.split()[2:])\n\n    def is_balanced(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def change_parenthesis(s: str, i: int, c: int) -> str:\n        if s[i] == '(':\n            return s[:i] + ')' + s[i+1:]\n        else:\n            return s[:i] + '(' + s[i+1:]\n\n    def min_effort(s: str, c: int) -> int:\n        min_effort = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                min_effort += c\n            else:\n                min_effort -= c\n        return min_effort\n\n    def min_effort_helper(s: str, c: int, i: int, min_effort: int) -> int:\n        if i == len(s):\n            return min_effort\n\n        if s[i] == '(':\n            min_effort_helper(s, c, i+1, min_effort)\n            min_effort_helper(s, c, i+1, min_effort + c)\n        else:\n            min_effort_helper(s, c, i+1, min_effort)\n            min_effort_helper(s, c, i+1, min_effort - c)\n\n        return min_effort\n\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    if min_effort == 0:\n        return '?'\n\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_effort_helper(s, 0, 0, 0)\n    min_effort = min_eff"
    },
    {
        "number": 3452,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rooms = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        k = int(stdin.split()[i])\n        for j in range(k):\n            rooms[i].append(int(stdin.split()[i + j + 1]))\n\n    def is_effectively_identical(room1: int, room2: int) -> bool:\n        if len(rooms[room1])!= len(rooms[room2]):\n            return False\n        for corridor in rooms[room1]:\n            if corridor not in rooms[room2]:\n                return False\n        return True\n\n    def find_effectively_identical_sets() -> list[list[int]]:\n        result = []\n        visited = set()\n        for room1 in range(1, n + 1):\n            if room1 in visited:\n                continue\n            visited.add(room1)\n            for room2 in range(room1 + 1, n + 1):\n                if room2 in visited:\n                    continue\n                if is_effectively_identical(room1, room2):\n                    result.append([room1, room2])\n                    visited.add(room2)\n        return result\n\n    sets = find_effectively_identical_sets()\n    if not sets:\n        return \"None\"\n\n    sets.sort(key=lambda x: min(x))\n    result = []\n    for set_ in sets:\n        result.append(\" \".join(map(str, set_)))\n    return \"\\n\".join(result)"
    },
    {
        "number": 3453,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    chambers = list(map(int, stdin.split()))\n    tunnels = []\n    for i in range(M):\n        A, B, L = map(int, stdin.split())\n        tunnels.append((A, B, L))\n\n    def dfs(chamber, visited, path, danger):\n        if chamber == N:\n            return 0\n\n        if (chamber, visited) in visited:\n            return visited[(chamber, visited)]\n\n        visited[(chamber, visited)] = 0\n        for tunnel in tunnels:\n            if tunnel[0] == chamber and tunnel[1] not in visited:\n                visited[(chamber, visited)] += dfs(tunnel[1], visited, path + [tunnel[1]], danger)\n            elif tunnel[1] == chamber and tunnel[0] not in visited:\n                visited[(chamber, visited)] += dfs(tunnel[0], visited, path + [tunnel[0]], danger)\n\n        visited[(chamber, visited)] %= 10**9 + 7\n        return visited[(chamber, visited)]\n\n    danger = dfs(1, {}, [], 0)\n    return \" \".join(map(str, danger))"
    },
    {
        "number": 3454,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    b = [0] * n\n    r = [0] * n\n\n    for i in range(n):\n        b[i] = c[i]\n        r[i] = m - c[i]\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1\n\n    for i in range(n):\n        if b[i] > 0:\n            b[i] -= 1\n            r[i] += 1\n\n    for i in range(n):\n        if r[i] > 0:\n            b[i] += 1\n            r[i] -= 1"
    },
    {
        "number": 3455,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def is_safe(car: tuple, cars: list) -> bool:\n        lane, length, distance = car\n        for car in cars:\n            if car[0] == lane and distance < car[2]:\n                return False\n        return True\n\n    def find_safe_lane(cars: list) -> int:\n        max_safe_factor = 0\n        for i in range(len(cars)):\n            for j in range(i + 1, len(cars)):\n                if is_safe((cars[i][0], cars[i][1], cars[i][2]), cars) and is_safe((cars[j][0], cars[j][1], cars[j][2]), cars):\n                    max_safe_factor = max(max_safe_factor, distance(cars[i][2], cars[j][2]))\n        return max_safe_factor\n\n    def find_lane_switch_plan(cars: list) -> str:\n        max_safe_factor = find_safe_lane(cars)\n        if max_safe_factor == 0:\n            return \"Impossible\"\n        for i in range(len(cars)):\n            for j in range(i + 1, len(cars)):\n                if is_safe((cars[i][0], cars[i][1], cars[i][2]), cars) and is_safe((cars[j][0], cars[j][1], cars[j][2]), cars):\n                    return f\"Switch to lane {cars[i][0]}\"\n        return \"Impossible\"\n\n    def read_input() -> tuple:\n        n, m, r = map(int, stdin.split())\n        cars = []\n        for _ in range(m):\n            lane, length, distance = map(int, stdin.split())\n            cars.append((lane, length, distance))\n        return n, m, r, cars\n\n    n, m, r, cars = read_input()\n    result = find_lane_switch_plan(cars)\n    print(result)\n    return result\n"
    },
    {
        "number": 3456,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    crates = list(map(int, stdin.split()[1:]))\n\n    def is_valid(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            else:\n                return False\n        return True\n\n    def is_valid_stack(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return True\n\n    def is_valid_stack_height(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal_and_rearrangement(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal_and_rearrangement_with_new_stack(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal_and_rearrangement_with_new_stack_and_removal(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal_and_rearrangement_with_new_stack_and_removal_and_rearrangement(crates: List[int]) -> bool:\n        stack = []\n        for crate in crates:\n            if not stack or stack[-1] < crate:\n                stack.append(crate)\n            elif stack[-1] == crate:\n                return False\n        return len(stack) == len(crates)\n\n    def is_valid_stack_height_and_width_and_order_with_new_stack_and_removal_and_rearrangement_with_new_stack_and_removal_and_rearrangement_with"
    },
    {
        "number": 3457,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def dfs(x, y, path):\n        if x == N and y == N:\n            return 1\n\n        if x == N:\n            return dfs(0, y + 1, path)\n\n        if y == N:\n            return dfs(x + 1, 0, path)\n\n        if x + y == N:\n            return dfs(0, 0, path + 1)\n\n        return dfs(x + 1, y, path)\n\n    return str(dfs(0, 0, 0) % MOD)"
    },
    {
        "number": 3458,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    max_xor_sum = 0\n    for i in range(1, n + 1):\n        xor_sum = 0\n        for j in range(n):\n            xor_sum ^= a[j] ^ i\n        if xor_sum > max_xor_sum:\n            max_xor_sum = xor_sum\n    return str(max_xor_sum)"
    },
    {
        "number": 3459,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n = int(stdin.split('\\n')[1])\n        residents = []\n        for _ in range(n):\n            resident = stdin.split('\\n')[2].split()\n            clubs = stdin.split('\\n')[3].split()\n            residents.append((resident[0], resident[1], int(clubs[0]), clubs[1:]))\n        residents.sort(key=lambda x: (x[1], x[2], x[3]))\n        council = []\n        for i in range(n):\n            if i == 0 or residents[i][1]!= residents[i-1][1]:\n                council.append(residents[i][0])\n        if len(council) == 0:\n            print(\"Impossible.\")\n        else:\n            for i in range(len(council)):\n                print(council[i], residents[i][3])"
    },
    {
        "number": 3460,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    can_locations = []\n    for _ in range(n):\n        x, r = map(int, stdin.split()[1:])\n        can_locations.append((x, r))\n\n    explosion_count = [0] * n\n    explosion_count[0] = 1\n\n    for i in range(1, n):\n        for j in range(i):\n            if can_locations[i][0] - can_locations[j][0] <= can_locations[i][1] + can_locations[j][1]:\n                explosion_count[i] += explosion_count[j]\n\n    return \" \".join(map(str, explosion_count))"
    },
    {
        "number": 3461,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    hearings = []\n    for _ in range(n):\n        s, a, b = map(int, stdin.split()[1:])\n        hearings.append((s, a, b))\n    hearings.sort()\n    expected_value = 0\n    for i in range(n):\n        if i == 0:\n            expected_value += 1\n        elif i == n - 1:\n            expected_value += 1\n        else:\n            expected_value += 2\n        if hearings[i][0] <= hearings[i - 1][0]:\n            expected_value -= 1\n    return str(expected_value)"
    },
    {
        "number": 3462,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pattern, n = stdin.split('\\n')\n    pattern = pattern.strip()\n    files = stdin.split('\\n')[1:]\n\n    matches = []\n    for file in files:\n        if fnmatch.fnmatch(file, pattern):\n            matches.append(file)\n\n    return '\\n'.join(matches)"
    },
    {
        "number": 3463,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    p = list(map(float, stdin.split()))\n    p.append(1 - sum(p))\n\n    total_points = N + M\n    p_win = p[0]\n    p_loss = p[1]\n\n    for i in range(2, len(p)):\n        p_win *= (total_points - i) / (total_points - i + 1)\n        p_loss *= i / (i + 1)\n\n    return f\"{p_win:.6f}\""
    },
    {
        "number": 3464,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, p = map(float, stdin.split())\n    if x < 0 or x > 100 or p < 0 or p > 50:\n        return \"Invalid input\"\n\n    # Calculate the expected profit for each bet\n    expected_profit = [0] * 10\n    for i in range(1, 10):\n        expected_profit[i] = (1 - p) * expected_profit[i - 1] + p * 2\n\n    # Calculate the maximum expected profit\n    max_profit = 0\n    for i in range(1, 10):\n        max_profit = max(max_profit, expected_profit[i] + x * (1 - p))\n\n    return f\"{max_profit:.3f}\""
    },
    {
        "number": 3465,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    roads = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split()[1:])\n        roads.append((a, b))\n    roads.append((n, 1))\n    roads.append((1, n))\n\n    def dfs(city, visited):\n        if city in visited:\n            return\n        visited.add(city)\n        for road in roads:\n            if road[0] == city and road[1] not in visited:\n                dfs(road[1], visited)\n            elif road[1] == city and road[0] not in visited:\n                dfs(road[0], visited)\n\n    visited = set()\n    for city in range(1, n + 1):\n        if city not in visited:\n            dfs(city, visited)\n\n    result = []\n    for road in roads:\n        if road[0] in visited and road[1] in visited:\n            result.append(f\"{road[0]} {road[1]}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3466,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_balanced(s: list) -> bool:\n        n = sum(s)\n        for i in range(1, m + 1):\n            if n * a[i - 1] - 1 < s[i - 1] < n * a[i - 1] + 1:\n                return False\n        return True\n\n    def find_max_buy(s: list) -> int:\n        max_buy = 0\n        for i in range(1, m + 1):\n            if s[i - 1] > 0:\n                max_buy = max(max_buy, s[i - 1])\n        return max_buy\n\n    def find_max_eat(s: list) -> int:\n        max_eat = 0\n        for i in range(1, m + 1):\n            if s[i - 1] > 0:\n                max_eat = max(max_eat, s[i - 1])\n        return max_eat\n\n    def find_max_buy_eat(s: list) -> int:\n        max_buy = find_max_buy(s)\n        max_eat = find_max_eat(s)\n        return max(max_buy, max_eat)\n\n    def find_max_buy_eat_balanced(s: list) -> int:\n        max_buy_eat = find_max_buy_eat(s)\n        if is_balanced(s):\n            return max_buy_eat\n        else:\n            return -1\n\n    max_buy_eat_balanced = find_max_buy_eat_balanced(b)\n    if max_buy_eat_balanced == -1:\n        return \"forever\"\n    else:\n        return str(max_buy_eat_balanced)"
    },
    {
        "number": 3467,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    tram_stops = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, t0, p, d = map(int, stdin.split())\n        tram_stops[u].append((v, t0, p, d))\n        tram_stops[v].append((u, t0 + p + d, p, d))\n\n    def find_earliest_arrival(tram_stops: List[List[Tuple[int, int, int, int]]]) -> int:\n        earliest_arrival = float('inf')\n        for stop in tram_stops:\n            if stop:\n                earliest_arrival = min(earliest_arrival, stop[0][1])\n        return earliest_arrival\n\n    earliest_arrival = find_earliest_arrival(tram_stops)\n    if earliest_arrival > s:\n        return 'impossible'\n    return str(earliest_arrival)"
    },
    {
        "number": 3468,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    apps = []\n    for _ in range(n):\n        d, s = map(int, stdin.split())\n        apps.append((d, s))\n\n    def is_valid(app, used_apps):\n        return app[0] <= c - sum(app[1] for app in used_apps)\n\n    def max_valid_apps(used_apps):\n        max_valid = 0\n        for app in apps:\n            if is_valid(app, used_apps):\n                max_valid += 1\n        return max_valid\n\n    def max_valid_order(used_apps):\n        max_valid = 0\n        for i, app in enumerate(apps):\n            if is_valid(app, used_apps):\n                max_valid = max(max_valid, i + 1)\n        return max_valid\n\n    used_apps = []\n    max_valid = max_valid_apps(used_apps)\n    max_valid_order = max_valid_order(used_apps)\n\n    if max_valid == 0:\n        return \"\"\n\n    for i in range(n):\n        if is_valid(apps[i], used_apps):\n            used_apps.append(apps[i])\n            max_valid = max(max_valid, max_valid_apps(used_apps))\n            max_valid_order = max(max_valid_order, max_valid_order(used_apps))\n            if max_valid == n:\n                break\n\n    return str(max_valid) + \"\\n\" + \" \".join(str(i) for i in range(1, max_valid_order))"
    },
    {
        "number": 3469,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g, k, p = stdin.split()\n    g, k = g.upper(), k.upper()\n    if 'H' not in g or 'H' not in k or 'T' not in g or 'T' not in k:\n        return 'Invalid input'\n\n    def flip_coin(p: float) -> str:\n        return 'H' if random() < p else 'T'\n\n    s = ''\n    for _ in range(10**100):\n        s += flip_coin(float(p))\n\n    if g in s and k in s:\n        return 'Draw'\n    elif g in s:\n        return 'Gon'\n    else:\n        return 'Killua'"
    },
    {
        "number": 3470,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    mines = set()\n    for i in range(1, 4 * n + 4):\n        if i % n == 0 or i % n == n - 1:\n            mines.add(i)\n    safe_cells = [i for i in range(1, 4 * n + 4) if i not in mines]\n    print(len(safe_cells))\n    print(\" \".join(map(str, safe_cells)))\n    return \"\""
    },
    {
        "number": 3471,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, *a = map(int, stdin.split())\n    Q = int(stdin.split()[1])\n    queries = [tuple(map(int, stdin.split())) for _ in range(Q)]\n\n    def xorbonacci(n: int) -> int:\n        if n == 1:\n            return a[0]\n        elif n == 2:\n            return a[0] ^ a[1]\n        else:\n            return xorbonacci(n - 1) ^ xorbonacci(n - 2) ^ xorbonacci(n - 3)\n\n    def query(l: int, r: int) -> int:\n        return xorbonacci(r) ^ xorbonacci(r - 1) ^ xorbonacci(r - 2) ^ xorbonacci(r - 3) ^ xorbonacci(r - 4)\n\n    return \"\\n\".join(map(str, [query(l, r) for l, r in queries]))\n"
    },
    {
        "number": 3472,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, N = map(int, stdin.split())\n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        lines.append((x1, y1, x2, y2))\n    lines.sort(key=lambda x: (x[0], x[1]))\n    max_area = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            max_area = max(max_area, (lines[i][2] - lines[i][0]) * (lines[j][3] - lines[j][1]))\n    return str(max_area)"
    },
    {
        "number": 3473,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Z, F = map(int, stdin.split())\n    forbidden_dates = []\n    for _ in range(F):\n        year, month, day = map(int, stdin.split())\n        forbidden_dates.append(datetime(year, month, day))\n\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        return 31 if month in [4, 6, 9, 11] else 30\n\n    def days_in_year(year: int) -> int:\n        return days_in_month(year, 1)\n\n    def days_since_start_of_year(year: int) -> int:\n        return days_in_month(year, 1) + (year - 1) * 365\n\n    def days_since_start_of_month(year: int, month: int) -> int:\n        return days_in_month(year, month) + days_since_start_of_year(year)\n\n    def days_since_start_of_week(year: int, month: int, day: int) -> int:\n        return (days_since_start_of_month(year, month) + day - 1) % 7\n\n    def is_friday(year: int, month: int, day: int) -> bool:\n        return days_since_start_of_week(year, month, day) == 4\n\n    def is_thursday(year: int, month: int, day: int) -> bool:\n        return days_since_start_of_week(year, month, day) == 3\n\n    def is_sunday(year: int, month: int, day: int) -> bool:\n        return days_since_start_of_week(year, month, day) == 0\n\n    def is_saturday(year: int, month: int, day: int) -> bool:\n        return days_since_start_of_week(year, month, day) == 6\n\n    def is_thanksgiving(year: int) -> bool:\n        return is_thursday(year, 10, 1)\n\n    def is_forbidden_date(year: int, month: int, day: int) -> bool:\n        return any(\n            forbidden_date.year == year and forbidden_date.month == month and forbidden_date.day == day\n            for forbidden_date in forbidden_dates\n        )\n\n    def surprise_penalty(year: int) -> int:\n        if is_thanksgiving(year):\n            return 0\n        if is_sunday(year, 10, 1):\n            return 0\n        if is_saturday(year, 10, 1):\n            return 0\n        if is_sunday(year, 10, 25):\n            return 0\n        if is_saturday(year, 10, 25):\n            return 0\n        if is_sunday(year, 10, 31):\n            return 0\n        if is_saturday(year, 10, 31):\n            return 0\n        if is_sunday(year, 11, 01):\n            return 0\n        if is_saturday(year, 11, 01):\n            return 0\n        if is_sunday(year, 11, 07):\n            return 0\n        if is_saturday(year, 11, 07):\n            return 0\n        if is_sunday(year, 11, 13):\n            return 0\n        if is_saturday(year, 11, 13):\n            return 0\n        if is_sunday(year, 11, 19):\n            return 0\n        if is_saturday(year, 11, 19):\n            return 0\n        if is_sunday(year, 11, 25):\n            return 0\n        if is_saturday(year, 11, 25):\n            return 0\n        if is_sunday(year, 11, 31):\n            return 0\n        if is_saturday(year, 11, 31):\n            return 0\n        if is_s"
    },
    {
        "number": 3474,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reflect(x: float, y: float, x0: float, y0: float, x1: float, y1: float) -> float:\n        return (x - x0) * (y1 - y0) - (y - y0) * (x1 - x0)\n\n    def reflect_y(y: float, y0: float, y1: float) -> float:\n        return (y1 - y0) * (y - y0) / (y1 - y0)\n\n    def reflect_x(x: float, x0: float, x1: float) -> float:\n        return (x1 - x0) * (x - x0) / (x1 - x0)\n\n    def reflect_xy(x: float, y: float, x0: float, y0: float, x1: float, y1: float) -> Tuple[float, float]:\n        x_reflected = reflect(x, y, x0, y0, x1, y1)\n        y_reflected = reflect_y(y, y0, y1)\n        return x_reflected, y_reflected\n\n    def reflect_y_range(y0: float, y1: float) -> List[float]:\n        return [reflect_y(y, y0, y1) for y in range(y0, y1 + 1)]\n\n    def reflect_x_range(x0: float, x1: float) -> List[float]:\n        return [reflect_x(x, x0, x1) for x in range(x0, x1 + 1)]\n\n    def reflect_xy_range(x0: float, y0: float, x1: float, y1: float) -> List[Tuple[float, float]]:\n        return [(reflect_x(x, x0, x1), reflect_y(y, y0, y1)) for x in range(x0, x1 + 1) for y in range(y0, y1 + 1)]\n\n    def reflect_xy_ranges(x0s: List[float], y0s: List[float], x1s: List[float], y1s: List[float]) -> List[Tuple[float, float]]:\n        return [(reflect_x(x, x0, x1), reflect_y(y, y0, y1)) for x0, x1, y0, y1 in zip(x0s, x1s, y0s, y1s)]\n\n    def reflect_xy_ranges_with_infinities(x0s: List[float], y0s: List[float], x1s: List[float], y1s: List[float]) -> List[Tuple[float, float]]:\n        return [(reflect_x(x, x0, x1), reflect_y(y, y0, y1)) for x0, x1, y0, y1 in zip(x0s, x1s, y0s, y1s) if x0!= x1 or y0!= y1]\n\n    def reflect_xy_ranges_with_infinities_and_mirror_hit(x0s: List[float], y0s: List[float], x1s: List[float], y1s: List[float]) -> List[Tuple[float, float]]:\n        return [(reflect_x(x, x0, x1), reflect_y(y, y0, y1)) for x0, x1, y0, y1 in zip(x0s, x1s, y0s, y1s) if x0!= x1 or y0!= y1 and reflect_y(y, y0, y1) < 0]\n\n    def reflect_xy_ranges_with_infinities_and_mirror_hit_and_mirror_miss(x0s: List[float], y0s: List[float], x1s: List[float], y1s: List[float]) -> List[Tuple[float, float]]:\n        return [(reflect_x(x, x0, x1), reflect_y(y, y0, y1)) for x0, x1, y0, y1 in zip(x0s, x1s, y0s, y1s) if x0!= x1 or y0!= y1 and reflect_y(y, y0, y1) >= 0]\n\n    def reflect_xy_ranges_with_infinities_and_mirror_hit_and_mirror_miss_and_mirror_hit(x0s: List[float"
    },
    {
        "number": 3475,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[Tuple[int, int]], List[Tuple[int, int]]]:\n        n, t = map(int, stdin.split())\n        d_min, a = map(int, stdin.split())\n        d_list = []\n        h_list = []\n        for _ in range(n - 1):\n            d, h = map(int, stdin.split())\n            d_list.append((d, h))\n            h_list.append((d, h))\n        return n, t, d_min, a, d_list, h_list\n\n    def is_valid_itinerary(d_list: List[Tuple[int, int]], h_list: List[Tuple[int, int]], d_min: int, a: int) -> bool:\n        total_distance = sum(d[0] for d in d_list)\n        if total_distance < d_min:\n            return False\n        heading_range = max(h[1] for h in h_list) - min(h[1] for h in h_list)\n        if heading_range > a:\n            return False\n        return True\n\n    def find_valid_itineraries(n: int, t: int, d_min: int, a: int, d_list: List[Tuple[int, int]], h_list: List[Tuple[int, int]]) -> List[List[int]]:\n        itineraries = []\n        for i in range(t):\n            valid_itineraries = []\n            for j in range(n - 1):\n                if is_valid_itinerary(d_list[:j] + [(d_list[j][0], (h_list[j][1] + 1) % 360000)], h_list[:j] + [(h_list[j][0], (h_list[j][1] + 1) % 360000)], d_min, a):\n                    valid_itineraries.append(j)\n            if valid_itineraries:\n                itineraries.append(valid_itineraries)\n        return itineraries\n\n    def count_valid_itineraries(itineraries: List[List[int]]) -> int:\n        count = 0\n        for it in itineraries:\n            count += len(it)\n        return count\n\n    n, t, d_min, a, d_list, h_list = read_input()\n    itineraries = find_valid_itineraries(n, t, d_min, a, d_list, h_list)\n    count = count_valid_itineraries(itineraries)\n    if count == 0:\n        return \"IMPOSSIBLE\"\n    return str(count)"
    },
    {
        "number": 3476,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = []\n    for _ in range(R):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    def rotate_row(i: int, k: int) -> None:\n        matrix[i] = matrix[i][k:] + matrix[i][:k]\n\n    def rotate_col(j: int, k: int) -> None:\n        for i in range(R):\n            matrix[i][j], matrix[i][-k] = matrix[i][-k], matrix[i][j]\n\n    def neg_row(i: int) -> None:\n        matrix[i] = [-x for x in matrix[i]]\n\n    def neg_col(j: int) -> None:\n        for i in range(R):\n            matrix[i][j] = -matrix[i][j]\n\n    T = 0\n    while T < 5 * R * C:\n        operation, *args = stdin.split()\n        if operation == \"rotR\":\n            i, k = map(int, args)\n            rotate_row(i - 1, k - 1)\n        elif operation == \"rotS\":\n            j, k = map(int, args)\n            rotate_col(j - 1, k - 1)\n        elif operation == \"negR\":\n            i = int(args[0]) - 1\n            neg_row(i)\n        elif operation == \"negS\":\n            j = int(args[0]) - 1\n            neg_col(j)\n        T += 1\n\n    max_sum = max(sum(row) for row in matrix)\n    return f\"{max_sum} {T}\""
    },
    {
        "number": 3477,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    energies = list(map(int, stdin.split()))\n    energies.sort()\n    min_sum = float('inf')\n    for i in range(m):\n        sum_i = 0\n        for j in range(n):\n            sum_i += energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] * energies[j] *"
    },
    {
        "number": 3478,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    cities.append(2)\n    cities.append(1)\n\n    def bfs(start: int) -> list:\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            city, path = queue.pop(0)\n            if city not in visited:\n                visited.add(city)\n                for neighbor in cities[cities.index(city) + 1:]:\n                    if neighbor not in visited and neighbor not in path:\n                        queue.append((neighbor, path + [neighbor]))\n        return visited\n\n    def dfs(start: int, visited: set) -> list:\n        if start in visited:\n            return []\n        visited.add(start)\n        result = [start]\n        for neighbor in cities[cities.index(start) + 1:]:\n            if neighbor not in visited:\n                result += dfs(neighbor, visited)\n        return result\n\n    def is_connected(city1: int, city2: int) -> bool:\n        return city1 in bfs(city1) and city2 in bfs(city2)\n\n    def is_connected_to_remaining_cities(city: int) -> bool:\n        return city in bfs(city)\n\n    def is_connected_to_all_cities(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2)\n\n    def is_connected_to_all_cities_except_two(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1)\n\n    def is_connected_to_all_cities_except_one(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1)\n\n    def is_connected_to_all_cities_except_one_and_two(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2)\n\n    def is_connected_to_all_cities_except_two_and_one(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2)\n\n    def is_connected_to_all_cities_except_one_and_two_and_three(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2) and city not in bfs(3)\n\n    def is_connected_to_all_cities_except_two_and_one_and_three(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2) and city not in bfs(3)\n\n    def is_connected_to_all_cities_except_one_and_two_and_three_and_four(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2) and city not in bfs(3) and city not in bfs(4)\n\n    def is_connected_to_all_cities_except_two_and_one_and_three_and_four(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2) and city not in bfs(3) and city not in bfs(4)\n\n    def is_connected_to_all_cities_except_one_and_two_and_three_and_four_and_five(city: int) -> bool:\n        return city in bfs(city) and city in bfs(2) and city not in bfs(1) and city not in bfs(2) and city not in bfs(3) and city not in bfs(4) and city not in bfs(5)\n\n    def is_connected_to_all_cities_except_two_and_one_and_three_and_four_and_five(city: int) -> bool:\n        return city in bfs(city) and city in bfs("
    },
    {
        "number": 3479,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    times = list(map(int, stdin.split()))\n\n    def find_min_time(start_time: int, end_time: int) -> int:\n        min_time = float('inf')\n        for i in range(k):\n            if i == 0:\n                time_taken = start_time\n            else:\n                time_taken = end_time - start_time\n            if time_taken < min_time:\n                min_time = time_taken\n        return min_time\n\n    min_time = float('inf')\n    for i in range(n):\n        min_time = min(min_time, find_min_time(times[i], times[i]))\n\n    return str(min_time)"
    },
    {
        "number": 3480,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    lines = [line.strip() for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split(' ') for line in lines]\n    lines = [line.split('_') for line in lines]\n    lines = [line.split(',') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=') for line in lines]\n    lines = [line.split('=')"
    },
    {
        "number": 3481,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    G, K, R = map(int, stdin.split())\n    roads = [tuple(map(int, stdin.split())) for _ in range(R)]\n    gigs = [tuple(map(int, stdin.split())) for _ in range(G)]\n\n    def bellman_ford(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        for _ in range(len(graph) - 1):\n            for u in range(len(graph)):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def dijkstra(graph, start, end):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heappush(pq, (dist[v], v))\n        return dist[end]\n\n    def max_profit(gigs, roads):\n        graph = [[] for _ in range(K + 1)]\n        for u, v, w in roads:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n\n        dist = bellman_ford(graph, 1)\n        max_profit = 0\n        for u, v, w in gigs:\n            if dist[u] == float('inf') or dist[v] == float('inf'):\n                continue\n            max_profit = max(max_profit, w * (dist[v] - dist[u]))\n        return max_profit\n\n    return str(max_profit(gigs, roads))"
    },
    {
        "number": 3482,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, p = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n    t, n = map(int, stdin.split())\n    trips = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        trips.append((a, b))\n\n    dp = [float('inf')] * (t + 1)\n    dp[0] = 0\n\n    for i in range(1, t + 1):\n        for j in range(l):\n            if i >= d[j]:\n                dp[i] = min(dp[i], dp[i - d[j]] + p[j])\n\n    return str(dp[t])"
    },
    {
        "number": 3483,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    weights = list(map(int, stdin.split()[1:]))\n    max_weight = max(weights)\n    min_weight = min(weights)\n    distinct_weights = len(set(weights))\n    expected_weight = sum(weights) / len(weights)\n    return f\"{max_weight} {min_weight} {distinct_weights} {expected_weight:.4f}\""
    },
    {
        "number": 3484,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    grid = []\n    for _ in range(k):\n        row = list(map(int, stdin.split()))\n        grid.append(row)\n    for i in range(k, n * n):\n        row = []\n        for j in range(n):\n            row.append(i + 1)\n        grid.append(row)\n    return \"yes\" if solve(grid) else \"no\"\n\ndef"
    },
    {
        "number": 3485,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n\n    def count_cards(cards: list) -> int:\n        count = 0\n        for card in cards:\n            if card < 0:\n                count += 1\n        return count\n\n    def play_game(cards: list) -> float:\n        total_sum = 0\n        count = 0\n        for card in cards:\n            total_sum += card\n            count += 1\n            if card < 0:\n                count -= 1\n                if count == 0:\n                    return total_sum / count\n        return 0\n\n    stop_counting = False\n    start_counting = False\n    max_payout = 0\n\n    for card in cards:\n        if not stop_counting and not start_counting:\n            max_payout = max(max_payout, play_game(cards[:card]))\n        elif stop_counting and not start_counting:\n            max_payout = max(max_payout, play_game(cards[:card]))\n        elif not stop_counting and start_counting:\n            max_payout = max(max_payout, play_game(cards[card:]))\n        elif stop_counting and start_counting:\n            max_payout = max(max_payout, play_game(cards[card:]))\n\n        if card < 0:\n            stop_counting = True\n        else:\n            start_counting = True\n\n    return str(max_payout)"
    },
    {
        "number": 3486,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = list(map(int, stdin.split()[1:]))\n    students.sort()\n    MOD = 10**9 + 7\n\n    def dfs(start: int, end: int, count: int) -> int:\n        if start == end:\n            return 1\n        if count == 0:\n            return 0\n\n        res = 0\n        for i in range(start, end):\n            if students[i] % students[start]!= 0:\n                res += dfs(start, i, count - 1)\n                res %= MOD\n        return res\n\n    return str(dfs(0, n - 1, n))"
    },
    {
        "number": 3487,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    v, a = map(float, stdin.split())\n\n    pipes = []\n    for _ in range(p):\n        j, k, c = map(int, stdin.split())\n        pipes.append((j, k, c))\n\n    def find_max_value(j, k, c, f, w):\n        def is_valid(f, w):\n            return v * f + w <= c\n\n        def is_valid_for_node(f, w, node):\n            return is_valid(f, w) and (node == j or node == k)\n\n        def is_valid_for_source(f, w, node):\n            return is_valid(f, w) and node == 2\n\n        def is_valid_for_destination(f, w, node):\n            return is_valid(f, w) and node == 3\n\n        def is_valid_for_pipe(f, w, node):\n            return is_valid_for_node(f, w, node) and is_valid_for_source(f, w, node) and is_valid_for_destination(f, w, node)\n\n        def is_valid_for_location(f, w, node):\n            return is_valid_for_node(f, w, node) and is_valid_for_source(f, w, node) and is_valid_for_destination(f, w, node)\n\n        def is_valid_for_pipe_and_location(f, w, node):\n            return is_valid_for_pipe(f, w, node) and is_valid_for_location(f, w, node)\n\n        def is_valid_for_pipe_and_location_and_capacity(f, w, node, capacity):\n            return is_valid_for_pipe_and_location(f, w, node) and f + w <= capacity\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid(f, w, node, capacity, liquid):\n            return is_valid_for_pipe_and_location_and_capacity(f, w, node, capacity) and liquid <= f + w\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate(f, w, node, capacity, liquid, liquid_rate):\n            return is_valid_for_pipe_and_location_and_capacity_and_liquid(f, w, node, capacity, liquid) and liquid_rate <= f\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value(f, w, node, capacity, liquid, liquid_rate, liquid_value):\n            return is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate(f, w, node, capacity, liquid, liquid_rate) and liquid_value <= f * w\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value_and_liquid_rate_value(f, w, node, capacity, liquid, liquid_rate, liquid_value, liquid_rate_value):\n            return is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value(f, w, node, capacity, liquid, liquid_rate, liquid_value) and liquid_rate_value <= f * w\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value_and_liquid_rate_value_and_liquid_value_rate(f, w, node, capacity, liquid, liquid_rate, liquid_value, liquid_rate_value, liquid_value_rate):\n            return is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value_and_liquid_rate_value(f, w, node, capacity, liquid, liquid_rate, liquid_value, liquid_rate_value) and liquid_value_rate <= f * w\n\n        def is_valid_for_pipe_and_location_and_capacity_and_liquid_and_liquid_rate_and_liquid_value_and_liquid_rate_value_and_liquid_value_rate_and_liquid_value_value(f, w, node, capacity, liquid,"
    },
    {
        "number": 3488,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        vertices.append((x, y))\n\n    sightings = []\n    for _ in range(k):\n        x, y = map(int, stdin.split())\n        sightings.append((x, y))\n\n    def is_inside(p: tuple, polygon: list) -> bool:\n        x, y = p\n        return all(x < polygon[i][0] or (x == polygon[i][0] and y < polygon[i][1]) for i in range(len(polygon)))\n\n    def is_convex(polygon: list) -> bool:\n        return all(polygon[i][0] * (polygon[i + 1][1] - polygon[i][1]) < polygon[i + 1][0] * (polygon[i][1] - polygon[i + 1][1]) for i in range(len(polygon) - 1))\n\n    def convex_hull(points: list) -> list:\n        if len(points) <= 3:\n            return points\n\n        def quick_hull(points: list) -> list:\n            if len(points) <= 3:\n                return points\n\n            pivot = points[0]\n            left = [p for p in points[1:] if p[0] < pivot[0]]\n            right = [p for p in points[1:] if p[0] >= pivot[0]]\n\n            return quick_hull(left) + [pivot] + quick_hull(right)\n\n        return quick_hull(points)\n\n    def count_vertices(polygon: list) -> int:\n        return len(set(polygon))\n\n    convex_polygon = convex_hull(vertices)\n    if not is_convex(convex_polygon):\n        convex_polygon = convex_hull(vertices)\n\n    for sighting in sightings:\n        if is_inside(sighting, convex_polygon):\n            convex_polygon.append(sighting)\n\n    return str(count_vertices(convex_polygon))"
    },
    {
        "number": 3489,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for a, b in map(lambda x: map(int, x.split()), stdin.split()[1:].split('\\n')):\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def bfs(start: int) -> list:\n        queue = [start]\n        visited = set()\n        while queue:\n            current = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                queue.extend(graph[current])\n        return visited\n\n    safe_routes = set(bfs(h))\n    min_routes = len(safe_routes)\n    for i in range(n):\n        if i not in safe_routes:\n            min_routes = min(min_routes, len(bfs(i)))\n\n    return str(min_routes) + '\\n' + '\\n'.join(map(lambda x: str(x) +'' + str(x), safe_routes))"
    },
    {
        "number": 3490,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    brooms = []\n    for _ in range(n):\n        x, y, r = map(float, stdin.split()[1:])\n        brooms.append((x, y, r))\n    brooms.sort(key=lambda x: (x[1], x[0]))\n\n    def rotate(x, y, r):\n        x, y = x * cos(r) - y * sin(r), x * sin(r) + y * cos(r)\n        return x, y\n\n    def check_collisions(brooms):\n        for i in range(len(brooms) - 1):\n            for j in range(i + 1, len(brooms)):\n                x1, y1, r1 = brooms[i]\n                x2, y2, r2 = brooms[j]\n                x1, y1 = rotate(x1, y1, r1)\n                x2, y2 = rotate(x2, y2, r2)\n                if x1 == x2 and y1 == y2:\n                    return True\n        return False\n\n    if check_collisions(brooms):\n        return \"crash\"\n    else:\n        return \"ok\""
    },
    {
        "number": 3491,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    staircases = set()\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        staircases.add((a, b))\n\n    for i in range(m, 2 * m):\n        a, b = map(int, stdin.split())\n        staircases.add((a, b))\n\n    red_buttons = set()\n    green_buttons = set()\n\n    for a, b in staircases:\n        if a not in red_buttons and b not in red_buttons:\n            red_buttons.add(a)\n        if a not in green_buttons and b not in green_buttons:\n            green_buttons.add(a)\n\n    red_buttons = sorted(red_buttons)\n    green_buttons = sorted(green_buttons)\n\n    result = []\n    for i in range(n):\n        if i in red_buttons:\n            result.append(\"R \" + str(i))\n        elif i in green_buttons:\n            result.append(\"G \" + str(i))\n        else:\n            result.append(\"N \" + str(i))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3492,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    states, raw_materials, factories, transportations = map(int, stdin.split())\n    raw_materials_sites = stdin.split()[1:raw_materials+1]\n    factories_sites = stdin.split()[raw_materials+1:raw_materials+factories+1]\n    transportation_companies = stdin.split()[raw_materials+factories+1:]\n\n    # Create a graph to represent the transportation companies\n    graph = [[] for _ in range(transportations)]\n    for i in range(transportations):\n        n, *states = map(int, transportation_companies[i].split())\n        graph[i] = states[:n]\n\n    # Bellman-Ford algorithm to find the shortest path between each pair of states\n    distances = [float('inf')] * (states + 1)\n    distances[1] = 0\n    for i in range(states):\n        for j in range(transportations):\n            for state in graph[j]:\n                if distances[state]!= float('inf') and distances[state] + 1 < distances[i]:\n                    distances[i] = distances[state] + 1\n\n    # Find the maximum number of factories that can be supplied with raw materials\n    max_factories = 0\n    for i in range(raw_materials):\n        for j in range(factories):\n            if distances[factories_sites[j]] + 1 < distances[raw_materials_sites[i]]:\n                max_factories = max(max_factories, j + 1)\n\n    return str(max_factories)"
    },
    {
        "number": 3493,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, buttons = map(int, stdin.split())\n    buttons = [list(line.strip()) for line in stdin.splitlines()[1:]]\n    buttons = [list(map(int, line)) for line in buttons]\n\n    def find_max_groups(buttons):\n        groups = []\n        for i in range(len(buttons)):\n            group = []\n            for j in range(len(buttons)):\n                if buttons[i][j] == 1:\n                    group.append(j)\n            groups.append(group)\n        return groups\n\n    def find_max_groups_with_duplicates(buttons):\n        groups = []\n        for i in range(len(buttons)):\n            group = []\n            for j in range(len(buttons)):\n                if buttons[i][j] == 1:\n                    group.append(j)\n            groups.append(group)\n        return groups\n\n    groups = find_max_groups(buttons)\n    max_groups = find_max_groups_with_duplicates(buttons)\n\n    max_groups_count = 0\n    max_groups_with_duplicates_count = 0\n\n    for group in max_groups:\n        max_groups_count = max(max_groups_count, len(group))\n\n    for group in max_groups_with_duplicates:\n        max_groups_with_duplicates_count = max(max_groups_with_duplicates_count, len(group))\n\n    return str(max_groups_count) + '\\n' +''.join(map(str, max_groups_with_duplicates[0])) + '\\n' +''.join(map(str, max_groups_with_duplicates[1]))"
    },
    {
        "number": 3494,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S = map(int, stdin.split()[0].split())\n    matrix = [list(row) for row in stdin.split()[1:]]\n    G = int(stdin.split()[2])\n\n    distances = []\n    for i in range(G):\n        apple_row, apple_col = map(int, stdin.split()[i+3].split())\n        apple_tree = matrix[apple_row-1][apple_col-1]\n        min_distance = float('inf')\n        min_tree = None\n        for row in range(R):\n            for col in range(S):\n                if matrix[row][col] == apple_tree:\n                    distance = ((row - apple_row)**2 + (col - apple_col)**2)**0.5\n                    if distance < min_distance:\n                        min_distance = distance\n                        min_tree = matrix[row][col]\n        distances.append(min_distance**2)\n\n    return '\\n'.join(map(str, distances))"
    },
    {
        "number": 3495,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    x, y = map(float, stdin.split())\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def closest_point(p, points):\n        min_dist = float('inf')\n        closest = None\n        for q in points:\n            dist = distance(p, q)\n            if dist < min_dist:\n                min_dist = dist\n                closest = q\n        return closest\n\n    def closest_points(points):\n        closest = [closest_point(p, points) for p in points]\n        return closest\n\n    def closest_points_to_target(points, x, y):\n        closest = closest_points(points)\n        closest_to_target = [closest_point(p, [(x, y)]) for p in closest]\n        return closest_to_target\n\n    def closest_points_to_target_with_length(points, x, y):\n        closest = closest_points_to_target(points, x, y)\n        closest_with_length = [(distance(p, (x, y)), p) for p in closest]\n        closest_with_length.sort()\n        return closest_with_length\n\n    def closest_points_to_target_with_length_and_angle(points, x, y):\n        closest = closest_points_to_target_with_length(points, x, y)\n        closest_with_angle = [(distance(p, (x, y)), p, angle(p, (x, y))) for p in closest]\n        closest_with_angle.sort()\n        return closest_with_angle\n\n    def angle(p1, p2):\n        return (p2[0] - p1[0]) * (p2[1] + p1[1]) - (p2[1] - p1[1]) * (p2[0] + p1[0])\n\n    points = [(0, 0)] + [(0, 0)] * (n - 1) + [(x, y)]\n    closest_with_angle = closest_points_to_target_with_length_and_angle(points, x, y)\n\n    return '\\n'.join(f'{x:.4f} {y:.4f}' for _, _, angle in closest_with_angle)\n"
    },
    {
        "number": 3496,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    def explodification(k):\n        if k <= n:\n            return a[k - 1]\n        else:\n            i, j = 1, k - i\n            return explodification(i) + explodification(j)\n\n    result = []\n    for i in range(1, q + 1):\n        result.append(explodification(k[i - 1]))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3497,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        for v in range(len(graph)):\n            if graph[u][v] and v not in visited:\n                if dfs(v, visited) == 1:\n                    return 1\n        return 0\n\n    def bfs(u: int) -> int:\n        queue = deque([u])\n        visited = set()\n        visited.add(u)\n        while queue:\n            v = queue.popleft()\n            for w in range(len(graph)):\n                if graph[v][w] and w not in visited:\n                    visited.add(w)\n                    queue.append(w)\n        return len(visited)\n\n    def count_wolves(u: int) -> int:\n        return bfs(u) - 1\n\n    def escape_count(pigs: List[int]) -> int:\n        graph = [[0] * (len(pigs) + 1) for _ in range(len(pigs) + 1)]\n        for u, v in edges:\n            graph[u][v] = 1\n            graph[v][u] = 1\n\n        for u, v in edges:\n            if u in pigs and v not in pigs:\n                graph[u][v] = 0\n                graph[v][u] = 0\n\n        wolves = 0\n        for pig in pigs:\n            if pig in pigs:\n                wolves += count_wolves(pig)\n\n        return wolves\n\n    def min_wolves(pigs: List[int]) -> int:\n        min_wolves = float('inf')\n        for pig in pigs:\n            min_wolves = min(min_wolves, escape_count([pig]))\n        return min_wolves\n\n    def min_wolves_helper(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper(pigs, wolves - 1)\n\n    def min_wolves_helper_2(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_2(pigs, wolves - 1)\n\n    def min_wolves_helper_3(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_3(pigs, wolves - 1)\n\n    def min_wolves_helper_4(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_4(pigs, wolves - 1)\n\n    def min_wolves_helper_5(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_5(pigs, wolves - 1)\n\n    def min_wolves_helper_6(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_6(pigs, wolves - 1)\n\n    def min_wolves_helper_7(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_7(pigs, wolves - 1)\n\n    def min_wolves_helper_8(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0\n        if escape_count(pigs) == wolves:\n            return 1\n        return min_wolves_helper_8(pigs, wolves - 1)\n\n    def min_wolves_helper_9(pigs: List[int], wolves: int) -> int:\n        if wolves == 0:\n            return 0"
    },
    {
        "number": 3498,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tasks = []\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        task = line.split()\n        tasks.append((int(task[0]), int(task[1]), int(task[2]), task[3:]))\n\n    tasks.sort(key=lambda x: (x[1], x[0]))\n\n    processor_clock = 0\n    current_priorities = {task[0]: task[1] for task in tasks}\n    blocked_tasks = set()\n\n    for task in tasks:\n        if task[0] <= processor_clock and not all(instruction[0]!= 'C' for instruction in task[3]):\n            blocked_tasks.update(task[3])\n            current_priorities[task[0]] = max(current_priorities[task[0]], current_priorities[blocked_task])\n        else:\n            for instruction in task[3]:\n                if instruction[0] == 'C':\n                    processor_clock += 1\n                elif instruction[0] == 'L':\n                    blocked_tasks.add(instruction[1])\n                elif instruction[0] == 'U':\n                    blocked_tasks.discard(instruction[1])\n\n    return''.join(str(processor_clock) for task in tasks)"
    },
    {
        "number": 3499,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = stdin.split()[1]\n    MOD = 10**9 + 7\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def count_palindromes(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_palindrome(s[i:j]):\n                    count += 1\n        return count\n\n    def count_subsequences(s: str, t: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                count += count_subsequences(s[i + 1:], t[i + 1:])\n        return count\n\n    def count_palindromic_strings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_palindrome(s[i:j]):\n                    count += count_subsequences(s[i:j], s[i:j])\n        return count\n\n    return str(count_palindromic_strings(S) % MOD)\n"
    },
    {
        "number": 3500,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = []\n    for _ in range(n):\n        cards.append(list(map(int, stdin.split()[1].split())))\n    for i in range(n):\n        for j in range(5):\n            cards[i][j] -= 1\n    for i in range(n):\n        for j in range(5):\n            for k in range(5):\n                if cards[i][j] == cards[i][k] == cards[i][j + k]:\n                    return f\"{i+1} {j+1}\"\n    return \"no ties\""
    },
    {
        "number": 3501,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a1, a2, a3 = map(int, stdin.split()[1:])\n    b1, b2, b3 = map(int, stdin.split()[1:])\n    c1, c2, c3 = map(int, stdin.split()[1:])\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.add((a1, b1, c1))\n            pairs.add((a1, b1, c2))\n            pairs.add((a1, b1, c3))\n            pairs.add((a1, b2, c1))\n            pairs.add((a1, b2, c2))\n            pairs.add((a1, b2, c3))\n            pairs.add((a1, b3, c1))\n            pairs.add((a1, b3, c2))\n            pairs.add((a1, b3, c3))\n            pairs.add((a2, b1, c1))\n            pairs.add((a2, b1, c2))\n            pairs.add((a2, b1, c3))\n            pairs.add((a2, b2, c1))\n            pairs.add((a2, b2, c2))\n            pairs.add((a2, b2, c3))\n            pairs.add((a2, b3, c1))\n            pairs.add((a2, b3, c2))\n            pairs.add((a2, b3, c3))\n            pairs.add((a3, b1, c1))\n            pairs.add((a3, b1, c2))\n            pairs.add((a3, b1, c3))\n            pairs.add((a3, b2, c1))\n            pairs.add((a3, b2, c2))\n            pairs.add((a3, b2, c3))\n            pairs.add((a3, b3, c1))\n            pairs.add((a3, b3, c2))\n            pairs.add((a3, b3, c3))\n\n    return str(len(pairs))"
    },
    {
        "number": 3502,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lights = []\n    for _ in range(n):\n        x, r, g = map(int, stdin.split()[1:])\n        lights.append((x, r, g))\n    lights.sort(key=lambda x: x[0])\n\n    def probability(x: int) -> float:\n        total = 0\n        for i, (light_x, light_r, light_g) in enumerate(lights):\n            if i == 0:\n                total += 1\n            if light_x <= x:\n                total += 1\n            if light_x <= x < light_x + light_r:\n                total += 1\n            if light_x + light_r <= x < light_x + light_r + light_g:\n                total += 1\n            if light_x + light_r + light_g <= x:\n                total += 1\n        return total / (2 * n)\n\n    return f\"{probability(0):.6f}\\n{probability(2019):.6f}\""
    },
    {
        "number": 3503,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:])\n        pairs.append((a, b))\n    pairs.sort()\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for op in \"+-*/\":\n                a, b = pairs[i]\n                c, d = pairs[j]\n                if op == \"+\":\n                    if a + b == c + d:\n                        result.append(f\"{a} {op} {b} = {c + d}\")\n                elif op == \"-\":\n                    if a - b == c - d:\n                        result.append(f\"{a} {op} {b} = {c - d}\")\n                elif op == \"*\":\n                    if a * b == c * d:\n                        result.append(f\"{a} {op} {b} = {c * d}\")\n    if not result:\n        return \"impossible\"\n    return \"\\n\".join(result)"
    },
    {
        "number": 3504,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_droplet_coordinates(droplet_coordinates: List[str]) -> Tuple[int, int]:\n        x, y = map(int, droplet_coordinates.split())\n        return x, y\n\n    def get_sensor_coordinates(sensor_coordinates: List[str]) -> Tuple[int, int]:\n        x1, x2, y = map(int, sensor_coordinates.split())\n        return x1, x2, y\n\n    def is_droplet_hitting_sensor(droplet_coordinates: Tuple[int, int], sensor_coordinates: Tuple[int, int]) -> bool:\n        x1, x2, y = sensor_coordinates\n        return x1 <= droplet_coordinates[0] <= x2 and y == droplet_coordinates[1]\n\n    def get_droplet_disintegration_coordinates(droplet_coordinates: Tuple[int, int], sensor_coordinates: Tuple[int, int]) -> int:\n        x1, x2, y = sensor_coordinates\n        if droplet_coordinates[0] < x1:\n            return y\n        elif droplet_coordinates[0] > x2:\n            return y\n        else:\n            return 0\n\n    def process_droplet(droplet_coordinates: Tuple[int, int], sensor_coordinates: List[str]) -> int:\n        disintegration_coordinates = get_droplet_disintegration_coordinates(droplet_coordinates, get_sensor_coordinates(sensor_coordinates))\n        return disintegration_coordinates\n\n    def process_droplets(droplet_coordinates: List[str], sensor_coordinates: List[str]) -> List[int]:\n        return [process_droplet(get_droplet_coordinates(droplet_coordinates), sensor_coordinates) for _ in range(len(droplet_coordinates))]\n\n    def process_input(input_data: str) -> List[int]:\n        droplet_coordinates, sensor_coordinates = input_data.split('\\n\\n')\n        droplet_coordinates = droplet_coordinates.split('\\n')[1:]\n        sensor_coordinates = sensor_coordinates.split('\\n')[1:]\n        return process_droplets(droplet_coordinates, sensor_coordinates)\n\n    input_data = stdin.strip()\n    output = process_input(input_data)\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3505,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    arr.sort()\n    count = 0\n    for i in range(N - 2):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        for j in range(i + 1, N - 1):\n            if j > i + 1 and arr[j] == arr[j - 1]:\n                continue\n            for k in range(j + 1, N):\n                if k > j + 1 and arr[k] == arr[k - 1]:\n                    continue\n                if arr[i] + arr[j] == arr[k]:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 3506,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, m = map(int, stdin.split())\n    cheerleaders = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        cheerleaders.append((a, b))\n\n    goals_sportify = 0\n    goals_spoilify = 0\n    current_time = 0\n    current_cheerleaders = []\n\n    for a, b in cheerleaders:\n        if a <= current_time <= b:\n            current_cheerleaders.append(a)\n        elif a > current_time:\n            current_time = a\n            current_cheerleaders = [a]\n\n    for i in range(t // 5):\n        if current_cheerleaders:\n            cheerleader = current_cheerleaders.pop(0)\n            goals_sportify += 1\n            goals_spoilify += 1 if current_time - cheerleader >= 5 else 3\n            current_time += 5\n        else:\n            goals_sportify += 1\n            goals_spoilify += 3\n            current_time += 5\n\n    return f\"{goals_sportify} {goals_spoilify}\""
    },
    {
        "number": 3507,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, W, d = map(int, stdin.split())\n    K = 1\n    for i in range(R, W + 1):\n        if i <= d:\n            K *= i\n        else:\n            K *= (i - d)\n    return str((K % (10**9 + 7)) % (10**9 + 7))"
    },
    {
        "number": 3508,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    b = [b[i] for i in range(n)]\n    max_damage = 0\n    max_pillar = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if b[i] + b[j] > b[max_pillar]:\n                max_damage += 1\n                max_pillar = j\n    return str(max_damage) + \" \" + str(max_pillar)"
    },
    {
        "number": 3509,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, t = map(int, stdin.split())\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heappush(pq, (dist[v], v))\n        return dist\n\n    def bellman_ford(start: int) -> int:\n        dist = dijkstra(start)\n        for _ in range(n - 1):\n            for u in range(1, n + 1):\n                for v, w in graph[u]:\n                    if dist[u] + w < dist[v]:\n                        dist[v] = float('inf')\n        return dist[n]\n\n    def min_waiting_time(start: int) -> int:\n        waiting_time = bellman_ford(start)\n        return waiting_time\n\n    return str(min_waiting_time(1))"
    },
    {
        "number": 3510,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    positions = list(stdin.split())\n    n = int(positions[0])\n    positions = positions[1:]\n    positions.sort()\n    options = {}\n    for i in range(n):\n        options[positions[i]] = list(set(stdin.split()[i+1].split()))\n    rounds = []\n    for i in range(n):\n        rounds.append(0)\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    for m in range(l+1, n):\n                        for p in options[positions[i]]:\n                            for q in options[positions[j]]:\n                                for r in options[positions[k]]:\n                                    for s in options[positions[l]]:\n                                        for t in options[positions[m]]:\n                                            for u in options[positions[p]]:\n                                                for v in options[positions[q]]:\n                                                    for w in options[positions[r]]:\n                                                        for x in options[positions[s]]:\n                                                            for y in options[positions[t]]:\n                                                                for z in options[positions[u]]:\n                                                                    for a in options[positions[v]]:\n                                                                        for b in options[positions[w]]:\n                                                                            for c in options[positions[x]]:\n                                                                                for d in options[positions[y]]:\n                                                                                    for e in options[positions[z]]:\n                                                                                        for f in options[positions[a]]:\n                                                                                            for g in options[positions[b]]:\n                                                                                                for h in options[positions[c]]:\n                                                                                                    for i in options[positions[d]]:\n                                                                                                        for j in options[positions[e]]:\n                                                                                                            for k in options[positions[f]]:\n                                                                                                                for l in options[positions[g]]:\n                                                                                                                    for m in options[positions[h]]:\n                                                                                                                        for n in options[positions[i]]:\n                                                                                                                            for o in options[positions[j]]:\n                                                                                                                                for p in options[positions[k]]:\n                                                                                                                                    for q in options[positions[l]]:\n                                                                                                                                        for r in options[positions[m]]:\n                                                                                                                                            for s in options[positions[n]]:\n                                                                                                                                                for t in options[positions[o]]:\n                                                                                                                                                    for u in options[positions[p]]:\n                                                                                                                                                        for v in options[positions[q]]:\n                                                                                                                                                            for w in options[positions[r]]:\n                                                                                                                                                                for x in options[positions[s]]:\n                                                                                                                                                                    for y in options[positions[t]]:\n                                                                                                                                                                        for z in options[positions[u]]:\n                                                                                                                                                                            for a in options[positions[v]]:\n                                                                                                                                                                                for b in options[positions[w]]:\n                                                                                                                                                                                    for c in options[positions[x]]:\n                                                                                                                                                                                        for d in options[positions[y]]:\n                                                                                                                                                                                            for e in options[positions[z]]:\n                                                                                                                                                                                                for f in options[positions[a]]:\n                                                                                                                                                                                                    for g in options[positions[b]]:\n                                                                                                                                                                                                        for h in options[positions[c]]:\n                                                                                                                                                                                                            for i in options[positions[d]]:\n                                                                                                                                                                                                                for j in options[positions[e]]:\n                                                                                                                                                                                                                    for k in options[positions[f]]:\n                                                                                                                                                                                                                        for l in options[positions[g]]:\n                                                                                                                                                                                                                            for m in options[positions[h]]:\n                                                                                                                                                                                                                                for n in options[positions[i]]:\n                                                                                                                                                                                                                                    for o in options[positions[j]]:\n                                                                                                                                                                                                                                        for p in options[positions[k]]:\n                                                                                                                                                                                                                                                for q in options[positions[l]]:\n                                                                                                                                                                                                                                                    for r in options[positions[m]]:\n                                                                                                                                                                                                                                                        for s in options[positions[n]]:\n                                                                                                                                                                                                                                                            for t in options[positions[o]]:\n                                                                                                                                                                                                                                                                for u in options[positions[p]]:\n                                                                                                                                                                                                                                                                    for v in options[positions[q]]:\n                                                                                                                                                                                                                                                                        for w in options[positions[r]]:\n                                                                                                                                                                                                                                                                            for x in options[positions[s]]:\n                                                                                                                                                                                                                                                                                for y in options[positions[t]]:\n                                                                                                                                                                                                                                                                                    for z in options[positions[u]]:\n                                                                                                                                                                                                                                                                                        for a in options[positions[v]]:\n                                                                                                                                                                                                                                                                                            for b in options[positions[w]]:\n                                                                                                                                                                                                                                                                                                for c in options[positions[x]]:\n                                                                                                                                                                                                                                                                                                    for d in options[positions[y]]:\n                                                                                                                                                                                                                                                                                                        for e in options[positions[z]]:\n                                                                                                                                                                                                                                                                                                            for f in options[positions[a]]:\n                                                                                                                                                                                                                                                                                                                for g in options[positions[b]]:\n                                                                                                                                                                                                                                                                                                                    for h in options[positions[c]]:\n                                                                                                                                                                                                                                                                                                                        for i in options[positions[d]]:\n                                                                                                                                                                                                                                                                                                                            for j in options[positions[e]]:\n                                                                                                                                                                                                                                                                                                                                for k in options[positions[f]]:\n                                "
    },
    {
        "number": 3511,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    black_boxes = [0] * N\n    for _ in range(Q):\n        query = list(map(int, stdin.split()))\n        if query[0] == 1:\n            u, v = query[1:]\n            black_boxes[u - 1] += 1\n            black_boxes[v - 1] += 1\n        elif query[0] == 2:\n            A = sum(black_boxes[i] ** 2 for i in range(N))\n            B = (A + 1) ** 2\n            print((A * B) % (10 ** 9 + 7))\n    return \"\""
    },
    {
        "number": 3512,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            graph[i].append((j, int(stdin.split()[j+1])))\n            graph[j].append((i, int(stdin.split()[j+1])))\n    start = int(stdin.split()[n+1])\n    end = int(stdin.split()[n+2])\n    visited = [False] * n\n    visited[start] = True\n    visited[end] = True\n    visited_cities = [start]\n    total_duration = 0\n    while visited_cities!= visited:\n        min_duration = float('inf')\n        min_city = None\n        for city in visited_cities:\n            for neighbor, duration in graph[city]:\n                if not visited[neighbor] and duration < min_duration:\n                    min_duration = duration\n                    min_city = neighbor\n        if min_city is None:\n            break\n        visited[min_city] = True\n        visited_cities.append(min_city)\n        total_duration += min_duration\n    return str(total_duration)"
    },
    {
        "number": 3513,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    k = 0\n    Y = []\n    while k < X:\n        Y.append(k + 1)\n        k += 1\n    Y.sort()\n    return str(len(Y))"
    },
    {
        "number": 3514,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(row) for row in stdin.splitlines()]\n\n    def count_armed_buildings(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if grid[i][j] == 'x':\n                    count += 1\n                    break\n        return count\n\n    def find_armed_building(row: int, col: int) -> int:\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if grid[i][j] == 'x':\n                    return i, j\n        return -1, -1\n\n    def disarm_buildings(row: int, col: int) -> None:\n        armed_buildings = count_armed_buildings(row, col)\n        if armed_buildings == 0:\n            return\n        if armed_buildings == 1:\n            grid[row][col] = '.'\n            return\n        if armed_buildings == 2:\n            grid[row][col] = '.'\n            disarm_buildings(row - 1, col)\n            disarm_buildings(row, col - 1)\n            return\n        if armed_buildings == 3:\n            grid[row][col] = '.'\n            disarm_buildings(row - 1, col)\n            disarm_buildings(row, col - 1)\n            disarm_buildings(row - 1, col - 1)\n            return\n\n    def find_max_buildings() -> int:\n        max_buildings = 0\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == 'x':\n                    disarm_buildings(i, j)\n                    max_buildings = max(max_buildings, count_armed_buildings(i, j))\n        return max_buildings\n\n    return str(find_max_buildings())"
    },
    {
        "number": 3515,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    cities = []\n    for i in range(1, N+1):\n        y, d, r = map(int, stdin.split()[1:])\n        cities.append((y, d, r))\n\n    cities.sort(key=lambda x: x[0])\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (N+1)\n        dist[start] = 0\n        for _ in range(N-1):\n            for i in range(1, N+1):\n                for j in range(1, N+1):\n                    if dist[i]!= float('inf') and dist[i] + cities[i-1][2] + cities[j-1][2] < dist[j]:\n                        dist[j] = dist[i] + cities[i-1][2] + cities[j-1][2]\n        return dist[N]\n\n    def dijkstra(start: int) -> int:\n        dist = [float('inf')] * (N+1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            cost, city = heapq.heappop(pq)\n            if dist[city] < cost:\n                continue\n            for i in range(1, N+1):\n                if dist[city] + cities[i-1][2] < dist[i]:\n                    dist[i] = dist[city] + cities[i-1][2]\n                    heapq.heappush(pq, (dist[i], i))\n        return dist[N]\n\n    def shortest_path(start: int) -> int:\n        return min(bellman_ford(start), dijkstra(start))\n\n    result = []\n    for i in range(1, N):\n        result.append(shortest_path(i))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3516,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    levels = []\n    for i in range(n):\n        x, s = map(int, stdin.split()[1:3])\n        items = list(map(int, stdin.split()[3:]))\n        levels.append((x, s, items))\n\n    def beat_level(level: int, items: List[int]) -> int:\n        total_time = 0\n        for i in range(len(items)):\n            total_time += items[i]\n        return total_time\n\n    def beat_levels(levels: List[Tuple[int, int, List[int]]]) -> int:\n        total_time = 0\n        for level, shortcut, items in levels:\n            if shortcut == 1:\n                total_time += beat_level(level, items)\n            else:\n                total_time += beat_level(level, items[:-1])\n        return total_time\n\n    return str(beat_levels(levels))"
    },
    {
        "number": 3517,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *times = map(int, stdin.split())\n    dependencies = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        a, b = map(int, stdin.split())\n        dependencies[a].append(b)\n        dependencies[b].append(a)\n\n    def dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n        min_time = float('inf')\n        for child in dependencies[node]:\n            min_time = min(min_time, dfs(child, visited))\n        return min_time + times[node]\n\n    return str(dfs(1, set()))"
    },
    {
        "number": 3518,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        p, q, c = map(int, stdin.split())\n        pairs.append((p, q, c))\n\n    def find_friends(p: int, q: int) -> int:\n        for i, (friend_p, friend_q, _) in enumerate(pairs):\n            if friend_p == p and friend_q == q:\n                return i\n        return -1\n\n    def find_groups(p: int, q: int) -> int:\n        groups = set()\n        for i, (friend_p, friend_q, _) in enumerate(pairs):\n            if friend_p == p or friend_p == q or friend_q == p or friend_q == q:\n                groups.add(i)\n        return len(groups)\n\n    def find_min_total_co2(p: int, q: int) -> int:\n        min_co2 = float('inf')\n        for i, (friend_p, friend_q, co2) in enumerate(pairs):\n            if friend_p == p or friend_p == q or friend_q == p or friend_q == q:\n                if find_groups(friend_p, friend_q) == 2:\n                    min_co2 = min(min_co2, co2)\n        return min_co2\n\n    def is_possible(p: int, q: int) -> bool:\n        for i, (friend_p, friend_q, _) in enumerate(pairs):\n            if friend_p == p or friend_p == q or friend_q == p or friend_q == q:\n                if find_groups(friend_p, friend_q) == 2:\n                    return True\n        return False\n\n    min_co2 = float('inf')\n    for p in range(1, n + 1):\n        for q in range(p + 1, n + 1):\n            if is_possible(p, q):\n                min_co2 = min(min_co2, find_min_total_co2(p, q))\n\n    if min_co2 == float('inf'):\n        return 'impossible'\n    else:\n        return str(min_co2)"
    },
    {
        "number": 3519,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    cards = [f\"Card {i}\" for i in range(1, N+1)]\n    shuffled_cards = list(cards)\n    shuffled_cards.sort()\n    turns = 0\n    while len(shuffled_cards) > 1:\n        turns += 1\n        first_card = shuffled_cards.pop(0)\n        second_card = shuffled_cards.pop(0)\n        if first_card == second_card:\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n        else:\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            shuffled_cards.remove(first_card)\n            shuffled_cards.remove(second_card)\n            sh"
    },
    {
        "number": 3520,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, c = map(int, stdin.split())\n    pills = []\n    for _ in range(p):\n        t, x, y = map(int, stdin.split())\n        pills.append((t, x, y))\n    pills.sort(key=lambda x: x[0])\n\n    def age(pill: tuple) -> int:\n        t, x, y = pill\n        return t - c\n\n    max_age = 0\n    for pill in pills:\n        max_age = max(max_age, age(pill))\n\n    return str(max_age)"
    },
    {
        "number": 3521,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    stars = []\n    for i in range(N):\n        T, s, a = map(float, stdin.split()[1:])\n        stars.append((T, s, a))\n    T = 0\n    for i in range(N):\n        T += stars[i][0] * max(0, stars[i][0] - stars[i][1] * distance(stars[i][2], 0))\n    return f\"{T:.6f}\"\n\ndef"
    },
    {
        "number": 3522,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    batteries = list(map(int, stdin.split()))\n    batteries.sort()\n    d = 1\n    while d <= k:\n        if sum(batteries[:n]) <= d:\n            return d\n        d += 1\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3523,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, N1, N5, N10, N25 = map(int, stdin.split())\n    if P > N10 * 10 + N5 * 5 + N1 * 1 + N25 * 25:\n        return \"Impossible\"\n    else:\n        return max(N1, N5, N10, N25)"
    },
    {
        "number": 3524,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    s1 = stdin.strip().split()[1]\n    s2 = stdin.strip().split()[2]\n\n    if len(s)!= len(s1) + len(s2):\n        return \"no\"\n\n    for i in range(len(s1)):\n        if s1[i]!= s[i]:\n            return \"no\"\n\n    for i in range(len(s2)):\n        if s2[i]!= s[len(s1) + i]:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3525,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, b = map(int, stdin.split())\n    s, d = map(int, stdin.split())\n    locks = []\n    for _ in range(l):\n        a, b, x, y = map(int, stdin.split())\n        locks.append((a, b, x, y))\n\n    def is_valid(badge: int) -> bool:\n        for lock in locks:\n            if badge >= lock[2] and badge <= lock[3]:\n                return True\n        return False\n\n    count = 0\n    for i in range(b + 1):\n        if is_valid(i):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3526,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    hints = []\n    for _ in range(m):\n        l, r, word = map(int, stdin.split())\n        hints.append((l, r, word))\n\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, 1 << n):\n        if all(i & (1 << j) == 0 for j in range(n)):\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 3527,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cables = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        cables.add((a, b))\n        cables.add((b, a))\n    cables = list(cables)\n    cables.sort()\n    max_hops = 0\n    for i in range(len(cables)):\n        for j in range(i + 1, len(cables)):\n            if cables[i][0] < cables[j][0]:\n                max_hops = max(max_hops, cables[i][0] + cables[j][1] - 1)\n    return str(max_hops)"
    },
    {
        "number": 3528,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nails = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    nails.sort(key=lambda x: (x[0], x[1]))\n    areas = []\n    for i in range(len(nails) - 2):\n        area = abs(nails[i][0] - nails[i + 1][0]) * abs(nails[i][1] - nails[i + 1][1])\n        areas.append(area)\n    return '\\n'.join(map(str, areas))"
    },
    {
        "number": 3529,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        color, from_node, to_node = map(str, stdin.split())\n        if color == 'B':\n            graph[int(from_node)].append(int(to_node))\n        else:\n            graph[int(to_node)].append(int(from_node))\n    visited = [False] * (n + 1)\n    blue_edges = 0\n    for node in range(1, n + 1):\n        if not visited[node]:\n            visited[node] = True\n            blue_edges += 1\n            if blue_edges == k:\n                break\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    blue_edges += 1\n                    if blue_edges == k:\n                        break\n    return '1' if blue_edges == k else '0'"
    },
    {
        "number": 3530,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = map(int, stdin.split())\n    a, b, t = data[:N]\n    Q, *T = map(int, stdin.split())\n\n    def fun(i, k):\n        return a - (k - 1) ** 2 * b\n\n    total_fun = 0\n    for i in range(N):\n        for k in range(T[i]):\n            total_fun += fun(i, k)\n            if total_fun <= 0:\n                break\n\n    return str(total_fun)"
    },
    {
        "number": 3531,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split())\n    special_places = list(map(int, stdin.split()))\n    trails = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        trails.append((a, b, c))\n\n    def is_special(place: int) -> bool:\n        return place in special_places\n\n    def is_special_nonspecial(trail: tuple) -> bool:\n        return is_special(trail[0]) and not is_special(trail[1])\n\n    def is_special_nonspecial_direct(trail: tuple) -> bool:\n        return is_special_nonspecial(trail) and trail[2] == 1\n\n    def is_special_direct(trail: tuple) -> bool:\n        return is_special(trail[0]) and is_special(trail[1]) and trail[2] == 1\n\n    def is_special_nonspecial_direct_cost(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and trail[2] <= w\n\n    def is_special_direct_cost(trail: tuple) -> bool:\n        return is_special_direct(trail) and trail[2] <= w\n\n    def is_special_nonspecial_direct_cost_less_than_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and trail[2] < w\n\n    def is_special_direct_cost_less_than_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and trail[2] < w\n\n    def is_special_nonspecial_direct_cost_greater_than_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and trail[2] > w\n\n    def is_special_direct_cost_greater_than_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and trail[2] > w\n\n    def is_special_nonspecial_direct_cost_less_than_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and trail[2] <= w\n\n    def is_special_direct_cost_less_than_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and trail[2] <= w\n\n    def is_special_nonspecial_direct_cost_greater_than_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and trail[2] >= w\n\n    def is_special_direct_cost_greater_than_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and trail[2] >= w\n\n    def is_special_nonspecial_direct_cost_less_than_w_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and (trail[2] <= w or trail[2] == 1)\n\n    def is_special_direct_cost_less_than_w_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and (trail[2] <= w or trail[2] == 1)\n\n    def is_special_nonspecial_direct_cost_greater_than_w_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and (trail[2] >= w or trail[2] == 1)\n\n    def is_special_direct_cost_greater_than_w_or_equal_to_w(trail: tuple) -> bool:\n        return is_special_direct(trail) and (trail[2] >= w or trail[2] == 1)\n\n    def is_special_nonspecial_direct_cost_less_than_w_or_equal_to_w_or_one(trail: tuple) -> bool:\n        return is_special_nonspecial_direct(trail) and (trail[2] <= w or trail[2] == 1 or trail[2] == 2)\n\n    def is_special_direct_cost_less_than_w_or_equal_to_w_or_one(trail: tuple) -> bool:\n        return is_special_direct(trail) and (trail[2] <= w or trail"
    },
    {
        "number": 3532,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    explosion = stdin.split()[1]\n    explosion_set = set(explosion)\n    explosion_count = 0\n    remaining_string = \"\"\n\n    while explosion_count < len(explosion):\n        explosion_index = explosion.find(explosion[explosion_count])\n        if explosion_index!= -1:\n            explosion_count += 1\n            explosion_set.remove(explosion[explosion_count - 1])\n        else:\n            break\n\n    if explosion_count == len(explosion):\n        return \"FRULA\"\n    else:\n        remaining_string = \"\".join(explosion_set)\n        return remaining_string"
    },
    {
        "number": 3533,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trucks = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    trucks.sort(key=lambda x: x[0])\n    \n    total_toll = 0\n    for i in range(len(trucks)):\n        for j in range(i+1, len(trucks)):\n            entrance, exit = trucks[i], trucks[j]\n            if entrance[1]!= exit[1]:\n                total_toll += abs(entrance[1] - exit[1])\n    \n    return str(total_toll)"
    },
    {
        "number": 3534,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_keys = 0\n    k = 0\n\n    for i in range(1, n + 1):\n        if a[i - 1] > a[i - 2]:\n            k += 1\n        elif a[i - 1] < a[i - 2]:\n            k -= 1\n        else:\n            k = max(k, 0)\n\n        max_keys = max(max_keys, k)\n\n    return str(max_keys) + \" \" + str(k)"
    },
    {
        "number": 3535,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    s = [list(map(str, stdin.split())) for _ in range(K)]\n    s = [tuple(map(int, x)) for x in s]\n    s = set(s)\n    MOD = 10**9 + 7\n\n    def count_valid_states(spin: int, y: int, x: int) -> int:\n        def count_neighbors(y: int, x: int) -> int:\n            count = 0\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ny, nx = y + dy, x + dx\n                if 1 <= ny <= N and 1 <= nx <= M:\n                    count += s[(ny - 1) * M + nx - 1]\n            return count\n\n        def count_subgrid(y: int, x: int) -> int:\n            count = 0\n            for dy in range(2):\n                for dx in range(2):\n                    ny, nx = y + dy, x + dx\n                    if 1 <= ny <= N and 1 <= nx <= M:\n                        count += s[(ny - 1) * M + nx - 1]\n            return count\n\n        def count_spin(y: int, x: int) -> int:\n            count = 0\n            for dy in range(2):\n                for dx in range(2):\n                    ny, nx = y + dy, x + dx\n                    if 1 <= ny <= N and 1 <= nx <= M:\n                        count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_neighbors(y: int, x: int) -> int:\n            count = 0\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ny, nx = y + dy, x + dx\n                if 1 <= ny <= N and 1 <= nx <= M:\n                    count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_subgrid(y: int, x: int) -> int:\n            count = 0\n            for dy in range(2):\n                for dx in range(2):\n                    ny, nx = y + dy, x + dx\n                    if 1 <= ny <= N and 1 <= nx <= M:\n                        count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_neighbors_subgrid(y: int, x: int) -> int:\n            count = 0\n            for dy in range(2):\n                for dx in range(2):\n                    ny, nx = y + dy, x + dx\n                    if 1 <= ny <= N and 1 <= nx <= M:\n                        count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_neighbors_subgrid_neighbors(y: int, x: int) -> int:\n            count = 0\n            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ny, nx = y + dy, x + dx\n                if 1 <= ny <= N and 1 <= nx <= M:\n                    count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_neighbors_subgrid_neighbors_neighbors(y: int, x: int) -> int:\n            count = 0\n            for dy in range(2):\n                for dx in range(2):\n                    ny, nx = y + dy, x + dx\n                    if 1 <= ny <= N and 1 <= nx <= M:\n                        count += s[(ny - 1) * M + nx - 1] * (1 if s[(ny - 1) * M + nx - 1] == spin else -1)\n            return count\n\n        def count_spin_neighbors_sub"
    },
    {
        "number": 3536,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tree = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        a, b, c = map(int, stdin.split())\n        tree[a].append((b, c))\n        tree[c].append((b, a))\n    for i in range(1, n + 1):\n        tree[i].sort(key=lambda x: x[0])\n    def heapify(node):\n        nonlocal tree\n        left = 2 * node\n        right = 2 * node + 1\n        if left <= len(tree[node]) and tree[node][left][0] < tree[node][node][0]:\n            max_child = left\n        else:\n            max_child = node\n        if right <= len(tree[node]) and tree[node][right][0] < tree[node][max_child][0]:\n            max_child = right\n        if max_child!= node:\n            tree[node], tree[max_child] = tree[max_child], tree[node]\n            heapify(max_child)\n    def is_heap(node):\n        nonlocal tree\n        if node == 1:\n            return True\n        return is_heap(tree[node][0][1])\n    def count_heap(node):\n        nonlocal tree\n        if node == 1:\n            return 1\n        return count_heap(tree[node][0][1]) + count_heap(tree[node][1][1])\n    def count_heap_pairs(node):\n        nonlocal tree\n        if node == 1:\n            return 0\n        return count_heap_pairs(tree[node][0][1]) + count_heap_pairs(tree[node][1][1]) + count_heap_pairs(tree[node][0][1]) + count_heap_pairs(tree[node][1][1])\n    def count_heap_pairs_with_heap(node):\n        nonlocal tree\n        if node == 1:\n            return 0\n        return count_heap_pairs_with_heap(tree[node][0][1]) + count_heap_pairs_with_heap(tree[node][1][1]) + count_heap_pairs_with_heap(tree[node][0][1]) + count_heap_pairs_with_heap(tree[node][1][1]) + count_heap_pairs_with_heap(tree[node][0][1])\n    def count_heap_pairs_with_heap_and_heap(node):\n        nonlocal tree\n        if node == 1:\n            return 0\n        return count_heap_pairs_with_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap(tree[node][1][1]) + count_heap_pairs_with_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap(tree[node][1][1]) + count_heap_pairs_with_heap_and_heap(tree[node][0][1])\n    def count_heap_pairs_with_heap_and_heap_and_heap(node):\n        nonlocal tree\n        if node == 1:\n            return 0\n        return count_heap_pairs_with_heap_and_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap_and_heap(tree[node][1][1]) + count_heap_pairs_with_heap_and_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap_and_heap(tree[node][1][1]) + count_heap_pairs_with_heap_and_heap_and_heap(tree[node][0][1])\n    def count_heap_pairs_with_heap_and_heap_and_heap_and_heap(node):\n        nonlocal tree\n        if node == 1:\n            return 0\n        return count_heap_pairs_with_heap_and_heap_and_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap_and_heap_and_heap(tree[node][1][1]) + count_heap_pairs_with_heap_and_heap_and_heap_and_heap(tree[node][0][1]) + count_heap_pairs_with_heap_and_heap_and_heap_and_heap"
    },
    {
        "number": 3537,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flights = []\n    for _ in range(m):\n        a, b, s, e = map(int, stdin.split())\n        flights.append((a, b, s, e))\n\n    flights.sort(key=lambda x: (x[2], x[3]))\n\n    def dfs(i, visited, frustration):\n        if i == n:\n            return frustration\n\n        visited.add(i)\n        for j in range(i + 1, n + 1):\n            if j not in visited and flights[j - 1][0] == i + 1:\n                return dfs(j, visited, frustration + (flights[j - 1][3] - flights[j - 1][2]) ** 2)\n\n        return dfs(i + 1, visited, frustration)\n\n    return str(dfs(1, set(), 0))"
    },
    {
        "number": 3538,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    frogs = []\n    for _ in range(n):\n        l, w, h = map(int, stdin.split())\n        frogs.append((l, w, h))\n    frogs.sort(key=lambda x: (x[0], x[1], x[2]))\n    max_escape = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                escape = 0\n                for frog in frogs:\n                    if frog[0] > d:\n                        escape += 1\n                if escape > max_escape:\n                    max_escape = escape\n    return str(max_escape)"
    },
    {
        "number": 3539,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def dfs(graph, visited, color, count):\n        nonlocal result\n        if len(visited) == len(graph):\n            result += 1\n            return\n        for i in range(len(graph)):\n            if visited[i] or (color[i] == color[graph[i]] and i not in graph):\n                continue\n            visited[i] = True\n            color[i] = 1 - color[graph[i]]\n            dfs(graph, visited, color, count)\n            color[i] = color[graph[i]]\n            visited[i] = False\n\n    result = 0\n    for i in range(N):\n        graph = [j for j in range(1, a[i] + 1) if j not in b[i]]\n        visited = [False] * len(graph)\n        color = [0] * len(graph)\n        dfs(graph, visited, color, 0)\n\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3540,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(row) for row in stdin.split('\\n')]\n    rows = [0, 1, 2, 3]\n    cols = [0, 1, 2, 3]\n    visited = set()\n    moves = 0\n\n    def is_valid(row, col):\n        return 0 <= row < 4 and 0 <= col < 4 and (row, col) not in visited\n\n    def dfs(row, col):\n        visited.add((row, col))\n        if row == 0 or row == 3:\n            moves += 1\n        if col == 0 or col == 3:\n            moves += 1\n        if row == 0 or col == 0 or row == 3 or col == 3:\n            return\n        if grid[row][col] == 'R':\n            dfs(row - 1, col)\n        elif grid[row][col] == 'G':\n            dfs(row, col - 1)\n        elif grid[row][col] == 'B':\n            dfs(row + 1, col)\n        elif grid[row][col] == 'Y':\n            dfs(row, col + 1)\n\n    for row in rows:\n        for col in cols:\n            if grid[row][col]!='':\n                dfs(row, col)\n                break\n\n    return str(moves)"
    },
    {
        "number": 3541,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def get_candy_value(candy: int) -> int:\n        if candy == -1:\n            return 0\n        elif candy == 0:\n            return 1\n        else:\n            return abs(candy)\n\n    def get_candy_type(candy: int) -> str:\n        if candy == -1:\n            return \"A\"\n        elif candy == 0:\n            return \"B\"\n        else:\n            return \"C\"\n\n    def get_candy_type_value(candy: int) -> int:\n        if candy == -1:\n            return 0\n        elif candy == 0:\n            return 1\n        else:\n            return abs(candy)\n\n    def get_candy_type_value_sum(candy_type: str, candy_value: int) -> int:\n        if candy_type == \"A\":\n            return a[candy_value]\n        elif candy_type == \"B\":\n            return b[candy_value]\n        else:\n            return 0\n\n    def get_candy_type_value_sum_list(candy_type: str) -> list:\n        return [get_candy_type_value_sum(candy_type, i) for i in range(N)]\n\n    def get_candy_type_value_sum_list_sorted(candy_type: str) -> list:\n        return sorted(get_candy_type_value_sum_list(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum(candy_type: str) -> int:\n        return sum(get_candy_type_value_sum_list_sorted(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_min(candy_type: str) -> int:\n        return min(get_candy_type_value_sum_list_sorted_sum(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index(candy_type: str) -> int:\n        return get_candy_type_value_sum_list_sorted_sum_min(candy_type).index(get_candy_type_value_sum_list_sorted_sum_min(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index_candy_type(candy_type: str) -> str:\n        return get_candy_type(get_candy_type_value_sum_list_sorted_sum_min(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value(candy_type: str) -> int:\n        return get_candy_type_value_sum_list_sorted_sum_min(candy_type)[get_candy_type_value_sum_list_sorted_sum_min_index(candy_type)]\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value_candy_type(candy_type: str) -> str:\n        return get_candy_type(get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value_candy_type_value(candy_type: str) -> int:\n        return get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value(candy_type)\n\n    def get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value_candy_type_value_candy_type(candy_type: str) -> str:\n        return get_candy_type(get_candy_type_value_sum_list_sorted_sum_min_index_candy_type_value_candy_type_value(candy_type))\n\n    def get_candy_type_value_sum_list_sorted_sum_"
    },
    {
        "number": 3542,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    points = []\n    for _ in range(4):\n        x, y = map(int, stdin.split()[1].split())\n        points.append((x, y))\n    points.sort()\n    for i in range(len(points) - 1):\n        if points[i][0] == points[i + 1][0] or points[i][1] == points[i + 1][1]:\n            return \"IMPOSSIBLE\"\n    for i in range(len(points) - 1):\n        if points[i][0] == points[i + 1][0]:\n            if points[i][1] < points[i + 1][1]:\n                return abs(points[i][1] - points[i + 1][1])\n            else:\n                return abs(points[i][1] - points[i + 1][1]) + 1\n        elif points[i][1] == points[i + 1][1]:\n            if points[i][0] < points[i + 1][0]:\n                return abs(points[i][0] - points[i + 1][0])\n            else:\n                return abs(points[i][0] - points[i + 1][0]) + 1\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3543,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dictionary = {}\n    for _ in range(n):\n        word, frequency = stdin.split()\n        dictionary[word] = int(frequency)\n\n    words_to_type = []\n    for _ in range(m):\n        words_to_type.append(stdin.strip())\n\n    def min_keystrokes(word: str) -> int:\n        if word in dictionary:\n            return dictionary[word]\n        return len(word)\n\n    min_keystrokes_dict = {word: min_keystrokes(word) for word in words_to_type}\n    min_keystrokes_list = sorted(min_keystrokes_dict.items(), key=lambda x: x[1])\n\n    result = []\n    for word, min_keystrokes in min_keystrokes_list:\n        result.append(str(min_keystrokes))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3544,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    groups = [int(x) for x in stdin.split()[1:]]\n    groups.sort(reverse=True)\n    max_seats = 12\n    min_seats = 1\n    for group in groups:\n        if group > max_seats:\n            return \"impossible\"\n        max_seats -= group\n        min_seats = max(min_seats, group)\n    return str(min_seats)"
    },
    {
        "number": 3545,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    observed_output, test_tree = stdin.split('\\n')\n    preorder_print, inorder_print, postorder_print = observed_output.split()\n    preorder_tree, inorder_tree, postorder_tree = test_tree.split()\n\n    def reconstruct_code(preorder_print: str, inorder_print: str, postorder_print: str) -> str:\n        def preorder_to_inorder(preorder: str) -> str:\n            if not preorder:\n                return ''\n            value, left, right = preorder.split()\n            return value + preorder_to_inorder(left) + preorder_to_inorder(right)\n\n        def inorder_to_preorder(inorder: str) -> str:\n            if not inorder:\n                return ''\n            value, left, right = inorder.split()\n            return inorder_to_preorder(left) + value + inorder_to_preorder(right)\n\n        def postorder_to_preorder(postorder: str) -> str:\n            if not postorder:\n                return ''\n            value, left, right = postorder.split()\n            return postorder_to_preorder(left) + postorder_to_preorder(right) + value\n\n        preorder_inorder = preorder_to_inorder(preorder_print)\n        inorder_preorder = inorder_to_preorder(inorder_print)\n        postorder_preorder = postorder_to_preorder(postorder_print)\n\n        preorder_calls = preorder_inorder.split()\n        inorder_calls = inorder_preorder.split()\n        postorder_calls = postorder_preorder.split()\n\n        return''.join(preorder_calls) +'' +''.join(inorder_calls) +'' +''.join(postorder_calls)\n\n    def find_first_tree(preorder_tree: str, inorder_tree: str, postorder_tree: str) -> str:\n        def find_first_tree_helper(preorder_tree: str, inorder_tree: str, postorder_tree: str) -> str:\n            if not preorder_tree:\n                return ''\n            value, left, right = preorder_tree.split()\n            if value == inorder_tree:\n                return value + find_first_tree_helper(left, inorder_tree, postorder_tree)\n            elif value == postorder_tree:\n                return value + find_first_tree_helper(left, inorder_tree, postorder_tree)\n            else:\n                return find_first_tree_helper(left, inorder_tree, postorder_tree)\n\n        return find_first_tree_helper(preorder_tree, inorder_tree, postorder_tree)\n\n    reconstruction = reconstruct_code(preorder_print, inorder_print, postorder_print)\n    first_tree = find_first_tree(preorder_tree, inorder_tree, postorder_tree)\n\n    return reconstruction + '\\n' + first_tree"
    },
    {
        "number": 3546,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, = map(int, stdin.split())\n    theorems = [[] for _ in range(n)]\n    for _ in range(n):\n        p, = map(int, stdin.split())\n        for _ in range(p):\n            l, k, *d = map(int, stdin.split())\n            theorems[d[0]].append((l, k, d))\n    shortest = float('inf')\n    for theorem in theorems:\n        if theorem:\n            l, k, d = min(theorem, key=lambda x: x[0])\n            shortest = min(shortest, l)\n    return str(shortest)"
    },
    {
        "number": 3547,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    plots = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, stdin.split()[1:])\n        plots.append((x1, y1, x2, y2))\n    total_area = 0\n    for x1, y1, x2, y2 in plots:\n        total_area += (x2 - x1) * (y2 - y1)\n    return f\"{total_area:.2f}\""
    },
    {
        "number": 3548,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    bad_pairs = set()\n    for _ in range(P):\n        a, b = map(int, stdin.split())\n        bad_pairs.add((a, b))\n\n    def is_valid(drinks: list[int]) -> bool:\n        for i in range(len(drinks) - 1):\n            for j in range(i + 1, len(drinks)):\n                if drinks[i] == drinks[j]:\n                    return False\n        return True\n\n    def count_valid_combinations(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates_and_duplicates(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates_and_duplicates_and_duplicates(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates_and_duplicates_and_duplicates_and_duplicates(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates_and_duplicates_and_duplicates_and_duplicates_and_duplicates(drinks: list[int]) -> int:\n        count = 0\n        for i in range(1, len(drinks) + 1):\n            for j in range(i, len(drinks) + 1):\n                if is_valid(drinks[:i] + drinks[j:]):\n                    count += 1\n        for pair in bad_pairs:\n            if pair[0] in drinks and pair[1] in drinks:\n                count -= 1\n        return count\n\n    def count_valid_combinations_with_bad_pairs_and_duplicates_and_duplicates_and_duplicates_and_duplicates_and_duplicates_and"
    },
    {
        "number": 3549,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m1, m2, m3 = map(int, stdin.split())\n    x1, x2, x3 = map(int, stdin.split())\n    y1, y2, y3 = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_within_distance(x, y, m):\n        return abs(x - y) % m == 0\n\n    def smallest_distance(m1, m2, m3, x1, x2, x3, y1, y2, y3):\n        if not is_prime(m1) or not is_prime(m2) or not is_prime(m3):\n            return \"INVALID\"\n\n        if not all(0 < x1 < m1, 0 < x2 < m2, 0 < x3 < m3, 0 < y1 < 300, 0 < y2 < 300, 0 < y3 < 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= y2 <= y3):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= x2 <= x3):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= x1 <= 300):\n            return \"INVALID\"\n\n        if not all(0 <= y1 <= 300):\n            return \"INVALID\"\n\n        if not all(0"
    },
    {
        "number": 3550,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    commands = stdin.split('\\n')\n    result = []\n\n    for command in commands:\n        if command.startswith('var '):\n            name, value = command.split('=')\n            result.append(f'{name} = {value}')\n        elif command.startswith('print '):\n            expr = command.split('print ')[1]\n            result.append(f'print {expr}')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3551,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *volumes = map(int, stdin.split())\n    T = int(stdin.split()[-1])\n\n    if T > sum(volumes):\n        return \"impossible\"\n\n    moves = []\n    for i in range(n):\n        if volumes[i] <= T:\n            moves.append(f\"fill {i}\")\n            T -= volumes[i]\n        else:\n            moves.append(f\"transfer {i} 0\")\n            T = 0\n\n    return \" \".join(moves)"
    },
    {
        "number": 3552,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    gnomes = list(range(1, n+1))\n    groups = [gnomes[i:i+m] for i in range(0, len(gnomes), m)]\n    max_damage = 0\n    for group in groups:\n        group_damage = sum(gnomes[i] for i in group)\n        if group_damage <= k:\n            group_damage = k\n        else:\n            group_damage -= k\n        max_damage = max(max_damage, group_damage)\n    return str(max_damage)"
    },
    {
        "number": 3553,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    arr = list(map(int, stdin.split()[1:]))\n\n    def change_number(p: int, v: int) -> None:\n        arr[p - 1] = v\n\n    def shortest_subarray(arr: List[int]) -> int:\n        left, right = 0, 0\n        min_length = float('inf')\n        while right < len(arr):\n            if arr[right] - arr[left] < min_length:\n                min_length = arr[right] - arr[left]\n            if arr[right] == K:\n                return right - left + 1\n            if arr[right] < K:\n                right += 1\n            else:\n                left += 1\n        return -1\n\n    for _ in range(M):\n        query = stdin.split()\n        if query[0] == '1':\n            p, v = map(int, query[1:])\n            change_number(p, v)\n        elif query[0] == '2':\n            print(shortest_subarray(arr))\n        else:\n            raise ValueError(\"Invalid query\")\n\n    return \"\\n\".join(map(str, arr))\n"
    },
    {
        "number": 3554,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, W, C = map(int, stdin.split())\n    # Assuming the monkey can exactly transfer any real number of ml of smoothie between two containers\n    # and walk any real number of meters\n    # Assuming the monkey can carry at most two containers at the same time\n    # Assuming the containers are bio-degradable\n    # Assuming the monkey can leave empty containers anywhere she likes in the forest\n    # Assuming the monkey can only carry the same amount of smoothie regardless of whether she is carrying one or two containers\n    # Assuming the monkey can start with all the smoothie in a single place and a unlimited supply of large containers\n    # Assuming the monkey has limited strength and is only able to carry a limited amount of smoothie at a time\n    # Assuming the monkey can not move\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same time\n    # Assuming the monkey is lazy and will not help the monkey transport the smoothie\n    # Assuming the monkey is able to exactly transfer any real number of ml of smoothie between two containers she is carrying\n    # Assuming the monkey is able to exactly walk any real number of meters\n    # Assuming the monkey can not be able to deliver all the smoothie to her family at the same"
    },
    {
        "number": 3555,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    toys = []\n    trees = []\n\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        toys.append((x, y))\n\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        trees.append((x, y))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def closest_toy(x, y):\n        return min(toys, key=lambda t: distance(t, (x, y)))\n\n    def closest_tree(x, y):\n        return min(trees, key=lambda t: distance(t, (x, y)))\n\n    def closest_toys(x, y):\n        return [closest_toy(x, y)]\n\n    def closest_trees(x, y):\n        return [closest_tree(x, y)]\n\n    def closest_toys_and_trees(x, y):\n        return closest_toys(x, y) + closest_trees(x, y)\n\n    def closest_toys_and_trees_sorted(x, y):\n        return sorted(closest_toys_and_trees(x, y), key=lambda t: t[0])\n\n    def closest_toys_and_trees_sorted_by_shininess(x, y):\n        return sorted(closest_toys_and_trees_sorted(x, y), key=lambda t: t[1])\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess(x, y), key=lambda t: distance(t, (x, y)))\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance(x, y), key=lambda t: t[0])\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance_and_x(x, y), key=lambda t: t[1])\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y(x, y), key=lambda t: distance(t, (x, y)))\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance(x, y), key=lambda t: t[0])\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x_and_y(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x(x, y), key=lambda t: t[1])\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x_and_y_and_distance(x, y):\n        return sorted(closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x_and_y(x, y), key=lambda t: distance(t, (x, y)))\n\n    def closest_toys_and_trees_sorted_by_shininess_and_distance_and_x_and_y_and_distance_and_x_and_y_and_distance_and_x(x, y):"
    },
    {
        "number": 3556,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_height(employee_id: int, heights: List[int]) -> int:\n        return heights[employee_id - 1]\n\n    def get_immediate_boss(employee_id: int, heights: List[int]) -> int:\n        boss_id = employee_id\n        while boss_id!= 1:\n            boss_id = heights[boss_id - 1]\n        return boss_id\n\n    def get_subordinates(employee_id: int, heights: List[int]) -> int:\n        boss_id = employee_id\n        subordinates = 0\n        while boss_id!= 1:\n            boss_id = heights[boss_id - 1]\n            subordinates += 1\n        return subordinates\n\n    def get_chairperson(heights: List[int]) -> int:\n        chairperson_id = 1\n        while heights[chairperson_id - 1] < heights[1]:\n            chairperson_id += 1\n        return chairperson_id\n\n    def get_employee_id(line: str) -> int:\n        return int(line.split()[0])\n\n    def get_salary(line: str) -> int:\n        return int(line.split()[1])\n\n    def get_height_in_meters(line: str) -> int:\n        return int(line.split()[2])\n\n    def get_query(line: str) -> int:\n        return int(line.split()[0])\n\n    def get_employee_id_from_query(query: int, employees: List[int]) -> int:\n        return employees[query - 1]\n\n    def get_immediate_boss_from_query(query: int, employees: List[int], heights: List[int]) -> int:\n        return get_immediate_boss(get_employee_id_from_query(query, employees), heights)\n\n    def get_subordinates_from_query(query: int, employees: List[int], heights: List[int]) -> int:\n        return get_subordinates(get_employee_id_from_query(query, employees), heights)\n\n    def get_chairperson_from_query(heights: List[int]) -> int:\n        return get_chairperson(heights)\n\n    def get_employee_id_from_query_or_chairperson(query: int, employees: List[int], heights: List[int]) -> int:\n        if query == 1:\n            return get_chairperson_from_query(heights)\n        else:\n            return get_immediate_boss_from_query(query, employees, heights)\n\n    def get_employee_id_from_query_or_chairperson_and_subordinates(query: int, employees: List[int], heights: List[int]) -> Tuple[int, int]:\n        employee_id = get_employee_id_from_query_or_chairperson(query, employees, heights)\n        subordinates = get_subordinates_from_query(query, employees, heights)\n        return employee_id, subordinates\n\n    def get_employee_id_from_query_or_chairperson_and_subordinates_or_chairperson(query: int, employees: List[int], heights: List[int]) -> Tuple[int, int, int]:\n        employee_id, subordinates = get_employee_id_from_query_or_chairperson_and_subordinates(query, employees, heights)\n        chairperson_id = get_chairperson_from_query(heights)\n        return employee_id, subordinates, chairperson_id\n\n    def get_employee_id_from_query_or_chairperson_and_subordinates_or_chairperson_and_subordinates(query: int, employees: List[int], heights: List[int]) -> Tuple[int, int, int, int]:\n        employee_id, subordinates, chairperson_id = get_employee_id_from_query_or_chairperson_and_subordinates_or_chairperson(query, employees, heights)\n        subordinates_of_chairperson = get_subordinates(chairperson_id, heights)\n        return employee_id, subordinates, chairperson_id, subordinates_of_chairperson\n\n    def get_employee_id_from_query_or_chairperson_and_subordinates_or_chairperson"
    },
    {
        "number": 3557,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *passengers = map(int, stdin.split())\n    chaos = [sum(passengers[i:i+n]) for i in range(0, len(passengers), n)]\n    max_chaos = max(chaos)\n    return str(max_chaos)"
    },
    {
        "number": 3558,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    buildings = []\n    for _ in range(n):\n        x, h = map(int, stdin.split())\n        buildings.append((x, h))\n    buildings.sort(key=lambda x: x[0])\n\n    covered_length = 0\n    for x, h in buildings:\n        if covered_length + x > d:\n            break\n        covered_length += x + h\n\n    return f\"{covered_length:.3f}\""
    },
    {
        "number": 3559,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, attack1, armour1, attack2, armour2, t = map(int, stdin.split())\n    attack1, armour1, attack2, armour2 = map(lambda x: x + 1, [attack1, armour1, attack2, armour2])\n    map_ = [list(row) for row in stdin.split()[1:]]\n    map_ = [[1 if c == '.' else 2 for c in row] for row in map_]\n    for _ in range(t):\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    map_[i][j] = 2\n                    break\n                elif map_[i][j] == 2:\n                    map_[i][j] = 1\n                    break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 1:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 2\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 1\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 2:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 1\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 2\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 1:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 2\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 1\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 2:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 1\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 2\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 1:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 2\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 1\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 2:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 1\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map_[i][j] = 2\n                            break\n        for i in range(N):\n            for j in range(N):\n                if map_[i][j] == 1:\n                    continue\n                for k in range(N):\n                    for l in range(N):\n                        if map_[k][l] == 1:\n                            continue\n                        if abs(i - k) + abs(j - l) == 1:\n                            map_[i][j] = 2\n                            break\n                        elif abs(i - k) + abs(j - l) == 2:\n                            map"
    },
    {
        "number": 3560,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    words = [stdin.split()[1] for _ in range(N)]\n    for i in range(Q):\n        T, S = map(int, stdin.split())\n        if T == 1:\n            P = stdin.split()[1]\n            for j in range(N):\n                if words[j][:len(P)] == P:\n                    print(j + 1)\n                    break\n        elif T == 2:\n            S = int(S) - 1\n            count = 0\n            for j in range(N):\n                if words[j][:len(words[S])] == words[S]:\n                    count += 1\n            print(count)\n    return \"\""
    },
    {
        "number": 3561,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    wolves, sheep, cabbages, k = map(int, stdin.split())\n    if wolves + sheep + cabbages > k:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3562,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a, b, c = map(float, stdin.split())\n    a, b, c = abs(a), abs(b), abs(c)\n    f = [lambda x: a * x ** 2 + b * x + c for x in range(t + 1)]\n    f = [f[i] / f[i + 1] for i in range(len(f) - 1)]\n    return str(sum(f) * n)"
    },
    {
        "number": 3563,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    holes = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2*n)]\n    holes.sort(key=lambda x: x[0])\n    \n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n    \n    def cross(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n    \n    def orientation(a, b, c):\n        return cross(b, c, a)\n    \n    def convex_hull(points):\n        hull = []\n        for i in range(len(points)):\n            j = (i + 1) % len(points)\n            if orientation(hull[-1] if hull else points[0], hull[-1] if hull else points[0], points[i]) <= 0:\n                hull.append(points[i])\n        return hull\n    \n    def is_convex(points):\n        return orientation(points[0], points[1], points[2]) <= 0 and all(orientation(points[i], points[i+1], points[i+2]) <= 0 for i in range(len(points)-2))\n    \n    def is_inside(points, x, y):\n        return all(cross(points[i], points[(i+1) % len(points)], (x, y)) <= 0 for i in range(len(points)))\n    \n    def is_on_convex_hull(points, x, y):\n        return is_inside(convex_hull(points), x, y)\n    \n    def is_on_boundary(points, x, y):\n        return all(cross(points[i], points[(i+1) % len(points)], (x, y)) >= 0 for i in range(len(points)))\n    \n    def is_on_hole(points, x, y):\n        return all(cross(points[i], points[(i+1) % len(points)], (x, y)) <= 0 for i in range(len(points)))\n    \n    def is_on_edge(points, x, y):\n        return all(cross(points[i], points[(i+1) % len(points)], (x, y)) == 0 for i in range(len(points)))\n    \n    def is_on_vertex(points, x, y):\n        return all(cross(points[i], points[(i+1) % len(points)], (x, y)) == 0 for i in range(len(points)))\n    \n    def is_on_point(points, x, y):\n        return is_on_vertex(points, x, y) or is_on_edge(points, x, y) or is_on_hole(points, x, y) or is_on_convex_hull(points, x, y)\n    \n    def is_on_boundary_or_hole(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_hole(points, x, y)\n    \n    def is_on_boundary_or_convex_hull(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_convex_hull(points, x, y)\n    \n    def is_on_boundary_or_vertex(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_vertex(points, x, y)\n    \n    def is_on_boundary_or_edge(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_edge(points, x, y)\n    \n    def is_on_boundary_or_hole_or_convex_hull(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_hole(points, x, y) or is_on_convex_hull(points, x, y)\n    \n    def is_on_boundary_or_hole_or_vertex(points, x, y):\n        return is_on_boundary(points, x, y) or is_on_hole(points, x, y) or is_on_vertex(points, x, y)\n    \n    def is_on_boundary_or_hole_or_edge(points, x, y):\n        return is_on_boundary(points, x"
    },
    {
        "number": 3564,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    islands = []\n    palm_trees = []\n\n    for _ in range(n):\n        x, y, r = map(int, stdin.split())\n        islands.append((x, y, r))\n\n    for _ in range(m):\n        x, y, h = map(int, stdin.split())\n        palm_trees.append((x, y, h))\n\n    islands.sort(key=lambda x: x[2])\n    palm_trees.sort(key=lambda x: x[2])\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def palm_tree_height(x, y):\n        return min(palm_tree[2] for palm_tree in palm_trees if distance(palm_tree[:2], (x, y)) <= palm_tree[2])\n\n    def palm_tree_distance(x, y, h):\n        return distance(x, y) + (h - palm_tree_height(x, y)) * k\n\n    def island_distance(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_sea(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_palm_tree(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_sea(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_palm_tree(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_sea(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_palm_tree(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_tunnel(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_tunnel_crossing(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_tunnel_crossing_to_sea(a, b):\n        return distance(a, b) + (islands[0][2] - islands[1][2]) * k\n\n    def island_distance_to_tunnel_crossing_to_tunnel_crossing_to_tunnel_crossing_to_palm_tree(a, b):\n        return distance(a, b"
    },
    {
        "number": 3565,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = stdin.split()[1:n+1]\n    routes = []\n    for i in range(m):\n        a, b, c = map(str, stdin.split()[i+1:i+4])\n        routes.append((a, b, int(c)))\n\n    assignments = []\n    for i in range(4):\n        a, b = map(str, stdin.split()[n+i*2+1:n+i*2+3])\n        assignments.append((a, b))\n\n    def min_cost(routes: List[Tuple[str, str, int]], assignments: List[Tuple[str, str]]) -> int:\n        def dfs(routes: List[Tuple[str, str, int]], assignments: List[Tuple[str, str]], used: Set[Tuple[str, str]]) -> int:\n            if not routes:\n                return 0\n\n            a, b, c = routes[0]\n            if (a, b) in used or (b, a) in used:\n                return dfs(routes[1:], assignments, used)\n\n            used.add((a, b))\n            used.add((b, a))\n\n            cost = c + dfs(routes[1:], assignments, used)\n\n            if (a, b) in assignments:\n                cost += dfs(routes[1:], assignments, used)\n\n            return cost\n\n        return dfs(routes, assignments, set())\n\n    return str(min_cost(routes, assignments))"
    },
    {
        "number": 3566,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    huts = list(map(int, stdin.split()))\n    days = list(map(int, stdin.split()))\n\n    def find_best_position(hut, left_queue, right_queue):\n        if left_queue == right_queue:\n            return left_queue\n        elif left_queue > right_queue:\n            return left_queue + 1\n        else:\n            return right_queue - 1\n\n    for day in days:\n        for i in range(n):\n            huts[i] = max(0, huts[i] - day)\n\n    best_positions = []\n    for i in range(q):\n        left_queue, right_queue = huts[i], huts[i]\n        for j in range(i + 1, q):\n            if huts[j] < left_queue:\n                left_queue = huts[j]\n            if huts[j] > right_queue:\n                right_queue = huts[j]\n\n        best_positions.append(find_best_position(i, left_queue, right_queue))\n\n    return \"\\n\".join(map(str, best_positions))\n"
    },
    {
        "number": 3567,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    characters = []\n    for _ in range(n):\n        character = list(map(int, stdin.split()))\n        characters.append(character)\n\n    def calculate_similarity(character1: list, character2: list) -> int:\n        similarity = 0\n        for i in range(k):\n            if character1[i] == 1 and character2[i] == 1:\n                similarity += 1\n            elif character1[i] == 1 or character2[i] == 1:\n                similarity += 0.5\n        return similarity\n\n    def find_best_character(characters: list) -> list:\n        best_character = characters[0]\n        best_similarity = calculate_similarity(best_character, characters[0])\n        for character in characters[1:]:\n            similarity = calculate_similarity(character, best_character)\n            if similarity < best_similarity:\n                best_character = character\n                best_similarity = similarity\n        return best_character\n\n    best_character = find_best_character(characters)\n    return ''.join(map(str, best_character))"
    },
    {
        "number": 3568,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    frequencies = int(stdin.split()[0])\n    intervals = []\n    for i in range(frequencies):\n        t, n = map(int, stdin.split()[1:])\n        intervals.append((t, n))\n        stdin = stdin.split('\\n')[1]\n\n    intervals.sort()\n    for i in range(frequencies):\n        if intervals[i][0] > intervals[i][1]:\n            return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 3569,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    opponents = []\n    for i in range(n):\n        x, y, r = map(float, stdin.split()[1:])\n        opponents.append((x, y, r))\n    opponents.sort(key=lambda x: (x[2], x[0]**2 + x[1]**2))\n    max_hits = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if opponents[i][2] < opponents[j][2]:\n                continue\n            hits = 0\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                dx = opponents[k][0] - opponents[i][0]\n                dy = opponents[k][1] - opponents[i][1]\n                if dx**2 + dy**2 <= opponents[i][2]**2:\n                    hits += 1\n            max_hits = max(max_hits, hits)\n    return str(max_hits)"
    },
    {
        "number": 3570,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events, dreams, scenarios = [], [], []\n    for line in stdin.split('\\n'):\n        if line.startswith('E '):\n            events.append(line[2:])\n        elif line.startswith('D '):\n            dreams.append(int(line[2:]))\n        elif line.startswith('S '):\n            scenario = line.split()\n            k, *events = scenario[2:]\n            events = [event.strip() for event in events]\n            scenarios.append((int(k), events))\n\n    def is_consistent(events, dreams, scenario):\n        k, events = scenario\n        for event in events:\n            if event in events:\n                return False\n        for event in events:\n            if event in dreams:\n                return False\n        return True\n\n    for scenario in scenarios:\n        if is_consistent(events, dreams, scenario):\n            print(\"Yes\")\n        else:\n            r = min(dreams)\n            print(f\"{r} Just A Dream\")\n\n    return \"\"\n"
    },
    {
        "number": 3571,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, H, F, N = map(int, stdin.split())\n    lines = stdin.split('\\n')[1:]\n    text = '\\n'.join(lines)\n    text = text.replace(' ', '')\n    text = text.replace('\\t', '')\n    text = text.replace('\\n', '')\n    text = text.replace('\\r', '')\n    text = text.replace('\\f', '')\n    text = text.replace('\\v', '')\n    text = text.replace('\\x0b', '')\n    text = text.replace('\\x0c', '')\n    text = text.replace('\\x0e', '')\n    text = text.replace('\\x0f', '')\n    text = text.replace('\\x10', '')\n    text = text.replace('\\x11', '')\n    text = text.replace('\\x12', '')\n    text = text.replace('\\x13', '')\n    text = text.replace('\\x14', '')\n    text = text.replace('\\x15', '')\n    text = text.replace('\\x16', '')\n    text = text.replace('\\x17', '')\n    text = text.replace('\\x18', '')\n    text = text.replace('\\x19', '')\n    text = text.replace('\\x1a', '')\n    text = text.replace('\\x1b', '')\n    text = text.replace('\\x1c', '')\n    text = text.replace('\\x1d', '')\n    text = text.replace('\\x1e', '')\n    text = text.replace('\\x1f', '')\n    text = text.replace('\\x7f', '')\n    text = text.replace('\\x80', '')\n    text = text.replace('\\x81', '')\n    text = text.replace('\\x82', '')\n    text = text.replace('\\x83', '')\n    text = text.replace('\\x84', '')\n    text = text.replace('\\x85', '')\n    text = text.replace('\\x86', '')\n    text = text.replace('\\x87', '')\n    text = text.replace('\\x88', '')\n    text = text.replace('\\x89', '')\n    text = text.replace('\\x8a', '')\n    text = text.replace('\\x8b', '')\n    text = text.replace('\\x8c', '')\n    text = text.replace('\\x8d', '')\n    text = text.replace('\\x8e', '')\n    text = text.replace('\\x8f', '')\n    text = text.replace('\\x90', '')\n    text = text.replace('\\x91', '')\n    text = text.replace('\\x92', '')\n    text = text.replace('\\x93', '')\n    text = text.replace('\\x94', '')\n    text = text.replace('\\x95', '')\n    text = text.replace('\\x96', '')\n    text = text.replace('\\x97', '')\n    text = text.replace('\\x98', '')\n    text = text.replace('\\x99', '')\n    text = text.replace('\\x9a', '')\n    text = text.replace('\\x9b', '')\n    text = text.replace('\\x9c', '')\n    text = text.replace('\\x9d', '')\n    text = text.replace('\\x9e', '')\n    text = text.replace('\\x9f', '')\n    text = text.replace('\\xa0', '')\n    text = text.replace('\\xa1', '')\n    text = text.replace('\\xa2', '')\n    text = text.replace('\\xa3', '')\n    text = text.replace('\\xa4', '')\n    text = text.replace('\\xa5', '')\n    text = text.replace('\\xa6', '')\n    text = text.replace('\\xa7', '')\n    text = text.replace('\\xa8', '')\n    text = text.replace('\\xa9', '')\n    text = text.replace('\\xaa', '')\n    text = text.replace('\\xab', '')\n    text = text.replace('\\xac', '')\n    text = text.replace('\\xad', '')\n    text = text.replace('\\xae', '')\n    text = text.replace('\\xaf', '')\n    text = text.replace('\\xb0', '')\n    text = text.replace('\\xb1', '')\n    text = text.replace('\\xb2', '')\n    text = text.replace('\\xb3', '')\n    text = text.replace('\\xb4', '')\n    text = text.replace('\\xb5', '')\n    text = text.replace('\\xb6', '')\n    text = text.replace('\\xb7', '')\n    text = text.replace('\\xb8', '')\n    text = text.replace('\\xb9', '')\n    text = text.replace('\\xba', '')\n   "
    },
    {
        "number": 3572,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            d = int(stdin.split()[i+1])\n            graph[i].append((j, d))\n            graph[j].append((i, d))\n    visited = [False] * n\n    visited[0] = True\n    order = [0]\n    total_distance = 0\n    while order[-1]!= n-1:\n        for i in range(n):\n            if not visited[i] and total_distance + graph[order[-1]][i][1] <= L:\n                visited[i] = True\n                order.append(i)\n                total_distance += graph[order[-1]][i][1]\n                break\n    if total_distance == L:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3573,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, c = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    cards.sort()\n    rounds = 0\n    while len(cards) < c:\n        rounds += 1\n        balls = set(range(1, n + 1))\n        for _ in range(d):\n            balls.remove(random.choice(list(balls)))\n        cards.extend(list(balls))\n    return str(rounds)"
    },
    {
        "number": 3574,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *a = map(int, stdin.split())\n    Q = int(stdin.split()[1])\n    queries = []\n    for _ in range(Q):\n        L, R = map(int, stdin.split())\n        queries.append((L, R))\n\n    def is_magical(arr):\n        return all(min(arr) <= i <= max(arr) for i in arr)\n\n    def longest_magical_subarray(arr):\n        max_length = 0\n        current_length = 0\n        current_magical = []\n        for i in range(len(arr)):\n            if is_magical(arr[i:i+current_length+1]):\n                current_magical.append(arr[i])\n                current_length += 1\n                if current_length > max_length:\n                    max_length = current_length\n            else:\n                current_length = 0\n        return max_length\n\n    result = []\n    for L, R in queries:\n        subarray = a[L-1:R]\n        result.append(longest_magical_subarray(subarray))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3575,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stations = list(range(n))\n    neighbours = set()\n\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        neighbours.add((u, v))\n        neighbours.add((v, u))\n\n    s, t = map(int, stdin.split())\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        while queue:\n            current = queue.popleft()\n            for neighbour in neighbours.get(current, []):\n                if neighbour not in visited:\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return list(visited)\n\n    alice_stations = bfs(s)\n    bob_stations = bfs(t)\n\n    alice_time = 0\n    bob_time = 0\n\n    for station in alice_stations:\n        if station in bob_stations:\n            alice_time += 1\n            bob_time += 1\n\n    for station in bob_stations:\n        if station in alice_stations:\n            alice_time += 1\n            bob_time += 1\n\n    if alice_time == 0 or bob_time == 0:\n        return \"never meet\"\n    else:\n        return str(alice_time + bob_time)"
    },
    {
        "number": 3576,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    p = 10**11 + 3\n    q = 1\n    for i in range(1, R + 1):\n        for j in range(1, C + 1):\n            p *= (i + j)\n            q *= (R - i + C - j)\n    p //= q\n    return str(p % (10**11 + 3))"
    },
    {
        "number": 3577,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *plants = map(int, stdin.split())\n    flowers = [0] * n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if plants[i][0] < plants[j][0] < plants[i][1] or plants[j][0] < plants[i][0] < plants[j][1]:\n                flowers[i] += 1\n                flowers[j] += 1\n    return '\\n'.join(map(str, flowers))"
    },
    {
        "number": 3578,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    flights = []\n    for _ in range(r):\n        a, b, c = map(int, stdin.split())\n        flights.append((a, b, c))\n\n    f, flights = map(int, stdin.split())\n    for _ in range(f):\n        a, b, c = map(int, stdin.split())\n        flights.append((a, b, c))\n\n    flights.sort(key=lambda x: x[2])\n    total_cost = 0\n    for a, b, c in flights:\n        total_cost += c\n\n    return str(total_cost)"
    },
    {
        "number": 3579,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    a, b = map(int, stdin.split()[1].split())\n    s = list(map(int, stdin.split()[2:h+2]))\n\n    def get_density(area):\n        count = 0\n        for i in range(h):\n            for j in range(w):\n                if s[i*w+j] > 0 and area >= a and area <= b:\n                    count += 1\n        return count\n\n    def get_mad(area):\n        count = 0\n        total = 0\n        for i in range(h):\n            for j in range(w):\n                if s[i*w+j] > 0 and area >= a and area <= b:\n                    count += 1\n                    total += s[i*w+j]\n        return total / count\n\n    def get_median(area):\n        count = 0\n        total = 0\n        for i in range(h):\n            for j in range(w):\n                if s[i*w+j] > 0 and area >= a and area <= b:\n                    count += 1\n                    total += s[i*w+j]\n        total = total / count\n        if count % 2 == 0:\n            return (total + s[count//2-1] + s[count//2]) / 2\n        else:\n            return total\n\n    densities = []\n    for area in range(a, b+1):\n        densities.append(get_density(area))\n\n    mad = get_mad(a)\n    median = get_median(a)\n\n    return f\"{mad:.3f}\""
    },
    {
        "number": 3580,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    queries = []\n    for _ in range(q):\n        i, m = map(int, stdin.split())\n        queries.append((i, set(map(int, stdin.split()))))\n\n    def longest_consecutive_subsequence(a: list, b: set) -> int:\n        b_set = set(b)\n        max_length = 0\n        current_length = 0\n        for i in range(len(a)):\n            if a[i] in b_set:\n                current_length += 1\n            else:\n                max_length = max(max_length, current_length)\n                current_length = 0\n        max_length = max(max_length, current_length)\n        return max_length\n\n    result = []\n    for i, b in queries:\n        result.append(longest_consecutive_subsequence(a[i-1:i+1], b))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3581,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    N, H, *probs = map(int, stdin.split())\n    probs = [tuple(map(float, line.split())) for line in probs]\n    H = H // 2\n    rows = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    # Compute expected payout\n    def expected_payout(row, ball_prob):\n        total_payout = 0\n        for i, (hole, payout) in enumerate(row):\n            if i == 0:\n                total_payout += payout * ball_prob[0]\n            else:\n                total_payout += payout * ball_prob[1]\n        return total_payout\n\n    expected_payouts = [expected_payout(row, probs) for row in rows]\n    expected_payout = sum(expected_payouts) / len(expected_payouts)\n\n    # Check accuracy\n    def relative_error(a, b):\n        return abs(a - b) / max(a, b)\n\n    def absolute_error(a, b):\n        return abs(a - b)\n\n    if relative_error(expected_payout, 32.6405451448) < 1e-4:\n        return f\"{expected_payout:.4f}\"\n    else:\n        return f\"{absolute_error(expected_payout, 32.6405451448):.4e}\""
    },
    {
        "number": 3582,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    mentors = list(map(int, stdin.split()[1:]))\n\n    # Find the lowest-numbered Gaggler\n    lowest_number = min(mentors)\n\n    # Find the new mentors\n    new_mentors = []\n    for i in range(n):\n        if i == lowest_number:\n            new_mentors.append(i)\n        else:\n            new_mentors.append(find_new_mentor(i, mentors))\n\n    # Output the new assignment\n    return \" \".join(map(str, new_mentors))\n\n\ndef"
    },
    {
        "number": 3583,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vertices = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.split()[1:3])\n        vertices.append((x, y))\n\n    def distance(a: tuple, b: tuple) -> float:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def circumference(vertices: list) -> float:\n        return sum(distance(vertices[i], vertices[(i + 1) % len(vertices)]) for i in range(len(vertices)))\n\n    def max_circumference(vertices: list) -> float:\n        return max(circumference(vertices), circumference(vertices[::-1]))\n\n    max_circumference_vertices = sorted(vertices, key=lambda x: circumference(x), reverse=True)[:6]\n    max_circumference_distances = [distance(max_circumference_vertices[i], max_circumference_vertices[(i + 1) % 6]) for i in range(6)]\n    max_circumference_distances.sort(reverse=True)\n    return \" \".join(map(str, max_circumference_distances))\n"
    },
    {
        "number": 3584,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    onions = [tuple(map(int, stdin.split())) for _ in range(n)]\n    fence_posts = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def convex_hull(points):\n        points.sort(key=lambda x: x[1])\n        hull = [points[0]]\n        for i in range(1, len(points)):\n            if points[i][1]!= points[i - 1][1]:\n                hull.append(points[i])\n        return hull\n\n    def is_convex(points):\n        return len(points) > 2 and points[0][0] * (points[1][1] - points[2][1]) <= points[1][0] * (points[2][1] - points[0][1])\n\n    def is_on_convex_hull(point, convex_hull):\n        return all(point[0] <= convex_hull[i][0] <= point[0] for i in range(len(convex_hull)))\n\n    convex_hull_onions = [onion for onion in onions if is_on_convex_hull(onion, convex_hull(fence_posts))]\n    max_onions = len(convex_hull_onions)\n\n    if max_onions <= k:\n        return str(max_onions)\n\n    for i in range(k):\n        if i < len(convex_hull_onions):\n            max_onions -= 1\n        else:\n            max_onions += 1\n\n        if max_onions <= k:\n            return str(max_onions)\n\n    return str(max_onions)"
    },
    {
        "number": 3585,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    max_bags = 0\n    for i in range(1, m + 1):\n        for j in range(1, k + 1):\n            max_bags = max(max_bags, 1 + (i * j) // (k * (k - 1)))\n    return str(max_bags % 998244353)"
    },
    {
        "number": 3586,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = set(map(int, stdin.split()[1:]))\n    for i in range(1, n):\n        if s.issubset(set(range(i, n))):\n            return str(i)\n    return \"No solution\""
    },
    {
        "number": 3587,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    taboo = [bin(i)[2:].zfill(8) for i in range(2 ** 8)]\n    taboo.extend(stdin.split()[1:])\n    taboo = set(taboo)\n    longest_clue = \"\"\n    for i in range(2 ** 8):\n        if bin(i)[2:].zfill(8) not in taboo:\n            if len(bin(i)[2:].zfill(8)) > len(longest_clue):\n                longest_clue = bin(i)[2:].zfill(8)\n    return longest_clue"
    },
    {
        "number": 3588,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_companies = int(stdin.split()[0])\n    records = []\n\n    for _ in range(n_companies):\n        k = int(stdin.split()[1])\n        records.append([int(x) for x in stdin.split()[2:2+k]])\n        stdin = stdin.split()[2+k:]\n\n    shares_by_day = {}\n    for record in records:\n        for day, shares in record:\n            if day not in shares_by_day:\n                shares_by_day[day] = 0\n            shares_by_day[day] += shares\n\n    sorted_days = sorted(shares_by_day.keys())\n    result = []\n    for day in sorted_days:\n        result.append(str(shares_by_day[day]))\n        if shares_by_day[day] > 0:\n            break\n\n    return''.join(result)"
    },
    {
        "number": 3589,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = [0] * 10\n    for x in range(L, R + 1):\n        digit = 0\n        while x > 0:\n            digit += x % 10\n            x //= 10\n        count[digit] += 1\n    return \" \".join(map(str, count))"
    },
    {
        "number": 3590,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a: tuple, b: tuple, c: tuple) -> float:\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def area(points: list) -> float:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return 0.5 * abs(x1 * y2 - x2 * y1)\n\n    def distance(a: tuple, b: tuple) -> float:\n        return ((b[0] - a[0]) ** 2 + (b[1] - a[1]) ** 2) ** 0.5\n\n    def is_inside(point: tuple, polygon: list) -> bool:\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n):\n            p2x, p2y = polygon[i]\n            if ((p1y > point[1] and p2y <= point[1]) or (p2y > point[1] and p1y <= point[1])) and (\n                    (point[0] - p1x) * (p2y - p1y) < (point[1] - p1y) * (p2x - p1x)):\n                inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def is_convex(polygon: list) -> bool:\n        n = len(polygon)\n        for i in range(n):\n            j = (i + 1) % n\n            if cross_product(polygon[i], polygon[j], polygon[(i + 2) % n]) < 0:\n                return False\n        return True\n\n    def is_clockwise(polygon: list) -> bool:\n        n = len(polygon)\n        for i in range(n):\n            j = (i + 1) % n\n            if (polygon[i][0] - polygon[j][0]) * (polygon[i][1] + polygon[j][1]) < 0:\n                return False\n        return True\n\n    def is_collinear(a: tuple, b: tuple, c: tuple) -> bool:\n        return abs(cross_product(a, b, c)) < 1e-6\n\n    def is_contained(a: list, b: list) -> bool:\n        return is_inside(b, a) and is_clockwise(a) == is_clockwise(b)\n\n    def is_separated(a: list, b: list) -> bool:\n        return not is_contained(a, b) and not is_contained(b, a)\n\n    def cut(a: list, b: list) -> float:\n        a_min_x, a_min_y = min(a, key=lambda x: x[0])\n        a_max_x, a_max_y = max(a, key=lambda x: x[0])\n        b_min_x, b_min_y = min(b, key=lambda x: x[0])\n        b_max_x, b_max_y = max(b, key=lambda x: x[0])\n\n        a_min_x, a_max_x, b_min_x, b_max_x = min(a_min_x, a_max_x), max(a_min_x, a_max_x), min(b_min_x, b_max_x), max(b_min_x, b_max_x)\n        a_min_y, a_max_y, b_min_y, b_max_y = min(a_min_y, a_max_y), max(a_min_y, a_max_y), min(b_min_y, b_max_y), max(b_min_y, b_max_y)\n\n        a_min_x, a_min_y, a_max_x, a_max_y = min(a_min_x, a_min_y), min(a_min_x, a_min_y), max(a_max_x, a_max_y), max(a_max_x, a_max_y)\n        b_min_x, b_min_y, b_max_x, b_max_y = min(b_min_x, b_min_y), min(b_min"
    },
    {
        "number": 3591,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    photos = []\n    for _ in range(k):\n        n = int(stdin.split()[1])\n        heights = list(map(int, stdin.split()[2:2+n]))\n        photos.append((heights, n))\n    photos.sort(key=lambda x: x[1])\n    result = []\n    for i in range(k):\n        result.append(photos[i][0])\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3592,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p_t, p_1, p_2 = map(float, stdin.split())\n    p_t = int(p_t * 100)\n    p_1 = int(p_1 * 100)\n    p_2 = int(p_2 * 100)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_combinations(p_t, p_1, p_2):\n        def is_valid(p_t, p_1, p_2):\n            return p_t <= p_1 + p_2\n\n        def find_combination(p_t, p_1, p_2):\n            p_t_lcm = lcm(p_t, p_1 + p_2)\n            p_t_gcd = gcd(p_t, p_t_lcm)\n            p_t_lcm //= p_t_gcd\n\n            p_1_lcm = lcm(p_1, p_t_lcm)\n            p_1_gcd = gcd(p_1, p_1_lcm)\n            p_1_lcm //= p_1_gcd\n\n            p_2_lcm = lcm(p_2, p_1_lcm)\n            p_2_gcd = gcd(p_2, p_2_lcm)\n            p_2_lcm //= p_2_gcd\n\n            return p_t_lcm, p_1_lcm, p_2_lcm\n\n        def find_combinations_helper(p_t, p_1, p_2, combinations):\n            if p_t == 0:\n                return combinations\n\n            p_t_lcm, p_1_lcm, p_2_lcm = find_combination(p_t, p_1, p_2)\n            if is_valid(p_t_lcm, p_1_lcm, p_2_lcm):\n                combinations.append((p_t_lcm, p_1_lcm, p_2_lcm))\n\n            return find_combinations_helper(p_t - p_t_lcm, p_1, p_2, combinations)\n\n        return find_combinations_helper(p_t, p_1, p_2, [])\n\n    combinations = find_combinations(p_t, p_1, p_2)\n    combinations.sort(key=lambda x: (x[1], x[2]))\n\n    result = []\n    for p_t_lcm, p_1_lcm, p_2_lcm in combinations:\n        result.append(f\"{p_t_lcm / 100:.2f} {p_1_lcm / 100:.2f} {p_2_lcm / 100:.2f}\")\n\n    return \"\\n\".join(result) if result else \"None\""
    },
    {
        "number": 3593,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    board = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        board.append(row)\n\n    def is_valid(board, dominoes):\n        for domino in dominoes:\n            if domino[0] > domino[1]:\n                return False\n            for row in board:\n                if domino[0] in row and domino[1] in row:\n                    return False\n        return True\n\n    def max_sum(board, dominoes):\n        max_sum = 0\n        for domino in dominoes:\n            row = board[domino[0]][domino[1]]\n            if row == 0:\n                row = 1\n            max_sum += row\n        return max_sum\n\n    def rotate_dominoes(board, dominoes):\n        rotated_board = []\n        for row in board:\n            rotated_row = []\n            for i in range(len(row)):\n                rotated_row.append(row[i])\n            rotated_board.append(rotated_row)\n        return rotated_board\n\n    def find_dominoes(board, dominoes):\n        for domino in dominoes:\n            if domino[0] > domino[1]:\n                domino[0], domino[1] = domino[1], domino[0]\n            if domino[0] < 0 or domino[1] < 0 or domino[0] >= n or domino[1] >= n:\n                return None\n            if board[domino[0]][domino[1]] == 0:\n                return None\n        return dominoes\n\n    def find_max_sum(board, dominoes):\n        max_sum = 0\n        for domino in dominoes:\n            row = board[domino[0]][domino[1]]\n            if row == 0:\n                row = 1\n            max_sum += row\n        return max_sum\n\n    rotated_board = rotate_dominoes(board, find_dominoes(board, [\n        [0, 0],\n        [0, 1],\n        [1, 0],\n        [1, 1]\n    ]))\n\n    dominoes = [\n        [0, 0],\n        [0, 1],\n        [1, 0],\n        [1, 1]\n    ]\n\n    while not is_valid(rotated_board, dominoes):\n        rotated_board = rotate_dominoes(rotated_board, dominoes)\n\n    max_sum = max_sum(rotated_board, dominoes)\n\n    return str(max_sum)"
    },
    {
        "number": 3594,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    players = []\n    for _ in range(n):\n        name, num = stdin.split()[1:]\n        players.append((name, int(num)))\n    players.sort(key=lambda x: (x[1], x[0]))\n    odd, even, ingmariay = players\n    return f\"{odd[1]} {even[1]} {ingmariay[1]}\""
    },
    {
        "number": 3595,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, l = map(int, stdin.split())\n    rooms = []\n    for _ in range(r):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        rooms.append((x1, y1, x2, y2))\n\n    def is_valid(x, y, angle, l):\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < r and 0 <= ny < r and rooms[nx][ny][0] <= x <= rooms[nx][ny][2] and rooms[nx][ny][1] <= y <= rooms[nx][ny][3]:\n                if angle == 0:\n                    return True\n                elif angle == 90:\n                    return nx == r - 1\n                elif angle == 180:\n                    return ny == r - 1\n                elif angle == 270:\n                    return nx == 0\n                else:\n                    return False\n\n    def is_hit(x, y, angle, l):\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < r and 0 <= ny < r and rooms[nx][ny][0] <= x <= rooms[nx][ny][2] and rooms[nx][ny][1] <= y <= rooms[nx][ny][3]:\n                if angle == 0:\n                    return True\n                elif angle == 90:\n                    return ny == 0\n                elif angle == 180:\n                    return nx == 0\n                elif angle == 270:\n                    return ny == r - 1\n                else:\n                    return False\n\n    def is_hit_by_beam(x, y, angle, l):\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < r and 0 <= ny < r and rooms[nx][ny][0] <= x <= rooms[nx][ny][2] and rooms[nx][ny][1] <= y <= rooms[nx][ny][3]:\n                if angle == 0:\n                    return True\n                elif angle == 90:\n                    return ny == r - 1\n                elif angle == 180:\n                    return nx == r - 1\n                elif angle == 270:\n                    return ny == 0\n                else:\n                    return False\n\n    def is_hit_by_beam_and_valid(x, y, angle, l):\n        return is_hit_by_beam(x, y, angle, l) and is_valid(x, y, angle, l)\n\n    def is_hit_by_beam_and_valid_and_not_hit(x, y, angle, l):\n        return not is_hit(x, y, angle, l) and is_hit_by_beam_and_valid(x, y, angle, l)\n\n    def is_hit_by_beam_and_valid_and_not_hit_and_not_hit_by_beam(x, y, angle, l):\n        return not is_hit_by_beam(x, y, angle, l) and is_hit_by_beam_and_valid(x, y, angle, l)\n\n    def is_hit_by_beam_and_valid_and_not_hit_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_by_beam_and_not_hit_"
    },
    {
        "number": 3596,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split()[0].split('.'))\n    t1, t2, t3, t4 = map(int, stdin.split()[1].split())\n    n, k, r, s, l = map(int, stdin.split()[2].split())\n\n    def f(x):\n        return c * (np.exp(x) - np.exp(-x))\n\n    def P(x):\n        return sum(f(i) / math.factorial(i) * x ** i for i in range(r + 1))\n\n    def P_n(x):\n        return sum(P(i) * x ** i for i in range(r + 1))\n\n    def P_s(x):\n        return P_n(x)\n\n    def g(n):\n        return (P_s(n) + l) ** 2 / (np.pi * np.e) + 1 / (l + 1)\n\n    return str(round(g(n), 2))"
    },
    {
        "number": 3597,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l, r1, y1, x2, y2, x3, y3, h = map(int, stdin.split())\n    r2 = r1 + 1\n    d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x3 - x2) ** 2 + (y3 - y2) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x3) ** 2 + (y1 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x3) ** 2 + (y2 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x3) ** 2 + (y1 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x3 - x1) ** 2 + (y3 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x3) ** 2 + (y2 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x3) ** 2 + (y1 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x3 - x1) ** 2 + (y3 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x3) ** 2 + (y2 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x3) ** 2 + (y1 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x3 - x1) ** 2 + (y3 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x3) ** 2 + (y2 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x1 - x3) ** 2 + (y1 - y3) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x2 - x1) ** 2 + (y2 - y1) ** 2\n    if d > (w / 2) ** 2:\n        return \"impossible\"\n    d = (x3 - x1) ** 2 +"
    },
    {
        "number": 3598,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    magnets = [int(m) for m in stdin.split()[1:]]\n    cheapest = min(magnets)\n    for i in range(n):\n        if magnets[i] == cheapest:\n            magnets[i] = 0\n    return ''.join(str(m) for m in magnets)"
    },
    {
        "number": 3599,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N = map(int, stdin.split())\n    breaks = list(map(int, stdin.split()))\n\n    def find_breaks(breaks: List[int], start: int, end: int) -> List[int]:\n        if start == end:\n            return [start]\n\n        mid = (start + end) // 2\n        left_breaks = find_breaks(breaks, start, mid)\n        right_breaks = find_breaks(breaks, mid + 1, end)\n\n        result = []\n        for left in left_breaks:\n            for right in right_breaks:\n                if left + right <= T:\n                    result.append(left + right)\n\n        return result\n\n    breaks = find_breaks(breaks, 0, T)\n    result = []\n    for i in range(N):\n        result.append(breaks.pop(0))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3600,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    intersections = []\n    for _ in range(n):\n        d, *neighbours = map(int, stdin.split())\n        intersections.append((d, neighbours))\n\n    def dfs(i, visited, drone_count):\n        if drone_count == k:\n            return True\n        if i in visited:\n            return False\n        visited.add(i)\n\n        for neighbour in intersections[i][1]:\n            if dfs(neighbour, visited, drone_count):\n                return True\n\n        visited.remove(i)\n        return False\n\n    for i in range(1, n + 1):\n        if dfs(i, set(), 0):\n            return \"possible\"\n\n    return \"impossible\""
    },
    {
        "number": 3601,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def shortest_path(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2) + 1\n\n    def shortest_path_without_messenger(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger_and_delay(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2) + 1\n\n    def shortest_path_without_messenger_and_delay(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger_and_delay_and_distance(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2) + 1\n\n    def shortest_path_without_messenger_and_delay_and_distance(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger_and_delay_and_distance_and_delay(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2) + 1\n\n    def shortest_path_without_messenger_and_delay_and_distance_and_delay(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger_and_delay_and_distance_and_delay_and_distance(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2) + 1\n\n    def shortest_path_without_messenger_and_delay_and_distance_and_delay_and_distance(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]]) -> float:\n        x1, y1 = path1[0]\n        x2, y2 = path2[0]\n        return distance(x1, y1, x2, y2)\n\n    def shortest_path_with_messenger_and_delay_and_distance_and_delay_and_distance_and_delay(path1: List[Tuple[int, int]], path2: List[Tuple[int, int]])"
    },
    {
        "number": 3602,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, k = map(int, stdin.split())\n    lamps = set()\n    for i in range(k):\n        row, col = map(int, stdin.split())\n        lamps.add((row, col))\n\n    def is_valid(lamps: set, row: int, col: int, distance: int) -> bool:\n        if (row, col) in lamps:\n            return False\n        for lamp in lamps:\n            if abs(row - lamp[0]) <= distance and abs(col - lamp[1]) <= distance:\n                return False\n        return True\n\n    def dfs(lamps: set, row: int, col: int, distance: int) -> bool:\n        if len(lamps) == 0:\n            return True\n        if not is_valid(lamps, row, col, distance):\n            return False\n        lamps.remove((row, col))\n        if dfs(lamps, row, col, distance + 1):\n            return True\n        lamps.add((row, col))\n        return False\n\n    return str(1 if dfs(lamps, 0, 0, 0) else 0)"
    },
    {
        "number": 3603,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    translators = []\n    for _ in range(m):\n        languages = map(int, stdin.split())\n        translators.append(languages)\n\n    pairs = []\n    for i in range(m):\n        for j in range(i + 1, m):\n            if translators[i][0] == translators[j][1] or translators[i][1] == translators[j][0]:\n                pairs.append((i, j))\n\n    if len(pairs) == 0:\n        return \"impossible\"\n\n    for pair in pairs:\n        if translators[pair[0]][0] == translators[pair[1]][1]:\n            print(pair[0], pair[1])\n            break\n\n    return \"\"\n"
    },
    {
        "number": 3604,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    sensors = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        sensors.append((x, y))\n\n    def is_connected(a: tuple, b: tuple) -> bool:\n        return abs(a[0] - b[0]) <= d and abs(a[1] - b[1]) <= d\n\n    def dfs(i: int, visited: set) -> int:\n        if i in visited:\n            return 0\n\n        visited.add(i)\n        count = 1\n        for j in range(n):\n            if is_connected(sensors[i], sensors[j]) and j not in visited:\n                count += dfs(j, visited)\n\n        return count\n\n    max_count = 0\n    max_subset = []\n    for i in range(n):\n        visited = set()\n        count = dfs(i, visited)\n        if count > max_count:\n            max_count = count\n            max_subset = [i + 1]\n        elif count == max_count:\n            max_subset.append(i + 1)\n\n    return str(max_count) + '\\n' +''.join(map(str, max_subset))"
    },
    {
        "number": 3605,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def find_min_height_difference(start, end):\n        min_height = float('inf')\n        for i in range(start, end):\n            min_height = min(min_height, a[i])\n        return min_height\n\n    min_height_difference = float('inf')\n    for i in range(n - k + 1):\n        min_height_difference = min(min_height_difference, find_min_height_difference(i, i + k) - find_min_height_difference(i, i + k - 1))\n\n    return str(min_height_difference)"
    },
    {
        "number": 3606,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    directions = stdin.split()[1]\n    plants = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        plants.append((x, y))\n\n    x, y = plants[0]\n    for _ in range(k):\n        if directions[0] == 'A':\n            x += 1\n        elif directions[0] == 'B':\n            x -= 1\n        elif directions[0] == 'C':\n            y += 1\n        else:\n            y -= 1\n        if 0 <= x < 1000000000 and 0 <= y < 1000000000:\n            directions = directions[1:]\n        else:\n            break\n\n    return f\"{x} {y}\""
    },
    {
        "number": 3607,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    program = stdin.split('\\n')\n    program = [line.split() for line in program]\n\n    def evaluate(tokens: list) -> int:\n        if tokens[0] == 'LET':\n            variable, value = tokens[1], tokens[2]\n            if value.isdigit():\n                return int(value)\n            else:\n                return program[int(value) - 1]\n        elif tokens[0] == 'IF':\n            condition, label = tokens[1], tokens[2]\n            if condition.isdigit():\n                return evaluate(program[int(condition) - 1])\n            else:\n                return program[program.index(label) - 1]\n        elif tokens[0] == 'PRINT':\n            return program[0][1]\n        elif tokens[0] == 'PRINTLN':\n            return program[0][1] + '\\n'\n        else:\n            raise ValueError(f'Invalid token: {tokens[0]}')\n\n    for statement in program:\n        tokens = statement[1:]\n        result = evaluate(tokens)\n        print(result)\n\n    return ''\n"
    },
    {
        "number": 3608,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tasks = [int(x) for x in stdin.split()[1:]]\n    diff_1 = [int(x) for x in stdin.split()[1:][::-1]]\n    diff_2 = [int(x) for x in stdin.split()[2:][::-1]]\n\n    def dfs(tasks, diff_1, diff_2, index, memo):\n        if index == len(tasks):\n            return 1\n\n        if (index, diff_1[index]) in memo:\n            return memo[(index, diff_1[index])]\n\n        memo[(index, diff_1[index])] = dfs(tasks, diff_1, diff_2, index + 1, memo)\n\n        if (index, diff_2[index]) in memo:\n            return memo[(index, diff_2[index])]\n\n        memo[(index, diff_2[index])] = dfs(tasks, diff_1, diff_2, index + 1, memo)\n\n        return memo[(index, diff_1[index])] + memo[(index, diff_2[index])]\n\n    return str(dfs(tasks, diff_1, diff_2, 0, {})) % 1000000007"
    },
    {
        "number": 3609,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    edges.sort()\n\n    left_edges = []\n    right_edges = []\n\n    for u, v in edges:\n        if u < v:\n            left_edges.append((u, v))\n        else:\n            right_edges.append((u, v))\n\n    if len(left_edges) == 0 or len(right_edges) == 0:\n        return \"impossible\"\n\n    left_tree = [0] * (n - 1)\n    right_tree = [0] * (n - 1)\n\n    for u, v in left_edges:\n        left_tree[u - 1] = v\n\n    for u, v in right_edges:\n        right_tree[v - 1] = u\n\n    for i in range(n - 1):\n        if left_tree[i] == 0:\n            return \"impossible\"\n\n    for i in range(n - 1):\n        if right_tree[i] == 0:\n            return \"impossible\"\n\n    for i in range(n - 1):\n        if left_tree[i] > right_tree[i]:\n            return \"impossible\"\n\n    return ''.join(['L' if left_tree[i] == 0 else 'R' for i in range(n - 1)])"
    },
    {
        "number": 3610,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split()[0])\n    teams = []\n    for _ in range(m):\n        team = list(map(int, stdin.split()[1:]))\n        teams.append(team)\n    friend_id = 1009\n\n    def find_smallest_team(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size:\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_size(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        for team in teams:\n            if len(team) < min_team_size:\n                min_team_size = len(team)\n        return min_team_size\n\n    def find_smallest_team_with_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and team[0]!= friend_id:\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_without_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and team[0] == friend_id:\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_with_friend_and_without_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and (team[0]!= friend_id or team[1]!= friend_id):\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_without_friend_and_with_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and (team[0] == friend_id or team[1] == friend_id):\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_with_friend_and_without_friend_and_with_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and (team[0]!= friend_id or team[1]!= friend_id or team[0] == friend_id or team[1] == friend_id):\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_without_friend_and_with_friend_and_without_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and (team[0] == friend_id or team[1] == friend_id or team[0]!= friend_id or team[1]!= friend_id):\n                min_team_size = len(team)\n                min_team = i\n        return min_team\n\n    def find_smallest_team_with_friend_and_without_friend_and_with_friend_and_without_friend(teams: List[List[int]]) -> int:\n        min_team_size = float('inf')\n        min_team = -1\n        for i, team in enumerate(teams):\n            if len(team) < min_team_size and (team[0]!= friend_id or team[1]!= friend_id or team[0] == friend_id or team[1] == friend_id or team[0]!= friend_"
    },
    {
        "number": 3611,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    s, t = map(int, stdin.split())\n    dist = [float('inf')] * n\n    dist[s] = 0\n\n    def dijkstra(start: int) -> List[int]:\n        q = [(start, 0)]\n        visited = set()\n        while q:\n            u, d = q.pop(0)\n            if u in visited:\n                continue\n            visited.add(u)\n            if u == t:\n                return d\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    q.append((v, dist[v]))\n        return -1\n\n    return''.join(map(str, dijkstra(s)))"
    },
    {
        "number": 3612,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m, w, h, x, y = map(float, stdin.split())\n    heights = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n    heights = [[heights[i][j] for j in range(w)] for i in range(h)]\n\n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < w and 0 <= y < h\n\n    def is_dry(x: int, y: int) -> bool:\n        return heights[y][x] == 0\n\n    def is_low_tide(x: int, y: int) -> bool:\n        return heights[y][x] <= 1000\n\n    def is_low_tide_neighbour(x: int, y: int) -> bool:\n        return is_valid(x - 1, y) and is_low_tide(x - 1, y) and is_valid(x + 1, y) and is_low_tide(x + 1, y)\n\n    def is_low_tide_neighbour_neighbour(x: int, y: int) -> bool:\n        return is_valid(x - 1, y - 1) and is_low_tide(x - 1, y - 1) and is_valid(x + 1, y - 1) and is_low_tide(x + 1, y - 1) and is_valid(x - 1, y + 1) and is_low_tide(x - 1, y + 1) and is_valid(x + 1, y + 1) and is_low_tide(x + 1, y + 1)\n\n    def is_low_tide_neighbour_neighbour_neighbour(x: int, y: int) -> bool:\n        return is_valid(x - 1, y - 1) and is_low_tide(x - 1, y - 1) and is_valid(x + 1, y - 1) and is_low_tide(x + 1, y - 1) and is_valid(x - 1, y + 1) and is_low_tide(x - 1, y + 1) and is_valid(x + 1, y + 1) and is_low_tide(x + 1, y + 1) and is_valid(x - 1, y) and is_low_tide(x - 1, y) and is_valid(x + 1, y) and is_low_tide(x + 1, y)\n\n    def is_low_tide_neighbour_neighbour_neighbour_neighbour(x: int, y: int) -> bool:\n        return is_valid(x - 1, y - 1) and is_low_tide(x - 1, y - 1) and is_valid(x + 1, y - 1) and is_low_tide(x + 1, y - 1) and is_valid(x - 1, y + 1) and is_low_tide(x - 1, y + 1) and is_valid(x + 1, y + 1) and is_low_tide(x + 1, y + 1) and is_valid(x - 1, y) and is_low_tide(x - 1, y) and is_valid(x + 1, y) and is_low_tide(x + 1, y) and is_valid(x, y - 1) and is_low_tide(x, y - 1) and is_valid(x, y + 1) and is_low_tide(x, y + 1)\n\n    def is_low_tide_neighbour_neighbour_neighbour_neighbour_neighbour(x: int, y: int) -> bool:\n        return is_valid(x - 1, y - 1) and is_low_tide(x - 1, y - 1) and is_valid"
    },
    {
        "number": 3613,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    kids = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def find_best_partition(kids: List[List[int]]) -> int:\n        n = len(kids)\n        rank = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                rank[j] += rank[i]\n        for i in range(n):\n            rank[i] += i\n\n        def find_max_rank(i: int, j: int) -> int:\n            return max(rank[i], rank[j])\n\n        def find_min_rank(i: int, j: int) -> int:\n            return min(rank[i], rank[j])\n\n        def find_max_rank_index(i: int, j: int) -> int:\n            return rank[i] + rank[j] - 1\n\n        def find_min_rank_index(i: int, j: int) -> int:\n            return rank[i] - rank[j]\n\n        def find_max_rank_index_helper(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_max_rank_index_helper(i, j, rank_i + 1, rank_j)\n            else:\n                return find_max_rank_index_helper(i, j, rank_i, rank_j - 1)\n\n        def find_min_rank_index_helper(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_min_rank_index_helper(i, j, rank_i + 1, rank_j)\n            else:\n                return find_min_rank_index_helper(i, j, rank_i, rank_j - 1)\n\n        def find_max_rank_index_helper_2(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_max_rank_index_helper_2(i, j, rank_i + 1, rank_j)\n            else:\n                return find_max_rank_index_helper_2(i, j, rank_i, rank_j - 1)\n\n        def find_min_rank_index_helper_2(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_min_rank_index_helper_2(i, j, rank_i + 1, rank_j)\n            else:\n                return find_min_rank_index_helper_2(i, j, rank_i, rank_j - 1)\n\n        def find_max_rank_index_helper_3(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_max_rank_index_helper_3(i, j, rank_i + 1, rank_j)\n            else:\n                return find_max_rank_index_helper_3(i, j, rank_i, rank_j - 1)\n\n        def find_min_rank_index_helper_3(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find_min_rank_index_helper_3(i, j, rank_i + 1, rank_j)\n            else:\n                return find_min_rank_index_helper_3(i, j, rank_i, rank_j - 1)\n\n        def find_max_rank_index_helper_4(i: int, j: int, rank_i: int, rank_j: int) -> int:\n            if rank_i == rank_j:\n                return i\n            elif rank_i < rank_j:\n                return find"
    },
    {
        "number": 3614,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, C = map(int, stdin.split())\n    flowers = []\n    for i in range(N):\n        flowers.append(list(map(int, stdin.split())))\n\n    def can_jump(r: int, c: int) -> bool:\n        if r == 0 or c == 0:\n            return True\n        if r == N - 1 or c == N - 1:\n            return True\n        return abs(r - R) == 1 and abs(c - C) > 1 or abs(c - C) == 1 and abs(r - R) > 1\n\n    def dfs(r: int, c: int, count: int) -> int:\n        if r == N or c == N:\n            return count\n        if not can_jump(r, c):\n            return dfs(r + 1, c, count)\n        return dfs(r + 1, c, count) + dfs(r, c + 1, count)\n\n    max_count = 0\n    for i in range(N):\n        for j in range(N):\n            if can_jump(i, j):\n                max_count = max(max_count, dfs(i, j, 0))\n\n    return str(max_count)"
    },
    {
        "number": 3615,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    towers = []\n    for _ in range(n):\n        x, y = map(float, stdin.split()[1:])\n        towers.append((x, y))\n    towers.sort(key=lambda x: (x[0], x[1]))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1, 3.1))\n    towers.append((4.2, 3.1))\n    towers.append((3.1, 4.2))\n    towers.append((1.0, 4.2))\n    towers.append((4.2, 1.0))\n    towers.append((1.0, 1.0))\n    towers.append((3.1, 1.0))\n    towers.append((1.0, 3.1))\n    towers.append((3.1,"
    },
    {
        "number": 3616,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    allergens = [int(line.strip()) for line in stdin.split('\\n')[1:]]\n    allergen_durations = {}\n    for allergen, duration in zip(allergens, allergens):\n        if allergen in allergen_durations:\n            allergen_durations[allergen] = min(allergen_durations[allergen], duration)\n        else:\n            allergen_durations[allergen] = duration\n\n    min_duration = min(allergen_durations.values())\n    return str(min_duration)"
    },
    {
        "number": 3617,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a, b, c, t0 = map(int, stdin.split())\n    t = [((a * t0 + b) % c + 1) for _ in range(n)]\n    max_problems = 0\n    total_penalty = 0\n    for i in range(n):\n        if t[i] > t[max_problems]:\n            max_problems = i\n        total_penalty += t[i]\n    return f\"{max_problems} {total_penalty % 1000000007}\""
    },
    {
        "number": 3618,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 998244353\n    best_friends = set()\n    for i in range(10 ** n):\n        for j in range(10 ** n):\n            if i == j:\n                continue\n            new_num = i + j\n            if new_num < 10:\n                continue\n            if new_num % 10 == 0:\n                continue\n            if new_num % 10 == 1 and new_num // 10 == 1:\n                continue\n            best_friends.add(new_num)\n    return str(len(best_friends))"
    },
    {
        "number": 3619,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    candidates = []\n    for _ in range(n):\n        s, p, r = map(int, stdin.split())\n        candidates.append((s, p, r))\n\n    candidates.sort(key=lambda x: (-x[1], x[0]))\n    total_value = 0\n    team = []\n\n    for i, (s, p, r) in enumerate(candidates):\n        if i == 0 or r == 0 or r == team[-1][2]:\n            team.append((s, p, r))\n            total_value += p / s\n            if len(team) == k:\n                break\n\n    return f\"{total_value:.3f}\""
    },
    {
        "number": 3620,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, k, P = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    colors = [0] * (N + 1)\n    count = 0\n    for i in range(1, N + 1):\n        if not colors[i]:\n            colors[i] = 1\n            count += 1\n            dfs(graph, colors, i, k, count)\n    return str(count % P)\n\ndef"
    },
    {
        "number": 3621,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = [list(map(int, stdin.split()[1:n+1])) for _ in range(n)]\n    colors = [list(map(lambda x: x % 301, row)) for row in colors]\n    colors = [list(map(lambda x: x + 1, row)) for row in colors]\n    colors = [list(map(lambda x: x if x > 0 else 300, row)) for row in colors]\n    colors = [list(map(lambda x: x if x < 301 else 1, row)) for row in colors]\n\n    def f(S):\n        max_size = 0\n        for i in range(1, n + 1):\n            if i not in S:\n                continue\n            for j in range(i + 1, n + 1):\n                if j not in S:\n                    continue\n                if colors[i - 1][j - 1] == colors[j - 1][i - 1]:\n                    max_size = max(max_size, f(S + [i, j]))\n        return max_size\n\n    return str((f(set()) % (10**9 + 7)))"
    },
    {
        "number": 3622,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[0].split())\n    u, d, l, r = map(int, stdin.split()[1].split())\n\n    grid = []\n    for _ in range(h):\n        grid.append(list(stdin.split()[2]))\n\n    targets = [i for i, row in enumerate(grid) for j, cell in enumerate(row) if cell == 'T']\n    target_probs = [0] * len(targets)\n\n    for i in range(len(targets)):\n        target_probs[i] = (u + d + l + r) / 100\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'T':\n                target_probs[targets.index(i * w + j)] = 1\n\n    return''.join(map(str, target_probs))"
    },
    {
        "number": 3623,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(float, stdin.split())\n    a = a * math.pi / 180\n    b = b * math.pi / 180\n    c = c * math.pi / 180\n    d = d * math.pi / 180\n\n    area = (a + b + c + d) / 2\n    watered_area = area * 0.75\n\n    return str(watered_area)"
    },
    {
        "number": 3624,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    trails = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        trails.append((u, v, d))\n\n    def bfs(start, end, visited):\n        queue = [(start, 0)]\n        while queue:\n            node, time = queue.pop(0)\n            if node == end:\n                return time\n            if node not in visited:\n                visited.add(node)\n                for neighbor, duration in trails:\n                    if neighbor == node:\n                        queue.append((neighbor, time + duration))\n        return float('inf')\n\n    start = 0\n    end = n - 1\n    visited = set()\n    time = bfs(start, end, visited)\n    if time == float('inf'):\n        return 'impossible'\n    return str(time)"
    },
    {
        "number": 3625,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    populations = []\n    for _ in range(n):\n        populations.append(list(map(int, stdin.split()[1:])))\n    populations.sort(key=lambda x: x[2])\n    max_trees = 0\n    for i in range(n):\n        max_trees += populations[i][0] * populations[i][1]\n    return str(max_trees)"
    },
    {
        "number": 3626,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        rectangles.append((x1, y1, x2, y2))\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles[i][0] < rectangles[j][2] and rectangles[i][1] < rectangles[j][3] and rectangles[j][0] < rectangles[i][2] and rectangles[j][1] < rectangles[i][3]:\n                return \"1\"\n    return \"0\""
    },
    {
        "number": 3627,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    cliff = [list(map(int, row.split())) for row in stdin.split()[1].split()]\n    start_points = [list(map(int, row.split())) for row in stdin.split()[2].split()]\n\n    def dfs(x, y, energy):\n        if x < 0 or x >= R or y < 0 or y >= C or cliff[x][y] == 0:\n            return energy\n        if cliff[x][y] > 0:\n            energy += cliff[x][y]\n        return dfs(x + 1, y, energy) + dfs(x - 1, y, energy) + dfs(x, y + 1, energy) + dfs(x, y - 1, energy)\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if (x, y) == (R - 1, C - 1):\n                return visited\n            queue.extend([(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)])\n        return visited\n\n    def min_energy(x, y):\n        visited = bfs(x, y)\n        return min(visited, key=lambda p: dfs(p[0], p[1], 0))\n\n    min_energy_set = set()\n    for x, y in start_points:\n        min_energy_set.add(min_energy(x, y))\n\n    return str(min(min_energy_set))"
    },
    {
        "number": 3628,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = list(map(int, a.split()))\n\n    for i in range(n):\n        a[i] = (a[i] - 1) % n + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == n:\n                print(f\"{a[i]} {a[j]}\")\n                return\n\n    print(\"impossible\")\n    return"
    },
    {
        "number": 3629,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trees = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    b, d = map(int, stdin.split('\\n')[-1].split())\n\n    def overlap(x, y, r):\n        return any(abs(x - tx) <= r + b for tx, ty, tr in trees)\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def boar_travel(x, y, r, d):\n        if overlap(x, y, r):\n            return None\n        if distance(x, y, 0, 0) >= d:\n            return None\n        return (x + d * (random.random() - 0.5), y + d * (random.random() - 0.5))\n\n    x, y = 0, 0\n    r = b\n    count = 0\n    while True:\n        x, y = boar_travel(x, y, r, d)\n        if x is None:\n            break\n        count += 1\n\n    return str(1 - count / (2 * math.pi * b ** 2))"
    },
    {
        "number": 3630,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split()\n    moves = 0\n    for i in range(len(s1)):\n        if s1[i] == 'z' and s2[i] == 'z':\n            moves += 1\n        elif s1[i] == 'a' and s2[i] == 'a':\n            moves += 1\n        elif s1[i] == 'z' and s2[i] == 'a':\n            moves += 1\n            s2 = s2[:i] + 'a' + s2[i+1:]\n        elif s1[i] == 'a' and s2[i] == 'z':\n            moves += 1\n            s2 = s2[:i] + 'z' + s2[i+1:]\n        else:\n            moves += 1\n            s2 = s2[:i] + chr(ord(s1[i]) + 1) + s2[i+1:]\n    return str(moves)"
    },
    {
        "number": 3631,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    beacons = []\n    mountains = []\n\n    for line in stdin.split('\\n'):\n        if line.startswith('1'):\n            x, y = map(int, line.split()[1:])\n            beacons.append((x, y))\n        elif line.startswith('2'):\n            x, y, r = map(int, line.split()[1:])\n            mountains.append((x, y, r))\n\n    def is_within_sight(beacon1: tuple, beacon2: tuple) -> bool:\n        x1, y1 = beacon1\n        x2, y2 = beacon2\n\n        for mountain in mountains:\n            x, y, r = mountain\n            if abs(x - x1) <= r and abs(y - y1) <= r:\n                return True\n            if abs(x - x2) <= r and abs(y - y2) <= r:\n                return True\n\n        return False\n\n    def count_messages(beacon: tuple) -> int:\n        count = 0\n        for beacon2 in beacons:\n            if beacon2!= beacon and is_within_sight(beacon, beacon2):\n                count += 1\n        return count\n\n    messages = sum(count_messages(beacon) for beacon in beacons)\n    return str(messages)"
    },
    {
        "number": 3632,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    initial_strings = stdin.split()[1:]\n    test_composite_string = stdin.split()[-1]\n\n    def get_composite_strings(initial_strings):\n        for i in range(1, len(initial_strings)):\n            for j in range(i + 1, len(initial_strings)):\n                for k in range(j + 1, len(initial_strings)):\n                    yield ''.join(sorted(initial_strings[i:j+1] + initial_strings[j:k+1] + initial_strings[k:]))\n\n    composite_strings = sorted(get_composite_strings(initial_strings))\n    test_composite_string_index = composite_strings.index(test_composite_string)\n    return str((test_composite_string_index + 1) % (10**9 + 7))"
    },
    {
        "number": 3633,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def find_permutation(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n        return scores\n\n    def find_best_permutation(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores_and_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores_and_scores_and_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores\n        return scores\n\n    def find_best_permutation_with_scores_and_scores_and_scores_and_scores_and_scores_and_scores_and_scores_and_scores(scores: list) -> list:\n        n = len(scores)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if scores[i] + scores[j] > k:\n                    scores[i], scores[j] = scores[j], scores[i]\n                    break\n            else:\n                return scores"
    },
    {
        "number": 3634,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    log = [list(map(int, line.split())) for line in stdin.split()[1:]]\n    log.sort(key=lambda x: x[0])\n\n    def count_ways(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return 1\n\n        ways = 0\n        for i in range(start, end + 1):\n            if i % 1 == 0:\n                ways += count_ways(start, i - 1)\n            else:\n                ways += count_ways(i + 1, end)\n\n        return ways\n\n    ways = 0\n    for i in range(len(log)):\n        for j in range(i + 1, len(log)):\n            if log[i][1] < log[j][0]:\n                ways += count_ways(log[i][0], log[j][1])\n\n    return str(ways % 1000000009)"
    },
    {
        "number": 3635,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    briefcases, bananas = map(int, stdin.split())\n    bananas_per_briefcase = [int(x) for x in stdin.split()]\n\n    def find_min_bananas(bananas_per_briefcase: List[int]) -> int:\n        min_bananas = bananas_per_briefcase[0]\n        for banana in bananas_per_briefcase:\n            if banana < min_bananas:\n                min_bananas = banana\n        return min_bananas\n\n    def find_max_bananas(bananas_per_briefcase: List[int]) -> int:\n        max_bananas = bananas_per_briefcase[0]\n        for banana in bananas_per_briefcase:\n            if banana > max_bananas:\n                max_bananas = banana\n        return max_bananas\n\n    def find_min_briefcases(bananas_per_briefcase: List[int]) -> int:\n        min_briefcases = bananas_per_briefcase[0]\n        for briefcase in bananas_per_briefcase:\n            if briefcase < min_briefcases:\n                min_briefcases = briefcase\n        return min_briefcases\n\n    def find_max_briefcases(bananas_per_briefcase: List[int]) -> int:\n        max_briefcases = bananas_per_briefcase[0]\n        for briefcase in bananas_per_briefcase:\n            if briefcase > max_briefcases:\n                max_briefcases = briefcase\n        return max_briefcases\n\n    min_bananas = find_min_bananas(bananas_per_briefcase)\n    max_bananas = find_max_bananas(bananas_per_briefcase)\n    min_briefcases = find_min_briefcases(bananas_per_briefcase)\n    max_briefcases = find_max_briefcases(bananas_per_briefcase)\n\n    max_executives = 0\n    for i in range(min_briefcases, max_briefcases + 1):\n        if i <= min_executives:\n            max_executives += 1\n        elif i <= max_executives:\n            max_executives += 1\n        else:\n            break\n\n    return str(max_executives)"
    },
    {
        "number": 3636,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    if n * m % p!= 0:\n        return \"Invalid input\"\n\n    def is_valid(grid: List[List[int]], row: int, col: int) -> bool:\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if grid[i][j] == 1:\n                    return False\n        return True\n\n    def count_ways(grid: List[List[int]]) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    count += 1\n                    for k in range(i, i + 2):\n                        for l in range(j, j + 2):\n                            if is_valid(grid, k, l):\n                                grid[k][l] = 1\n                                count += count_ways(grid)\n                                grid[k][l] = 0\n        return count\n\n    return str(count_ways(create_grid(n, m))) % p\n\n\ndef"
    },
    {
        "number": 3637,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *wishes = stdin.split('\\n')\n    wishes = [tuple(wish.split()) for wish in wishes]\n    wishes = {wish[0]: wish[1] for wish in wishes}\n\n    def count_wishes(wish: str) -> int:\n        return wishes[wish].count('+') - wishes[wish].count('-')\n\n    def count_friends(wish: str) -> int:\n        return sum(1 for friend, _ in wishes.items() if wishes[friend].count(wish) > 0)\n\n    def count_fulfilled(wish: str) -> int:\n        return sum(1 for _, friend in wishes.items() if wishes[friend].count(wish) > 0)\n\n    def is_fulfilled(wish: str) -> bool:\n        return count_fulfilled(wish) > count_friends(wish) * 2 // 3\n\n    toppings = sorted(set(wish for wish in wishes if is_fulfilled(wish)))\n    return''.join(toppings)"
    },
    {
        "number": 3638,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    predictions = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def count_matches(prediction: str) -> int:\n        return sum(1 for i in range(n) if prediction[i] == 'R' and (i == 0 or prediction[i-1] == 'S') or prediction[i] == 'S' and (i == n-1 or prediction[i+1] == 'R'))\n\n    matches = [count_matches(prediction) for prediction in predictions]\n    max_matches = max(matches)\n    max_matches_indices = [i for i, match in enumerate(matches) if match == max_matches]\n\n    result = []\n    for i in max_matches_indices:\n        result.append(predictions[i])\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3639,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, c, d = map(float, stdin.split())\n    rain = [int(x) for x in stdin.split()[1:]]\n\n    def get_rain_and_sweat(t: int) -> float:\n        if t == 0:\n            return 0, 0\n        rain_t = rain[t - 1]\n        sweat_t = c * (d / 1000) ** 2 * (t / 60) ** 2\n        return rain_t, sweat_t\n\n    def get_min_rain_and_sweat(t: int) -> float:\n        min_rain = min(rain)\n        min_sweat = c * (d / 1000) ** 2 * (t / 60) ** 2\n        return min_rain, min_sweat\n\n    def get_max_rain_and_sweat(t: int) -> float:\n        max_rain = max(rain)\n        max_sweat = c * (d / 1000) ** 2 * (t / 60) ** 2\n        return max_rain, max_sweat\n\n    def get_min_rain_and_sweat_time(t: int) -> int:\n        min_rain, min_sweat = get_min_rain_and_sweat(t)\n        return t - (min_sweat / (c * (d / 1000) ** 2))\n\n    def get_max_rain_and_sweat_time(t: int) -> int:\n        max_rain, max_sweat = get_max_rain_and_sweat(t)\n        return t - (max_sweat / (c * (d / 1000) ** 2))\n\n    min_rain_and_sweat_time = get_min_rain_and_sweat_time(T)\n    max_rain_and_sweat_time = get_max_rain_and_sweat_time(T)\n\n    if min_rain_and_sweat_time == max_rain_and_sweat_time:\n        return str(min_rain_and_sweat_time)\n    else:\n        return str(min(min_rain_and_sweat_time, max_rain_and_sweat_time))"
    },
    {
        "number": 3640,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.lower()\n    n = len(S)\n    meow_factor = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for m in range(l + 1, n + 1):\n                        for n in range(m + 1, n + 1):\n                            if S[i:j] == \"meow\" and S[j:k] == \"meow\" and S[k:l] == \"meow\" and S[l:m] == \"meow\" and S[m:n] == \"meow\":\n                                meow_factor += 1\n\n    return str(meow_factor)"
    },
    {
        "number": 3641,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    beads = list(map(int, stdin.split()))\n    beads.sort()\n    total_weight = sum(beads)\n    if total_weight % k!= 0:\n        return \"NO\"\n    beads_per_person = total_weight // k\n    for i in range(k):\n        if beads_per_person * (i + 1) > beads[i]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3642,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[1:3])\n        edges.append((a - 1, b - 1))\n    magic = [int(stdin.split()[i + 1]) for i in range(n)]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def path_magic(path):\n        magic_sum = 1\n        for i in range(len(path) - 1):\n            magic_sum *= magic[path[i]]\n            magic_sum //= magic[path[i + 1]]\n        return magic_sum\n\n    def min_magic_path(magic_sum):\n        path = []\n        for i in range(n):\n            if magic_sum % magic[i] == 0:\n                path.append(i)\n                magic_sum //= magic[i]\n            else:\n                break\n        return path\n\n    min_magic = float('inf')\n    min_path = []\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            path = edges[i - 1] + edges[j - 1]\n            magic_sum = path_magic(path)\n            if magic_sum < min_magic:\n                min_magic = magic_sum\n                min_path = path\n\n    P, Q = min_magic, 1\n    for i in range(2, min_magic + 1):\n        if gcd(i, min_magic) == 1:\n            P = i\n            break\n    for i in range(2, min_magic + 1):\n        if gcd(min_magic, i) == 1:\n            Q = i\n            break\n\n    return f\"{P}/{Q}\""
    },
    {
        "number": 3643,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    L = list(map(float, stdin.split()[1:]))\n    R = list(map(float, stdin.split()[1:]))\n\n    def sue(i: int, j: int) -> int:\n        return max(0, R[i] - L[j])\n\n    damages = 0\n    for i in range(2, N):\n        for j in range(i):\n            damages += sue(i, j)\n\n    return str(damages / (N ** 2))"
    },
    {
        "number": 3644,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    firing_counts = [int(x) for x in stdin.split()[1:]]\n    hiring_counts = [0] * n\n\n    for i in range(n):\n        hiring_counts[i] = firing_counts[i]\n\n    for i in range(n - 1, 0, -1):\n        hiring_counts[i] = max(0, hiring_counts[i] - hiring_counts[i - 1])\n\n    k = 1\n    for i in range(n):\n        if hiring_counts[i] > 0:\n            k += 1\n\n    result = [str(k)]\n    for i in range(n):\n        result.append(str(i + 1))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3645,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    paper_numbers = list(map(int, stdin.split()[1:]))\n\n    def find_closest_integer(x: int) -> int:\n        closest_integer = None\n        closest_distance = float('inf')\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                distance = abs(paper_numbers[i] - paper_numbers[j])\n                if distance < closest_distance:\n                    closest_distance = distance\n                    closest_integer = paper_numbers[i]\n\n        return closest_integer\n\n    def find_closest_pair(x: int) -> int:\n        closest_pair = None\n        closest_distance = float('inf')\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    distance = abs(paper_numbers[i] - paper_numbers[j]) + abs(paper_numbers[j] - paper_numbers[k]) + abs(paper_numbers[k] - paper_numbers[i])\n                    if distance < closest_distance:\n                        closest_distance = distance\n                        closest_pair = (paper_numbers[i], paper_numbers[j], paper_numbers[k])\n\n        return closest_pair\n\n    x = find_closest_integer(1)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(2)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(3)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(4)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(5)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(6)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(7)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(8)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(9)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(10)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(11)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(12)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(13)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(14)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(15)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(16)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(17)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(18)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(19)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(20)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(21)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(22)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(23)\n    if x is not None:\n        print(x)\n    else:\n        print(\"none\")\n\n    x = find_closest_integer(24)"
    },
    {
        "number": 3646,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pebbles = list(map(int, stdin.split()[1:]))\n\n    def find_most_distant_pebble(pebbles: List[int]) -> int:\n        def is_valid_jump(pebbles: List[int], i: int, j: int) -> bool:\n            return pebbles[i] + pebbles[j] == j - i\n\n        def dfs(pebbles: List[int], visited: Set[int], i: int, j: int) -> int:\n            if i == j:\n                return 0\n\n            if (i, j) in visited:\n                return 0\n\n            visited.add((i, j))\n\n            if is_valid_jump(pebbles, i, j):\n                return 1 + min(dfs(pebbles, visited, i + 1, j), dfs(pebbles, visited, i, j - 1))\n\n            return 0\n\n        return dfs(pebbles, set(), 0, len(pebbles) - 1)\n\n    return str(find_most_distant_pebble(pebbles))\n"
    },
    {
        "number": 3647,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split()[0].split())\n    maze = [list(row) for row in stdin.split()[1:]]\n\n    def is_obstacle(row: int, col: int) -> bool:\n        return maze[row][col] in ['#', '_']\n\n    def is_ice(row: int, col: int) -> bool:\n        return maze[row][col] == '_'\n\n    def is_goal(row: int, col: int) -> bool:\n        return maze[row][col] == 'M'\n\n    def get_neighbors(row: int, col: int) -> List[Tuple[int, int]]:\n        return [(row + dr, col + dc) for dr in [-1, 0, 1] for dc in [-1, 0, 1] if 0 <= row + dr < rows and 0 <= col + dc < cols]\n\n    def get_moves(row: int, col: int) -> int:\n        moves = 0\n        for neighbor in get_neighbors(row, col):\n            if is_obstacle(*neighbor):\n                return -1\n            if is_ice(*neighbor):\n                moves += 1\n            if is_goal(*neighbor):\n                return moves\n        return -1\n\n    def bfs(start: Tuple[int, int]) -> List[Tuple[int, int]]:\n        queue = deque([start])\n        visited = set()\n        while queue:\n            row, col = queue.popleft()\n            if (row, col) == goal:\n                return [goal]\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    queue.append(neighbor)\n        return []\n\n    def dfs(start: Tuple[int, int]) -> List[Tuple[int, int]]:\n        stack = [(start, 0)]\n        visited = set()\n        while stack:\n            row, col, moves = stack.pop()\n            if (row, col) == goal:\n                return [goal]\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    stack.append((neighbor, moves))\n        return []\n\n    def dijkstra(start: Tuple[int, int]) -> int:\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            cost, (row, col) = queue.pop(0)\n            if (row, col) == goal:\n                return cost\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    queue.append((cost + 1, neighbor))\n        return -1\n\n    def bfs_solution(start: Tuple[int, int]) -> int:\n        queue = deque([start])\n        visited = set()\n        while queue:\n            row, col = queue.popleft()\n            if (row, col) == goal:\n                return cost\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    queue.append(neighbor)\n        return -1\n\n    def dfs_solution(start: Tuple[int, int]) -> int:\n        stack = [(start, 0)]\n        visited = set()\n        while stack:\n            row, col, moves = stack.pop()\n            if (row, col) == goal:\n                return moves\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    stack.append((neighbor, moves + 1))\n        return -1\n\n    def dijkstra_solution(start: Tuple[int, int]) -> int:\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            cost, (row, col) = queue.pop(0)\n            if (row, col) == goal:\n                return cost\n            visited.add((row, col))\n            for neighbor in get_neighbors(row, col):\n                if neighbor not in visited and is_obstacle(*neighbor):\n                    queue.append((cost + 1, neighbor))\n        return -1\n\n    moves = []\n    for row in range(rows):\n        for col in range(cols):\n            if is_ice(row, col):\n                moves.append(get_moves(row, col))\n            elif is_obstacle(row, col):\n                moves.append(-1)\n            elif is_goal(row, col):\n                moves.append(0)\n\n    moves = [min(moves)]"
    },
    {
        "number": 3648,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    insecure_buildings = list(map(int, stdin.split()))\n    lines = []\n    for _ in range(m):\n        x, y, l = map(int, stdin.split())\n        lines.append((x, y, l))\n\n    def is_insecure(b: int) -> bool:\n        return b in insecure_buildings\n\n    def is_connected(a: int, b: int) -> bool:\n        for x, y, l in lines:\n            if a == x and b == y or a == y and b == x:\n                return True\n        return False\n\n    def min_cost(a: int, b: int) -> int:\n        if a == b:\n            return 0\n        for x, y, l in lines:\n            if a == x and b == y or a == y and b == x:\n                return l\n        return float('inf')\n\n    def dfs(a: int, visited: set) -> int:\n        if a in visited:\n            return float('inf')\n        visited.add(a)\n        cost = 0\n        for b in range(1, n + 1):\n            if is_connected(a, b) and not is_insecure(b):\n                cost += min_cost(a, b)\n                cost = min(cost, dfs(b, visited))\n        return cost\n\n    cheapest_cost = float('inf')\n    for a in range(1, n + 1):\n        if not is_insecure(a):\n            visited = set()\n            cheapest_cost = min(cheapest_cost, dfs(a, visited))\n\n    if cheapest_cost == float('inf'):\n        return 'impossible'\n    else:\n        return str(cheapest_cost)"
    },
    {
        "number": 3649,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d!= 1:\n        return \"impossible\"\n\n    def count_subsequences(s: str, subseq: str) -> int:\n        count = 0\n        for i in range(len(s) - len(subseq) + 1):\n            if s[i:i + len(subseq)] == subseq:\n                count += 1\n        return count\n\n    def generate_bitstring(a: int, b: int, c: int, d: int) -> str:\n        bitstring = \"\"\n        for _ in range(a):\n            bitstring += \"0\"\n        for _ in range(b):\n            bitstring += \"1\"\n        for _ in range(c):\n            bitstring += \"0\"\n        for _ in range(d):\n            bitstring += \"1\"\n        return bitstring\n\n    bitstring = generate_bitstring(a, b, c, d)\n    while True:\n        if count_subsequences(bitstring, \"00\") == a and count_subsequences(bitstring, \"01\") == b and count_subsequences(bitstring, \"10\") == c and count_subsequences(bitstring, \"11\") == d:\n            return bitstring\n        else:\n            bitstring = generate_bitstring(a, b, c, d)"
    },
    {
        "number": 3650,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b = map(int, stdin.split())\n    target_board = []\n    for _ in range(b):\n        r, c = map(int, stdin.split())\n        target_board.append((r - 1, c - 1))\n\n    initial_board = []\n    for i in range(n):\n        row = list(stdin.readline().strip())\n        initial_board.append([row.index(c) for c in row])\n\n    def is_valid(board: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == -1:\n                    continue\n                for k in range(i - 1, -1, -1):\n                    if board[k][j]!= -1:\n                        return False\n                for k in range(j - 1, -1, -1):\n                    if board[i][k]!= -1:\n                        return False\n        return True\n\n    def bfs(board: List[List[int]]) -> List[Tuple[int, int]]:\n        queue = deque([(0, 0)])\n        visited = set()\n        while queue:\n            x, y = queue.popleft()\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if board[x][y] == -1:\n                continue\n            if (x, y) == (n - 1, m - 1):\n                return [(x, y)]\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n        return []\n\n    def dfs(board: List[List[int]], target: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        if not target:\n            return [(x, y) for x in range(n) for y in range(m) if board[x][y] == -1]\n        x, y = target[0]\n        if board[x][y] == -1:\n            return [(x, y)]\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and board[nx][ny] == -1:\n                for move in dfs(board, target[1:]):\n                    yield (x, y) + move\n\n    def solve(board: List[List[int]]) -> List[Tuple[str, int]]:\n        if not is_valid(board):\n            return []\n        target = bfs(board)\n        if not target:\n            return []\n        moves = dfs(board, target)\n        return [(move[0], move[1]) for move in moves]\n\n    moves = solve(initial_board)\n    if not moves:\n        return \"impossible\"\n    return \"possible\\n\" + \"\\n\".join(f\"{move[0]} {move[1]}\" for move in moves)"
    },
    {
        "number": 3651,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    planets = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split()[1:])\n        planets.append((x, y, z))\n\n    def distance(a: tuple, b: tuple) -> float:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def portal_distance(a: tuple, b: tuple) -> float:\n        return distance(a, b)\n\n    def portal_collision(a: tuple, b: tuple) -> bool:\n        return distance(a, b) < 0.0001\n\n    def portal_usage(a: tuple, b: tuple) -> bool:\n        return portal_distance(a, b) == 0\n\n    def portal_usage_count(a: tuple, b: tuple) -> int:\n        return sum(portal_usage(a, b) for _ in range(n))\n\n    def portal_usage_count_max(a: tuple, b: tuple) -> int:\n        return max(portal_usage_count(a, b) for _ in range(n))\n\n    def portal_usage_count_min(a: tuple, b: tuple) -> int:\n        return min(portal_usage_count(a, b) for _ in range(n))\n\n    def portal_usage_count_sum(a: tuple, b: tuple) -> int:\n        return sum(portal_usage_count(a, b) for _ in range(n))\n\n    def portal_usage_count_average(a: tuple, b: tuple) -> float:\n        return sum(portal_usage_count(a, b) for _ in range(n)) / n\n\n    def portal_usage_count_median(a: tuple, b: tuple) -> float:\n        return sorted(portal_usage_count(a, b) for _ in range(n))[n // 2]\n\n    def portal_usage_count_mode(a: tuple, b: tuple) -> int:\n        return max(set(portal_usage_count(a, b) for _ in range(n)), key=portal_usage_count_count)\n\n    def portal_usage_count_count(a: tuple, b: tuple) -> int:\n        return portal_usage_count(a, b)\n\n    def portal_usage_count_variance(a: tuple, b: tuple) -> float:\n        return sum((portal_usage_count(a, b) - portal_usage_count_average(a, b)) ** 2 for _ in range(n)) / n\n\n    def portal_usage_count_standard_deviation(a: tuple, b: tuple) -> float:\n        return (portal_usage_count_variance(a, b) ** 0.5)\n\n    def portal_usage_count_quartile_1(a: tuple, b: tuple) -> float:\n        return sorted(portal_usage_count(a, b) for _ in range(n))[n // 4]\n\n    def portal_usage_count_quartile_3(a: tuple, b: tuple) -> float:\n        return sorted(portal_usage_count(a, b) for _ in range(n))[3 * n // 4]\n\n    def portal_usage_count_interquartile_range(a: tuple, b: tuple) -> float:\n        return portal_usage_count_quartile_3(a, b) - portal_usage_count_quartile_1(a, b)\n\n    def portal_usage_count_skewness(a: tuple, b: tuple) -> float:\n        return (portal_usage_count_average(a, b) - portal_usage_count_median(a, b)) / (portal_usage_count_interquartile_range(a, b) ** 1.5)\n\n    def portal_usage_count_kurtosis(a: tuple, b: tuple) -> float:\n        return (portal_usage_count_average(a, b) - portal_usage_count_median(a, b)) / (portal_usage_count_interquartile_range(a, b) ** 2)\n\n    def portal_usage_count_entropy(a: tuple, b: tuple) -> float:\n        from scipy.stats import entropy\n\n        return entropy(portal_usage_count(a, b) for _ in range(n))\n\n    def portal_usage_count_correlation(a: tuple, b:"
    },
    {
        "number": 3652,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    table = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    for i in range(n):\n        table[i].sort()\n\n    min_cols = n\n    for i in range(n):\n        if table[i]!= table[0]:\n            min_cols = min(min_cols, n - i)\n\n    return str(min_cols)"
    },
    {
        "number": 3653,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, x1, y1, x2, y2 = map(int, stdin.split())\n    if x1 == x2 or y1 == y2:\n        return \"Infinity\"\n\n    dx = x2 - x1\n    dy = y2 - y1\n    if dx == 0:\n        return abs(y2)\n    elif dy == 0:\n        return abs(x2)\n    else:\n        gcd = gcd(dx, dy)\n        dx //= gcd\n        dy //= gcd\n        return abs(x2) + abs(y2)\n\ndef"
    },
    {
        "number": 3654,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k > 100 or n > 1000000:\n        return \"Invalid input\"\n\n    def fibonacci(n: int) -> int:\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n\n    def f(k: int, n: int) -> int:\n        if k == 1:\n            return 42\n        elif k == 2:\n            return 11 * k + 77\n        else:\n            return 2 * f(k - 1, n - 1) - f(k - 2, n - 2) + 10 * k\n\n    result = 0\n    for i in range(n):\n        result += fibonacci(i)\n\n    return str(result)"
    },
    {
        "number": 3655,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    floor_image = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    robot_image = [list(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def count_same_pixels(image1: list, image2: list) -> int:\n        return sum(sum(image1[i][j] == image2[i][j] for j in range(len(image1[0]))) for i in range(len(image1)))\n\n    def find_candidates(floor_image: list, robot_image: list) -> list:\n        candidates = []\n        for i in range(len(floor_image)):\n            for j in range(len(floor_image[0])):\n                if floor_image[i][j] == 1 and robot_image[i][j] == 1:\n                    candidates.append((i, j))\n        return candidates\n\n    candidates = find_candidates(floor_image, robot_image)\n    candidates.sort(key=lambda x: (x[0], x[1]))\n    return''.join(f'{x} {y}' for x, y in candidates)"
    },
    {
        "number": 3656,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, T, f = map(int, stdin.split())\n    bugs = []\n    for _ in range(B):\n        p, s = map(float, stdin.split())\n        bugs.append((p, s))\n    total_severity = 0\n    for _ in range(T):\n        p, s = max(bugs, key=lambda x: x[0])\n        if p > 0:\n            p -= f\n            if p <= 0:\n                p = 0\n            bugs = [(p, s)]\n        total_severity += s\n    return f\"{total_severity:.6f}\""
    },
    {
        "number": 3657,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, v_h, N = map(int, stdin.split())\n    gates = []\n    for _ in range(N):\n        x, y = map(int, stdin.split())\n        gates.append((x, y))\n\n    S = int(stdin.split()[1])\n    skis = []\n    for _ in range(S):\n        s = int(stdin.split()[1])\n        skis.append(s)\n\n    gates.sort(key=lambda x: x[1])\n    skis.sort(reverse=True)\n\n    left_gate = gates[0]\n    right_gate = gates[-1]\n    left_skis = skis[0]\n    right_skis = skis[-1]\n\n    left_x, left_y = left_gate\n    right_x, right_y = right_gate\n\n    left_distance = left_y - left_skis\n    right_distance = right_x - right_skis\n\n    if left_distance > right_distance:\n        return \"IMPOSSIBLE\"\n\n    if left_distance == right_distance:\n        return \"IMPOSSIBLE\"\n\n    if left_distance < right_distance:\n        left_distance = right_distance\n\n    time = left_distance / left_skis\n    time += right_distance / right_skis\n\n    if time > 1:\n        return \"IMPOSSIBLE\"\n\n    return str(left_skis)"
    },
    {
        "number": 3658,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pine_trees, aspens = map(int, stdin.split())\n    pine_trees_locations = []\n    aspens_locations = []\n\n    for _ in range(pine_trees):\n        x, y = map(float, stdin.split())\n        pine_trees_locations.append((x, y))\n\n    for _ in range(aspens):\n        x, y = map(float, stdin.split())\n        aspens_locations.append((x, y))\n\n    pine_trees_locations.sort(key=lambda x: x[0])\n    aspens_locations.sort(key=lambda x: x[0])\n\n    pine_trees_covered = 0\n    aspens_covered = 0\n\n    for i in range(len(pine_trees_locations)):\n        pine_tree = pine_trees_locations[i]\n        for j in range(i + 1, len(pine_trees_locations)):\n            if pine_tree[0] < pine_trees_locations[j][0] < pine_tree[0] + 0.2 and pine_tree[1] < pine_trees_locations[j][1] < pine_tree[1] + 0.2:\n                pine_trees_covered += 1\n                break\n\n    for i in range(len(aspens_locations)):\n        aspen = aspens_locations[i]\n        for j in range(i + 1, len(aspens_locations)):\n            if aspen[0] < aspens_locations[j][0] < aspen[0] + 0.2 and aspen[1] < aspens_locations[j][1] < aspen[1] + 0.2:\n                aspens_covered += 1\n                break\n\n    return str(pine_trees_covered + aspens_covered)"
    },
    {
        "number": 3659,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    books = []\n    for _ in range(n):\n        h, t = map(int, stdin.split()[1:])\n        books.append((h, t))\n    books.sort(key=lambda x: (-x[0], -x[1]))\n    height = sum(book[0] for book in books)\n    width = sum(book[1] for book in books)\n    area = height * width\n    shelves = 3\n    while area > 1000000:\n        area -= height * width\n        shelves += 1\n    return str(area)"
    },
    {
        "number": 3660,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message, n = stdin.split('\\n')\n    message = message.upper()\n    stickers = []\n    for i in range(n):\n        word, price = stdin.split('\\n')\n        stickers.append((word, int(price)))\n\n    stickers.sort(key=lambda x: x[1])\n    total_cost = 0\n    message_length = len(message)\n    for i in range(message_length):\n        for j in range(i + 1, message_length + 1):\n            if j - i > 2:\n                break\n            overlap = 0\n            for k in range(i, j):\n                if message[k] == message[i]:\n                    overlap += 1\n                    if overlap > 2:\n                        break\n            if overlap == 2:\n                total_cost += stickers[i][1] + stickers[j - 1][1]\n                break\n\n    if total_cost == 0:\n        return 'IMPOSSIBLE'\n    else:\n        return str(total_cost)"
    },
    {
        "number": 3661,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S, L = map(int, stdin.split())\n    A = [list(map(int, stdin.split())) for _ in range(L)]\n    B = [list(map(int, stdin.split())) for _ in range(L)]\n\n    def find_winner(A, B):\n        max_count = 0\n        winner = None\n        for a in A:\n            count = 0\n            for b in B:\n                if a[0] == b[0] and a[1] == b[1]:\n                    count += 1\n            if count > max_count:\n                max_count = count\n                winner = a\n        return winner\n\n    def find_winner_for_lawsuit(A, B, i):\n        A_i, B_i = A[i], B[i]\n        A_winners = [find_winner(A[:i] + A[i+1:], B[:i] + B[i+1:]) for i in range(len(A))]\n        B_winners = [find_winner(A[:i] + A[i+1:], B[:i] + B[i+1:]) for i in range(len(B))]\n        return A_winners[B_winners.index(find_winner(A_i, B_i))]\n\n    return '\\n'.join(find_winner_for_lawsuit(A, B, i) for i in range(L))"
    },
    {
        "number": 3662,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, W = map(int, stdin.split())\n    trees = [int(x) for x in stdin.split()]\n    trees.sort()\n    total_distance = 0\n    for i in range(N):\n        total_distance += abs(trees[i] - L)\n    return str(total_distance)"
    },
    {
        "number": 3663,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    routes = []\n    for i in range(n - 1):\n        u, v, c = map(int, stdin.split())\n        routes.append((u, v, c))\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        routes.append((i, i, x))\n        routes.append((i, i, y))\n\n    routes.sort(key=lambda x: (x[1], x[0]))\n\n    total_cost = 0\n    for u, v, c in routes:\n        total_cost += c\n\n    return str(total_cost)"
    },
    {
        "number": 3664,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, i, j, n = map(int, stdin.split())\n    rink = [['.' for _ in range(c)] for _ in range(r)]\n    zamboni = [i - 1, j - 1]\n    direction = 0\n    color = 'A'\n\n    for _ in range(n):\n        if direction == 0:\n            if zamboni[0] == 0:\n                direction = 1\n            else:\n                zamboni[0] -= 1\n        elif direction == 1:\n            if zamboni[0] == r - 1:\n                direction = 2\n            else:\n                zamboni[0] += 1\n        elif direction == 2:\n            if zamboni[1] == 0:\n                direction = 3\n            else:\n                zamboni[1] -= 1\n        elif direction == 3:\n            if zamboni[1] == c - 1:\n                direction = 0\n            else:\n                zamboni[1] += 1\n\n        if direction == 0:\n            rink[zamboni[0]][zamboni[1]] = color\n            color = chr((ord(color) + 1) % 26)\n        elif direction == 1:\n            rink[zamboni[0]][zamboni[1]] = color\n            color = chr((ord(color) + 1) % 26)\n        elif direction == 2:\n            rink[zamboni[0]][zamboni[1]] = color\n            color = chr((ord(color) + 1) % 26)\n        elif direction == 3:\n            rink[zamboni[0]][zamboni[1]] = color\n            color = chr((ord(color) + 1) % 26)\n\n    return '\\n'.join([''.join(row) for row in rink])"
    },
    {
        "number": 3665,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    nums = [int(num.zfill(m)) for num in stdin.split()]\n\n    def lossy_sort(nums):\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] > nums[j]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return nums\n\n    def min_digit_changes(nums):\n        min_changes = float('inf')\n        for i in range(1, m + 1):\n            for j in range(len(nums)):\n                for k in range(j + 1, len(nums)):\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums[j]\n                    if nums[j] > nums[k]:\n                        nums[j], nums[k] = nums[k], nums["
    },
    {
        "number": 3666,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    gear_ratios = [int(x.split('/')[0]) / int(x.split('/')[1]) for x in stdin.split('\\n')]\n    front_sprocket_sizes = [19, 20]\n    rear_sprocket_sizes = [17, 15, 14, 13, 7, 2]\n\n    for ratio in gear_ratios:\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17, 19 / 2, 19 / 17]:\n            continue\n        if ratio in [19 / 13, 10 / 1, 19 / 14, 4 / 3, 20 / 7, 19 / 7, 20 / 13, 19 / 15, 10 / 7, 20 / 17"
    },
    {
        "number": 3667,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, p = map(int, stdin.split())\n    wells = [tuple(map(int, stdin.split())) for _ in range(w)]\n    pipes = []\n    for _ in range(p):\n        s, x, y = map(int, stdin.split())\n        pipes.append((s, (x, y)))\n\n    def is_valid(x, y):\n        return all(0 <= i <= w for i in x) and all(0 <= j <= 2 for j in y)\n\n    def is_valid_intersection(x, y):\n        return all(is_valid(i, j) for i, j in zip(x, y))\n\n    def clean_intersection(x, y):\n        for i, j in zip(x, y):\n            if is_valid(i, j):\n                robots.append(Robot(i, j))\n\n    def clean_well(i):\n        for x, y in pipes:\n            if x == i:\n                clean_intersection(x, y)\n\n    robots = []\n    for i in range(1, w + 1):\n        clean_well(i)\n\n    if len(robots) == 0:\n        return \"possible\"\n    else:\n        return \"impossible\"\n\n\nclass Robot:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        self.visited = set()\n\n    def move(self, x, y):\n        if (x, y) in self.visited:\n            return False\n        self.visited.add((x, y))\n        return True\n\n\ndef"
    },
    {
        "number": 3668,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colleagues = list(map(int, stdin.split()))\n    colleagues.sort()\n    max_count = 0\n    for i in range(m):\n        count = 0\n        for j in range(n):\n            if colleagues[j] == i + 1:\n                count += 1\n        max_count = max(max_count, count)\n    return str(max_count)"
    },
    {
        "number": 3669,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n    for i in range(n - 1):\n        if points[i][0] == points[i + 1][0]:\n            return \"Mirko\"\n    return \"Slavko\""
    },
    {
        "number": 3670,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = list(map(int, stdin.split()[1:]))\n    m = 1\n    while True:\n        remainder = sum(numbers) % m\n        if remainder == 0:\n            break\n        m += 1\n    return \" \".join(map(str, range(m, m * n + 1, m)))"
    },
    {
        "number": 3671,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    times = list(map(int, stdin.split()[1:]))\n\n    cookies = 0\n    for i in range(n):\n        if i % 2 == 0:\n            cookies += 1\n\n    return str(cookies)"
    },
    {
        "number": 3672,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    resources = [[] for _ in range(n + 1)]\n    for i in range(m):\n        line = stdin.split()\n        for j in range(n):\n            if line[j]!= '0':\n                resources[int(line[j])].append(i)\n    zax_resources = [[] for _ in range(n + 1)]\n    xaz_resources = [[] for _ in range(n + 1)]\n    for i in range(n):\n        zax_resources[i] = resources[i]\n        xaz_resources[i] = resources[i]\n    for i in range(n, 2 * n):\n        zax_resources[i] = resources[i - n]\n        xaz_resources[i] = resources[i - n]\n    for i in range(2 * n):\n        if len(zax_resources[i]) == 0 or len(xaz_resources[i]) == 0:\n            return 'NO'\n    return 'YES'"
    },
    {
        "number": 3673,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    for i in range(n):\n        if a[i] == i + 1:\n            continue\n        else:\n            break\n    else:\n        return \"Impossible\"\n    arrows = [[] for _ in range(n)]\n    for i in range(n):\n        arrows[a[i] - 1].append(i + 1)\n    for i in range(n):\n        if len(arrows[i]) == 0:\n            return \"Impossible\"\n    for i in range(n):\n        if len(arrows[i]) == 1:\n            arrows[i].append(arrows[i][0])\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted(arrow) for arrow in arrows]\n    arrows = [sorted(set(arrow)) for arrow in arrows]\n    arrows = [sorted"
    },
    {
        "number": 3674,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, p, q = map(int, stdin.split())\n    if m < n:\n        return \"IMPOSSIBLE\"\n\n    def cross_out(num: int, n: int) -> int:\n        return num * 10 ** (m - n) + p\n\n    def multiply(num1: int, num2: int) -> int:\n        return num1 * num2\n\n    def find_number(num: int) -> int:\n        for i in range(1, 10):\n            if num % 10 == i:\n                return num\n        return -1\n\n    def is_valid(num: int) -> bool:\n        return num >= 10 ** (m - n) and num % 10!= 0\n\n    def cross_out_and_multiply(num: int) -> int:\n        cross_out_num = cross_out(num, n)\n        if cross_out_num == num:\n            return -1\n        cross_out_num = find_number(cross_out_num)\n        if cross_out_num == -1:\n            return -1\n        cross_out_num = multiply(cross_out_num, q)\n        return cross_out_num\n\n    def find_smallest_number(start: int) -> int:\n        if start == 10 ** m:\n            return start\n        num = find_number(start)\n        if num == -1:\n            return -1\n        num = multiply(num, 10)\n        return find_smallest_number(num)\n\n    smallest_number = find_smallest_number(1)\n    if smallest_number == -1:\n        return \"IMPOSSIBLE\"\n    return str(smallest_number)"
    },
    {
        "number": 3675,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    strings = [list(input()) for _ in range(n)]\n    strings = [sorted(s) for s in strings]\n\n    def lcs(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lcs(strings[i], strings[j]) > max_length:\n                max_length = lcs(strings[i], strings[j])\n\n    return str(max_length)"
    },
    {
        "number": 3676,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    if R == 1 and C == 1:\n        return \"1\"\n    if R == 1:\n        return \"2\"\n    if C == 1:\n        return \"2\"\n    if R == 2 and C == 2:\n        return \"3\"\n    if R == 2:\n        return \"6\"\n    if C == 2:\n        return \"6\"\n    if R == 3 and C == 3:\n        return \"7\"\n    if R == 3:\n        return \"24\"\n    if C == 3:\n        return \"24\"\n    if R == 4 and C == 4:\n        return \"25\"\n    if R == 4:\n        return \"120\"\n    if C == 4:\n        return \"120\"\n    return \"?\""
    },
    {
        "number": 3677,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    disagreements = [[] for _ in range(N)]\n    for i in range(N):\n        disagreements[i] = list(map(int, stdin.split()[1:]))\n\n    def find_largest_committee(disagreements: List[List[int]]) -> int:\n        def dfs(committee: List[int], visited: Set[int]) -> int:\n            if len(committee) == K:\n                return 1\n            if len(committee) > K:\n                return 0\n\n            for i in range(N):\n                if i not in visited and disagreements[i] not in committee:\n                    visited.add(i)\n                    committee.append(i)\n                    if dfs(committee, visited) == 1:\n                        return 1\n                    committee.pop()\n                    visited.remove(i)\n            return 0\n\n        return dfs([], set())\n\n    return str(find_largest_committee(disagreements))"
    },
    {
        "number": 3678,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_loop(points: List[Tuple[int, int]], n: int) -> bool:\n        points.sort(key=lambda x: (x[0], x[1]))\n        for i in range(n - 1):\n            if points[i][0] == points[i + 1][0] == points[i + 2][0] == points[i + 3][0] == points[i + 4][0] == points[i + 5][0]:\n                return False\n            if points[i][0] == points[i + 1][0] or points[i][1] == points[i + 1][1] or points[i + 2][0] == points[i + 3][0] or points[i + 2][1] == points[i + 3][1] or points[i + 4][0] == points[i + 5][0] or points[i + 4][1] == points[i + 5][1]:\n                return False\n            if not is_perpendicular(points[i], points[i + 1], points[i + 2]):\n                return False\n            if not is_valid_segment(points[i], points[i + 1], points[i + 2]):\n                return False\n        return True\n\n    def is_perpendicular(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool:\n        return (p2[0] - p1[0]) * (p3[1] - p2[1]) == (p3[0] - p2[0]) * (p2[1] - p1[1])\n\n    def is_valid_segment(p1: Tuple[int, int], p2: Tuple[int, int], p3: Tuple[int, int]) -> bool:\n        return (p2[0] - p1[0]) * (p3[1] - p2[1])!= (p3[0] - p2[0]) * (p2[1] - p1[1])\n\n    def is_valid_points(points: List[Tuple[int, int]], n: int) -> bool:\n        return len(set(points)) == n\n\n    def is_valid_loop_conditions(points: List[Tuple[int, int]], n: int) -> bool:\n        return is_valid_points(points, n) and is_valid_loop(points, n)\n\n    def read_points(stdin: str) -> List[Tuple[int, int]]:\n        n = int(stdin.split()[0])\n        return [(int(x), int(y)) for x, y in [tuple(map(int, line.split())) for line in stdin.split()[1:n + 1]]]\n\n    def read_test_cases(stdin: str) -> int:\n        return int(stdin.split()[0])\n\n    def read_points_from_stdin(stdin: str) -> List[Tuple[int, int]]:\n        return read_points(stdin)\n\n    def read_test_cases_from_stdin(stdin: str) -> int:\n        return read_test_cases(stdin)\n\n    def main() -> None:\n        test_cases = read_test_cases_from_stdin(stdin)\n        for _ in range(test_cases):\n            points = read_points_from_stdin(stdin)\n            n = len(points)\n            if is_valid_loop_conditions(points, n):\n                print('YES')\n            else:\n                print('NO')\n\n    main()\n"
    },
    {
        "number": 3679,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    gifts = [f\"Gift {i}\" for i in range(1, n+1)]\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append(\"Your own gift\")\n    gifts.append"
    },
    {
        "number": 3680,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    poles = list(map(int, stdin.split()))\n\n    def cut_poles(poles, cuts):\n        if not poles:\n            return cuts\n\n        pole = poles.pop()\n        cuts = cut_poles(poles, cuts + 1)\n\n        if cuts == 0:\n            return cuts\n\n        if cuts % 2 == 0:\n            return cut_poles(poles, cuts)\n\n        if cuts % 2 == 1:\n            return cut_poles(poles, cuts + 1)\n\n    cuts = cut_poles(poles, 0)\n    return str(cuts)"
    },
    {
        "number": 3681,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    queries = []\n    for _ in range(q):\n        query = list(map(int, stdin.split()))\n        queries.append(query)\n\n    class_teachers = [[] for _ in range(n + 1)]\n    for query in queries:\n        if query[0] == 0:\n            class_teachers[query[1]].append(query[2:])\n        elif query[0] == 1:\n            print(class_teachers[query[1]][query[2] - 1])\n\n    return \"\"\n"
    },
    {
        "number": 3682,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    fragments = []\n    code_snippet = []\n\n    for line in stdin.splitlines():\n        if line.startswith(\"$\"):\n            if code_snippet:\n                fragments.append((code_snippet, code_snippet.count(\"\\n\") + 1))\n                code_snippet = []\n        else:\n            code_snippet.append(line.strip())\n\n    if code_snippet:\n        fragments.append((code_snippet, code_snippet.count(\"\\n\") + 1))\n\n    matches = []\n    for fragment, length in fragments:\n        longest_match = \"\"\n        for file_name, file_contents in repository.items():\n            if fragment in file_contents:\n                match = fragment.split(\"\\n\")\n                match_length = len(match)\n                if match_length > len(longest_match):\n                    longest_match = match\n                    longest_match_length = match_length\n\n        if longest_match:\n            matches.append((longest_match_length, file_name))\n\n    if not matches:\n        return \"0\"\n\n    matches.sort(reverse=True)\n    result = \"\"\n    for length, file_name in matches:\n        result += f\"{length} {file_name}\\n\"\n\n    return result.strip()\n\nrepository = {\n    \"HelloWorld.c\": [\n        \"int Main() {\",\n        \"  printf(\\\"Hello %d\\\\n\\\",i);\",\n        \"}\"\n    ],\n    \"Add.c\": [\n        \"int Main() {\",\n        \"  for (int i=0; i<10; i++)\",\n        \"    sum += i;\",\n        \"  printf(\\\"SUM %d\\\", sum);\",\n        \"}\"\n    ]\n}\n\nstdin = \"\"\"\n2\nHelloWorld.c\nint Main() {\n    printf(\"Hello %d\\n\",i);\n}\n***END***\nAdd.c\nint Main() {\n  for (int i=0; i<10; i++)\n    sum += i;\n  printf(\"SUM %d\", sum);\n}\n***END***\nint Main() {\n  printf(\"Hello %d\\n\",i);\n  printf(\"THE END\\n\");\n}\n***END***\n\"\"\"\n\nprint(solution(stdin))"
    },
    {
        "number": 3683,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players, holes = map(int, stdin.split())\n    scores = []\n    for _ in range(holes):\n        scores.append(list(map(int, stdin.split())))\n\n    def adjust_scores(scores: List[List[int]]) -> List[List[int]]:\n        for i in range(holes):\n            for j in range(players):\n                if scores[i][j] > l:\n                    scores[i][j] = l\n        return scores\n\n    l = max(max(scores[i]) for i in range(holes))\n    adjusted_scores = adjust_scores(scores)\n\n    ranks = []\n    for i in range(players):\n        total_score = sum(adjusted_scores[i][j] for j in range(holes))\n        ranks.append(total_score)\n\n    return str(min(ranks))"
    },
    {
        "number": 3684,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split())\n    users = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def find_min_buffer_size(user: list) -> int:\n        buffer_size = 0\n        for i in range(user[1]):\n            if i >= user[0]:\n                buffer_size += min(user[2], user[1] - i)\n        return buffer_size\n\n    min_buffer_sizes = [find_min_buffer_size(user) for user in users]\n    return str(max(min_buffer_sizes))"
    },
    {
        "number": 3685,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split())\n    start_row, start_col = map(int, stdin.split()[1].split()[1:-1])\n    fridge_row, fridge_col = map(int, stdin.split()[2].split()[1:-1])\n    masters = []\n    for _ in range(int(stdin.split()[3])):\n        row, col = map(int, stdin.split()[4].split()[1:-1])\n        masters.append((row, col))\n\n    def is_valid(row: int, col: int) -> bool:\n        return 0 <= row < r and 0 <= col < c\n\n    def is_blocked(row: int, col: int) -> bool:\n        return '#' in grid[row][col]\n\n    def is_special(row: int, col: int) -> bool:\n        return (row, col) == (start_row, start_col) or (row, col) == (fridge_row, fridge_col)\n\n    def is_blocked_or_special(row: int, col: int) -> bool:\n        return is_blocked(row, col) or is_special(row, col)\n\n    def is_blocked_or_special_or_master(row: int, col: int) -> bool:\n        return is_blocked_or_special(row, col) or (row, col) in masters\n\n    def is_blocked_or_special_or_master_or_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master(row, col) or (row, col) in visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited(row, col) or (row, col) in visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited(row, col) or (row, col) in visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited_visited(row, col) or (row, col) in visited_visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited_visited_visited(row, col) or (row, col) in visited_visited_visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited(row, col) or (row, col) in visited_visited_visited_visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited(row, col) or (row, col) in visited_visited_visited_visited_visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited_visited(row, col) or (row, col) in visited_visited_visited_visited_visited_visited_visited_visited\n\n    def is_blocked_or_special_or_master_or_visited_or_visited_visited_visited_visited_visited_visited_visited_visited(row: int, col: int) -> bool:\n        return is_blocked_or_special_"
    },
    {
        "number": 3686,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    targets = []\n    for i in range(N):\n        x, y = map(int, stdin.split()[i+1].split())\n        targets.append((x, y))\n    targets.sort(key=lambda x: (x[0], x[1]))\n    \n    def is_valid(x, y):\n        for target in targets:\n            if abs(x - target[0]) > 1 or abs(y - target[1]) > 1:\n                return False\n        return True\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            if is_valid(targets[i][0], targets[j][1]) and is_valid(targets[j][0], targets[i][1]):\n                return \"success\"\n    \n    return \"failure\""
    },
    {
        "number": 3687,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, s = map(int, stdin.split())\n    q_list = list(map(int, stdin.split()))\n    c_list = list(map(int, stdin.split()))\n    d = int(stdin.split()[0])\n    a_list = list(map(int, stdin.split()))\n\n    def is_possible(d: int, a_list: List[int]) -> bool:\n        total_size = sum(c_list)\n        if total_size < d:\n            return False\n\n        queue_sizes = [0] * q\n        for i in range(s):\n            queue_sizes[q_list[i] - 1] += a_list[i]\n\n        for i in range(q):\n            if queue_sizes[i] > 0:\n                return False\n\n        return True\n\n    if is_possible(d, a_list):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3688,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    malls = []\n    for _ in range(n):\n        x, y, t = map(int, stdin.split())\n        malls.append((x, y, t))\n\n    def is_vertical(a, b):\n        return abs(a[0] - b[0]) < abs(a[1] - b[1])\n\n    def min_moves(malls):\n        visited = set()\n        queue = [(0, 0, 0)]\n        while queue:\n            x, y, moves = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if x == 0 and y == 0:\n                return moves\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(malls) and 0 <= ny < len(malls[0]) and malls[nx][ny][2] == malls[x][y][2]:\n                    if is_vertical((x, y), (nx, ny)):\n                        queue.append((nx, ny, moves + 1))\n        return -1\n\n    return str(min_moves(malls))"
    },
    {
        "number": 3689,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = int(stdin.split()[1])\n\n    beautiful = []\n    for i in range(n):\n        if x % 10 == i + k:\n            beautiful.append(i + 1)\n            x //= 10\n\n    beautiful.sort()\n    y = int(''.join(map(str, beautiful)))\n\n    return str(len(str(y))) + ''.join(map(str, beautiful))"
    },
    {
        "number": 3690,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, m, s, t_1, t_2 = map(int, stdin.split())\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 > 12 or t_2 > 12:\n        return \"NO\"\n\n    if t_1 == 12 and t_2 == 12:\n        return \"YES\"\n\n    if t_1 == 12:\n        t_1 = 0\n\n    if t_2 == 12:\n        t_2 = 0\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:\n        t_2 = 12\n\n    if t_1 > 12:\n        t_1 -= 12\n\n    if t_2 > 12:\n        t_2 -= 12\n\n    if t_1 == t_2:\n        return \"NO\"\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 == 0:\n        t_1 = 12\n\n    if t_2 == 0:"
    },
    {
        "number": 3691,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, a_x, a_y, b_x, b_y, x_s, y_s, t = map(int, stdin.split())\n\n    def f(x, y):\n        return (x - x_s) * a_x + (y - y_s) * a_y\n\n    def g(x, y):\n        return (x - x_s) * b_x + (y - y_s) * b_y\n\n    def h(x, y):\n        return abs(x - x_s) + abs(y - y_s)\n\n    def is_valid(x, y):\n        return 0 <= x <= 10**16 and 0 <= y <= 10**16\n\n    def is_data_node(x, y):\n        return is_valid(x, y) and (x, y) in data_nodes\n\n    def collect_data(x, y):\n        nonlocal data_nodes\n        if is_data_node(x, y):\n            data_nodes.remove((x, y))\n            return True\n        return False\n\n    def collect_data_nodes(x, y):\n        nonlocal data_nodes\n        if is_data_node(x, y):\n            data_nodes.remove((x, y))\n            return True\n        return False\n\n    data_nodes = set()\n    data_nodes.add((x_s, y_s))\n\n    def collect_data_nodes_in_time(t):\n        nonlocal data_nodes\n        while t > 0:\n            x, y = data_nodes.pop()\n            if collect_data_nodes(x, y):\n                t -= 1\n            else:\n                data_nodes.add((x, y))\n\n    def collect_data_in_time(t):\n        nonlocal data_nodes\n        while t > 0:\n            x, y = data_nodes.pop()\n            if collect_data(x, y):\n                t -= 1\n            else:\n                data_nodes.add((x, y))\n\n    collect_data_nodes_in_time(t)\n    collect_data_in_time(t)\n\n    return str(len(data_nodes))"
    },
    {
        "number": 3692,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    circles = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.split()[1:])\n        circles.append((x, y, r))\n    regions = set()\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            if circles[i][0] == circles[j][0] and circles[i][1] == circles[j][1] and circles[i][2] == circles[j][2]:\n                continue\n            if circles[i][0] + circles[j][0] == 0 and circles[i][1] + circles[j][1] == 0 and circles[i][2] + circles[j][2] == 0:\n                regions.add(frozenset((circles[i], circles[j])))\n    return str(len(regions))"
    },
    {
        "number": 3693,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    square1 = [list(map(int, line.split())) for line in lines[:2]]\n    square2 = [list(map(int, line.split())) for line in lines[2:]]\n\n    def is_point_in_square(point: list, square: list) -> bool:\n        x, y = point\n        return all(x >= min(square[0][0], square[1][0]) and x <= max(square[0][0], square[1][0])\n                   and y >= min(square[0][1], square[1][1]) and y <= max(square[0][1], square[1][1]))\n\n    def is_square_intersecting(square1: list, square2: list) -> bool:\n        return any(is_point_in_square(point, square2) for point in square1)\n\n    return \"Yes\" if is_square_intersecting(square1, square2) else \"No\""
    },
    {
        "number": 3694,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_win(state: list) -> bool:\n        for i in range(n):\n            if state[i] == 0:\n                return False\n            if state[i]!= a[i]:\n                return True\n        return True\n\n    def is_winning_move(state: list, player: int) -> bool:\n        for i in range(n):\n            if state[i] == 0:\n                return False\n            if state[i]!= a[i]:\n                return True\n        return True\n\n    def is_losing_move(state: list, player: int) -> bool:\n        for i in range(n):\n            if state[i] == 0:\n                return False\n            if state[i]!= a[i]:\n                return True\n        return False\n\n    def is_tie(state: list) -> bool:\n        for i in range(n):\n            if state[i]!= a[i]:\n                return False\n        return True\n\n    def is_valid_move(state: list, player: int) -> bool:\n        if is_winning_move(state, player):\n            return True\n        if is_losing_move(state, player):\n            return False\n        return is_tie(state)\n\n    def best_move(state: list, player: int) -> int:\n        if is_winning_move(state, player):\n            return 0\n        if is_losing_move(state, player):\n            return 1\n        return 2\n\n    def next_state(state: list, player: int, move: int) -> list:\n        if move == 0:\n            return [state[i] - 1 if state[i] > 0 else 0 for i in range(n)]\n        if move == 1:\n            return [state[i] - 1 if state[i] > 0 else 0 for i in range(n)]\n        return state\n\n    def play_game(state: list, player: int) -> int:\n        if is_win(state):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_move(state: list, player: int, move: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_best_move(state: list, player: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_next_state(state: list, player: int, move: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game(state: list, player: int) -> int:\n        if is_win(state):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game_with_move(state: list, player: int, move: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game_with_best_move(state: list, player: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game_with_next_state(state: list, player: int, move: int) -> int:\n        if is_winning_move(state, player):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game_with_play_game(state: list, player: int) -> int:\n        if is_win(state):\n            return 1\n        if is_losing_move(state, player):\n            return 0\n        return 2\n\n    def play_game_with_play_game_with_play_game_with_"
    },
    {
        "number": 3695,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    def find_max_eatable_bowls(t: List[int]) -> int:\n        max_eatable_bowls = 0\n        current_eatable_bowls = 0\n        current_time = 0\n\n        for i in range(n):\n            if current_time < t[i]:\n                current_eatable_bowls += 1\n            else:\n                max_eatable_bowls = max(max_eatable_bowls, current_eatable_bowls)\n                current_eatable_bowls = 0\n                current_time = t[i] + 1\n\n        max_eatable_bowls = max(max_eatable_bowls, current_eatable_bowls)\n        return max_eatable_bowls\n\n    return str(find_max_eatable_bowls(t))\n"
    },
    {
        "number": 3696,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"1\\n0 1\\n0\"\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def extended_gcd(a, b):\n        if b == 0:\n            return a, 1, 0\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return g, y, x - (a // b) * y\n\n    def build_polynomial(degree, coefficients):\n        result = 0\n        for i in range(degree + 1):\n            result += coefficients[i] * (i + 1) ** i\n        return result\n\n    def long_division(a, b):\n        if b == 0:\n            return a, 0\n        else:\n            g, x, y = extended_gcd(a, b)\n            return g, x // g * b + y\n\n    def build_polynomial_from_remainder(degree, remainder):\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = remainder % 2\n            remainder //= 2\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_long_division(degree, a, b):\n        g, x, y = long_division(a, b)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd(degree, a, b):\n        g, x, y = extended_gcd(a, b)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd_and_remainder(degree, a, b, remainder):\n        g, x, y = extended_gcd(a, b)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd_and_long_division(degree, a, b, c):\n        g, x, y = long_division(a, b)\n        h, z, w = extended_gcd(c, g)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd_and_gcd_and_remainder(degree, a, b, c, d):\n        g, x, y = extended_gcd(a, b)\n        h, z, w = extended_gcd(c, g)\n        i, j, k = extended_gcd(d, h)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd_and_gcd_and_long_division(degree, a, b, c, d, e):\n        g, x, y = extended_gcd(a, b)\n        h, z, w = extended_gcd(c, g)\n        i, j, k = extended_gcd(d, h)\n        l, m, n = extended_gcd(e, i)\n        coefficients = [0] * (degree + 1)\n        for i in range(degree, -1, -1):\n            coefficients[i] = x % 2\n            x //= g\n        return build_polynomial(degree, coefficients)\n\n    def build_polynomial_from_gcd_and_gcd_and_gcd_and_remainder(degree, a, b, c, d, e, f):\n        g, x, y = extended_gcd(a, b)\n        h, z, w = extended_gcd(c, g)\n        i, j, k = extended_gcd(d, h)\n        l, m, n = extended_gcd(e, i)"
    },
    {
        "number": 3697,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, a = map(int, stdin.split())\n    citizens = list(map(int, stdin.split()))\n\n    votes = {}\n    for citizen in citizens:\n        votes[citizen] = votes.get(citizen, 0) + 1\n\n    candidates = sorted(votes.items(), key=lambda x: (-x[1], -x[0]))\n\n    result = []\n    for i, (candidate, votes) in enumerate(candidates, start=1):\n        if i <= k:\n            result.append(1)\n        elif i == k + 1:\n            result.append(2)\n        else:\n            result.append(3)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3698,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_special_numbers(x: int) -> int:\n        count = 0\n        while x > 1:\n            count += x & 1\n            x >>= 1\n        return count\n\n    def reduce_to_one(x: int) -> int:\n        count = 0\n        while x > 1:\n            count += x & 1\n            x >>= 1\n        return count\n\n    def is_special(x: int) -> bool:\n        return reduce_to_one(x) == 1\n\n    def special_numbers(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            if is_special(i):\n                count += 1\n        return count\n\n    def main() -> int:\n        return special_numbers(n) % MOD\n\n    return str(main())"
    },
    {
        "number": 3699,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return min(distance(x1, y1, x2, y2), distance(x2, y2, x1, y1))\n\n    def min_distance_to_recycling_bin(x1: int, y1: int, x2: int, y2: int, n: int, bottles: List[Tuple[int, int]]) -> float:\n        min_distance_to_bin = float('inf')\n        for i in range(n):\n            x, y = bottles[i]\n            min_distance_to_bin = min(min_distance_to_bin, distance(x, y, x1, y1) + distance(x, y, x2, y2))\n        return min_distance_to_bin\n\n    def min_distance_to_recycling_bin_helper(x1: int, y1: int, x2: int, y2: int, n: int, bottles: List[Tuple[int, int]], adil_path: List[Tuple[int, int]], bera_path: List[Tuple[int, int]]) -> float:\n        if not bottles:\n            return 0\n\n        x, y = bottles[0]\n        if x == x1 and y == y1:\n            return min_distance_to_recycling_bin_helper(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path)\n        elif x == x2 and y == y2:\n            return min_distance_to_recycling_bin_helper(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path)\n        else:\n            return min_distance_to_recycling_bin_helper(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path) + min_distance(x, y, x1, y1) + min_distance(x, y, x2, y2)\n\n    def min_distance_to_recycling_bin_helper_with_stop(x1: int, y1: int, x2: int, y2: int, n: int, bottles: List[Tuple[int, int]], adil_path: List[Tuple[int, int]], bera_path: List[Tuple[int, int]]) -> float:\n        if not bottles:\n            return 0\n\n        x, y = bottles[0]\n        if x == x1 and y == y1:\n            return min_distance_to_recycling_bin_helper_with_stop(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path)\n        elif x == x2 and y == y2:\n            return min_distance_to_recycling_bin_helper_with_stop(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path)\n        else:\n            return min_distance_to_recycling_bin_helper_with_stop(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_path) + min_distance(x, y, x1, y1) + min_distance(x, y, x2, y2)\n\n    def min_distance_to_recycling_bin_helper_with_stop_and_continue(x1: int, y1: int, x2: int, y2: int, n: int, bottles: List[Tuple[int, int]], adil_path: List[Tuple[int, int]], bera_path: List[Tuple[int, int]]) -> float:\n        if not bottles:\n            return 0\n\n        x, y = bottles[0]\n        if x == x1 and y == y1:\n            return min_distance_to_recycling_bin_helper_with_stop_and_continue(x1, y1, x2, y2, n, bottles[1:], adil_path, bera_"
    },
    {
        "number": 3700,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * (n - 1) // 2:\n        return \"0\"\n\n    def backtrack(i, j, total_cost):\n        if total_cost == k:\n            return 1\n        if total_cost > k:\n            return 0\n\n        count = 0\n        for l in range(i, n):\n            if l == i or l == j:\n                continue\n            count += backtrack(i, l, total_cost + l)\n        return count\n\n    return str(backtrack(0, 0, 0))"
    },
    {
        "number": 3701,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(stdin.strip())\n\n    def reverse_substring(start: int, end: int) -> int:\n        nonlocal a\n        a[start:end+1] = a[start:end+1][::-1]\n        return x * (end - start + 1)\n\n    def invert_substring(start: int, end: int) -> int:\n        nonlocal a\n        for i in range(start, end+1):\n            a[i] = 1 - a[i]\n        return y * (end - start + 1)\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if a[i] == a[j]:\n                continue\n            min_cost = min(min_cost, reverse_substring(i, j) + invert_substring(i, j))\n\n    return str(min_cost) if min_cost!= float('inf') else '0'"
    },
    {
        "number": 3702,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, d = map(int, stdin.split())\n    if n < 2 or a < 1 or d < 1 or a + (n - 1) * d >= 10**6:\n        return -1\n\n    fib = [0, 1]\n    for i in range(2, n):\n        fib.append(fib[i - 1] + fib[i - 2])\n\n    for b in range(1, 2**64):\n        if b + a * d >= 10**6:\n            break\n        for e in range(1, 2**64):\n            if e + b * d >= 10**6:\n                break\n            if str(a + (n - 1) * d) in str(fib[b + (n - 1) * e]):\n                return f\"{b} {e}\"\n\n    return -1"
    },
    {
        "number": 3703,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    def f(n):\n        if n == 1:\n            return 1\n        if n % 2 == 0:\n            return f(n // 2) + f(n // 2)\n        else:\n            return f(n // 2) + f(n // 2) + 1\n\n    def g(n):\n        return sum(f(d) for d in range(1, n + 1) if n % d == 0)\n\n    def F(k):\n        if k == 1:\n            return f(g(n))\n        else:\n            return F(k - 1) * (2 if k % 2 == 0 else 1)\n\n    return str(F(k) % 1000000007)"
    },
    {
        "number": 3704,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    subnets = []\n    for _ in range(n):\n        line = stdin.split()[1]\n        if line[0] == '-':\n            subnets.append(line[1:])\n        else:\n            subnets.append(line)\n    subnets = [subnet.split('/') for subnet in subnets]\n    subnets = [subnet for subnet in subnets if len(subnet) == 2]\n    subnets = [subnet for subnet in subnets if subnet[1] == '32']\n    subnets = [subnet for subnet in subnets if subnet[0] == '0.0.0.0']\n    subnets = [subnet for subnet in subnets if subnet[0] == '127.0.0.1']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.0.0']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.127.12']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.127.12']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets if subnet[0] == '192.168.3.11']\n    subnets = [subnet for subnet in subnets"
    },
    {
        "number": 3705,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = ''.join(sorted(s))\n    count = 0\n    for i in range(len(s) - 11):\n        if s[i:i+11] == '8' + s[i+11:i+11+10]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3706,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = []\n    for i in range(n):\n        row = list(map(int, stdin.split()[i+1].split()))\n        grid.append(row)\n\n    def is_valid(grid, row, col, target):\n        if row < 0 or row >= n or col < 0 or col >= m:\n            return False\n        if grid[row][col]!= target:\n            return False\n        return True\n\n    def dfs(grid, row, col, target, moves):\n        if is_valid(grid, row, col, target):\n            if grid[row][col] == target:\n                moves.append((row, col))\n            else:\n                moves.append((row, col))\n                dfs(grid, row, col+1, target, moves)\n                dfs(grid, row, col-1, target, moves)\n                dfs(grid, row+1, col, target, moves)\n                dfs(grid, row-1, col, target, moves)\n\n    def min_moves(grid, target):\n        moves = []\n        dfs(grid, 0, 0, target, moves)\n        return len(moves)\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                target = i\n                break\n\n    min_moves_count = min_moves(grid, target)\n    if min_moves_count == n * m:\n        return -1\n\n    moves = []\n    dfs(grid, 0, 0, target, moves)\n\n    result = []\n    for move in moves:\n        if move[0] == 0:\n            result.append(\"row \" + str(move[1]+1))\n        else:\n            result.append(\"col \" + str(move[1]+1))\n\n    return str(min_moves_count) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 3707,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, d = map(int, stdin.split())\n    \n    if n <= k:\n        return \"YES\"\n    \n    if n - k <= k:\n        return \"NO\"\n    \n    if t + d <= n:\n        return \"YES\"\n    \n    return \"NO\""
    },
    {
        "number": 3708,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    volcanoes = set()\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        volcanoes.add((x, y))\n\n    def bfs(start):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            cell, time = queue.pop(0)\n            if cell == (n, n):\n                return time\n            if cell in visited:\n                continue\n            visited.add(cell)\n            for neighbor in [(cell[0] + 1, cell[1]), (cell[0], cell[1] + 1)]:\n                if neighbor not in visited and neighbor not in volcanoes:\n                    queue.append((neighbor, time + 1))\n        return -1\n\n    return str(bfs((1, 1)))"
    },
    {
        "number": 3709,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    teams = [list(map(int, stdin.split())) for _ in range(k)]\n    selected_problems = set()\n\n    for team in teams:\n        for problem in team:\n            if problem == 1:\n                selected_problems.add(team.index(problem))\n\n    if len(selected_problems) == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3710,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def mod_k(x: int) -> int:\n        return x % k\n\n    def mod_c(x: int) -> int:\n        return x % c[i]\n\n    for i in range(n):\n        if mod_k(x) == mod_c(x):\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 3711,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n * m < k:\n        return -1\n\n    def is_valid(cut):\n        x1, y1, x2, y2 = cut\n        return 0 <= x1 < n and 0 <= y1 < m and 0 <= x2 < n and 0 <= y2 < m and x1!= x2 and y1!= y2\n\n    def area(cut):\n        x1, y1, x2, y2 = cut\n        return (x2 - x1 + 1) * (y2 - y1 + 1)\n\n    def min_area(cuts):\n        return min(area(cut) for cut in cuts)\n\n    cuts = []\n    for i in range(k):\n        x1, y1, x2, y2 = i * (n + 1), 0, (i + 1) * (n + 1) - 1, m - 1\n        cuts.append((x1, y1, x2, y2))\n\n    return str(min_area(cuts))"
    },
    {
        "number": 3712,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [list(map(int, a_str.split())) for a_str in stdin.split()]\n\n    def find_min_swaps(seats: list[list[int]]) -> int:\n        def is_valid(seats: list[list[int]]) -> bool:\n            for i in range(len(seats)):\n                if len(seats[i]) == 0:\n                    return False\n                if len(set(seats[i]))!= 4:\n                    return False\n            return True\n\n        def is_bored(seats: list[list[int]]) -> bool:\n            for i in range(len(seats)):\n                if len(seats[i]) == 1 or len(seats[i]) == 2:\n                    return True\n            return False\n\n        def is_fun(seats: list[list[int]]) -> bool:\n            for i in range(len(seats)):\n                if len(seats[i]) == 3 or len(seats[i]) == 4:\n                    return True\n            return False\n\n        def is_company(seats: list[list[int]]) -> bool:\n            for i in range(len(seats)):\n                if len(seats[i]) == 3 or len(seats[i]) == 4:\n                    return True\n            return False\n\n        def is_valid_swap(seats: list[list[int]]) -> bool:\n            if is_valid(seats):\n                if is_bored(seats):\n                    return True\n                if is_fun(seats):\n                    return True\n                if is_company(seats):\n                    return True\n            return False\n\n        def swap_seats(seats: list[list[int]]) -> list[list[int]]:\n            for i in range(len(seats)):\n                for j in range(len(seats[i])):\n                    if seats[i][j] == 0:\n                        for k in range(len(seats[i])):\n                            if k!= j:\n                                seats[i][k], seats[i][j] = seats[i][j], seats[i][k]\n            return seats\n\n        def find_min_swaps_helper(seats: list[list[int]]) -> int:\n            if is_valid_swap(seats):\n                return 0\n            if is_bored(seats):\n                return 1\n            if is_fun(seats):\n                return 2\n            if is_company(seats):\n                return 3\n            return 4\n\n        def find_min_swaps_recursive(seats: list[list[int]]) -> int:\n            if is_valid_swap(seats):\n                return 0\n            if is_bored(seats):\n                return 1\n            if is_fun(seats):\n                return 2\n            if is_company(seats):\n                return 3\n            return 4\n\n        def find_min_swaps_iterative(seats: list[list[int]]) -> int:\n            min_swaps = 4\n            for i in range(len(seats)):\n                for j in range(len(seats[i])):\n                    if seats[i][j] == 0:\n                        for k in range(len(seats[i])):\n                            if k!= j:\n                                seats[i][k], seats[i][j] = seats[i][j], seats[i][k]\n                                min_swaps = min(min_swaps, find_min_swaps_helper(seats))\n                                seats[i][k], seats[i][j] = seats[i][j], seats[i][k]\n            return min_swaps\n\n        if is_valid(seats):\n            return 0\n        if is_bored(seats):\n            return 1\n        if is_fun(seats):\n            return 2\n        if is_company(seats):\n            return 3\n        return 4\n\n    min_swaps = find_min_swaps(a)\n    if min_swaps == 4:\n        return \"-1\"\n    return str(min_swaps)"
    },
    {
        "number": 3713,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = ''.join(map(str, list(map(int, s))))\n    max_length = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                continue\n            s[i], s[j] = s[j], s[i]\n            length = 0\n            for k in range(n):\n                if s[k] == '0':\n                    length += 1\n                else:\n                    break\n            if length > max_length:\n                max_length = length\n            s[i], s[j] = s[j], s[i]\n    return str(max_length)"
    },
    {
        "number": 3714,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *crushes = map(int, stdin.split())\n    crushes = {i: crush for i, crush in enumerate(crushes)}\n\n    def dfs(x: int, t: int) -> int:\n        if t == 1:\n            return x\n        return dfs(crushes[x], t - 1)\n\n    for i in range(1, n + 1):\n        if i in crushes:\n            continue\n        x = dfs(i, 1)\n        if x == i:\n            return 1\n\n    return -1"
    },
    {
        "number": 3715,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    days = list(map(int, stdin.split()[1:]))\n\n    rest_days = 0\n    for i in range(n):\n        if days[i] == 0 and days[i+1] == 0:\n            rest_days += 1\n\n    return str(rest_days)"
    },
    {
        "number": 3716,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a, b, c = 1, 2, 3\n    while a <= n and b <= n and c <= n:\n        lcm = a * b * c\n        if lcm > n:\n            break\n        a += 1\n        b += 1\n        c += 1\n    return str(lcm)"
    },
    {
        "number": 3717,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:5])\n        rectangles.append((x1, y1, x2, y2))\n    x, y = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if rectangles[i][0] <= x <= rectangles[i][2] and rectangles[j][1] <= y <= rectangles[j][3]:\n                x = (rectangles[i][0] + rectangles[i][2]) // 2\n                y = (rectangles[j][1] + rectangles[j][3]) // 2\n                break\n    return f\"{x} {y}\""
    },
    {
        "number": 3718,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n\n    def is_valid(t1, t2, t3):\n        return t1!= t2 and t2!= t3 and abs(t1 - t2) <= 2 and abs(t2 - t3) <= 2 and abs(t1 - t3) <= 2\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if is_valid(t[i], t[j], t[k]):\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3719,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    y1, y2 = map(list, zip(*[map(int, line.split()) for line in stdin.split('\\n')[1:]]))\n\n    def is_valid(y, x):\n        return -100 <= x <= 100 and all(0 <= y <= 10000 for y in y)\n\n    def count_destroyed(y, x):\n        destroyed = 0\n        for i in range(n):\n            if y1[i] == y and x == -100:\n                destroyed += 1\n            if y2[i] == y and x == 100:\n                destroyed += 1\n        return destroyed\n\n    def max_destroyed():\n        max_destroyed = 0\n        for y in range(-100, 101):\n            for x in range(-101, 101):\n                destroyed = count_destroyed(y, x)\n                if destroyed > max_destroyed:\n                    max_destroyed = destroyed\n        return max_destroyed\n\n    return str(max_destroyed())"
    },
    {
        "number": 3720,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"Vasya\"\n    elif n == 2:\n        return \"Petya\"\n    else:\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                continue\n            for j in range(2, int(i ** 0.5) + 1):\n                if i % j == 0:\n                    break\n            else:\n                return \"Vasya\"\n        return \"Petya\""
    },
    {
        "number": 3721,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    elements = set()\n    for _ in range(q):\n        r, c = map(int, stdin.split())\n        elements.add((r, c))\n\n    # Initialize the table with the elements\n    table = [[0] * m for _ in range(n)]\n    for r, c in elements:\n        table[r - 1][c - 1] = 1\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n        return count\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n                    if count == 4:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples_and_remaining(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n                    if count == 4:\n                        return True\n                    if count == 5:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples_and_remaining_and_remaining(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n                    if count == 4:\n                        return True\n                    if count == 5:\n                        return True\n                    if count == 6:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples_and_remaining_and_remaining_and_remaining(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n                    if count == 4:\n                        return True\n                    if count == 5:\n                        return True\n                    if count == 6:\n                        return True\n                    if count == 7:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples_and_remaining_and_remaining_and_remaining_and_remaining(row, col):\n        count = 0\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if table[i][j] == 1:\n                    count += 1\n                    if count == 3:\n                        return True\n                    if count == 4:\n                        return True\n                    if count == 5:\n                        return True\n                    if count == 6:\n                        return True\n                    if count == 7:\n                        return True\n                    if count == 8:\n                        return True\n        return False\n\n    # Find the number of elements that can be produced with nuclear fusion\n    def count_elements_with_fusion_and_samples_and_remaining_and_remaining_and_remaining_and_remaining_"
    },
    {
        "number": 3722,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, c_AA, c_AB, c_BA, c_BB = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (N + 1) for _ in range(4)]\n    dp[0][0] = 1\n\n    for i in range(1, 4):\n        for j in range(N + 1):\n            if j >= i:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % MOD\n\n    return str(dp[N][N])"
    },
    {
        "number": 3723,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *strengths = map(int, stdin.split())\n    strengths.sort()\n    max_strength = strengths[-1]\n    count = 0\n    for i in range(n):\n        if strengths[i] == max_strength:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 3724,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = list(S)\n    MOD = 10**9 + 7\n\n    def count_strings(i: int) -> int:\n        if i == 0:\n            return 1\n        count = 0\n        for j in range(i):\n            if S[j]!= S[i]:\n                count += count_strings(j)\n        return count\n\n    count = 0\n    for i in range(1, N):\n        if S[i]!= S[i - 1]:\n            count += count_strings(i)\n            S[i] = (S[i] + 1) % 3\n            count %= MOD\n    count += count_strings(N - 1)\n\n    return str(count)"
    },
    {
        "number": 3725,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, h_1, x_1, h_2, x_2 = map(int, stdin.split())\n    a_1, a_2 = h_1, h_2\n\n    if a_1 == a_2:\n        return -1\n\n    while a_1!= a_2:\n        a_1 = (a_1 * x_1 + y_1) % m\n        a_2 = (a_2 * x_2 + y_2) % m\n\n    return a_1"
    },
    {
        "number": 3726,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = map(int, stdin.split())\n    cards.sort()\n    prime_p = 3\n    count = 0\n\n    while prime_p <= n:\n        if all(cards[i] % prime_p == 0 for i in range(prime_p - 1, n - prime_p + 1, prime_p)):\n            count += prime_p\n            for i in range(prime_p - 1, n - prime_p + 1, prime_p):\n                cards[i] = 0\n        prime_p += 2\n\n    return str(count)"
    },
    {
        "number": 3727,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d > 10**5:\n        return \"NO\"\n\n    beautiful_sequence = [0] * a + [1] * b + [2] * c + [3] * d\n    for i in range(a, len(beautiful_sequence) - 1):\n        if abs(beautiful_sequence[i] - beautiful_sequence[i + 1])!= 1:\n            return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, beautiful_sequence)) + \"\\n\"\n"
    },
    {
        "number": 3728,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_identity(row):\n        return row == list(range(1, m + 1))\n\n    for i in range(n):\n        if not is_identity(table[i]):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3729,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, w, h = map(int, stdin.split())\n    if f > w:\n        f, w = w, f\n\n    def count_stacks(height: int) -> int:\n        return sum(1 for _ in range(height + 1))\n\n    def count_stacks_with_food(height: int) -> int:\n        return sum(1 for _ in range(height + 1) if count_stacks(height) % 2 == 0)\n\n    def count_stacks_with_wine(height: int) -> int:\n        return sum(1 for _ in range(height + 1) if count_stacks(height) % 2 == 1)\n\n    def count_different_stacks(height: int) -> int:\n        return count_stacks(height) - count_stacks_with_food(height) - count_stacks_with_wine(height)\n\n    def count_different_arrangements(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2\n\n    def count_different_arrangements_with_food(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height)\n\n    def count_different_arrangements_with_wine(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_wine(height)\n\n    def count_different_arrangements_with_food_and_wine(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height)\n\n    def count_different_arrangements_with_food_and_wine_and_height(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height) + count_different_stacks(height - 1)\n\n    def count_different_arrangements_with_food_and_wine_and_height_less_than_h(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height) + count_different_stacks(height - 1)\n\n    def count_different_arrangements_with_food_and_wine_and_height_less_than_h_and_height_greater_than_h(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height) + count_different_stacks(height - 1)\n\n    def count_different_arrangements_with_food_and_wine_and_height_less_than_h_and_height_greater_than_h_and_height_less_than_h(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height) + count_different_stacks(height - 1)\n\n    def count_different_arrangements_with_food_and_wine_and_height_less_than_h_and_height_greater_than_h_and_height_less_than_h_and_height_greater_than_h(height: int) -> int:\n        return count_different_stacks(height) * (count_different_stacks(height) - 1) // 2 + count_stacks_with_food(height) + count_stacks_with_wine(height) + count_different_stacks(height - 1)\n\n    def count_different_arrangements_with_food_and_wine_and_height_less_than_h_and_height_greater_than_h_and_height_less_than_h_and_height_greater_than_h_and_height_less_than_h(height:"
    },
    {
        "number": 3730,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_length = 0\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 3731,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l, r = map(int, stdin.split())\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    s = s[:l-1] + s[l-1:r] + s[r:]\n    s = s[:a-1] + s[a-1:a] + s[a:]\n    s = s[:b-1] + s[b-1:b] + s[b:]\n    return len(set(s))"
    },
    {
        "number": 3732,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, m = map(int, stdin.split())\n    \n    if x >= m or y >= m:\n        return \"-1\"\n    \n    if x + y >= m:\n        return 1\n    \n    if x + y + m >= m:\n        return 2\n    \n    return \"-1\""
    },
    {
        "number": 3733,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, I = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    k = 0\n    while k < 31 and len(set(a)) < 2 ** k:\n        k += 1\n\n    if k == 31:\n        return \"0\"\n\n    l, r = 0, 1\n    while r <= 10 ** 9:\n        if all(l <= ai <= r for ai in a):\n            break\n        elif ai < l:\n            l = ai\n        elif ai > r:\n            r = ai\n\n    changed = 0\n    for i in range(n):\n        if l <= a[i] <= r:\n            changed += 1\n            a[i] = l\n        elif a[i] < l:\n            a[i] = l\n            changed += 1\n        elif a[i] > r:\n            a[i] = r\n            changed += 1\n\n    return str(changed)\n"
    },
    {
        "number": 3734,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]\n    first_day = days.index(stdin[0].lower())\n    second_day = days.index(stdin[1].lower())\n\n    if first_day == second_day:\n        return \"NO\"\n\n    if first_day < second_day:\n        for i in range(first_day + 1, second_day):\n            if days[i] == stdin[1].lower():\n                return \"YES\"\n    else:\n        for i in range(first_day - 1, second_day, -1):\n            if days[i] == stdin[1].lower():\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3735,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_sum = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            if a + b == n:\n                sum_a = sum(int(digit) for digit in str(a))\n                sum_b = sum(int(digit) for digit in str(b))\n                if sum_a + sum_b > max_sum:\n                    max_sum = sum_a + sum_b\n    return str(max_sum)"
    },
    {
        "number": 3736,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mirror_words = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n    name = stdin.upper()\n    mirror_name = ''.join(mirror_words)\n    if name == mirror_name:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 3737,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    stewards = sorted(set(a))\n    count = 0\n    for i in range(len(stewards) - 1):\n        if stewards[i] < stewards[i + 1]:\n            count += 1\n            break\n    return str(count)"
    },
    {
        "number": 3738,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    s = stdin.split()[1]\n    x, y = 0, 0\n    for c in s:\n        if c == 'U':\n            y += 1\n        elif c == 'D':\n            y -= 1\n        elif c == 'L':\n            x -= 1\n        elif c == 'R':\n            x += 1\n    if x == a and y == b:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3739,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_goldbach(n: int) -> bool:\n        if n <= 3:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_valid_goldbach(n: int) -> bool:\n        return is_goldbach(n) and is_prime(n)\n\n    def parse_input(input_str: str) -> tuple[int, int, int]:\n        numbers = input_str.split()\n        if len(numbers)!= 3:\n            return None, None, None\n        num1, num2, num3 = map(int, numbers)\n        if num1 <= 3 or num1 > 10**9 or num2 <= 3 or num2 > 10**9 or num3 <= 3 or num3 > 10**9:\n            return None, None, None\n        return num1, num2, num3\n\n    def check_goldbach(num1: int, num2: int) -> bool:\n        return is_valid_goldbach(num1 + num2)\n\n    input_str = stdin.strip()\n    num1, num2, num3 = parse_input(input_str)\n    if num1 is None or num2 is None or num3 is None:\n        return \"0\"\n\n    if check_goldbach(num1, num2):\n        return \"1\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 3740,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, 10):\n        for j in range(i, 10):\n            if i + j == S:\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 3741,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in range(n):\n            if not visited[neighbor] and (a[node] & a[neighbor])!= 0:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i] and dfs(i, visited):\n            return -1\n\n    shortest_cycle = []\n    for i in range(n):\n        if not visited[i] and (a[i] & a[i+1])!= 0:\n            shortest_cycle.append(i)\n            shortest_cycle.append(i+1)\n            break\n\n    return str(len(shortest_cycle))"
    },
    {
        "number": 3742,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = [0] + p + [0]\n    p.sort()\n    complexity = 0\n    for i in range(1, n):\n        if p[i] % 2!= p[i - 1] % 2:\n            complexity += 1\n    return str(complexity)"
    },
    {
        "number": 3743,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = set()\n    for i in range(1, n+1):\n        colors.add(i)\n    return str(len(colors))"
    },
    {
        "number": 3744,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    programming_team = []\n    sports_team = []\n\n    for i in range(n):\n        if a[i] > b[i]:\n            programming_team.append(i + 1)\n        elif a[i] < b[i]:\n            sports_team.append(i + 1)\n        else:\n            continue\n\n    programming_team.sort()\n    sports_team.sort()\n\n    programming_team = programming_team[:p]\n    sports_team = sports_team[:s]\n\n    strength_programming = sum(a)\n    strength_sports = sum(b)\n\n    strength_university = strength_programming + strength_sports\n\n    return str(strength_university) + '\\n' +''.join(map(str, programming_team)) + '\\n' +''.join(map(str, sports_team))"
    },
    {
        "number": 3745,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[1:]):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def is_neighbouring(s1: str, s2: str) -> bool:\n        for i in range(len(s1)):\n            if s1[i] == s2[i]:\n                continue\n            if s1[i] == 'a' and s2[i] == 'b':\n                return True\n            if s1[i] == 'b' and s2[i] == 'c':\n                return True\n            if s1[i] == 'c' and s2[i] == 'a':\n                return True\n            return False\n\n    def is_connected(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if not is_neighbouring(s[i], s[i + 1]):\n                return False\n        return True\n\n    def is_valid_string(s: str) -> bool:\n        return all(c in 'abc' for c in s) and is_connected(s)\n\n    def find_string(graph: List[List[int]], visited: Set[int], s: str) -> str:\n        if s in visited:\n            return s\n        visited.add(s)\n        for u in graph[s[0]]:\n            if u not in visited:\n                new_s = s + chr(ord(s[0]) + 1)\n                if is_valid_string(new_s):\n                    return find_string(graph, visited, new_s)\n        return ''\n\n    result = 'Yes'\n    for s in 'abc':\n        if is_valid_string(s):\n            result = 'No'\n            break\n\n    if result == 'Yes':\n        result = find_string(graph, set(), 'a')\n\n    return result\n\n\ndef"
    },
    {
        "number": 3746,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    n = int(stdin.split('\\n')[3])\n\n    def hanoi(n, source, target, auxiliary):\n        if n == 1:\n            print(f\"Move disk 1 from rod {source} to rod {target}\")\n            return\n        hanoi(n - 1, source, auxiliary, target)\n        print(f\"Move disk {n} from rod {source} to rod {target}\")\n        hanoi(n - 1, auxiliary, target, source)\n\n    hanoi(n, 1, 3, 2)\n    return \" \".join(map(str, hanoi_cost(n, 1, 3, 2)))\n\n\ndef"
    },
    {
        "number": 3747,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            word = s[i:j]\n            if word == \"bulbasaur\":\n                count += 1\n                break\n    return str(count)"
    },
    {
        "number": 3748,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    S = [list(stdin.split()[i]) for i in range(1, H + 1)]\n\n    for i in range(H):\n        for j in range(W):\n            if S[i][j]!= S[H - i][W - j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 3749,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    A = list(map(int, stdin.split()[1:]))\n\n    def count_different_integers(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n        return count\n\n    def count_different_integers_with_xor(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor_and_double(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor_and_double(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n                count += 1\n        return count\n\n    def count_different_integers_with_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor_and_double_and_take_xor_and_double(x: int) -> int:\n        count = 0\n        for a in A:\n            if a <= x:\n                count += 1\n            elif a > x:\n                count"
    },
    {
        "number": 3750,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    if a + b <= k:\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 3751,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    identifiers = stdin.split()\n    obfuscated_identifiers = []\n\n    for identifier in identifiers:\n        if identifier.isalpha():\n            obfuscated_identifiers.append(identifier)\n        else:\n            obfuscated_identifiers.append(\"a\")\n\n    obfuscated_program = \"\".join(obfuscated_identifiers)\n    obfuscated_program = obfuscated_program.replace(\"a\", \"b\")\n    obfuscated_program = obfuscated_program.replace(\"b\", \"c\")\n    obfuscated_program = obfuscated_program.replace(\"c\", \"d\")\n\n    if \"a\" in obfuscated_program and \"b\" in obfuscated_program and \"c\" in obfuscated_program and \"d\" in obfuscated_program:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3752,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, d, t = map(int, stdin.split())\n    total_time = 0\n    stove_on = False\n    for i in range(k * d, k * (d + t) + 1, k * d):\n        if i % (k * d) == 0:\n            total_time += t\n            stove_on = not stove_on\n        total_time += 2 * t if stove_on else 0\n    return str(total_time)"
    },
    {
        "number": 3753,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    island = [list(row) for row in stdin.split()[1:]]\n\n    def is_impassable(r: int, c: int) -> bool:\n        return island[r - 1][c - 1] == \"#\"\n\n    def is_free(r: int, c: int) -> bool:\n        return island[r - 1][c - 1] == \".\"\n\n    def is_treasure(r: int, c: int) -> bool:\n        return r == n and c == m\n\n    def is_valid_move(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= m and is_free(r, c)\n\n    def is_valid_move_to_forest(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= m and is_free(r, c) and not is_impassable(r, c)\n\n    def is_valid_move_to_treasure(r: int, c: int) -> bool:\n        return r == n and c == m\n\n    def is_valid_move_to_forest_or_treasure(r: int, c: int) -> bool:\n        return is_valid_move_to_forest(r, c) or is_valid_move_to_treasure(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure(r, c) or is_impassable(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable(r, c) or is_free(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable_or_free(r, c) or is_treasure(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure(r, c) or is_impassable(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable_or_free(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable(r, c) or is_free(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable_or_free_or_treasure(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable_or_free(r, c) or is_treasure(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable_or_free_or_treasure_or_impassable(r: int, c: int) -> bool:\n        return is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or_impassable_or_free_or_treasure(r, c) or is_impassable(r, c)\n\n    def is_valid_move_to_forest_or_treasure_or_impassable_or_free_or_treasure_or"
    },
    {
        "number": 3754,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    d = list(map(int, stdin.split()[1:]))\n\n    def dfs(part: int, used: set, count: int) -> int:\n        if part == N:\n            return 1\n\n        count += dfs(part + 1, used, count)\n\n        for i in range(d[part]):\n            if i not in used:\n                used.add(i)\n                count += dfs(part + 1, used, count)\n                used.remove(i)\n\n        return count\n\n    return str(dfs(0, set(), 0) % 998244353)\n"
    },
    {
        "number": 3755,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    operations = 0\n    max_value = float('-inf')\n    max_index = -1\n\n    for i in range(N):\n        if i == 0 or i == N - 1:\n            continue\n\n        if sequence[i] == sequence[i - 1] or sequence[i] == sequence[i + 1]:\n            sequence.pop(i)\n            operations += 1\n            continue\n\n        if sequence[i] > sequence[i - 1] and sequence[i] > sequence[i + 1]:\n            sequence[i] = sequence[i - 1] + sequence[i + 1]\n            sequence.pop(i - 1)\n            sequence.pop(i)\n            operations += 2\n        elif sequence[i] < sequence[i - 1] and sequence[i] < sequence[i + 1]:\n            sequence[i] = sequence[i - 1] + sequence[i + 1]\n            sequence.pop(i - 1)\n            sequence.pop(i)\n            operations += 2\n        else:\n            sequence[i] = sequence[i - 1] + sequence[i + 1]\n            sequence.pop(i - 1)\n            sequence.pop(i)\n            operations += 1\n\n        if sequence[i] > max_value:\n            max_value = sequence[i]\n            max_index = i\n\n    return f\"{max_value}\\n{operations}\\n\" + \"\\n\".join(map(str, max_index))\n"
    },
    {
        "number": 3756,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    grade = float(stdin.split()[1])\n\n    def round_to_n_digits(grade: float, n: int) -> float:\n        if grade == 0:\n            return 0\n\n        if grade < 0:\n            grade = -grade\n\n        if grade >= 1:\n            grade = round(grade, n)\n            return grade\n\n        if grade < 0.5:\n            return round_to_n_digits(grade * 10, n)\n\n        if grade >= 0.5:\n            return round_to_n_digits((grade - 0.5) * 10 + 1, n)\n\n    def round_to_nearest_integer(grade: float) -> int:\n        if grade == 0:\n            return 0\n\n        if grade < 0:\n            grade = -grade\n\n        if grade >= 1:\n            return int(grade)\n\n        if grade < 0.5:\n            return round_to_nearest_integer(grade * 10)\n\n        if grade >= 0.5:\n            return round_to_nearest_integer((grade - 0.5) * 10 + 1)\n\n    def round_to_n_digits_and_nearest_integer(grade: float, n: int) -> int:\n        rounded_grade = round_to_n_digits(grade, n)\n        rounded_integer = round_to_nearest_integer(rounded_grade)\n\n        return rounded_integer\n\n    max_grade = 0\n    for i in range(t):\n        max_grade = max(max_grade, round_to_n_digits_and_nearest_integer(grade, n))\n\n    return str(max_grade)"
    },
    {
        "number": 3757,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_00, a_01, a_10, a_11 = map(int, stdin.split())\n\n    if a_00 + a_01 + a_10 + a_11!= 4:\n        return \"Impossible\"\n\n    def count_subsequences(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_2(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_3(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_4(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 3):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_5(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 4):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3] and s[i + 3] == s[i + 4]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_6(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 5):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3] and s[i + 3] == s[i + 4] and s[i + 4] == s[i + 5]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_7(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 6):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3] and s[i + 3] == s[i + 4] and s[i + 4] == s[i + 5] and s[i + 5] == s[i + 6]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_8(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 7):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3] and s[i + 3] == s[i + 4] and s[i + 4] == s[i + 5] and s[i + 5] == s[i + 6] and s[i + 6] == s[i + 7]:\n                count += 1\n        return count\n\n    def count_subsequences_of_length_9(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 8):\n            if s[i] == s[i + 1] and s[i + 1] == s[i + 2] and s[i + 2] == s[i + 3] and s[i + 3] == s[i + 4] and s[i + 4] == s[i + 5] and s[i + 5] == s[i + 6] and s[i + 6] == s[i +"
    },
    {
        "number": 3758,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    game_field = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_empty(cell: str) -> bool:\n        return cell == '.'\n\n    def is_packman(cell: str) -> bool:\n        return cell == 'P'\n\n    def is_asterisk(cell: str) -> bool:\n        return cell == '*'\n\n    def get_neighbors(cell: str) -> list[str]:\n        row, col = cell\n        return [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n\n    def move_packman(packman: str, time: int) -> str:\n        row, col = packman\n        neighbors = get_neighbors(packman)\n        for neighbor in neighbors:\n            if is_empty(game_field[neighbor[0]][neighbor[1]]):\n                return neighbor\n        return packman\n\n    def eat_asterisk(packman: str, time: int) -> str:\n        row, col = packman\n        if is_asterisk(game_field[row][col]):\n            game_field[row][col] = '.'\n            return packman\n        return packman\n\n    def is_all_eaten(game_field: list[list[str]]) -> bool:\n        for row in game_field:\n            for cell in row:\n                if is_asterisk(cell):\n                    return False\n        return True\n\n    def get_min_time(game_field: list[list[str]]) -> int:\n        packman = (0, 0)\n        time = 0\n        while not is_all_eaten(game_field):\n            packman = move_packman(packman, time)\n            packman = eat_asterisk(packman, time)\n            time += 1\n        return time\n\n    return str(get_min_time(game_field))\n"
    },
    {
        "number": 3759,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    blocked_points = set()\n    special_points = set()\n\n    for i in range(n):\n        x, y = map(int, input().split())\n        if x == 0 and y == 0:\n            blocked_points.add((x, y))\n        else:\n            special_points.add((x, y))\n\n    def is_4_connected(point: tuple) -> bool:\n        x, y = point\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) in blocked_points or (nx, ny) in special_points:\n                continue\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n                return True\n            if (nx, ny) in blocked_points:\n                return False\n            if (nx, ny) in special_points:\n               "
    },
    {
        "number": 3760,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, a, b = map(int, stdin.split())\n    x_1, y_1, x_2, y_2 = 0, 0, 0, 0\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) == (x, y):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) < (x, y):\n                continue\n            if (i, j) > (x, y):\n                break\n            if (i, j) == (x, y - 1):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x - 1, y):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x - 1, y - 1):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x - 1, y + 1):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x + 1, y - 1):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x + 1, y + 1):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n            if (i, j) == (x + 1, y):\n                x_1, y_1, x_2, y_2 = i, j, i, j\n                break\n\n    if (x_2 - x_1) * (y_2 - y_1)!= a * b:\n        return \"No solution\"\n\n    return f\"{x_1} {y_1} {x_2} {y_2}\"\n"
    },
    {
        "number": 3761,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    x, y = map(int, stdin.strip().split())\n\n    def move(dx, dy):\n        nonlocal x, y\n        x += dx\n        y += dy\n\n    def turn(direction):\n        nonlocal x, y\n        if direction == \"L\":\n            x, y = y, -x\n        elif direction == \"R\":\n            x, y = -y, x\n\n    for instruction in s:\n        if instruction == \"F\":\n            move(1, 0)\n        elif instruction == \"T\":\n            turn(\"L\")\n\n    return \"Yes\" if abs(x) <= abs(y) else \"No\""
    },
    {
        "number": 3762,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    mod = 10**9 + 7\n\n    def is_perfect(S: set) -> int:\n        for a in S:\n            for b in S:\n                if a!= b and (a ^ b) in S:\n                    return 0\n        return 1\n\n    def count_perfect_sets(k: int) -> int:\n        perfect_sets = set()\n        for i in range(1, k + 1):\n            perfect_sets.add(frozenset(i))\n        return sum(is_perfect(S) for S in perfect_sets)\n\n    return str(count_perfect_sets(k) % mod)"
    },
    {
        "number": 3763,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    p = int(stdin.split()[2])\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def calculate_average(n: int) -> float:\n        return 1.0 / factorial(n)\n\n    def calculate_guest_sizes(a: list) -> list:\n        return [a[i] for i in range(n)]\n\n    def calculate_guest_sizes_sum(a: list) -> int:\n        return sum(a)\n\n    def calculate_guest_sizes_sum_plus_guest_size(a: list, i: int) -> int:\n        return calculate_guest_sizes_sum(a) + a[i]\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size(a, i) <= p\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p(a, i) and i!= 0\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_and_not_in_queue_plus_1(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue(a, i) and i!= n - 1\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1(a, i) or i!= n - 2\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2(a, i) or i!= n - 3\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3_or_not_in_queue_plus_4(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3(a, i) or i!= n - 4\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3_or_not_in_queue_plus_4_or_not_in_queue_plus_5(a: list, i: int) -> bool:\n        return calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3_or_not_in_queue_plus_4(a, i) or i!= n - 5\n\n    def calculate_guest_sizes_sum_plus_guest_size_less_than_p_and_not_in_queue_plus_1_or_not_in_queue_plus_2_or_not_in_queue_plus_3_or_not_in_queue_plus_4_"
    },
    {
        "number": 3764,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    strengths = list(map(int, stdin.split()[1:]))\n\n    for _ in range(k):\n        strengths = [strengths[i] ^ x for i in range(1, len(strengths), 2)]\n\n    max_strength = max(strengths)\n    min_strength = min(strengths)\n\n    return f\"{max_strength} {min_strength}\""
    },
    {
        "number": 3765,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, h, w, n = map(int, stdin.split())\n    a_list = list(map(int, stdin.split()[2:]))\n\n    def is_valid(h, w, a_list):\n        for a in a_list:\n            if h % a!= 0 or w % a!= 0:\n                return False\n        return True\n\n    def min_extensions(h, w, a_list):\n        min_ext = 0\n        for a in a_list:\n            min_ext += h // a + w // a\n        return min_ext\n\n    if is_valid(h, w, a_list):\n        return str(min_extensions(h, w, a_list))\n    else:\n        return \"-1\""
    },
    {
        "number": 3766,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = stdin.split()[1:]\n    colors = set()\n    values = set()\n    for card in cards:\n        color, value = card\n        colors.add(color)\n        values.add(value)\n\n    min_hints = 0\n    for color in colors:\n        min_hints += len(cards)\n    for value in values:\n        min_hints += len(cards)\n\n    return str(min_hints)"
    },
    {
        "number": 3767,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a = list(zip(a, b))\n    a.sort(key=lambda x: x[0])\n    a = [x[0] for x in a]\n    b = [x[1] for x in a]\n    k = 1\n    t = 0\n    for i in range(1, n):\n        if a[i] <= b[i]:\n            k += 1\n            t += b[i] - a[i]\n            a[i] = 0\n        else:\n            a[i] -= b[i]\n            t += b[i]\n            k += 1\n    return f\"{k} {t}\""
    },
    {
        "number": 3768,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == y:\n        return \"Impossible\"\n\n    def compress(s: str) -> str:\n        result = \"\"\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                result += str(count) + s[i - 1]\n                count = 1\n        result += str(count) + s[-1]\n        return result\n\n    def play_game(x: int, y: int) -> str:\n        cards = [f\"A{i}\" for i in range(x + 1)] + [f\"B{i}\" for i in range(y + 1)]\n        cards.sort()\n        result = \"\"\n        for card in cards:\n            if card[1] == \"A\":\n                result += compress(f\"{x}A{x - 1}B{x - 2}\")\n                x -= 1\n            else:\n                result += compress(f\"{y}A{y - 1}B{y - 2}\")\n                y -= 1\n        return result\n\n    result = play_game(x, y)\n    return result\n"
    },
    {
        "number": 3769,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    if p < 3 or p % 2 == 0 or p > 10**6:\n        return \"Invalid input\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_functions(f: int) -> int:\n        count = 0\n        for x in range(p):\n            if f(x) == x:\n                count += 1\n        return count\n\n    def f(x: int) -> int:\n        return (x * f(x) % p) % p\n\n    count = 0\n    for i in range(p):\n        if is_prime(i) and is_prime(p - i):\n            count += count_functions(f)\n\n    return str((count % (10**9 + 7)))\n"
    },
    {
        "number": 3770,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    edges = []\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in edges[u - 1]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def connected_components(edges):\n        visited = [False] * (len(edges) + 1)\n        components = []\n        for u in range(1, len(edges) + 1):\n            if not visited[u]:\n                dfs(u, visited)\n                components.append(u)\n        return components\n\n    components = connected_components(edges)\n    score = 0\n    for component in components:\n        score += abs(sum(b[component - 1]))\n\n    profit = score - sum(a)\n    return str(profit)"
    },
    {
        "number": 3771,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    a = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W and a[i][j]!= '.'\n\n    def is_leaf(i, j):\n        return a[i][j] in ['S', 'T']\n\n    def get_neighbors(i, j):\n        return [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n\n    def jump_to_leaf(i, j):\n        for neighbor in get_neighbors(i, j):\n            if is_valid(neighbor[0], neighbor[1]) and is_leaf(neighbor[0], neighbor[1]):\n                return neighbor\n        return None\n\n    def remove_leaves(i, j):\n        if is_leaf(i, j):\n            a[i][j] = '.'\n            return True\n        return False\n\n    def count_leaves():\n        return sum(1 for row in a for leaf in row if leaf in ['S', 'T'])\n\n    def min_leaves_to_remove():\n        leaves = count_leaves()\n        if leaves == 0:\n            return 0\n        if leaves == 1:\n            return 1\n\n        i, j = 0, 0\n        while True:\n            next_i, next_j = jump_to_leaf(i, j)\n            if next_i is None:\n                return -1\n            if remove_leaves(next_i, next_j):\n                leaves -= 1\n                if leaves == 1:\n                    return 1\n            i, j = next_i, next_j\n\n    return str(min_leaves_to_remove())\n"
    },
    {
        "number": 3772,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b == 1:\n        return \"1\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def resistor_count(e, r0):\n        if e == 1:\n            return 1\n        return resistor_count(e - 1, r0) + resistor_count(e - 1, r0 + 1)\n\n    def element_count(e, r0):\n        if e == 1:\n            return 1\n        return element_count(e - 1, r0) + element_count(e - 1, r0 + 1)\n\n    e = a // b\n    r0 = 1\n    while True:\n        if element_count(e, r0) == 1:\n            break\n        r0 += 1\n\n    return str(resistor_count(e, r0))\n"
    },
    {
        "number": 3773,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    piles = []\n    for i in range(n):\n        a, k = map(int, stdin.split()[1:3])\n        piles.append((a, k))\n    piles.sort(key=lambda x: (-x[0], x[1]))\n    takahashi_stones = 0\n    aoki_stones = 0\n    winner = \"\"\n    for pile in piles:\n        takahashi_stones += pile[0]\n        aoki_stones += pile[0]\n        if takahashi_stones >= aoki_stones:\n            winner = \"Takahashi\"\n            break\n        aoki_stones -= pile[0]\n        takahashi_stones -= pile[0]\n    return winner"
    },
    {
        "number": 3774,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    chessboard = [[0] * m for _ in range(n)]\n    max_count = 0\n    for i in range(n):\n        for j in range(m):\n            if chessboard[i][j] == 0:\n                max_count += 1\n                dfs(i, j, chessboard, max_count)\n    return str(max_count)\n\ndef"
    },
    {
        "number": 3775,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs_1 = set(map(int, stdin.split()))\n    pairs_2 = set(map(int, stdin.split()))\n\n    if len(pairs_1)!= len(pairs_2):\n        return \"-1\"\n\n    for pair in pairs_1:\n        if pair in pairs_2:\n            return str(pair)\n\n    for pair in pairs_2:\n        if pair in pairs_1:\n            return str(pair)\n\n    return \"0\""
    },
    {
        "number": 3776,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    format_type = int(stdin.split()[0])\n    time = stdin.split()[1]\n\n    if format_type == 12:\n        hours, minutes = map(int, time.split(':'))\n        if hours == 0:\n            hours = 12\n        if minutes == 0:\n            minutes = 60\n        if hours == 12:\n            time = f\"{hours:02d}:{minutes:02d}\"\n        else:\n            time = f\"{hours:02d}:{minutes:02d}\"\n    else:\n        hours, minutes = map(int, time.split(':'))\n        if hours == 0:\n            hours = 24\n        if minutes == 0:\n            minutes = 60\n        if hours == 24:\n            time = f\"{hours:02d}:{minutes:02d}\"\n        else:\n            time = f\"{hours:02d}:{minutes:02d}\"\n\n    return time"
    },
    {
        "number": 3777,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = int(stdin.split()[1])\n    edges = []\n    for i in range(m):\n        u, v, w = map(int, stdin.split())\n        edges.append((u - 1, v - 1, w))\n\n    def dfs(u, color, visited, parent, depth):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                if color[v] == -1 or (color[v] == 0 and w < x):\n                    color[v] = 1 - color[u]\n                    parent[v] = u\n                    dfs(v, color, visited, parent, depth + 1)\n\n    color = [-1] * n\n    parent = [-1] * n\n    visited = [False] * n\n    depth = 0\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, color, visited, parent, depth)\n            depth = 0\n\n    white_count = 0\n    black_count = 0\n    for u in range(n):\n        for v, w in edges[u]:\n            if color[u] == 0 and color[v] == 1:\n                white_count += 1\n            elif color[u] == 1 and color[v] == 0:\n                black_count += 1\n\n    return str(white_count + black_count)\n"
    },
    {
        "number": 3778,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(row, col, hits):\n        if row == 1 and col == 1:\n            return hits == 1\n        if row == n and col == n:\n            return hits == 1\n        if row == 1 and col == n:\n            return hits == 2\n        if row == n and col == 1:\n            return hits == 2\n        if row == 1:\n            return hits <= 2\n        if row == n:\n            return hits <= 2\n        if col == 1:\n            return hits <= 2\n        if col == n:\n            return hits <= 2\n        return True\n\n    def dfs(row, col, hits, result):\n        if row == n and col == n:\n            return result\n\n        if row == 1 and col == n:\n            if hits == 1:\n                result.append((row, col))\n            return result\n\n        if row == n and col == 1:\n            if hits == 1:\n                result.append((row, col))\n            return result\n\n        if row == 1:\n            if hits <= 2:\n                result.append((row, col))\n            return result\n\n        if row == n:\n            if hits <= 2:\n                result.append((row, col))\n            return result\n\n        if col == 1:\n            if hits <= 2:\n                result.append((row, col))\n            return result\n\n        if col == n:\n            if hits <= 2:\n                result.append((row, col))\n            return result\n\n        if is_valid(row, col, hits):\n            dfs(row + 1, col, hits + 1, result)\n            dfs(row - 1, col, hits + 1, result)\n            dfs(row, col + 1, hits + 1, result)\n            dfs(row, col - 1, hits + 1, result)\n            dfs(row + 1, col + 1, hits + 1, result)\n            dfs(row - 1, col - 1, hits + 1, result)\n            dfs(row - 1, col + 1, hits + 1, result)\n            dfs(row + 1, col - 1, hits + 1, result)\n\n    result = []\n    dfs(1, 1, 1, result)\n\n    if not result:\n        return -1\n\n    t = len(result)\n    print(t)\n    for row, col in result:\n        print(row, col)\n\n    return \"\"\n"
    },
    {
        "number": 3779,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_happy(num: int) -> bool:\n        while num!= 1:\n            num = sum(int(digit) ** 2 for digit in str(num))\n        return num == 1\n\n    def find_happy_digits(a: list[int]) -> list[int]:\n        happy_digits = []\n        for num in a:\n            if is_happy(num):\n                happy_digits.append(num)\n        return happy_digits\n\n    happy_digits = find_happy_digits(a)\n    happy_digits.sort()\n\n    print(len(happy_digits))\n    for digit in happy_digits:\n        print(digit)\n\n    return \"\"\n"
    },
    {
        "number": 3780,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    v_max, t = map(int, stdin.split())\n    wind_changes = [tuple(map(int, stdin.split())) for _ in range(2)]\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def angle(x1, y1, x2, y2):\n        return (x2 - x1) * (y2 - y1) / distance(x1, y1, x2, y2)\n\n    def dot(x1, y1, x2, y2):\n        return x1 * x2 + y1 * y2\n\n    def cross(x1, y1, x2, y2):\n        return x1 * y2 - x2 * y1\n\n    def is_colliding(x1, y1, v1, w1, x2, y2, v2, w2):\n        return (\n            (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n        )\n\n    def is_wind_colliding(x1, y1, v1, w1, x2, y2, v2, w2):\n        return (\n            (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n        )\n\n    def is_wind_colliding_with_airship(x1, y1, v1, w1, x2, y2, v2, w2):\n        return (\n            (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n            and (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n        )\n\n    def is_wind_colliding_with_airship_and_wind_change(x1, y1, v1, w1, x2, y2, v2, w2):\n        return (\n            (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n            and (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x2, y2, x1, y1)) ** 2\n            and is_wind_colliding_with_airship(x1, y1, v1, w1, x2, y2, v2, w2)\n        )\n\n    def is_wind_colliding_with_airship_and_wind_change_and_wind_change(\n        x1, y1, v1, w1, x2, y2, v2, w2\n    ):\n        return (\n            (x1 + v1 * t) ** 2 + (y1 + v1 * t * angle(x1, y1, x2, y2)) ** 2\n            <= (x2 + v2 * t) ** 2 + (y2 + v2 * t * angle(x"
    },
    {
        "number": 3781,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for i in range(test_cases):\n        N = int(stdin.split('\\n')[i+1].split()[0])\n        coins = list(map(int, stdin.split('\\n')[i+1].split()[1:]))\n        bag_coins = [0] * N\n        bag_count = [0] * N\n        for coin in coins:\n            bag_index = coin // 1000\n            dish_index = coin % 1000\n            bag_coins[bag_index] += 1\n            bag_count[bag_index] += 1\n            if bag_count[bag_index] == 1:\n                bag_coins[bag_index] = coin\n            else:\n                bag_coins[bag_index] -= 1\n        for j in range(N):\n            if bag_coins[j] > 0:\n                bag_index = j\n                break\n        else:\n            continue\n        dish_index = coins.index(bag_coins[bag_index])\n        coins.remove(bag_coins[bag_index])\n        bag_coins[bag_index] = 0\n        bag_count[bag_index] = 0\n        if bag_index == 0:\n            bag_index = N - 1\n        else:\n            bag_index -= 1\n        bag_coins[bag_index] += 1\n        bag_count[bag_index] += 1\n        if bag_count[bag_index] == 1:\n            bag_coins[bag_index] = coins[0]\n        else:\n            bag_coins[bag_index] -= 1\n        if bag_coins[bag_index] == 0:\n            dish_index = coins.index(1)\n            coins.remove(1)\n            bag_coins[bag_index] = 0\n            bag_count[bag_index] = 0\n            if bag_index == 0:\n                bag_index = N - 1\n            else:\n                bag_index -= 1\n            bag_coins[bag_index] += 1\n            bag_count[bag_index] += 1\n            if bag_count[bag_index] == 1:\n                bag_coins[bag_index] = coins[0]\n            else:\n                bag_coins[bag_index] -= 1\n        if bag_coins[bag_index] > 0:\n            bag_index = j\n            break\n        else:\n            continue\n        dish_index = coins.index(bag_coins[bag_index])\n        coins.remove(bag_coins[bag_index])\n        bag_coins[bag_index] = 0\n        bag_count[bag_index] = 0\n        if bag_index == 0:\n            bag_index = N - 1\n        else:\n            bag_index -= 1\n        bag_coins[bag_index] += 1\n        bag_count[bag_index] += 1\n        if bag_count[bag_index] == 1:\n            bag_coins[bag_index] = coins[0]\n        else:\n            bag_coins[bag_index] -= 1\n        if bag_coins[bag_index] == 0:\n            dish_index = coins.index(1)\n            coins.remove(1)\n            bag_coins[bag_index] = 0\n            bag_count[bag_index] = 0\n            if bag_index == 0:\n                bag_index = N - 1\n            else:\n                bag_index -= 1\n            bag_coins[bag_index] += 1\n            bag_count[bag_index] += 1\n            if bag_count[bag_index] == 1:\n                bag_coins[bag_index] = coins[0]\n            else:\n                bag_coins[bag_index] -= 1\n        if bag_coins[bag_index] > 0:\n            bag_index = j\n            break\n        else:\n            continue\n        dish_index = coins.index(bag_coins[bag_index])\n        coins.remove(bag_coins[bag_index])\n        bag_coins[bag_index] = 0\n        bag_count[bag_index] = 0\n        if bag_index == 0:\n            bag_index = N - 1\n        else:\n            bag_index -= 1\n        bag_coins[bag_index] += 1\n        bag_count[bag_index] += 1\n        if bag_count[bag_index] == 1:\n            bag_coins[bag_index] = coins[0]\n        else:\n            bag_coins[bag_index] -= 1"
    },
    {
        "number": 3782,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_heapify(arr, i, heap_size):\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < heap_size and arr[left] < arr[smallest]:\n            smallest = left\n\n        if right < heap_size and arr[right] < arr[smallest]:\n            smallest = right\n\n        if smallest!= i:\n            arr[i], arr[smallest] = arr[smallest], arr[i]\n            min_heapify(arr, smallest, heap_size)\n\n    def build_min_heap(arr):\n        heap_size = len(arr)\n        for i in range(heap_size // 2 - 1, -1, -1):\n            min_heapify(arr, i, heap_size)\n\n    def extract_min(arr):\n        if len(arr) == 0:\n            return None\n        min_val = arr[0]\n        arr[0] = arr[-1]\n        heap_size = len(arr) - 1\n        min_heapify(arr, 0, heap_size)\n        return min_val\n\n    def min_heap_extract_min(arr):\n        min_val = extract_min(arr)\n        heap_size = len(arr)\n        if heap_size > 1:\n            arr[0] = arr[heap_size - 1]\n            min_heapify(arr, 0, heap_size - 1)\n        return min_val\n\n    def min_heap_extract_min_k(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min(arr)\n\n    def min_heap_extract_min_k_and_remove(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove_min(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min_min_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove_min_min(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min_min_min_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove_min_min_min(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min_min_min_min_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove_min_min_min_min(arr, k)\n\n    def min_heap_extract_min_k_and_remove_min_min_min_min_min_min(arr, k):\n        min_heap_size = len(arr)\n        if min_heap_size < k:\n            return None\n        min_heap_extract_min(arr)\n        return min_heap_extract_min_k_and_remove_min_min_min_min_min(arr, k)\n\n    def min_heap_extract_min_k"
    },
    {
        "number": 3783,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N + 1):\n        for j in range(i):\n            dp[i] += dp[j] * (j + 1)\n            dp[i] %= MOD\n    return str(dp[N])"
    },
    {
        "number": 3784,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def is_isomorphic(g1, g2):\n        def dfs(u, f):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g1[u]:\n                if v not in visited:\n                    visited[v] = dfs(v, f) ^ 1\n            return visited[u] ^ f[u]\n\n        visited = {}\n        for u in g1:\n            visited[u] = dfs(u, {})\n\n        visited = {}\n        for u in g2:\n            visited[u] = dfs(u, {})\n\n        return visited == visited\n\n    def count_non_similar_worlds(changes):\n        def dfs(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g1[u]:\n                if v not in visited:\n                    visited[v] = dfs(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count_count_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count_count_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count_count_count_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count_count_count_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count_count_count_count_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count_count_count_count_count(u, f, visited):\n            if u in visited:\n                return visited[u]\n            visited[u] = True\n            for v in g2[u]:\n                if v not in visited:\n                    visited[v] = dfs_isomorphic_cut_count_count_count_count_count_count(v, f, visited) ^ 1\n            return visited[u] ^ f[u]\n\n        def dfs_isomorphic_cut_count_count_count_count_count_count_count(u, f, visited):\n            if u in visited:\n                return visited["
    },
    {
        "number": 3785,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    maze = [list(line.strip()) for line in stdin.splitlines()]\n\n    def dfs(x, y):\n        if x < 0 or x >= n or y < 0 or y >= m or maze[x][y] == \"#\":\n            return False\n        maze[x][y] = \"X\"\n        return dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1)\n\n    for _ in range(k):\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == \".\" and dfs(i, j):\n                    maze[i][j] = \"#\"\n\n    return \"\\n\".join(\"\".join(row) for row in maze)\n"
    },
    {
        "number": 3786,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    apples = [0] * n\n    for i in range(1, n):\n        apples[p[i] - 1] += 1\n    return str(sum(apples))"
    },
    {
        "number": 3787,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n\n    def is_valid(seq):\n        increasing = True\n        decreasing = True\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i + 1]:\n                increasing = False\n            elif seq[i] < seq[i + 1]:\n                decreasing = False\n            if not increasing and not decreasing:\n                return False\n        return True\n\n    def longest_increasing_subsequence(seq):\n        increasing = [False] * len(seq)\n        increasing[0] = True\n        for i in range(1, len(seq)):\n            if seq[i] > seq[i - 1]:\n                increasing[i] = increasing[i - 1]\n            else:\n                increasing[i] = True\n                for j in range(i - 1, -1, -1):\n                    if increasing[j] and seq[i] > seq[j]:\n                        increasing[i] = False\n                        break\n        return increasing\n\n    def longest_decreasing_subsequence(seq):\n        decreasing = [False] * len(seq)\n        decreasing[0] = True\n        for i in range(1, len(seq)):\n            if seq[i] < seq[i - 1]:\n                decreasing[i] = decreasing[i - 1]\n            else:\n                decreasing[i] = True\n                for j in range(i - 1, -1, -1):\n                    if decreasing[j] and seq[i] < seq[j]:\n                        decreasing[i] = False\n                        break\n        return decreasing\n\n    def construct_sequence(increasing, decreasing):\n        sequence = []\n        i = 0\n        while i < len(increasing) and increasing[i]:\n            sequence.append(i)\n            i += 1\n        j = len(increasing) - 1\n        while j >= 0 and decreasing[j]:\n            sequence.append(j)\n            j -= 1\n        return sequence\n\n    increasing = longest_increasing_subsequence(list(range(1, n + 1)))\n    decreasing = longest_decreasing_subsequence(list(range(n, 0, -1)))\n\n    if not is_valid(increasing) or not is_valid(decreasing):\n        return -1\n\n    sequence = construct_sequence(increasing, decreasing)\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 3788,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_possible(a: int, b: int) -> bool:\n        return gcd(a, b) > 1\n\n    def reconstruct_tree(a: int, b: int) -> str:\n        if a == b:\n            return str(a)\n        if is_possible(a, b):\n            return f\"({reconstruct_tree(a, b // 2)} {reconstruct_tree(a, b // 2)})\"\n        return f\"({reconstruct_tree(a, b // 2)} {reconstruct_tree(a, b // 2)})\"\n\n    possible = False\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_possible(a[i], a[j]):\n                possible = True\n                print(\"Yes\")\n                return\n\n    if possible:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
    },
    {
        "number": 3789,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def smash(i: int) -> int:\n        nonlocal a\n        while i % 2 == 0:\n            i //= 2\n            a[i] = 0\n        return i\n\n    def can_smash(i: int) -> bool:\n        nonlocal a\n        return a[i] > 0\n\n    def can_earn(i: int) -> int:\n        nonlocal a\n        return a[i] * (i + 1)\n\n    def max_earn() -> int:\n        nonlocal a\n        max_earn = 0\n        for i in range(1, N + 1):\n            if can_smash(i):\n                a[smash(i)] = 0\n            if can_earn(i) > max_earn:\n                max_earn = can_earn(i)\n        return max_earn\n\n    return str(max_earn())"
    },
    {
        "number": 3790,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the length of the longest non-decreasing subsequence\n    max_length = 1\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            max_length += 1\n        else:\n            max_length = 1\n\n    # Find the length of the longest non-decreasing sequence\n    max_length_seq = 1\n    for i in range(n, n + T):\n        if a[i] > a[i - n]:\n            max_length_seq += 1\n        else:\n            max_length_seq = 1\n\n    return str(max(max_length, max_length_seq))"
    },
    {
        "number": 3791,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    def min_deviation(p: list) -> int:\n        min_dev = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] > p[j]:\n                    min_dev = min(min_dev, abs(p[i] - p[j]))\n        return min_dev\n\n    def min_shift(p: list) -> tuple:\n        min_dev = min_deviation(p)\n        min_shift_id = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] > p[j]:\n                    shift_id = abs(p[i] - p[j])\n                    if shift_id < min_shift_id or (shift_id == min_shift_id and p[i] < p[j]):\n                        min_shift_id = shift_id\n                        min_shift = (i, j)\n        return min_shift_id, min_shift\n\n    min_dev_id, min_dev_shift = min_shift(p)\n    return f\"{min_dev_id} {min_dev_shift[0]}\"\n"
    },
    {
        "number": 3792,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s, t = stdin.split()\n    s, t = s.lower(), t.lower()\n    c = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            c += 1\n        else:\n            break\n    for i in range(n, len(s)):\n        if s[i] == t[i]:\n            c += 1\n        else:\n            break\n    return str(c)"
    },
    {
        "number": 3793,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = len(lines)\n    if n!= 8:\n        return \"NO\"\n\n    def restore_coordinates(coordinates: List[int]) -> List[int]:\n        x, y, z = coordinates\n        return [x, y, z]\n\n    def is_valid_permutation(coordinates: List[int]) -> bool:\n        x, y, z = coordinates\n        return x == 0 or y == 0 or z == 0 or x == y or x == z or y == z\n\n    def find_valid_permutation(coordinates: List[int]) -> List[int]:\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n        return None\n\n    def find_permutation(coordinates: List[int]) -> List[int]:\n        if is_valid_permutation(coordinates):\n            return coordinates\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n            coordinates[i] = 0\n        return None\n\n    def swap_numbers(coordinates: List[int], i: int, j: int) -> List[int]:\n        x, y, z = coordinates\n        coordinates[i], coordinates[j] = coordinates[j], coordinates[i]\n        return coordinates\n\n    def find_swapped_coordinates(coordinates: List[int], i: int, j: int) -> List[int]:\n        x, y, z = coordinates\n        if x == 0:\n            coordinates[i] = 0\n            coordinates[j] = 0\n        elif y == 0:\n            coordinates[i] = 0\n            coordinates[j] = 1\n        elif z == 0:\n            coordinates[i] = 0\n            coordinates[j] = 2\n        elif x == y:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        elif x == z:\n            coordinates[i] = 2\n            coordinates[j] = 1\n        elif y == z:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        return coordinates\n\n    def find_valid_swapped_coordinates(coordinates: List[int], i: int, j: int) -> List[int]:\n        x, y, z = coordinates\n        if x == 0:\n            coordinates[i] = 0\n            coordinates[j] = 0\n        elif y == 0:\n            coordinates[i] = 0\n            coordinates[j] = 1\n        elif z == 0:\n            coordinates[i] = 0\n            coordinates[j] = 2\n        elif x == y:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        elif x == z:\n            coordinates[i] = 2\n            coordinates[j] = 1\n        elif y == z:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n            coordinates[i] = 0\n        return None\n\n    def find_swapped_permutation(coordinates: List[int], i: int, j: int) -> List[int]:\n        x, y, z = coordinates\n        if x == 0:\n            coordinates[i] = 0\n            coordinates[j] = 0\n        elif y == 0:\n            coordinates[i] = 0\n            coordinates[j] = 1\n        elif z == 0:\n            coordinates[i] = 0\n            coordinates[j] = 2\n        elif x == y:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        elif x == z:\n            coordinates[i] = 2\n            coordinates[j] = 1\n        elif y == z:\n            coordinates[i] = 1\n            coordinates[j] = 2\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n            coordinates[i] = 0\n        return None\n\n    def find_valid_coordinates(coordinates: List[int]) -> List[int]:\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n        return None\n\n    def find_coordinates(coordinates: List[int]) -> List[int]:\n        if is_valid_permutation(coordinates):\n            return coordinates\n        for i in range(1, 10):\n            if is_valid_permutation(coordinates):\n                return coordinates\n            coordinates[i] = 0\n        return None\n\n    def find_valid_swapped_coordinates_and_permutation(coordinates: List[int], i: int, j: int) -> Tuple[List[int], List[int"
    },
    {
        "number": 3794,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def split_groups(arr: List[int]) -> List[int]:\n        first_group = []\n        second_group = []\n        for num in arr:\n            if gcd(num, 1) == 1:\n                first_group.append(num)\n            else:\n                second_group.append(num)\n        return first_group, second_group\n\n    first_group, second_group = split_groups(arr)\n\n    if len(first_group) == 0 or len(second_group) == 0:\n        return \"NO\"\n\n    first_group_gcd = gcd(first_group[0], 1)\n    second_group_gcd = gcd(second_group[0], 1)\n\n    if first_group_gcd!= 1 or second_group_gcd!= 1:\n        return \"NO\"\n\n    first_group_nums = [1] * len(first_group)\n    second_group_nums = [2] * len(second_group)\n\n    return \"YES\\n\" + \" \".join(map(str, first_group_nums + second_group_nums))\n"
    },
    {
        "number": 3795,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, e = map(int, stdin.split())\n    bills = [1, 2, 5, 10, 20, 50, 100]\n    bills_prices = [d, e]\n    bills_count = [0] * len(bills)\n\n    for bill in bills:\n        bills_count[bills.index(bill)] = n // bill\n\n    for i in range(len(bills_count)):\n        bills_count[i] = min(bills_count[i], bills_prices[i] // bills_prices[i - 1])\n\n    total_rubles = sum(bills_prices[:i + 1] * bills_count[:i + 1] for i in range(len(bills_count)))\n\n    return str(total_rubles)"
    },
    {
        "number": 3796,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n\n    def is_beautiful(matrix):\n        for row in matrix:\n            if len(set(row))!= len(row):\n                return False\n        for col in range(len(matrix[0])):\n            if len(set([row[col] for row in matrix]))!= len(matrix):\n                return False\n        return True\n\n    def construct_rectangle(nums):\n        matrix = [[0] * n for _ in range(n)]\n        for num in nums:\n            row, col = divmod(matrix.index(nums[:num]), n)\n            matrix[row][col] = num\n            nums.pop(0)\n        return matrix\n\n    def max_beautiful_rectangle(matrix):\n        max_area = 0\n        for row in matrix:\n            for col in range(len(row)):\n                for i in range(1, n - col):\n                    area = (i + 1) * min(row[col], row[col + i])\n                    max_area = max(max_area, area)\n        return max_area\n\n    matrix = construct_rectangle(nums)\n    if is_beautiful(matrix):\n        x = max_beautiful_rectangle(matrix)\n        p = len(matrix)\n        q = len(matrix[0])\n        result = []\n        for row in matrix:\n            result.append(\" \".join(map(str, row)))\n        return f\"{x}\\n{p} {q}\\n{'\\n'.join(result)}\"\n    else:\n        return \"No solution\""
    },
    {
        "number": 3797,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    l_list = []\n    r_list = []\n    x_list = []\n    for i in range(M):\n        l, r, x = map(int, stdin.split())\n        l_list.append(l)\n        r_list.append(r)\n        x_list.append(x)\n\n    MOD = 10**9 + 7\n\n    def count_ways(l, r, x):\n        if l == r:\n            return 1\n        if l > r:\n            l, r = r, l\n        ways = 0\n        for i in range(l, r + 1):\n            if x_list[i - 1] == 1:\n                ways += count_ways(l, i - 1, x_list[i - 1])\n            elif x_list[i - 1] == 2:\n                ways += count_ways(l, i - 1, x_list[i - 1]) + count_ways(i, r, x_list[i - 1])\n            else:\n                ways += count_ways(l, i - 1, x_list[i - 1]) + count_ways(i, r, x_list[i - 1])\n        return ways % MOD\n\n    ways = 1\n    for i in range(1, N + 1):\n        ways *= count_ways(1, i, x_list[i - 1])\n        ways %= MOD\n    return str(ways)"
    },
    {
        "number": 3798,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    b = 2\n    while b <= n:\n        if f(b, n) == s:\n            return str(b)\n        b += 1\n    return \"-1\"\n\ndef"
    },
    {
        "number": 3799,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 3:\n        return \"Invalid input\"\n\n    # Check if there are any equal neighboring characters\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return \"Invalid input\"\n\n    # Takahashi goes first\n    player = 0\n    while True:\n        # Remove a character from the end of the string\n        if player == 0:\n            s = s[:-1]\n        else:\n            s = s[1:]\n\n        # Check if the string is valid\n        if len(s) < 3:\n            return \"Invalid input\"\n\n        # Check if there are any equal neighboring characters\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return \"Invalid input\"\n\n        # Check if the string is valid after removing a character\n        if len(s) < 3:\n            return \"Invalid input\"\n\n        # If the string is valid, the player with the first character wins\n        if len(s) == 3:\n            return \"First\"\n\n        # Switch to the other player\n        player = 1 - player"
    },
    {
        "number": 3800,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, s = map(int, stdin.split())\n    n = len(s)\n    b = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            b[i][j] = s[i] * s[j]\n\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if b[i][j] == a:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3801,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    likes = list(map(int, stdin.split()))\n    weights = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(likes, weights):\n        total_weight = sum(weights)\n        p = [w / total_weight for w in weights]\n        q = [0] * len(p)\n        for i in range(len(p)):\n            q[i] = lcm(p[i], 998244353)\n\n        def solve_helper(index, weights, p, q):\n            if index == len(likes):\n                return 0\n\n            if weights[index] == 0:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 1:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 2:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 3:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 4:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 5:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 6:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 7:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 8:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 9:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 10:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 11:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 12:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 13:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 14:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 15:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 16:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 17:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 18:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 19:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 20:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 21:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 22:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 23:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 24:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 25:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 26:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 27:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 28:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] == 29:\n                return solve_helper(index + 1, weights, p, q)\n\n            if weights[index] =="
    },
    {
        "number": 3802,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2, virus = stdin.split('\\n')\n    s1 = set(s1)\n    s2 = set(s2)\n    virus = set(virus)\n\n    def longest_common_subsequence(s1: set, s2: set, virus: set) -> str:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        lcs = []\n        i, j = m, n\n        while i > 0 and j > 0:\n            if s1[i - 1] == s2[j - 1]:\n                lcs.append(s1[i - 1])\n                i -= 1\n                j -= 1\n            elif dp[i - 1][j] > dp[i][j - 1]:\n                i -= 1\n            else:\n                j -= 1\n\n        return ''.join(reversed(lcs))\n\n    return longest_common_subsequence(s1, s2, virus)"
    },
    {
        "number": 3803,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hp_y, atk_y, def_y = map(int, stdin.split())\n    hp_m, atk_m, def_m = map(int, stdin.split())\n    h, a, d = map(int, stdin.split())\n\n    def buy_attributes(hp, atk, def_, h, a, d):\n        total_price = (hp * h) + (atk * a) + (def_ * d)\n        return total_price\n\n    def battle(hp_y, atk_y, def_y, hp_m, atk_m, def_m):\n        while hp_y > 0 and hp_m > 0:\n            if hp_y > 0:\n                hp_y -= max(0, atk_y - def_m)\n            if hp_m > 0:\n                hp_m -= max(0, atk_m - def_y)\n        return hp_y, hp_m\n\n    total_price = buy_attributes(hp_y, atk_y, def_y, h, a, d)\n    min_bitcoins = total_price\n    while True:\n        hp_y, hp_m = battle(hp_y, atk_y, def_y, hp_m, atk_m, def_m)\n        total_price = buy_attributes(hp_y, atk_y, def_y, h, a, d)\n        if total_price < min_bitcoins:\n            min_bitcoins = total_price\n\n    return str(min_bitcoins)"
    },
    {
        "number": 3804,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    m = n + 1\n\n    # Initialize the matrix with zeros\n    matrix = [[0] * m for _ in range(m)]\n\n    # Fill the matrix\n    for i in range(1, m):\n        for j in range(1, m):\n            matrix[i][j] = matrix[i - 1][j] ^ matrix[i][j - 1]\n\n    # Count the numbers m such that the sum of values in the cells in the row number m + 1 of the resulting matrix equals t\n    count = 0\n    for i in range(1, m):\n        if matrix[i][m - 1] == t:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3805,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    plus_count = 0\n    minus_count = 0\n    for i in range(n):\n        if stdin[i] == '+':\n            plus_count += 1\n        else:\n            minus_count += 1\n    if plus_count == 0 or minus_count == 0:\n        return \"Yes\"\n    if plus_count == 1 and minus_count == 1:\n        return \"Yes\"\n    return \"No\""
    },
    {
        "number": 3806,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def cross(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def area(points):\n        return 0.5 * abs(cross(points[0], points[1], points[2]))\n\n    def is_inside(p, points):\n        return all(cross(p, points[i], points[(i + 1) % 3]) > 0 for i in range(n))\n\n    def is_on_border(p, points):\n        return any(cross(p, points[i], points[(i + 1) % 3]) == 0 for i in range(n))\n\n    def is_on_line(p, points):\n        return all(cross(points[i], points[(i + 1) % 3], p) == 0 for i in range(n))\n\n    def is_on_segment(p, a, b):\n        return cross(a, b, p) == 0\n\n    def is_on_circle(p, center, radius):\n        return distance(p, center) <= radius\n\n    def is_inside_circle(p, center, radius):\n        return is_on_circle(p, center, radius) and is_inside(p, points)\n\n    def is_on_circle_border(p, center, radius):\n        return is_on_circle(p, center, radius) and is_on_border(p, points)\n\n    def is_on_circle_segment(p, center, radius):\n        return is_on_circle(p, center, radius) and is_on_segment(p, points[0], points[1])\n\n    def is_on_circle_triangle(p, center, radius):\n        return is_on_circle(p, center, radius) and is_on_triangle(p, points[0], points[1], points[2])\n\n    def is_on_triangle(p, a, b, c):\n        return cross(b - a, c - a) * cross(p - a, b - a) > 0 and cross(c - b, a - b) * cross(p - b, c - b) > 0\n\n    def is_inside_triangle(p, a, b, c):\n        return is_on_triangle(p, a, b, c) and is_inside(p, [a, b, c])\n\n    def is_on_triangle_border(p, a, b, c):\n        return is_on_triangle(p, a, b, c) and is_on_border(p, [a, b, c])\n\n    def is_on_triangle_segment(p, a, b, c):\n        return is_on_triangle(p, a, b, c) and is_on_segment(p, a, b)\n\n    def is_on_triangle_circle(p, a, b, c, center, radius):\n        return is_on_triangle(p, a, b, c) and is_on_circle(p, center, radius)\n\n    def is_inside_triangle_circle(p, a, b, c, center, radius):\n        return is_inside_triangle(p, a, b, c) and is_on_circle(p, center, radius)\n\n    def is_on_triangle_triangle(p, a, b, c, d):\n        return is_on_triangle(p, a, b, c) and is_on_triangle(p, a, b, d)\n\n    def is_inside_triangle_triangle(p, a, b, c, d):\n        return is_inside_triangle(p, a, b, c) and is_inside_triangle(p, a, b, d)\n\n    def is_on_triangle_triangle_border(p, a, b, c, d):\n        return is_on_triangle(p, a, b, c) and is_on_triangle(p, a, b, d) and is_on_border(p, [a, b, c, d])\n\n    def is"
    },
    {
        "number": 3807,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    max_blocks = 0\n    max_volume = 0\n\n    for side in range(1, m + 1):\n        volume = side ** 3\n        if volume > max_volume:\n            max_blocks = 1\n            max_volume = volume\n        elif volume == max_volume:\n            max_blocks += 1\n\n    return str(max_blocks) + \" \" + str(max_volume)"
    },
    {
        "number": 3808,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n\n    def is_correct(s: str) -> bool:\n        if not s:\n            return True\n        if s[0] == \"(\":\n            return s[1:] in correct_sequences\n        if s[0] == \")\":\n            return s[1:] in correct_sequences\n        return False\n\n    def is_valid(s: str) -> bool:\n        if not s:\n            return True\n        if s[0] == \"(\":\n            return s[1:] in valid_sequences\n        if s[0] == \")\":\n            return s[1:] in valid_sequences\n        return False\n\n    def is_valid_concat(s: str) -> bool:\n        if not s:\n            return True\n        if s[0] == \"(\":\n            return s[1:] in valid_concat_sequences\n        if s[0] == \")\":\n            return s[1:] in valid_concat_sequences\n        return False\n\n    valid_sequences = set()\n    valid_concat_sequences = set()\n    correct_sequences = set()\n\n    def dfs(s: str, index: int, is_concat: bool) -> None:\n        if index == n:\n            if is_concat:\n                valid_concat_sequences.add(s)\n            else:\n                valid_sequences.add(s)\n            return\n\n        if is_concat:\n            dfs(s + \"()\", index + 1, is_concat)\n        else:\n            dfs(s + \"()\", index + 1, is_concat)\n            dfs(s + \"()\", index + 1, is_concat)\n\n    dfs(\"\", 0, False)\n\n    if is_valid(sequence):\n        return \"Yes\"\n    elif is_valid_concat(sequence):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 3809,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    people_weights = list(map(int, stdin.split()))\n    people_weights.append(0)  # add 0 to the end to make it a valid list\n\n    def dfs(start, visited, path, rides):\n        if start == n:\n            rides += 1\n            return rides\n\n        if start in visited:\n            return dfs(start + 1, visited, path, rides)\n\n        visited.add(start)\n        path.append(start)\n\n        for i in range(n):\n            if i not in visited and people_weights[i] <= k:\n                rides = dfs(i, visited, path, rides)\n\n        visited.remove(start)\n        path.pop()\n\n        return rides\n\n    rides = 0\n    visited = set()\n    path = []\n    dfs(0, visited, path, rides)\n\n    if rides == 0:\n        print(-1)\n        print(0)\n    else:\n        print(rides)\n        print(1000000007 % (rides // 1000000007))"
    },
    {
        "number": 3810,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_piles(boxes):\n        piles = []\n        for i in range(1, len(boxes) + 1):\n            for j in range(i, len(boxes) + 1):\n                for k in range(j, len(boxes) + 1):\n                    if gcd(boxes[i], boxes[j]) == 1 and gcd(boxes[i], boxes[k]) == 1:\n                        piles.append(boxes[i] * boxes[j] * boxes[k])\n        return len(piles)\n\n    def find_lcm(boxes):\n        lcm_boxes = []\n        for i in range(1, len(boxes) + 1):\n            for j in range(i, len(boxes) + 1):\n                lcm_boxes.append(lcm(boxes[i], boxes[j]))\n        return lcm_boxes\n\n    def find_max_piles(boxes):\n        max_piles = []\n        for i in range(1, len(boxes) + 1):\n            for j in range(i, len(boxes) + 1):\n                for k in range(j, len(boxes) + 1):\n                    if gcd(boxes[i], boxes[j]) == 1 and gcd(boxes[i], boxes[k]) == 1:\n                        max_piles.append(boxes[i] * boxes[j] * boxes[k])\n        return max_piles\n\n    def find_max_boxes(boxes):\n        max_boxes = []\n        for i in range(1, len(boxes) + 1):\n            for j in range(i, len(boxes) + 1):\n                for k in range(j, len(boxes) + 1):\n                    if gcd(boxes[i], boxes[j]) == 1 and gcd(boxes[i], boxes[k]) == 1:\n                        max_boxes.append(boxes[i] * boxes[j] * boxes[k])\n        return max_boxes\n\n    def find_max_piles_with_max_boxes(boxes):\n        max_piles = []\n        max_boxes = []\n        for i in range(1, len(boxes) + 1):\n            for j in range(i, len(boxes) + 1):\n                for k in range(j, len(boxes) + 1):\n                    if gcd(boxes[i], boxes[j]) == 1 and gcd(boxes[i], boxes[k]) == 1:\n                        max_piles.append(boxes[i] * boxes[j] * boxes[k])\n                        max_boxes.append(boxes[i] * boxes[j] * boxes[k])\n        return max_piles, max_boxes\n\n    boxes = sorted(set(a))\n    lcm_boxes = find_lcm(boxes)\n    max_piles = find_max_piles(boxes)\n    max_boxes = find_max_boxes(boxes)\n    max_piles_with_max_boxes = find_max_piles_with_max_boxes(boxes)\n\n    max_piles_count = count_piles(max_piles)\n    max_boxes_count = count_piles(max_boxes)\n    max_piles_with_max_boxes_count = count_piles(max_piles_with_max_boxes[0])\n\n    max_piles_with_max_boxes_count %= 10**9 + 7\n\n    if max_piles_count > max_piles_with_max_boxes_count:\n        return str(max_piles_count)\n    elif max_boxes_count > max_piles_with_max_boxes_count:\n        return str(max_boxes_count)\n    else:\n        return str(max_piles_with_max_boxes_count)"
    },
    {
        "number": 3811,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[1:])\n        pairs.append((a, b))\n    pairs.sort(key=lambda x: x[0])\n    pairs.sort(key=lambda x: x[1])\n    gcd = 1\n    for i in range(n):\n        gcd = gcd * pairs[i][0] // pairs[i][1]\n    return str(gcd)"
    },
    {
        "number": 3812,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s_a, s_b = 0, 0\n    t_a, t_b = 0, 0\n\n    for i in range(len(s)):\n        if s[i] == 'a':\n            s_a += 1\n        else:\n            s_b += 1\n\n    for i in range(len(t)):\n        if t[i] == 'a':\n            t_a += 1\n        else:\n            t_b += 1\n\n    if s_a == 0 or t_b == 0:\n        return \"0\"\n\n    if s_b == 0 or t_a == 0:\n        return \"0\"\n\n    if s_a == 1 and s_b == 0:\n        return \"1 0\"\n\n    if s_b == 1 and s_a == 0:\n        return \"1 3\"\n\n    if s_a == 1 and s_b == 1:\n        return \"1 0\\n1 3\"\n\n    if s_b == 1 and s_a == 1:\n        return \"1 3\\n1 0\"\n\n    return \"0\"\n"
    },
    {
        "number": 3813,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *parents = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    def dfs(v: int, color: int, weight: int, parent: int) -> None:\n        nonlocal total_weight\n        if color == 0:\n            total_weight += weight\n        for child in range(n + 1):\n            if child!= v and parents[child] == v:\n                dfs(child, 1 - color, weight, v)\n\n    total_weight = 0\n    for v in range(1, n + 1):\n        dfs(v, 0, x[v - 1], 0)\n\n    if total_weight == sum(x):\n        return \"POSSIBLE\"\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3814,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > 50:\n        return \"0\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    if not is_prime(m):\n        return \"0\"\n\n    def count_sets(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_sets(toppings[1:]) + count_sets(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_without_toppings(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_without_toppings(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings_and_without_toppings(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings_and_with_A(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings_and_without_toppings_and_with_A(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings_and_with_B(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings_and_without_toppings_and_with_B(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings_and_with_A_and_B(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings_and_without_toppings_and_with_A_and_B(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings_and_with_A_and_B_and_C(toppings: list) -> int:\n        if len(toppings) == 0:\n            return 1\n        return count_combinations_with_toppings_and_without_toppings_and_with_A_and_B_and_C(toppings[1:]) * (toppings[0] == \"with A\" or toppings[0] == \"with B\")\n\n    def count_combinations_with_toppings_and_without_toppings_and_with_A_and_B_and_C_and_D(toppings: list) -> int:\n        "
    },
    {
        "number": 3815,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    s = list(stdin.split()[1])\n    s = [1 if c == '+' else -1 for c in s]\n\n    def periodicity(s: list, k: int) -> int:\n        return s[k - 1]\n\n    def sum_of_powers(s: list, a: int, b: int, n: int) -> int:\n        return sum(a ** (n - i) * b ** i for i in range(n + 1))\n\n    def modulo(a: int, b: int) -> int:\n        return (a * b) % (10 ** 9 + 9)\n\n    def non_negative_remainder(a: int, b: int, n: int) -> int:\n        return modulo(sum_of_powers(s, a, b, n), 10 ** 9 + 9)\n\n    remainder = non_negative_remainder(a, b, n)\n    return str(remainder)"
    },
    {
        "number": 3816,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, l = map(int, stdin.split())\n    if a + b <= c or a + c <= b or b + c <= a:\n        return \"0\"\n\n    def dfs(a, b, c, l, memo):\n        if (a, b, c, l) in memo:\n            return memo[(a, b, c, l)]\n\n        if a == 0 and b == 0 and c == 0:\n            memo[(a, b, c, l)] = 1\n            return 1\n\n        if a == 0 or b == 0 or c == 0:\n            memo[(a, b, c, l)] = 0\n            return 0\n\n        if a + b <= c or a + c <= b or b + c <= a:\n            memo[(a, b, c, l)] = 0\n            return 0\n\n        if a + b <= l and a + c <= l and b + c <= l:\n            memo[(a, b, c, l)] = dfs(a - 1, b, c, l - a - b, memo) + dfs(a, b - 1, c, l - a - c, memo) + dfs(a, b, c - 1, l - a - c, memo)\n        else:\n            memo[(a, b, c, l)] = 0\n\n        return memo[(a, b, c, l)]\n\n    return str(dfs(a, b, c, l, {}))\n"
    },
    {
        "number": 3817,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(2**m):\n        if i & (i - 1) == 0:\n            count += 1\n    return str((count % (10**9 + 9)))"
    },
    {
        "number": 3818,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    edges = []\n    for i in range(N - 1):\n        a, b = map(int, stdin.split()[1:3])\n        edges.append((a, b))\n    edges.append((N, 1))\n\n    def dfs(u: int, color: int, distance: int, visited: set) -> int:\n        visited.add(u)\n        max_distance = 0\n        for v, d in edges:\n            if v not in visited:\n                if d == 1:\n                    if color == 1:\n                        max_distance = max(max_distance, distance + 1)\n                    else:\n                        max_distance = max(max_distance, distance)\n                else:\n                    max_distance = max(max_distance, dfs(v, 1 - color, distance + 1, visited))\n        return max_distance\n\n    max_distance = 0\n    for i in range(1, 1 << N):\n        if i & (i - 1) == 0:\n            max_distance = max(max_distance, dfs(i, 0, 0, set()))\n\n    return str(max_distance)"
    },
    {
        "number": 3819,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def play_card(hand, pile):\n        if hand:\n            return hand[0], pile[1:]\n        else:\n            return pile[0], pile[1:]\n\n    def draw_card(hand, pile):\n        if hand:\n            return hand[0], pile[1:]\n        else:\n            return pile[0], pile\n\n    def piles_to_order(piles):\n        piles.sort()\n        return piles\n\n    def min_operations(a, b):\n        piles = [a, b]\n        while piles[0]:\n            a, b = play_card(a, b)\n            piles[0] = piles_to_order(piles[0])\n        return len(piles[1])\n\n    return str(min_operations(a, b))"
    },
    {
        "number": 3820,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s, t = stdin.split()\n    s = s.replace('*', '')\n    if s == t:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3821,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *probs = map(float, stdin.split())\n    probs = [round(p, 6) for p in probs]\n    max_prob = max(probs)\n    min_prob = min(probs)\n    if max_prob - min_prob > 1e-9:\n        return \"Invalid input\"\n\n    def max_profit(friends):\n        total_profit = 0\n        for i in range(len(friends)):\n            for j in range(i + 1, len(friends)):\n                total_profit += max(friends[i] - friends[j], 0)\n        return total_profit\n\n    def min_profit(friends):\n        total_profit = 0\n        for i in range(len(friends)):\n            for j in range(i + 1, len(friends)):\n                total_profit += min(friends[i] - friends[j], 0)\n        return total_profit\n\n    def max_profit_friends(friends):\n        max_profit = 0\n        for i in range(len(friends)):\n            for j in range(i + 1, len(friends)):\n                profit = max(friends[i] - friends[j], 0)\n                if profit > max_profit:\n                    max_profit = profit\n        return max_profit\n\n    def min_profit_friends(friends):\n        min_profit = float('inf')\n        for i in range(len(friends)):\n            for j in range(i + 1, len(friends)):\n                profit = min(friends[i] - friends[j], 0)\n                if profit < min_profit:\n                    min_profit = profit\n        return min_profit\n\n    max_profit_friends_set = set()\n    min_profit_friends_set = set()\n    for i in range(n):\n        max_profit_friends_set.add(max_profit_friends(probs))\n        min_profit_friends_set.add(min_profit_friends(probs))\n\n    max_profit_friends_set = sorted(max_profit_friends_set)\n    min_profit_friends_set = sorted(min_profit_friends_set)\n\n    if max_profit_friends_set[-1] == min_profit_friends_set[-1]:\n        return \"Invalid input\"\n\n    if max_profit_friends_set[-1] > min_profit_friends_set[-1]:\n        return max_profit_friends_set[-1]\n    else:\n        return min_profit_friends_set[-1]"
    },
    {
        "number": 3822,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, v_1, v_2, k = map(int, stdin.split())\n    time = 0\n    for i in range(n):\n        if i == 0:\n            time += l / v_1\n        else:\n            time += (l - (i - 1) * l) / v_1\n    time += (n - 1) * (l - l / v_2) / v_2\n    return f\"{time:.6f}\""
    },
    {
        "number": 3823,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(float, stdin.split()[1:]))\n\n    for i in range(n):\n        if i % 2 == 0:\n            a[i] = round(a[i])\n        else:\n            a[i] = round(a[i], 0)\n\n    a_sum = sum(a)\n    a_sum_after_operations = sum(a)\n\n    for i in range(n):\n        if i % 2 == 0:\n            a[i] = round(a[i])\n        else:\n            a[i] = round(a[i], 0)\n\n    a_sum_after_operations = sum(a)\n\n    return str(abs(a_sum_after_operations - a_sum))"
    },
    {
        "number": 3824,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        if dy > 0:\n            return \"8\"\n        else:\n            return \"8\"\n    elif dy == 0:\n        if dx > 0:\n            return \"8\"\n        else:\n            return \"8\"\n    else:\n        x = x1\n        y = y1\n        path = []\n        while True:\n            path.append((x, y))\n            if x == x2 and y == y2:\n                break\n            x += dx\n            y += dy\n\n        path.append((x2, y2))\n        path.reverse()\n\n        min_length = float(\"inf\")\n        for i in range(len(path) - 1):\n            dx = path[i + 1][0] - path[i][0]\n            dy = path[i + 1][1] - path[i][1]\n            length = abs(dx) + abs(dy)\n            if length < min_length:\n                min_length = length\n\n        return str(min_length)"
    },
    {
        "number": 3825,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    roman_digits = {'I': 1, 'V': 5, 'X': 10, 'L': 50}\n    distinct_integers = set()\n\n    def convert_to_integer(roman_numeral: str) -> int:\n        result = 0\n        for digit in roman_numeral:\n            result += roman_digits[digit]\n        return result\n\n    for i in range(1, 4000):\n        roman_numeral = str(i)\n        integer = convert_to_integer(roman_numeral)\n        if integer <= n:\n            distinct_integers.add(integer)\n\n    return str(len(distinct_integers))"
    },
    {
        "number": 3826,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    # sort the array\n    a.sort()\n    \n    # find the minimum size of the subsegment\n    min_size = n\n    for i in range(n-1):\n        if a[i] + 1!= a[i+1]:\n            min_size = min(min_size, i+1)\n    \n    return str(min_size)"
    },
    {
        "number": 3827,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_count = b_count = c_count = 0\n    for char in stdin:\n        if char == 'a':\n            a_count += 1\n        elif char == 'b':\n            b_count += 1\n        else:\n            c_count += 1\n    \n    if a_count == 0 or b_count == 0 or c_count == 0:\n        return \"NO\"\n    \n    if a_count == b_count == c_count:\n        return \"YES\"\n    \n    if a_count == c_count or b_count == c_count:\n        return \"YES\"\n    \n    return \"NO\""
    },
    {
        "number": 3828,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = list(set(p))\n    p.sort()\n    return str(len(p))"
    },
    {
        "number": 3829,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    expected_max = 0\n    for i in range(1, m + 1):\n        expected_max += i * (n - i + 1)\n    return str(expected_max)"
    },
    {
        "number": 3830,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = list(stdin.split('\\n')[2])\n        visited = [False] * n\n        returnable_rooms = 0\n        for i in range(n):\n            if s[i] == '>':\n                visited[i] = True\n            elif s[i] == '<':\n                visited[(i + n - 1) % n] = True\n            elif s[i] == '-':\n                visited[i] = True\n                visited[(i + n - 1) % n] = True\n        for i in range(n):\n            if not visited[i]:\n                returnable_rooms += 1\n        print(returnable_rooms)"
    },
    {
        "number": 3831,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    parts = []\n    for i in range(n):\n        parts.append(list(map(int, stdin.split()[1:3])))\n    parts.sort(key=lambda x: x[0])\n    \n    s = 0\n    s_new = []\n    for i in range(n):\n        s += parts[i][0]\n        s_new.append(s)\n    \n    if s_new[-1] > 10**6:\n        return -1\n    \n    s_new = [s_new[i] + parts[i][1] for i in range(n)]\n    \n    return''.join(map(str, s_new))"
    },
    {
        "number": 3832,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    k = len(a)\n    if k == 1:\n        return \"0\"\n    elif k == 2:\n        return \"1 2\"\n    else:\n        hills = [0] * n\n        hills[0] = a[0]\n        hills[1] = a[1]\n        for i in range(2, n):\n            if a[i] > hills[i - 1]:\n                hills[i] = hills[i - 1] + 1\n            else:\n                hills[i] = hills[i - 1]\n        return \" \".join(map(str, hills[:k]))"
    },
    {
        "number": 3833,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n\n    def count_substrings(s: list, t: list) -> int:\n        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[n][m]\n\n    def rearrange_schedule(s: list, t: list) -> str:\n        n = len(s)\n        m = len(t)\n        dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if i == 0 or j == 0:\n                    dp[i][j] = 0\n                elif s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        max_occurrences = 0\n        max_substring = \"\"\n\n        for i in range(n + 1):\n            for j in range(m + 1):\n                if dp[i][j] > max_occurrences:\n                    max_occurrences = dp[i][j]\n                    max_substring = s[i - 1] * max_occurrences\n\n        return max_substring\n\n    s_rearranged = rearrange_schedule(s, t)\n    return s_rearranged\n"
    },
    {
        "number": 3834,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def dfs(i, j, visited, rectangles):\n        if i < 0 or i >= n or j < 0 or j >= m or a[i][j] == 0 or (i, j) in visited:\n            return\n        visited.add((i, j))\n        rectangles.add((i, j))\n\n        if len(rectangles) == 1:\n            dfs(i - 1, j, visited, rectangles)\n            dfs(i + 1, j, visited, rectangles)\n            dfs(i, j - 1, visited, rectangles)\n            dfs(i, j + 1, visited, rectangles)\n        else:\n            dfs(i - 1, j, visited, rectangles)\n            dfs(i + 1, j, visited, rectangles)\n            dfs(i, j - 1, visited, rectangles)\n            dfs(i, j + 1, visited, rectangles)\n\n        rectangles.remove((i, j))\n\n    rectangles = set()\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                dfs(i, j, visited, rectangles)\n\n    if len(rectangles) == 1:\n        return 0\n    elif len(rectangles) > 1:\n        return -1\n    else:\n        return len(visited)"
    },
    {
        "number": 3835,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    for i in range(n):\n        a[i][i] = 0\n    return \" \".join(str(x) for row in a for x in row)"
    },
    {
        "number": 3836,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    people = []\n    for i in range(n):\n        s, a = stdin.split()[1:3]\n        people.append((s, int(a)))\n\n    alice_count = 0\n    bob_count = 0\n    total_influence = 0\n\n    for s, a in people:\n        if s == \"00\":\n            total_influence += a\n            alice_count += 1\n        elif s == \"10\":\n            total_influence += a\n            bob_count += 1\n        elif s == \"01\":\n            total_influence += a\n            alice_count += 1\n        elif s == \"11\":\n            total_influence += a\n            alice_count += 1\n            bob_count += 1\n\n    if alice_count * 2 >= n and bob_count * 2 >= n and total_influence == max(alice_count, bob_count):\n        return str(total_influence)\n    else:\n        return \"0\""
    },
    {
        "number": 3837,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def dfs(i, j, used, res):\n        if i == n:\n            return res\n\n        if used[i]:\n            return dfs(i + 1, j, used, res)\n\n        if j == m:\n            return dfs(i + 1, 0, used, res)\n\n        if b[i] >= a[j]:\n            used[i] = True\n            res = dfs(i + 1, j + 1, used, res)\n            used[i] = False\n\n        return dfs(i + 1, j + 1, used, res)\n\n    used = [False] * n\n    res = dfs(0, 0, used, [])\n\n    if not res:\n        return \"NO\"\n\n    return \"YES\" + \" \".join(map(str, res))\n"
    },
    {
        "number": 3838,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    q = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n\n    def is_permutation(p: list) -> bool:\n        return len(p) == len(set(p))\n\n    def apply_permutation(p: list, q: list) -> list:\n        result = []\n        for i in range(len(p)):\n            result.append(p[q.index(p[i])])\n        return result\n\n    if not is_permutation(q) or not is_permutation(s):\n        return \"NO\"\n\n    for i in range(k):\n        if s == apply_permutation(q, s):\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3839,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = [[0] * 8 for _ in range(8)]\n    for i in range(n):\n        x, y = map(int, input().split())\n        board[x][y] = 1\n\n    def is_attacked(x, y):\n        return sum(board[i][j] for i in range(8) for j in range(8) if i!= x and j!= y) >= 4\n\n    def find_free_cell():\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 0:\n                    return i, j\n        return None\n\n    def place_knight(x, y):\n        board[x][y] = 1\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 0:\n                    return i, j\n        return None\n\n    def is_valid(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def is_valid_position(x, y):\n        return is_valid(x, y) and board[x][y] == 0\n\n    def is_valid_move(x, y, new_x, new_y):\n        return is_valid(new_x, new_y) and board[new_x][new_y] == 0 and (new_x, new_y)!= (x, y)\n\n    def is_valid_placement(x, y):\n        return is_valid_position(x, y) and not is_attacked(x, y)\n\n    def is_valid_placement_move(x, y, new_x, new_y):\n        return is_valid_move(x, y, new_x, new_y) and is_valid_placement(new_x, new_y)\n\n    def is_valid_placement_placement(x, y, new_x, new_y):\n        return is_valid_placement(new_x, new_y) and (new_x, new_y)!= (x, y)\n\n    def is_valid_placement_placement_move(x, y, new_x, new_y):\n        return is_valid_placement_move(x, y, new_x, new_y) and is_valid_placement_placement(new_x, new_y, new_x, new_y)\n\n    def is_valid_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y):\n        return is_valid_placement_placement_move(x, y, new_x, new_y) and is_valid_placement_placement(new_new_x, new_new_y, new_x, new_y)\n\n    def is_valid_placement_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y, new_new_new_x, new_new_new_y):\n        return is_valid_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y) and is_valid_placement_placement(new_new_new_x, new_new_new_y, new_new_x, new_new_y)\n\n    def is_valid_placement_placement_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y, new_new_new_x, new_new_new_y, new_new_new_new_x, new_new_new_new_y):\n        return is_valid_placement_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y, new_new_new_x, new_new_new_y) and is_valid_placement_placement(new_new_new_new_x, new_new_new_new_y, new_new_new_x, new_new_new_y)\n\n    def is_valid_placement_placement_placement_placement_placement_placement_move(x, y, new_x, new_y, new_new_x, new_new_y, new_new_new_x, new_new_new_y, new_new_new_new_x, new_new_new_new_y"
    },
    {
        "number": 3840,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *coins = map(int, stdin.split())\n    coins = [0] + coins\n    moves = 0\n    while True:\n        moves += 1\n        for i in range(1, n + 1):\n            if coins[i] > 0:\n                coins[i] -= 1\n                if coins[i] == 0:\n                    coins[i] = 1\n                else:\n                    coins[i] = 0\n                break\n        else:\n            break\n    return str(moves) if moves < n else \"-1\""
    },
    {
        "number": 3841,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_poly(poly, mod):\n        res = [0] * len(poly)\n        for i in range(len(poly)):\n            res[i] = (poly[i] + mod) % mod\n        return res\n\n    def find_poly(p, k):\n        def is_valid(poly):\n            non_zero_coeff = False\n            for coeff in poly:\n                if coeff!= 0:\n                    non_zero_coeff = True\n                    break\n            return non_zero_coeff\n\n        def is_valid_poly(poly):\n            non_zero_coeff = False\n            for i in range(len(poly) - 1):\n                if poly[i] == 0:\n                    continue\n                if poly[i] * poly[i + 1] % k == p:\n                    non_zero_coeff = True\n                    break\n            return non_zero_coeff\n\n        def find_poly_helper(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper(a - 1, b, c, d)\n            return find_poly_helper(a, b - 1, c, d)\n\n        def find_poly_helper_2(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_2(a - 1, b, c, d)\n            return find_poly_helper_2(a, b, c - 1, d)\n\n        def find_poly_helper_3(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_3(a - 1, b, c, d)\n            return find_poly_helper_3(a, b, c, d - 1)\n\n        def find_poly_helper_4(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_4(a - 1, b, c, d)\n            return find_poly_helper_4(a, b, c, d + 1)\n\n        def find_poly_helper_5(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_5(a - 1, b, c, d)\n            return find_poly_helper_5(a, b, c, d)\n\n        def find_poly_helper_6(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_6(a - 1, b, c, d)\n            return find_poly_helper_6(a, b, c, d)\n\n        def find_poly_helper_7(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_7(a - 1, b, c, d)\n            return find_poly_helper_7(a, b, c, d)\n\n        def find_poly_helper_8(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_8(a - 1, b, c, d)\n            return find_poly_helper_8(a, b, c, d)\n\n        def find_poly_helper_9(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] + find_poly_helper_9(a - 1, b, c, d)\n            return find_poly_helper_9(a, b, c, d)\n\n        def find_poly_helper_10(a, b, c, d):\n            if a == 0:\n                return [d]\n            if a * b % k == p:\n                return [d] +"
    },
    {
        "number": 3842,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n\n    for i in range(n):\n        b[i] = a[i] * 24\n\n    a = [0] * n\n    for i in range(n):\n        a[i] = a[i] * 24\n\n    a.sort()\n    b.sort()\n\n    experience = 0\n    income = 0\n    days = 0\n\n    for i in range(n):\n        experience += a[i]\n        income += b[i]\n        days += 1\n\n        if experience >= p:\n            break\n\n    if days == 0:\n        return \"0.000000000000000\"\n\n    return str(days)"
    },
    {
        "number": 3843,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    watches = [0] * (n + m + 1)\n    for i in range(1, n + 1):\n        watches[i] = 1\n    for i in range(1, m + 1):\n        watches[i] = 2\n    for i in range(n + 1, n + m + 1):\n        watches[i] = 3\n    watches.sort()\n    count = 0\n    for i in range(1, len(watches)):\n        if watches[i]!= watches[i - 1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3844,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and a[j] < a[i]:\n            j += 1\n        if j == n:\n            return \"Conan\"\n        a[i:j] = []\n        i = j\n    return \"Agasa\""
    },
    {
        "number": 3845,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    grid = [['.' for _ in range(w)] for _ in range(h)]\n\n    def dfs(i, j, color):\n        if i < 0 or i >= h or j < 0 or j >= w or grid[i][j]!= '.':\n            return\n        grid[i][j] = color\n        dfs(i - 1, j, color)\n        dfs(i + 1, j, color)\n        dfs(i, j - 1, color)\n        dfs(i, j + 1, color)\n\n    def bfs(i, j, color):\n        queue = [(i, j)]\n        while queue:\n            x, y = queue.pop(0)\n            if x < 0 or x >= h or y < 0 or y >= w or grid[x][y]!= '.':\n                continue\n            grid[x][y] = color\n            queue.append((x - 1, y))\n            queue.append((x + 1, y))\n            queue.append((x, y - 1))\n            queue.append((x, y + 1))\n\n    def find_connected_components(grid):\n        components = []\n        for i in range(h):\n            for j in range(w):\n                if grid[i][j] == '#':\n                    bfs(i, j, '#')\n                    components.append(grid[i][j] * ''.join(grid[i][j] for j in range(w)))\n                    bfs(i, j, '.')\n        return components\n\n    white_squares = set(map(str, range(1, A + 1)))\n    black_squares = set(map(str, range(1, B + 1)))\n\n    white_components = find_connected_components(grid)\n    black_components = find_connected_components(['#' if c == '.' else '.' for row in grid for c in row])\n\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '.':\n                if white_squares.issubset(white_components):\n                    dfs(i, j, '#')\n                elif black_squares.issubset(black_components):\n                    dfs(i, j, '#')\n                else:\n                    dfs(i, j, '.')\n\n    return f\"{h} {w}\\n\" + '\\n'.join([''.join(row) for row in grid])\n"
    },
    {
        "number": 3846,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    team = [0] * (n + 1)\n    for line in stdin.split('\\n')[1:]:\n        if line[0] == '+':\n            id = int(line.split()[1])\n            team[id] = 1\n        elif line[0] == '-':\n            id = int(line.split()[1])\n            team[id] = 0\n    leaders = []\n    for i in range(1, n + 1):\n        if team[i] == 1:\n            leaders.append(i)\n    leaders.sort()\n    return str(len(leaders)) + '\\n' +''.join(map(str, leaders))"
    },
    {
        "number": 3847,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n    x = int(stdin.split()[3])\n\n    c = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            c[i][j] = a[i] * b[j]\n\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    if sum(c[i:k+1][j:l+1]) <= x:\n                        area = (k - i + 1) * (l - j + 1)\n                        if area > max_area:\n                            max_area = area\n\n    return str(max_area)"
    },
    {
        "number": 3848,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_tolerable(s: str) -> bool:\n        for i in range(p):\n            if s[i] not in 'abcdefghijklmnopqrstuvwxyz':\n                return False\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return False\n        return True\n\n    def lexicographically_next_tolerable(s: str) -> str:\n        for i in range(len(s)):\n            if s[i] == 'z':\n                return s[:i] + chr(ord('a') + 1) + s[i + 1:]\n        return s + 'a'\n\n    def find_next_tolerable(s: str) -> str:\n        if is_tolerable(s):\n            return s\n        for i in range(len(s)):\n            if s[i] == 'z':\n                return s[:i] + chr(ord('a') + 1) + s[i + 1:]\n        return s + 'a'\n\n    if is_tolerable(s):\n        return s\n    else:\n        return 'NO'"
    },
    {
        "number": 3849,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    cards.sort()\n    if sum(cards) > 10**9:\n        return \"once again\"\n    if cards[0] == 0:\n        return \"tokitsukaze\"\n    if cards[-1] == 0:\n        return \"quailty\"\n    for i in range(1, n - k + 1):\n        if cards[i] == cards[i + k - 1]:\n            return \"once again\"\n    return \"tokitsukaze\""
    },
    {
        "number": 3850,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    time = 0\n    for i in range(n):\n        if a[i] <= p <= a[i + 1]:\n            time += a[i] - p\n            break\n\n    for j in range(k):\n        if b[j] <= p <= b[j + 1]:\n            time += b[j] - p\n            break\n\n    return str(time)"
    },
    {
        "number": 3851,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n\n    def distance(city: int) -> int:\n        if city % (n * k) == 0:\n            return k\n        else:\n            return k + 1\n\n    def min_stops(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_reverse_fast_food(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_reverse_fast_food_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def max_stops_reverse_reverse_reverse_reverse(city: int) -> int:\n        return (city - 1) // (n * k) + 1\n\n    def min_stops_reverse_reverse_reverse_reverse_"
    },
    {
        "number": 3852,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    m = 0\n    for i in range(1, N):\n        if a[i] > a[i - 1]:\n            m += 1\n            a[i] += a[i - 1]\n            a[i - 1] = 0\n\n    print(m)\n    for i in range(m):\n        x = random.randint(1, N)\n        y = random.randint(1, N)\n        print(x, y)\n\n    return \"\"\n"
    },
    {
        "number": 3853,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    boxes = []\n    for _ in range(n):\n        k, a = map(int, stdin.split()[1:])\n        boxes.append((k, a))\n    boxes.sort(key=lambda x: x[0])\n    for i in range(len(boxes)):\n        for j in range(i + 1, len(boxes)):\n            if boxes[i][0] + boxes[j][0] < 2 ** (boxes[i][0] + 1):\n                return str(boxes[i][0] + 1)\n    return str(2 ** (boxes[-1][0] + 1))"
    },
    {
        "number": 3854,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    coins = list(map(int, stdin.split()))\n\n    def is_subset_sum(arr, target):\n        for i in range(len(arr)):\n            if target - arr[i] >= 0:\n                return is_subset_sum(arr[:i] + arr[i+1:], target)\n        return target == 0\n\n    def find_values(coins, target):\n        values = []\n        for coin in coins:\n            if is_subset_sum(coins, target - coin):\n                values.append(coin)\n        return values\n\n    values = find_values(coins, k)\n    return str(len(values)) + '\\n' +''.join(map(str, values))"
    },
    {
        "number": 3855,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1] * n\n    coins[0] = 0\n    coins[1] = 0\n    coins[2] = 0\n    coins[3] = 0\n    coins[4] = 0\n    coins[5] = 0\n    coins[6] = 0\n    coins[7] = 0\n    coins[8] = 0\n    coins[9] = 0\n    coins[10] = 0\n    coins[11] = 0\n    coins[12] = 0\n    coins[13] = 0\n    coins[14] = 0\n    coins[15] = 0\n    coins[16] = 0\n    coins[17] = 0\n    coins[18] = 0\n    coins[19] = 0\n    coins[20] = 0\n    coins[21] = 0\n    coins[22] = 0\n    coins[23] = 0\n    coins[24] = 0\n    coins[25] = 0\n    coins[26] = 0\n    coins[27] = 0\n    coins[28] = 0\n    coins[29] = 0\n    coins[30] = 0\n    coins[31] = 0\n    coins[32] = 0\n    coins[33] = 0\n    coins[34] = 0\n    coins[35] = 0\n    coins[36] = 0\n    coins[37] = 0\n    coins[38] = 0\n    coins[39] = 0\n    coins[40] = 0\n    coins[41] = 0\n    coins[42] = 0\n    coins[43] = 0\n    coins[44] = 0\n    coins[45] = 0\n    coins[46] = 0\n    coins[47] = 0\n    coins[48] = 0\n    coins[49] = 0\n    coins[50] = 0\n    coins[51] = 0\n    coins[52] = 0\n    coins[53] = 0\n    coins[54] = 0\n    coins[55] = 0\n    coins[56] = 0\n    coins[57] = 0\n    coins[58] = 0\n    coins[59] = 0\n    coins[60] = 0\n    coins[61] = 0\n    coins[62] = 0\n    coins[63] = 0\n    coins[64] = 0\n    coins[65] = 0\n    coins[66] = 0\n    coins[67] = 0\n    coins[68] = 0\n    coins[69] = 0\n    coins[70] = 0\n    coins[71] = 0\n    coins[72] = 0\n    coins[73] = 0\n    coins[74] = 0\n    coins[75] = 0\n    coins[76] = 0\n    coins[77] = 0\n    coins[78] = 0\n    coins[79] = 0\n    coins[80] = 0\n    coins[81] = 0\n    coins[82] = 0\n    coins[83] = 0\n    coins[84] = 0\n    coins[85] = 0\n    coins[86] = 0\n    coins[87] = 0\n    coins[88] = 0\n    coins[89] = 0\n    coins[90] = 0\n    coins[91] = 0\n    coins[92] = 0\n    coins[93] = 0\n    coins[94] = 0\n    coins[95] = 0\n    coins[96] = 0\n    coins[97] = 0\n    coins[98] = 0\n    coins[99] = 0\n    coins[100] = 0\n    coins[101] = 0\n    coins[102] = 0\n    coins[103] = 0\n    coins[104] = 0\n    coins[105] = 0\n    coins[106] = 0\n    coins[107] = 0\n    coins[108] = 0\n    coins[109] = 0\n    coins[110] = 0\n    coins[111] = "
    },
    {
        "number": 3856,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *rectangles = map(int, stdin.split())\n    rectangles.sort(key=lambda x: (-x[1], x[0]))\n    total_width = sum(x[0] for x in rectangles)\n    max_height = max(x[1] for x in rectangles)\n    min_area = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            min_area += rectangles[i][0] * rectangles[i][1]\n        else:\n            min_area += rectangles[i][0] * rectangles[i][1]\n            min_area += rectangles[i][0] * max_height\n\n    return str(min_area)"
    },
    {
        "number": 3857,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *x = map(int, stdin.split())\n    piles = []\n    for i in range(n):\n        pile = []\n        for j in range(i+1):\n            pile.append(x[j])\n            if len(pile) > x[i]:\n                break\n        piles.append(pile)\n    return str(len(piles))"
    },
    {
        "number": 3858,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n\n    def convex_hull(points):\n        hull = []\n        for p in points:\n            hull.append(p)\n            while len(hull) > 1 and cross(hull[-2], hull[-1], hull[-3]) <= 0:\n                hull.pop()\n        return hull\n\n    def cross(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p2[1]) - (p2[1] - p1[1]) * (p3[0] - p2[0])\n\n    def is_convex(points):\n        hull = convex_hull(points)\n        return len(hull) > 2 and all(cross(hull[i], hull[i + 1], hull[0]) > 0 for i in range(len(hull) - 1))\n\n    def score(points):\n        n_inside = len(points)\n        return 2 ** (n_inside - len(points))\n\n    convex_polygons = [set(points[i:j + 1]) for i in range(n) for j in range(i + 1, n) if is_convex(points[i:j + 1])]\n    convex_polygon_scores = [score(points) for points in convex_polygons]\n    return str((sum(convex_polygon_scores) % 998244353))\n"
    },
    {
        "number": 3859,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    balls = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    balls.sort(key=lambda x: x[0])\n\n    def swap(a: int, b: int) -> None:\n        nonlocal balls\n        a_i, c_i = balls[a - 1]\n        a_j, c_j = balls[b - 1]\n        balls[a - 1] = (a_j, c_j)\n        balls[b - 1] = (a_i, c_i)\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if balls[i - 1][0] < balls[j - 1][0]:\n                swap(i, j)\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3860,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, g, n = map(int, stdin.split())\n    decks = []\n    for i in range(n+1):\n        decks.append(i*b + n - i*g)\n    decks.sort()\n    return str(decks[0])"
    },
    {
        "number": 3861,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if a[i] ** 2!= a[i]:\n            return str(a[i])\n\n    return \"None\""
    },
    {
        "number": 3862,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    total_volume = sum(a)\n    min_liters = float('inf')\n    for i in range(k):\n        for j in range(i + 1, k):\n            if a[i] + a[j] > n:\n                break\n            volume = (a[i] + a[j]) / (1000 * (i + 1))\n            if volume < min_liters:\n                min_liters = volume\n    if min_liters == float('inf'):\n        return -1\n    return int(min_liters)"
    },
    {
        "number": 3863,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    a = [1] * N\n    a[0] = 1\n    a[1] = 2\n    count = 1\n    for i in range(2, N):\n        if a[i] == a[i - 1]:\n            a[i] = a[i - 1] + 1\n        else:\n            a[i] = 1\n        count = (count + a[i]) % MOD\n    return str(count)"
    },
    {
        "number": 3864,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    board = ['w' * n for _ in range(n)]\n    black_stones = 0\n    white_stones = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                white_stones += 1\n            else:\n                black_stones += 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if board[i][j] == 'w':\n                board[i][j] = 'b'\n            else:\n                board[i][j] = 'w'\n\n    for i in range(n):\n        for"
    },
    {
        "number": 3865,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a < 2 or a > 10**3:\n        return -1\n\n    n = 1\n    while True:\n        if sum(int(digit) for digit in str(n * a)) < a:\n            break\n        n += 1\n\n    if n > 500000:\n        return -1\n\n    return str(n)"
    },
    {
        "number": 3866,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 1:\n        return \"1 0 0\"\n\n    a = [i for i in range(n)]\n    b = [i for i in range(n)]\n    c = [i for i in range(n)]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b[i], c[i]\n\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        c[i], b[i] = b"
    },
    {
        "number": 3867,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, stdin.split()[1:])) for _ in range(n - 1)]\n    sequence = list(map(int, stdin.split()[n:]))\n\n    def bfs(start: int) -> bool:\n        queue = collections.deque([start])\n        used = set()\n        used.add(start)\n\n        while queue:\n            v = queue.popleft()\n            print(v, end=\" \")\n            used.add(v)\n\n            for u in range(1, n + 1):\n                if u not in used and u in graph[v]:\n                    queue.append(u)\n\n        return len(used) == n\n\n    graph = {i: set() for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    for i in range(1, n):\n        if sequence[i - 1] == sequence[i]:\n            return \"No\"\n\n    return \"Yes\" if bfs(1) else \"No\"\n"
    },
    {
        "number": 3868,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    flights = []\n    for _ in range(m):\n        d, f, t, c = map(int, stdin.split())\n        flights.append((d, f, t, c))\n\n    flights.sort(key=lambda x: (x[0], x[1], x[2]))\n\n    total_cost = 0\n    departure_city = 0\n    arrival_city = 0\n    departure_day = 0\n    arrival_day = 0\n\n    for d, f, t, c in flights:\n        if f == 0:\n            departure_city = f\n            departure_day = d\n        elif t == 0:\n            arrival_city = t\n            arrival_day = d\n\n        if departure_city == 0 and arrival_city == 0:\n            total_cost += c\n\n        if departure_city == 0 and arrival_city == 1:\n            total_cost += c\n            departure_city = t\n            departure_day = d\n\n        if departure_city == 1 and arrival_city == 0:\n            total_cost += c\n            arrival_city = f\n            arrival_day = d\n\n        if departure_city == 1 and arrival_city == 1:\n            total_cost += c\n            departure_city = t\n            departure_day = d\n\n    if departure_city == 0 and arrival_city == 0:\n        return str(total_cost)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3869,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, \u03b1 = map(int, stdin.split())\n    \u03b1 = \u03b1 * (math.pi / 180)\n    x1 = 0\n    y1 = 0\n    x2 = w\n    y2 = h\n    x3 = w / 2\n    y3 = h / 2\n    x4 = x3 * math.cos(\u03b1) - y3 * math.sin(\u03b1)\n    y4 = x3 * math.sin(\u03b1) + y3 * math.cos(\u03b1)\n    area1 = abs(x1 * y2 - x2 * y1) / 2\n    area2 = abs(x2 * y3 - x3 * y2) / 2\n    area3 = abs(x3 * y4 - x4 * y3) / 2\n    area4 = abs(x4 * y1 - x1 * y4) / 2\n    return str(area1 + area2 + area3 + area4)"
    },
    {
        "number": 3870,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    jiro_cards = []\n    ciel_cards = []\n\n    for _ in range(n):\n        position, strength = stdin.split()\n        jiro_cards.append((position, int(strength)))\n\n    for _ in range(m):\n        strength = int(stdin.strip())\n        ciel_cards.append(strength)\n\n    jiro_alive_cards = [card for card in jiro_cards if card[1] > 0]\n    ciel_alive_cards = [card for card in ciel_cards if card > 0]\n\n    max_damage = 0\n\n    for i in range(len(jiro_alive_cards)):\n        jiro_card = jiro_alive_cards[i]\n        for j in range(len(ciel_alive_cards)):\n            ciel_card = ciel_alive_cards[j]\n\n            if jiro_card[0] == \"ATK\" and ciel_card > jiro_card[1]:\n                damage = ciel_card - jiro_card[1]\n                max_damage = max(max_damage, damage)\n                ciel_alive_cards.pop(j)\n                break\n\n            if jiro_card[0] == \"DEF\" and ciel_card < jiro_card[1]:\n                damage = ciel_card - jiro_card[1]\n                max_damage = max(max_damage, damage)\n                ciel_alive_cards.pop(j)\n                break\n\n    return str(max_damage)"
    },
    {
        "number": 3871,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    l = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def max_profit(l, s, c):\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            for j in range(i):\n                if l[j] < l[i] and dp[j] + s[j] > dp[i]:\n                    dp[i] = dp[j] + s[j]\n        return dp[n]\n\n    return str(max_profit(l, s, c))"
    },
    {
        "number": 3872,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    if a == b:\n        return \"YES\"\n    else:\n        a_1, a_2 = a[:len(a) // 2], a[len(a) // 2:]\n        b_1, b_2 = b[:len(b) // 2], b[len(b) // 2:]\n        if a_1 == b_1 and a_2 == b_2:\n            return \"YES\"\n        elif a_1 == b_2 and a_2 == b_1:\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 3873,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 1:\n        return \"YES\"\n    elif n == 2:\n        return \"NO\"\n    else:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i < j:\n                    return \"NO\"\n        return \"YES\""
    },
    {
        "number": 3874,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    files = stdin.split('\\n')[1:]\n    indices = list(map(int, stdin.split('\\n')[-1].split()))\n\n    def is_match(pattern: str, filename: str) -> bool:\n        if len(pattern)!= len(filename):\n            return False\n\n        for i, (p, f) in enumerate(zip(pattern, filename)):\n            if p == '?':\n                continue\n            if p!= f:\n                return False\n        return True\n\n    for i in indices:\n        files.pop(i - 1)\n\n    for i, file in enumerate(files):\n        if is_match('a?ba?', file):\n            print('Yes')\n            print(file)\n            return\n\n    print('No')\n    return"
    },
    {
        "number": 3875,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    X = [1] * N\n    for i in range(N):\n        X[i] = random.randint(1, A[i])\n\n    P = 1\n    for i in range(N):\n        P *= X[i]\n        P %= 1000000007\n\n    Q = 1\n    for i in range(N):\n        Q *= A[i]\n        Q %= 1000000007\n\n    R = P // Q\n    R %= 1000000007\n\n    return str(R)"
    },
    {
        "number": 3876,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        x, y = map(int, stdin.split()[i + 1].split())\n        edges.append((x, y))\n\n    def dfs(u, visited, pairs):\n        if u in visited:\n            return\n        visited.add(u)\n        pairs.add(u)\n        for v, w in edges:\n            if w == u:\n                continue\n            if w in visited:\n                continue\n            if dfs(w, visited, pairs):\n                return True\n        return False\n\n    pairs = set()\n    visited = set()\n    for i in range(1, n, 2):\n        if dfs(i, visited, pairs):\n            pairs.remove(i)\n    return str(len(pairs))"
    },
    {
        "number": 3877,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    list_ = [0] * n\n    list_[0] = 1\n    count = 0\n    index = 0\n\n    while index < n:\n        if list_[index] == 1:\n            count += 1\n        if list_[index] > 1:\n            list_[index] = 0\n            list_[index + 1] = 1\n            index += 1\n        else:\n            index += 1\n\n    return str(count)"
    },
    {
        "number": 3878,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v in stdin.split()[1:]:\n        u, v = int(u), int(v)\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    visited = set()\n    for node in range(1, n + 1):\n        if node not in visited:\n            dfs(node, visited)\n\n    steps = 0\n    selected = []\n    for node in range(1, n + 1):\n        if node not in visited:\n            steps += 1\n            selected.append(node)\n\n    return str(steps) + \"\\n\" + \" \".join(map(str, selected))"
    },
    {
        "number": 3879,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bids = list(map(int, stdin.split()[1:]))\n\n    def can_make_equal(bids: list) -> bool:\n        bids.sort(reverse=True)\n        for i in range(1, len(bids)):\n            if bids[i]!= bids[i - 1] * 2:\n                return False\n        return True\n\n    if can_make_equal(bids):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 3880,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            current_sum = sum(arr[i:j])\n            max_sum = max(max_sum, current_sum)\n\n    return str(max_sum)"
    },
    {
        "number": 3881,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    operations = [tuple(map(str, stdin.split())) for _ in range(q)]\n\n    def compress(s: str) -> str:\n        if len(s) <= 2:\n            return s\n        if s[0] in \"ab\" and s[1] in \"cd\":\n            return compress(s[2:])\n        if s[0] in \"cd\" and s[1] in \"ef\":\n            return compress(s[2:])\n        if s[0] in \"ef\" and s[1] in \"ab\":\n            return compress(s[2:])\n        return s\n\n    def count_strings(s: str) -> int:\n        if s == \"a\":\n            return 1\n        return count_strings(compress(s))\n\n    return str(count_strings(\"a\"))"
    },
    {
        "number": 3882,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"3\"\n    else:\n        count = 0\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if i!= j:\n                    count += 1\n        return str((count % (10**9 + 7)))"
    },
    {
        "number": 3883,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = 0\n    while True:\n        x += 1\n        if x * x * x + a * x + b == 0:\n            break\n    if x * x * x + a * x + b == 0:\n        return str(x)\n    else:\n        return \"-1\""
    },
    {
        "number": 3884,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    a = [a] * (n - 2) + [0]\n    b = [b] * (n - 2) + [0]\n\n    fuel = m\n    fuel_needed = 0\n    for i in range(n - 2):\n        fuel_needed += a[i] + b[i]\n        fuel -= a[i] + b[i]\n        if fuel < 0:\n            return -1\n\n    return fuel_needed"
    },
    {
        "number": 3885,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    min_cost = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            cost = (i + j) % (n + 1)\n            min_cost = min(min_cost, cost)\n    return str(min_cost)"
    },
    {
        "number": 3886,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.split()[0])\n    queries = []\n    for _ in range(q):\n        n, k = map(int, stdin.split()[1:])\n        queries.append((n, k))\n\n    def process_query(f: str, k: int) -> str:\n        if k > len(f):\n            return '.'\n        return f[k - 1]\n\n    result = []\n    for n, k in queries:\n        f = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\n        for i in range(1, n):\n            f = \"What are you doing while sending \" + process_query(f, i) + \"? Are you busy? Will you send \" + process_query(f, i) + \"?\"\n        result.append(process_query(f, k))\n\n    return ''.join(result)"
    },
    {
        "number": 3887,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def replace_question_mark(question_mark: str, n: int) -> str:\n        if question_mark == \"?\":\n            return str(random.randint(1, n))\n        else:\n            return question_mark\n\n    def is_valid_rebus(rebus: str) -> bool:\n        for i in range(len(rebus) - 1):\n            if rebus[i] == \"+\" and rebus[i + 1] == \"-\":\n                return False\n        return True\n\n    def is_valid_rebus_with_replacement(rebus: str, n: int) -> bool:\n        for i in range(len(rebus) - 1):\n            if rebus[i] == \"+\" and rebus[i + 1] == \"-\":\n                return False\n        return all(1 <= int(replace_question_mark(question_mark, n)) <= n for question_mark in rebus.split(\"=\"))\n\n    rebus = stdin.strip()\n    n = int(rebus.split(\"=\")[1])\n\n    if is_valid_rebus(rebus):\n        return \"Possible\"\n    elif is_valid_rebus_with_replacement(rebus, n):\n        return \"Possible\\n\" + rebus\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3888,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()[1:]))\n        matrix.append(row)\n\n    zeros = 0\n    ones = 0\n    twos = 0\n\n    for row in matrix:\n        for num in row:\n            if num == 0:\n                zeros += 1\n            elif num == 1:\n                ones += 1\n            elif num == 2:\n                twos += 1\n\n    return f\"{zeros} {ones} {twos}\""
    },
    {
        "number": 3889,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    colors = set(s)\n    if len(colors) == 1:\n        return \"Yes\"\n    elif len(colors) == 26:\n        return \"No\"\n    else:\n        for color in colors:\n            if s.count(color) >= 2:\n                return \"Yes\"\n        return \"No\""
    },
    {
        "number": 3890,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"0\"\n\n    def count_ways(house: int) -> int:\n        if house == 1:\n            return 1\n        if house == k + 1:\n            return 0\n        return count_ways(house - 1) + count_ways(house - k)\n\n    ways = count_ways(n)\n    return str((ways % (10**9 + 7)) % (10**9 + 7))"
    },
    {
        "number": 3891,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    table = [list(row) for row in stdin.split()[1:]]\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] = 'W'\n            else:\n                table[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'W':\n                table[i][j] = 'B'\n            else:\n                table[i][j] = 'W'\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                table[i][j] ="
    },
    {
        "number": 3892,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    candies = [[] for _ in range(m + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        candies[a].append(b)\n    candies[0] = [1]\n    candies[n] = [n]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = float('inf')\n            for k in candies[i]:\n                if k == j:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + 1)\n                elif k < j:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + 1)\n    return''.join(map(str, dp[m][1:]))"
    },
    {
        "number": 3893,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    n = int(stdin.split()[2])\n    roads = []\n    for i in range(n):\n        a, b, c = map(int, stdin.split())\n        roads.append((a, b, c))\n\n    def is_valid(x, y):\n        for road in roads:\n            if a * x + b * y + c == 0:\n                return False\n            if a * x + b * y + c == road[0]:\n                return False\n            if a * x + b * y + c == road[1]:\n                return False\n            if a * x + b * y + c == road[2]:\n                return False\n        return True\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        steps = 0\n        while queue:\n            steps += 1\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                if x == x2 and y == y2:\n                    return steps\n                for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 1000001 and 0 <= ny < 1000001 and (nx, ny) not in visited and is_valid(nx, ny):\n                        visited.add((nx, ny))\n                        queue.append((nx, ny))\n        return -1\n\n    return str(bfs(x1, y1))"
    },
    {
        "number": 3894,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def remove_last_cow(piles: list[int]) -> int:\n        return piles.pop()\n\n    def replace_pile(piles: list[int], k: int) -> list[int]:\n        return [piles.pop() for _ in range(k)]\n\n    def is_even_size_2(piles: list[int]) -> bool:\n        return len(piles) % 2 == 0\n\n    def is_empty(piles: list[int]) -> bool:\n        return not piles\n\n    def is_winning_move(piles: list[int]) -> bool:\n        return is_even_size_2(piles) and is_empty(piles)\n\n    def is_losing_move(piles: list[int]) -> bool:\n        return not is_winning_move(piles)\n\n    def is_tie(piles: list[int]) -> bool:\n        return len(piles) == 1\n\n    def is_winning_move_for_player(piles: list[int], player: str) -> bool:\n        if player == \"Kevin\":\n            return is_winning_move(piles)\n        elif player == \"Nicky\":\n            return is_losing_move(piles)\n        else:\n            raise ValueError(\"Invalid player\")\n\n    def is_losing_move_for_player(piles: list[int], player: str) -> bool:\n        if player == \"Kevin\":\n            return is_losing_move(piles)\n        elif player == \"Nicky\":\n            return is_winning_move(piles)\n        else:\n            raise ValueError(\"Invalid player\")\n\n    def is_tie_for_player(piles: list[int], player: str) -> bool:\n        if player == \"Kevin\":\n            return is_tie(piles)\n        elif player == \"Nicky\":\n            return is_tie(piles)\n        else:\n            raise ValueError(\"Invalid player\")\n\n    def get_winning_player(piles: list[int]) -> str:\n        if is_winning_move_for_player(piles, \"Kevin\"):\n            return \"Kevin\"\n        elif is_winning_move_for_player(piles, \"Nicky\"):\n            return \"Nicky\"\n        else:\n            raise ValueError(\"Invalid game state\")\n\n    def get_losing_player(piles: list[int]) -> str:\n        if is_losing_move_for_player(piles, \"Kevin\"):\n            return \"Kevin\"\n        elif is_losing_move_for_player(piles, \"Nicky\"):\n            return \"Nicky\"\n        else:\n            raise ValueError(\"Invalid game state\")\n\n    def get_tie_player(piles: list[int]) -> str:\n        if is_tie_for_player(piles, \"Kevin\"):\n            return \"Kevin\"\n        elif is_tie_for_player(piles, \"Nicky\"):\n            return \"Nicky\"\n        else:\n            raise ValueError(\"Invalid game state\")\n\n    def get_next_player(player: str) -> str:\n        if player == \"Kevin\":\n            return \"Nicky\"\n        elif player == \"Nicky\":\n            return \"Kevin\"\n        else:\n            raise ValueError(\"Invalid player\")\n\n    def get_next_move(piles: list[int], player: str) -> tuple[str, list[int]]:\n        if is_winning_move_for_player(piles, player):\n            return \"remove_last_cow\", []\n        elif is_losing_move_for_player(piles, player):\n            return \"replace_pile\", [2, k]\n        elif is_tie_for_player(piles, player):\n            return \"remove_last_cow\", []\n        else:\n            raise ValueError(\"Invalid game state\")\n\n    def play_game(piles: list[int], player: str) -> tuple[str, list[int]]:\n        next_player = get_next_player(player)\n        next_move, args = get_next_move(piles, player)\n        if next_move == \"remove_last_cow\":\n            piles.pop()\n            return play_game(piles, next_player)\n        elif next_move == \"replace_pile\":\n            piles = replace_pile(piles, args[0])\n            return play_game(piles, next_player)\n        else:\n            raise ValueError(\"Invalid move\")\n\n    piles = a\n   "
    },
    {
        "number": 3895,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    f = list(map(int, stdin.split()[1:]))\n\n    def g(x):\n        return f[x - 1]\n\n    def h(x):\n        return x\n\n    for i in range(1, n + 1):\n        if g(i)!= i:\n            return -1\n\n    for i in range(1, m + 1):\n        if h(i)!= f[i - 1]:\n            return -1\n\n    return str(m) + \" \" + \" \".join(map(str, g(1))) + \"\\n\" + \" \".join(map(str, h(1))) + \"\\n\"\n"
    },
    {
        "number": 3896,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    x = int(stdin, 2)\n    pairs = []\n    for i in range(2**n):\n        for j in range(2**n):\n            if i ^ j == x:\n                pairs.append((i, j))\n    complexity = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            a, b = pairs[i]\n            c, d = pairs[j]\n            if a < c and b > d:\n                complexity += 1\n    return str(complexity % (10**9 + 7))"
    },
    {
        "number": 3897,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = 1\n    for i in range(n):\n        m *= a[i]\n    mod = 1000000007\n    count = 0\n    for i in range(1, m + 1):\n        if m % i == 0:\n            count += 1\n            m //= i\n    return str(count % mod)"
    },
    {
        "number": 3898,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = list(map(int, stdin.split()[1:]))\n\n    def dfs(i, j, visited):\n        if i == n:\n            return True\n\n        if visited[i]:\n            return False\n\n        visited[i] = True\n\n        if a[i] == 0 and b[i] == 0:\n            return dfs(i + 1, j, visited)\n\n        if a[i] == 0:\n            return dfs(i + 1, j, visited)\n\n        if b[i] == 0:\n            return dfs(i + 1, j, visited)\n\n        if a[i] == b[i]:\n            return dfs(i + 1, j, visited)\n\n        if a[i] == j:\n            return dfs(i + 1, j, visited)\n\n        if b[i] == j:\n            return dfs(i + 1, j, visited)\n\n        return False\n\n    visited = [False] * n\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, i, visited):\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3899,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a = sorted(a)\n    b = sorted(b)\n    total_power = sum(a)\n    total_processors = sum(b)\n    total_tasks = len(a)\n\n    if total_power > total_processors:\n        return \"0\"\n\n    def compute_power(task_power, task_processors):\n        return task_power * task_processors\n\n    def compute_utilization(task_power, task_processors):\n        return task_power / task_processors\n\n    def compute_total_power(task_power, task_processors):\n        return task_power * task_processors * total_tasks\n\n    def compute_total_utilization(task_power, task_processors):\n        return task_power / task_processors * total_tasks\n\n    def compute_total_utilization_threshold(task_power, task_processors):\n        return compute_total_utilization(task_power, task_processors) * 0.9\n\n    def compute_total_power_threshold(task_power, task_processors):\n        return compute_total_power(task_power, task_processors) * 0.9\n\n    def compute_utilization_threshold(task_power, task_processors):\n        return compute_utilization(task_power, task_processors) * 0.9\n\n    def compute_utilization_threshold_for_task(task_power, task_processors, task_index):\n        return compute_utilization_threshold(task_power, task_processors) * (1 - b[task_index])\n\n    def compute_power_threshold_for_task(task_power, task_processors, task_index):\n        return compute_power(task_power, task_processors) * (1 - b[task_index])\n\n    def compute_total_utilization_threshold_for_task(task_power, task_processors, task_index):\n        return compute_total_utilization_threshold(task_power, task_processors) * (1 - b[task_index])\n\n    def compute_total_power_threshold_for_task(task_power, task_processors, task_index):\n        return compute_total_power_threshold(task_power, task_processors) * (1 - b[task_index])\n\n    def compute_utilization_threshold_for_total(task_power, task_processors):\n        return compute_utilization_threshold(task_power, task_processors) * (1 - total_processors)\n\n    def compute_power_threshold_for_total(task_power, task_processors):\n        return compute_power(task_power, task_processors) * (1 - total_processors)\n\n    def compute_total_utilization_threshold_for_total(task_power, task_processors):\n        return compute_total_utilization_threshold(task_power, task_processors) * (1 - total_processors)\n\n    def compute_total_power_threshold_for_total(task_power, task_processors):\n        return compute_total_power_threshold(task_power, task_processors) * (1 - total_processors)\n\n    def compute_utilization_threshold_for_total_task(task_power, task_processors, task_index):\n        return compute_utilization_threshold_for_task(task_power, task_processors, task_index) * (1 - total_processors)\n\n    def compute_power_threshold_for_total_task(task_power, task_processors, task_index):\n        return compute_power_threshold_for_task(task_power, task_processors, task_index) * (1 - total_processors)\n\n    def compute_total_utilization_threshold_for_total_task(task_power, task_processors, task_index):\n        return compute_total_utilization_threshold_for_task(task_power, task_processors, task_index) * (1 - total_processors)\n\n    def compute_total_power_threshold_for_total_task(task_power, task_processors, task_index):\n        return compute_total_power_threshold_for_task(task_power, task_processors, task_index) * (1 - total_processors)\n\n    def compute_utilization_threshold_for_total_task_total(task_power, task_processors):\n        return compute_utilization_threshold_for_total_task(task_power, task_processors, total_tasks) * (1 - total_processors)\n\n    def compute_power_threshold_for_total_task_total(task_power, task_processors):\n        return compute_"
    },
    {
        "number": 3900,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    coders = [[] for _ in range(n + 1)]\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        coders[x].append(y)\n        coders[y].append(x)\n\n    def is_valid(suspects: list) -> bool:\n        for i in range(n):\n            if i in suspects:\n                continue\n            for j in range(i + 1, n):\n                if j in suspects:\n                    continue\n                if i in coders[j] or j in coders[i]:\n                    return True\n        return False\n\n    def count_valid_sets(suspects: list) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if i not in suspects:\n                for j in range(1, n + 1):\n                    if j not in suspects:\n                        if is_valid([i, j]):\n                            count += 1\n        return count\n\n    valid_sets = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if is_valid([i, j]):\n                valid_sets += 1\n\n    return str(valid_sets)"
    },
    {
        "number": 3901,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def make_one(a):\n        for i in range(len(a)):\n            if a[i]!= 1:\n                return False\n        return True\n\n    def make_zero(a):\n        for i in range(len(a)):\n            if a[i]!= 0:\n                return False\n        return True\n\n    def replace_with_gcd(a, x, y):\n        a[x], a[y] = gcd(a[x], a[y]), a[x]\n\n    def make_one_helper(a, index, count):\n        if index == len(a):\n            return count\n\n        if a[index] == 1:\n            return make_one_helper(a, index + 1, count)\n\n        if a[index] == 0:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 2:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 3:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 4:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 5:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 6:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 7:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 8:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 9:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 10:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 11:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 12:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 13:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 14:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 15:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 16:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 17:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 18:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 19:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 20:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 21:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 22:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 23:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 24:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 25:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 26:\n            return make_one_helper(a, index + 1, count + 1)\n\n        if a[index] == 27:\n            return make_one_"
    },
    {
        "number": 3902,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    suffixes = set()\n    for i in range(n - 2):\n        if s[i] == s[i + 1] and s[i] == s[i + 2]:\n            continue\n        suffixes.add(s[i:])\n    return str(len(suffixes)) + '\\n' + '\\n'.join(sorted(suffixes))"
    },
    {
        "number": 3903,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    map_ = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(x, y):\n        return 1 <= x < n and 1 <= y < m and map_[x - 1][y - 1] == '.'\n\n    def is_passable(x, y):\n        return is_valid(x, y) and map_[x - 1][y - 1] == '.'\n\n    def get_neighbors(x, y):\n        return [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n\n    def get_neighbors_passable(x, y):\n        return [neighbor for neighbor in get_neighbors(x, y) if is_passable(*neighbor)]\n\n    def get_neighbors_passable_count(x, y):\n        return len(get_neighbors_passable(x, y))\n\n    def get_neighbors_passable_count_min(x, y):\n        return min(get_neighbors_passable_count(x, y))\n\n    def get_neighbors_passable_count_max(x, y):\n        return max(get_neighbors_passable_count(x, y))\n\n    def get_neighbors_passable_count_sum(x, y):\n        return sum(get_neighbors_passable_count(x, y))\n\n    def get_neighbors_passable_count_avg(x, y):\n        return get_neighbors_passable_count_sum(x, y) / get_neighbors_passable_count_min(x, y)\n\n    def get_neighbors_passable_count_median(x, y):\n        return sorted(get_neighbors_passable_count(x, y))[len(get_neighbors_passable_count(x, y)) // 2]\n\n    def get_neighbors_passable_count_mode(x, y):\n        return max(set(get_neighbors_passable_count(x, y)), key=get_neighbors_passable_count.count)\n\n    def get_neighbors_passable_count_variance(x, y):\n        return sum((get_neighbors_passable_count(x, y) - get_neighbors_passable_count_avg(x, y)) ** 2) / get_neighbors_passable_count_min(x, y)\n\n    def get_neighbors_passable_count_std_dev(x, y):\n        return get_neighbors_passable_count_variance(x, y) ** 0.5\n\n    def get_neighbors_passable_count_kurtosis(x, y):\n        return sum((get_neighbors_passable_count(x, y) - get_neighbors_passable_count_avg(x, y)) ** 4) / get_neighbors_passable_count_variance(x, y) ** 2\n\n    def get_neighbors_passable_count_skewness(x, y):\n        return get_neighbors_passable_count_avg(x, y) / get_neighbors_passable_count_std_dev(x, y)\n\n    def get_neighbors_passable_count_entropy(x, y):\n        return sum(-get_neighbors_passable_count(x, y) * (math.log(get_neighbors_passable_count(x, y), 2) if get_neighbors_passable_count(x, y) > 0 else 0) for x in range(get_neighbors_passable_count_min(x, y), get_neighbors_passable_count_max(x, y) + 1))\n\n    def get_neighbors_passable_count_entropy_min(x, y):\n        return min(get_neighbors_passable_count_entropy(x, y))\n\n    def get_neighbors_passable_count_entropy_max(x, y):\n        return max(get_neighbors_passable_count_entropy(x, y))\n\n    def get_neighbors_passable_count_entropy_sum(x, y):\n        return sum(get_neighbors_passable_count_entropy(x, y) for x in range(get_neighbors_passable_count_min(x, y), get_neighbors_passable_count_max(x, y) + 1))\n\n    def get_neighbors_passable_count_entropy_avg(x, y):\n        return get_neighbors_passable_count_entropy_sum(x, y) / (get_neighbors_passable"
    },
    {
        "number": 3904,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s = s.replace(\"()\", \"+1\")\n    s ="
    },
    {
        "number": 3905,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split())\n    u = list(map(int, stdin.split()))\n    clients = []\n    for _ in range(m):\n        clients.append(list(map(int, stdin.split())))\n\n    def is_accessible(client: list, data_center: int) -> bool:\n        return u[client[0] - 1]!= u[data_center - 1]\n\n    def shift_maintenance_time(data_center: int) -> int:\n        return (u[data_center - 1] + 1) % h\n\n    min_k = n\n    min_x = []\n\n    for i in range(n):\n        if is_accessible(clients[i], i + 1):\n            min_k = min(min_k, i + 1)\n            min_x.append(i + 1)\n\n    if min_k == n:\n        return \"Impossible\"\n\n    min_x = list(set(min_x))\n    min_x.sort()\n\n    return str(min_k) + \" \" + \" \".join(map(str, min_x))\n"
    },
    {
        "number": 3906,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [[0] * m for _ in range(n)]\n    count = 0\n    for _ in range(1000000):\n        for i in range(n):\n            for j in range(m):\n                if field[i][j] == 0:\n                    count += 1\n                    field[i][j] = 1\n                    break\n                elif field[i][j] == field[i][(j + 1) % m]:\n                    count += 1\n                    field[i][j] = 1\n                    break\n                elif field[i][j] == field[(i + 1) % n][j]:\n                    count += 1\n                    field[i][j] = 1\n                    break\n                elif field[i][j] == field[(i + 1) % n][(j + 1) % m]:\n                    count += 1\n                    field[i][j] = 1\n                    break\n                else:\n                    field[i][j] = 0\n    return str((count % (10**9 + 7)))"
    },
    {
        "number": 3907,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    coupons = [list(map(int, stdin.split())) for _ in range(m)]\n    a = [0] * n\n    max_sum = 0\n\n    for coupon in coupons:\n        q, w = coupon\n        for i in range(n):\n            if a[i] == 0:\n                a[i] = q\n                max_sum += w\n                break\n            elif a[i] == q:\n                a[i] += 1\n                max_sum += w\n                break\n            elif a[i] == q + 1:\n                a[i] = q\n                max_sum += w\n                break\n            elif a[i] == q - 1:\n                a[i] = q + 1\n                max_sum += w\n                break\n\n    return str(max_sum)"
    },
    {
        "number": 3908,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    hidden_strings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            hidden_strings.add(s[i:j])\n    return str(len(hidden_strings))"
    },
    {
        "number": 3909,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 377789319, 1162261467, 3307474961, 1048576, 295147905179, 942408170189, 2652528598121, 8465752633861, 23859154401373, 76296004088329, 2147483647, 69077259306881, 194444922738957, 590295810358721, 1759218604441601, 5033164807174401, 15845632595328001, 4294967296, 14210854715200001, 36028797018963969, 127441935348226049, 309485009821345061, 1140413042737705729, 262144, 1024, 2251799813685248, 9223372036854775808]\n    min_coins = [0] * (n + 1)\n    min_coins[0] = 0\n    for coin in coins:\n        for i in range(1, n + 1):\n            if i >= coin:\n                min_coins[i] = max(min_coins[i], min_coins[i - coin] + 1)\n    return str(min_coins[n])"
    },
    {
        "number": 3910,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(n):\n        pair = list(map(int, stdin.split()[1:]))\n        pairs.append(pair)\n    pairs.sort(key=lambda x: (x[0], x[1]))\n\n    for i in range(n):\n        if i == 0 or pairs[i][0]!= pairs[i - 1][0] + 1:\n            print(1, 2)\n            break\n        if i == n - 1 or pairs[i][1]!= pairs[i + 1][1] - 1:\n            print(2, 1)\n            break\n\n    else:\n        print(-1)"
    },
    {
        "number": 3911,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    row = [1] * n\n    for i in range(1, n):\n        row.append(row[i - 1] + 1)\n    return \" \".join(map(str, row))"
    },
    {
        "number": 3912,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    # Remove non-alphabetic characters and convert to lowercase\n    s = ''.join(filter(str.isalpha, s)).lower()\n\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    # Sort the characters by their count in descending order\n    sorted_chars = sorted(char_count.items(), key=lambda x: (-x[1], x[0]))\n\n    # Initialize the result list\n    result = []\n\n    # Iterate through the sorted characters\n    for char, count in sorted_chars:\n        # If the count is odd, add the character to the result\n        if count % 2!= 0:\n            result.append(char)\n\n        # If the count is even, add the character to the result and the reverse of the character\n        else:\n            result.append(char)\n            result.append(char[::-1])\n\n    # Join the result list into a string and return\n    return''.join(result)"
    },
    {
        "number": 3913,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, revealed_letters, m = map(int, stdin.split())\n    revealed_letters = list(revealed_letters)\n    words = stdin.split('\\n')[3:]\n\n    def is_valid_word(word: str) -> bool:\n        return word in words\n\n    def is_valid_revealed_letters(word: str) -> bool:\n        return all(letter in word for letter in revealed_letters)\n\n    def find_valid_word(words: List[str]) -> str:\n        for word in words:\n            if is_valid_word(word) and is_valid_revealed_letters(word):\n                return word\n        return \"\"\n\n    valid_word = find_valid_word(words)\n    if valid_word:\n        revealed_letters.extend(valid_word)\n        revealed_letters = list(set(revealed_letters))\n        revealed_letters.sort()\n        return str(len(revealed_letters))\n    else:\n        return \"0\"\n"
    },
    {
        "number": 3914,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    x1 = 0\n    x2 = 0\n\n    for i in range(1, n):\n        if a[i]!= b:\n            x1 += 1\n\n    for i in range(n - 1, 0, -1):\n        if a[i]!= b:\n            x2 += 1\n\n    return str(min(x1, x2))"
    },
    {
        "number": 3915,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    A = p / q\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_primes(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            if is_prime(i):\n                count += 1\n        return count\n\n    def count_palindromic(n: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if str(i) == str(i)[::-1]:\n                count += 1\n        return count\n\n    max_n = 0\n    max_primes = 0\n    max_palindromic = 0\n\n    for n in range(1, 43):\n        primes = count_primes(n)\n        palindromic = count_palindromic(n)\n\n        if primes <= A * palindromic:\n            max_n = n\n            max_primes = primes\n            max_palindromic = palindromic\n\n    if max_primes <= A * max_palindromic:\n        return str(max_n)\n    else:\n        return \"Palindromic tree is better than splay tree\"\n"
    },
    {
        "number": 3916,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *k = map(int, stdin.split())\n    k = [k[i] for i in range(n)]\n    k.sort()\n    k.append(1)\n    k.append(2)\n    k.append(3)\n    k.append(4)\n    k.append(5)\n    k.append(6)\n    k.append(7)\n    k.append(8)\n    k.append(9)\n    k.append(10)\n    k.append(11)\n    k.append(12)\n    k.append(13)\n    k.append(14)\n    k.append(15)\n    k.append(16)\n    k.append(17)\n    k.append(18)\n    k.append(19)\n    k.append(20)\n    k.append(21)\n    k.append(22)\n    k.append(23)\n    k.append(24)\n    k.append(25)\n    k.append(26)\n    k.append(27)\n    k.append(28)\n    k.append(29)\n    k.append(30)\n    k.append(31)\n    k.append(32)\n    k.append(33)\n    k.append(34)\n    k.append(35)\n    k.append(36)\n    k.append(37)\n    k.append(38)\n    k.append(39)\n    k.append(40)\n    k.append(41)\n    k.append(42)\n    k.append(43)\n    k.append(44)\n    k.append(45)\n    k.append(46)\n    k.append(47)\n    k.append(48)\n    k.append(49)\n    k.append(50)\n    k.append(51)\n    k.append(52)\n    k.append(53)\n    k.append(54)\n    k.append(55)\n    k.append(56)\n    k.append(57)\n    k.append(58)\n    k.append(59)\n    k.append(60)\n    k.append(61)\n    k.append(62)\n    k.append(63)\n    k.append(64)\n    k.append(65)\n    k.append(66)\n    k.append(67)\n    k.append(68)\n    k.append(69)\n    k.append(70)\n    k.append(71)\n    k.append(72)\n    k.append(73)\n    k.append(74)\n    k.append(75)\n    k.append(76)\n    k.append(77)\n    k.append(78)\n    k.append(79)\n    k.append(80)\n    k.append(81)\n    k.append(82)\n    k.append(83)\n    k.append(84)\n    k.append(85)\n    k.append(86)\n    k.append(87)\n    k.append(88)\n    k.append(89)\n    k.append(90)\n    k.append(91)\n    k.append(92)\n    k.append(93)\n    k.append(94)\n    k.append(95)\n    k.append(96)\n    k.append(97)\n    k.append(98)\n    k.append(99)\n    k.append(100)\n    k.append(101)\n    k.append(102)\n    k.append(103)\n    k.append(104)\n    k.append(105)\n    k.append(106)\n    k.append(107)\n    k.append(108)\n    k.append(109)\n    k.append(110)\n    k.append(111)\n    k.append(112)\n    k.append(113)\n    k.append(114)\n    k.append(115)\n    k.append(116)\n    k.append(117)\n    k.append(118)\n    k.append(119)\n    k.append(120)\n    k.append(121)\n    k.append(122)"
    },
    {
        "number": 3917,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def g(i, j):\n        sum = 0\n        for k in range(min(i, j) + 1, max(i, j) + 1):\n            sum += a[k]\n        return sum\n\n    min_i = None\n    for i in range(1, n + 1):\n        if i!= min_i:\n            if g(i, min_i) < g(i, i):\n                min_i = i\n                break\n\n    return str(min_i)"
    },
    {
        "number": 3918,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k_1, k_2 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def min_error(a, b, k_1, k_2):\n        error = 0\n        for i in range(k_1):\n            error += (a[i] - b[i]) ** 2\n            a[i] += 1\n        for i in range(k_2):\n            error += (a[i] - b[i]) ** 2\n            b[i] -= 1\n        return error\n\n    return str(min_error(a, b, k_1, k_2))"
    },
    {
        "number": 3919,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    S = list(stdin.split()[1])\n    l_list = list(map(int, stdin.split()[2:]))\n    r_list = list(map(int, stdin.split()[2:]))\n\n    def permute(s: list, l: int, r: int) -> list:\n        if l == r:\n            return [s[l]]\n        result = []\n        for i in range(l, r):\n            for p in permute(s, l, i):\n                result.append(s[i] + p)\n        return result\n\n    def count_values(s: list, l: int, r: int) -> int:\n        if l == r:\n            return 1\n        result = 0\n        for i in range(l, r):\n            result += count_values(s, l, i)\n        return result\n\n    def count_values_after_operations(s: list, l_list: list, r_list: list, m: int) -> int:\n        result = 0\n        for i in range(m):\n            l, r = l_list[i], r_list[i]\n            s_perm = permute(s, l - 1, r)\n            result += count_values(s_perm, 0, len(s_perm) - 1)\n        return result\n\n    return str(count_values_after_operations(S, l_list, r_list, M))"
    },
    {
        "number": 3920,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, a_4, a_5, a_6 = map(int, stdin.split())\n    hexagon_sides = [a_1, a_2, a_3, a_4, a_5, a_6]\n    hexagon_angles = [120, 60, 30, 60, 30, 60]\n    hexagon_angles.sort()\n    hexagon_angles.append(hexagon_angles[-1] + 60)\n    hexagon_angles.sort()\n    triangles = 0\n    for i in range(len(hexagon_angles) - 1):\n        angle = hexagon_angles[i]\n        if angle < 60:\n            continue\n        for j in range(i + 1, len(hexagon_angles)):\n            if hexagon_angles[j] - angle > 60:\n                break\n            if hexagon_angles[j] - angle < 60:\n                triangles += 1\n    return str(triangles)"
    },
    {
        "number": 3921,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    k = 0\n    for i in range(1, n):\n        if a[i] - a[i - 1] == 1 and gcd(a[i], a[i + 1]) > 1:\n            k = max(k, i + 1)\n    return str(k)\n\ndef"
    },
    {
        "number": 3922,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        k = int(stdin.split('\\n')[1].split()[0])\n        row1 = list(map(int, stdin.split('\\n')[2].split()))\n        row2 = list(map(int, stdin.split('\\n')[3].split()))\n        row1.extend([0] * (2 * k + 1 - len(row1)))\n        row2.extend([0] * (2 * k + 1 - len(row2)))\n        grid = [row1, row2]\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 1\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 2\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 3\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 4\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 5\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 6\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 7\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 8\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 9\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 10\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 11\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 12\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 13\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 14\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == 0:\n                    grid[i][j] = 15\n                    break\n            else:\n                return 'SURGERY COMPLETE'\n        for i in range(2):\n            for j in range(2 * k + 1):\n                if grid[i][j] == "
    },
    {
        "number": 3923,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a == b:\n        return str(a) * n\n    g = [0] * (n + 1)\n    for i in range(1, n + 1):\n        g[i] = min(g[j] + 1 for j in range(1, i + 1))\n    for i in range(1, n + 1):\n        if g[i] == a:\n            return str(i) * n\n    for i in range(1, n + 1):\n        if g[i] == b:\n            return str(i) * n\n    return -1"
    },
    {
        "number": 3924,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_bags(a: int, k: int) -> int:\n        if a == 0:\n            return 0\n        if a <= k:\n            return 1 + count_bags(a - 1, k)\n        else:\n            return count_bags(a - k, k)\n\n    bags = count_bags(sum(a), k)\n    return str(bags)\n"
    },
    {
        "number": 3925,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    max_length = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i] == s[j]:\n                max_length = max(max_length, j - i)\n    return str(max_length)"
    },
    {
        "number": 3926,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    r, c = map(int, stdin.split()[1].split())\n    x, y = map(int, stdin.split()[2].split())\n\n    labyrinth = []\n    for line in stdin.split()[3:3+n]:\n        labyrinth.append(list(line))\n\n    def is_valid(r: int, c: int) -> bool:\n        return 0 <= r < n and 0 <= c < m\n\n    def is_obstacle(r: int, c: int) -> bool:\n        return labyrinth[r][c] == '*'\n\n    def is_reachable(r: int, c: int, steps: int) -> bool:\n        if steps == 0:\n            return True\n        if not is_valid(r, c):\n            return False\n        if is_obstacle(r, c):\n            return False\n        return is_reachable(r, c-1, steps-1) or is_reachable(r, c+1, steps-1) or is_reachable(r-1, c, steps-1) or is_reachable(r+1, c, steps-1)\n\n    reachable_cells = 0\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j) and not is_obstacle(i, j) and is_reachable(i, j, x):\n                reachable_cells += 1\n\n    return str(reachable_cells)"
    },
    {
        "number": 3927,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(set(a))\n    m = sum(a)\n    k = 0\n    while k < n:\n        if sum(a[:k+1]) == m:\n            return str(k+1)\n        k += 1\n    return \"impossible\""
    },
    {
        "number": 3928,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def encode(s: str) -> str:\n        if len(s) == 1:\n            return s, 0\n        else:\n            for i in range(1, len(s)):\n                if s[i] == s[i - 1]:\n                    return s[:i] + s[i], b\n            return s, a\n\n    def compress(s: str) -> str:\n        result = []\n        for i in range(len(s)):\n            if i == 0 or s[i]!= s[i - 1]:\n                encoded_s, cost = encode(s[i:])\n                result.append(encoded_s)\n                if cost < a:\n                    a -= cost\n        return ''.join(result)\n\n    compressed_s = compress(s)\n    return str(min(a, b) * len(compressed_s))"
    },
    {
        "number": 3929,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = deque()\n    for i in range(1, n + 1):\n        cards.append(i)\n    count = 0\n    for _ in range(k):\n        if cards[0] == 1:\n            cards.popleft()\n            cards.popleft()\n        else:\n            cards.pop()\n            cards.pop()\n        count += 1\n    return str((count % (10**9 + 7)))"
    },
    {
        "number": 3930,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    count = 0\n    for i in range(n - 1):\n        if a[i] + a[i + 1] == k:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3931,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k, f = map(int, stdin.split())\n    trips = stdin.split('\\n')[1:]\n    trips = [trip.split() for trip in trips]\n\n    def min_sum(cards: int) -> int:\n        total_sum = 0\n        for trip in trips:\n            start, finish = trip\n            if cards > 0:\n                total_sum += a + b * (cards - 1)\n                cards -= 1\n            total_sum += f\n            total_sum += a + b * (cards - 1)\n            cards -= 1\n        return total_sum\n\n    return str(min(min_sum(k) for _ in range(1, k + 1)))"
    },
    {
        "number": 3932,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    c = list(map(int, stdin.split()[1:]))\n\n    def dfs(node: int, count: int) -> bool:\n        if count < 2:\n            return False\n\n        for child in range(node * 2, node * 2 + 2):\n            if child >= n:\n                continue\n\n            if dfs(child, count - 1):\n                return True\n\n        return False\n\n    for i in range(n):\n        if dfs(i, c[i]):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3933,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    t = [t[i] for i in range(n)]\n    t.append(sum(t) // n)\n    return str(t[-1])"
    },
    {
        "number": 3934,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:3])\n        edges[u - 1].append(v - 1)\n        edges[v - 1].append(u - 1)\n    visited = [False] * n\n    visited[0] = True\n    def dfs(node):\n        nonlocal visited\n        if visited[node]:\n            return False\n        visited[node] = True\n        for neighbor in edges[node]:\n            if dfs(neighbor):\n                return True\n        visited[node] = False\n        return False\n    for i in range(1, n):\n        if not visited[i]:\n            if dfs(i):\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 3935,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    b = set(b)\n    b.remove(min(b))\n    k = len(b)\n    return f\"{k}\\n{' '.join(str(x) for x in sorted(b))}\""
    },
    {
        "number": 3936,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split())\n    s1 = list(s1)\n    s2 = list(s2)\n\n    def count_ways(i, j, color):\n        if i == n:\n            return 1\n        if s1[i] == s2[j]:\n            return count_ways(i + 1, j + 1, color)\n        if s1[i] == color:\n            return count_ways(i + 1, j, color)\n        if s2[j] == color:\n            return count_ways(i, j + 1, color)\n        return count_ways(i + 1, j, color)\n\n    red_ways = count_ways(0, 0, 'r')\n    cyan_ways = count_ways(0, 0, 'c')\n    green_ways = count_ways(0, 0, 'g')\n\n    return str((red_ways + cyan_ways + green_ways) % 1000000007)"
    },
    {
        "number": 3937,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    gcd = [0] * (n + 1)\n    for i in range(1, n + 1):\n        gcd[i] = gcd[i - 1]\n        for j in range(1, m - k + 1):\n            gcd[i] = max(gcd[i], gcd[j] * gcd[i - j])\n\n    for i in range(1, n + 1):\n        for j in range(1, m - k + 1):\n            if gcd[i] == a[k - 1]:\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3938,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    black_rectangles = []\n    for _ in range(m):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        black_rectangles.append((x1, y1, x2, y2))\n\n    black_cells = set()\n    for x1, y1, x2, y2 in black_rectangles:\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                black_cells.add((i, j))\n\n    white_cells = set()\n    for i in range(n):\n        for j in range(n):\n            white_cells.add((i, j))\n\n    total_cost = 0\n    for black_cell in black_cells:\n        min_cost = min(abs(black_cell[0] - i) + abs(black_cell[1] - j) for i in range(n) for j in range(n) if (i, j)!= black_cell)\n        total_cost += min_cost\n\n    return str(total_cost)"
    },
    {
        "number": 3939,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, k = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:]))\n        a.sort()\n        if a[n // 2] == k:\n            print(\"yes\")\n        else:\n            print(\"no\")"
    },
    {
        "number": 3940,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    subarrays = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        subarrays.append((l, r))\n\n    def find_mex(subarray):\n        return max(subarray) + 1\n\n    def find_min_mex(subarrays):\n        return min(find_mex(subarray) for subarray in subarrays)\n\n    min_mex = find_min_mex(subarrays)\n    a = [0] * n\n    for subarray in subarrays:\n        a[subarray[0] - 1] = find_mex(subarray)\n        a[subarray[1]] = find_mex(subarray)\n\n    return str(min_mex) + '\\n' +''.join(map(str, a))"
    },
    {
        "number": 3941,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    rooms = list(map(int, stdin.split()[2:2+n]))\n    switches = []\n    for i in range(m):\n        x, *y = map(int, stdin.split()[2+n+i].split())\n        switches.append((x, set(y)))\n\n    def is_possible(switches: List[Tuple[int, Set[int]]]) -> bool:\n        def is_valid(switches: List[Tuple[int, Set[int]]]) -> bool:\n            for x, y in switches:\n                if len(y)!= 2:\n                    return False\n                if x not in rooms or y.isdisjoint(rooms):\n                    return False\n            return True\n\n        def is_valid_state(state: List[int]) -> bool:\n            for i in range(n):\n                if state[i] == 0 and rooms[i] == 0:\n                    return False\n            return True\n\n        def is_valid_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 0:\n                    return False\n            return True\n\n        def is_valid_state_after_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and_switch(switches: List[Tuple[int, Set[int]]], state: List[int]) -> bool:\n            for x, y in switches:\n                if x in rooms and y.issubset(rooms) and state[x-1] == 1:\n                    return False\n            return True\n\n        def is_valid_state_after_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and_switch_and"
    },
    {
        "number": 3942,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    stack = []\n    beautiful = True\n    count = 0\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                beautiful = False\n                break\n            stack.pop()\n        elif char == '#':\n            if not stack:\n                beautiful = False\n                break\n            count += 1\n\n    if beautiful:\n        return '\\n'.join(map(str, count))\n    else:\n        return -1"
    },
    {
        "number": 3943,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a + b < 1:\n        return \"0\\n\"\n\n    def score(cards: str) -> int:\n        score = 0\n        for i in range(len(cards) - 1):\n            if cards[i] == \"o\" and cards[i + 1] == \"o\":\n                score += (i + 1) ** 2\n            elif cards[i] == \"x\" and cards[i + 1] == \"x\":\n                score -= (i + 1) ** 2\n            elif cards[i] == \"o\" and cards[i + 1] == \"x\":\n                score += (i + 1) ** 2\n            elif cards[i] == \"x\" and cards[i + 1] == \"o\":\n                score -= (i + 1) ** 2\n        return score\n\n    def arrange_cards(cards: str) -> str:\n        result = []\n        for i in range(len(cards)):\n            if cards[i] == \"o\":\n                result.append(\"o\")\n            elif cards[i] == \"x\":\n                result.append(\"x\")\n        return \"\".join(result)\n\n    def max_score(cards: str) -> int:\n        return max(score(arrange_cards(cards)), score(arrange_cards(cards[::-1])))\n\n    max_score_str = str(max_score(\"ooxoooxxo\"))\n    if max_score_str == \"0\":\n        return \"0\\n\"\n    return f\"{max_score_str}\\n{arrange_cards(max_score_str)}\"\n"
    },
    {
        "number": 3944,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_patterns(cards: list) -> int:\n        patterns = set()\n        for i in range(len(cards)):\n            for j in range(i + 1, len(cards)):\n                for k in range(j + 1, len(cards)):\n                    if cards[i] == cards[j] == cards[k]:\n                        patterns.add(cards[i])\n        return len(patterns)\n\n    alice_deck = [chr(ord('a') + i) for i in range(N)]\n    bob_deck = [chr(ord('a') + i) for i in range(N, N + M)]\n    charlie_deck = [chr(ord('a') + i) for i in range(N + M, N + M + K)]\n\n    alice_win_count = 0\n    bob_win_count = 0\n    charlie_win_count = 0\n\n    for i in range(1, 1 << (N + M + K)):\n        alice_deck_copy = alice_deck.copy()\n        bob_deck_copy = bob_deck.copy()\n        charlie_deck_copy = charlie_deck.copy()\n\n        for j in range(N):\n            if i & (1 << j):\n                alice_deck_copy.remove(alice_deck[j])\n                bob_deck_copy.remove(bob_deck[j])\n                charlie_deck_copy.remove(charlie_deck[j])\n\n        alice_win_count += count_patterns(alice_deck_copy)\n        bob_win_count += count_patterns(bob_deck_copy)\n        charlie_win_count += count_patterns(charlie_deck_copy)\n\n    alice_win_count %= MOD\n    bob_win_count %= MOD\n    charlie_win_count %= MOD\n\n    return str((alice_win_count + bob_win_count + charlie_win_count) % MOD)"
    },
    {
        "number": 3945,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def compare(a: int, b: int) -> str:\n        if a == b:\n            return \"equal\"\n        elif a < b:\n            return \"smaller\"\n        else:\n            return \"greater\"\n\n    def assign_height(a: int, b: int) -> int:\n        if a == b:\n            return a\n        elif a < b:\n            return b - 1\n        else:\n            return a + 1\n\n    def max_height(a: int, b: int) -> int:\n        return max(a, b)\n\n    def min_height(a: int, b: int) -> int:\n        return min(a, b)\n\n    def assign_skyscrapers(a: int, b: int) -> int:\n        max_height_a = max_height(a, b)\n        min_height_a = min_height(a, b)\n        max_height_b = max_height(b, a)\n        min_height_b = min_height(b, a)\n\n        if max_height_a == min_height_a:\n            return max_height_a\n        elif max_height_a == min_height_b:\n            return max_height_a\n        elif max_height_b == min_height_a:\n            return max_height_b\n        else:\n            return max_height_a\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = assign_skyscrapers(a[i][j], a[i][j + 1])\n            a[i][j] = assign_skyscrapers(a[i][j], a[i + 1][j])\n            a[i][j] = assign_skyscrapers(a[i][j], a[i + 1][j + 1])\n\n    for i in range(n):\n        for j in range(m):\n            print(a[i][j], end=\" \")\n        print()\n\n    return \"\"\n"
    },
    {
        "number": 3946,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    likes = list(map(int, stdin.split()))\n    weights = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(likes, weights):\n        total_weight = sum(weights)\n        p = [w / total_weight for w in weights]\n        q = [0] * len(p)\n        for i in range(len(p)):\n            q[i] = lcm(p[i], m)\n\n        r = [0] * len(p)\n        for i in range(len(p)):\n            for j in range(i + 1, len(p)):\n                if gcd(p[i], p[j]) == 1:\n                    r[i] = (q[i] * p[j]) % m\n                    r[j] = (q[j] * p[i]) % m\n                    break\n\n        return r\n\n    result = solve(likes, weights)\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3947,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    \n    max_points = 0\n    for i in range(n):\n        if i == 0 or i == n-1:\n            max_points += arr[i]\n        else:\n            max_points += min(arr[i], arr[i-1])\n    \n    return str(max_points)"
    },
    {
        "number": 3948,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    adj = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[1:].split('\\n')):\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(v, visited, parent):\n        visited[v] = True\n        for neighbor in adj[v]:\n            if neighbor!= parent and not visited[neighbor]:\n                dfs(neighbor, visited, v)\n\n    def is_multihedgehog(v, visited, parent, k):\n        visited[v] = True\n        for neighbor in adj[v]:\n            if neighbor!= parent and not visited[neighbor]:\n                if is_multihedgehog(neighbor, visited, v, k):\n                    return True\n        return False\n\n    visited = [False] * (n + 1)\n    for v in range(1, n + 1):\n        if not visited[v]:\n            dfs(v, visited, 0)\n            if is_multihedgehog(v, visited, 0, k):\n                return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 3949,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    north_magnets = []\n    south_magnets = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                north_magnets.append((i, j))\n            elif grid[i][j] == '.':\n                south_magnets.append((i, j))\n\n    if not north_magnets or not south_magnets:\n        return -1\n\n    north_magnets.sort(key=lambda x: (x[0], x[1]))\n    south_magnets.sort(key=lambda x: (x[0], x[1]))\n\n    north_magnet_count = 0\n    south_magnet_count = 0\n\n    for north_magnet in north_magnets:\n        south_magnet = south_magnets.pop(0)\n\n        if north_magnet[0] == south_magnet[0]:\n            if north_magnet[1] < south_magnet[1]:\n                north_magnet_count += 1\n        elif north_magnet[1] == south_magnet[1]:\n            if north_magnet[0] < south_magnet[0]:\n                north_magnet_count += 1\n\n    if south_magnets:\n        return -1\n\n    return str(north_magnet_count)"
    },
    {
        "number": 3950,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def restore(a: list) -> str:\n        return \" \".join(map(str, a))\n\n    def check(a: list) -> bool:\n        for i in range(1, q + 1):\n            if a[i - 1]!= i:\n                return False\n        return True\n\n    def find_array(a: list) -> str:\n        for i in range(1, q + 1):\n            a[i - 1] = i\n        return restore(a)\n\n    def find_arrays(a: list) -> list:\n        result = []\n        for i in range(1, q + 1):\n            a[i - 1] = 0\n            result.append(restore(a))\n            a[i - 1] = i\n        return result\n\n    if check(a):\n        print(\"YES\")\n        print(restore(a))\n    else:\n        print(\"NO\")\n\n    arrays = find_arrays(a)\n    if len(arrays) == 1:\n        print(restore(arrays[0]))\n    else:\n        print(\"Multiple arrays are possible.\")\n        for array in arrays:\n            print(restore(array))"
    },
    {
        "number": 3951,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    result = []\n    for i in range(n):\n        result.append(a[i])\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3952,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort()\n    l, r, a = points[0][0], points[-1][0], points[0][1]\n    count = 0\n    for i in range(1, n):\n        if points[i][0] < r and points[i][1] > a:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3953,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    def is_evil(row: int, col: int) -> bool:\n        return grid[row - 1][col - 1] == 'E'\n\n    def is_purified(row: int, col: int) -> bool:\n        return grid[row - 1][col - 1] == '.'\n\n    def purify(row: int, col: int) -> None:\n        grid[row - 1][col - 1] = '.'\n\n    def cast_spell(row: int, col: int) -> None:\n        if not is_purified(row, col):\n            purify(row, col)\n            for i in range(1, n + 1):\n                if i!= row and i!= col:\n                    cast_spell(i, col)\n\n    def min_spells(row: int, col: int) -> int:\n        min_spells = float('inf')\n        for i in range(1, n + 1):\n            if i!= row and i!= col:\n                min_spells = min(min_spells, min_spells(i, col))\n        return min_spells\n\n    def find_min_spells() -> None:\n        for row in range(1, n + 1):\n            for col in range(1, n + 1):\n                if is_evil(row, col):\n                    cast_spell(row, col)\n                    min_spells = min_spells(row, col)\n                    if min_spells == float('inf'):\n                        print(-1)\n                        return\n                    for spell in range(min_spells):\n                        cast_spell(row, col)\n\n    find_min_spells()\n    return ''\n"
    },
    {
        "number": 3954,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(a, l, r):\n        return sum(a[i] for i in range(l, r + 1))\n\n    def m(a):\n        return max(f(a, l, r) for l in range(1, n + 1) for r in range(l, n + 1))\n\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    def max_m(a, k):\n        for _ in range(k):\n            max_m_ = max(m(a) for i in range(n))\n            for i in range(n):\n                if m(a) == max_m_:\n                    swap(a, i, random.randint(0, i))\n        return m(a)\n\n    return str(max_m(a, k))\n"
    },
    {
        "number": 3955,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    max_or = 0\n    for i in range(n):\n        if i == 0:\n            max_or = a[i]\n        else:\n            max_or = max(max_or, a[i] | a[i-1])\n        if i >= k:\n            max_or = max(max_or, a[i] | a[i-k])\n    return str(max_or)"
    },
    {
        "number": 3956,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_combinations(i: int) -> int:\n        def helper(k: int, count: int) -> int:\n            if k == 0:\n                return count\n            if k == 1:\n                return helper(K - 1, count + 1)\n            return helper(k - 1, helper(k - 1, count) + helper(k - 2, count))\n\n        return helper(K, 0) * (i - 1) % MOD\n\n    for i in range(2, 2 * K + 1):\n        print(count_combinations(i))"
    },
    {
        "number": 3957,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    u_indices = list(map(int, stdin.split()))\n    u_indices.sort()\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 == 0]\n    u_indices = [u_indices[i] for i in range(len(u_indices)) if i % 2 =="
    },
    {
        "number": 3958,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    zebras = []\n    for i in range(n):\n        if i == 0 or s[i]!= s[i - 1]:\n            zebras.append([])\n        zebras[-1].append(i)\n\n    def is_zebra(zebra):\n        return (\n            len(zebra) >= 2\n            and zebra[0] % 2 == 0\n            and zebra[-1] % 2 == 1\n            and all(zebra[i] % 2 == zebra[i + 1] % 2 for i in range(len(zebra) - 1))\n        )\n\n    def is_valid(zebra):\n        return is_zebra(zebra) and all(s[i] == \"0\" or s[i] == \"1\" for i in zebra)\n\n    def find_subsequences(zebra):\n        subsequences = []\n        for i in range(len(zebra) - 1):\n            for j in range(i + 2, len(zebra) + 1):\n                subsequences.append(zebra[i:j])\n        return subsequences\n\n    def find_subsequence_lengths(zebra):\n        subsequences = find_subsequences(zebra)\n        return [len(subsequence) for subsequence in subsequences]\n\n    def find_subsequence_indices(zebra):\n        subsequences = find_subsequences(zebra)\n        return [zebra.index(subsequence[0]) for subsequence in subsequences]\n\n    def find_subsequence_days(subsequence_indices):\n        return [subsequence_indices.index(i) + 1 for i in range(1, len(subsequence_indices) + 1)]\n\n    def find_subsequences_with_length(length):\n        subsequences = []\n        for i in range(len(zebras) - length + 1):\n            subsequences.append(zebras[i : i + length])\n        return subsequences\n\n    def find_subsequences_with_length_and_indices(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence) for subsequence in subsequences]\n\n    def find_subsequences_with_length_and_days(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_days(subsequence) for subsequence in subsequences]\n\n    def find_subsequences_with_length_and_indices_and_days(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_days(subsequence)]\n\n    def find_subsequences_with_length_and_indices_and_days_with_length(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_days(subsequence), length]\n\n    def find_subsequences_with_length_and_indices_and_days_with_length_and_indices(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_days(subsequence), length, find_subsequence_indices(subsequence)]\n\n    def find_subsequences_with_length_and_indices_and_days_with_length_and_indices_and_days(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_days(subsequence), length, find_subsequence_indices(subsequence), find_subsequence_days(subsequence)]\n\n    def find_subsequences_with_length_and_indices_and_days_with_length_and_indices_and_days_with_length(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_days(subsequence), length, find_subsequence_indices(subsequence), find_subsequence_days(subsequence), length]\n\n    def find_subsequences_with_length_and_indices_and_days_with_length_and_indices_and_days_with_length_and_indices(length):\n        subsequences = find_subsequences_with_length(length)\n        return [find_subsequence_indices(subsequence), find_subsequence_"
    },
    {
        "number": 3959,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    gyms = []\n    for _ in range(n):\n        g = list(map(int, stdin.split()))\n        gyms.append(g)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid_plan(plan):\n        for i in range(1, m):\n            if plan[i] == plan[i - 1]:\n                return False\n        return True\n\n    def count_valid_plans(gyms):\n        valid_plans = set()\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        valid_plans.add(tuple(plan))\n        return len(valid_plans)\n\n    def count_evolution_plans(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        count += 1\n        return count\n\n    def count_evolution_plans_with_same_type(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        if plan[i] == plan[j - 1]:\n                            count += 1\n        return count\n\n    def count_evolution_plans_with_different_type(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        if plan[i]!= plan[j - 1]:\n                            count += 1\n        return count\n\n    def count_evolution_plans_with_same_type_and_different_type(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        if plan[i] == plan[j - 1] and plan[i]!= plan[j]:\n                            count += 1\n        return count\n\n    def count_evolution_plans_with_same_type_and_different_type_after_evolving(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        if plan[i] == plan[j - 1] and plan[i]!= plan[j]:\n                            count += 1\n        return count\n\n    def count_evolution_plans_with_same_type_and_different_type_before_evolving(gyms):\n        count = 0\n        for i in range(m):\n            for j in range(i + 1, m):\n                for plan in itertools.permutations(range(1, m + 1)):\n                    if plan[i] == plan[j]:\n                        continue\n                    if plan[i] in gyms[i] and plan[j] in gyms[j]:\n                        if plan[i]!= plan[j - 1]:\n                            count += 1\n        return count\n\n    def count_evolution_plans_with_same_type_and_different_type_before_and_after_evol"
    },
    {
        "number": 3960,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def f(l, r):\n        return sum(abs(a[i] - a[i + 1]) * (-1) ** (i - l) for i in range(l, r - 1))\n\n    max_f = max(f(l, r) for l in range(1, n + 1) for r in range(l, n + 1))\n    print(max_f)\n\n    return \"\"\n"
    },
    {
        "number": 3961,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = [p[i - 1] for i in range(1, n + 1)]\n    visited = [False] * (n + 1)\n    visited[1] = True\n    count = 0\n\n    def dfs(room: int) -> None:\n        nonlocal count\n        if room == n:\n            count += 1\n            return\n        if not visited[room]:\n            visited[room] = True\n            dfs(room + 1)\n            visited[room] = False\n            dfs(p[room - 1])\n\n    dfs(1)\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3962,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    l = [int(x.split()[0]) for x in stdin.split()[1:]]\n    r = [int(x.split()[1]) for x in stdin.split()[1:]]\n\n    def min_chairs(l, r):\n        return max(l, r) * 2\n\n    def min_chairs_helper(l, r, chairs, used_chairs):\n        if not l and not r:\n            return min(used_chairs, chairs)\n\n        if not l:\n            return min_chairs_helper(r, r, chairs + r, used_chairs)\n\n        if not r:\n            return min_chairs_helper(l, l, chairs + l, used_chairs)\n\n        return min(min_chairs_helper(l - 1, r, chairs, used_chairs),\n                   min_chairs_helper(l, r - 1, chairs, used_chairs),\n                   min_chairs_helper(l - 1, r - 1, chairs + 1, used_chairs))\n\n    return str(min_chairs_helper(n, n, 0, 0))"
    },
    {
        "number": 3963,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, m = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n    a = [1] + a\n    b = [1] + b\n\n    MOD = 10**9 + 7\n\n    def dp(i, j):\n        if i == j:\n            return 1\n        if i > j:\n            return 0\n\n        if dp(i + 1, j) == 0:\n            return dp(i, j - 1)\n\n        if dp(i, j - 1) == 0:\n            return dp(i + 1, j)\n\n        for k in range(i, j):\n            if b[k] > m:\n                continue\n            if a[k] * b[k] == a[k + 1] * b[k + 1]:\n                return (dp(i, k) + dp(k + 1, j)) % MOD\n\n        return 0\n\n    return str(dp(0, n - 1))"
    },
    {
        "number": 3964,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b, mod = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_good_plans(plan):\n        count = 0\n        for i in range(n):\n            count += plan[i] // a[i]\n        return count\n\n    good_plans = set()\n    for i in range(1, m + 1):\n        plan = [0] * n\n        for j in range(n):\n            plan[j] = i // a[j]\n            i %= a[j]\n        good_plans.add(tuple(plan))\n\n    return str((len(good_plans) % mod) % mod)"
    },
    {
        "number": 3965,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    syllables = set()\n    for line in stdin.split('\\n')[1:]:\n        words = line.split()\n        for word in words:\n            syllables.update(divide_word(word))\n    return 'YES' if len(syllables) == sum(p) else 'NO'\n\ndef"
    },
    {
        "number": 3966,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    score = 0\n    for i in range(n):\n        score += a[i]\n        if i % 2 == 0:\n            score += a[i]\n            a[i] = 0\n    return str(max(score, 0))"
    },
    {
        "number": 3967,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    d = 1\n    max_d = 0\n    while d <= n:\n        cut_parts = 0\n        for i in range(n):\n            if a[i] <= k:\n                cut_parts += 1\n                if cut_parts == d:\n                    max_d = d\n                    break\n        d += 1\n    return str(max_d)"
    },
    {
        "number": 3968,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, c = map(int, stdin.split())\n    infected = list(map(int, stdin.split()[1:c+1]))\n    s = list(map(int, stdin.split()[c+1:2*c+1]))\n    t = list(map(int, stdin.split()[2*c+1:]))\n\n    infected_set = set(infected)\n    infected_set.add(1)\n\n    infected_indices = []\n    for i in range(1, n+1):\n        if i in infected_set:\n            infected_indices.append(i)\n\n    infected_indices.sort()\n\n    for i in range(d):\n        infected_set = set(infected_indices)\n        for j in range(len(infected_indices)):\n            for k in range(j+1, len(infected_indices)):\n                if s[infected_indices[j]] <= t[infected_indices[k]] <= t[infected_indices[j]]:\n                    infected_set.add(infected_indices[k])\n\n        infected_indices = list(infected_set)\n        infected_indices.sort()\n\n    return''.join(map(str, infected_indices))"
    },
    {
        "number": 3969,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    plants = []\n    for i in range(n):\n        s, x = map(int, stdin.split()[i+1].split())\n        plants.append((s, x))\n\n    plants.sort(key=lambda x: x[1])\n\n    min_replants = 0\n    for i in range(1, m):\n        if plants[i][0] == plants[i-1][0]:\n            min_replants += 1\n        else:\n            break\n\n    return str(min_replants)"
    },
    {
        "number": 3970,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_k_multiple_free(x: int) -> bool:\n        for i in range(n):\n            if a[i] % k == 0:\n                if a[i] // k == x // k:\n                    return False\n        return True\n\n    max_size = 0\n    max_subset = []\n\n    for x in range(1, k + 1):\n        if is_k_multiple_free(x):\n            size = 1\n            for i in range(n):\n                if a[i] % k == 0:\n                    if a[i] // k == x // k:\n                        size += 1\n            if size > max_size:\n                max_size = size\n                max_subset = [x]\n            elif size == max_size:\n                max_subset.append(x)\n\n    return str(max_size)"
    },
    {
        "number": 3971,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_points = 0\n    for i in range(n):\n        if a[i] == a[i + 1] + 1 or a[i] == a[i - 1] - 1:\n            max_points += a[i]\n\n    return str(max_points)"
    },
    {
        "number": 3972,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(1, n + 1):\n        sequence = [1] * i\n        for j in range(i):\n            sequence[j] = sequence[j] * i\n        count += 1\n        for j in range(i, n + 1):\n            sequence[j] = sequence[j] * (i - j)\n            sequence[j] %= MOD\n        count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 3973,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    favorite_brightness = a[0]\n    forward_pressed = False\n    favorite_pressed = False\n\n    for i in range(1, n):\n        if a[i] == favorite_brightness:\n            favorite_pressed = True\n        elif a[i] == favorite_brightness + 1:\n            favorite_brightness += 1\n            favorite_pressed = True\n        elif a[i] == favorite_brightness + 2:\n            favorite_brightness += 1\n            forward_pressed = True\n        elif a[i] == favorite_brightness + 3:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n        elif a[i] == favorite_brightness + 4:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n        elif a[i] == favorite_brightness + 5:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n        elif a[i] == favorite_brightness + 6:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n        elif a[i] == favorite_brightness + 7:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n        elif a[i] == favorite_brightness + 8:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n        elif a[i] == favorite_brightness + 9:\n            favorite_brightness += 1\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n            forward_pressed = True\n            favorite_pressed = True\n\n    if forward_pressed:\n        favorite_brightness += 1\n    if favorite_pressed:\n        favorite_brightness = favorite_brightness + 1\n\n    return str(favorite_brightness)"
    },
    {
        "number": 3974,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for char in stdin:\n        if char == '+':\n            count += 1\n        elif char == '-':\n            count -= 1\n    return str(count)"
    },
    {
        "number": 3975,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n):\n        line = stdin.split()\n        vertex_type = line[0]\n        if vertex_type == \"IN\":\n            value = int(line[1])\n            graph[1].append(value)\n        else:\n            inputs = line[1:]\n            for input in inputs:\n                if input.isdigit():\n                    graph[int(input)].append(vertex_type)\n                else:\n                    graph[int(input)].append(vertex_type[0])\n\n    def dfs(vertex, visited):\n        visited[vertex] = True\n        for child in graph[vertex]:\n            if not visited[child]:\n                dfs(child, visited)\n\n    visited = [False] * (n + 1)\n    dfs(1, visited)\n\n    result = []\n    for i in range(1, n + 1):\n        if visited[i]:\n            result.append(graph[i])\n\n    return \"\".join(result)"
    },
    {
        "number": 3976,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = a[p - 1:] + a[:p - 1]\n    q = 0\n    while q + (m - 1) * p <= n:\n        if b == a[q:q + m]:\n            return str(q + 1)\n        q += 1\n    return \"0\""
    },
    {
        "number": 3977,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def is_stable(graph: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] > 0 or graph[j][i] > 0:\n                    return False\n        return True\n\n    def bellman_ford(graph: List[List[int]]) -> int:\n        dist = [float('inf')] * n\n        dist[0] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v in range(n):\n                    if graph[u][v] > 0 and dist[u]!= float('inf') and dist[u] + graph[u][v] < dist[v]:\n                        dist[v] = dist[u] + graph[u][v]\n        return dist[n - 1]\n\n    def max_edges(graph: List[List[int]]) -> int:\n        dist = bellman_ford(graph)\n        max_dist = max(dist)\n        return sum(1 for d in dist if d == max_dist)\n\n    graph = [[0] * n for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1][v - 1] = 1\n        graph[v - 1][u - 1] = 1\n\n    if not is_stable(graph):\n        return \"0\"\n\n    return str(max_edges(graph))"
    },
    {
        "number": 3978,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    colors = set()\n    min_elements = {}\n\n    for num in a:\n        if num not in min_elements or num % min_elements[num] == 0:\n            colors.add(num)\n            min_elements[num] = num\n        else:\n            colors.add(num % min_elements[num])\n\n    return str(len(colors))"
    },
    {
        "number": 3979,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words = []\n    for _ in range(n):\n        word = list(map(int, stdin.split()))\n        words.append(word)\n\n    def is_lexicographically_greater(word1, word2):\n        for i in range(min(len(word1), len(word2))):\n            if word1[i]!= word2[i]:\n                return word1[i] < word2[i]\n        return len(word1) < len(word2)\n\n    def is_possible(words):\n        for i in range(len(words) - 1):\n            for j in range(i + 1, len(words)):\n                if is_lexicographically_greater(words[i], words[j]):\n                    return False\n        return True\n\n    def find_capitalization(words):\n        for i in range(m):\n            if all(word[i] == i + 1 for word in words):\n                return i + 1\n        return 0\n\n    capitalization = find_capitalization(words)\n    if is_possible(words):\n        print(\"Yes\")\n        print(capitalization)\n        print(*sorted(set(range(1, m + 1))), sep=\"\\n\")\n    else:\n        print(\"No\")"
    },
    {
        "number": 3980,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_beauty = 0\n    max_permutation = []\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            for k in range(j):\n                for l in range(k):\n                    beauty = (0 ^ i) + (1 ^ j) + (2 ^ k) + (3 ^ l)\n                    if beauty > max_beauty:\n                        max_beauty = beauty\n                        max_permutation = [i, j, k, l]\n\n    return str(max_beauty) +'' +''.join(map(str, max_permutation))"
    },
    {
        "number": 3981,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    engines = [[] for _ in range(2)]\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        engines[0].append((x, y))\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        engines[1].append((x, y))\n\n    def rotate(x, y, theta):\n        return x * math.cos(theta) - y * math.sin(theta), x * math.sin(theta) + y * math.cos(theta)\n\n    def shift(x, y, a, b):\n        return x + a, y + b\n\n    def combine(engine1, engine2):\n        result = []\n        for point in engine1:\n            result.append(shift(*point, *engine2[0]))\n        for point in engine2:\n            result.append(shift(*point, *engine1[0]))\n        return result\n\n    def is_safe(engine1, engine2):\n        power_field1 = set(combine(engine1, engine2))\n        power_field2 = set(combine(engine2, engine1))\n        return power_field1 == power_field2\n\n    for engine in engines:\n        engine.sort(key=lambda x: (x[0], x[1]))\n\n    for engine in engines:\n        engine.sort(key=lambda x: (x[0], x[1]))\n        for i in range(len(engine)):\n            for j in range(i + 1, len(engine)):\n                if is_safe(engine[:i], engine[i:j]) or is_safe(engine[:j], engine[j:]):\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 3982,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split()[0])\n    morse_code = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'\n    }\n    mod = 10**9 + 7\n    count = 0\n    for i in range(m):\n        s = stdin.split()[i+1]\n        if s == '0':\n            s = '0000'\n        elif s == '1':\n            s = '1111'\n        else:\n            s = ''.join(morse_code[c] for c in s)\n        count += len(s)\n        count %= mod\n    return str(count)"
    },
    {
        "number": 3983,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for i in range(test_cases):\n        n, m = map(int, stdin.split('\\n')[i+1].split())\n        graph = [[] for _ in range(n+1)]\n        for _ in range(m):\n            a, b = map(int, stdin.split('\\n')[i+1].split())\n            graph[a].append(b)\n            graph[b].append(a)\n        for i in range(1, n+1):\n            if i in graph[1:]:\n                return 'First'\n        return 'Second'\n\nwith open('input.txt', 'r') as file:\n    stdin = file.read()\n\nprint(solution(stdin))"
    },
    {
        "number": 3984,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for k in range(n):\n        if s[k] == s[n - k - 1]:\n            print(\"Mike\")\n            return \"Mike\"\n        else:\n            print(\"Ann\")\n            return \"Ann\""
    },
    {
        "number": 3985,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    pairs = []\n    for i in range(m):\n        pair = list(map(int, stdin.split()))\n        pairs.append(pair)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def divide(a, b):\n        return a * b // gcd(a, b)\n\n    def max_operations(a, pairs):\n        max_operations = 0\n        for pair in pairs:\n            i, j = pair\n            if i + j % 2 == 1 and 1 <= i < j <= n:\n                max_operations += 1\n                a[i] = divide(a[i], pair[2])\n                a[j] = divide(a[j], pair[2])\n        return max_operations\n\n    return str(max_operations(a, pairs))\n"
    },
    {
        "number": 3986,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    distinct_letters = set()\n    for _ in range(k):\n        distinct_letters.add(input())\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distinct_letters.issubset(set(input())):\n                return ''.join(sorted(input()))\n    return \"-1\""
    },
    {
        "number": 3987,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def longest_non_decreasing_subsequence(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    return str(longest_non_decreasing_subsequence(a))"
    },
    {
        "number": 3988,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        t, u, v = map(int, stdin.split())\n        edges.append((t, u, v))\n\n    def dfs(u, visited, plan):\n        visited[u] = True\n        plan.append(u)\n        for v, t, w in edges:\n            if t == 1 and not visited[v]:\n                dfs(v, visited, plan)\n            elif t == 2 and not visited[v] and not visited[w]:\n                dfs(v, visited, plan)\n                dfs(w, visited, plan)\n\n    visited = [False] * (n + 1)\n    dfs(s, visited, [])\n\n    max_reachable = len(visited)\n    min_reachable = max_reachable\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            max_reachable = min(max_reachable, dfs(i, visited[:], []))\n            min_reachable = min(min_reachable, dfs(i, visited[:], []))\n\n    if max_reachable == min_reachable:\n        return str(max_reachable)\n\n    max_plan = []\n    min_plan = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, visited[:], max_plan):\n                max_plan.append('+')\n            else:\n                max_plan.append('-')\n            if dfs(i, visited[:], min_plan):\n                min_plan.append('+')\n            else:\n                min_plan.append('-')\n\n    return str(max_reachable) + '\\n' + ''.join(max_plan) + '\\n' + str(min_reachable) + '\\n' + ''.join(min_plan)\n"
    },
    {
        "number": 3989,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    digits = [int(digit) for digit in str(a)]\n    digits.sort()\n    result = []\n    for digit in digits:\n        result.append(digit)\n    result.reverse()\n    result_str = ''.join(map(str, result))\n    if int(result_str) % 7 == 0:\n        return result_str\n    else:\n        return '0'"
    },
    {
        "number": 3990,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    railways = set()\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        railways.add((u, v))\n        railways.add((v, u))\n\n    def is_valid(route: list[int]) -> bool:\n        for i in range(len(route) - 1):\n            if (route[i], route[i + 1]) in railways or (route[i + 1], route[i]) in railways:\n                return False\n        return True\n\n    def min_time(route: list[int]) -> int:\n        time = 0\n        for i in range(len(route) - 1):\n            time += 1\n        return time\n\n    def min_time_for_railway(railway: tuple[int, int]) -> int:\n        return min_time([railway[0], railway[1]])\n\n    def min_time_for_route(route: list[int]) -> int:\n        return min(min_time_for_railway(railway) for railway in railways if railway[0] in route and railway[1] in route)\n\n    def min_time_for_town(town: int) -> int:\n        return min(min_time_for_route(route) for route in railways if town in route)\n\n    def min_time_for_all_towns() -> int:\n        return min(min_time_for_town(town) for town in range(1, n + 1))\n\n    return str(min_time_for_all_towns())"
    },
    {
        "number": 3991,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n\n    def distance(a, b):\n        return abs(a - b)\n\n    def f(a):\n        return max(distance(x[i], x[j]) for i in a for j in a if i!= j)\n\n    def sum_f(a):\n        return sum(f(a))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(a):\n        if len(a) == 1:\n            return f(a)\n        else:\n            b = a[1:]\n            c = [x for x in a[1:] if x not in b]\n            return lcm(f(a), solve(b))\n\n    result = solve(range(1, n + 1))\n    return str(result % MOD)\n"
    },
    {
        "number": 3992,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_divisible(a, k):\n        return a % k == 0\n\n    def find_k(a):\n        for k in range(1, 100001):\n            if is_divisible(sum(a), k):\n                return k\n\n    def find_moves(a, k):\n        moves = []\n        for i in range(n):\n            if a[i] > 0:\n                for j in range(i - 1, -1, -1):\n                    if a[j] > 0 and is_divisible(a[j] + a[i], k):\n                        moves.append((i, j))\n                for j in range(i + 1, n):\n                    if a[j] > 0 and is_divisible(a[j] + a[i], k):\n                        moves.append((i, j))\n        return moves\n\n    def min_moves(a, k):\n        moves = find_moves(a, k)\n        moves.sort(key=lambda x: (a[x[0]] + a[x[1]], -x[0], -x[1]))\n        return moves\n\n    k = find_k(a)\n    if k is None:\n        return \"-1\"\n\n    moves = min_moves(a, k)\n    if not moves:\n        return \"-1\"\n\n    return str(moves[0][0] + moves[0][1] + 1)\n"
    },
    {
        "number": 3993,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    p.sort()\n    special_pages = []\n    for i in range(len(p)):\n        if p[i] - 1 not in special_pages:\n            special_pages.append(p[i] - 1)\n    special_pages.sort()\n    operations = 0\n    for i in range(len(special_pages)):\n        if i == 0:\n            operations += len(special_pages[i])\n        else:\n            operations += len(special_pages[i]) - len(special_pages[i - 1])\n    return str(operations)"
    },
    {
        "number": 3994,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    lights = [int(x) for x in s]\n    a, b = map(int, stdin.split()[2:n+2])\n    max_on = 0\n    for i in range(n):\n        if lights[i] == 1:\n            max_on += 1\n        for j in range(b, b + a, a):\n            if lights[i] == 0:\n                max_on += 1\n    return str(max_on)"
    },
    {
        "number": 3995,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = \"0\" * n\n    for i in range(n):\n        s = s.replace(\"0\", \"1\", n - i)\n        s = s.replace(\"1\", \"0\", n - i)\n    return s[:k]"
    },
    {
        "number": 3996,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *a = map(int, stdin.split())\n    n = 1\n    for i in a:\n        n *= i\n    p = 1\n    q = 1\n    for i in range(1, n + 1):\n        p *= i\n        q *= n // i\n    return f\"{p % (10**9 + 7)}/{q % (10**9 + 7)}\""
    },
    {
        "number": 3997,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    edges = []\n    for i in range(n - 1):\n        p, w = map(int, stdin.split())\n        edges.append((p - 1, w))\n\n    def dfs(u, parent):\n        nonlocal count\n        count[u] = 1\n        for v, w in edges:\n            if v == parent:\n                continue\n            if w <= a[v]:\n                dfs(v, u)\n                count[u] += count[v]\n\n    count = [0] * n\n    dfs(0, -1)\n    return \" \".join(map(str, count))\n"
    },
    {
        "number": 3998,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *ratings = map(int, stdin.split())\n    ratings.sort()\n    max_rating = ratings[-1]\n    min_rating = ratings[0]\n    t = 0\n    while max_rating - min_rating > 1:\n        t += 1\n        max_rating = (max_rating + min_rating) // 2\n        min_rating = (max_rating + min_rating) // 2\n    return str(t)"
    },
    {
        "number": 3999,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tiles = []\n    for i in range(1, n + 1):\n        row = list(map(int, stdin.split()[i].split()))\n        tiles.append(row)\n\n    def is_valid(tile):\n        for j in range(4):\n            if tile[j]!= 0 and tile[j]!= tile[j + 4] and tile[j]!= tile[j + 8]:\n                return False\n        return True\n\n    def is_same_color(tile1, tile2):\n        return all(tile1[j] == tile2[j] for j in range(4))\n\n    def is_same_tile(tile1, tile2):\n        return all(tile1[j] == tile2[j] for j in range(4))\n\n    def is_same_direction(tile1, tile2):\n        return all(tile1[j] == tile2[j] for j in range(4) if j % 4 == 0)\n\n    def is_valid_tile(tile):\n        return is_valid(tile) and is_same_color(tile, tiles[tile[0] - 1])\n\n    def is_valid_cube(cube):\n        return all(is_valid_tile(tile) for tile in cube)\n\n    def is_valid_rotation(cube1, cube2):\n        return all(is_same_tile(cube1[i], cube2[j]) for i in range(4) for j in range(4) if i!= j)\n\n    def count_cubes(tiles):\n        cubes = []\n        for i in range(1, n + 1):\n            for j in range(4):\n                for k in range(4):\n                    for l in range(4):\n                        if tiles[i - 1][j] == 0:\n                            continue\n                        tile = [tiles[i - 1][j], tiles[i - 1][j + 4], tiles[i - 1][j + 8], tiles[i - 1][j + 12]]\n                        if is_valid_tile(tile):\n                            cubes.append(tile)\n        return len(cubes)\n\n    return str(count_cubes(tiles))\n"
    }
]